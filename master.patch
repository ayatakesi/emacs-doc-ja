diff --git a/lispref/commands.texi.po b/lispref/commands.texi.po
index d704452..f4ac2cd 100644
--- a/lispref/commands.texi.po
+++ b/lispref/commands.texi.po
@@ -348,7 +348,7 @@ msgstr "@code{interactive-only} property"
 #. type: Plain text
 #: original_texis/commands.texi:138
 msgid "Sometimes, a function is only intended to be called interactively, never directly from Lisp.  In that case, give the function a non-@code{nil} @code{interactive-only} property, either directly or via @code{declare} (@pxref{Declare Form}).  This causes the byte compiler to warn if the command is called from Lisp.  The output of @code{describe-function} will include similar information.  The value of the property can be: a string, which the byte-compiler will use directly in its warning (it should end with a period, and not start with a capital, e.g., @code{\"use (system-name) instead.\"}); @code{t}; any other symbol, which should be an alternative function to use in Lisp code."
-msgstr "インタラクティブに呼び出されることだけを意図していて、決してLispから直接呼び出されない関数が時折あります。この場合には、直接あるいは@code{declare} (@ref{Declare Form}を参照)を通じて、その関数の@code{interactive-only}プロパティに非@code{nil}を与えます。これにより、そのコマンドがLispから呼び出されるとバイトコンパイラーが警告を発します。@code{describe-function}の出力にはこれに類似する情報が含まれます。このプロパティの値には文字列、@code{t}、または任意のシンボルを指定できます。文字列なら、それはバイトコンパイラーによる警告内で直接使用されます(最初は大文字でなくピリオドで終端される文字列であること。たとえば@code{\\\"use (system-name) instead.\\\"})。シンボルなら、それはLispコード内で使用されるかわりの関数です。"
+msgstr "インタラクティブに呼び出されることだけを意図していて、決してLispから直接呼び出されない関数が時折あります。この場合には、直接あるいは@code{declare} (@ref{Declare Form}を参照)を通じて、その関数の@code{interactive-only}プロパティに非@code{nil}を与えます。これにより、そのコマンドがLispから呼び出されるとバイトコンパイラーが警告を発します。@code{describe-function}の出力にはこれに類似する情報が含まれます。このプロパティの値には文字列、@code{t}、または任意のシンボルを指定できます。文字列なら、それはバイトコンパイラーによる警告内で直接使用されます(最初は大文字でなくピリオドで終端される文字列であること。たとえば@code{\"use (system-name) instead.\"})。シンボルなら、それはLispコード内で使用されるかわりの関数です。"
 
 #. type: Plain text
 #: original_texis/commands.texi:141
@@ -6431,7 +6431,7 @@ msgstr "この関数は、(ユーザーからの保留中入力がければ)再
 #. type: defun
 #: original_texis/commands.texi:3621
 msgid "The argument @var{seconds} need not be an integer.  If it is floating point, @code{sit-for} waits for a fractional number of seconds.  Some systems support only a whole number of seconds; on these systems, @var{seconds} is rounded down."
-msgstr "引数@var{seconds}は整数である必要はない。浮動小数点数なら@code{sit-for}は少数点数の秒を待機する。整数の秒だけをサポートするいくつかのシステムでは@var{seconds}は切り捨てられる。"
+msgstr "引数@var{seconds}は整数である必要はない。浮動小数点数なら@code{sit-for}は小数点数の秒を待機する。整数の秒だけをサポートするいくつかのシステムでは@var{seconds}は切り捨てられる。"
 
 #. type: defun
 #: original_texis/commands.texi:3625
@@ -6467,7 +6467,7 @@ msgstr "この関数は表示を更新せず単に@var{seconds}秒の間一時
 #. type: defun
 #: original_texis/commands.texi:3648
 msgid "The argument @var{seconds} need not be an integer.  If it is floating point, @code{sleep-for} waits for a fractional number of seconds.  Some systems support only a whole number of seconds; on these systems, @var{seconds} is rounded down."
-msgstr "引数@var{seconds}は整数である必要はない。浮動小数点数なら@code{sleep-for}は少数点数の秒を待機する。整数の秒だけをサポートするいくつかのシステムでは@var{seconds}は切り捨てられる。"
+msgstr "引数@var{seconds}は整数である必要はない。浮動小数点数なら@code{sleep-for}は小数点数の秒を待機する。整数の秒だけをサポートするいくつかのシステムでは@var{seconds}は切り捨てられる。"
 
 #. type: defun
 #: original_texis/commands.texi:3653
diff --git a/lispref/control.texi.po b/lispref/control.texi.po
index f464576..7478505 100644
--- a/lispref/control.texi.po
+++ b/lispref/control.texi.po
@@ -647,7 +647,7 @@ msgstr "すべての@var{conditions}が非@code{nil}なら、それらの最後
 #. type: defspec
 #: original_texis/control.texi:375
 msgid "Here is an example.  The first condition returns the integer 1, which is not @code{nil}.  Similarly, the second condition returns the integer 2, which is not @code{nil}.  The third condition is @code{nil}, so the remaining condition is never evaluated."
-msgstr "以下に例を示す。1番目の条件は整数1をリターンし、これは@code{nil}ではまい。同様に2番目の条件は整数2をリターンし、これも@code{nil}ではない。3番目の条件は@code{nil}なので、のこりの条件が評価されることは決してない。"
+msgstr "以下に例を示す。1番目の条件は整数1をリターンし、これは@code{nil}ではない。同様に2番目の条件は整数2をリターンし、これも@code{nil}ではない。3番目の条件は@code{nil}なので、のこりの条件が評価されることは決してない。"
 
 #. type: group
 #: original_texis/control.texi:382
@@ -1876,12 +1876,12 @@ msgstr "structural matching"
 #. type: Plain text
 #: original_texis/control.texi:1135
 msgid "This subsection describes @dfn{backquote-style patterns}, a set of builtin patterns that eases structural matching.  For background, @pxref{Pattern-Matching Conditional}."
-msgstr "このサブセクションでは構造化マッチングを容易にするビルトインパターン@dfn{バッククォートスタイルパターン(backquote-style patterns)}について説明します。背景については@ref{Pattern-Matching Conditional}を参照してください。"
+msgstr "このサブセクションでは構造化マッチングを容易にするビルトインパターンである@dfn{バッククォートスタイルパターン(backquote-style patterns)}について説明します。背景については@ref{Pattern-Matching Conditional}を参照してください。"
 
 #. type: Plain text
 #: original_texis/control.texi:1139
 msgid "Backquote-style patterns are a powerful set of @code{pcase} pattern extensions (created using @code{pcase-defmacro}) that make it easy to match @var{expval} against specifications of its @emph{structure}."
-msgstr "バッククォートスタイルパターンは(@code{pcase-defmacro}を使用して作成された)強力な@code{pcase}パターン拡張であり、その@emph{構造(structure)}の仕様にたいする@var{expval}をマッチを容易にします。"
+msgstr "バッククォートスタイルパターンは(@code{pcase-defmacro}を使用して作成された)強力な@code{pcase}パターン拡張であり、その@emph{構造(structure)}の仕様にたいする@var{expval}のマッチを容易にします。"
 
 #. type: Plain text
 #: original_texis/control.texi:1143
@@ -2086,7 +2086,7 @@ msgstr ""
 #. type: Plain text
 #: original_texis/control.texi:1281
 msgid "This will not only extract @code{x} and @code{y} but will additionally test that @code{my-list} is a list containing exactly 3 elements and whose first element is the symbol @code{add}.  If any of those tests fail, @code{pcase} will immediately return @code{nil} without calling @code{message}."
-msgstr "これは@code{x}と@code{y}を抽出すだけではなく、加えて@code{my-list}が正確に3つの要素を含むリストであり、最初の要素がシンボル@code{add}かどうかをテストします。これらのテストのいずれかが失敗したら、@code{pcase}は@code{message}を呼び出さずに即座に@code{nil}をリターンします。"
+msgstr "これは@code{x}と@code{y}を抽出するだけではなく、加えて@code{my-list}が正確に3つの要素を含むリストであり、最初の要素がシンボル@code{add}かどうかをテストします。これらのテストのいずれかが失敗したら、@code{pcase}は@code{message}を呼び出さずに即座に@code{nil}をリターンします。"
 
 #. type: Plain text
 #: original_texis/control.texi:1288
@@ -2168,7 +2168,7 @@ msgstr "pcase-let* bindings body@dots{}"
 #. type: defmac
 #: original_texis/control.texi:1351
 msgid "@var{bindings} is a list of bindings of the form @code{(@var{pattern} @var{exp})}, where @var{exp} is an expression to evaluate and @var{pattern} is a @code{pcase} pattern.  The variable bindings are produced by destructuring binding of elements of @var{pattern} to the values of the corresponding elements of the evaluated @var{exp}."
-msgstr "@var{bindings}は@code{(@var{pattern} @var{exp})}という形式のバインディングのリスト。ここで@var{exp}は評価する式、@var{pattern}は@code{pcase}パターン。この変数バインディングは@var{pattern}の要素を、評価された@var{exp}の対応する要素の値に分割してのバインディングすることにより生成される。"
+msgstr "@var{bindings}は@code{(@var{pattern} @var{exp})}という形式のバインディングのリスト。ここで@var{exp}は評価する式、@var{pattern}は@code{pcase}パターン。この変数バインディングは@var{pattern}の要素を、評価された@var{exp}の対応する要素の値に分割してバインディングすることにより生成される。"
 
 #. type: defmac
 #: original_texis/control.texi:1358
@@ -2184,7 +2184,7 @@ msgstr "pcase-dolist (pattern list) body@dots{}"
 #. type: defmac
 #: original_texis/control.texi:1367
 msgid "Execute @var{body} once for each element of @var{list}, on each iteration performing a destructuring binding of variables in @var{pattern} to the values of the corresponding subfields of the element of @var{list}.  The bindings are performed as if by @code{pcase-let}.  When @var{pattern} is a simple variable, this ends up being equivalent to @code{dolist} (@pxref{Iteration})."
-msgstr "繰り返しごとに@var{pattern}の変数を@var{list}の要素の対応するサブフィールドに分割バインディングしながら、@var{list}の各要素ごとに一度@var{body}を実行するこのバインディングは@code{pcase-let}の場合のように行われる。@var{pattern}が単なる変数なら@code{dolist}と等価(@ref{Iteration}を参照)。"
+msgstr "繰り返しごとに@var{pattern}の変数を@var{list}の要素の対応するサブフィールドに分割バインディングしながら、@var{list}の各要素ごとに一度@var{body}を実行する。このバインディングは@code{pcase-let}の場合のように行われる。@var{pattern}が単なる変数なら@code{dolist}と等価(@ref{Iteration}を参照)。"
 
 #. type: defmac
 #: original_texis/control.texi:1369
@@ -2665,7 +2665,7 @@ msgstr "@code{throw}フォームが実行されると、対応する@code{catch}
 #. type: Plain text
 #: original_texis/control.texi:1654
 msgid "The function @code{throw} finds the matching @code{catch} based on the first argument: it searches for a @code{catch} whose first argument is @code{eq} to the one specified in the @code{throw}.  If there is more than one applicable @code{catch}, the innermost one takes precedence.  Thus, in the above example, the @code{throw} specifies @code{foo}, and the @code{catch} in @code{foo-outer} specifies the same symbol, so that @code{catch} is the applicable one (assuming there is no other matching @code{catch} in between)."
-msgstr "関数@code{throw}は1番目の引数にもとづいて、それにマッチする@code{catch}を探します。@code{throw}は1番目の引数が、@code{throw}で指定されたものと@code{eq}であるような@code{catch}を検索します。複数の該当する@code{catch}がある場合には、最内のものが優先されます。したがって上記の例では@code{throw}が@code{foo}を指定していて、@code{foo-outer}内の@code{catch}が同じシンボルを指定しているので、(この間に他のマッチする@code{catch}は存在しないと仮定するなら)その@code{catch}が該当します。"
+msgstr "関数@code{throw}は1番目の引数にもとづいて、それにマッチする@code{catch}を探します。@code{throw}は1番目の引数が、@code{throw}で指定されたものと@code{eq}であるような@code{catch}を検索します。複数の該当する@code{catch}がある場合には、最も内側にあるものが優先されます。したがって上記の例では@code{throw}が@code{foo}を指定していて、@code{foo-outer}内の@code{catch}が同じシンボルを指定しているので、(この間に他のマッチする@code{catch}は存在しないと仮定するなら)その@code{catch}が該当します。"
 
 #. type: Plain text
 #: original_texis/control.texi:1664
@@ -2708,7 +2708,7 @@ msgstr "@code{catch}は@code{throw}関数にたいするリターン位置を確
 #. type: defspec
 #: original_texis/control.texi:1693
 msgid "With the return point in effect, @code{catch} evaluates the forms of the @var{body} in textual order.  If the forms execute normally (without error or nonlocal exit) the value of the last body form is returned from the @code{catch}."
-msgstr "リターン位置が効果をもつことにより、@code{catch}は@var{body}のフォームをテキスト順に評価する。フォームが(エラーや非ローカル脱出なしで)通常に実行されたなら、bodyの最後のフォームの値が@code{catch}からリターンされる。"
+msgstr "リターン位置が有効な場合、@code{catch}は@var{body}のフォームをテキスト順に評価する。フォームが(エラーや非ローカル脱出なしで)通常に実行されたなら、bodyの最後のフォームの値が@code{catch}からリターンされる。"
 
 #. type: defspec
 #: original_texis/control.texi:1698
@@ -2724,7 +2724,7 @@ msgstr "throw tag value"
 #. type: defun
 #: original_texis/control.texi:1706
 msgid "The purpose of @code{throw} is to return from a return point previously established with @code{catch}.  The argument @var{tag} is used to choose among the various existing return points; it must be @code{eq} to the value specified in the @code{catch}.  If multiple return points match @var{tag}, the innermost one is used."
-msgstr "@code{throw}の目的は、以前に@code{catch}により確立されたリターン位置に戻ることである。引数@var{tag}は、既存のさまざまなリターン位置からリターン位置を選択するために使用される。複数のリターン位置が@var{tag}にマッチしたら、最内のものが使用される。"
+msgstr "@code{throw}の目的は、以前に@code{catch}により確立されたリターン位置に戻ることである。引数@var{tag}は、既存のさまざまなリターン位置からリターン位置を選択するために使用される。複数のリターン位置が@var{tag}にマッチしたら、最も内側のものが使用される。"
 
 #. type: defun
 #: original_texis/control.texi:1709
@@ -2867,7 +2867,7 @@ msgstr "エラーがシグナルされるとエラーメッセージを表示し
 #. type: Plain text
 #: original_texis/control.texi:1811
 msgid "In complicated programs, simple termination may not be what you want.  For example, the program may have made temporary changes in data structures, or created temporary buffers that should be deleted before the program is finished.  In such cases, you would use @code{unwind-protect} to establish @dfn{cleanup expressions} to be evaluated in case of error.  (@xref{Cleanups}.)  Occasionally, you may wish the program to continue execution despite an error in a subroutine.  In these cases, you would use @code{condition-case} to establish @dfn{error handlers} to recover control in case of error."
-msgstr "複雑なプログラムでは単なる終了が望ましくない場合もあるでしょう。たとえばそのプログラムがータ構造に一時的に変更を行なっていたり、プログラム終了前に削除する必要がある一時バッファーを作成しているかもしれません。このような場合には、エラー時に評価される@dfn{クリーンアップ式(cleanup expressions)}を設定するために、@code{unwind-protect}を使用するでしょう(@ref{Cleanups}を参照)。サブルーチン内のエラーにもかかわらずに、プログラムの実行を継続したいときがあるかもしれません。このような場合には、エラー時のリカバリーを制御する@dfn{エラーハンドラー(error handlers)}を設定するために@code{condition-case}を使用するでしょう。"
+msgstr "複雑なプログラムでは単なる終了が望ましくない場合もあるでしょう。たとえばそのプログラムがデータ構造に一時的に変更を行なっていたり、プログラム終了前に削除する必要がある一時バッファーを作成しているかもしれません。このような場合には、エラー時に評価される@dfn{クリーンアップ式(cleanup expressions)}を設定するために、@code{unwind-protect}を使用するでしょう(@ref{Cleanups}を参照)。サブルーチン内のエラーにもかかわらずに、プログラムの実行を継続したいときがあるかもしれません。このような場合には、エラー時のリカバリーを制御する@dfn{エラーハンドラー(error handlers)}を設定するために@code{condition-case}を使用するでしょう。"
 
 #. type: Plain text
 #: original_texis/control.texi:1815
@@ -2948,7 +2948,7 @@ msgstr "ユーザーが@kbd{C-g}をタイプしたときに発生するquitは
 #. type: Plain text
 #: original_texis/control.texi:1848
 msgid "Every error specifies an error message, one way or another.  The message should state what is wrong (``File does not exist''), not how things ought to be (``File must exist'').  The convention in Emacs Lisp is that error messages should start with a capital letter, but should not end with any sort of punctuation."
-msgstr "すべてのエラーメッセージはそれぞれ、何らかのエラーメッセージを指定します。そのメッセージは何が悪いのか(``File does not exist'')、物事がどうしてそうあるべきではない(``File must exist'')かを示すべきです。Emacs Lispの慣習ではエラーメッセージは大文字で開始され、区切り文字で終わるべきではありません。"
+msgstr "すべてのエラーメッセージはそれぞれ、何らかのエラーメッセージを指定します。そのメッセージはどうであるべきか(``File must exist'')ではなく、何が悪いのか(``File does not exist'')を示すべきです。Emacs Lispの慣習ではエラーメッセージは大文字で開始され、区切り文字で終わるべきではありません。"
 
 #. type: defun
 #: original_texis/control.texi:1849
@@ -2989,7 +2989,7 @@ msgstr ""
 #. type: defun
 #: original_texis/control.texi:1871
 msgid "@code{error} works by calling @code{signal} with two arguments: the error symbol @code{error}, and a list containing the string returned by @code{format-message}."
-msgstr "2つの引数 --- エラーシンボル@code{error}と@code{format-message}がリターンするる文字列を含むリスト --- で@code{signal}を呼び出すことにより@code{error}は機能する。"
+msgstr "2つの引数 --- エラーシンボル@code{error}と@code{format-message}がリターンする文字列を含むリスト --- で@code{signal}を呼び出すことにより@code{error}は機能する。"
 
 #. type: defun
 #: original_texis/control.texi:1876
@@ -3310,7 +3310,7 @@ msgstr ""
 #. type: defspec
 #: original_texis/control.texi:2129
 msgid "Each error that occurs has an @dfn{error symbol} that describes what kind of error it is, and which describes also a list of condition names (@pxref{Error Symbols}).  Emacs searches all the active @code{condition-case} forms for a handler that specifies one or more of these condition names; the innermost matching @code{condition-case} handles the error.  Within this @code{condition-case}, the first applicable handler handles the error."
-msgstr "発生するエラーはそれぞれ、それが何の種類のエラーかを記述する@dfn{エラーシンボル(error symbol)}をもち、これはコンディション名のリストも記述する(@ref{Error Symbols}を参照)。Emacsは1つ以上のコンディション名を指定するハンドラーにたいして、すべてのアクティブな@code{condition-case}フォームを検索する。@code{condition-case}の最内のマッチがそのエラーを処理する。@code{condition-case}内では、最初に適合したハンドラーがそのエラーを処理する。"
+msgstr "発生するエラーはそれぞれ、それが何の種類のエラーかを記述する@dfn{エラーシンボル(error symbol)}をもち、これはコンディション名のリストも記述する(@ref{Error Symbols}を参照)。Emacsは1つ以上のコンディション名を指定するハンドラーにたいして、すべてのアクティブな@code{condition-case}フォームを検索する。@code{condition-case}の最も内側のマッチがそのエラーを処理する。@code{condition-case}内では、最初に適合したハンドラーがそのエラーを処理する。"
 
 #. type: defspec
 #: original_texis/control.texi:2133
@@ -3538,7 +3538,7 @@ msgstr ""
 #. type: defmac
 #: original_texis/control.texi:2265
 msgid "@var{condition} can also be a list of error conditions."
-msgstr "@var{condition}はエエラーコンディションのリストでも可。"
+msgstr "@var{condition}はエラーコンディションのリストでも可。"
 
 #. type: defmac
 #: original_texis/control.texi:2267
@@ -3806,7 +3806,7 @@ msgstr "ftp-login"
 #. type: Plain text
 #: original_texis/control.texi:2448
 msgid "Here is an actual example derived from an FTP package.  It creates a process (@pxref{Processes}) to try to establish a connection to a remote machine.  As the function @code{ftp-login} is highly susceptible to numerous problems that the writer of the function cannot anticipate, it is protected with a form that guarantees deletion of the process in the event of failure.  Otherwise, Emacs might fill up with useless subprocesses."
-msgstr "以下はFTPパッケージ由来の実例です。これはリモートマシンへの接続の確立を試みるために、プロセス(@ref{Processes}を参照)を作成しています。関数@code{ftp-login}は関数のライター(writer)が予想できないことによる多くの問題から非常に影響を受けるので、失敗イベントでプロセスの削除を保証するフォームで保護されています。そうしないとEmacsは無用なサブプロセスで一杯になってしまうでしょう。"
+msgstr "以下はFTPパッケージ由来の実例です。これはリモートマシンへの接続の確立を試みるために、プロセス(@ref{Processes}を参照)を作成しています。関数@code{ftp-login}は関数の作成者が予想できない多くの問題から非常に影響を受け易いので、失敗イベントでプロセスの削除を保証するフォームで保護されています。そうしないとEmacsは無用なサブプロセスで一杯になってしまうでしょう。"
 
 #. type: group
 #: original_texis/control.texi:2459
diff --git a/lispref/debugging.texi.po b/lispref/debugging.texi.po
index 7c091b1..2249ca0 100644
--- a/lispref/debugging.texi.po
+++ b/lispref/debugging.texi.po
@@ -1607,7 +1607,7 @@ msgstr "debugging invalid Lisp syntax"
 #. type: Plain text
 #: original_texis/debugging.texi:911
 msgid "The Lisp reader reports invalid syntax, but cannot say where the real problem is.  For example, the error @samp{End of file during parsing} in evaluating an expression indicates an excess of open parentheses (or square brackets).  The reader detects this imbalance at the end of the file, but it cannot figure out where the close parenthesis should have been.  Likewise, @samp{Invalid read syntax: \")\"} indicates an excess close parenthesis or missing open parenthesis, but does not say where the missing parenthesis belongs.  How, then, to find what to change?"
-msgstr "Lispリーダーは無効な構文(invalid syntax)について報告はしますが実際の問題箇所は報告しません。たとえばある式を評価中のエラー@samp{End of file during parsing}は、開カッコまたは開角カッコ(open parenthese or open square bracket)が多いことを示しています。Lispリーダーはこの不一致をファイル終端で検出しましたが、本来閉カッコがあるべき箇所を解決することはできません。同様に@samp{Invalid read syntax: \\\")\\\"}は開カッコの欠落を示していますが、欠落しているカッコが属すべき場所は告げません。ならばどうやって変更すべき箇所を探せばよいのでしょうか?"
+msgstr "Lispリーダーは無効な構文(invalid syntax)について報告はしますが実際の問題箇所は報告しません。たとえばある式を評価中のエラー@samp{End of file during parsing}は、開カッコまたは開角カッコ(open parenthese or open square bracket)が多いことを示しています。Lispリーダーはこの不一致をファイル終端で検出しましたが、本来閉カッコがあるべき箇所を解決することはできません。同様に@samp{Invalid read syntax: \")\"}は開カッコの欠落を示していますが、欠落しているカッコが属すべき場所は告げません。ならばどうやって変更すべき箇所を探せばよいのでしょうか?"
 
 #. type: Plain text
 #: original_texis/debugging.texi:917
diff --git a/lispref/display.texi.po b/lispref/display.texi.po
index 0992d26..54a618e 100644
--- a/lispref/display.texi.po
+++ b/lispref/display.texi.po
@@ -1012,7 +1012,7 @@ msgstr "@var{min-value}と@var{max-value}が数値なら、進行状況の初期
 #. type: defun
 #: original_texis/display.texi:464
 msgid "The remaining arguments control the rate of echo area updates.  The progress reporter will wait for at least @var{min-change} more percents of the operation to be completed before printing next message; the default is one percent.  @var{min-time} specifies the minimum time in seconds to pass between successive prints; the default is 0.2 seconds.  (On some operating systems, the progress reporter may handle fractions of seconds with varying precision)."
-msgstr "残りの引数はエコーエリアの更新レートを制御する。プログレスリポーターは次のメッセージを表示する前に、その処理が少なくとも@var{min-change}パーセントより多く完了するまで待機する。デフォルトは1パーセント。@var{min-time}は連続するプリントの間に空ける最小時間をミリ秒単位で指定する(いくつかのオペレーティングシステムではプログレスリポーターは秒の少数部をさまざまな精度で処理するかもしれない)。"
+msgstr "残りの引数はエコーエリアの更新レートを制御する。プログレスリポーターは次のメッセージを表示する前に、その処理が少なくとも@var{min-change}パーセントより多く完了するまで待機する。デフォルトは1パーセント。@var{min-time}は連続するプリントの間に空ける最小時間をミリ秒単位で指定する(いくつかのオペレーティングシステムではプログレスリポーターは秒の小数部をさまざまな精度で処理するかもしれない)。"
 
 #. type: defun
 #: original_texis/display.texi:467
diff --git a/lispref/elisp.texi.po b/lispref/elisp.texi.po
index f13bd8d..194a21c 100644
--- a/lispref/elisp.texi.po
+++ b/lispref/elisp.texi.po
@@ -1482,7 +1482,7 @@ msgstr "Float Basics"
 #. type: menuentry
 #: original_texis/elisp.texi:383
 msgid "Representation and range of floating point."
-msgstr "浮動少数の表現と範囲。"
+msgstr "浮動小数の表現と範囲。"
 
 #. type: menuentry
 #: original_texis/elisp.texi:383
diff --git a/lispref/eval.texi.po b/lispref/eval.texi.po
index b52c426..72c859f 100644
--- a/lispref/eval.texi.po
+++ b/lispref/eval.texi.po
@@ -161,7 +161,7 @@ msgstr "以降のセクションでは、各種フォームにたいしてそれ
 #. type: Plain text
 #: original_texis/eval.texi:65
 msgid "It is very common to read a Lisp form and then evaluate the form, but reading and evaluation are separate activities, and either can be performed alone.  Reading per se does not evaluate anything; it converts the printed representation of a Lisp object to the object itself.  It is up to the caller of @code{read} to specify whether this object is a form to be evaluated, or serves some entirely different purpose.  @xref{Input Functions}."
-msgstr "Lispフォームを読み取ってそのフォームを評価するのは、非常に一般的なアクティビティーですが、読み取りと評価は別のアクティビティーであって、どちらか一方を単独で処理することができます。読み取っただけでは何も評価されません。読み取りはLispオブジェクトのプリント表現をそのオブジェクト自体に変換します。そのオブジェクトが評価されるべきフォームなのか、そのれともまったく違う目的をもつかを指定するのは、@code{read}の呼び出し元の役目です。@ref{Input Functions}を参照してください。"
+msgstr "Lispフォームを読み取ってそのフォームを評価するのは、非常に一般的なアクティビティーですが、読み取りと評価は別のアクティビティーであって、どちらか一方を単独で処理することができます。読み取っただけでは何も評価されません。読み取りはLispオブジェクトのプリント表現をそのオブジェクト自体に変換します。そのオブジェクトが評価されるべきフォームなのか、それともまったく違う目的をもつかを指定するのは、@code{read}の呼び出し元の役目です。@ref{Input Functions}を参照してください。"
 
 #. type: cindex
 #: original_texis/eval.texi:66
@@ -172,7 +172,7 @@ msgstr "recursive evaluation"
 #. type: Plain text
 #: original_texis/eval.texi:77
 msgid "Evaluation is a recursive process, and evaluating a form often involves evaluating parts within that form.  For instance, when you evaluate a @dfn{function call} form such as @code{(car x)}, Emacs first evaluates the argument (the subform @code{x}).  After evaluating the argument, Emacs @dfn{executes} the function (@code{car}), and if the function is written in Lisp, execution works by evaluating the @dfn{body} of the function (in this example, however, @code{car} is not a Lisp function; it is a primitive function implemented in C).  @xref{Functions}, for more information about functions and function calls."
-msgstr "評価とは再帰的な処理であり、あるフォームを評価するとそのフォームの一部が評価されるといったことがよくあります。たとえば@code{(car x)}のような@dfn{関数呼び出し(function call)}のフォームを評価する場合、Emacsは最初にその引数(サブフォーム@code{x})を評価します。引数を評価した後、Emacsはその関数(@code{car})を@dfn{実行(executes)}します。その関数がLispで記述されていれば、関数の@dfn{body(本文)}を評価することによって実行が行なわれます(しかしこの例で使用している@code{car}はLisp関数ではなくCで実装されたプリミティブ関数である)。関数と関数呼び出しについての情報は@ref{Functions}を参照してください。"
+msgstr "評価とは再帰的な処理であり、あるフォームを評価するとそのフォームの一部が評価されるといったことがよくあります。たとえば@code{(car x)}のような@dfn{関数呼び出し(function call)}のフォームを評価する場合、Emacsは最初にその引数(サブフォーム @code{x})を評価します。引数を評価した後、Emacsはその関数(@code{car})を@dfn{実行(executes)}します。その関数がLispで記述されていれば、関数の@dfn{body(本文)}を評価することによって実行が行なわれます(しかしこの例で使用している@code{car}はLisp関数ではなくCで実装されたプリミティブ関数である)。関数と関数呼び出しについての情報は@ref{Functions}を参照してください。"
 
 #. type: cindex
 #: original_texis/eval.texi:78
@@ -681,7 +681,7 @@ msgstr "この関数は@var{function}が意味するものを関数としてリ
 #. type: defun
 #: original_texis/eval.texi:345
 msgid "This function returns @code{nil} if the final symbol is unbound.  It signals a @code{cyclic-function-indirection} error if there is a loop in the chain of symbols."
-msgstr "この関数は最終的なシンボルがバインドされていなければ@code{nil}をリターンする。特定のシンボル内にループがれば、この関数は@code{cyclic-function-indirection}エラーをシグナルする。"
+msgstr "この関数は最終的なシンボルがバインドされていなければ@code{nil}をリターンする。特定のシンボル内にループがあれば、この関数は@code{cyclic-function-indirection}エラーをシグナルする。"
 
 #. type: defun
 #: original_texis/eval.texi:348
@@ -851,7 +851,7 @@ msgstr "スペシャルフォームはそれぞれ、どの引数を評価して
 #. type: Plain text
 #: original_texis/eval.texi:454
 msgid "If an expression's first symbol is that of a special form, the expression should follow the rules of that special form; otherwise, Emacs's behavior is not well-defined (though it will not crash).  For example, @code{((lambda (x) x . 3) 4)} contains a subexpression that begins with @code{lambda} but is not a well-formed @code{lambda} expression, so Emacs may signal an error, or may return 3 or 4 or @code{nil}, or may behave in other ways."
-msgstr "式の最初のシンボルがスペシャルフォームなら、式はそのスペシャルフォームのルールにしたがう必要があります。それ以外ならEmacsの挙動は(たとえクラッシュしなくいとしても)未定義です。たとえば@code{((lambda (x) x . 3) 4)}は@code{lambda}で始まるサブ式を含みますが、これは適正な@code{lambda}式ではないので、Emacsはエラーをシグナルするかもしれないし、3や4や@code{nil}をリターンしたり、もしかしたら他の挙動を示すかもしれません。"
+msgstr "式の最初のシンボルがスペシャルフォームなら、式はそのスペシャルフォームのルールにしたがう必要があります。それ以外ならEmacsの挙動は(たとえクラッシュしてないとしても)未定義です。たとえば@code{((lambda (x) x . 3) 4)}は@code{lambda}で始まるサブ式を含みますが、これは適正な@code{lambda}式ではないので、Emacsはエラーをシグナルするかもしれないし、3や4や@code{nil}をリターンしたり、もしかしたら他の挙動を示すかもしれません。"
 
 #. type: defun
 #: original_texis/eval.texi:455
@@ -1261,7 +1261,7 @@ msgstr "forms, backquote"
 #. type: Plain text
 #: original_texis/eval.texi:630
 msgid "@dfn{Backquote constructs} allow you to quote a list, but selectively evaluate elements of that list.  In the simplest case, it is identical to the special form"
-msgstr "@dfn{バッククォート構文(backquote constructs)}を使用することにより、リストをクォートしてそのリストのある要素を選択的に評価することができます。もっとも簡単な使い方ではスペシャルフォーム"
+msgstr "@dfn{バッククォート構文(backquote constructs)}を使用することにより、リストをクォートしてそのリストのある要素を選択的に評価することができます。もっとも単純な場合、スペシャルフォーム"
 
 #. type: iftex
 #: original_texis/eval.texi:632
@@ -1271,7 +1271,7 @@ msgstr "@code{quote}と同じです。"
 #. type: ifnottex
 #: original_texis/eval.texi:636
 msgid "@code{quote} (described in the previous section; @pxref{Quoting})."
-msgstr "@code{quote} (前セクションで説明済み。@ref{Quoting}を参照)。"
+msgstr "@code{quote} (前セクションで説明済み。@ref{Quoting}を参照)と同じになります。"
 
 #. type: Plain text
 #: original_texis/eval.texi:638
@@ -1709,7 +1709,7 @@ msgstr "lazy evaluation"
 #. type: Plain text
 #: original_texis/eval.texi:923
 msgid "Sometimes it is useful to delay the evaluation of an expression, for example if you want to avoid performing a time-consuming calculation if it turns out that the result is not needed in the future of the program.  The @file{thunk} library provides the following functions and macros to support such @dfn{deferred evaluation}:"
-msgstr "たとえばプログラムの将来において計算結果が不要なら時間を要する計算処理を回避したい等、式の評価を遅延できれば便利な場合があります。そのような@dfn{遅延評価(deferred evaluation)}をサポートするために、@file{thunk}は以下の関数とマクロを提供します。"
+msgstr "たとえばプログラムの将来において計算結果が不要ということがわかった場合に時間を要する計算処理を回避したい等、式の評価を遅延させると便利な場合があります。そのような@dfn{遅延評価(deferred evaluation)}をサポートするために、@file{thunk}ライブラリは以下の関数とマクロを提供します。"
 
 #. type: cindex
 #: original_texis/eval.texi:924
@@ -1726,7 +1726,7 @@ msgstr "thunk-delay forms@dots{}"
 #. type: defmac
 #: original_texis/eval.texi:930
 msgid "Return a @dfn{thunk} for evaluating the @var{forms}.  A thunk is a closure (@pxref{Closures}) that inherits the lexical environment of the @code{thunk-delay} call.  Using this macro requires @code{lexical-binding}."
-msgstr "@var{forms}を評価するための@dfn{thunk}をリターンする(訳注: thunkとは別のサブルーチンに計算を追加で挿入するために使用するサブルーチンであり、計算結果が必要になるまで計算を遅延したり、別のサブルーチンの先頭や最後に処理を挿入するために使用される。英語版Wikipediaより)。thunkは@code{thunk-delay}呼び出しのlexical環境を継承するクロージャである(@ref{Closures}を参照)。このマクロの使用には@code{lexical-binding}が必要。"
+msgstr "@var{forms}を評価するための@dfn{thunk}をリターンする(訳注: thunkとは、別のサブルーチンに計算を追加で挿入するために使用するサブルーチンであり、計算結果が必要になるまで計算を遅延したり、別のサブルーチンの先頭や最後に処理を挿入するために使用される。英語版Wikipediaより)。thunkは@code{thunk-delay}呼び出しのlexical環境を継承するクロージャである(@ref{Closures}を参照)。このマクロの使用には@code{lexical-binding}が必要。"
 
 #. type: defun
 #: original_texis/eval.texi:932
diff --git a/lispref/hash.texi.po b/lispref/hash.texi.po
index 81bc8ba..29f7f70 100644
--- a/lispref/hash.texi.po
+++ b/lispref/hash.texi.po
@@ -7,7 +7,7 @@ msgid ""
 msgstr ""
 "Project-Id-Version: Emacs 26.1\n"
 "POT-Creation-Date: 2022-12-01 02:45+0900\n"
-"PO-Revision-Date: 2022-08-15 11:38+0900\n"
+"PO-Revision-Date: 2023-08-21 19:10+0900\n"
 "Last-Translator: Takeshi Ayanokoji <takeshi.ayanokoji@gmail.com>\n"
 "Language-Team: Japanese <takeshi.ayanokoji@gmail.com>\n"
 "Language: ja\n"
@@ -160,7 +160,7 @@ msgstr "eql"
 #. type: table
 #: original_texis/hash.texi:78
 msgid "Keys which are numbers are the same if they are @code{equal}, that is, if they are equal in value and either both are integers or both are floating point; otherwise, two distinct objects are never the same."
-msgstr "キーが数字ならそれらが@code{equal}、つまりそれらの値が等しくどちらも整数か浮動少数点数なら同一。それ以外なら別の2つのオブジェクトは決して同一とならない。"
+msgstr "キーが数字ならそれらが@code{equal}、つまりそれらの値が等しくどちらも整数か浮動小数点数なら同一。それ以外なら別の2つのオブジェクトは決して同一とならない。"
 
 #. type: item
 #: original_texis/hash.texi:79
@@ -208,7 +208,7 @@ msgstr "値@var{weak}には@code{nil}、@code{key}、@code{value}、@code{key-or
 #. type: table
 #: original_texis/hash.texi:106
 msgid "If @var{weak} is @code{value}, then the hash table does not prevent values from being collected as garbage (if they are not referenced anywhere else); if a particular value does get collected, the corresponding association is removed from the hash table."
-msgstr "@var{weak}が@code{value}ならそのハッシュテーブルは、(値が他の場所で参照されていなければ)ハッシュテーブルの値がガベージコレクトされるのを妨げませんられない。ある特定の値がガーベージコレクトされると、それに対応する連想はハッシュテーブルから削除される。"
+msgstr "@var{weak}が@code{value}ならそのハッシュテーブルは、(値が他の場所で参照されていなければ)ハッシュテーブルの値がガベージコレクトされるのを妨げられない。ある特定の値がガーベージコレクトされると、それに対応する連想はハッシュテーブルから削除される。"
 
 #. type: table
 #: original_texis/hash.texi:112
@@ -413,12 +413,12 @@ msgstr "@code{define-hash-table-test}でキーを照合する新しい方法を
 #. type: Plain text
 #: original_texis/hash.texi:249
 msgid "You can think of a hash table conceptually as a large array of many slots, each capable of holding one association.  To look up a key, @code{gethash} first computes an integer, the hash code, from the key.  It can reduce this integer modulo the length of the array, to produce an index in the array.  Then it looks in that slot, and if necessary in other nearby slots, to see if it has found the key being sought."
-msgstr "概念的にはハッシュテーブルを1つの連想を保持できるスロットがたくさんある巨大な配列として考えることができます。キーを照合するにはまず、@code{gethash}がキーから整数のハッシュコードを計算します。配列の長さをmoduloとしてこの整数を減らして、配列内のインデックスを生成することができます。それからキーが見つかったかどうか確認するためにそのスロット、もし必要なら近くのスロットを探します。"
+msgstr "概念的にはハッシュテーブルを1つの連想を保持できるスロットがたくさんある巨大な配列として考えることができます。キーを照合するにはまず、@code{gethash}がキーから整数(ハッシュコード)を計算します。配列の長さを法(modulo)としてこの整数を縮小して(訳注:配列の長さで割った余りの整数にして)、配列内のインデックスを生成することができます。それから探しているキーが見つかったかどうか確認するためにそのスロット、必要なら近くのスロットを調べます。"
 
 #. type: Plain text
 #: original_texis/hash.texi:258
 msgid "Thus, to define a new method of key lookup, you need to specify both a function to compute the hash code from a key, and a function to compare two keys directly.  The two functions should be consistent with each other: that is, two keys' hash codes should be the same if the keys compare as equal.  Also, since the two functions can be called at any time (such as by the garbage collector), the functions should be free of side effects and should return quickly, and their behavior should depend on only on properties of the keys that do not change."
-msgstr "しあがってキーを照合する新たな方法を定義するにはキーからハッシュコードを計算する関数、および2つのキーを直接比較する関数の両方を指定する必要があります。この2つの関数は互いに一貫性をもつ必要があります。すなわちキーを比較してequalなら、2つのキーのハッシュコードは同一であるべきです。さらに(ガーベージコレクターからの呼び出しのように)2つの関数は任意のタイミングで呼び出される可能性があるので、関数が副作用をもたないこと、すぐにリターンすること、そしてこれらの関数の挙動はそのキーの不変の性質だけに依存する必要があります。"
+msgstr "したがってキーを照合する新たな方法を定義するにはキーからハッシュコードを計算する関数、および2つのキーを直接比較する関数の両方を指定する必要があります。この2つの関数は互いに一貫性をもつ必要があります。すなわちキーを比較してequalなら、2つのキーのハッシュコードは同一であるべきです。さらに(ガーベージコレクターからの呼び出しのように)2つの関数は任意のタイミングで呼び出される可能性があるので、関数が副作用をもたないこと、すぐにリターンすること、そしてこれらの関数の挙動はそのキーの不変の性質だけに依存する必要があります。"
 
 #. type: defun
 #: original_texis/hash.texi:259
@@ -465,14 +465,14 @@ msgstr "この関数はLispオブジェクト@var{obj}のハッシュコード
 #. type: defun
 #: original_texis/hash.texi:288
 msgid "If two objects @var{obj1} and @var{obj2} are @code{equal}, then @code{(sxhash-equal @var{obj1})} and @code{(sxhash-equal @var{obj2})} are the same integer."
-msgstr "2つのオブジェクト@var{obj1}と@var{obj2}が等しければ@code{(sxhash-equal @var{obj1})}と@code{(sxhash-equal @var{obj2})}は同じ整数になる。"
+msgstr "2つのオブジェクト@var{obj1}と@var{obj2}が@code{equal}ならば@code{(sxhash-equal @var{obj1})}と@code{(sxhash-equal @var{obj2})}は同じ整数になる。"
 
 #. type: defun
 #: original_texis/hash.texi:297
 #, fuzzy
 #| msgid "If the two objects are not @code{equal}, the values returned by @code{sxhash-equal} are usually different, but not always; once in a rare while, by luck, you will encounter two distinct-looking objects that give the same result from @code{sxhash-equal}."
 msgid "If the two objects are not @code{equal}, the values returned by @code{sxhash-equal} are usually different, but not always.  @code{sxhash-equal} is designed to be reasonably fast (since it's used for indexing hash tables) so it won't recurse deeply into nested structures.  In addition; once in a rare while, by luck, you will encounter two distinct-looking simple objects that give the same result from @code{sxhash-equal}.  So you can't, in general, use @code{sxhash-equal} to check whether an object has changed."
-msgstr "2つのオブジェクトが@code{equal}でなければ通常は@code{sxhash-equal}がreturnする値は異なるが、常に異なるとは限らない。稀(運次第)に@code{sxhash-equal}が同じ結果を与える、2つの異なって見えるオブジェクトに遭遇するかもしれない。"
+msgstr "2つのオブジェクトが@code{equal}でなければ通常は@code{sxhash-equal}がreturnする値は異なるが、常に異なるとは限らない。@code{sxhash-equal}は(インデックスされたハッシュテーブルを使っているゆえ)十分に速さになるようにデザインされているので、入れ子になった構造に深く再帰することはないであろう。加えて稀(運次第)ではあるが、@code{sxhash-equal}が同じ結果を与える、見た目が異なる2つの単純なオブジェクトに遭遇するかもしれない。だから一般的にオブジェクトが変化したかどうかのチェックするには@code{sxhash-equal}は使えない。"
 
 #. type: defun
 #: original_texis/hash.texi:301
@@ -488,12 +488,12 @@ msgstr "sxhash-eq obj"
 #. type: defun
 #: original_texis/hash.texi:306
 msgid "This function returns a hash code for Lisp object @var{obj}.  Its result reflects identity of @var{obj}, but not its contents."
-msgstr "この関数はLispオブジェクト@var{obj}にたいするハッシュコードをリターンする。結果は@var{obj}の識別値でありコンテンツではない。"
+msgstr "この関数はLispオブジェクト@var{obj}にたいするハッシュコードをリターンする。結果は@var{obj}の識別値であり内容が反映されているわけではない。"
 
 #. type: defun
 #: original_texis/hash.texi:310
 msgid "If two objects @var{obj1} and @var{obj2} are @code{eq}, then @code{(sxhash-eq @var{obj1})} and @code{(sxhash-eq @var{obj2})} are the same integer."
-msgstr "2つのオブジェクト@var{obj1}と@var{obj2}が@code{eq}なら@code{(sxhash-eq @var{obj1})}と@code{(sxhash-eq @var{obj2})}は同じ整数。"
+msgstr "2つのオブジェクト@var{obj1}と@var{obj2}が@code{eq}なら@code{(sxhash-eq @var{obj1})}と@code{(sxhash-eq @var{obj2})}は同じ整数になる。"
 
 #. type: defun
 #: original_texis/hash.texi:312
@@ -509,12 +509,12 @@ msgstr "この関数は@code{eql}による比較に適したLispオブジェク
 #. type: defun
 #: original_texis/hash.texi:321
 msgid "If two objects @var{obj1} and @var{obj2} are @code{eql}, then @code{(sxhash-eql @var{obj1})} and @code{(sxhash-eql @var{obj2})} are the same integer."
-msgstr "2つのオブジェクト@var{obj1}と@var{obj2}が@code{eql}なら@code{(sxhash-eql @var{obj1})}と@code{(sxhash-eql @var{obj2})}は同じ整数。"
+msgstr "2つのオブジェクト@var{obj1}と@var{obj2}が@code{eql}なら@code{(sxhash-eql @var{obj1})}と@code{(sxhash-eql @var{obj2})}は同じ整数になる。"
 
 #. type: Plain text
 #: original_texis/hash.texi:325
 msgid "This example creates a hash table whose keys are strings that are compared case-insensitively."
-msgstr "以下はlcaseを区別しない文字列のキーをもつハッシュテーブルを作成する例です。"
+msgstr "以下はcaseを区別しない文字列のキーをもつハッシュテーブルを作成する例です。"
 
 #. type: example
 #: original_texis/hash.texi:329
@@ -572,7 +572,7 @@ msgstr "(make-hash-table :test 'contents-hash)\n"
 #. type: Plain text
 #: original_texis/hash.texi:350
 msgid "Lisp programs should @emph{not} rely on hash codes being preserved between Emacs sessions, as the implementation of the hash functions uses some details of the object storage that can change between sessions and between different architectures."
-msgstr "ハッシュ関数の実装はセッション中に変更されたり、アークテクチャーごとに異なるかもしれなオブジェクトストレージのいくつかの詳細を使用するので、LispプログラムはEmacsセッションの間はハッシュコードが保存されることに@emph{依存するべきではありません}。"
+msgstr "ハッシュ関数の実装はセッション間や異なるアークテクチャー間で変わる可能性のあるオブジェクトストレージのいくつかの詳細を使用するので、LispプログラムはEmacsセッションの間はハッシュコードが保存されることに@emph{依存するべきではありません}。"
 
 #. type: section
 #: original_texis/hash.texi:352
diff --git a/lispref/help.texi.po b/lispref/help.texi.po
index 2911388..9a0bd2f 100644
--- a/lispref/help.texi.po
+++ b/lispref/help.texi.po
@@ -732,7 +732,7 @@ msgstr "\\="
 #. type: table
 #: original_texis/help.texi:368
 msgid "quotes the following character and is discarded; thus, @samp{\\=`} puts @samp{`} into the output, @samp{\\=\\[} puts @samp{\\[} into the output, and @samp{\\=\\=} puts @samp{\\=} into the output."
-msgstr "これは後続の文字をクォートして無効にする。したがって@samp{\\=\\[}は@samp{\\[}、@samp{\\=\\=}は@samp{\\=}を出力する。"
+msgstr "これは後続の文字をクォートして無効にする。したがって@samp{\\=`}は@samp{`}、@samp{\\=\\[}は@samp{\\[}、@samp{\\=\\=}は@samp{\\=}を出力する。"
 
 #. type: item
 #: original_texis/help.texi:369
diff --git a/lispref/internals.texi.po b/lispref/internals.texi.po
index 2e6da10..6273829 100644
--- a/lispref/internals.texi.po
+++ b/lispref/internals.texi.po
@@ -2587,7 +2587,7 @@ msgstr "long tv_nsec"
 #. type: table
 #: original_texis/internals.texi:1666
 msgid "Fractional seconds as a number of nanoseconds.  For timestamps returned by @code{extract_time}, this is always nonnegative and less than one billion.  (Although POSIX requires the type of @code{tv_nsec} to be @code{long}, the type is @code{long long} on some nonstandard platforms.)"
-msgstr "ナノ秒としての少数秒数。@code{extract_time}がリターンするタイムスタンプでは常に非負かつ十億未満(@code{tv_nsec}のタイプが@code{long}であることをPOSIXがが要求しているとしても、非標準的なプラットフォームでは@code{long long}である)。"
+msgstr "ナノ秒としての小数秒数。@code{extract_time}がリターンするタイムスタンプでは常に非負かつ十億未満(@code{tv_nsec}のタイプが@code{long}であることをPOSIXがが要求しているとしても、非標準的なプラットフォームでは@code{long long}である)。"
 
 #. type: deftypefn
 #: original_texis/internals.texi:1670
diff --git a/lispref/keymaps.texi.po b/lispref/keymaps.texi.po
index d8e11fd..e96c1c8 100644
--- a/lispref/keymaps.texi.po
+++ b/lispref/keymaps.texi.po
@@ -3576,7 +3576,7 @@ msgstr "accessible-keymaps keymap &optional prefix"
 #. type: defun
 #: original_texis/keymaps.texi:2096
 msgid "This function returns a list of all the keymaps that can be reached (via zero or more prefix keys) from @var{keymap}.  The value is an association list with elements of the form @code{(@var{key} .@: @var{map})}, where @var{key} is a prefix key whose definition in @var{keymap} is @var{map}."
-msgstr "この関数は、(0個以上のプレフィクスキーを通じて)@var{keymap}から到達可能なすべてのキーマップのリストをリターンする。リターン値は@code{(@var{key} .@: @var{map})}のような形式の要素をもつ連想配列(alist)である。ここで@var{key}は@var{keymap}内での定義が@var{map}であるようなプレフィクスキーである。"
+msgstr "この関数は、(0個以上のプレフィクスキーを通じて)@var{keymap}から到達可能なすべてのキーマップのリストをリターンする。リターン値は@code{(@var{key} .@: @var{map})}のような形式の要素をもつ連想リスト(alist)である。ここで@var{key}は@var{keymap}内での定義が@var{map}であるようなプレフィクスキーである。"
 
 #. type: defun
 #: original_texis/keymaps.texi:2101
diff --git a/lispref/lists.texi.po b/lispref/lists.texi.po
index 93d41d4..0bb7f2f 100644
--- a/lispref/lists.texi.po
+++ b/lispref/lists.texi.po
@@ -775,7 +775,7 @@ msgstr "この関数はエラーや無限ループの危険なしで、@var{list
 #. type: defun
 #: original_texis/lists.texi:398
 msgid "If @var{list} is not @code{nil} or a cons cell, @code{safe-length} returns 0."
-msgstr "@var{list}が@code{nil}]とコンスセルのいずれでもなければ@code{safe-length}は0をリターンする。"
+msgstr "@var{list}が@code{nil}とコンスセルのいずれでもなければ@code{safe-length}は0をリターンする。"
 
 #. type: Plain text
 #: original_texis/lists.texi:403
@@ -1081,7 +1081,7 @@ msgstr "(setq list (cons newelt list))\n"
 #. type: defun
 #: original_texis/lists.texi:521
 msgid "Note that there is no conflict between the variable named @code{list} used in this example and the function named @code{list} described below; any symbol can serve both purposes."
-msgstr "この例で使用されている@code{list}という名前の変数と、以下で説明する@code{list}という名前の関数は競合しないことに注意されたい。すべてのシンボルが、変数ト関数の両方の役割を果たすことができる。"
+msgstr "この例で使用されている@code{list}という名前の変数と、以下で説明する@code{list}という名前の関数は競合しないことに注意されたい。すべてのシンボルが、変数と関数の両方の役割を果たすことができる。"
 
 #. type: defun
 #: original_texis/lists.texi:523
@@ -1092,7 +1092,7 @@ msgstr "list &rest objects"
 #. type: defun
 #: original_texis/lists.texi:527
 msgid "This function creates a list with @var{objects} as its elements.  The resulting list is always @code{nil}-terminated.  If no @var{objects} are given, the empty list is returned."
-msgstr "この関数は@var{objects}を要素とするリストを作成する。結果となるリストは常に@code{nil}終端される。@var{objects}を指定しないと空リストがリターンされる。"
+msgstr "この関数は@var{objects}を要素とするリストを作成する。結果となるリストは常に@code{nil}で終端される。@var{objects}を指定しないと空リストがリターンされる。"
 
 #. type: group
 #: original_texis/lists.texi:532
@@ -1452,17 +1452,17 @@ msgstr "number-sequence from &optional to separation"
 #. type: defun
 #: original_texis/lists.texi:743
 msgid "This function returns a list of numbers starting with @var{from} and incrementing by @var{separation}, and ending at or just before @var{to}.  @var{separation} can be positive or negative and defaults to 1.  If @var{to} is @code{nil} or numerically equal to @var{from}, the value is the one-element list @code{(@var{from})}.  If @var{to} is less than @var{from} with a positive @var{separation}, or greater than @var{from} with a negative @var{separation}, the value is @code{nil} because those arguments specify an empty sequence."
-msgstr "この関数は@var{from}から@var{separation}づつインクリメントして、@var{to}の直前で終わる数字のリストをリターンする。@var{separation}には正か負の数を指定でき、デフォルトは1。@var{to}が@code{nil}、または数値的に@var{from}と等しければ、値は1要素のリスト@code{(@var{from})}になる。@var{separation}が正で@var{to}が@var{from}より小さい、または@var{separation}が負で@var{to}が@var{from}より大きければ、これらの引数は空のシーケンスを指示することになるので、値は@code{nil}になる。"
+msgstr "この関数は@var{from}から@var{separation}ずつインクリメントして、@var{to}の直前で終わる数字のリストをリターンする。@var{separation}には正か負の数を指定でき、デフォルトは1。@var{to}が@code{nil}、または数値的に@var{from}と等しければ、値は1要素のリスト@code{(@var{from})}になる。@var{separation}が正で@var{to}が@var{from}より小さい、または@var{separation}が負で@var{to}が@var{from}より大きければ、これらの引数は空のシーケンスを指示することになるので、値は@code{nil}になる。"
 
 #. type: defun
 #: original_texis/lists.texi:747
 msgid "If @var{separation} is 0 and @var{to} is neither @code{nil} nor numerically equal to @var{from}, @code{number-sequence} signals an error, since those arguments specify an infinite sequence."
-msgstr "@var{separation}が0で、@var{to}が@code{nil}でもなく、数値的に@var{from}とも等しくまければ、これらの引数は無限シーケンスを指示することになるので、エラーがシグナルされる。"
+msgstr "@var{separation}が0で、@var{to}が@code{nil}でもなく、数値的に@var{from}とも等しくなければ、これらの引数は無限シーケンスを指示することになるので、エラーがシグナルされる。"
 
 #. type: defun
 #: original_texis/lists.texi:760
 msgid "All arguments are numbers.  Floating-point arguments can be tricky, because floating-point arithmetic is inexact.  For instance, depending on the machine, it may quite well happen that @code{(number-sequence 0.4 0.6 0.2)} returns the one element list @code{(0.4)}, whereas @code{(number-sequence 0.4 0.8 0.2)} returns a list with three elements.  The @var{n}th element of the list is computed by the exact formula @code{(+ @var{from} (* @var{n} @var{separation}))}.  Thus, if one wants to make sure that @var{to} is included in the list, one can pass an expression of this exact type for @var{to}.  Alternatively, one can replace @var{to} with a slightly larger value (or a slightly more negative value if @var{separation} is negative)."
-msgstr "引数はすべて数字である。浮動少数点数の計算は正確ではないので、浮動少数点数の引数には注意する必要がある。たとえばマシンへの依存により、@code{(number-sequence 0.4 0.8 0.2)}が3要素のリストをリターンして、@code{(number-sequence 0.4 0.6 0.2)}が1要素のリスト@code{(0.4)}をリターンnすることがよく起こる。リストの@var{n}番目の要素は、厳密に@code{(+ @var{from} (* @var{n} @var{separation}))}という式により計算される。リストに確実に@var{to}が含まれるようにするために、この式に適切な型の@var{to}を渡すことができる。別の方法として@var{to}を少しだけ大きな値(@var{separation}が負なら少しだけ小さな値)に置き換えることもできる。"
+msgstr "引数はすべて数字である。浮動小数点数の計算は正確ではないので、浮動小数点数の引数には注意する必要がある。たとえばマシンへの依存により、@code{(number-sequence 0.4 0.8 0.2)}が3要素のリストをリターンして、@code{(number-sequence 0.4 0.6 0.2)}が1要素のリスト@code{(0.4)}をリターンすることがよく起こる。リストの@var{n}番目の要素は、厳密に@code{(+ @var{from} (* @var{n} @var{separation}))}という式により計算される。リストに確実に@var{to}が含まれるようにするために、この式に適切な型の@var{to}を渡すことができる。別の方法として@var{to}を少しだけ大きな値(@var{separation}が負なら少しだけ小さな値)に置き換えることもできる。"
 
 #. type: defun
 #: original_texis/lists.texi:762
@@ -2671,7 +2671,7 @@ msgstr "memql object list"
 #. type: defun
 #: original_texis/lists.texi:1407
 msgid "The function @code{memql} tests to see whether @var{object} is a member of @var{list}, comparing members with @var{object} using @code{eql}, so floating-point elements are compared by value.  If @var{object} is a member, @code{memql} returns a list starting with its first occurrence in @var{list}.  Otherwise, it returns @code{nil}."
-msgstr "関数@code{memql}は@code{eql}(浮動少数点数の要素は値で比較される)を使用してメンバーと@code{eql}を比較することにより、@var{object}が@var{list}のメンバーかどうかをテストする。@var{object}がメンバーなら、@code{memql}は@var{list}内で最初に見つかった要素から始まるリスト、それ以外なら@code{nil}をリターンする。"
+msgstr "関数@code{memql}は@code{eql}(浮動小数点数の要素は値で比較される)を使用してメンバーと@code{eql}を比較することにより、@var{object}が@var{list}のメンバーかどうかをテストする。@var{object}がメンバーなら、@code{memql}は@var{list}内で最初に見つかった要素から始まるリスト、それ以外なら@code{nil}をリターンする。"
 
 #. type: defun
 #: original_texis/lists.texi:1409 original_texis/lists.texi:1433
@@ -2900,7 +2900,7 @@ msgstr "alist"
 #. type: Plain text
 #: original_texis/lists.texi:1550
 msgid "An @dfn{association list}, or @dfn{alist} for short, records a mapping from keys to values.  It is a list of cons cells called @dfn{associations}: the @sc{car} of each cons cell is the @dfn{key}, and the @sc{cdr} is the @dfn{associated value}.@footnote{This usage of ``key'' is not related to the term ``key sequence''; it means a value used to look up an item in a table.  In this case, the table is the alist, and the alist associations are the items.}"
-msgstr "@dfn{連想配列(association list、短くはalist)}は、キーと値のマッピングを記録します。これは@dfn{連想(associations)}と呼ばれるコンスセルのリストです。各コンスセルにおいて@sc{car}は@dfn{キー(key)}で、@sc{cdr}は@dfn{連想値(associated value)}となります。@footnote{ここでの``キー(key)''の使い方は、用語``キーシーケンス(key sequence)''とは関係ありません。キーはテーブルにあるアイテムを探すために使用される値という意味です。この場合、テーブルはalistでありalistはアイテムに関連付けられます。}"
+msgstr "@dfn{連想リスト(association list、短くはalist)}は、キーと値のマッピングを記録します。これは@dfn{連想(associations)}と呼ばれるコンスセルのリストです。各コンスセルにおいて@sc{car}は@dfn{キー(key)}で、@sc{cdr}は@dfn{連想値(associated value)}となります。@footnote{ここでの``キー(key)''の使い方は、用語``キーシーケンス(key sequence)''とは関係ありません。キーはテーブルにあるアイテムを探すために使用される値という意味です。この場合、テーブルはalistでありalistはアイテムに関連付けられます。}"
 
 #. type: Plain text
 #: original_texis/lists.texi:1554
@@ -2922,7 +2922,7 @@ msgstr ""
 #. type: Plain text
 #: original_texis/lists.texi:1568
 msgid "Both the values and the keys in an alist may be any Lisp objects.  For example, in the following alist, the symbol @code{a} is associated with the number @code{1}, and the string @code{\"b\"} is associated with the @emph{list} @code{(2 3)}, which is the @sc{cdr} of the alist element:"
-msgstr "alist内の値とキーには、任意のLispオブジェクトを指定できます。たとえば以下のalist0では、シンボル@code{a}は数字@code{1}、文字列@code{\"b\"}は@emph{リスト}@code{(2 3)}(alist要素の@sc{cdr})に関連付けられます。"
+msgstr "alist内の値とキーには、任意のLispオブジェクトを指定できます。たとえば以下のalistでは、シンボル@code{a}は数字@code{1}、文字列@code{\"b\"}は@emph{リスト}@code{(2 3)}(alist要素の@sc{cdr})に関連付けられます。"
 
 #. type: example
 #: original_texis/lists.texi:1571
@@ -2975,7 +2975,7 @@ msgstr "assoc key alist &optional testfn"
 #. type: defun
 #: original_texis/lists.texi:1619
 msgid "This function returns the first association for @var{key} in @var{alist}, comparing @var{key} against the alist elements using @var{testfn} if it is a function, and @code{equal} otherwise (@pxref{Equality Predicates}).  If @var{testfn} is a function, it is called with two arguments: the @sc{car} of an element from @var{alist} and @var{key}.  The function returns @code{nil} if no association in @var{alist} has a @sc{car} equal to @var{key}, as tested by @var{testfn}.  For example:"
-msgstr "この関数はalist要素にたいして@var{testfn}が関数なら@var{testfn}、それ以外なら@code{equal}を使用して、@var{alist}内から@var{key}をもつ最初の連想をリターンする。@var{testfn}が関数の場合には@var{alist}の要素の@sc{car}、@var{key}とおう2つの引数で呼び出される。@var{testfn}でテストした結果、@sc{car}が@var{key}と一致する連想が@var{alist}になければ、この関数は@code{nil}をリターンする。たとえば:"
+msgstr "この関数はalist要素にたいして@var{testfn}が関数なら@var{testfn}、それ以外なら@code{equal}を使用して、@var{alist}内から@var{key}をもつ最初の連想をリターンする。@var{testfn}が関数の場合には@var{alist}の要素の@sc{car}と@var{key}の2つの引数で呼び出される。@var{testfn}でテストした結果、@sc{car}が@var{key}と一致する連想が@var{alist}になければ、この関数は@code{nil}をリターンする。たとえば:"
 
 #. type: smallexample
 #: original_texis/lists.texi:1629
@@ -3127,7 +3127,7 @@ msgstr "この関数は@code{assq}と似ている。これは@var{alist}の要
 #. type: defun
 #: original_texis/lists.texi:1705
 msgid "This is a generalized variable (@pxref{Generalized Variables})  that can be used to change a value with @code{setf}.  When using it to set a value, optional argument @var{remove} non-@code{nil} means to remove @var{key}'s association from @var{alist} if the new value is @code{eql} to @var{default}."
-msgstr "これは@code{setf}での値の変更に使用できる汎変数(@ref{Generalized Variables}を参照)。値の値へのセットにこれを使用する際にオプション引数@var{remove}が@code{nil}の場合は、新たな値が@var{default}と@code{eql}なら@var{alist}から@var{key}の連想を削除することを意味する。"
+msgstr "これは@code{setf}での値の変更に使用できる汎変数(@ref{Generalized Variables}を参照)である。値の設定にこれを使用する際にオプション引数@var{remove}が@code{nil}の場合は、新たな値が@var{default}と@code{eql}なら@var{alist}から@var{key}の連想を削除することを意味する。"
 
 #. type: defun
 #: original_texis/lists.texi:1707
@@ -3224,7 +3224,7 @@ msgstr "alistの要素がこの条件により@var{key}とマッチすると、@
 #. type: defun
 #: original_texis/lists.texi:1763
 msgid "If no alist element matches @var{key}, @code{assoc-default} returns @code{nil}."
-msgstr "@var{key}にマッチする要素がalistに存在しないければ、@code{assoc-default}は@code{nil}をリターンする。"
+msgstr "@var{key}にマッチする要素がalistに存在しないなら、@code{assoc-default}は@code{nil}をリターンする。"
 
 #. type: defun
 #: original_texis/lists.texi:1765
@@ -3328,7 +3328,7 @@ msgstr ""
 #. type: defun
 #: original_texis/lists.texi:1806
 msgid "This example shows how @code{copy-alist} makes it possible to change the associations of one copy without affecting the other:"
-msgstr "以下の例は、どのようにして@code{copy-alist}が他に影響を与えずにコピーの連想を変更可能なのかを示す:"
+msgstr "以下の例は、@code{copy-alist}を使用して、他方のコピーへの影響なしに一方のコピーの連想を変更することが可能である方法を示す:"
 
 #. type: group
 #: original_texis/lists.texi:1812
diff --git a/lispref/minibuf.texi.po b/lispref/minibuf.texi.po
index 3951c57..17561c2 100644
--- a/lispref/minibuf.texi.po
+++ b/lispref/minibuf.texi.po
@@ -1694,7 +1694,7 @@ msgstr "この関数はポイントの前のテキストが@var{string}、ポイ
 #. type: defun
 #: original_texis/minibuf.texi:1034
 msgid "Normally completion operates on the whole string, so for all normal collections, this will always return @code{(0 . (length @var{suffix}))}.  But more complex completion, such as completion on files, is done one field at a time.  For example, completion of @code{\"/usr/sh\"} will include @code{\"/usr/share/\"} but not @code{\"/usr/share/doc\"} even if @code{\"/usr/share/doc\"} exists.  Also @code{all-completions} on @code{\"/usr/sh\"} will not include @code{\"/usr/share/\"} but only @code{\"share/\"}.  So if @var{string} is @code{\"/usr/sh\"} and @var{suffix} is @code{\"e/doc\"}, @code{completion-boundaries} will return @w{@code{(5 . 1)}} which tells us that the @var{collection} will only return completion information that pertains to the area after @code{\"/usr/\"} and before @code{\"/doc\"}.  @code{try-completion} is not affected by nontrivial boundaries; e.g., @code{try-completion} on @code{\"/usr/sh\"} might still return @code{\"/usr/share/\"}, not @code{\"share/\"}."
-msgstr "補完は通常は文字列(string)全体に作用するので、すべての普通のコレクション(collection)にたいして、この関数は常に@code{(0 . (length @var{suffix}))}をリターンするだろう。しかしファイルにたいする補完などの、より複雑な補完は1回に1フィールド行われる。たとえばたとえ@code{\"/usr/share/doc\"}が存在しても、@code{\"/usr/sh\"}の補完に@code{\"/usr/share/\"}は含まれるが、@code{\"/usr/share/doc\"}は含まれないだろう。また@code{\"/usr/sh\"}にたいする@code{all-completions}に@code{\"/usr/share/\"}は含まれず、@code{\"share/\"}だけが含まれるだろう。@var{string}が@code{\"/usr/sh\"}、@var{suffix}が@code{\"e/doc\"}なら、@code{completion-boundaries}は@w{@code{(5 . 1)}}をリターンするだろう。これは@var{collection}が@code{\"/usr/\"}の後ろにあり@code{\"/doc\"}の前にある領域に関する補完情報だけをリターンするであろうことを告げている。@code{try-completion}は意味のある境界に影響されない。すなわち@code{\\\"/usr/sh\\\"}にたいして@code{try-completion}は@code{\\\"share/\\\"}ではなく、依然として@code{\\\"/usr/share/\\\"}をリターンする。"
+msgstr "補完は通常は文字列(string)全体に作用するので、すべての普通のコレクション(collection)にたいして、この関数は常に@code{(0 . (length @var{suffix}))}をリターンするだろう。しかしファイルにたいする補完などの、より複雑な補完は1回に1フィールド行われる。たとえばたとえ@code{\"/usr/share/doc\"}が存在しても、@code{\"/usr/sh\"}の補完に@code{\"/usr/share/\"}は含まれるが、@code{\"/usr/share/doc\"}は含まれないだろう。また@code{\"/usr/sh\"}にたいする@code{all-completions}に@code{\"/usr/share/\"}は含まれず、@code{\"share/\"}だけが含まれるだろう。@var{string}が@code{\"/usr/sh\"}、@var{suffix}が@code{\"e/doc\"}なら、@code{completion-boundaries}は@w{@code{(5 . 1)}}をリターンするだろう。これは@var{collection}が@code{\"/usr/\"}の後ろにあり@code{\"/doc\"}の前にある領域に関する補完情報だけをリターンするであろうことを告げている。@code{try-completion}は意味のある境界に影響されない。すなわち@code{\"/usr/sh\"}にたいして@code{try-completion}は@code{\"share/\"}ではなく、依然として@code{\"/usr/share/\"}をリターンする。"
 
 #. type: Plain text
 #: original_texis/minibuf.texi:1039
@@ -2931,7 +2931,7 @@ msgstr "metadata"
 #. type: table
 #: original_texis/minibuf.texi:1953
 msgid "This specifies a request for information about the state of the current completion.  The return value should have the form @code{(metadata . @var{alist})}, where @var{alist} is an alist whose elements are described below."
-msgstr "カレント補完の状態に関する情報の要求を指定する。リターン値は@code{(metadata . @var{alist})}の形式をもち、@var{alist}は以下で説明する要素をもつ連想配列。"
+msgstr "カレント補完の状態に関する情報の要求を指定する。リターン値は@code{(metadata . @var{alist})}の形式をもち、@var{alist}は以下で説明する要素をもつ連想リスト。"
 
 #. type: itemize
 #: original_texis/minibuf.texi:1958
diff --git a/lispref/modes.texi.po b/lispref/modes.texi.po
index 8ec19ee..f6c5c0d 100644
--- a/lispref/modes.texi.po
+++ b/lispref/modes.texi.po
@@ -1035,7 +1035,7 @@ msgstr "auto-mode-alist"
 #. type: defvar
 #: original_texis/modes.texi:733
 msgid "This variable contains an association list of file name patterns (regular expressions) and corresponding major mode commands.  Usually, the file name patterns test for suffixes, such as @samp{.el} and @samp{.c}, but this need not be the case.  An ordinary element of the alist looks like @code{(@var{regexp} .  @var{mode-function})}."
-msgstr "この変数はファイル名パターン(正規表現)と対応するメジャーモードコマンドの連想配列を含む。ファイル名パターンは通常は@samp{.el}や@samp{.c}のようなサフィックスをテストするが必須ではない。このalistの通常の要素は@code{(@var{regexp} .  @var{mode-function})}のようになる。"
+msgstr "この変数はファイル名パターン(正規表現)と対応するメジャーモードコマンドの連想リストを含む。ファイル名パターンは通常は@samp{.el}や@samp{.c}のようなサフィックスをテストするが必須ではない。このalistの通常の要素は@code{(@var{regexp} .  @var{mode-function})}のようになる。"
 
 #. type: table
 #: original_texis/modes.texi:735 original_texis/modes.texi:3186
@@ -7555,7 +7555,7 @@ msgstr "(desktop-file-name @var{file-name} @var{desktop-dirname})\n"
 #. type: Plain text
 #: original_texis/modes.texi:5078
 msgid "For buffers not visiting a file to be restored, the major mode must define a function to do the job, and that function must be listed in the alist @code{desktop-buffer-mode-handlers}."
-msgstr "ファイルをvisitしていないバッファーがリストアされるようにするには、メジャーモードがその処理を行う関数を定義しなければならず、その関数は連想配列@code{desktop-buffer-mode-handlers}にリストされなければならない。"
+msgstr "ファイルをvisitしていないバッファーがリストアされるようにするには、メジャーモードがその処理を行う関数を定義しなければならず、その関数は連想リスト@code{desktop-buffer-mode-handlers}にリストされなければならない。"
 
 #. type: defvar
 #: original_texis/modes.texi:5079
diff --git a/lispref/nonascii.texi.po b/lispref/nonascii.texi.po
index 61a3dfe..a7faace 100644
--- a/lispref/nonascii.texi.po
+++ b/lispref/nonascii.texi.po
@@ -1030,7 +1030,7 @@ msgstr "special-lowercase"
 #. type: table
 #: original_texis/nonascii.texi:642
 msgid "Corresponds to Unicode language- and context-independent special lower-casing rules.  The value of this property is a string (which may be empty).  For example mapping for U+0130 @sc{latin capital letter i with dot above} the value is @code{\"i\\u0307\"} (i.e. 2-character string consisting of @sc{latin small letter i} followed by U+0307 @sc{combining dot above}).  For characters with no special mapping, the value is @code{nil} which means @code{lowercase} property needs to be consulted instead."
-msgstr "Unicodeの言語やコンテキストに依存しない特別な小文字caseルールに対応する。このプロパティの値は文字列(空も可)。たとえばU+0130 @sc{latin capital letter i with dot above}にたいするマッピングは@code{\"SS\"}。特別なマッピングのない文字にたいする値は@code{nil} (かわりに@code{lowercase}プロパティの照会が必要なことを意味する)。"
+msgstr "Unicodeの言語やコンテキストに依存しない特別な小文字caseルールに対応する。このプロパティの値は文字列(空も可)。たとえばU+0130 @sc{latin capital letter i with dot above}にたいするマッピングは@code{\"i\\u0307\"} (すなわち@sc{latin small letter i}の後にU+0307 @sc{combining dot above}が続くことによって構成される2文字の文字列)。特別なマッピングのない文字にたいする値は@code{nil} (かわりに@code{lowercase}プロパティの照会が必要なことを意味する)。"
 
 #. type: item
 #: original_texis/nonascii.texi:643
diff --git a/lispref/numbers.texi.po b/lispref/numbers.texi.po
index 3b6dac6..ee9f872 100644
--- a/lispref/numbers.texi.po
+++ b/lispref/numbers.texi.po
@@ -7,7 +7,7 @@ msgid ""
 msgstr ""
 "Project-Id-Version: Emacs 26.1\n"
 "POT-Creation-Date: 2022-12-01 02:55+0900\n"
-"PO-Revision-Date: 2021-08-09 20:44+0900\n"
+"PO-Revision-Date: 2023-08-21 18:12+0900\n"
 "Last-Translator: Takeshi Ayanokoji <takeshi.ayanokoji@gmail.com>\n"
 "Language-Team: Japanese <takeshi.ayanokoji@gmail.com>\n"
 "Language: ja\n"
@@ -59,7 +59,7 @@ msgstr "Float Basics"
 #. type: menuentry
 #: original_texis/numbers.texi:32
 msgid "Representation and range of floating point."
-msgstr "浮動少数の表現と範囲。"
+msgstr "浮動小数の表現と範囲。"
 
 #. type: node
 #: original_texis/numbers.texi:32 original_texis/numbers.texi:342
@@ -459,23 +459,23 @@ msgstr "integer-width"
 #. type: defvar
 #: original_texis/numbers.texi:204
 msgid "The value of this variable is a nonnegative integer that controls whether Emacs signals a range error when a large integer would be calculated.  Integers with absolute values less than"
-msgstr "この変数の値は大きな整数えお計算時にEmacsが範囲エラー(range error)をシグナルするかどうかを制御する負ではない整数。絶対値が"
+msgstr "この変数の値は大きな整数の計算時にEmacsが範囲エラー(range error)をシグナルするかどうかを制御する負ではない整数。絶対値が"
 
 #. type: ifnottex
 #: original_texis/numbers.texi:206
 msgid "2**@var{n},"
-msgstr "2**@var{n},"
+msgstr "2**@var{n}"
 
 #. type: tex
 #: original_texis/numbers.texi:209
 #, no-wrap
 msgid "@math{2^{n}},\n"
-msgstr "@math{2^{n}},\n"
+msgstr "@math{2^{n}}\n"
 
 #. type: defvar
 #: original_texis/numbers.texi:215
 msgid "where @var{n} is this variable's value, do not signal a range error.  Attempts to create larger integers typically signal a range error, although there might be no signal if a larger integer can be created cheaply.  Setting this variable to a large number can be costly if a computation creates huge integers."
-msgstr "(@var{n}はこの変数の値)が小さい整数は範囲エラーをシグナルしない。大きい整数を簡単に作成できればエラーがシグナルされない場合もあるが、通常は大きな整数の作成を試みると範囲エラーをシグナルする。この変数に大きな数値を設定すると、巨大な整数の計算にコストを要する可能性がある。"
+msgstr "(@var{n}はこの変数の値)より小さい整数の時は範囲エラーをシグナルしない。大きい整数を簡単に作成できればエラーがシグナルされない場合もあるが、通常は大きな整数の作成を試みると範囲エラーをシグナルする。この変数に大きな数値を設定すると、巨大な整数の計算にコストを要する可能性がある。"
 
 #. type: section
 #: original_texis/numbers.texi:218
@@ -492,7 +492,7 @@ msgstr "@acronym{IEEE} floating point"
 #. type: Plain text
 #: original_texis/numbers.texi:233
 msgid "Floating-point numbers are useful for representing numbers that are not integral.  The range of floating-point numbers is the same as the range of the C data type @code{double} on the machine you are using.  On all computers supported by Emacs, this is @acronym{IEEE} binary64 floating point format, which is standardized by @url{https://standards.ieee.org/standard/754-2019.html,,IEEE Std 754-2019} and is discussed further in David Goldberg's paper ``@url{https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html, What Every Computer Scientist Should Know About Floating-Point Arithmetic}''.  On modern platforms, floating-point operations follow the IEEE-754 standard closely; however, results are not always rounded correctly on some obsolescent platforms, notably 32-bit x86."
-msgstr "浮動小数点数は整数以外の数値の表現に有用です。浮動小数点数の範囲は使用中のシンでのCのデータ型@code{double}と同じ範囲です。Emacsがサポートするすべてのコンピューターでは@acronym{IEEE}の64ビット浮動小数フォーマットであり、これは@url{https://standards.ieee.org/standard/754-2019.html,,IEEE Std 754-2019}で標準化されたもので、David Goldbergの論文``@url{https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html, What Every Computer Scientist Should Know About Floating-Point Arithmetic}''で更に議論されています。モダンなプラットフォームでは浮動小数処理はIEEE-754標準に厳密にしたがいますが、特に32ビットX86のような陳腐化したプラットフォームでは丸めは常に正しい訳ではありません。"
+msgstr "浮動小数点数は整数以外の数値の表現に有用です。浮動小数点数の範囲は使用中のマシンでのCのデータ型@code{double}と同じ範囲です。Emacsがサポートするすべてのコンピューターでは@acronym{IEEE}の64ビット浮動小数フォーマットであり、これは@url{https://standards.ieee.org/standard/754-2019.html,,IEEE Std 754-2019}で標準化されたもので、David Goldbergの論文``@url{https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html, What Every Computer Scientist Should Know About Floating-Point Arithmetic}''で更に議論されています。モダンなプラットフォームでは浮動小数処理はIEEE-754標準に厳密にしたがいますが、特に32ビットX86のような陳腐化したプラットフォームでは丸めは常に正しい訳ではありません。"
 
 #. type: Plain text
 #: original_texis/numbers.texi:243
@@ -649,7 +649,7 @@ msgstr "logb x"
 #. type: defun
 #: original_texis/numbers.texi:331
 msgid "This function returns the binary exponent of @var{x}.  More precisely, if @var{x} is finite and nonzero, the value is the logarithm base 2 of @math{|x|}, rounded down to an integer.  If @var{x} is zero or infinite, the value is infinity; if @var{x} is a NaN, the value is a NaN."
-msgstr "この関数は@var{x}の2進指数をリターンする。より正確には@var{x}が有限かつ非0なら@math{|x|}の2を底とする対数を整数に切り下げた値。@var{x}が0または無限なら値は無限大。@var{x}がNaなら値はNaN。"
+msgstr "この関数は@var{x}の2進指数をリターンする。より正確には@var{x}が有限かつ非0なら@math{|x|}の2を底とする対数を整数に切り下げた値。@var{x}が0または無限なら値は無限大。@var{x}がNaNなら値はNaN。"
 
 #. type: example
 #: original_texis/numbers.texi:339
@@ -756,7 +756,7 @@ msgstr "natural numbers"
 #. type: defun
 #: original_texis/numbers.texi:386
 msgid "This predicate (whose name comes from the phrase ``natural number'')  tests to see whether its argument is a nonnegative integer, and returns @code{t} if so, @code{nil} otherwise.  0 is considered non-negative."
-msgstr "この述語は引数が正の整数かどうかをテストしてもしそうなら@code{t}、それ以外は@code{nil}をリターンする(名前は``natural numberl: 自然数''が由来)。0は整数と判断される。"
+msgstr "この述語は引数が正の整数かどうかをテストしてもしそうなら@code{t}、それ以外は@code{nil}をリターンする(名前は``natural number: 自然数''が由来)。0は負でないと判断される。"
 
 #. type: findex
 #: original_texis/numbers.texi:387
@@ -810,7 +810,7 @@ msgstr "Emacs Lispでは2つのfixnumが数値的に等しければ同一のLisp
 #. type: Plain text
 #: original_texis/numbers.texi:428
 msgid "Sometimes it is useful to compare numbers with @code{eql} or @code{equal}, which treat two numbers as equal if they have the same data type (both integers, or both floating point) and the same value.  By contrast, @code{=} can treat an integer and a floating-point number as equal.  @xref{Equality Predicates}."
-msgstr "数の比較において、2つの数が同じデータ型(どちらも整数か浮動小数)では、同じ値の場合は等しい数として扱う@code{eql}や@code{equal}のほうが便利なときもあります。対照的に@code{=}は整数と浮動小数点数を等しい数と扱うことができます。@ref{Equality Predicates}を参照してください。"
+msgstr "数の比較において、2つの数が同じデータ型(どちらも整数であるかどちらも浮動小数であるか)で同じ値の場合は等しい数として扱う@code{eql}や@code{equal}のほうが便利なときもあります。対照的に@code{=}は整数と浮動小数点数を(訳注:同じ値の場合には)等しい数と扱うことができます。@ref{Equality Predicates}を参照してください。"
 
 #. type: Plain text
 #: original_texis/numbers.texi:433
@@ -855,7 +855,7 @@ msgstr "eql value1 value2"
 #. type: defun
 #: original_texis/numbers.texi:458
 msgid "This function acts like @code{eq} except when both arguments are numbers.  It compares numbers by type and numeric value, so that @code{(eql 1.0 1)} returns @code{nil}, but @code{(eql 1.0 1.0)} and @code{(eql 1 1)} both return @code{t}.  This can be used to compare large integers as well as small ones.  Floating-point values with the same sign, exponent and fraction are @code{eql}.  This differs from numeric comparison: @code{(eql 0.0 -0.0)} returns @code{nil} and @code{(eql 0.0e+NaN 0.0e+NaN)} returns @code{t}, whereas @code{=} does the opposite."
-msgstr "この関数は@code{eq}と同様に振る舞うが引数が両方とも数のときを除く。これは数を型と数値的な値により比較するので@code{(eql 1.0 1)}は@code{nil}をリターンするが、@code{(eql 1.0 1.0)}と@code{(eql 1 1)}は@code{t}をリターンする。これは小さい整数と同様に大きい整数の比較に使用できる。符号、指数部、少数部が同じ浮動小数点数は@code{eql}であり、これは数値の比較とは異なる。@code{(eql 0.0 -0.0)}は@code{nil}、@code{(eql 0.0e+NaN 0.0e+NaN)}は@code{t}をリターンするが、これは@code{=}の動作とは逆である。"
+msgstr "この関数は@code{eq}と同様に振る舞うが引数が両方とも数のときを除く。これは数を型と数値的な値により比較するので@code{(eql 1.0 1)}は@code{nil}をリターンするが、@code{(eql 1.0 1.0)}と@code{(eql 1 1)}は@code{t}をリターンする。これは小さい整数と同様に大きい整数の比較に使用できる。符号、指数部、小数部が同じ浮動小数点数は@code{eql}であり、これは数値の比較とは異なる。@code{(eql 0.0 -0.0)}は@code{nil}、@code{(eql 0.0e+NaN 0.0e+NaN)}は@code{t}をリターンするが、これは@code{=}の動作とは逆である。"
 
 #. type: defun
 #: original_texis/numbers.texi:460
@@ -994,7 +994,7 @@ msgstr "converting numbers"
 #. type: Plain text
 #: original_texis/numbers.texi:518
 msgid "To convert an integer to floating point, use the function @code{float}."
-msgstr "整数を浮動少数の変換には関数@code{float}を使用します。"
+msgstr "整数の浮動小数への変換には関数@code{float}を使用します。"
 
 #. type: defun
 #: original_texis/numbers.texi:519
@@ -1599,7 +1599,7 @@ msgstr "rounding without conversion"
 #. type: Plain text
 #: original_texis/numbers.texi:842
 msgid "The functions @code{ffloor}, @code{fceiling}, @code{fround}, and @code{ftruncate} take a floating-point argument and return a floating-point result whose value is a nearby integer.  @code{ffloor} returns the nearest integer below; @code{fceiling}, the nearest integer above; @code{ftruncate}, the nearest integer in the direction towards zero; @code{fround}, the nearest integer."
-msgstr "関数@code{ffloor}、@code{fceiling}、@code{fround}、@code{ftruncate}は浮動小数の引数をとり、値が近くの整数であるような浮動少数をリターンします。@code{ffloor}は一番近い下方の整数、@code{fceiling}は一番近い上方の整数、@code{ftruncate}は0に向かう方向で一番近い整数、@code{fround}は一番近い整数をリターンします。"
+msgstr "関数@code{ffloor}、@code{fceiling}、@code{fround}、@code{ftruncate}は浮動小数の引数をとり、値が近くの整数であるような浮動小数をリターンします。@code{ffloor}は一番近い下方の整数、@code{fceiling}は一番近い上方の整数、@code{ftruncate}は0に向かう方向で一番近い整数、@code{fround}は一番近い整数をリターンします。"
 
 #. type: defun
 #: original_texis/numbers.texi:843
@@ -1666,7 +1666,7 @@ msgstr "logical arithmetic"
 #. type: Plain text
 #: original_texis/numbers.texi:876
 msgid "In a computer, an integer is represented as a binary number, a sequence of @dfn{bits} (digits which are either zero or one).  Conceptually the bit sequence is infinite on the left, with the most-significant bits being all zeros or all ones.  A bitwise operation acts on the individual bits of such a sequence.  For example, @dfn{shifting} moves the whole sequence left or right one or more places, reproducing the same pattern moved over."
-msgstr "コンピューターの中では、整数は@dfn{ビット(bit: 0か1の数字)}のシーケンスである2進数で表されます。ビットシーケンスは概念的には最上位ビットがすべて0か1であるような左側に無限なシ0ケンスです。ビット演算はそのようなシーケンスの中の個々のビットに作用します。たとえば@dfn{シフト(shifting)}はシーケンス全体を1つ以上左または右に移動して、移動されたのと同じパターンを再現します。"
+msgstr "コンピューターの中では、整数は@dfn{ビット(bit: 0か1の数字)}のシーケンスである2進数で表されます。ビットシーケンスは概念的には最上位ビットがすべて0か1であるような左側に無限なシーケンスです。ビット演算はそのようなシーケンスの中の個々のビットに作用します。たとえば@dfn{シフト(shifting)}はシーケンス全体を1つ以上左または右に移動して、移動されたのと同じパターンを再現します。"
 
 #. type: Plain text
 #: original_texis/numbers.texi:878
@@ -1688,7 +1688,7 @@ msgstr "arithmetic shift"
 #. type: defun
 #: original_texis/numbers.texi:886
 msgid "@code{ash} (@dfn{arithmetic shift}) shifts the bits in @var{integer1} to the left @var{count} places, or to the right if @var{count} is negative.  Left shifts introduce zero bits on the right; right shifts discard the rightmost bits.  Considered as an integer operation, @code{ash} multiplies @var{integer1} by"
-msgstr "@code{ash} (@dfn{算術シフト(arithmetic shift)})は、@var{integer1}の中のビット位置を左に@var{count}シフトする。@var{count}が負なら右にシフトする。左シフトでは右側に0が挿入されて、右シフトでは最右ビットが破棄される。整数処理として考えると、@code{ash}は@var{integer1}を"
+msgstr "@code{ash} (@dfn{算術シフト(arithmetic shift)})は、@var{integer1}の中のビット位置を左に@var{count}シフトする。@var{count}が負なら右にシフトする。左シフトでは右側に0が挿入されて、右シフトでは最右ビットが破棄される。整数処理として考えると、@code{ash}は@var{integer1}に"
 
 #. type: ifnottex
 #: original_texis/numbers.texi:888
@@ -1704,12 +1704,12 @@ msgstr "@math{2^{count}}\n"
 #. type: defun
 #: original_texis/numbers.texi:894
 msgid "and then converts the result to an integer by rounding downward, toward minus infinity."
-msgstr "乗じてから下方、負の無限大に向かって丸めることにより結果を変換する。"
+msgstr "を乗じてから、負の無限大に向かって丸めることによりその結果を変換する。"
 
 #. type: defun
 #: original_texis/numbers.texi:901
 msgid "Here are examples of @code{ash}, shifting a pattern of bits one place to the left and to the right.  These examples show only the low-order bits of the binary pattern; leading bits all agree with the highest-order bit shown.  As you can see, shifting left by one is equivalent to multiplying by two, whereas shifting right by one is equivalent to dividing by two and then rounding toward minus infinity."
-msgstr "以下はビットパターンを1ビット左にシフトしてから右にシフトする例。この例で2進数パターンの下位ビットだけを示している。先行ビットは表示されている上位ビットにすべて一致する。確認できるように1ビットの左シフトは2を乗じて、右シフトは2で除してから負の無限大方向に丸められる。"
+msgstr "以下はビットパターンを1ビット左にシフトしてから右にシフトする例。この例で2進数パターンの下位ビットだけを示している。先頭ビットはすべて表示されている最上位ビットと一致する。ご覧のとおり1ビットの左シフトは2を乗ずること、1ビットの右シフトは2で除してから負の無限大方向に丸められることと等価である。"
 
 #. type: group
 #: original_texis/numbers.texi:909
@@ -1825,7 +1825,7 @@ msgstr "logical shift"
 #. type: defun
 #: original_texis/numbers.texi:965
 msgid "@code{lsh}, which is an abbreviation for @dfn{logical shift}, shifts the bits in @var{integer1} to the left @var{count} places, or to the right if @var{count} is negative, bringing zeros into the vacated bits.  If @var{count} is negative, then @var{integer1} must be either a fixnum or a positive bignum, and @code{lsh} treats a negative fixnum as if it were unsigned by subtracting twice @code{most-negative-fixnum} before shifting, producing a nonnegative result.  This quirky behavior dates back to when Emacs supported only fixnums; nowadays @code{ash} is a better choice."
-msgstr "@code{lsh}は@dfn{logical shift}の略で、@var{integer1}のビットを左に@var{count}シフトする。@var{count}が負なら@var{integer1}はfixnumか正のbignumのいずれかでなければならず、@code{lsh}はシフト前に負のfixnumを@code{most-negative-fixnum}で2回減算してあたかも符号なしであるかのように非負の結果を生成する。この奇妙な振る舞いはEmacsがfixnumsだけをサポートしていた頃の振る舞いであり、現在では@code{ash}がより良い選択である。"
+msgstr "@code{lsh}は@dfn{logical shift}の略で、@var{integer1}のビットを左に@var{count}回シフト(@var{count}が負なら右にシフト、空いたビットには0を補填)する。@var{count}が負なら@var{integer1}はfixnumか正のbignumのいずれかでなければならず、@code{lsh}はシフト前に負のfixnumを@code{most-negative-fixnum}で2回減算してあたかも符号なしであるかのように非負の結果を生成する。この奇妙な振る舞いはEmacsがfixnumsだけをサポートしていた頃の振る舞いであり、現在では@code{ash}がより良い選択である。"
 
 #. type: defun
 #: original_texis/numbers.texi:969
@@ -1896,7 +1896,7 @@ msgstr ""
 #. type: defun
 #: original_texis/numbers.texi:1013
 msgid "If @code{logand} is not passed any argument, it returns a value of @minus{}1.  This number is an identity element for @code{logand} because its binary representation consists entirely of ones.  If @code{logand} is passed just one argument, it returns that argument."
-msgstr "@code{logand}に何も引数も渡さなければ、値@minus{}1がリターンされる。@minus{}1を2進数で表すとすべてのビットが1なので、@minus{}1は@code{logand}にたいする単位元(identity element)である。"
+msgstr "@code{logand}に何も引数も渡さなければ、値@minus{}1がリターンされる。@minus{}1を2進数で表すとすべてのビットが1なので、@minus{}1は@code{logand}にたいする単位元(identity element)である。@code{logand}に渡す引数が1つだけならその引数がリターンされる。"
 
 #. type: group
 #: original_texis/numbers.texi:1017 original_texis/numbers.texi:1047
@@ -2258,7 +2258,7 @@ msgstr "expt x y"
 #. type: defun
 #: original_texis/numbers.texi:1206
 msgid "This function returns @var{x} raised to power @var{y}.  If both arguments are integers and @var{y} is nonnegative, the result is an integer; in this case, overflow signals an error, so watch out.  If @var{x} is a finite negative number and @var{y} is a finite non-integer, @code{expt} returns a NaN."
-msgstr "この関数は@var{x}に@var{y}を乗じてリターンする。引数が両方とも整数で@var{y}が非負なら結果は整数になる。この場合オーバーフローはエラーをシグナルするので注意。@var{x}が有限の負数で@var{y}が有限の非整数なら、@code{expt}はNaNをリターンする。"
+msgstr "この関数は@var{x}の@var{y}乗をリターンする。引数が両方とも整数で@var{y}が非負なら結果は整数になる。この場合オーバーフローはエラーをシグナルするので注意。@var{x}が有限の負数で@var{y}が有限の非整数なら、@code{expt}はNaNをリターンする。"
 
 #. type: defun
 #: original_texis/numbers.texi:1208
diff --git a/lispref/objects.texi.po b/lispref/objects.texi.po
index b59973a..9f811c9 100644
--- a/lispref/objects.texi.po
+++ b/lispref/objects.texi.po
@@ -960,7 +960,7 @@ msgstr "?Q @result{} 81     ?q @result{} 113\n"
 #. type: Plain text
 #: original_texis/objects.texi:377
 msgid "You can use the same syntax for punctuation characters.  However, if the punctuation character has a special syntactic meaning in Lisp, you must quote it with a @samp{\\}.  For example, @samp{?\\(} is the way to write the open-paren character.  Likewise, if the character is @samp{\\}, you must use a second @samp{\\} to quote it: @samp{?\\\\}."
-msgstr "区切り文字(punctuation characters)にも同じ構文を使用できますが、区切り文字がLispで特別な意味をもつ場合には@samp{\\\\}でクォートしなければなりません。たとえば@samp{?\\\\(}が開カッコを記述する方法であり、同様に文字が@samp{\\}なら、@samp{?\\\\}のようにクォートするために2つ目の@samp{\\}を使用しなければなりません。"
+msgstr "区切り文字(punctuation characters)にも同じ構文を使用できますが、区切り文字がLispで特別な意味をもつ場合には@samp{\\}でクォートしなければなりません。たとえば@samp{?\\(}が開カッコを記述する方法であり、同様に文字が@samp{\\}なら、@samp{?\\\\}のようにクォートするために2つ目の@samp{\\}を使用しなければなりません。"
 
 #. type: cindex
 #: original_texis/objects.texi:378
@@ -1301,7 +1301,7 @@ msgstr "2**7"
 #. type: Plain text
 #: original_texis/objects.texi:575
 msgid "bit attached to an @acronym{ASCII} character indicates a meta character; thus, the meta characters that can fit in a string have codes in the range from 128 to 255, and are the meta versions of the ordinary @acronym{ASCII} characters.  @xref{Strings of Events}, for details about @key{META}-handling in strings."
-msgstr "ビットが付加されます。したがって文字列に含めることができるメタ文字のコードは1から255の範囲となり、メタ文字は通常の@acronym{ASCII}文字のメタ修飾されたバージョンとなります。文字列内での@key{META}処理の詳細については、@ref{Strings of Events}を参照してください。"
+msgstr "ビットが付加されます。したがって文字列に含めることができるメタ文字のコードは128から255の範囲となり、メタ文字は通常の@acronym{ASCII}文字のメタ修飾されたバージョンとなります。文字列内での@key{META}処理の詳細については、@ref{Strings of Events}を参照してください。"
 
 #. type: Plain text
 #: original_texis/objects.texi:582
@@ -1513,7 +1513,7 @@ msgstr "リスト、文字列、およびその他の配列型も、重要な類
 #. type: Plain text
 #: original_texis/objects.texi:742
 msgid "It is generally impossible to read the same sequence twice, since sequences are always created anew upon reading.  If you read the read syntax for a sequence twice, you get two sequences with equal contents.  There is one exception: the empty list @code{()} always stands for the same object, @code{nil}."
-msgstr "シーケンスは読み取りにより常に新たに作成されるやめ、同じシーケンスを2回読み取るのは一般的に不可能です。シーケンスにたいする入力構文を2回読み取った場合には、内容が等しい2つのシーケンスを得ます。これには1つ例外があります。空リスト@code{()}は、常に同じオブジェクト@code{nil}を表します。"
+msgstr "シーケンスは読み取りにより常に新たに作成されるため、同じシーケンスを2回読み取るのは一般的に不可能です。シーケンスにたいする入力構文を2回読み取った場合には、内容が等しい2つのシーケンスを得ます。これには1つ例外があります。空リスト@code{()}は、常に同じオブジェクト@code{nil}を表します。"
 
 #. type: subsection
 #: original_texis/objects.texi:744
@@ -2135,7 +2135,7 @@ msgstr "Non-@acronym{ASCII} Characters in Strings"
 #. type: Plain text
 #: original_texis/objects.texi:1142
 msgid "There are two text representations for non-@acronym{ASCII} characters in Emacs strings: multibyte and unibyte (@pxref{Text Representations}).  Roughly speaking, unibyte strings store raw bytes, while multibyte strings store human-readable text.  Each character in a unibyte string is a byte, i.e., its value is between 0 and 255.  By contrast, each character in a multibyte string may have a value between 0 to 4194303 (@pxref{Character Type}).  In both cases, characters above 127 are non-@acronym{ASCII}."
-msgstr "Emacdの文字列内の非@acronym{ASCII}文字にたいしては2つのテキスト表現 --- マルチバイト(multibyte)とユニバイト(unibyte)があります(@ref{Text Representations}を参照)。大まかに言うとユニバイト文字列にはraw(生)バイトが保存され、マルチバイト文字列には人間が読めるテキストが保存されます。ユニバイト文字列内の各文字はバイトであり、値は0から255となります。対照的にマルチバイト文字列内の各文字は、0から4194303の値をもつかもしれません(@ref{Character Type}を参照)。いずれも127より上の文字は非@acronym{ASCII}です。"
+msgstr "Emacsの文字列内の非@acronym{ASCII}文字にたいしては2つのテキスト表現 --- マルチバイト(multibyte)とユニバイト(unibyte)があります(@ref{Text Representations}を参照)。大まかに言うとユニバイト文字列にはraw(生)バイトが保存され、マルチバイト文字列には人間が読めるテキストが保存されます。ユニバイト文字列内の各文字はバイトであり、値は0から255となります。対照的にマルチバイト文字列内の各文字は、0から4194303の値をもつかもしれません(@ref{Character Type}を参照)。いずれも127より上の文字は非@acronym{ASCII}です。"
 
 #. type: Plain text
 #: original_texis/objects.texi:1152
@@ -2323,7 +2323,7 @@ msgstr "@dfn{ブールベクター(bool-vector)}は、要素が@code{t}か@code{
 #. type: Plain text
 #: original_texis/objects.texi:1323
 msgid "The printed representation of a bool-vector is like a string, except that it begins with @samp{#&} followed by the length.  The string constant that follows actually specifies the contents of the bool-vector as a bitmap---each character in the string contains 8 bits, which specify the next 8 elements of the bool-vector (1 stands for @code{t}, and 0 for @code{nil}).  The least significant bits of the character correspond to the lowest indices in the bool-vector."
-msgstr "ブールベクターのプリント表現は文字列と似ていますが、後に長さを記述した@samp{#&}で始まります。これに続く文字列定数は、ビットマップとして実際に内容を指定するブールベクターです --- 文字列定数内のそれぞれの``文字''は8ビットを含み、これはブールベクターの次の8要素を指定します(1は@code{t}、0は@code{nil}です)。文字の最下位ビットブールベクターの最下位のインデックスに対応します。"
+msgstr "ブールベクターのプリント表現は文字列と似ていますが、後に長さを記述した@samp{#&}で始まります。これに続く文字列定数は、ビットマップとして実際に内容を指定するブールベクターです --- 文字列定数内のそれぞれの``文字''は8ビットを含み、これはブールベクターの次の8要素を指定します(1は@code{t}、0は@code{nil}です)。文字の最下位ビットが、ブールベクターの最下位のインデックスに対応しています。"
 
 #. type: example
 #: original_texis/objects.texi:1329
@@ -2420,7 +2420,7 @@ msgstr "primitive function"
 #. type: Plain text
 #: original_texis/objects.texi:1413
 msgid "A @dfn{primitive function} is a function callable from Lisp but written in the C programming language.  Primitive functions are also called @dfn{subrs} or @dfn{built-in functions}.  (The word ``subr'' is derived from ``subroutine''.)  Most primitive functions evaluate all their arguments when they are called.  A primitive function that does not evaluate all its arguments is called a @dfn{special form} (@pxref{Special Forms})."
-msgstr "@dfn{プリミティブ関数(primitive function)}とは、Cプログラミング言語で記述されたLispから呼び出せる関数です。プリミティブ関数は@dfn{subrs}や@dfn{ビルトイン関数(built-in functions)}とも呼ばれます(単語``subr''は``サブルーチン(subroutine)''が由来)。ほとんどのプリミティブ関数ハ、呼び出されたときニすべての引数を評価します。すべての引数を評価しないプリミティブ関数は@dfn{スペシャルフォーム(special form)}と呼ばれます(@ref{Special Forms}を参照)。"
+msgstr "@dfn{プリミティブ関数(primitive function)}とは、Cプログラミング言語で記述されたLispから呼び出せる関数です。プリミティブ関数は@dfn{subrs}や@dfn{ビルトイン関数(built-in functions)}とも呼ばれます(単語``subr''は``サブルーチン(subroutine)''が由来)。ほとんどのプリミティブ関数は、呼び出されたときにすべての引数を評価します。すべての引数を評価しないプリミティブ関数は@dfn{スペシャルフォーム(special form)}と呼ばれます(@ref{Special Forms}を参照)。"
 
 #. type: Plain text
 #: original_texis/objects.texi:1421
@@ -2507,7 +2507,7 @@ msgstr "autoloadオブジェクトは通常、シンボルの関数セルにオ
 #. type: Plain text
 #: original_texis/objects.texi:1505
 msgid "A @dfn{finalizer object} helps Lisp code clean up after objects that are no longer needed.  A finalizer holds a Lisp function object.  When a finalizer object becomes unreachable after a garbage collection pass, Emacs calls the finalizer's associated function object.  When deciding whether a finalizer is reachable, Emacs does not count references from finalizer objects themselves, allowing you to use finalizers without having to worry about accidentally capturing references to finalized objects themselves."
-msgstr "@dfn{ファイナライザーオブジェクト(finalizer object)}は、オブジェクトがもはや必要なくなった後のLispコードのクリーンアップを助けます。ファイナライザーは、Lisp関数オブジェクトを保持します。ガーベージコレクションのオアス後にファイナライザーオブジェクトが到達不能になったとき、Emacsはそのファイナライザーに関連付けられた関数オブジェクトを呼び出します。ファイナライザーの到達可否の判定時、もしかしてファイナライザーオブジェクト自身が参照を離さないのではないかと心配することなくファイナライザーを使用できるように、Emacsはファイナラーオブジェト自身からの参照は勘定しません。"
+msgstr "@dfn{ファイナライザーオブジェクト(finalizer object)}は、オブジェクトがもはや必要なくなった後のLispコードのクリーンアップを助けます。ファイナライザーは、Lisp関数オブジェクトを保持します。ガーベージコレクションをパス(通過)した後にファイナライザーオブジェクトが到達不能になったとき、Emacsはそのファイナライザーに関連付けられた関数オブジェクトを呼び出します。ファイナライザーの到達可否の判定時、もしかしてファイナライザーオブジェクト自身が参照を離さないのではないかと心配することなくファイナライザーを使用できるように、Emacsはファイナラーオブジェト自身からの参照は勘定しません。"
 
 #. type: Plain text
 #: original_texis/objects.texi:1509
@@ -2737,7 +2737,7 @@ msgstr "@dfn{バッファー(buffer)}とは、編集されるテキストを保
 #. type: Plain text
 #: original_texis/objects.texi:1567
 msgid "The contents of a buffer are much like a string, but buffers are not used like strings in Emacs Lisp, and the available operations are different.  For example, you can insert text efficiently into an existing buffer, altering the buffer's contents, whereas inserting text into a string requires concatenating substrings, and the result is an entirely new string object."
-msgstr "バッファーの内容は文字列によく似ていますが、バッファーはEmacs Lispの文字列と同じようには使用されず、利用可能な操作は異なります。文字列にテキストを挿入するためには部分文字列の結合が必要で、結果は完全に新しい文字列オブジェクトなのるのにたいして、バッファーでは既存のバッファーに効率的にテキストを挿入してバッファーの内容を変更できます。"
+msgstr "バッファーの内容は文字列によく似ていますが、バッファーはEmacs Lispの文字列と同じようには使用されず、利用可能な操作は異なります。たとえば文字列にテキストを挿入するためには部分文字列の結合が必要であり、結果は完全に新しい文字列オブジェクトなのるのにたいして、バッファーでは既存のバッファーに効率的にテキストを挿入してバッファーの内容を変更できます。"
 
 #. type: Plain text
 #: original_texis/objects.texi:1571
@@ -3897,7 +3897,7 @@ msgstr "@var{object1}と@var{object2}が同じ名前をもつシンボルなら
 #. type: defun
 #: original_texis/objects.texi:2214
 msgid "If @var{object1} and @var{object2} are numbers with differing types or values, then they cannot be the same object and @code{eq} returns @code{nil}.  If they are fixnums with the same value, then they are the same object and @code{eq} returns @code{t}.  If they were computed separately but happen to have the same value and the same non-fixnum numeric type, then they might or might not be the same object, and @code{eq} returns @code{t} or @code{nil} depending on whether the Lisp interpreter created one object or two."
-msgstr "@var{object1}と@var{object2}異なるタイプや値をもつ数値なら同じオブジェクトではなく、@code{eq}は@code{nil}をリターンする。同じ値をもつfixnumなら同じオブジェクトであり、@code{eq}は@code{t}をリターンする。別個に計算されてたまたま同じ値をもち、かつ非fixnumタイプの同じ数値型なら、それらは同じかもしれないし違うかもしれず、Lispインタープリターが作成したオブジェクトが1つか2つかに依存して@code{eq}は@code{t}か@code{nil}をリターンする。"
+msgstr "@var{object1}と@var{object2}が異なるタイプや値をもつ数値なら同じオブジェクトではなく、@code{eq}は@code{nil}をリターンする。同じ値をもつfixnumなら同じオブジェクトであり、@code{eq}は@code{t}をリターンする。別個に計算されてたまたま同じ値をもち、かつ非fixnumタイプの同じ数値型なら、それらは同じかもしれないし違うかもしれず、Lispインタープリターが作成したオブジェクトが1つか2つかに依存して@code{eq}は@code{t}か@code{nil}をリターンする。"
 
 #. type: group
 #: original_texis/objects.texi:2219
@@ -4201,7 +4201,7 @@ msgstr "変更されるべきではないLispオブジェクトがいくつか
 #. type: Plain text
 #: original_texis/objects.texi:2423
 msgid "Other Lisp objects are @dfn{mutable}: it is safe to change their values via destructive operations involving side effects.  For example, an existing marker can be changed by moving the marker to point to somewhere else."
-msgstr "その他のLispオブジェクトは副作用をともなう破壊的な操作を通じて安全に値を変更可能な@dfn{mutable(可変)}オブジェクトです。たとえばマーカーを別のポイントを指すマーカーに移動することにより、既存のマーカーを変更することができます。"
+msgstr "その他のLispオブジェクトは@dfn{mutable(可変)}オブジェクトで、副作用をともなう破壊的な操作を通じて値を変更しても安全です。たとえばマーカーを別のポイントを指すマーカーに移動することにより、既存のマーカーを変更することができます。"
 
 #. type: Plain text
 #: original_texis/objects.texi:2431
diff --git a/lispref/os.texi.po b/lispref/os.texi.po
index e499959..b493b37 100644
--- a/lispref/os.texi.po
+++ b/lispref/os.texi.po
@@ -2390,7 +2390,7 @@ msgstr "現在のところ3つのLispタイムスタンプ形式があり、そ
 #. type: itemize
 #: original_texis/os.texi:1342
 msgid "An integer.  Although this is the simplest form, it cannot represent subsecond timestamps."
-msgstr "整数。これがもっとも単純な形式だが、少数秒のタイムスタンプは表現できない。"
+msgstr "整数。これがもっとも単純な形式だが、小数秒のタイムスタンプは表現できない。"
 
 #. type: itemize
 #: original_texis/os.texi:1349
@@ -2547,7 +2547,7 @@ msgstr "TZ@r{, environment variable}"
 #. type: Plain text
 #: original_texis/os.texi:1471
 msgid "The default time zone is determined by the @env{TZ} environment variable.  @xref{System Environment}.  For example, you can tell Emacs to default to Universal Time with @code{(setenv \"TZ\" \"UTC0\")}.  If @env{TZ} is not in the environment, Emacs uses system wall clock time, which is a platform-dependent default time zone."
-msgstr "デフォルトのタイムゾーンは環境変数@env{TZ}により判断されます。@ref{System Environment}を参照してください。たとえば@code{(setenv \\\"TZ\\\" \\\"UTC0\\\")}とすれば万国標準時の使用をEmacsに指示できます。その環境に@env{TZ}がなければ、Emacsはプラットフォーム依存のデフォルト時刻であるシステムの実時間(system wall clock time)を使用します。"
+msgstr "デフォルトのタイムゾーンは環境変数@env{TZ}により判断されます。@ref{System Environment}を参照してください。たとえば@code{(setenv \"TZ\" \"UTC0\")}とすれば万国標準時の使用をEmacsに指示できます。その環境に@env{TZ}がなければ、Emacsはプラットフォーム依存のデフォルト時刻であるシステムの実時間(system wall clock time)を使用します。"
 
 #. type: Plain text
 #: original_texis/os.texi:1480
diff --git a/lispref/processes.texi.po b/lispref/processes.texi.po
index dc902f7..3678c86 100644
--- a/lispref/processes.texi.po
+++ b/lispref/processes.texi.po
@@ -3052,7 +3052,7 @@ msgstr "引数@var{seconds}と@var{millisec}によりタイムアウトの長さ
 #. type: defun
 #: original_texis/processes.texi:1962
 msgid "The argument @var{millisec} is obsolete (and should not be used), because @var{seconds} can be floating point to specify waiting a fractional number of seconds.  If @var{seconds} is 0, the function accepts whatever output is pending but does not wait."
-msgstr "@var{seconds}に浮動小数点数を指定することにより秒を少数点で指定できるので引数@var{millisec}は時代遅れ(であり使用するべきではない)。@var{seconds}が0ならこの関数は保留中の出力が何であれ受け取り待機しない。"
+msgstr "@var{seconds}に浮動小数点数を指定することにより秒を小数点で指定できるので引数@var{millisec}は時代遅れ(であり使用するべきではない)。@var{seconds}が0ならこの関数は保留中の出力が何であれ受け取り待機しない。"
 
 #. type: defun
 #: original_texis/processes.texi:1970
@@ -4062,7 +4062,7 @@ msgstr "@var{buffer}引数はその接続に関連付けるバッファー。そ
 #. type: defun
 #: original_texis/processes.texi:2579
 msgid "The arguments @var{host} and @var{service} specify where to connect to; @var{host} is the host name (a string), and @var{service} is the name of a defined network service (a string) or a port number (an integer like @code{80} or an integer string like @code{\"80\"})."
-msgstr "引数@var{host}と@var{service}は接続先を指定する。@var{host}はホスト名(文字列)、@var{service}は定義済みのネットワークサービス名(文字列)、またはポート番号(@code{80}のような整数か@code{\\\"80\\\"}のような整数文字列)。"
+msgstr "引数@var{host}と@var{service}は接続先を指定する。@var{host}はホスト名(文字列)、@var{service}は定義済みのネットワークサービス名(文字列)、またはポート番号(@code{80}のような整数か@code{\"80\"}のような整数文字列)。"
 
 #. type: defun
 #: original_texis/processes.texi:2582
@@ -4506,7 +4506,7 @@ msgstr ":service @var{service}"
 #. type: table
 #: original_texis/processes.texi:2838
 msgid "@var{service} specifies a port number to connect to; or, for a server, the port number to listen on.  It should be a service name like @samp{\"https\"} that translates to a port number, or an integer like @samp{443} or an integer string like @samp{\"443\"} that specifies the port number directly.  For a server, it can also be @code{t}, which means to let the system select an unused port number."
-msgstr "@var{service}は接続先のポート番号、またはサーバーにたいしてはlistenするポート番号である。これは@samp{\"https\"}のようにポート番号に変換されるようなサービス名、または直接ポート番号を指定する@samp{4430}のような整数か@samp{\\\"443\\\"}のような整数文字列であること。サーバーにたいしては@code{t}も指定でき、これは未使用のポート番号をシステムに選択させることを意味する。"
+msgstr "@var{service}は接続先のポート番号、またはサーバーにたいしてはlistenするポート番号である。これは@samp{\"https\"}のようにポート番号に変換されるようなサービス名、または直接ポート番号を指定する@samp{443}のような整数か@samp{\"443\"}のような整数文字列であること。サーバーにたいしては@code{t}も指定でき、これは未使用のポート番号をシステムに選択させることを意味する。"
 
 #. type: item
 #: original_texis/processes.texi:2839
@@ -5099,7 +5099,7 @@ msgstr "この関数はネットワークアドレスのLisp表現を文字列
 #. type: defun
 #: original_texis/processes.texi:3199
 msgid "A five-element vector @code{[@var{a} @var{b} @var{c} @var{d} @var{p}]} represents an IPv4 address @var{a}.@var{b}.@var{c}.@var{d} and port number @var{p}.  @code{format-network-address} converts that to the string @code{\"@var{a}.@var{b}.@var{c}.@var{d}:@var{p}\"}."
-msgstr "5要素のベクター@code{[@var{a} @var{b} @var{c} @var{d} @var{p}]}はIPv4アドレス@var{a}.@var{b}.@var{c}.@var{d}、およびポート番号@var{p}を表す。@code{format-network-address}はこれを文字列@code{\\\"@var{a}.@var{b}.@var{c}.@var{d}:@var{p}\\\"}に変換する。"
+msgstr "5要素のベクター@code{[@var{a} @var{b} @var{c} @var{d} @var{p}]}はIPv4アドレス@var{a}.@var{b}.@var{c}.@var{d}、およびポート番号@var{p}を表す。@code{format-network-address}はこれを文字列@code{\"@var{a}.@var{b}.@var{c}.@var{d}:@var{p}\"}に変換する。"
 
 #. type: defun
 #: original_texis/processes.texi:3205
diff --git a/lispref/searching.texi.po b/lispref/searching.texi.po
index f3f04d0..10a39f1 100644
--- a/lispref/searching.texi.po
+++ b/lispref/searching.texi.po
@@ -778,7 +778,7 @@ msgstr "ある種の文字候補は、たとえそれらがEmacs内において
 #. type: enumerate
 #: original_texis/searching.texi:458
 msgid "Although a range's bound can be almost any character, it is better style to stay within natural sequences of ASCII letters and digits because most people have not memorized character code tables.  For example, @samp{[.-9]} is less clear than @samp{[./0-9]}, and @samp{[`-~]} is less clear than @samp{[`a-z@{|@}~]}.  Unicode character escapes can help here; for example, for most programmers @samp{[ก-ฺ฿-๛]} is less clear than @samp{[\\u0E01-\\u0E3A\\u0E3F-\\u0E5B]}."
-msgstr "ほとんどすべての文字を範囲の境界にできるとはいえ、文字コードテーブルを記憶している人はほとんどいないので、ASCII文字や数字の自然な順序を守るほうがよいスタイルである。たとえば@samp{[.-9]}は@samp{[./0-9]}、@samp{[`-~]}は@samp{[`a-z@{|@}~]}より明確さに劣る。ここではUnicodeの文字エスケープが助けとなる。たとえばほとんどのプログラマーにとっては@samp{[ก-ฺ฿-๛]}より@samp{[\\\\u0E01-\\\\u0E3A\\\\u0E3F-\\\\u0E5B]}のほうが明確だろう。"
+msgstr "ほとんどすべての文字を範囲の境界にできるとはいえ、文字コードテーブルを記憶している人はほとんどいないので、ASCII文字や数字の自然な順序を守るほうがよいスタイルである。たとえば@samp{[.-9]}は@samp{[./0-9]}、@samp{[`-~]}は@samp{[`a-z@{|@}~]}より明確さに劣る。ここではUnicodeの文字エスケープが助けとなる。たとえばほとんどのプログラマーにとっては@samp{[ก-ฺ฿-๛]}より@samp{[\\u0E01-\\u0E3A\\u0E3F-\\u0E5B]}のほうが明確だろう。"
 
 #. type: enumerate
 #: original_texis/searching.texi:463
@@ -885,7 +885,7 @@ msgstr "バッファーではなく文字列とマッチする際には、@samp{
 #. type: table
 #: original_texis/searching.texi:524
 msgid "For historical compatibility reasons, @samp{$} can be used only at the end of the regular expression, or before @samp{\\)} or @samp{\\|}."
-msgstr "歴史的な互換性という理由により@samp{$}は正規表現の先頭、または@samp{\\(}、@samp{\\(?:}、@samp{\\|}の前でのみ使用できる。"
+msgstr "歴史的な互換性という理由により@samp{$}は正規表現の終端、または@samp{\\)}、@samp{\\|}の前でのみ使用できる。"
 
 #. type: samp{#1}
 #: original_texis/searching.texi:525
@@ -912,7 +912,7 @@ msgstr "@samp{\\}はスペシャル文字をクォートするので@samp{\\$}
 #. type: table
 #: original_texis/searching.texi:541
 msgid "Note that @samp{\\} also has special meaning in the read syntax of Lisp strings (@pxref{String Type}), and must be quoted with @samp{\\}.  For example, the regular expression that matches the @samp{\\} character is @samp{\\\\}.  To write a Lisp string that contains the characters @samp{\\\\}, Lisp syntax requires you to quote each @samp{\\} with another @samp{\\}.  Therefore, the read syntax for a regular expression matching @samp{\\} is @code{\"\\\\\\\\\"}."
-msgstr "@samp{\\}はLisp文字列(@ref{String Type}を参照)の入力構文(read syntax)内でも特別な意味をもち、@samp{\\}でクォートしなければならないことに注意。たとえば文字@samp{\\}にマッチする正規表現は@samp{\\\\}。文字@samp{\\\\}を含むLisp文字列を記述するには、別の@samp{\\\\}で@samp{\\\\}をクォートすることをLisp構文は要求する。したがって@samp{\\}にマッチする正規表現にたいする入力構文は@code{\"\\\\\\\\\"}となる。"
+msgstr "@samp{\\}はLisp文字列(@ref{String Type}を参照)の入力構文(read syntax)内でも特別な意味をもち、@samp{\\}でクォートしなければならないことに注意。たとえば文字@samp{\\}にマッチする正規表現は@samp{\\\\}。文字@samp{\\\\}を含むLisp文字列を記述するには、別の@samp{\\}で@samp{\\}をクォートすることをLisp構文は要求する。したがって@samp{\\}にマッチする正規表現にたいする入力構文は@code{\"\\\\\\\\\"}となる。"
 
 #. type: Plain text
 #: original_texis/searching.texi:549
@@ -3564,7 +3564,7 @@ msgstr "rx-to-string rx-expr &optional no-group"
 #. type: defun
 #: original_texis/searching.texi:1575
 msgid "Translate @var{rx-expr} to a string regexp which is returned.  If @var{no-group} is absent or nil, bracket the result in a non-capturing group, @samp{\\(?:@dots{}\\)}, if necessary to ensure that a postfix operator appended to it will apply to the whole expression.  Example:"
-msgstr "@var{rx-expr}をリターンされる文字列regexpに変換する。@var{no-group}が省略またはnilの場合には、後に付加する後置演算子が式全体に適用されるために、必要なら結果を非キャプチャリンググループ@samp{\\\\(?:@dots{}\\\\)}としてカッコで括る。たとえば:"
+msgstr "@var{rx-expr}をリターンされる文字列regexpに変換する。@var{no-group}が省略またはnilの場合には、後に付加する後置演算子が式全体に適用されるために、必要なら結果を非キャプチャリンググループ@samp{\\(?:@dots{}\\)}としてカッコで括る。たとえば:"
 
 #. type: group
 #: original_texis/searching.texi:1580
@@ -3946,7 +3946,7 @@ msgstr "非@code{nil}"
 #. type: table
 #: original_texis/searching.texi:1837
 msgid "The resulting regexp is surrounded by @samp{\\(} and @samp{\\)}."
-msgstr "結果となるregexpは@samp{\\\\(}と@samp{\\\\)}で括られる。"
+msgstr "結果となるregexpは@samp{\\(}と@samp{\\)}で括られる。"
 
 #. type: code{#1}
 #: original_texis/searching.texi:1838 original_texis/searching.texi:1994
diff --git a/lispref/sequences.texi.po b/lispref/sequences.texi.po
index 1b44dc6..1aab8d8 100644
--- a/lispref/sequences.texi.po
+++ b/lispref/sequences.texi.po
@@ -3240,7 +3240,7 @@ msgstr "Bool-vectors"
 #. type: Plain text
 #: original_texis/sequences.texi:1721
 msgid "A bool-vector is much like a vector, except that it stores only the values @code{t} and @code{nil}.  If you try to store any non-@code{nil} value into an element of the bool-vector, the effect is to store @code{t} there.  As with all arrays, bool-vector indices start from 0, and the length cannot be changed once the bool-vector is created.  Bool-vectors are constants when evaluated."
-msgstr "ブールベクター(bool-vector)はベクターとよく似ていますが、値に@code{t}と@code{nil}しか格納できません。ブールベクターの要素に非@code{nil}値の格納を試みたると、そこには@code{t}が格納されます。すべての配列と同様、ブールベクターのインデックスは0から開始され、一度ブールベクターが作成されたら長さを変更することはできません。ブールベクターは定数として評価されます。"
+msgstr "ブールベクター(bool-vector)はベクターとよく似ていますが、値に@code{t}と@code{nil}しか格納できません。ブールベクターの要素に非@code{nil}値の格納を試みると、そこには@code{t}が格納されます。すべての配列と同様、ブールベクターのインデックスは0から開始され、一度ブールベクターが作成されたら長さを変更することはできません。ブールベクターは定数として評価されます。"
 
 #. type: Plain text
 #: original_texis/sequences.texi:1725
diff --git a/lispref/strings.texi.po b/lispref/strings.texi.po
index 3060b98..94a2227 100644
--- a/lispref/strings.texi.po
+++ b/lispref/strings.texi.po
@@ -189,7 +189,7 @@ msgstr "文字(character)とは、テキスト内の1つの文字を表すLisp
 #. type: Plain text
 #: original_texis/strings.texi:50
 msgid "A string is a fixed sequence of characters.  It is a type of sequence called a @dfn{array}, meaning that its length is fixed and cannot be altered once it is created (@pxref{Sequences Arrays Vectors}).  Unlike in C, Emacs Lisp strings are @emph{not} terminated by a distinguished character code."
-msgstr "文字列(string)とは固定された文字シーケンスです。これは@dfn{配列(array)}と呼ばれるシーケンス型であり、配列長が固定で一度作成したら変更できないことを意味します(@ref{Sequences Arrays Vectors}を参照)。Cとは異なり、Emacs Lispの文字列は文字コードを判断することにより@emph{終端されません}。"
+msgstr "文字列(string)とは固定された文字シーケンスです。これは@dfn{配列(array)}と呼ばれるシーケンス型であり、配列長が固定で一度作成したら変更できないことを意味します(@ref{Sequences Arrays Vectors}を参照)。Cとは異なり、Emacs Lispの文字列は文字コードを判断することにより@emph{終端されません}。(訳注: 文字列の終端用の文字コードはない、ということ。)"
 
 #. type: Plain text
 #: original_texis/strings.texi:56
@@ -464,7 +464,7 @@ msgstr "substring-no-properties string &optional start end"
 #. type: defun
 #: original_texis/strings.texi:249
 msgid "This works like @code{substring} but discards all text properties from the value.  Also, @var{start} may be omitted or @code{nil}, which is equivalent to 0.  Thus, @w{@code{(substring-no-properties @var{string})}} returns a copy of @var{string}, with all text properties removed."
-msgstr "これは@code{substring}と同じように機能するが、値のすべてのテキストプロパティーを破棄する。@var{start}を省略したり@code{nil}を指定することができ、その場合は0と等価だる。したがって@w{@code{(substring-no-properties @var{string})}}は、すべてのテキストプロパティーが削除された@var{string}のコピーをリターンする。"
+msgstr "これは@code{substring}と同じように機能するが、値のすべてのテキストプロパティーを破棄する。@var{start}を省略したり@code{nil}を指定することができ、その場合は0と等価である。したがって@w{@code{(substring-no-properties @var{string})}}は、すべてのテキストプロパティーが削除された@var{string}のコピーをリターンする。"
 
 #. type: defun
 #: original_texis/strings.texi:251
@@ -509,7 +509,7 @@ msgstr ""
 "     @result{} \"abc-def\"\n"
 "(concat \"abc\" (list 120 121) [122])\n"
 "     @result{} \"abcxyz\"\n"
-";; @r{@code{nil}hあ空のシーケンス。}\n"
+";; @r{@code{nil}は空のシーケンス。}\n"
 "(concat \"abc\" nil \"-def\")\n"
 "     @result{} \"abc-def\"\n"
 "(concat \"The \" \"quick brown \" \"fox.\")\n"
@@ -788,7 +788,7 @@ msgstr "string-pad string length &optional padding start"
 #. type: defun
 #: original_texis/strings.texi:452
 msgid "Pad @var{string} to be of the given @var{length} using @var{padding} as the padding character.  @var{padding} defaults to the space character.  If @var{string} is longer than @var{length}, no padding is done.  If @var{start} is @code{nil} or omitted, the padding is appended to the characters of @var{string}, and if it's non-@code{nil}, the padding is prepended to @var{string}'s characters."
-msgstr "@var{padding}をパディング文字に使用して、与えられた@var{length}になるように@var{string}をパディングする。@var{padding}のデフォルトはスペース文字。@var{length}より@var{string}が短ければパディングしない。@var{start}が@code{nil} (または省略)ならパディングは文字列終端、非@code{nil}なら文字列先頭に追加される。"
+msgstr "@var{padding}をパディング文字に使用して、与えられた@var{length}になるように@var{string}をパディングする。@var{padding}のデフォルトはスペース文字。@var{length}より@var{string}が長ければパディングしない。@var{start}が@code{nil} (または省略)ならパディングは文字列終端、非@code{nil}なら文字列先頭に追加される。"
 
 #. type: defun
 #: original_texis/strings.texi:454
@@ -1054,7 +1054,7 @@ msgstr "この関数は2つの文字列を1文字ずつ比較する。この関
 #. type: defun
 #: original_texis/strings.texi:632
 msgid "Pairs of characters are compared according to their character codes.  Keep in mind that lower case letters have higher numeric values in the @acronym{ASCII} character set than their upper case counterparts; digits and many punctuation characters have a lower numeric value than upper case letters.  An @acronym{ASCII} character is less than any non-@acronym{ASCII} character; a unibyte non-@acronym{ASCII} character is always less than any multibyte non-@acronym{ASCII} character (@pxref{Text Representations})."
-msgstr "文字のペアーは文字コードで比較されル。@acronym{ASCII}文字セットでは英小文字は英大文字より高い数値をもつことに留意されたい。数字と区切り文字の多くは英大文字より低い数値をもつ。@acronym{ASCII}文字は任意の非@acronym{ASCII}文字より小さくなる。ユニバイトの非@acronym{ASCII}文字は、任意のマルチバイト非@acronym{ASCII}文字より常に小さくなります(@ref{Text Representations}を参照)。"
+msgstr "文字のペアーは文字コードで比較される。@acronym{ASCII}文字セットでは英小文字は英大文字より高い数値をもつことに留意されたい。数字と区切り文字の多くは英大文字より低い数値をもつ。@acronym{ASCII}文字は任意の非@acronym{ASCII}文字より小さくなる。ユニバイトの非@acronym{ASCII}文字は、任意のマルチバイト非@acronym{ASCII}文字より常に小さくなります(@ref{Text Representations}を参照)。"
 
 #. type: group
 #: original_texis/strings.texi:641
@@ -1169,7 +1169,7 @@ msgstr ""
 #. type: defun
 #: original_texis/strings.texi:701
 msgid "This behavior is system-dependent; e.g., punctuation and whitespace are never ignored on Cygwin, regardless of locale."
-msgstr "Cygwinではlocaleと無関係に区切り文字と空白文字が無視されることが決してないように、この振る舞いはシステム依存である。"
+msgstr "この振る舞いはシステム依存であり、例えばCygwinではlocaleに関係なく区切り文字と空白文字が無視されることは一切ない。"
 
 #. type: defun
 #: original_texis/strings.texi:708
@@ -1240,7 +1240,7 @@ msgstr "string-search needle haystack &optional start-pos"
 #. type: defun
 #: original_texis/strings.texi:762
 msgid "Return the position of the first instance of @var{needle} in @var{haystack}, both of which are strings.  If @var{start-pos} is non-@code{nil}, start searching from that position in @var{needle}.  Return @code{nil} if no match was found.  This function only considers the characters in the strings when doing the comparison; text properties are ignored.  Matching is always case-sensitive."
-msgstr "@var{haystack}内で最初に@var{needle} (いずれも文字列)が出現する位置をリターンする。@var{start-pos}が非@code{nil}なら、検索は@var{needle}内のその位置から開始される。マッチが見つからなければ@code{nil}をリターンする。この関数は比較を行う際にはテキストプロパティは無視して、文字列内の文字だけを考慮する。マッチングでは常にcaseを区別する。"
+msgstr "@var{haystack}内で最初に@var{needle} (いずれも文字列)が出現する位置をリターンする。@var{start-pos}が非@code{nil}なら、検索は@var{needle}内のその位置から開始される。マッチ(一致するもの)が見つからなければ@code{nil}をリターンする。この関数は比較を行う際にはテキストプロパティは無視して、文字列内の文字だけを考慮する。マッチングでは常にcaseを区別する。"
 
 #. type: defun
 #: original_texis/strings.texi:764
@@ -1261,7 +1261,7 @@ msgstr "文字列は文字列内の文字の数値により比較される。た
 #. type: defun
 #: original_texis/strings.texi:789
 msgid "If the specified portions of the two strings match, the value is @code{t}.  Otherwise, the value is an integer which indicates how many leading characters agree, and which string is less.  Its absolute value is one plus the number of characters that agree at the beginning of the two strings.  The sign is negative if @var{string1} (or its specified portion) is less."
-msgstr "2つの文字列の指定部分がマッチした場合、値は@code{t}になる。それ以外なら値は整数で、何文字が一致してどちらの文字が小さいかを示す。この値の絶対値は、2つの文字列の先頭から一致した文字数に1加えた値になる。@var{string1}(または指定部分)のほうが小さければ符号は負になる。"
+msgstr "2つの文字列の指定部分がマッチ(一致)した場合、値は@code{t}になる。それ以外なら値は整数で、何文字が一致してどちらの文字が小さいかを示す。この値の絶対値は、2つの文字列の先頭から一致した文字数に1加えた値になる。@var{string1}(または指定部分)のほうが小さければ符号は負になる。"
 
 #. type: cindex
 #: original_texis/strings.texi:791
@@ -1419,7 +1419,7 @@ msgstr "string to number"
 #. type: defun
 #: original_texis/strings.texi:882
 msgid "This function returns the numeric value of the characters in @var{string}.  If @var{base} is non-@code{nil}, it must be an integer between 2 and 16 (inclusive), and integers are converted in that base.  If @var{base} is @code{nil}, then base ten is used.  Floating-point conversion only works in base ten; we have not implemented other radices for floating-point numbers, because that would be much more work and does not seem useful."
-msgstr "この関数は@var{string}内の文字の数値的な値をリターンする。@var{base}が非@code{nil}なら値は2以上16以下でなければならず、整数はその基数に変換される。@var{base}が@code{nil}なら基数に10が使用される。浮動少数点数の変換は基数が10のときだけ機能する。わたしたちは浮動小数点数にたいして他の基数を実装しない。なぜならこれには多くの作業を要し、その割にその機能が有用には思えないからだ。"
+msgstr "この関数は@var{string}内の文字の数値的な値をリターンする。@var{base}が非@code{nil}なら値は2以上16以下でなければならず、整数はその基数に変換される。@var{base}が@code{nil}なら基数に10が使用される。浮動小数点数の変換は基数が10のときだけ機能する。わたしたちは浮動小数点数にたいして他の基数を実装しない。なぜならこれには多くの作業を要し、その割にその機能が有用には思えないからだ。"
 
 #. type: defun
 #: original_texis/strings.texi:888
@@ -1489,7 +1489,7 @@ msgstr "string-to-char string"
 #. type: defun
 #: original_texis/strings.texi:920
 msgid "This function returns the first character in @var{string}.  This mostly identical to @code{(aref string 0)}, except that it returns 0 if the string is empty.  (The value is also 0 when the first character of @var{string} is the null character, @acronym{ASCII} code 0.)  This function may be eliminated in the future if it does not seem useful enough to retain."
-msgstr "この関数は@var{string}の最初の文字をリターンする。これはほとんど@code{(aref string 0)}と同じで、例外は文字列が空のときに0をリターンすること(文字列の最初の文字が@acronym{ASCII}コード0のヌル文字のときも0をリターンする)。この関数は残すのに充分なほど有用と思えないければ、将来削除されるかもしれない。"
+msgstr "この関数は@var{string}の最初の文字をリターンする。これはほとんど@code{(aref string 0)}と同じで、例外は文字列が空のときに0をリターンすること(文字列の最初の文字が@acronym{ASCII}コード0のヌル文字のときも0をリターンする)。この関数は残すのに充分なほど有用と思えないなら、将来削除されるかもしれない。"
 
 #. type: Plain text
 #: original_texis/strings.texi:923
@@ -1555,7 +1555,7 @@ msgstr "strings, formatting them"
 #. type: Plain text
 #: original_texis/strings.texi:950
 msgid "@dfn{Formatting} means constructing a string by substituting computed values at various places in a constant string.  This constant string controls how the other values are printed, as well as where they appear; it is called a @dfn{format string}."
-msgstr "@dfn{フォーマット(formatting)}とは、定数文字列内のなまざまな場所を計算された値で置き換えることにより、文字列を構築することを意味します。この定数文字列は他の値がプリントされる方法、同様にどこに表示するかを制御します。これは@dfn{フォーマット文字列(format string)}と呼ばれます。"
+msgstr "@dfn{フォーマット(formatting)}とは、定数文字列内のさまざまな場所を計算された値で置き換えることにより、文字列を構築することを意味します。この定数文字列は他の値がどのようにプリントされるか、およびどこに表示するかを制御します。これは@dfn{フォーマット文字列(format string)}と呼ばれます。"
 
 #. type: Plain text
 #: original_texis/strings.texi:955
@@ -1626,7 +1626,7 @@ msgstr "format specification"
 #. type: Plain text
 #: original_texis/strings.texi:992
 msgid "A format specification is a sequence of characters beginning with a @samp{%}.  Thus, if there is a @samp{%d} in @var{string}, the @code{format} function replaces it with the printed representation of one of the values to be formatted (one of the arguments @var{objects}).  For example:"
-msgstr "フォーマット仕様(format specification)は@samp{%}で始まる文字シーケンスです。したがって@var{string}内に@samp{%d}がると@code{format}はそれを、フォーマットされる値の1つ(引数@var{objects}のうちの1つ)にたいするプリント表現で置き換えます。たとえば:"
+msgstr "フォーマット仕様(format specification)は@samp{%}で始まる文字シーケンスです。したがって@var{string}内に@samp{%d}があると@code{format}はそれを、フォーマットされる値の1つ(引数@var{objects}のうちの1つ)にたいするプリント表現で置き換えます。たとえば:"
 
 #. type: group
 #: original_texis/strings.texi:997
@@ -1641,7 +1641,7 @@ msgstr ""
 #. type: Plain text
 #: original_texis/strings.texi:1006
 msgid "Since @code{format} interprets @samp{%} characters as format specifications, you should @emph{never} pass an arbitrary string as the first argument.  This is particularly true when the string is generated by some Lisp code.  Unless the string is @emph{known} to never include any @samp{%} characters, pass @code{\"%s\"}, described below, as the first argument, and the string as the second, like this:"
-msgstr "@code{format}は文字@samp{%}をフォーマット仕様と解釈するので、@emph{決して}最初の引数に不定な文字列(arbitrary string)を渡すべきではありません。これは特に何らかのLispコードga生成siた文字列の場合に当てはまります。その文字列が決して文字@samp{%}を含まないと@emph{確信}できないならば、以下で説明するように最初の引数に@code{\"%s\"}を渡して、不定な文字列を2番目の引数として渡します:"
+msgstr "@code{format}は文字@samp{%}をフォーマット仕様と解釈するので、@emph{決して}最初の引数に不定な文字列(arbitrary string)を渡すべきではありません。これは特に何らかのLispコードが生成した文字列の場合に当てはまります。その文字列が決して文字@samp{%}を含まないと@emph{確信}できないならば、以下で説明するように最初の引数に@code{\"%s\"}を渡して、その不定な文字列を2番目の引数として渡します:"
 
 #. type: example
 #: original_texis/strings.texi:1009
@@ -1701,7 +1701,7 @@ msgstr "integer to octal"
 #. type: table
 #: original_texis/strings.texi:1041
 msgid "Replace the specification with the base-eight representation of an integer.  Negative integers are formatted in a platform-dependent way.  The object can also be a floating-point number that is formatted as an integer, dropping any fraction."
-msgstr "フォーマット仕様を整数の8進表現に置き換える。負の整数はプラットフォーム依存の方法でフォーマットされる。オブジェクトは浮動小数点数(少数部分を切り捨てて整数にフォーマット)でもよい。"
+msgstr "フォーマット仕様を整数の8進表現に置き換える。負の整数はプラットフォーム依存の方法でフォーマットされる。オブジェクトは浮動小数点数(小数部分を切り捨てて整数にフォーマット)でもよい。"
 
 #. type: item
 #: original_texis/strings.texi:1042
@@ -1712,7 +1712,7 @@ msgstr "%d"
 #. type: table
 #: original_texis/strings.texi:1046
 msgid "Replace the specification with the base-ten representation of a signed integer.  The object can also be a floating-point number that is formatted as an integer, dropping any fraction."
-msgstr "フォーマット仕様を10進表現の符号すき整数で置き換える。オブジェクトは浮動小数点数(少数部分を切り捨てて整数にフォーマット)でもよい。"
+msgstr "フォーマット仕様を10進表現の符号つき整数で置き換える。オブジェクトは浮動小数点数(小数部分を切り捨てて整数にフォーマット)でもよい。"
 
 #. type: item
 #: original_texis/strings.texi:1047
@@ -1735,7 +1735,7 @@ msgstr "integer to hexadecimal"
 #. type: table
 #: original_texis/strings.texi:1055
 msgid "Replace the specification with the base-sixteen representation of an integer.  Negative integers are formatted in a platform-dependent way.  @samp{%x} uses lower case and @samp{%X} uses upper case.  The object can also be a floating-point number that is formatted as an integer, dropping any fraction."
-msgstr "フォーマット仕様を16進表現の整数で置き換える。負の整数はプラットフォーム依存の方法でフォーマットされる。@samp{%x}なら小文字、@samp{%X}なら大文字が使用される。オブジェクトは少数部分を切り捨てて整数にフォーマットされた浮動小数点数でもよい。"
+msgstr "フォーマット仕様を16進表現の整数で置き換える。負の整数はプラットフォーム依存の方法でフォーマットされる。@samp{%x}なら小文字、@samp{%X}なら大文字が使用される。オブジェクトは小数部分を切り捨てて整数にフォーマットされた浮動小数点数でもよい。"
 
 #. type: item
 #: original_texis/strings.texi:1056
@@ -1768,7 +1768,7 @@ msgstr "%f"
 #. type: table
 #: original_texis/strings.texi:1066
 msgid "Replace the specification with the decimal-point notation for a floating-point number."
-msgstr "フォーマット仕様を浮動小数点数にたいする10進少数表記で置き換える。"
+msgstr "フォーマット仕様を浮動小数点数にたいする10進小数表記で置き換える。"
 
 #. type: item
 #: original_texis/strings.texi:1067
@@ -1779,7 +1779,7 @@ msgstr "%g"
 #. type: table
 #: original_texis/strings.texi:1075
 msgid "Replace the specification with notation for a floating-point number, using either exponential notation or decimal-point notation.  The exponential notation is used if the exponent would be less than @minus{}4 or greater than or equal to the precision (default: 6).  By default, trailing zeros are removed from the fractional portion of the result and a decimal-point character appears only if it is followed by a digit."
-msgstr "指数表記か小数点表記のいずれかを使用してフォーマット仕様を浮動小数点数にたいする表記に置き換える。指数が@minus{}4未満または精度(デフォルトは6)以上なら指数表記を使用する。デフォルトでは結果の少数部の末尾の0は削除されて、小数点が現れるのは後に数字が続く場合のみ。"
+msgstr "指数表記か小数点表記のいずれかを使用してフォーマット仕様を浮動小数点数にたいする表記に置き換える。指数が@minus{}4未満または精度(デフォルトは6)以上なら指数表記を使用する。デフォルトでは結果の小数部の末尾の0は削除されて、小数点が現れるのは後に数字が続く場合のみ。"
 
 #. type: item
 #: original_texis/strings.texi:1076
@@ -1889,7 +1889,7 @@ msgstr "フラグ@samp{+}は非負の数の前にプラス符号を挿入する
 #. type: Plain text
 #: original_texis/strings.texi:1147
 msgid "The flag @samp{#} specifies an alternate form which depends on the format in use.  For @samp{%o}, it ensures that the result begins with a @samp{0}.  For @samp{%x} and @samp{%X}, it prefixes nonzero results with @samp{0x} or @samp{0X}.  For @samp{%e} and @samp{%f}, the @samp{#} flag means include a decimal point even if the precision is zero.  For @samp{%g}, it always includes a decimal point, and also forces any trailing zeros after the decimal point to be left in place where they would otherwise be removed."
-msgstr "フラグ@samp{#}は代替形式(alternate form)を指定します。これは使用するフォーマットに依存します。@samp{%o}にたいしては結果を@samp{0}で開始させます。@samp{%x}と@samp{%X}にたいしては非0の結果のプレフィクスは@samp{0x}または@samp{0X}になります。@samp{%e}、@samp{%f}にたいしての@samp{#}フラグは、少数部が0のときにも小数点が含まれることを意味します。@samp{%g}にたいしては常に小数点が含まれるとともに、それ以外なら削除される小数点の後の末尾のすべての0も強制的に残されます。"
+msgstr "フラグ@samp{#}は代替形式(alternate form)を指定します。これは使用するフォーマットに依存します。@samp{%o}にたいしては結果を@samp{0}で開始させます。@samp{%x}と@samp{%X}にたいしては非0の結果のプレフィクスは@samp{0x}または@samp{0X}になります。@samp{%e}、@samp{%f}にたいしての@samp{#}フラグは、小数部が0のときにも小数点が含まれることを意味します。@samp{%g}にたいしては常に小数点が含まれるとともに、それ以外なら削除される小数点の後の末尾のすべての0も強制的に残されます。"
 
 #. type: Plain text
 #: original_texis/strings.texi:1153
@@ -1952,7 +1952,7 @@ msgstr "padding"
 #. type: Plain text
 #: original_texis/strings.texi:1180
 msgid "A specification can have a @dfn{width}, which is a decimal number that appears after any field number and flags.  If the printed representation of the object contains fewer characters than this width, @code{format} extends it with padding.  Any padding introduced by the width normally consists of spaces inserted on the left:"
-msgstr "フォーマット仕様は@dfn{フィールド幅(width)}をもつことができます。これはすべてのフィールド番号とフラグの後にある10進の数字です。オブジェクトのプリント表現がこのフィールド幅より少ない文字ｗ含む場合には、@code{format}はパディングによりフィールド幅に拡張します。フォーマット仕様@samp{%%}ではフィールド幅の指定は無視されます。フィールド幅指定子により行なわれるパディングは、通常は左側に挿入されるスペースで構成されます:"
+msgstr "フォーマット仕様は@dfn{フィールド幅(width)}をもつことができます。これはすべてのフィールド番号とフラグの後にある10進の数字です。オブジェクトのプリント表現がこのフィールド幅より少ない文字を含む場合には、@code{format}はパディングによりフィールド幅に拡張します。フォーマット仕様@samp{%%}ではフィールド幅の指定は無視されます。フィールド幅指定子により行なわれるパディングは、通常は左側に挿入されるスペースで構成されます:"
 
 #. type: example
 #: original_texis/strings.texi:1184
@@ -1997,7 +1997,7 @@ msgstr "precision in format specifications"
 #: original_texis/strings.texi:1223
 msgid "All the specification characters allow an optional @dfn{precision} after the field number, flags and width, if present.  The precision is a decimal-point @samp{.} followed by a digit-string.  For the floating-point specifications (@samp{%e} and @samp{%f}), the precision specifies how many digits following the decimal point to show; if zero, the decimal-point itself is also omitted.  For @samp{%g}, the precision specifies how many significant digits to show (significant digits are the first digit before the decimal point and all the digits after it).  If the precision of %g is zero or unspecified, it is treated as 1.  For @samp{%s} and @samp{%S}, the precision truncates the string to the given width, so @samp{%.3s} shows only the first three characters of the representation for @var{object}.  For other specification characters, the effect of precision is what the local library functions of the @code{printf} family produce."
 msgstr ""
-"すべてのフォーマット仕様文字にはフィールド番号、フラグ、フィールド幅の後にオプションで@dfn{精度(precision)}を指定できます。精度は小数点@samp{.}と、その後に桁文字列(digit-string)を指定します。浮動少数点数のフォーマット仕様(@samp{%e}と@samp{%f})では、精度は表示する小数点以下の桁数を指定します。0なら小数点も省略されます。%gの精度が0か未指定なら1として扱われます。@samp{%s}と@samp{%S}では精度として与えられた幅に文字列が切り詰められるので、@samp{%.3s}では@var{object}の表現の最初の3文字だけが表示されます。その他の仕様文字では、@code{printf}ファミリーのローカルライブラリーが生成する精度の効果が表れます。 \n"
+"すべてのフォーマット仕様文字にはフィールド番号、フラグ、フィールド幅の後にオプションで@dfn{精度(precision)}を指定できます。精度は小数点@samp{.}と、その後に桁文字列(digit-string)を指定します。浮動小数点数のフォーマット仕様(@samp{%e}と@samp{%f})では、精度は表示する小数点以下の桁数を指定します。0なら小数点も省略されます。%gの精度が0か未指定なら1として扱われます。@samp{%s}と@samp{%S}では精度として与えられた幅に文字列が切り詰められるので、@samp{%.3s}では@var{object}の表現の最初の3文字だけが表示されます。その他の仕様文字では、@code{printf}ファミリーのローカルライブラリーが生成する精度の効果が表れます。 \n"
 "@samp{%s}と@samp{%S}にたいしては、文字列を精度で指定された幅に切り詰めます。したがって@samp{%.3s}では、@var{object}にたいするプリント表現の最初の3文字だけが表示されます。他のフォーマット仕様文字にたいしては、精度の効果はローカルライブラリーの@code{printf}関数ファミリーが生成する効果となります。"
 
 #. type: cindex
@@ -2649,7 +2649,7 @@ msgstr "equivalences"
 #. type: table
 #: original_texis/strings.texi:1628
 msgid "The equivalences table maps each one of a set of case-related characters into the next character in that set."
-msgstr "equivalence(同値)テーブルは、大の字小文字に関連した文字セットのそれぞれを、そのセットの次の文字にマップする。"
+msgstr "equivalence(同値)テーブルは、大文字・小文字に関連した文字セットのそれぞれを、そのセットの次の文字にマップする。"
 
 #. type: Plain text
 #: original_texis/strings.texi:1632
diff --git a/lispref/symbols.texi.po b/lispref/symbols.texi.po
index 16d33b1..0705e3d 100644
--- a/lispref/symbols.texi.po
+++ b/lispref/symbols.texi.po
@@ -342,7 +342,7 @@ msgstr "ソースコード内でシンボルを参照する名前に出会うと
 #. type: Plain text
 #: original_texis/symbols.texi:208
 msgid "When looking up names, the Lisp reader also considers ``shorthands''.  If the programmer supplied them, this allows the reader to find a symbol even if its name isn't present in its full form in the source code.  Of course, the reader needs to be aware of some pre-established context about such shorthands, much as one needs context to be to able to refer uniquely to Jan Jones by just the name ``Jan'': it's probably fine when amongst the Joneses, or when Jan has been mentioned recently, but very ambiguous in any other situation.  @xref{Shorthands}."
-msgstr "Lispリーダーは名前の照合時には``ショートハンド(shorthandx 速記''も考慮します。プログラマーがショートハンドを提供した場合には、たとえソースコード内でシンボル名が完全な形式で与えられなくても、リーダーはシンボルを見つけることができます。もちろんリーダーはそのようなショートハンドに関して事前に既定されたコンテキストを認識する必要があり、同様に``Jan''という名前だけでJan Jonesを一意に参照できるコンテキストが必要です。これはJonesの中にいるときや、Janが最近言及されていれば問題はないでしょうが、他の状況下では非常に曖昧です。@ref{Shorthands}を参照してください。"
+msgstr "Lispリーダーは名前の照合時には``ショートハンド(shorthands 速記、簡略表記)''も考慮します。プログラマーがショートハンドを提供した場合には、たとえソースコード内でシンボル名が完全な形式で与えられなくても、リーダーはシンボルを見つけることができます。もちろんリーダーはそのようなショートハンドに関して事前に既定されたコンテキストを認識する必要があり、同様に``Jan''という名前だけでJan Jonesを一意に参照できるコンテキストが必要です。これはJonesの中にいるときや、Janが最近言及されていれば問題はないでしょうが、他の状況下では非常に曖昧です。@ref{Shorthands}を参照してください。"
 
 #. type: cindex
 #: original_texis/symbols.texi:209
@@ -459,7 +459,7 @@ msgstr "make-symbol name"
 #. type: defun
 #: original_texis/symbols.texi:295
 msgid "This function returns a newly-allocated, uninterned symbol whose name is @var{name} (which must be a string).  Its value and function definition are void, and its property list is @code{nil}.  In the example below, the value of @code{sym} is not @code{eq} to @code{foo} because it is a distinct uninterned symbol whose name is also @samp{foo}."
-msgstr "この関数は新たに割り当てられた、名前が@var{name}(文字列でなかればならない)であるような、インターンされていないシンボルをリターンする。このシンボルの値と関数はvoidで、プロパティーリストは@code{nil}。以下の例では@code{sym}の値は@code{foo}と@code{eq}ではない。なぜならこれは名前が@samp{foo}という、インターンされていないシンボルだからである。"
+msgstr "この関数は新たに割り当てられた、名前が@var{name}(文字列でなければならない)であるような、インターンされていないシンボルをリターンする。このシンボルの値と関数はvoidで、プロパティーリストは@code{nil}。以下の例では@code{sym}の値は@code{foo}と@code{eq}ではない。なぜならこれは名前が@samp{foo}という、インターンされていないシンボルだからである。"
 
 #. type: example
 #: original_texis/symbols.texi:301
@@ -672,7 +672,7 @@ msgstr "unintern symbol obarray"
 #. type: defun
 #: original_texis/symbols.texi:410
 msgid "This function deletes @var{symbol} from the obarray @var{obarray}.  If @code{symbol} is not actually in the obarray, @code{unintern} does nothing.  If @var{obarray} is @code{nil}, the current obarray is used."
-msgstr "この関数はオブジェクト配列@var{obarray}から@var{symbol}を削除する。obarrayの中に@code{symbol}が存在ければ、@code{unintern}は何も行なわない。@var{obarray}が@code{nil}なら現在のobarrayが使用される。"
+msgstr "この関数はオブジェクト配列@var{obarray}から@var{symbol}を削除する。obarrayの中に@code{symbol}が存在しなければ、@code{unintern}は何も行なわない。@var{obarray}が@code{nil}なら現在のobarrayが使用される。"
 
 #. type: defun
 #: original_texis/symbols.texi:415
@@ -927,7 +927,7 @@ msgstr "theme-face"
 #. type: table
 #: original_texis/symbols.texi:548
 msgid "These properties are used to record a face's standard, saved, customized, and themed face specs.  Do not set them directly; they are managed by @code{defface} and related functions.  @xref{Defining Faces}."
-msgstr "これらのプロパティーはフェイスの標準のフェイス仕様(face specs)と、フォント仕様のsaved-fase、customized-face、themed-faceを記録するために使用される。これらのプロパティーを直接セットしないこと。これらのプロパティーは@code{defface}と関連する関数により管理される。@ref{Defining Faces}を参照のこと。"
+msgstr "これらのプロパティーはフェイスの標準のフェイス仕様(face specs)と、フォント仕様のsaved-face、customized-face、themed-faceを記録するために使用される。これらのプロパティーを直接セットしないこと。これらのプロパティーは@code{defface}と関連する関数により管理される。@ref{Defining Faces}を参照のこと。"
 
 #. type: item
 #: original_texis/symbols.texi:549
@@ -1178,7 +1178,7 @@ msgstr "``名前変更シンボル(renamed symbols)''と呼ばれることもあ
 #. type: Plain text
 #: original_texis/symbols.texi:657
 msgid "It is useful to think of shorthands as @emph{abbreviating} the full names of intended symbols.  Despite this, do not confuse shorthands with the Abbrev system @pxref{Abbrevs}."
-msgstr "ショートハンドを意図するシンボルの完全名にたいする@emph{略語(abbreviating)}と考えることは有益です。その点を除けばAbbrevシステム(@ref{Abbrevs}を参照)とショートハンドをコンドミニアムしないでください。"
+msgstr "ショートハンドを意図するシンボルの完全名にたいする@emph{略語(abbreviating)}と考えることは有益です。その点を除けばAbbrevシステム(@ref{Abbrevs}を参照)とショートハンドを混同しないでください。"
 
 #. type: cindex
 #: original_texis/symbols.texi:658
