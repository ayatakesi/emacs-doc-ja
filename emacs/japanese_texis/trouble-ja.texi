@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================

@c This is part of the Emacs manual.
@c Copyright (C) 1985--1987, 1993--1995, 1997, 2001--2024 Free Software
@c Foundation, Inc.
@c See file emacs-ja.texi for copying conditions.
@iftex
@chapter 一般的な問題への対処

  意図しないコマンドをタイプした場合、その結果は不可解なことが多くあります。このチャプターでは、間違いをキャンセルしたり、不可解な状況から復帰するために何ができるかを示します。Emacsのバグとシステムクラッシュについても考察します。
@end iftex

@ifnottex
@raisesections
@end ifnottex

@node Quitting
@section 中止と中断

@table @kbd
@item C-g
@itemx C-@key{Break} @r{(MS-DOSのみ)}
quit(中止): コマンドの実行、または途中までタイプしたコマンドをキャンセルします。
@item C-]
最内の再帰編集レベル(recursive editing
level)をabort(中断)して、それを呼び出したコマンドをキャンセルします(@code{abort-recursive-edit})。
@item @key{ESC} @key{ESC} @key{ESC}
quitまたはabortのどちらか、意味のあるほうを行ないます(@code{keyboard-escape-quit})。
@item M-x top-level
現在実行中のすべての再帰編集レベルをabortします。
@item C-/
@itemx C-x u
@itemx C-_
バッファー内容にたいする直前の変更をキャンセルします(@code{undo})。
@end table

  完了する前のコマンドをキャンセルする方法は2つあります。それは@kbd{C-g}による@dfn{quit}と、@kbd{C-]}や@kbd{M-x
top-level}による@dfn{abort}です。quitは途中までタイプしたコマンド、または実行中のコマンドをキャンセルします。abortは再帰編集レベルを抜けて、再帰編集を呼び出したコマンドをキャンセルします(@ref{Recursive
Edit}を参照してください)。

@cindex quitting
@kindex C-g
  @kbd{C-g}によるquitは、途中までタイプしたコマンドから抜けたり、望まない数引数から抜け出す方法です。さらに、あるコマンドが実行中の場合、@kbd{C-g}は比較的安全にコマンドを停止します。たとえば、長い時間がかかるkillコマンドをquitした場合、@emph{すべて}のテキストがバッファーに残るか、または@emph{すべて}のテキストがkillリングに残るか、もしかしたらその両方かもしれません。リージョンがアクティブの場合、Transient
Markモードがオフでなければ、@kbd{C-g}はマークを非アクティブにします(@ref{Disabled Transient
Mark}を参照してください)。インクリメンタル検索の途中では、@kbd{C-g}は特別に振る舞います。検索を抜けるには2回連続して@kbd{C-g}をタイプします。詳細は、@ref{Incremental
Search}を参照してください。

  ミニバッファー内で@kbd{C-g}をタイプすると、ミニバッファーをオープンしたコマンドを終了して、ミニバッファーをクローズします。そのミニバッファーがもっとも最近オープンされたのでなければ(これは@code{minibuffer-follows-selected-frame}が@code{nil}の際に発生し得る。@ref{Basic
Minibuffer}を参照)、@kbd{C-g}は同意を求めた後にそれより最近にオープンされたミニバッファーもクローズして、それらに関連するコマンドを終了します。

  MS-DOSでは、文字@kbd{C-@key{Break}}が@kbd{C-g}のような文字の役割をします。MS-DOSではユーザーとの相互作用を行なうとき以外に、実行中のコマンドで@kbd{C-g}を認識できないのが理由です。それとは対照的に、@kbd{C-@key{Break}}は常に認識できます。
@iftex
@ref{MS-DOS Keyboard,,,emacs-xtra, Specialized Emacs Features}を参照してください。
@end iftex
@ifnottex
@ref{MS-DOS Keyboard}を参照してください。
@end ifnottex

@findex keyboard-quit
  @kbd{C-g}をタイプした瞬間に変数@code{quit-flag}を@code{t}にセットすることにより、@kbd{C-g}は機能します。Emacs
Lispはこの変数を頻繁にチェックして、これが非@code{nil}のときはquitします。Emacsが入力待ちのときにタイプしたときだけ、@kbd{C-g}は実際にコマンドとして実行されます。この場合に実行されるコマンドは、@code{keyboard-quit}です。

  テキスト端末では、最初の@kbd{C-g}が認識される前に2回目の@kbd{C-g}でquitした場合は、emergency
escape(緊急エスケープ)機能がアクティブになり、シェルに戻ります。@ref{Emergency Escape}を参照してください。

@cindex NFS and quitting
  quitできない状況もいくつか存在します。Emacsがオペレーティングシステムが何か行なうのを待つような場合、待ちが発生する箇所で特定のシステムコールにたいして、Emacsが特別な対処をしない場合、quitは不可能です。ユーザーがquitしたいと望むようなシステムコールにたいして、わたしたちはこれを行なっていなすが、それでも処理できないケースに出会う場合もあります。とても一般的なケースの1つは、NFSを使用したファイルへの入出力待ちです。Emacs自体はquitする方法を知っていますが、多くのNFS実装は、NFSサーバーがハングしたとき、ユーザープログラムがNFSを待つのを止めることを、単に許していません。

@cindex aborting recursive edit
@findex abort-recursive-edit
@kindex C-]
  @kbd{C-]}
(@code{abort-recursive-edit})によるabortは、再帰編集レベルを抜けて、それを呼び出したコマンドをキャンセルするのに使用されます。@kbd{C-g}によるquitはこれを行なわず、行なうこともできません。なぜならこれは再帰編集レベルの@emph{中}で、途中までタイプされたコマンドをキャンセルするからです。どちらの操作も有用です。たとえば再帰編集中に、数引数を入力するために@kbd{C-u
8}とタイプした場合、@kbd{C-g}でその引数をキャンセルして、その再帰編集レベルに留まることができます。

@findex keyboard-escape-quit
@kindex ESC ESC ESC
  シーケンス@kbd{@key{ESC} @key{ESC} @key{ESC}}
(@code{keyboard-escape-quit})は、quitかabortのどちらかを呼び出します(多くのPCプログラムで@key{ESC}は``抜け出す''ことを意味するので、このような定義にしました)。これは@kbd{C-g}のように、プレフィクス引数のキャンセル、選択されたリージョンのクリアー、また問い合わせつき置換から抜け出すこともできます。また@kbd{C-]}のように、ミニバッファーから抜け出したり、再帰編集から抜け出すこともできます。これは@kbd{C-x
1}のように、フレームの複数ウィンドウ分割から抜け出すこともできます。これが行なうことができないのは、実行中のコマンドの停止です。これは通常のコマンドとして実行されるので、Emacsが次のコマンドのために準備ができるまで、これを認識しないからです。

@findex top-level
  コマンド@kbd{M-x
top-level}は、現在の再帰編集レベルからすべての再帰編集レベルを抜けるための、充分な回数の@kbd{C-]}コマンドと等価です。ミニバッファーがアクティブなときは、ミニバッファーも抜けます。@kbd{C-]}は、1度に1レベル再帰編集レベルを抜けますが、@kbd{M-x
top-level}は、1度ですべての再帰編集レベルを抜けます。@kbd{C-]}と@kbd{M-x
top-level}の両方とも、他のすべてのコマンドと同様(そして@kbd{C-g}とは異なり)、Emacsがコマンドにたいして準備ができているときだけ効果があります。@kbd{C-]}は通常のキーで、このキーが意味をもつのは、それがキーマップでバインドされているときだけです。@ref{Recursive
Edit}を参照してください。

  厳密に言えば@kbd{C-/}
(@code{undo})はキャンセルコマンドではありませんが、すでに実行を終えたコマンドをキャンセルすると考えることができます。undo機能についての詳細は、@ref{Undo}を参照してください。

@node Lossage
@section Emacsのトラブルへの対処
@cindex troubleshooting Emacs

  このセクションでは、キーボードコードのミクスアップ(mixup)、文字化け、メモリー不足、クラッシュやハングなど、Emacsが期待したとおりに動作しない状況の認識と対処法について説明します。

  Emacsでバグを見つけたと思ったら何をすればよいかについては、@ref{Bugs}を参照してください。

@menu
* Stuck Recursive::          モードラインのカッコの周囲の'[...]'。
* Screen Garbled::           画面上のゴミ。
* Text Garbled::             テキストの中のゴミ。
* Memory Full::              メモリー不足に対処する方法。
* Crashing::                 クラッシュ時にEmacsが何を行なうか。
* After a Crash::            クラッシュしたEmacsセッションでの編集をリカバリーする。
* Emergency Escape::         Emacsが応答しなくなったとき、何を行なうべきか。
* DEL Does Not Delete::      @key{DEL}で削除できないとき、何を行なうべきか。
@end menu

@node Stuck Recursive
@subsection 再帰編集レベル
@cindex stuck in recursive editing
@cindex recursive editing, cannot exit

  再帰編集レベルは、Emacsの重要かつ便利な機能ですが、それを理解していない場合は、うまく機能していないように見えるかもしれません。

  モードラインの、メジャーモードやマイナーモードを囲む丸カッコ(parentheses)の周囲に、角カッコ(square
brackets)@samp{[@dots{}]}がある場合、それは再帰編集レベルにいることを意味します。もしこれが目的でない場合、またはその意味を理解していない場合は、すぐに再帰編集レベルを抜けるべきです。これを行なうには、@kbd{M-x
top-level}とタイプします。@ref{Recursive Edit}を参照してください。

@node Screen Garbled
@subsection スクリーン上のゴミ
@cindex garbled display
@cindex display, incorrect
@cindex screen display, wrong

  テキスト端末でテキストが間違って見える場合、まず行なうことはバッファーのテキストが間違っていないか確かめることです。画面全体を再描画するために、@kbd{C-l}
(@code{recenter-top-bottom})とタイプしてください。この後でスクリーンが正常に表示される場合、問題は前のスクリーンの更新にあります(そうでない場合は、以下のセクションを参照してください)。

  ディスプレイ更新の問題は、使用している端末にたいする間違ったterminfoエントリーの結果であることがしばしばあります。Emacsディストリビューションのファイル@file{etc/TERMS}は、この種の既知の問題にたいする解決を与えます。@file{INSTALL}のセクションの中の1つは、これらの問題にたいする一般的なアドバイスを含みます。正しいterminfoエントリーを使用しているようなら、それはterminfoエントリーにバグがあるか、特定の端末タイプで発生するEmacsのバグである可能性があります。

@node Text Garbled
@subsection テキスト内のゴミ
@cindex garbled text
@cindex buffer text garbled

  @kbd{C-l}がそのテキストが間違っていることを示す場合、最初に実際の結果を生成するのに何のコマンドをタイプしたか見るために、@kbd{C-h l}
(@code{view-lossage})とタイプします。それから@kbd{C-x u}
(@code{undo})を使用して、正しいと思える状態まで、1つずつ変更をundoします。

  バッファーの先頭または最後の大量のテキストが失われているように見える場合は、モードラインに単語@samp{Narrow}が表示されていないかチェックします。もしこれが表示されている場合、表示されていないテキストはまだ存在しますが、一時的に制限されています。これに再びアクセスできるようにするには、@kbd{C-x
n w} (@code{widen})とタイプします。@ref{Narrowing}を参照してください。

@node Memory Full
@subsection メモリー不足
@cindex memory full
@cindex out of memory

  @samp{Virtual memory exceeded}というエラーメッセージが表示された場合は、@kbd{C-x s}
(@code{save-some-buffers})で変更されたバッファーを保存してください。この方法は、バッファーを保存するのに最小限の追加メモリーを必要とします。Emacsはこのエラーが発生したときでも利用可能な予備メモリーを保持しており、それは@kbd{C-x
s}が処理を完了するのに充分なはずです。予備メモリーを使用したとき、モードラインの先頭に@samp{!MEM
FULL!}が表示された場合、それは予備メモリーも使い切ったことを意味します。

  変更されたバッファーを変更したら、このEmacsセッションを終了して別のセッションを開始するか、@kbd{M-x
kill-some-buffers}を使用して、カレントEmacsジョブのスペースを開放できます。これにより充分なスペースが開放された場合、予備メモリーは再充填され、モードラインから@samp{!MEM
FULL!}の表示が消えます。これは同じEmacsセッションで、安全に編集を継続できることを意味します。

  メモリー不足のときは、バッファーの保存やkillに@kbd{M-x buffer-menu}を使用しないでください。Buffer
Menuはかなりの量のメモリーを必要とするので、予備メモリーの供給では不充分でしょう。

@cindex out of memory killer, GNU/Linux
@cindex OOM killer
  GNU/Linuxシステムでは、Emacsがメモリー不足(out-of-memory)という状況の通知を受け取ることは通常はありません。かわりにEmacsプロセスがメモリー不足になると、OSがEmacsをkillするかもしれません。これは@dfn{out-of-memory
killer}、あるいは@dfn{@acronym{OOM}
killer}という名前で知られている機能です。この動作が効力をもつ際にはメモリー不足という状況をEmacsがすぐに検知することはできず、上述のようなバッファーの保存をあなたに促すことはできないでしょう。ただしOSのこの動作をオフに切り替えることは可能であり、そうすればEmacsがkillされてしまう前に、メモリー不足という状況をもっと有益なやり方で処理するチャンスが生まれます。これを行うにはスーパーユーザーになり、以下の行を@code{/etc/sysctl.conf}に含めてから、シェルプロンプトでコマンド@w{@kbd{sysctl
-p}}を呼び出してください:

@example
vm.overcommit_memory=2
vm.overcommit_ratio=0
@end example

@noindent
上記のセッティングはシステム上の全プロセスに影響を与えること、そしてメモリー負荷が高いシステムでは、Emacsプロセスに限定されない一般的な動作であることに注意してください。

@node Crashing
@subsection Emacsがクラッシュしたとき

@cindex crash report
@cindex backtrace
@cindex @file{emacs_backtrace.txt} file, MS-Windows
  Emacsはクラッシュを前提としていませんが、もしクラッシュした場合、exitする前に@dfn{クラッシュレポート(crash
report)}を生成します。クラッシュレポートは標準エラーストリームにプリントされます。EmacsがGNUシステムまたはUnixシステムでグラフィカルなデスクトップから開始された場合、標準エラーストリームは一般的に@file{~/.xsession-errors}のようなファイルにリダイレクトされるので、そこでクラッシュレポートを探すことができます。MS-Windowsでは、クラッシュレポートは標準エラーストリームに加え、Emacsプロセスのカレントとディレクトリーの、@file{emacs_backtrace.txt}という名前のファイルに書き込まれます。

  クラッシュレポートのフォーマットは、プラットフォームに依存します。GNU
Cライブラリーを使用するいくつかのプラットフォームでは、クラッシュレポートには、クラッシュ前の実行状態を説明する@dfn{backtrace}が含まれ、これはクラッシュをデバッグする助けとなります。以下はGNUシステムの例です:

@example
Fatal error 11: Segmentation fault
Backtrace:
emacs[0x5094e4]
emacs[0x4ed3e6]
emacs[0x4ed504]
/lib64/libpthread.so.0[0x375220efe0]
/lib64/libpthread.so.0(read+0xe)[0x375220e08e]
emacs[0x509af6]
emacs[0x5acc26]
@dots{}
@end example

@noindent
数字@samp{11} はクラッシュにたいするシステムのシグナル番号 --- このケースではsegmentation fault ---
です。16進数字はプログラムのアドレスで、これによりデバッグツールを使用して、ソースコード行に関連付けることができます。たとえばGDBコマンド@samp{list
*0x509af6}は、@samp{emacs[0x509af6]}エントリーにたいするソースコード行をプリントします。システムに@command{addr2line}ユーティリティーがある場合、以下のシェルコマンドはソースコードの行番号とともに、backtraceを出力します:

@example
sed -n 's/.*\[\(.*\)]$/\1/p' @var{backtrace} |
  addr2line -C -f -i -p -e @var{bindir}/@var{emacs-binary}
@end example

@noindent
On MS-Windows, the backtrace looks somewhat differently, for example:<
MS-Windowsではバックトレースの外観は若干異なります。以下は例です:

@example
Backtrace:
00007ff61166a12e
00007ff611538be1
00007ff611559601
00007ff6116ce84a
00007ff9b7977ff0
@dots{}
@end example

@noindent
したがって@command{sed}を通じたフィルタリングであり、ソースコードの行番号を表示するコマンドは以下のようになります

@example
 addr2line -C -f -i -p -e @var{bindir}/@var{emacs-binary} < @var{backtrace}
@end example

@noindent
ここで@var{backtrace}はbacktraceのコピーを含むテキストファイル名、@var{bindir}はEmacs実行可能ファイルを含むディレクトリー名(MS-WindowsではEmacsを起動したディレクトリーにある@file{emacs_backtrace.txt})、@var{emacs-binary}はEmacs実行可能ファイル(GNUおよびUnixシステムでは通常は@file{emacs}、MS-WindowsおよびMS-DOSでは@file{emacs.exe})です。@option{-p}オプションがない古いバージョンの@command{addr2line}では、このオプションを省略してください。

@cindex core dump
  coreファイルをサポートするシステムでは、Emacsはオプションで@dfn{コアダンプ(core
dump)}を生成します。コアダンプはクラッシュ前のプログラムの状態に関する多くのデータを含むファイルで、通常GDBのようなデバッガーにロードして調べられます。多くのプラットフォームでは、コアダンプはデフォルトで無効になっているので、(たとえばシェルのスタートアップスクリプトで)シェルコマンド@samp{ulimit
-c unlimited}を実行して、明示的に有効にしなければなりません。

@node After a Crash
@subsection クラッシュ後のリカバリー
@cindex recovering crashed session

  Emacs、またはコンピューターがクラッシュした場合、クラッシュしたとき編集していたファイルを、自動保存ファイルからリカバリーすることができます。これを行なうには、再びEmacsを開始して、コマンド@kbd{M-x
recover-session}とタイプしてください。

  このコマンドはm最初に中断されたセッションのファイルを、ファイルの日付とともにリストするバッファーを表示します。そこからリカバリーするファイルを、選択しなければなりません。通常リカバリーしたいファイルは、一番最近のセッションでしょう。選択したファイルにポイントを移動して、@kbd{C-c
C-c}とタイプしてください。

  その後@code{recover-session}は、そのセッション中に編集していた各ファイルについて、検討を行ないます。そのようなファイルそれぞれについて、そのファイルをリカバリーするか尋ねるのです。あるファイルにたいして@kbd{y}と応えると、コマンドはファイルとファイルの自動保存ファイルの日付を表示して、再度そのファイルをリカバリーするか尋ねます。この2回目の質問にたいして同意するには、@kbd{yes}と応えなければなりません。@kbd{yes}と応えた場合、Emacsはそのファイルをvisitしますが、テキストは自動保存ファイルから取得します。

  @code{recover-session}が終了すると、リカバリーを選択したファイルがEmacsバッファーに表示されます。そこでファイルを保存する必要があります。それらを保存することだけが、そのファイル自身を更新するのです。

  ファイルに関連付けられていないバッファーをリカバリーしたいときや、自動保存が重要な更新を記録するほど最新でなかった場合、最後の手段として ---
コアダンプが保存されていて、Emacsの実行ファイルからデバッグシンボルがストリップされていないという条件の元に ---
コアダンプからそれらを取得するために、GDB(GNUデバッガー)で@file{etc/emacs-buffer.gdb}スクリプトを使用することができます。

  コアダンプを入手したら、すぐに@file{core.emacs}のような別の名前にリネームします。これにより、他のクラッシュによるコアダンプの上書きを防ぎます。

  このスクリプトを使用するには、Emacs実行ファイル名とコアダンプのファイル名を、@samp{gdb /usr/bin/emacs
core.emacs}のように指定します。@code{(gdb)}プロンプトで、@samp{source
/usr/src/emacs/etc/emacs-buffer.gdb}としてリカバリースクリプトをロードします。それから利用可能なバッファーを見るために、コマンド@code{ybuffer-list}とタイプします。これは各バッファーにたいして、バッファー番号をリストします。バッファーを保存するには、@code{ysave-buffer}を使用します。ここでバッファー番号とそのバッファーを書き込むファイル名を指定します。すでに存在するファイル名を使用するべきではありません。ファイルがすでに存在する場合、このスクリプトはそのファイルの古い内容のバックアップを作成しません。

@node Emergency Escape
@subsection 緊急エスケープ
@cindex emergency escape

  テキスト端末では、1回目の@kbd{C-g}にたいしてEmacsが実際に反応してquitする前に、2回目の@kbd{C-g}をタイプすると、@dfn{緊急エスケープ(emergency
escape)}が、Emacsを即座にサスペンドします。これにより、どんなにひどくハングしていても、常にGNU
Emacsを抜け出すことができます。物事が正しく処理されている場合、Emacsは最初の@kbd{C-g}を素早く認識・処理するので。2回目の@kbd{C-g}は緊急エスケープを引き起こしません。しかし何らかの問題が、Emacsが最初の@kbd{C-g}を処理するのを妨げる場合、2回目の@kbd{C-g}でシェルに戻ります。

  緊急エスケープによるサスペンドからEmacsを再開する場合、サスペンド前に行なっていた何かに戻る前に、Emacsは回復の報告と、以下の2つの質問をします:

@example
Emacs is resuming after an emergency escape.
Auto-save? (y or n)
Abort (and dump core)? (y or n)
@end example

@noindent
質問に応えるには、それぞれにたいして@kbd{y}または@kbd{n}の後に、@key{RET}をタイプします。

  @samp{Auto-save?}にたいして@kbd{y}と応えると、自動保存が有効なすべての編集されたバッファーの自動保存を、即座に行ないます。@kbd{n}と応えると、これをスキップします。この質問は、Emacsが安全に自動保存を行えないような、何らかの状況にある場合は省略されます。

  @samp{Abort (and dump
core)?}にたいして@kbd{y}と応えると、Emacsはクラッシュしてコアダンプします。これは専門家(wizard)が、なぜEmacsが最初の@kbd{C-g}でquitしなかったかを見つけ出すことを可能にします。コアダンプの後、実行は継続されません。

  この質問に@kbd{n}と応えた場合、Emacsは実行を再開します。運がよければ、Emacsは最終的にquit要求を行なうでしょう。そうでない場合、連続して@kbd{C-g}をタイプして、緊急エスケープを再度呼び出します。

  実際はEmacsがハングしているのではなく、遅いだけの場合、本当に意味するところを意図せずに、2連@kbd{C-g}の機能を呼び出してしまうかもしれません。この場合は、2つの質問の両方に@kbd{n}を応えれば、前の状態に戻ることができます。やがて要求したquitが行なわれるでしょう。

  緊急エスケープはテキスト端末だけでアクティブになっています。グラフィカルなディスプレイでは、マウスを使用してEmacsをkillしたり、他のプログラムに切り替えることができます。

  MS-DOSでは緊急エスケープを発生させるために、@kbd{C-@key{Break}}を2回タイプしなければなりません ---
しかしシステムコールがハングしたり、EmacsがCコードのタイトなループにハマっているときは機能しないケースがあります。

@node DEL Does Not Delete
@subsection @key{DEL}で削除できない場合
@cindex @key{DEL} vs @key{BACKSPACE}
@cindex @key{BACKSPACE} vs @key{DEL}
@cindex @key{DEL} does not delete

  すべてのキーボードには多くのキーがありますが、通常@key{BACKSPACE}とラベルされたキーは、最後にタイプした文字を削除するのに使用されます。Emacsでは、このキーは@key{DEL}に等しいと想定されています。

  グラフィカルなディスプレイでEmacsを開始したとき、Emacsはどのキーが@key{DEL}なのか自動的に決定します。いくつかの特殊なケースでは、Emacsがシステムから間違った情報を取得して、@key{BACKSPACE}が後方ではなく前方に削除する場合があります。

  @key{Delete}というキーをもつキーボードもあります。これは通常、前方に削除するために使用されます。Emacsでこのキーが後方に削除を行なう場合も、Emacsが間違った情報
--- ただし反対の意味の --- を受け取ったことを意味します。

  テキスト端末で、@key{BACKSPACE}が文字を削除するかわりに、@kbd{Control-h}のようなヘルプコマンドのプロンプトを表示する場合、それはこのキーが実際は@samp{BS}文字を送っていることを意味します。Emacsは@key{BS}を@key{DEL}と扱うべきですが、そうしていないのです。

@findex normal-erase-is-backspace-mode
  これらのケースのすべてにおいて、直ちに改善できることは同じでで、それはコマンド@kbd{M-x
normal-erase-is-backspace-mode}を使用する方法です。これはEmacsが@key{DEL}の処理をサポートする2つのモードを切り替えるので、もしEmacsが間違ったモードで開始された場合、正しいモードに切り替えることができます。テキスト端末では、@key{BS}が@key{DEL}として扱われる場合にヘルプを見たいときは、@kbd{C-h}のかわりに@key{F1}を使用します。@kbd{C-?}が文字コード127を送る場合は、このキーも機能するでしょう。

  すべてのEmacsセッションで問題を解決するには、初期化ファイル(@ref{Init
File}を参照してください)に以下の行の1つを記述します。上記の最初のケースでは、@key{BACKSPACE}が後方ではなく前方に削除を行なうので、@key{BACKSPACE}が@key{DEL}として動作するように、以下の行を使用します:

@lisp
(normal-erase-is-backspace-mode 0)
@end lisp

@noindent
他の2つのケースでは、以下の行を使用します:

@lisp
(normal-erase-is-backspace-mode 1)
@end lisp

@vindex normal-erase-is-backspace
  すべてのEmacsセッションで問題を解決する別の方法は、変数@code{normal-erase-is-backspace}をカスタマイズする方法です。@key{BS}または@key{BACKSPACE}が@key{DEL}となるようにモードを指定するには値@code{t}、他のモードにたいしては@code{nil}を指定します。@ref{Easy
Customization}を参照してください。

@node Bugs
@section バグの報告

@cindex bugs
  Emacsでバグを見つけたと思ったときは、それを報告してください。それをfixすることは約束できませんし、それがバグであると常に認める訳ではありませんが、もちろんそれについて知りたいのです。追加したいと考える機能についても、同じことが言えます。このセクションはあなたが見つけたのがバグかどうかを判断したり、バグの場合に有効なバグレポートを作成する助けとなるでしょう。

バグの可能性がある何かを発見した際の一般的な手順は以下のようになります:

@itemize @bullet
@item
あなたが発見したものが既知の問題なのか、あるいはすでに報告および/または訂正されているバグなのかを確認してください。既知の問題やバグを調べる方法については、@ref{Known
Problems}で答えが得られるでしょう。

@item
あなたが見た挙動がバグなのか確信がもてなければ、@ref{Bug
Criteria}を参照のしてください。そこにはEmacsにおいて明確なバグだとわたしたちがみなすものについて記述されています。

@item
バグを見つけたと判断したら@ref{Understanding Bug
Reporting}を参照してください。わたしたちが問題の再現と調査を容易に行えるように、あなたが何を見つけたかをもっとも効率的に記述する助けとなる筈です。

@item
次に@ref{Checklist, Checklist for Bug
Reports}を参照してください。そこにはバグレポートを送信する方法、および含める情報についての詳細が記述されています。簡単に述べると、電子メールを通じてバグレポートを送信する助けとなるコマンド@code{report-emacs-bug}を通じてそれらを行うことになります。バグレポートの送信によってバグの調査および訂正のプロセスが始まり、そのバグに関して議論する電子メールのコピーを受け取ることになるでしょう。更に詳細な情報の提供や、見込みのある訂正のテスト等を求められるかもしれません。

@item
最後にバグの修整、新機能の追加、ドキュメントの改善などEmacsにたいして特定の変更を提案したい場合には、どうか@ref{Sending
Patches}を参照してください。そこにはその類いの変更を送信する際に関する詳細が記述されています。
@end itemize

@menu
* Known Problems::           既知の問題とバグについて読む方法。
* Criteria: Bug Criteria.    本当にバグを見つけたのか?
* Understanding Bug Reporting::  バグを報告する効果的な方法。
* Checklist::                良いバグレポートのために従うべきステップ。
* Sending Patches::          GNU Emacsにパッチを送る方法。
@end menu

@node Known Problems
@subsection 既存のバグレポートの既知の問題を読む
@cindex known bugs and problems

  バグを報告する前に、少しでも可能ならわたしたちが既に把握済みのバグではないか確認してください。実際にはそれがもっと後のEmacsリリースや、Emacsの開発バージョンですでにfixされているかもしれません。以下は既知の問題について読むことができる主な場所のリストです:

@itemize
@item
@file{etc/PROBLEMS}ファイル。@kbd{C-h
C-p}とタイプして読むことができます。このファイルにはEmacsをコンパイル、インストール、実行するときに出会うであろう既知の問題について、特に他のソフトウェアに起因する問題のためEmacsでは解決が困難な問題に重点を置いた詳細リストが含まれています。次善策や解決策の提案も、たくさんあります。

@cindex bug tracker
@cindex issue tracker
@cindex search known bugs
@item
@url{https://debbugs.gnu.org}のGNU Bug
Tracker。Emacsのバグや問題は@samp{emacs}パッケージの下のトラッカーにファイルされています。トラッカーには各バグの状態、最初のバグレポート、バグ報告者、およびバグに関する議論や訂正を共有するEmacs開発者によるフォローアップメッセージについての情報が記録されています。subject、severity、その他の条件でバグを検索できます。

@cindex debbugs package
ウェブページでバグトラッカーを閲覧するかわりに、@code{debbugs}パッケージを使用して、それをEmacsから閲覧できます。このパッケージはパッケージメニュー(@ref{Packages}を参照してください)を通じてダウンロードできます。このパッケージは、バグをリストするコマンド@kbd{M-x
debbugs-gnu}、特定のバグを検索する@kbd{M-x
debbugs-gnu-search}を提供します。Emacsメンテナーにより適用されるユーザータグは、@kbd{M-x
debbugs-gnu-usertags}で表示されます。

@item
@samp{bug-gnu-emacs}メーリングリスト(ニュースグループ@samp{gnu.emacs.bug}も利用可能)。リストのアーカイブは@url{https://lists.gnu.org/mailman/listinfo/bug-gnu-emacs}で見ることができます。このリストはバグトラッカーに送られたEmacsバグレポートとドローアップメッセージの、mirrorとして機能します。これにはバグトラッカーが導入される前(2008年以前)の古いバグレポートも含まれています。

もし望むなら、メーリングリストに登録できます。このリストの目的はEmacsメンテナーにバグと機能リクエストの情報を提供するためのもので、報告には大量のデータが含まれるかもしれないことに注意してください。購読者はこれについて不満を言うべきではありません。

@item
@samp{emacs-pretest-bug}メーリングリスト。このリストは今は使用されておらず、主に歴史的な興味のためのものです。一時は(たとえばまだリリースされていない)Emacs開発バージョンのために使用されていました。2003年から2007年中頃までのアーカイブは、@url{https://lists.gnu.org/r/emacs-pretest-bug/}で見ることができます。このリストに送信された電子メールメッセージは、現在では@samp{bug-gnu-emacs}にリダイレクトされています。

@item
@samp{emacs-devel}メーリングリスト。このメーリングリストにバグを報告する人がときどきいます。しかしこのリストの主な目的は違うので、バグレポートはバグリストに送るほうがよいでしょう。バグを報告する前に、この一覧を読んだことに感謝を感じることはありません。
@end itemize


@node Bug Criteria
@subsection バグがあったとき
@cindex bug criteria
@cindex what constitutes an Emacs bug

  Emacsが不正なメモリー位置にアクセスする場合(``segmentation fault''と呼ばれます)、または(``disk
full''のようなメッセージではなく)プログラムに問題があることを示す、オペレーティングシステムのエラーメッセージとともに終了する場合、それは確実にバグです。

  Emacsがバッファーの内容を正しく対応して表示しないとき、それはバグです。しかしバッファーのナローイング(@ref{Narrowing}を参照してください)チェックするべきです。これはバッファーの一部を隠して、表示される方法を変更できるので、バグではありません。

  コマンドが永久に完了しないなら、それはバグですが、本当にEmacsのせいか確認しなくてはなりません。コマンドの中には単に長時間かかるものがいくつかあります。@kbd{C-g}
(MS-DOSでは@kbd{C-@key{Break}})をタイプしてから、@kbd{C-h
l}で、Emacsが受け取った入力が、あなたがタイプしようと意図したものなのか確認します。その入力が、あなたが素早く処理されるべきだと@emph{わかっている}ものだった場合は、バグを報告してください。そのコマンドが長時間かかるものか判らない場合は、マニュアルを調べるか、協力してくれる人に尋ねてください。

  あなたの親しんでいるコマンドが、コマンドの通常の定義が正当なのに、Emacsのエラーメッセージを表示する場合、それはおそらくバグです。

  コマンドが間違ったことを行なうなら、それはバグです。しかしそのコマンドが何を行なうべきか確実に知っているか確認してください。そのコマンドに詳しくない場合、コマンドは実際は正しく動いているのでしょう。疑うなら、コマンドのドキュメント(@ref{Name
Help}を参照してください)を参照してください。

  あるコマンドの意図された定義が、それを編集するための最良の定義ではないこともあります。これはとても重要な問題の一種ですが、判断の問題でもあります。いくつかの既存の機能にたいする無知から、そのような決定を行なうのは簡単でもあります。通常の方法でドキュメントをチェックして、それを理解したと確信し、あなたがやりたいことが不可能だと確実に判るまでは、そのような問題にたいして不満を言わないのが、おそらく最良です。他のEmacsユーザーにも尋ねてみましょう。マニュアルを注意深く読んだ後でも、そのコマンドが何を想定しているか確信がもてないときは、不明解な単語をindex(索引)やglossary(用語集)でチェックしましょう。

  注意深くマニュアルを読んだ後でも、そのコマンドが何を行なうべきか判らないとき、それは報告すべきマニュアルのバグであることを示します。Emacsのエクスパートでない人
--- あなたを含めて --- にたいして、すべてを明解にするのがマニュアルの役目です。プログラムのバグと同様に、ドキュメントのバグレポートは重要です。

  関数や変数のビルトインドキュメントがマニュアルと異なる場合、どちらか一方が間違っていなければならないので、これはバグです。

  Emacsの一部ではないパッケージについての問題は、そのパッケージの開発者にそれらを報告することにより開始したほうが良いでしょう。

@node Understanding Bug Reporting
@subsection バグレポートの理解
@cindex bug reporting, principles
@cindex report an Emacs bug, how to

  バグがあると判断したときはそれを報告すること、そして有用な方法で報告することが重要です。もっとも有用なのは、Emacsを起動するシェルコマンドから、問題が発生するまで、何のコマンドをタイプしたか、そしてそれらのコマンドをタイプしたことにより生成された効果に関する正確な記述です。

  バグレポートのもっとも重要な原理は、@emph{事実}を報告することです。仮定や口頭の説明は、詳細な生データの代替にはなりません。事実の報告は簡単ですが、多くの人は事実のかわりに仮定の説明をしようと懸命に努め、それを報告するのです。その説明がEmacsが実装されている方法にたいする仮定にもとづく場合、それらは役に立たないかもしれません。その一方で事実の欠落により、わたしたちはバグについての実際の情報を得られないでしょう。実際に問題を@emph{デバッグ}して、推定を超える説明を報告したい場合、それは有用です
--- しかし、どうか生の事実も同様に含めてください。

  たとえば、@kbd{C-x C-f /glorp/baz.ugh
@key{RET}}とタイプして、ファイルをvisitしたとき、そのファイルが偶然大きい(とあなたは知っている)ファイルで、Emacsが@samp{I
feel pretty
today}と表示したとします。バグレポートにはすべての情報が必要になります。あなたは問題がファイルのサイズにあると仮定して、``大きなファイルをvisitしたら、Emacsが@samp{I
feel pretty today}と表示します''、などと報告すべきではありません。これはわたしたちが``推測説明(guessing
explanations)''と呼ぶものです。ファイル名に@samp{z}があるという事実が、問題の原因かもしれません。もしそうなら、あなたの報告を受け取ったとき、わたしたちは大きなファイルで問題の再現を試み、それらのファイル名にはおそらく@samp{z}が含まれておらず、問題を確認できないでしょう。名前に@samp{z}が含まれるファイルをvisitしてみるべきだと、推測できる方法はありません。

  @kbd{C-x
C-f}はおろか、``ファイルをvisitして''とさえ言うべきではありません。なぜならファイルがvisitされる方法は複数あり、それらの方法すべてにおいて問題が再現されるか確証がないからです。同様にテキストを入力する方法では、``その行に3文字あるとき''ではなく、もしもテキストを入力したのであれば``@kbd{@key{RET}
A B C @key{RET} C-p}とタイプした後''、すなわちあなたの場合に問題が発生したテキストについて教えてください。

  可能なら、すぐにバグを再現するために@command{emacs -Q}(Emacsは初期のカスタマイズなしで開始されます。@ref{Initial
Options}を参照してください)でEmacsを呼び出して、バグを発生させるステップを繰り返してみてください。この方法でバグを再現できたら、あなたの個人的なカスタマイズをバグから除外して、バグが容易に再現するようにしてください。バグレポートは、Emacsを@command{emacs
-Q}で開始したことから始まり、バグを再現させる正確な一連のステップを続けるべきです。可能ならバグを再現するのに必要な、正確なファイル内容を報告してください。

  @command{emacs
-Q}では再現できないバグもいくつかあります。結局は再現するのが難しいバグもあります。そのような場合、何を行なったかを報告すべきです ---
が、前述したように、どうか最初にバグを発生させた生の事実を固持してください。

  報告したい複数の問題がある場合は、どうかそれらを個別のバグとしてそれぞれ報告してください。

@node Checklist
@subsection バグレポートのためのチェックリスト
@cindex checklist before reporting a bug
@cindex bug reporting, checklist
@cindex report bugs in Emacs

  バグを報告する前に、まずその問題がすでに報告されていないか、確認を試みてください(@ref{Known Problems}を参照してください)。

もし可能なら、その問題がすでにfixされていないか、最新リリース版のEmacsも試してみてください。同様に、最新の開発版を試してみるのもよいでしょう。これがある人にとっては簡単でないことは認識しているので、バグを報告する前に、絶対にこれを行なわなければならないと思わないでください。

@findex report-emacs-bug
  Emacsでバグレポートを書くベストな方法は、コマンド@kbd{M-x
report-emacs-bug}を使用する方法です。これはメールバッファー(@ref{Sending
Mail}を参照してください)をセットアップして、自動的に@emph{いくつかの}重要な情報を挿入します。しかし、すべての必要な情報は提供できません。だから以下のガイドラインを読んで、それに従うべきです。そうすればメッセージを送る前に、他の重大な情報を手で入力できます。@kbd{M-x
report-emacs-bug}によって挿入されたいくつかの情報は、適切ではないと感じるかもしれませんが、完全に確信があるのでなければそれを残してください。そうすれば開発者たちがそれを判断できます。

レポートを記述し終えたら、@kbd{C-c C-c}とタイプすると、それはEmacsメンテナー
@ifnothtml
@email{bug-gnu-emacs@@gnu.org}に送られます
@end ifnothtml
@ifhtml
@url{https://lists.gnu.org/mailman/listinfo/bug-gnu-emacs,
bug-gnu-emacs}に送られます
@end ifhtml
Emacsの中からメールを送れなければ、バグレポートのテキストを普段使用しているメールクライアントにコピーして、そのアドレスに送信できます(システムがサポートしていれば@kbd{C-c
M-i}でEmacsに行なわせることができる)。または、そのアドレスに問題を説明する簡単なメールを送ることもできます。以下に示す必要な情報を含めてください。

(問題の訂正や新機能の実装等で)Emacsにコードを提供したい場合には、EmacsのIssue
Trackerにpatchを送るのが一番簡単にこれを行う方法です。@kbd{M-x
submit-emacs-patch}コマンドを使用してください。これはバグを報告する際と同じように機能します。@ref{Sending
Patches}を参照してください。

どのような場合でもレポートは@samp{bug-gnu-emacs}メーリングリストに送られて、@url{https://debbugs.gnu.org}のGNU
Bug
Trackerに保管されます。報告について、より詳細な情報を尋ねる必要がある場合のために、どうか有効な返信用アドレスを含めてください。提出されたレポートは調停されるので、Trackerで実際にレポートが見られるようになるまで遅れが生じることもあります。

バグを報告するためにGNU Bug
Trackerがどのように機能するか知る必要はありませんが、もし望むなら、トラッカーの@uref{https://debbugs.gnu.org/Advanced.html,
オンラインドキュメント}で、使用できるさまざま機能を見ることができます。

@samp{bug-gnu-emacs}メーリングリストに送られたすべてのメールは、@samp{gnu.emacs.bug}ニュースグループにもゲートウェイされます。この逆も真ですが、バグレポート(または返信)をニュースグループにポストしないでください。これにより、さらに情報を尋ねるためにあなたに連絡するのが困難になるのと、それがバグトラッカーと充分に統合されていないからです。

データが500,000バイトを超える場合は、どうかそれを直接レポートに含めないでください。要求されたら送るという提案に留めるか、データをオンラインで利用可能にしてその場所を知らせてください。大きい添付ファイルは圧縮して送信するのが最善です。

GNU Bug
Trackerはあなたのレポートにバグ番号を割り当てます。そのバグをフォローする議論ではTrackerがバグの議論を追跡できるように、受信者リストにあるバグのアドレスを消さないでください。バグのアドレスは@samp{@var{nnnnn}@@debbugs.gnu.org}のようなアドレスです。ここで@var{nnnnn}はバグ番号です。

  メンテナーがバグを詳細に調べられるように、レポートには以下の事項を含めるべきです:

@itemize @bullet
@item
あなたが間違いと主張する動作の説明。たとえば``Emacsプロセスが致命的なシグナルを受け取った''とか``結果のテキストは以下だが、これは間違いだと思う''など。

もちろん、Emacsが致命的なシグナルを受け取るというバグなら、見逃すことはないでしょう。しかし、そのバグが正しくないテキストの場合、メンテナーは何が間違っているか気づかないかもしれません。なぜそのような危険を放置するのですか?

あなたが遭遇した問題が致命的なシグナルの場合でも、明示的にそれを告げるべきです。何か奇妙なこと ---
たとえばあなたのソースコピーの同期がとれていない、またはあなたのシステムのCライブラリーにバグがある(これはあり得ます) ---
が起こっているとしましょう。あなたのコピーはクラッシュするかもしれませんが、私たちのコピーはクラッシュしないでしょう。あなたがクラッシュすることを@emph{告げて}いれば、わたしたちのEmacsはクラッシュしないので、バグはなかったとわたしたちは言うことができます。クラッシュすることを告げていない場合、わたしたちはバグがあるかどうか知ることができません
--- わたしたちの観察から、なんらかの結論を描くことも不可能です。

問題の挙動とそれを再現する方法の記述には、通常だと以下に挙げる観点のうち1つ以上が必要です:

@itemize @minus
@item
バグを再現するのに必要なファイルの完全なテキスト。

  ファイルをvisitせずに問題を発生させる方法を説明できるなら、ぜひそうしてください。これによりデバッグがとても簡単になります。ファイルが必要な場合、わたしたちがファイルの正確な内容を見られるよう確実にしてください。たとえば、行末にスペースがあるか、バッファーの最終行の後に改行があるかが問題となる場合があります(最終行が終端されているかどうかを心配すべき理由はないかもしれませんが、それがバグだと報告することを試みてください)。

@item
バグを再現するためにタイプする必要がある、正確なコマンド。少しでも可能なら、@samp{-Q}オプション(@ref{Initial
Options}を参照してください)でEmacsを開始したときからの、完全なレシピを送ってください。このオプションはあなたの個人的なカスタマイズをバイパスします。

@findex open-dribble-file
@cindex dribble file
@cindex logging keystrokes
Emacsへの入力を正確に記録する方法の1つとして、それをdribbleファイルに書き込む方法があります。このファイルを開始するにはコマンド@w{@kbd{M-x
open-dribble-file}}を使用します。このコマンドからそのEmacsプロセスがkillされるまで、Emacsはすべての入力を指定されたdribbleファイルにコピーします。機密情報(パスワードなど)は、dribbleファイルへの記録を終了させることに注意してください。

@item
Emacs ManualやEmacs Lisp Reference
Manualが、実際のEmacsの振る舞いを記述できていない、またはテキストが分かりにくいといったバグの場合、間違いだと思うテキストをマニュアルからコピーしてください。そのセクションが小さければ、セクション名だけで充分です。

@item
バグの徴候がEmacsのエラーメッセージの場合、エラーメッセージの正確なテキストと、EmacsのLispプログラムがどのようにしてエラーに至ったかを示す、backtraceを報告するのが重要です。

エラーメッセージを正確に取得するには、それを@file{*Messages*}バッファーからバグレポートにコピーします。一部だけではなく、すべてをコピーしてください。

@item
Lispの世界にロードしたプログラム(初期化ファイルを含みます)をチェックしてください。任意の変数にたいするセットは、Emacsの機能に影響を与えるかもしれません。初期化ファイルをロードせずに、フレッシュな状態で開始されたEmacsでも、その問題が発生するか確認してください(@code{-Q}スイッチでEmacsを開始することによりinitファイルのロードを抑止できます)。それで問題が発生しなかったら、問題を発生させるためにLispの世界にロードしなければならないプログラムの、正確な内容を報告しなければなりません。

@item
その問題がinitファイルやEmacsの標準システムの一部ではない他のLispプログラムに依存する場合、最初にそれらのプログラムのメンテナーに苦情を訴えて、それがバグでないことを確認すべきです。彼らが機能すると思われる方法でEmacsを使用してバグを確認した後、彼らがそのバグを報告すべきです。

@item
GNU Emacsのソース中の何かについて言及したい場合、数行のコンテキストとともにそのコードの行を示してください。行番号だけを示すのは止めてください。

開発ソースの行番号と、あなたのソースの行番号は一致しません。行番号だけでは、あなたのバージョンでその行番号がどのコードをさすのか、メンテナーが判断するのに余分な作業を要しますし、それに確信をもつこともできません。

@item
@findex open-termscript
@cindex termscript file
@vindex TERM@r{, environment variable, and display bugs}
テキスト端末上での表示のバグである可能性がある場合は、端末タイプ(環境変数@env{TERM}の値)、その端末にたいする@file{/etc/termcap}の完全なtermcapエントリー(このファイルはすべての機種で同じではありません)、Emacsが実際に端末に送った出力。

端末の出力を収集するためには、Emacsを開始した直後にコマンド@kbd{M-x
open-termscript}を呼び出すという方法があります。このコマンドはEmacsプロセスがkillされるまでの間に端末出力をどこに記録するかファイル名の入力を求めます。問題がEmacsのスタートアップ時に発生するようなら、

@example
(open-termscript "~/termscript")
@end example

@noindent
というLisp式をEmacsの初期化ファイルに記述すれば、Emacsが最初にスクリーンを表示する際にtermscriptファイルがオープンされます。

警告: バグをシミュレートする端末タイプへのアクセスなしに、端末依存バグをfixするのは、しばしば困難で、不可能なときもあります。
@end itemize

@item
Emacsのバージョン番号。これがないと、GNU Emacsのカレントバージョンで,
バグを探す意義があるかを知ることができません。

@findex emacs-version
この情報は、@kbd{M-x
report-emacs-bug}により自動的にレポートに含まれますが、レポートでこのコマンドを使用しない場合は、@kbd{M-x
emacs-version @key{RET}}とタイプして、バージョン番号を取得できます。このコマンドが機能しない場合、たぶんあなたはGNU
Emacsではない他の何かを使っているので、どこか他のところにそのバグを報告する必要があるでしょう。

@item
使用している機種のタイプ、およびオペレーティングシステム名とバージョン番号(繰り返しになりますが、これらは@w{@kbd{M-x
report-emacs-bug}}で自動的にレポートに含まれます)。@w{@kbd{M-x emacs-version
@key{RET}}}もこの情報を提供します。@file{*Messages*}バッファーからコマンドの出力をコピーするか、あるいはカレントバッファーにバージョン情報を挿入するために@w{@kbd{C-u
M-x emacs-version @key{RET}}}を使用すれば、すべてを正確に取得できます。

@item
Emacsのビルド時に@code{configure}に与えたコマンドライン引数(@kbd{M-x
report-emacs-bug}により自動的にレポートに含まれます)。

@item
Emacsのソースにたいして行なった変更の完全なリスト(わたしたちには、変更されたEmacsのバグを詳細に調べる時間はないでしょう。しかし変更を行なっていて、それをわたしたちに告げないとしたら、それはわたしたちを野性のダチョウ狩りに送り出すようなものです)。

これらの変更について正確に記述してください。英語による説明では充分ではありません。それらにたいする統一コンテキストdiff(unified
context diff)も送ってください。

独自のファイル追加や、他の機種へのポートも、ソースの変更です。

@item
GNU Emacsの標準的なインストール手順からの、その他あらゆる逸脱の詳細。

@item
非@acronym{ASCII}または国際化されたテキストと関連性がある場合は、Emacsを開始したときのlocale。これは@kbd{M-x
report-emacs-bug}によって自動的に含められます。GNU/LinuxとUnixシステム、またはBashのようなPOSIXスタイルのシェルを使用している場合には、かわりに以下のシェルコマンドを使用して関連する値を見ることができます:

@smallexample
echo LC_ALL=$LC_ALL LC_COLLATE=$LC_COLLATE LC_CTYPE=$LC_CTYPE \
  LC_MESSAGES=$LC_MESSAGES LC_TIME=$LC_TIME LANG=$LANG
@end smallexample

システムにあればGNU/LinuxおよびUnixコマンドを使用して、localeセッティングを表示することもできます。
@end itemize

以下はバグレポートには不要な事柄です:

@itemize @bullet
@item
バグを取り巻く状況の説明 --- これは再現可能なバグにたいしては必要ありません。

バグに遭遇したとき人は、入力ファイルを変えてバグが発生しなくなるか、影響がないかなどを詳しく調べるのに、多くの時間を費やすことがしばしばです。

これは大抵多くの時間がかかる割に、とても有用とは言えません。なぜならわたしたちがバグを探す方法は、ブレークポイントを設定したデバッガーの元で1つの例を実行することであり、一連の例から得られる推論ではないからです。追加の例を探すのを止めることにより、あなたも時間を節約できるでしょう。すぐにバグレポートを送って、編集作業に戻り、報告すべき他のバグを探す法がよいでしょう。

もちろんオリジナルの@emph{かわり}に、簡単な例を見つけることができたら、そちらのほうが便利です。出力中のエラーは簡単に見分けられますし、デバッガーでの実行も時間が短くなります

しかし単純化は必須ではありません、これを行なうことができなかったり、試す時間がない場合は、どうかオリジナルのテストケースでバグを報告してください。

@item
コアダンプファイル。

コアダンプによるデバッグは有用ですが、それはあなたのEmacs実行ファイルと、あなたのマシンだけで行なうことができます。したがってEmacsメンテナーにコアダンプを送るのは、有益ではないでしょう。何よりも、コアダンプをメールのバグレポートに含めないでください!
そのような巨大なメッセージは、すこぶる迷惑です。

@item
Emacsを実行したときのシステムコールトレース。

システムコールトレースは、ある特別な種類のデバッグにはとても有用ですが、有用な情報が少ない場合がほとんどです。したがって、クラッシュに関する情報を報告する@emph{一番}の方法は、システムコールトレースを送ることだと考えているように思える人が多いのは奇妙です。おそらくソースコードやデバッグシンボルがないプログラムをデバッグする経験がもたらす、習慣的なやり方なのでしょう。

ほとんどのプログラムでは、システムコールトレースより、backtraceのほうが、通常はずっとずっと参考になります。完全な情報を得るには、変数の値を表示して、それらを@code{pr}でLispオブジェクトとしてプリントすることによりbacktraceを補完すべきであるとはいえ、シンプルなbacktraceのほうが一般的により参考になります(上記参照)。

@item
バグにたいするパッチ。

バグにたいするパッチは、それが良いものなら有用です。しかし、そのパッチで充分だと思い込んで、テストケースのような、バグレポートに必要な他の情報を省略しないでください。わたしたちはそのパッチに問題を見つけて別の方法でfixすると判断するかもしれないし、結局はそれを理解できないかもしれません。わたしたちが、あなたがfixしようと試みているバグを理解できなければ、そしてなぜそのパッチが改善なのかを理解できなければ、私たちはそれを採用できません。わたしたちにパッチを理解、インストールさせることを容易にするためのガイドラインについては、@ref{Sending
Patches}を参照してください。

@item
バグが何か、何に依存するかについての推測。

そのような推測は通常間違っています。エキスパートでさえ、事実を見つけるために最初にデバッガーを使用しなければ、そのような事柄を正しく推測できないのです。
@end itemize

以下にEmacsをデバッグしてバグに関する追加情報を提供したい場合に役に立つアドバイスのいくつかを挙げます:

@findex toggle-debug-on-error
@pindex Edebug
@itemize
@item
エラーにたいするbacktraceを作成するには、エラーが発生する前に@kbd{M-x
toggle-debug-on-error}を使用します(つまりこのコマンドを与えた後でバグを発生させなければならない)。これはエラーによりbacktraceを表示するLispデバッガーを開始するためです。デバッガーのbacktraceをバグレポートにコピーしてください(関連する@file{*.el}を見つけてロードする方法を知っていれば、エラーを発生させる前にそれらをロードしておけばより詳細なバックトレースが得られるのでそうしてほしい)。

エラーのデバッグにはEdebugの使用をお薦めします。EdebugパッケージによるEmacs
Lispプログラムのデバッグに関する情報については@ref{Edebug,, Edebug, elisp, the Emacs Lisp
Reference Manual}を参照してください。

このデバッガーの使用は、バグを再現する方法を知っているときだけ利用可能です。バグを再現できなければ、最低でもエラーメッセージ全体をコピーしてください。

@vindex debug-on-quit
@item
Emacsが無限ループや、とても長い処理にハマっているように見えるとき、(変数@code{debug-on-quit}が非@code{nil}の場合は)@kbd{C-g}とタイプするとLispデバッガーを開始して、backtraceを表示します。このbacktraceは、そのような長いloopのデバッグにたいして有用なので、backtraceを生成できたら、バグレポートにコピーしてください。

@vindex debug-on-event
(@code{inhibit-quit}がセットされている等で)、@kbd{C-g}にEmacsが応答しない場合、Emacsの外から@code{debug-on-event}で指定されたシグナル(デフォルトはSIGUSR2)を送ることにより、デバッガーに入ることができます。

@item
GDBのようなCデバッガーからの追加情報は、そのマシンを利用できなくても問題を見つけることを可能にするかもしれません。GDBの使い方を知らなければ、どうかGDBマニュアルを読んでください
---
非常に長いという訳ではありませんし、GDBは簡単に使用できます。GDBマニュアルを含むGDBディストリビューションはオンライン形式で見つけることができ、ほとんどはEmacsディストリビューションと同じ場所で見つけることができます。GDBの下でEmacsを実行するためには、Emacsをコンパイルした場所の@file{src}サブディレクトリーに移動してから@kbd{gdb
./emacs}とタイプする必要があります。GDBはカレントディレクトリーの@file{.gdbinit}を読み込むので、カレントディレクトリーが@file{src}であることが肝要です(GDB内から@kbd{source
./.gdbinit}とタイプしてファイルを読み込むようGDBに指示することも可)。

しかし、何がバグを引き起こしたかを示すような追加の情報を収集するときは、考える必要があります。

@cindex backtrace for bug reports
たとえば、多くの人はCレベルのbacktraceだけを送ってきますが、これだけではとても有用とは言えません。引数つきのシンプルなbacktraceは、GNU
Emacsの中で何が起こっているかを少ししか伝えないことがしばしばです。なぜならbacktraceにリストされたほとんどの引数は、Lispオブジェクトへのポインターだからです。これらのポインターの数値は、何であれ意味をもちません。問題となるのはポインターが指すオブジェクトの内容(そして、その内容自身もポインターの場合がほとんどです)なのです。

@findex debug_print
有用な情報を提供するためには、Lispオブジェクトの値をLisp表記で示す必要があります。基底スタックの近傍のスタックフレームのいくつかで、Lispオブジェクト変数それぞれにたいしてこれを行ないます。どの変数がLispオブジェクトであるかはソースを調べます。なぜならデバッガーはそれらを整数と判断するからです。

Lisp構文で変数の値を表示するには、最初にその値をプリントして、それからLispオブジェクトをLisp構文でプリントするために、ユーザー定義のGDBコマンド@code{pr}を使用します(他のデバッガーを使用しなければならない場合、そのオブジェクトを引数として、関数@code{debug_print}を呼び出します)。@code{pr}コマンドはファイル@file{.gdbinit}で定義されていて、(コアダンプではなく)実行中のプロセスにたいしてデバッグするときだけ機能します。

LispエラーでEmacsを停止させてGDBに戻るには、@code{Fsignal}にブレークポイントを置きます。

実行中のLisp関数のバックトレースを得るにはは、GDBコマンド@code{xbacktrace}をタイプします。

ファイル@file{.gdbinit}では、データ型やLispオブジェクトの内容を調べるための、他のコマンドも定義されています。これらのコマンドの名前は@samp{x}で始まります。これらのコマンドは@code{pr}より低いレベルで動作するので、少し不便になりますが、コアダンプをデバッグしていたり、Emacsが致命的なシグナルを受け取ったときなど、@code{pr}が機能しないようなときでも、機能するでしょう。

@cindex debugging Emacs, tricks and techniques
Emacsのデバッグにたいする、より詳細なアドバイスと、他の有用なテクニックは、Emacsディストリビューションの、ファイル@file{etc/DEBUG}で利用可能です。そのファイルには、Emacsが応答しない問題を詳しく調べる手順も含まれています(多くの人はこれをEmacsが``ハング''したとみなしますが、実際はおそらく無限ループにハマっているのでしょう)。

インストールしたEmacsのファイル@file{etc/DEBUG}を探すには、変数@code{data-directory}に保管されたディレクトリー名を使用します。
@end itemize

@node Sending Patches
@subsection GNU Emacsへのパッチの送付

@cindex sending patches for GNU Emacs
@cindex patches, sending
  GNU
Emacsを改善するためにバグfixを書きたいなら、それはとても助けになります。変更を送るとき、メンテナーがそれらを使うのが簡単になるように、どうか以下のガイドラインにしたがってください。これらのガイドラインにしたがわない場合でも、あなたの情報はまだ有用でしょうが、それを使用するのに余分な作業が必要になります。GNU
Emacsの保守は最良の状況でも多くの作業を要すので、わたしたちを助けるのにあなたがベストをすくさなければ、わたしたちはそれを維持できないのです。

各パッチは、わたしたちがそれを正しく評価するために、簡単な情報をもたなければなりません。これらの情報については以下で説明します。

それらの情報がすべて揃ったら、@kbd{M-x
submit-emacs-patch}コマンドを使ってパッチを送信してください。このコマンドはそのパッチの件名とパッチファイルの入力を求めます。それからパッチファイルが添付されたMessageモードのバッファーを作成、表示してそのパッチに関するより詳細な説明、それから以下で求めるようなその他の情報を追加できるようにします。それらが終わったら@kbd{C-c
C-c}をタイプして、電子メールで開発者にパッチを送信してください。そのメールは@url{https://debbugs.gnu.org}にある、GNU
Bug
Trackerに送信されるでしょう。Trackerはバグレポートに行うように、あなたの投稿に番号を割り当てます。通常だと開発者が返信することになるので(さらなる詳細や追加の情報を求めるためかもしれません)、必ず有効な返信用のメールアドレスを含めるようにしてください。

パッチの投稿の一部としてわたしたちが提供して欲しいのは以下の情報です:

@itemize @bullet
@item
そのパッチがどんな問題をfixするか、またはどんな改善をもたらすのかを説明してください。

@itemize @minus
@item
既存のバグにたいするfixについては、@samp{bug-gnu-emacs}リストの関連するディスカッションか、@url{https://debbugs.gnu.org}のGNU
Bug Trackerのバグエントリーに返信するのが最善でしょう。その変更が、なぜバグをfixするのか説明してください。

@item
新しい機能については、その機能と実装についての説明を含めてください。

@item
新しいバグにたいしては、あなたがfixしたと思っている問題にたいする、正しいバグレポートを含めてください(@ref{Checklist,
Checklist for Bug
Reports}を参照)。それを採用する前に、わたしたちはその変更が正しいと、私たち自身に納得させる必要があります。もしパッチが正しくても問題を再現する方法がなければ、それがfixしようと試みている問題を理解する妨げになるでしょう。
@end itemize

@item
コードの変更には将来このソースを読む人の理解を助けとなるように、なぜこの変更が必要なのかについて適切なコメントすべてを含めてください。

@item
異なる理由にたいする変更を一緒に混ぜないでください。それらを@emph{個別}に送ってください。

異なる理由にたいして2つの変更を行なった場合、わたしたちをそれを一緒に採用したいとは思わないでしょう。1つだけを採用したいと思うかもしれないし、それぞれを異なるバージョンのEmacsにインストールしたいと思うかもしれません。それらを合わせて1つのdiffにして送った場合、それらを区別するために(変更のどの部分がどの目的のためかを理解するために)、余計な作業を行なう必要があります。それを行なう時間がない場合には、わたしたちはそのパッチの組み込みを長期間先延ばしする必要が生じるかもしれません。

1つの変更を記述したら、その変更の説明と一緒にそれをすぐに送れば、2つの変更は混ざることはなくなり、それらを区別する余計な作業なしに、わたしたちはそれぞれを正しく判断することができます。

@item
1つの変更を終えたら、それをすぐに送ってください。ときどき人は多くの変更を累積して、すべて一緒に送るのがわたしたちの助けとなると考えます。上述したように、それは正にあなたにできる最悪のことです。

変更は個別に送るべきなので、すぐに送ることができるでしょう。これは、その変更が重要なものなら、それをすぐに採用するオプションをわたしたちに与えます。

@item
パッチそのもの。これは以下のいずれかの方法によって生成できます:

@itemize @minus
@item
Emacsレポジトリを使用している場合、あなたのコピーが(たとえば@code{git
pull}などにより)最新であることを確認してください。あなたの変更をプライベートのブランチにコミットして、@code{git format-patch
master}を使用することにより、マスターバージョンからパッチを生成できます(パッチの適用が容易になるので、これが推奨する方法)。または以下で述べるように変更をコミットせずに、@code{git
diff}を使用することもできます。

@item
diff の作成には@kbd{diff -u}を使用してください。GNU diffがある場合、Cコードのdiffの作成には@w{@kbd{diff -u
-F'^[_a-zA-Z0-9$]\\+ *('}}を使用してください。これは変更のある関数名を表示します。

diffを作成する際にはどちらが古いバージョンで、どちらが新しいバージョンか、あいまいになるのを避けてください。どうかdiffの第1引数に古いバージョン、2番目の引数に新しいバージョンを指定してください。そして一方のバージョンにたいして、それが古いバージョンなのか、変更した新しいバージョンなのかを示す名前をつけてください。
@end itemize

@item
あなたの変更にたいする、コミットログのエントリーを記述してください。それにより、わたしたちがそれを記述するために余計な作業をしなくてすみ、あなたが行なった変更をわたしたちが理解する助けにもなります。

コミットログはその変更の根拠、あなたのパッチが修整を試みる問題を変更後のコードがどのように解決するかを説明して、更に人々がその変更をどこで見つけられるかを示すことが目的です。したがって変更した関数とその理由を具体的に記す必要があります。適切なコミットログメッセージにたいするわたしたちのスタイルと要件については、どうかEmacsソースツリーにあるファイル@file{CONTRIBUTE}のセクション``Commit
messages''を参照してください。

どのような種類の情報を記述するかを見るために、最近のコミットにたいするコミットログエントリーも参考にして、わたしたちが使用しているスタイルを学んでください。他のプロジェクトとは異なり、たとえばTexinfoファイルのようなドキュメントにたいするコミットログも必要です。@ref{Change
Log}、および
@ifset WWW_GNU_ORG
@url{https://www.gnu.org/prep/standards/html_node/Change-Log-Concepts.html}、
@end ifset
@ref{Change Log Concepts, Change Log Concepts, Change Log Concepts,
standards, GNU Coding Standards}を参照してください。

@item
fixを記述するときは、わたしたちが他のシステムを壊すような変更は採用できないということを、念頭に置いてください。あなたの変更が、ほかのタイプのシステムでコンパイルおよび/または使用された場合の影響についてどうか考慮してください。

一般的には改善となる@emph{かもしれない}が、そう確信するのは難しいようなfixを送る人が、ときどきいます。そのような変更を採用するのは、わたしたちがそれをとても慎重に調べなければならないので、難しくなります。もちろん、その変更が正しい理由の説明は、わたしたちを納得させる助けになります。

もっとも安全な変更は、特定の機種やシステムで使用されるファイルやファイルの一部にたいする変更です。これらの変更は、新しいバグを他の機種やシステムに作成しないので安全です。

インストールの安全性が明確な形式でパッチをデザインして、わたしたちの作業量を、良い状態に保つ助けとなってください。
@end itemize

@node Contributing
@section Emacs開発への貢献
@cindex contributing to Emacs

Emacsは共同制作によるプロジェクトであり、わたしたちは誰でも貢献できことを励行します。

Emacsに貢献する多くの方法があります:

@itemize
@item
バグの発見と報告。@ref{Bugs}を参照してください。

@item
Emacsユーザーメーリングリスト@url{https://lists.gnu.org/mailman/listinfo/help-gnu-emacs}の質問にたいする回答。

@item
@uref{https://www.emacswiki.org/, Wiki}またはEmacs source
repository(@ref{Sending Patches}を参照してください)のドキュメントの記述。

@item
既存のバグレポートが新しいバージョンのEmacs@url{https://debbugs.gnu.org/cgi/pkgreport.cgi?which=pkg&data=emacs}でfixされているかのチェック。

@item
既存バグのfixの報告。

@item
@c etc/TODO not in WWW_GNU_ORG
Emacsディストリビューションの@file{etc/TODO}にリストされた機能の実装、およびパッチの送付。

@item
新しい機能の実装、およびパッチの送付。

@item
Emacsで動作するパッケージの開発と、あなた自身またはGNU ELPA(@url{https://elpa.gnu.org/})での公開。

@item
新しいプラットフォームへEmacsをポート。ただしこれは現在一般的ではありません。

@end itemize

Emacsを改善する作業をしたい場合は、
@ifnothtml
@email{emacs-devel@@gnu.org}のメンテナーに連絡してください。
@end ifnothtml
@ifhtml
@url{https://lists.gnu.org/mailman/listinfo/emacs-devel,
emacs-develメーリングリスト}のメンテナーに連絡してください。
@end ifhtml
提案されたプロジェクトを尋ねたり、あなたのアイデアを提案することができます。

Emacsにたいする機能の要望や改善方法についての提案を送る場合には、
@ifnothtml
@email{bug-gnu-emacs@@gnu.orgが最善の場所です。}
@end ifnothtml
@ifhtml
@url{https://lists.gnu.org/mailman/listinfo/bug-gnu-emacs,
bug-gnu-emacs}が最善の場所です。
@end ifhtml
どのような変更を望むのか、そしてなぜ、どのようにすればそれがEmacsを改善すると思うかを、可能なかぎり明快に説明するようにお願いします。

すでに改善を記述したことがある場合は、それについて教えてください。まだ作業を開始していなければ、作業を開始する前に、
@ifnothtml
@email{emacs-devel@@gnu.org}
@end ifnothtml
@ifhtml
@url{https://lists.gnu.org/mailman/listinfo/emacs-devel, emacs-devel}
@end ifhtml
に連絡をとるのが有益です。Emacsの他の部分にたいして、あなたの拡張がより適合する方法を提案することが可能かもしれません。

機能を実装するときは、Emacs coding standardsに従ってください。@ref{Coding
Standards}を参照してください。くわえて重要な貢献にたいしてはFSFへの著作権の譲渡が必要になります。@ref{Copyright
Assignment}を参照してください。

Emacsの開発バージョンは、開発者グループにより活発にメンテされている、レポジトリからダウンロードできます。アクセスの詳細についてはEmacsプロジェクトのページ@url{https://savannah.gnu.org/projects/emacs/}を参照してください。

カレントワーキングバージョンにたいしてパッチを記述することは重要です。古いバージョンから開始した場合、パッチは時代遅れかもしれず(そのためメンテナーはそれを適用するのが難しくなります)、Emacsの変更によりあなたのパッチが不必要になっているかもしれません。レポジトリソースからダウンロードした後は、ビルド手順についてファイル@file{INSTALL.REPO}を読むべきです(ビルド手順が通常のビルドとは異なります)。

より広範な貢献を望むなら、Emacsソースツリーにある@file{CONTRIBUTE}ファイルからEmacs開発者になる方法に関する情報を確認してください。このファイルはEmacsのすべてのリリースバージョンのソースtarファイルの一部として配布されており、@url{https://git.savannah.gnu.org/cgit/emacs.git/tree/CONTRIBUTE,
Emacs on-line source
repository}で確認することもできます。@url{https://savannah.gnu.org/projects/emacs/}の手順にしたがってEmacsレポジトリをcloneした場合には、このファイルはEmacsソースツリーのトップディレクトリーにあります。

(望む変更を実装する方法を理解するために)、以下のEmacsドキュメントを参照してください:

@itemize
@item
@ifset WWW_GNU_ORG
@ifhtml
Emacs Manual @url{https://www.gnu.org/software/emacs/manual/emacs.html}.
@end ifhtml
@ifnothtml
@ref{Top, Emacs Manual,,emacs}を参照してください。
@end ifnothtml
@end ifset
@ifclear WWW_GNU_ORG
@ref{Top, Emacs Manual,,emacs}を参照してください。
@end ifclear

@item
@ifset WWW_GNU_ORG
@ifhtml
Emacs Lisp Reference Manual
@url{https://www.gnu.org/software/emacs/manual/elisp.html}.
@end ifhtml
@ifnothtml
@ref{Top, Emacs Lisp Reference Manual,,elisp}を参照してください。
@end ifnothtml
@end ifset
@ifclear WWW_GNU_ORG
@ref{Top, Emacs Lisp Reference Manual,,elisp}を参照してください。
@end ifclear

@item
@url{https://www.gnu.org/software/emacs}

@item
@url{https://www.emacswiki.org/}
@end itemize

@menu
* Coding Standards::         GNU Emacsコーディング規約
* Copyright Assignment::     FSFへの著作権の譲渡
@end menu

@node Coding Standards
@subsection コーディング規約
@cindex coding standards for Emacs submissions

貢献されたコードはGNUコーディング規約(GNU Coding Standards:
@url{https://www.gnu.org/prep/standards/})にしたがうべきです。これはシステムのinfoでも利用可能かもしれません。

これにしたがっていない場合、わたしたちがそれを使えるように、そのコードをfixする誰かを探す必要があるでしょう。

Emacsには追加のスタイルとコーディング規約があります:

@itemize
@item
@ifset WWW_GNU_ORG
@ifhtml
``Tips and Conventions'' Appendix in the Emacs Lisp Reference
@url{https://www.gnu.org/software/emacs/manual/html_node/elisp/Tips.html}を参照してください。
@end ifhtml
@ifnothtml
@ref{Tips, ``Tips and Conventions'' Appendix in the Emacs Lisp Reference,
Tips Appendix, elisp, Emacs Lisp Reference}を参照してください。
@end ifnothtml
@end ifset
@ifclear WWW_GNU_ORG
@ref{Tips, ``Tips and Conventions'' Appendix in the Emacs Lisp Reference,
Tips Appendix, elisp, Emacs Lisp Reference}を参照してください。
@end ifclear

@item
Emacsに含まれるLispコードでは、@code{advice-add}と@code{with-eval-after-load}の使用を避けてください。

@item
すべてのソースおよびテキストファイルの、すべての行末の空白文字を削除してください。

@item
Lispコード内のスペース文字は、@code{? }のかわりに@code{?\s}を使用してください。

@end itemize

@node Copyright Assignment
@subsection 著作権の割り当て
@cindex copyright assignment

FSF(Free Software Foundation)は、GNU
Emacsの著作権所有者です。FSFはコンピューターユーザーの自由の促進、およびすべてのフリーソフトウェアーユーザーの権利を守るという、世界的な使命をもつ、非営利団体です。一般的な情報については、ウェブサイト@url{https://www.fsf.org/}を参照してください。

一般的には、GNU Emacs、およびGNU
ELPAに格納されているパッケージにたいする些細とは言えない貢献にたいして、わたしたちは著作権をFSFに譲渡することを求めます。この背景にある理由については、@url{http://www.gnu.org/licenses/why-assign.html}を参照してください。

著作権譲渡はシンプルなプロセスです。多くの国の住民は、これを完全にコンピューター上で行なうことができます。わたしたちは@email{emacs-devel@@gnu.org}メーリングリストにおいて、著作権譲渡を満足するために必要なフォームを送ったり、あなたがもつであろうさまざまな疑問にたいして回答(または回答をもつ人物を掲示)することで、あなたの着手を助けることができます。

(どうか注意してください:
なぜいくつかのGNUプロジェクトは版権譲渡を求めるかについての一般的な議論は、emacs-develではoff-topicです。かわりにgnu-misc-discussを参照してください)

著作権放棄も可能ですが、好ましいのは譲渡です。著作権放棄者は、著作権譲渡者と同様に、FSFにサインされた書類を送ることが必要になります(単に``this
is in the public
domain''というだけでは充分ではありません)。著作権放棄は将来の作業には適用できないので、新しい何かを送りたいときは、毎回これを繰り返す必要があります。

わたしたちは、譲渡なしで小さな変更(大雑把に言うと15行以下)を受けとることができます。これはあなたの貢献全体にたいする蓄積的な制限です(たとえば5行パッチを3つ)。

@node Service
@section GNU Emacsにたいして助けを得る方法
@cindex help in using Emacs
@cindex @samp{help-gnu-emacs} mailing list
@cindex @samp{gnu.emacs.help} newsgroup

インストール、使用方法、またはGNU Emacsの変更について助言を必要とする場合は、それを探す2つの方法があります:

@itemize @bullet
@item
メッセージを
@ifnothtml
メーリングリスト@email{help-gnu-emacs@@gnu.org}に送るか、
@end ifnothtml
@ifhtml
@url{https://lists.gnu.org/mailman/listinfo/help-gnu-emacs,
help-gnu-emacsメーリングリスト}に送るか、
@end ifhtml
あなたの要求をニュースグループ@code{gnu.emacs.help}にポストしてください(このメーリングリストとニュースグループは相互接続しているので、どちらを使っても問題ありません)。

@item
手数料を徴収して助言してくれる人物を、@uref{https://www.fsf.org/resources/service/, service
directory}で探してください。
@end itemize

@ifnottex
@lowersections
@end ifnottex
