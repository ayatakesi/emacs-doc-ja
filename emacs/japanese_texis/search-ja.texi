@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================

@c -*- coding: utf-8 -*-
@c This is part of the Emacs manual.
@c Copyright (C) 1985--1987, 1993--1995, 1997, 2000--2024 Free Software
@c Foundation, Inc.
@c See file emacs-ja.texi for copying conditions.
@node Search
@chapter 検索と置換
@cindex searching
@cindex finding strings within text

  他のエディターと同様、Emacsには文字列を検索(search)するコマンドがあります。Emacsには、文字列を違う文字列で置き換える(replace)コマンドもあります。また、同じことを行いますが、固定文字列ではなくパターンを検索するコマンドもあります。

  @code{xref}の制御下にある複数ファイルにたいして検索したり((@ref{Identifier
Search}を参照してください)、Diredの@kbd{A}コマンドを通じて検索したり(@ref{Operating on
Files}を参照してください)、@code{grep}コマンドを使った検索(@ref{Grep Searching}を参照してください)も可能です。

@menu
* Incremental Search::       文字列をタイプすることにより始まる検索。
* Nonincremental Search::    文字列全体を指定してから検索する。
* Word Search::              単語の並びを検索する。
* Symbol Search::            ソースコードのシンボルを検索する。
* Regexp Search::            正規表現にマッチする検索。
* Regexps::                  正規表現の構文について。
* Regexp Backslash::         `\'で開始される正規表現の構築。
* Regexp Example::           複雑な正規表現の解説。
* Lax Search::               大文字小文字のような、類似した文字の違いを検索で無視する。
* Replace::                  一部またはすべてのマッチを検索または置換する。
* Other Repeating Search::   いくつかの正規表現にマッチするすべてを処理する。
* Search Customizations::    検索のさまざまなカスタマイズ。
@end menu

@node Incremental Search
@section インクリメンタル検索
@cindex incremental search
@cindex isearch

  Emacsにおける重要な検索コマンドは、@dfn{インクリメンタル検索(isearch: incremental
search)}です。これは検索する文字列の最初の文字をタイプすると、すぐに検索が開始されます。検索文字列をタイプしていくにつれて、Emacsはその文字列(それまでに入力した文字列)がどこにあるかを表示します。望む場所を特定するのに充分な文字列をタイプしたところで、検索をストップできます。次に何をするかによって、明示的な@key{RET}により検索を終えたり、続けることができます。

@table @kbd
@item C-s
前方にインクリメンタル検索します(@code{isearch-forward})。
@item C-r
後方にインクリメンタル検索します(@code{isearch-backward})。
@end table

メニューバーの@samp{Edit->Search}メニューからインクリメンタル検索を呼び出すこともできます。

@menu
* Basic Isearch::            基本的なインクリメンタル検索コマンド。
* Repeat Isearch::           同じ文字列を再度検索する。
* Isearch Yank::             検索文字列にテキストを取り込んだり、検索文字列を編集するコマンド。
* Error in Isearch::         文字列が見つからなかったとき。
* Special Isearch::          インクリメンタル検索での特別な入力。
* Not Exiting Isearch::      プレフィクス引数とスクロールコマンド。
* Isearch Minibuffer::       ミニバッファーヒストリーのインクリメンタル検索。
@end menu

@node Basic Isearch
@subsection インクリメンタル検索の基本

@table @kbd
@item C-s
インクリメンタル検索を開始します(@code{isearch-forward})。
@item C-r
逆向きのインクリメンタル検索を開始します(@code{isearch-backward})。
@end table

@kindex C-s
@findex isearch-forward
  @kbd{C-s}
(@code{isearch-forward})は、前方へのインクリメンタル検索を開始します。これはキーボードから文字を読み取り、タイプした文字が最初に出現するバッファーの位置に、ポイントを移動します。

  たとえば@kbd{C-s}とタイプした後に@kbd{F}をタイプすると、検索を開始したバッファーのポイント位置より前方にある、最初の@kbd{F}にカーソルを移動します。つぎに@kbd{O}をタイプすると、前方にある最初の@samp{FO}にカーソルが移動します。この場合、@samp{FO}の@samp{F}は、前に見つかった@samp{F}と同じ位置である必要はありません。もう一度@kbd{O}をタイプすると、カーソルは最初の@samp{FOO}に移動します。

@cindex faces for highlighting search matches
@cindex @code{isearch} face
  各ステップでEmacsは@dfn{カレントマッチ(current match:
現在のマッチ)}(検索文字列にマッチしたバッファーのテキスト)を、@code{isearch}フェイス(@ref{Faces}を参照してください)でハイライトします。このハイライトをカスタマイズするさまざまなオプションについては、@ref{Search
Customizations}を参照してください。その時点での検索文字列はエコーエリアにも表示されます。

@cindex isearch input item
@cindex input item, isearch
@findex isearch-delete-char
@kindex DEL @r{(Incremental search)}
  検索文字列のタイプ中に間違ったら、@key{DEL}(@code{isearch-delete-char})とタイプしてください。@key{DEL}をタイプするたびに、検索の間にエンターした最後の入力がキャンセルされます。検索文字列、ポイント位置、検索の成否、検索の方向、カレント検索結果の他端位置、検索の``ラッピング''を変更するコマンドのタイプ時、Emacsは常に新たな@dfn{入力アイテム(input
item)}を記録します。失敗した検索を処理するための詳細は、@ref{Error in Isearch}を参照してください。

@cindex exit incremental search
@cindex incremental search, exiting
@findex isearch-exit
@kindex RET @r{(Incremental search)}
  検索により到達した位置に満足したら、@key{RET}
(@code{isearch-exit})をタイプします。これは検索をストップして、検索により移動した位置にカーソルを残します。検索とは関係ないコマンドも、検索をストップして、そのコマンドが実行されます。つまり@kbd{C-a}は検索をexitして行の先頭に移動し、矢印キーをタイプすると検索をexitして対応する移動コマンドが処理される、などとなります。@key{RET}で検索を終える必要があるのは、次のコマンドが印字文字をタイプするコマンドのときだけです。@key{DEL}、@key{RET}および他のいくつかの文字(@kbd{C-q}、@kbd{C-w}、@kbd{C-r}、@kbd{C-s}、@kbd{C-y}、@kbd{M-y}、@kbd{M-r}、@kbd{M-c}、@kbd{M-e}、および以下で説明する文字)は、検索で特別な意味を持っています。検索をexitするコマンドを微調整できます。@ref{Not
Exiting Isearch}を参照してください。

  特別な例外として、検索文字列が空のときに@key{RET}を入力すると、非インクリメンタル検索(@ref{Nonincremental
Search}を開始します(これは"カスタマイズ可能"です。@ref{Search Customizations}を参照してください)。

@findex isearch-abort
@findex isearch-cancel
@kindex C-g C-g @r{(Incremental Search)}
@kindex ESC ESC ESC @r{(Incremental Search)}
  検索を中止して検索を開始した位置に戻るには、@kbd{@key{ESC} @key{ESC} @key{ESC}}
(@code{isearch-cancel})、または@kbd{C-g C-g} (@code{isearch-abort})とタイプしてください。

  インクリメンタル検索を終了するとき、ポイントの元の位置をマークをアクティブにせず(ただしマークがすでにアクティブではなかったときだけ)に、マークリングに追加します。これにより、@kbd{C-u
C-@key{SPC}}、または@kbd{C-x C-x}を使って、検索を開始する前の位置に戻ることができます。@ref{Mark
Ring}を参照してください(Emacsはマークがすでにアクティブでないときだけ、これを行ないます。検索を開始したときにマークがアクティブな場合は、@kbd{C-u
C-@key{SPC}}と@kbd{C-x C-x}の両方とも、マークに戻ります)。

@kindex C-r
@findex isearch-backward
  後方に検索するには、@kbd{C-s}で検索を開始するかわりに、@kbd{C-r}
(@code{isearch-backward})を使います。前方検索が検索を開始した位置より前方にある最初のマッチを探すように、後方検索は検索を開始した位置より後方にある最後のマッチを探します。

@node Repeat Isearch
@subsection インクリメンタル検索の繰り返し

@kindex C-s @r{(Incremental Search)}
@kindex C-r @r{(Incremental Search)}
@findex isearch-repeat-forward
@findex isearch-repeat-backward
  前方に@samp{FOO}を検索してマッチしたが探しているマッチではなく、探しているのはバッファーのもっと前方に出現する@samp{FOO}だとしましょう。ここでもう1度@kbd{C-s}
(@code{isearch-repeat-forward})をタイプすることにより、検索文字列が次に出現する場所、@kbd{C-r}
(@code{isearch-repeat-backward})とタイプすれば検索文字列が前に出現した場所に移動します。これは何回でも繰り返すことができます。次、または前へ@var{n}個目の出現場所を見つけるために@kbd{C-s}と@kbd{C-r}にプレフィクス数引数@var{n}をかわりに供給することもできます。もしタイプしすぎたときは、@kbd{C-s}コマンドを@key{DEL}で取り消すことができます。同様に後方へのインクリメンタル検索では、@kbd{C-r}
(@code{isearch-repeat-backward})により後方検索が繰り返されます。

@cindex lazy search highlighting
  インクリメンタル検索中に手を止めて眺めてみると、検索文字列にたいするカレントマッチ以外に、スクリーンに表示されている他のマッチもハイライトされていることがわかります。これは検索するために、何回@kbd{C-s}または@kbd{C-r}を繰り返せばよいのか予測しやすくするためです。その他のマッチは、カスタマイズ可能なフェイス@code{lazy-highlight}
(@ref{Faces}を参照してください)を使って、現在のマッチとは異なってハイライトされます。この機能を無効にするには、@code{isearch-lazy-highlight}に@code{nil}をセットしてください。マッチのハイライトに関連するその他のカスタマイズについては、@ref{Search
Customizations}を参照してください。

  検索を終了した後、同じ文字列を再度検索するには、@kbd{C-s
C-s}とタイプします。最初の@kbd{C-s}はインクリメンタル検索を呼び出し、2回目の@kbd{C-s}は最後に検索した文字列の再検索を意味します。同様に、@kbd{C-r
C-r}は最後に検索した文字列を後方に検索します。最後に検索された文字列の決定では、その文字列が@kbd{C-s}で検索されたのか、@kbd{C-r}で検索されたのかは問題ではありません。

  前方に検索していて、検索している対象が検索開始点より後方にあるのに気付いたときは、検索文字列を変更すること無く、@kbd{C-r}で後方検索に切り替えることができます。同様に後方検索で@kbd{C-s}をタイプすると、前方検索に切り替わります。

@cindex search, changing direction
@vindex isearch-repeat-on-direction-change
  検索方向を変更すると、最初にコマンドをタイプした時点ではデフォルトでは同じマッチ上に留まって、カーソルはそのマッチの他端へと移動するでしょう。別のマッチへ即座に移動するには、変数@code{isearch-repeat-on-direction-change}を@code{t}にカスタマイズしてください。

@cindex search, wrapping around
@cindex search, overwrapped
@cindex wrapped search
@cindex overwrapped search
  検索が失敗したとき、バッファーの先頭から検索を再開するには、もう一度@kbd{C-s}をタイプします。逆向きの繰り返し検索が失敗したときは、@kbd{C-r}でバッファーの最後から検索を再開します。これは@dfn{wrapping
around(巻き直し)}と呼ばれ、これが発生すると、@samp{Wrapped}という単語が検索プロンプトに表示されます。検索を続けて元の検索開始ポイントを通過すると、@samp{Overwrapped}に変化します。これはすでに見たマッチを再訪していることを意味します。

@vindex isearch-wrap-pause
  それ以上マッチが存在しない際に何が起こるかは、ユーザーオプション@code{isearch-wrap-pause}のカスタマイズによって制御できます。@code{t}
(デフォルト)ならエラーをシグナル(繰り返し検索すると最初に戻り検索)、@code{no}なら@code{ding}を発して最後のマッチ到達後即座に最初に戻り検索、@code{no-ding}なら@code{ding}なしで即座に最初に戻り検索を行います。値が@code{no}か@code{no-ding}なら、文字のタイプ中にも最初に戻って検索を試みます。最後に@code{nil}なら最初へは戻らず最後のマッチで単に停止します。

@cindex search ring
@findex isearch-ring-advance
@findex isearch-ring-retreat
@kindex M-n @r{(Incremental search)}
@kindex M-p @r{(Incremental search)}
@vindex search-ring-max
  以前に検索した文字列を再利用するには、@dfn{サーチリング(search ring)}を使います。コマンド@kbd{M-p}
(@code{isearch-ring-retreat})または@kbd{M-n}
(@code{isearch-ring-advance})で、リングを移動して再使用したい文字列を取り出します。これらのコマンドは、選択されたリング要素の文字列をミニバッファーに残すので、それを編集することができます。@kbd{C-s}と@kbd{C-r}、または@key{RET}とタイプすると、その文字列を受け入れて、その文字列にたいする検索を開始します。サーチリングの中に保存されている、最近使用された検索文字列の数は、変数@code{search-ring-max}で指定され、デフォルトは16です。

@cindex incremental search, edit search string
@cindex interactively edit search string
@findex isearch-edit-string
@kindex M-e @r{(Incremental search)}
@kindex mouse-1 @r{in the minibuffer (Incremental Search)}
  ミニバッファーの現在の検索文字列を、サーチリングのアイテムで置き換えずに編集するときは、@kbd{M-e}
(@code{isearch-edit-string})とタイプするか、ミニバッファーを@kbd{mouse-1}でクリックします。@key{RET}、@kbd{C-s}、@kbd{C-r}とタイプすれば、編集を終了してそれを検索できます。バッファーの検索を開始したポイントの後に続く文字を検索文字列に追加するには、@kbd{C-f}または@kbd{@key{RIGHT}}とタイプしてください。

@node Isearch Yank
@subsection インクリメンタル検索でのyank

  多くのケースで、ポイントの近くにあるテキストを検索文字列として使いたいことがあるでしょう。このサブセクションで説明されているコマンドにより、これを便利に行なえるようになります。

@kindex C-w @r{(Incremental search)}
@findex isearch-yank-word-or-char
  @kbd{C-w}
(@code{isearch-yank-word-or-char})は検索された文字列のポイントの次の文字または単語を検索文字列に追加します。これはポイント位置にあるテキストを検索する簡単な方法です(コピーする対象を文字または単語のどちらにするかの決定は発見的に行われます)。プレフィクス数引数@var{n}を与えると次の@var{n}個の文字または単語を追加します。

@kindex C-M-w @r{(Incremental search)}
@findex isearch-yank-symbol-or-char
  @kbd{C-M-w}
(@code{isearch-yank-symbol-or-char})は、検索された文字列のポイントの次の文字またはシンボルを検索文字列に追加します。これはポイント位置にあるシンボルを検索する簡単な方法です(コピーする対象を文字またはシンボルのどちらにするかの決定は発見的に行われます)。プレフィクス数引数@var{n}を与えると次の@var{n}個の文字またはシンボルを追加します。

@kindex M-s C-e @r{(Incremental search)}
@findex isearch-yank-line
  @kbd{M-s C-e}
(@code{isearch-yank-line})は、検索文字列にカレント行の残りの部分を追加します。ポイントが既に行末にある場合には次の行が追加されます。プレフィクス引数@var{n}を指定すると次の@var{n}行を追加します。

@kindex C-M-z @r{(Incremental search)}
@findex isearch-yank-until-char
  同様に@kbd{C-M-z}
(@code{isearch-yank-until-char})はポイントから指定した文字の次の出現場所(その文字を含まず)までのすべてを検索文字列に追加します。これはたとえばプログラミング言語やマークアップ言語でその文字が字句境界をマークするようなときのキーボードマクロにとって有用です。プレフィクス数引数@var{n}を与えると、このコマンドはポイントから@var{n}個目の指定した文字までのすべてを追加します。

@kindex C-y @r{(Incremental search)}
@kindex M-y @r{(Incremental search)}
@kindex mouse-2 @r{in the minibuffer (Incremental search)}
@findex isearch-yank-kill
@findex isearch-yank-pop
@findex isearch-yank-x-selection
  インクリメンタル検索での@kbd{C-y}
(@code{isearch-yank-kill})は、カレントkillを検索文字列に追加します。@kbd{C-y}の後のインクリメンタル検索中に@kbd{M-y}
(@code{isearch-yank-pop})が呼び出されると、追加するテキストをもっと前にkillされたものに置き換えます。これは通常の@kbd{M-y}
(@code{yank-pop})コマンドと似ています((@ref{Yanking})を参照)。エコーエリアで@kbd{mouse-2}をクリックすることにより、はカレントのX選択(@ref{Primary
Selection}を参照)を検索文字列に追加します(@code{isearch-yank-x-selection})。

@kindex C-M-d @r{(Incremental search)}
@kindex C-M-y @r{(Incremental search)}
@findex isearch-del-char
@findex isearch-yank-char
  @kbd{C-M-d} (@code{isearch-del-char})は検索文字列の最後の文字を削除し、@kbd{C-M-y}
(@code{isearch-yank-char})は検索されたポイントの後の文字を追加します。ポイントの後ろの文字を追加する他の方法は、@kbd{M-e}(@ref{Repeat
Isearch}を参照してください)でミニバッファーに移動してから、検索文字列の最後で@kbd{C-f}か@kbd{@key{RIGHT}}をタイプします。@kbd{C-f}か@kbd{@key{RIGHT}}をタイプするたびに、ポイントの後の文字が検索文字列に順次追加されます。

  検索が大文字小文字を区別しない場合は通常、検索文字列にyankされるテキストは小文字に変換されるので、検索は大文字小文字を区別しないままです(@ref{Lax
Search, case folding}を参照してください)。しかし、変数@code{search-upper-case} (@ref{Lax
Search,
search-upper-case}を参照してください)の値が@code{not-yanks}以外の場合には、この小文字への変換は無効になります。

@kindex M-s M-.
@findex isearch-forward-thing-at-point
  ポイント近傍のテキストを最初の検索文字列にyankしてインクリメンタル検索を新たに開始するには、コマンド@code{isearch-forward-thing-at-point}を実行するために@kbd{M-s
M-.}をタイプしてください。これはリージョンがアクティブなら、リージョンからテキストを検索文字列にyank、それ以外の場合にはポイントの近くで見つかったURL、シンボル、または式のyankを試みます。何をyankするかはユーザーオプション@code{isearch-forward-thing-at-point}で定義されます。

@node Error in Isearch
@subsection インクリメンタル検索でのエラー

@cindex @code{isearch-fail} face
  文字列が見つからなかった場合、エコーエリアに@samp{Failing
I-Search}と表示されて、文字列とできるかぎりマッチした位置に、カーソルが移動します。つまり@samp{FOOT}を検索して@samp{FOOT}がない場合、カーソルは@samp{FOOL}という文字列の@samp{FOO}の後ろに移動します。エコーエリアではマッチに失敗した検索文字列の一部が、フェイス@code{isearch-fail}を使ってハイライトされます。

  その時に行うことができる選択肢がいくつかあります。もし文字列が間違っている場合には、文字列を訂正するために、@key{DEL}で前の入力アイテム(@ref{Basic
Isearch}を参照)を削除、一度に一文字削除するなら@kbd{C-M-d}、編集する場合は@kbd{M-e}とタイプします。もし見つかった位置が望む位置なら、@key{RET}をタイプしてその位置に留まることができます。または@kbd{C-g}をタイプして、検索文字列から検索できなかった文字(@samp{FOOT}の中の@samp{T})を取り除き、検索された部分の文字列(@samp{FOOT}の中の@samp{FOO})を残します。その位置でもう1回@kbd{C-g}をタイプすると、検索全体を取り消し、ポイントは検索を開始した位置に戻ります。

@cindex quitting (in search)
@kindex C-g @r{(Incremental search)}
  終了コマンドの@kbd{C-g}は、検索において特別な処理を行います。このコマンドの動作は、検索の状況に依存します。もし指定した文字列の検索が成功して、さらに検索文字の入力を待っているとき、@kbd{C-g}は検索全体を取り消して、カーソルを検索を開始したときの位置に移動します。検索文字列に検索に失敗した文字が含まれているときに、@kbd{C-g}がタイプされたときは、検索文字列から検索に失敗した文字が取り除かれます。後に残るのは検索に成功した文字列で、さらに検索文字の入力を待っているので、先のケースと同様、2回目の@kbd{C-g}で検索全体が取り消されます。

@node Special Isearch
@subsection インクリメンタル検索の特別な入力

  前のサブセクションで説明した文字に加えて、インクリメンタル検索のときにタイプする文字列の中には、特別な効果をもつものがあります。ここではそれらについて説明します。

  lax space matching(「だらしない、ゆるんだ、緩慢な、締まりのない」スペースのマッチング。@ref{Lax Search, lax
space matching}を参照してください)を切り替えるには、@kbd{M-s @key{SPC}}とタイプします。

  検索でcase sensitivity(大文字小文字を区別するか)を切り替えるには、@kbd{M-c}または@kbd{M-s
c}とタイプします。@ref{Lax Search, case
folding}を参照してください。検索文字列が大文字を含む場合、デフォルトではその検索はcase-sensitive(大文字小文字を区別)します。

  検索が似ている文字、または等価な文字を考慮するかどうかを切り替えるには、@kbd{M-s '}とタイプします。@ref{Lax Search,
character folding}を参照してください。検索文字列にアクセント付きの文字が含まれる場合、その検索の間、character
foldingは無効になります。

@cindex invisible text, searching for
@kindex M-s i @r{(Incremental search)}
@findex isearch-toggle-invisible
  オーバーレイによって不可視になっているテキストを検索するかどうかを切り替えるには@kbd{M-s i}
(@code{isearch-toggle-invisible})をタイプします。@ref{Outline
Search}を参照してください。すべてのインクリメンタル検索において、テキストプロパティやオーバーレイプロパティのために不可視になっているテキストにたいするマッチを見つけるようにするには、@code{search-invisible}の値を@code{t}にカスタマイズしてください。

@kindex M-r @r{(Incremental Search)}
@kindex M-s r @r{(Incremental Search)}
@findex isearch-toggle-regexp
  インクリメンタル検索で、非正規表現による検索と、正規表現による検索を切り替えるには、@kbd{M-r}、または@kbd{M-s r}
(@code{isearch-toggle-regexp})とタイプします。@ref{Regexp Search}を参照してください。

  シンボルモードを切り替えるには、@kbd{M-s _}とタイプします。@ref{Symbol Search}を参照してください。

  改行文字を検索するには、検索文字列の途中で@kbd{C-j}とタイプします。

  インクリメンタル検索の間に非@acronym{ASCII}文字を検索するには、以下の方法のいずれかを使用してください:

@itemize @bullet
@item
@findex isearch-quote-char
@kindex C-q @r{(Incremental Search)}
@kbd{C-q}
(@code{isearch-quote-char})に続けて、非グラフィック文字か8進数字をタイプします。これは@kbd{C-q}を使ってバッファーに文字を挿入するのと同様に、検索文字列にタイプする文字を追加します(@ref{Inserting
Text}を参照してください)。たとえばインクリメンタル検索で@kbd{C-q
C-s}をタイプすると、検索文字列に文字@samp{control-S}が追加されます。

@item
@kindex C-^ @r{(Incremental Search)}
@findex isearch-toggle-input-method
@findex isearch-toggle-specified-input-method
@findex isearch-transient-input-method
入力メソッド(IM: input method)を使います(@ref{Input
Methods}を参照してください)。検索を開始したとき、カレントバッファーで入力メソッドが有効の場合、ミニバッファーで検索もL字列をタイプするときにも、同じメソッドがアクティブになるでしょう。検索文字列をタイプするとき、@kbd{C-\\}
(@code{isearch-toggle-input-method})で、入力メソッドを切り替えることができます。非デフォルトの入力メソッドに切り替えるには、@kbd{C-^}
(@code{isearch-toggle-specified-input-method})を使います。これは入力メソッドの名前を尋ねます。インクリメンタル検索で入力メソッドがアクティブのとき、検索プロンプトには以下のようなニーモニックが含まれます。

@example
I-search [@var{im}]:
@end example

@noindent
ここで@var{im}はアクティブな入力メソッドのニーモニックです。インクリメンタル検索の間に有効にした入力メソッドは、その後もカレントバッファーで有効のままです。最後に検索文字列に入力メソッドを使用して1文字を挿入してから、その後自動的に入力メソッドを無効にするために、@kbd{C-x
\}
(@code{isearch-transient-input-method})で一時的に一時入力メソッドを有効にできます(@ref{transient
input method}を参照)。

@item
@findex isearch-char-by-name
@kindex C-x 8 RET @r{(Incremental Search)}
@kbd{C-x 8 @key{RET}}
(@code{isearch-char-by-name})に続けて、Unicode名か16進のコードポイントをタイプします。これは通常の@code{insert-char}コマンドと同様に、検索文字列に指定した文字を追加します(@ref{Inserting
Text}を参照してください)。
@end itemize

@findex isearch-emoji-by-name
@kindex C-x 8 e RET @r{(Incremental Search)}
  サーチリングにはEmojiシーケンス(絵文字シーケンス)を含めることもできます。@w{@kbd{C-x 8 e
@key{RET}}}の後にEmojiのUnicode名(たとえば@kbd{smiling face}や@kbd{heart with
arrow})をタイプしてください。これによって指定されたEmojiがサーチリングに追加されます。検索したいemojiの名前が判らなければ@kbd{C-x
8 e l} (@code{emoji-list})と@kbd{C-x 8 e d}
(@code{emoji-describe})を使うことができます(@ref{Input Methods}を参照)。

@kindex M-s o @r{(Incremental Search)}
@findex isearch-occur
  インクリメンタル検索の中で@kbd{M-s
o}とタイプすることにより、カレントの検索文字列で@code{occur}を実行する、@code{isearch-occur}が呼び出されます。@ref{Other
Repeating Search, occur}を参照してください。

@findex isearch-query-replace
@findex isearch-query-replace-regexp
@kindex M-% @r{(Incremental search)}
@kindex C-M-% @r{(Incremental search)}
  インクリメンタル検索で@kbd{M-%}
(@code{isearch-query-replace})をタイプすると、@code{query-replace}または@code{query-replace-regexp}が呼び出され(検索モードに依存します)、現在の検索文字が置換対象になります。負のプレフィクス引数は、後方への置換を意味します。@ref{Query
Replace}を参照してください。@kbd{C-M-%}
(@code{isearch-query-replace-regexp})とタイプすることにより、カレント検索文字列を置換すべき正規表現として@code{query-replace-regexp}が呼び出されます。

@findex isearch-complete
@kindex M-TAB @r{(Incremental search)}
  インクリメンタル検索で@kbd{M-@key{TAB}}をタイプすると、@code{isearch-complete}が呼び出され、サーチリング(以前に使用された検索文字列)を補完リストとして使って、検索文字列の補完を試みます。@ref{Completion}を参照してください。多くのオペレーティングシステムでは、キーシーケンス@kbd{M-@key{TAB}}はウィンドウマネージャーに捕えられます。その場合、これを使うには@code{isearch-complete}を、他のキーシーケンスに再バインドする必要があります(@ref{Rebinding}を参照してください)。

@kindex M-s h r @r{(Incremental Search)}
@findex isearch-highlight-regexp
@kindex M-s h l @r{(Incremental Search)}
@findex isearch-highlight-lines-matching-regexp
  @kbd{M-s h r}
(@code{isearch-highlight-regexp})とタイプすればマッチをハイライトしたまま検索をexitできます。これはハイライトに使用するフェイスの入力を求める@code{highlight-regexp}
(@ref{Highlight
Interactively}を参照)に、検索文字列から継承したregexpをに渡して実行します。(@emph{マッチだけ}ではなく)マッチを含む@emph{行全体}をハイライトするには、@kbd{M-s
h l}
(@code{isearch-highlight-lines-matching-regexp})とタイプします。いずれの場合でも、ハイライトを除去するには@kbd{M-s
h u} (@code{unhighlight-regexp})とタイプしてください。

@cindex incremental search, help on special keys
@kindex C-h C-h @r{(Incremental Search)}
@findex isearch-help-map
@vindex isearch-mode-map
  インクリメンタル検索がアクティブのとき、@kbd{C-h C-h}
(@code{isearch-help-map})とタイプすると、特別なキーバインドのリストを含む、対話的なヘルプにアクセスできます。これらのキーバインドは、キーマップ@code{isearch-mode-map}の一部です(@ref{Keymaps}を参照してください)。

@cindex incremental search, go to first or last occurrence
@kindex M-s M->
@kindex M-s M-<
  インクリメンタル検索がアクティブな際に@kbd{M-s M->}とタイプすると検索文字列の最後の出現位置、@kbd{M-s
M-<}とタイプすると最初の出現位置に移動します。プレフィクス数引数@var{n}を与えると、これらのコマンドはそれぞれバッファーの先頭または最後から数えて@var{n}個目の検索文字列の出現位置へ移動します。

@node Not Exiting Isearch
@subsection インクリメンタル検索を終了させない

このサブセクションでは検索で特別な意味をもたないコマンドがコマンドを実行する前に、検索をexitするかどうかを制御する方法を説明します。また、(たとえそれらがインクリメンタル検索の一部ではなくても)カレントのインクリメンタル検索をexitせずにタイプできる、3つのカテゴリーに属するコマンドを説明します。

@vindex search-exit-option
  インクリメンタル検索によりバインドされていないコマンドをタイプすると通常、そのコマンドを実行する前に検索をexitします。したがって、そのコマンドは検索を呼び出したときのバッファーにたいして処理を行なうことになります。しかし、変数@code{search-exit-option}を@code{append}にカスタマイズした場合、(インクリメンタル検索により解釈されないような)タイプした文字は、単に検索文字列に追加されます。これにより、通常は検索をexitして、その文字にバインドされているコマンドをそのバッファーにたいして呼び出す、@kbd{C-a}のような制御文字を検索文字列に含めることができるようになります。

@table @asis
@item プレフィクス引数
@cindex prefix argument commands, during incremental search
@vindex isearch-allow-prefix
  インクリメンタル検索でプレフィクス引数を指定したコマンドをタイプすると、デフォルトではその引数は次の検索アクションに適用されるか、検索をexitするコマンドに渡されます。他の言い方をすると、プレフィクス引数の入力自体は、検索を終了させません。

  以前のバージョンのEmacsでは、プレフィクス引数の入力は常に検索を終了させていました。この振る舞いに戻すには、変数@code{isearch-allow-prefix}に@code{nil}をセットしてください。

  @code{isearch-allow-scroll}が非@code{nil}のとき(以下を参照)、プレフィクス引数は上で説明したようなデフォルト動作をします。つまり、たとえ@code{isearch-allow-prefix}が@code{nil}でも、プレフィクス引数は検索を終了させません。

@item スクロールコマンド
@cindex scrolling commands, during incremental search
@vindex isearch-allow-scroll
@cindex @code{scroll-command} property, and incremental search
  通常スクロールコマンドは、インクリメンタル検索を終了させます。しかし変数@code{isearch-allow-scroll}を非@code{nil}値に変更すると、非@code{nil}の@code{scroll-command}プロパティをもったスクロールバーや@kbd{C-v}、@kbd{M-v}、@kbd{C-l}のようなスクロールコマンド(@ref{Scrolling}を参照)が利用可能になります。これは、これらのコマンドをバウンドされたキーシーケンスで呼び出したときだけ適用されます。つまり@kbd{M-x}は依然として検索を終了させます。これらのコマンドには、通常の方法でプレフィクス引数を与えることができます。この機能では通常はカレントマッチが表示されない位置にスクロールすることはできません。しかし@code{isearch-allow-scroll}を特別な値@code{unlimited}にカスタマイズすることにより、この制限は解除されます。

@cindex @code{isearch-scroll} property
@cindex prevent commands from exiting incremental search
  @code{isearch-allow-scroll}の機能は、正確にはスクロールではないが、テキストが表示されるスクリーン位置に影響する@kbd{C-x
2} (@code{split-window-below})や@kbd{C-x ^}
(@code{enlarge-window})のようなコマンドにも効果を及ぼします。実際のところこれはコマンドの@code{isearch-scroll}プロパティが非@code{nil}のコマンドに適用されます。そのためどのコマンドが影響を受けるかは、それらのプロパティを変更して制御できます。

  たとえば将来のEmacsセッションも含めて、インクリメンタル検索中に@kbd{C-h l}を使えれば便利だと思ったら、まず@kbd{C-h
c}で何のコマンドが実行されるか調べて(@ref{Key
Help}を参照してください)、それが@code{view-lossage}だとわかります。その後はinitファイルに以下を追加します(@ref{Init
File}を参照してください)。

@example
(put 'view-lossage 'isearch-scroll t)
@end example

@noindent
この機能はポイント、バッファー内容、マッチデータ、カレントバッファーや選択されているウィンドウ・フレームを変更しない任意のコマンドに適用できます。そして、そのコマンド自体がインクリメンタル検索を行ってはなりません。この機能は、@code{isearch-allow-scroll}が@code{nil}(デフォルト)の場合は無効です。

@vindex isearch-allow-motion
@vindex isearch-motion-changes-direction
  同様に変数@code{isearch-allow-motion}を非@code{nil}値に変更するとキーボード移動コマンド@kbd{M-<}、@kbd{M->}、@kbd{C-v}、@kbd{M-v}でカレント検索文字列のバッファー内での最初、最後、カレントウィンドウの後にある最初、カレントウィンドウの前の最後の出現箇所へと移動します。これらの移動コマンド使用時は検索方向は変化しません。変数@code{isearch-motion-changes-direction}を非@code{nil}値に変更した場合には、検索方向は@kbd{M-<}と@kbd{C-v}の後は前方、@kbd{M->}と@kbd{M-v}の後は後方になります。

@item 移動コマンド
@cindex motion commands, during incremental search
@code{isearch-yank-on-move}を@code{shift}にカスタマイズしている際には、カーソル移動コマンドをタイプ中にシフトキーを押下することにより検索文字列を拡張できます。これはポイント移動後にカレントバッファーの新たな位置で終了するテキストをyankします。

@cindex @code{isearch-move} property
@code{isearch-yank-on-move}が@code{t}の際にはカーソル移動コマンドにシフトキーを使用せずに検索文字列を拡張できますが、それはコマンドのシンボルに@code{isearch-move}プロパティをもつ特定の移動コマンドだけに適用されます。
@end table

@node Isearch Minibuffer
@subsection ミニバッファーの検索
@cindex minibuffer history, searching

ミニバッファーがアクティブのときインクリメンタル検索を開始すると、Emacsはミニバッファーの内容を検索します。通常のバッファーにたいする検索とは異なり、エコーエリアはミニバッファーの表示に使われているので、検索文字列はエコーエリアには表示されません。

ミニバッファーでのインクリメンタル検索が失敗すると、ミニバッファーヒストリーを検索します。@ref{Minibuffer
History}を参照してください。ミニバッファーとミニバッファーのヒストリーは、一番古いヒストリー要素が最初で、カレントのミニバッファーが最後にある、一連のページとして視覚化することができます。前方検索の@kbd{C-s}は前方、つまり新しいページを検索し、後方検索の@kbd{C-r}は後方、つまり古いページを検索します。普通のバッファーの検索と同様、検索が失敗すると、最後から最初のページ、またはその逆に巻き直して検索します。

カレントマッチがヒストリーの要素にあった場合、ヒストリーの要素はミニバッファーに取り出されます。インクリメンタル検索を正常に終了(たとえば@key{RET}をタイプ)すれば、それはミニバッファーに残ります。検索を取り消すのは@kbd{C-g}で、これによりミニバッファーの内容は検索を開始したときのものに復元されます。

@node Nonincremental Search
@section 非インクリメンタル検索
@cindex nonincremental search

  Emacsには、従来式の非インクリメンタル検索もあります。これは検索を開始する前に、検索文字列全体を入力する必要があります。

@table @kbd
@item C-s @key{RET} @var{string} @key{RET}
@var{string}を検索します。
@item C-r @key{RET} @var{string} @key{RET}
後方に@var{string}を検索します。
@end table

  非インクリメンタル検索を開始するには、最初に@kbd{C-s
@key{RET}}をタイプします。これにより、検索文字列を読みとるために、ミニバッファーに移動します。検索文字列の入力を終了して検索を開始するには、@key{RET}をタイプします。文字列が見つからなかったとき、検索コマンドはエラーをシグナルします。

  @kbd{C-s
@key{RET}}とタイプすると、@kbd{C-s}は通常どおりインクリメンタル検索を呼び出します。しかし、このコマンドは指定した文字列が空のとき、非インクリメンタル検索を行うコマンドを呼び出すよう、プログラムされています(そのような用途以外に空の引数は無意味です)。@kbd{C-r
@key{RET}}も同様に、後方に非インクリメンタル検索を行なうコマンドを呼び出します。

  メニューバーの@samp{Edit->Search}メニューから非インクリメンタル検索を呼び出すこともできます。

@findex search-forward
@findex search-backward
  よりシンプルな2つのコマンド、@kbd{M-x search-forward}と@kbd{M-x
search-backward}を使うこともできます。これらのコマンドは指定した文字をリテラルとして検索し、case
folding(検索で大文字小文字を区別するか)を除くlax-search機能(@ref{Lax Search}を参照してください)をサポートしません。

@node Word Search
@section 単語検索
@cindex word search

  @dfn{単語検索(word
search)}は、単語の並びを、その間にある区切り文字の種類とは無関係に検索します。たとえば検索文字列に、1つのスペースで区切られた2つの単語を入力すると、2つの単語を区切るのが、1つまたはそれ以上のスペース、改行文字、およびそれ以外の区切り文字の場合にもマッチします。これはテキスト文書を検索するとき特に有用です。なぜなら検索する単語が改行で区切られているのか、スペースで区切られているのか考慮しなくてもよいからです。プログラミング言語のためのメジャーモード、およびその他の特別なメジャーモード、そのモードの構文的なニーズに適合するように、単語の定義が変更されているかもしれないことに注意してください。

@table @kbd
@item M-s w
  インクリメンタル検索がアクティブのとき、単語検索モードに切り替えます(@code{isearch-toggle-word})。非アクティブのときは、前方へのインクリメンタルな単語検索を開始します(@code{isearch-forward-word})。
@item M-s w @key{RET} @var{words} @key{RET}
非インクリメンタルな単語検索を使って、@var{words}を前方検索します。
@item M-s w C-r @key{RET} @var{words} @key{RET}
非インクリメンタルな単語検索を使って、@var{words}を後方検索します。
@item M-s M-w
リージョン内のテキストにたいして、Webを検索します。
@end table

@findex isearch-forward-word
@findex isearch-toggle-word
@kindex M-s w
  前方へのインクリメンタルな単語検索を開始するには、@kbd{M-s
w}とタイプします。インクリメンタル検索が非アクティブの場合、これはコマンド@code{isearch-forward-word}を実行します。インクリメンタル検索がすでにアクティブの場合(前方か後方かにかかわらず)、@kbd{M-s
w}は検索の方向と現在の検索文字列は変更せずに、単語検索に切り替えるコマンド@code{isearch-toggle-word}を実行します。単語検索をオフに切り替えるには、再度@kbd{M-s
w}をタイプしてください。

@findex word-search-forward
@findex word-search-backward
  非インクリメンタルな単語検索を開始する場合、前方検索は@kbd{M-s w @key{RET}}、後方検索は@kbd{M-s w C-r
@key{RET}}をタイプします。これらはコマンド@code{word-search-forward}、または@code{word-search-backward}を実行します。

  インクリメンタルな単語検索と、非インクリメンタルな単語検索では、マッチを見つける方法に若干の違いがあります。非インクリメンタルな単語検索では、検索文字列の各単語は、単語全体に厳密に一致しなければなりません。インクリメンタルな単語検索では、マッチの規則は緩くなります。検索文字列をタイプするとき、最初と最後の単語は、単語全体にマッチする必要はありません。これはタイプする度にマッチを処理するためです。これは(カーソルがある)カレントマッチ以外のマッチ(lazy
matches。@ref{Incremental
Search}を参照してください)には適用されません。それらは単語全体がマッチしなければハイライトされません。検索文字列をタイプしている間は、@kbd{C-s}のような検索繰り返しキーを使用するまで、検索プロンプトに@samp{Pending}が表示されます。

  単語検索コマンドは、character foldingを処理せず、lax whitespace matching(@ref{Lax Search,
lax space matching}を参照してください)が効果をもたないように切り替えます。

@kindex M-s M-w
@findex eww-search-words
@vindex eww-search-prefix
@cindex Internet search
@cindex search Internet for keywords
@cindex web search
  リージョン内のテキストにたいしてWebを検索するには、@kbd{M-s
M-w}とタイプします。このコマンドは、変数@code{eww-search-prefix}により指定された@acronym{URL}の検索エンジンを使用して、リージョン内の単語にたいするインターネット検索を行ないます(@ref{Basics,
EWW, , eww, The Emacs Web Wowser
Manual}を参照)。リージョンがアクティブでない場合、このコマンドはユーザーに検索するURL、またはキーワードの入力を求めます。


@node Symbol Search
@section シンボル検索
@cindex symbol search

  @dfn{シンボル検索(symbol
search)}は、通常の検索と似ていますが、検索の境界がシンボルの境界にマッチしていなければなりません。@dfn{シンボル}の意味は、メジャーモードのコンテキストに依存しており、Emacs
LispモードでのLispシンボルのように、通常はソースコードのトークンを参照します。たとえばLispシンボル@code{forward-word}をインクリメンタルなシンボル検索すると、これは@code{isearch-forward-word}にはマッチしません。そのため、この機能は主にソースコードの検索に有用です。

@table @kbd
@item M-s _
@findex isearch-toggle-symbol
インクリメンタル検索がアクティブのとき、シンボル検索モードに切り替えます(@code{isearch-toggle-symbol})。非アクティブのときは、前方へのインクリメンタルなシンボル検索を開始します(@code{isearch-forward-symbol})。
@item M-s .
ポイントの近くにあるシンボルを、検索文字列の初期値に追加して、前方へのインクリメンタルなシンボル検索を開始します。
@item M-s _ @key{RET} @var{symbol} @key{RET}
@var{symbol}にたいして、前方への非インクリメンタルな検索をします。
@item M-s _ C-r @key{RET} @var{symbol} @key{RET}
@var{symbol}にたいして、後方への非インクリメンタルな検索をします。
@end table

@kindex M-s _
@kindex M-s .
@findex isearch-forward-symbol
@findex isearch-forward-symbol-at-point
  前方へのインクリメンタルなシンボル検索を開始するには、@kbd{M-s _} (ポイントの近くにシンボルがあるときは@kbd{M-s
.})をタイプします。インクリメンタル検索がまだアクティブでなければ@kbd{M-s
_}はコマンド@code{isearch-forward-symbol}、@kbd{M-s
.}はコマンド@code{isearch-forward-symbol-at-point}を実行します。プレフィクス数引数@var{n}を与えると@kbd{M-s
.}はポイント位置のシンボルにたいして次の@var{n}番目の出現位置を検索します。負の@var{n}では後方に検索します。すでにインクリメンタル検索がアクティブのとき、@kbd{M-s
_}は検索方向と現在の検索文字列を維持した状態で、シンボル検索に切り替えます(もう一度@kbd{M-s
_}をタイプすると、シンボル検索を無効にできます)。インクリメンタルなシンボル検索では、検索み文字列をタイプする間は、検索文字列の先頭がシンボルの先頭にマッチだけが必要であり、@kbd{C-s}のような検索繰り返しキーを使用するまでは検索プロンプトに@samp{Pending}が表示されます。

  非インクリメンタルなシンボル検索は、前方への検索は@kbd{M-s _ @key{RET}}、後方への検索は@kbd{M-s _ C-r
@key{RET}}をタイプします。非インクリメンタル検索では、文字列の先頭と最後が、シンボルの先頭と最後にマッチする必要があります。

  シンボル検索コマンドは、character foldingを処理せず、lax whitespace matching(@ref{Lax Search,
lax space matching}を参照してください)が効果をもたないように切り替えます。

@node Regexp Search
@section 正規表現検索
@cindex regexp search
@cindex search for a regular expression

  @dfn{正規表現}(regular expression:
@dfn{regexp}と略します)とは、文字列にマッチさせるための文字列候補のクラスを示すパターンです。Emacsはregexpにマッチする検索をインクリメンタル、非インクリメンタルの両方で提供します。正規表現の構文は、次のセクションで説明します。

@table @kbd
@item C-M-s
インクリメンタルなregexp検索を開始します(@code{isearch-forward-regexp})。
@item C-M-r
逆方向のインクリメンタルなregexp検索を開始します(@code{isearch-backward-regexp})。
@end table

@kindex C-M-s
@findex isearch-forward-regexp
@kindex C-M-r
@findex isearch-backward-regexp
  regexpにたいするインクリメンタル検索は、@kbd{C-M-s}
(@code{isearch-forward-regexp}をタイプするか、プレフィクス引数(引数の値は何でもよい)を指定して、@kbd{C-s}を呼び出します。前方へのインクリメンタル検索中は、@kbd{M-r}をタイプします。このコマンドは@kbd{C-s}と同様に、検索文字列をインクリメンタルに読みとりますが、検索文字列に正確に一致するバッファーのテキストを検索するのではなく、検索文字列をregexpとして扱います。検索文字列にテキストを追加する度に、regexpは長くなり、新しいregexpを検索します。後方へのregexp検索には、@kbd{C-M-r}(@code{isearch-backward-regexp})またはプレフィクス引数を指定した@kbd{C-r}を使います。後方へのインクリメンタル検索中は@kbd{M-r}を使います。

@vindex regexp-search-ring-max
  通常のインクリメンタル検索の特別なキーシーケンス(@ref{Special
Isearch}を参照)は、インクリメンタルなregexp検索でも同じようなことを行います。たとえば検索開始直後に@kbd{C-s}をタイプすると、最後に行ったインクリメンタル検索で使ったregexpで、前方検索を行います。インクリメンタルなregexpと非regexp検索は、独立したデフォルトを持ちます。これらは別のサーチリングも持っており、これには@kbd{M-p}と@kbd{M-n}でアクセスできます。サーチリングに保存される検索regexpの最大数は、@code{regexp-search-ring-max}の値により決定され、デフォルトは16です。

  通常のインクリメンタル検索とは異なり、インクリメンタルregexp検索は、デフォルトではlax space
matchingを使いません。この機能を切り替えるには、@kbd{M-s @key{SPC}}
(@code{isearch-toggle-lax-whitespace})を使います。そうするとインクリメンタルregexp検索での@key{SPC}は、1つ以上の空白文字の並びにマッチするようになります。変数@code{search-whitespace-regexp}は、lax
space matchingにたいするregexpを指定します。@ref{Special Isearch}を参照してください。

  通常のインクリメンタル検索とは異なり、インクリメンタルなregexp検索ではcharacter folding(@ref{Lax
Search}を参照してください)を使用できません(インクリメンタルregexp検索の途中で、@kbd{M-s '}によりcharacter
foldingを切り替えた場合、検索は非regexp検索となり、タイプした検索パターンはリテラル文字列として解釈されます)。

@cindex pending, in incremental search
  インクリメンタルregexp検索では検索文字列の追加によりカーソルが前に戻されて、最初から検索しなおされることがありえます。たとえば検索文字列@samp{foo}に@samp{\|bar}を追加すると、カーソルは@samp{foo}より前にある最初の@samp{bar}に戻ります(この再計算の発生をユーザーに通知するために``Pending''を示すプロンプトに変更される)。@ref{Regexps}を参照してください。

  前方および後方へのregexp検索は、対照的ではありません。なぜならEmacsでのregexpに対するマッチは常に前方へ処理され、regexpの先頭から開始されるからです。したがって前方へのregexp検索は前方にスキャンし、可能性のある開始位置から前方へとマッチを試みます。後方へのregexp検索は後方へスキャンし、可能性のある開始位置から前方へとマッチを試みます。これらの検索手法はミラーイメージではありません。

@findex re-search-forward
@findex re-search-backward
  regexpにたいする非インクリメンタルな検索は、コマンド@code{re-search-forward}および@code{re-search-backward}で行われます。これらのコマンドは@kbd{M-x}から呼び出すか、インクリメンタルregexp検索からの@kbd{C-M-s
@key{RET}}および@kbd{C-M-r
@key{RET}}で呼び出します。@kbd{M-x}を使用してこれらのコマンドを呼び出した場合は、指定したregexpを厳密に検索するので、case
foldingを除くlax-search機能(@ref{Lax Search}を参照してください)はサポートされません

  プレフィクス引数を指定したインクリメンタルregexp検索は、@code{isearch-forward}や@code{isearch-backward}のような、通常の文字列を検索します。@ref{Incremental
Search}を参照してください。

@node Regexps
@section 正規表現の構文
@cindex syntax of regexps
@cindex regular expression
@cindex regexp

  このセクション(および、マニュアル全般)では、ユーザーが通常使う正規表現の機能を説明します。主にLispプログラムで使用される追加の機能については、@ref{Regular
Expressions,,, elisp, The Emacs Lisp Reference Manual}を参照してください。

  正規表現は、いくつかの@dfn{特殊文字(special
constructs)}と、それ以外の@dfn{普通}の文字からなる構文を持ちます。通常の文字はそれと同じ文字にマッチし、それ以外の文字にはマッチしません。特殊文字は、@samp{$^.*+?[\}です。文字@samp{]}は、ブラケット式(bracket
expression: ブラケット表現;
以下参照)を終了させる場合は特殊文字です。文字@samp{-}は、ブラケット式の中では特殊文字です。正規表現の中に現れるその他の文字は、前に@samp{\}がついてない限り普通の文字です(Lispプログラム内で正規表現を使う場合、@samp{\}は2つ記述しなければなりません。このセクションの最後にある例を参照してください)。

  たとえば@samp{f}は特殊文字ではなく普通の文字なので、正規表現中の@samp{f}は文字列@samp{f}にマッチし、他の文字列にはマッチしません(文字列@samp{ff}にはマッチ@emph{しません})。同様に正規表現中の@samp{o}は、@samp{o}だけにマッチします(大文字小文字を区別しない場合、これらのregexpは@samp{F}や@samp{O}にもマッチしますが、これを例外としてではなく、``同じ文字列''を一般化したものと考えます)。

  2つの正規表現@var{a}と@var{b}を結合できます。結合した結果は、@var{a}が先頭の適当な部分に一致して、@var{b}が残りの部分に一致する正規表現となります。些細な例としては、@samp{f}と@samp{o}という正規表現を結合すると、正規表現@samp{fo}となり、これは文字列@samp{fo}だけにマッチします。ここまでは普通です。これより複雑ことを行うには、特殊文字を使う必要があります。以下にリストを示します。

@table @asis
@item @kbd{.}@: @r{(ピリオド)}
これは改行文字以外の任意の1文字にマッチする特殊文字です。たとえば正規表現@samp{a.b}は、最初が@samp{a}で最後が@samp{b}の3文字の文字列にマッチします。

@item @kbd{*}
単独では使用されません。これは接尾演算子で、前の正規表現の任意の回数、可能な限り多くの回数を含めた繰り返しを意味します。したがって@samp{o*}は任意の個数の@samp{o}にマッチし、@samp{o}がない場合(0個の場合)も含めてマッチします。

@samp{*}は常に可能な限り@emph{小さな}、前置表現に適用されます。したがって@samp{fo*}は@samp{fo}の繰り返しではなく@samp{o}の繰り返しです。この正規表現は@samp{f}、@samp{fo}、@samp{foo}、...にマッチします。

マッチングにより構成される@samp{*}は、見つけられるだけの反復回数へと、直ちに処理されます。その後でパターンの残りの部分の処理を続けます。これが失敗すると、バックトラッキングが発生します。@samp{*}の反復回数をいくつか捨てて、パターンの残りの部分がマッチするように構成を変更します。たとえば文字列@samp{caaar}にたいして@samp{ca*ar}をマッチさせる場合、まず最初に@samp{a*}を、3つすべての@samp{a}にマッチさせます。しかしパターンの残りの部分は@samp{ar}ですが、マッチさせるために残っているのは@samp{r}だけなので、このマッチは失敗します。かわりに@samp{a*}を2つの@samp{a*}だけにマッチさせます。この選択により、regexpの残りの部分のマッチが成功します。

@item @kbd{+}
これは@samp{*}と同様に接尾演算子ですが、前置表現に最低1回マッチしなければならない点が異なります。したがって@samp{ca+r}は@samp{car}、@samp{caaaar}にマッチしますが、@samp{cr}にはマッチしません。一方@samp{ca*r}は、これら3つすべての文字列にマッチします。

@item @kbd{?}
これは@samp{*}と同様に接尾演算子ですが、前置表現が1回出現するか、出現しないかいずれかという点が異なります。したがって@samp{ca?r}は、@samp{car}または@samp{cr}のいずれかになります。

@item @kbd{*?}, @kbd{+?}, @kbd{??}
@cindex non-greedy regexp matching
これらは上述した演算子の、非@dfn{貪欲(greedy)}なタイプの演算子です。通常の演算子@samp{*}、@samp{+}、@samp{?}は、regexpがマッチする、できる限り長いマッチを行います。しかしこれらの演算子に@samp{?}を後置すると、できる限り短いマッチを行います。

したがって@samp{ab*}と@samp{ab*?}は、両方とも文字列@samp{a}と文字列@samp{abbbb}にマッチしますが、文字列@samp{abbb}にマッチさせたとき、@samp{ab*}は文字列全体(有効な最長マッチ)にマッチしますが、@samp{ab*?}は@samp{a}(有効な最短マッチ)だけにマッチします。

非貪欲な演算子は、与えられた開始位置から開始される、できるだけ短い文字列にマッチします。前方検索では、利用できる一番最初の開始位置は、常にカーソルの位置となります。したがって末尾が改行のテキスト@samp{abbab}にたいして@samp{a.*?$}を検索すると、文字列全体にマッチします。これはマッチが最初の@samp{a}から開始されので、マッチさせることが@emph{できる}のです。

@cindex bracket expression
@cindex set of alternative characters, in regular expressions
@cindex character set, in regular expressions
@item @kbd{[ @dots{} ]}
@dfn{ブラケット式(bracket expression)}、いわゆる@dfn{文字候補集合(set of alternative
characters)}です。文字集合のうちのいずれかの文字にマッチします。

もっとも簡単なケースでは、2つのカッコの間に指定された文字が、マッチできる文字集合となります。したがって@samp{[ad]}は1つの@samp{a}か1つの@samp{d}にマッチし、@samp{[ad]*}は@samp{a}と@samp{d}からなる任意の文字列にマッチします(空の文字列を含む)。結果として@samp{c[ad]*r}は、@samp{cr}、@samp{car}、@samp{cdr}、@samp{caddaar}、...にマッチします。

文字集合には、開始文字と終了文字の間に@samp{-}を記述することにより、文字の範囲を含めることもできます。したがって@samp{[a-z]}は、@acronym{ASCII}小文字となります。文字の範囲と特定の文字の指定を混ぜることもできます。@samp{[a-z$%.]}は任意の@acronym{ASCII}小文字と@samp{$}、@samp{%}、@samp{.}にマッチします。別の例としては、@samp{[α-ωί]}はギリシャ文字の小文字すべてにマッチします。

@cindex character classes, in regular expressions
いくつかの特別な@dfn{文字クラス(character
classes)}を文字集合に含めることもできます。ブラケット式を含む文字クラスは@samp{[:}と@samp{:]}で囲んで指定します。たとえば@samp{[[:alnum:]]}は、任意のアルファベットと数字にマッチします。文字クラスのリストは、@ref{Char
Classes,,, elisp, The Emacs Lisp Reference Manual}を参照してください。

文字集合に@samp{]}を含めるには、それを最初に記述しなければなりません。たとえば@samp{[]a]}は、@samp{]}または@samp{a}にマッチします。文字集合に@samp{-}を含めるには、@samp{-}を文字集合の最後に記述しますが、範囲の先頭や後にも記述できます。したがって@samp{[]-]}は、@samp{]}と@samp{-}の両方にマッチします。

文字集合に@samp{^}を含めるには、集合の最初以外に記述します(最初に記述した場合、補集合を指定したことになります。以下を参照してください)。

大文字小文字を区別しない検索で文字の範囲を使う場合、範囲の先頭と最後を、大文字だけ、または小文字だけで記述するか、先頭と最後をアルファベット以外で記述するべきです。@samp{A-z}のような大文字小文字を混成した範囲指定は不正な定義で、Emacsの将来のバージョンで変更されるかもしれません。

@item @kbd{[^ @dots{} ]}
@samp{[^}は@dfn{文字の補集合complemented character
set}を開始します。つまり指定された文字以外がマッチします。したがって@samp{[^a-z0-9A-Z]}は、@acronym{ASCII}文字と数字@emph{以外}にマッチします。

@samp{^}は文字集合で最初以外で使用された場合、特別な意味をもちません。@samp{^}に続く文字は、先頭にあるものとして扱われます(いいかえると@samp{-}と@samp{]}は、ここでは特別な意味をもちません)。

もしマッチしない文字として改行が記述されていなければ、文字の補集合を改行にマッチさせることができます。これは@code{grep}のようなプログラムにおける、regexpにたいする処理とは対照的です。

@item @kbd{^}
これは空文字列、ただしテキストの行頭だけにマッチする特殊文字です。それ以外ではマッチに失敗します。したがって@samp{^foo}は行の先頭にある@samp{foo}にマッチします。

歴史的な互換性により、この意味での@samp{^}の使用は、正規表現の先頭か、@samp{\(}または@samp{\|}の後に記述された場合に限ります。

@item @kbd{$}
@samp{^}と似ていますが、行末だけにマッチします。したがって@samp{x+$}は、行末にある1つ以上の@samp{x}にマッチします。

歴史的な互換性により、この意味での@samp{$}の使用は、正規表現の最後か、@samp{\)}または@samp{\|}の後に記述された場合に限ります。

@item @kbd{\}
これには2つの機能があります。まず特殊文字(@samp{\}を含む)をクォートすることと、追加の特別な構成を導入することです。

@samp{\}は特殊文字をクォートするので、正規表現中の@samp{\$}は@samp{$}だけにマッチし、@samp{\[}は@samp{[}だけにマッチします。

@samp{\}で始まる特別な構成については、以下のセクションを参照してください。
@end table

  注意:
歴史的な互換性から、特殊文字はそれが特殊な意味をもたないようなコンテキストで使用された場合は、通常の文字として扱われます。たとえば@samp{*foo}は、@samp{*}が特殊文字として動作するための前置された表現がないので、普通の文字として扱われます。このような振る舞いに依存することは、よい習慣ではありません。特殊文字を記述する場合、それがどこに記述されようとクォートするべきです。

ブラケット式の中では@samp{\}は特別ではなく@samp{-}、@samp{^}、@samp{]}のもつ特別な意味を除去することはありません。これらの文字が特別な意味をもたないような場所にあるときは、これらの文字もクォートすべきではありません。これでは明確ではないかもしれません。これらの特殊文字が@emph{特別な意味をもつ場所}にあるとき、バックスラッシュを前置することによりクォートされるのです。たとえば@samp{[^\]}(Lispの文字記法では@code{"[^\\]"})は、バックスラッシュ以外の任意の一文字にマッチします。

@node Regexp Backslash
@section 正規表現でのバックスラッシュ

  多くの場合、任意の文字を伴う@samp{\}はその文字だけに一致します。しかしいくつか例外があって、@samp{\}で始まる2文字のシーケンスが、特別な意味を持つ場合があります。シーケンス内の2文字目にくる文字は、単独で使った場合には普通の文字として扱われるものです。以下は@samp{\}の構成の表です。

@table @kbd
@item \|
選択肢を指定します。2つの正規表現@var{a}と@var{b}の間に@samp{\|}を記述すると、それは@var{a}または@var{b}のいずれかにマッチする表現を形成します。これはまず@var{a}とのマッチを試み、失敗した場合に@var{b}とのマッチを試みます。

したがって@samp{foo\|bar}は、@samp{foo}または@samp{bar}のいずれかにマッチし、それ以外の文字列にはマッチしません。

@samp{\|}は、周囲の一番大きな表現に適用されます。@samp{\|}のグループ化の能力に制限をかけることができるのは、周囲の@samp{\(
@dots{} \)}によるグループ化だけです。

複数の@samp{\|}使用を処理するための、完全なバックトラッキング能力が存在します。

@cindex sub-expressions, in regular expressions
@cindex grouping, in regular expressions
@item \( @dots{} \)
3つの目的のためのグループ化構成です:

@enumerate
@item
他の操作に使うために、一連の選択肢@samp{\|}を括ります。したがって@samp{\(foo\|bar\)x}は、@samp{foox}または@samp{barx}のいずれかにマッチします。

@item
接尾演算子@samp{*}、@samp{+}、@samp{?}を適用できるように、複雑な正規表現を括ります。したがって@samp{ba\(na\)*}は、@samp{bananana}のように、(0個以上の)文字列@samp{na}にマッチします。

@item
あとで参照できるように、マッチした部分文字列を記録します。
@end enumerate

この最後の使い方は、カッコでグループ化することが重要なのではありません。これは@w{@samp{\\( @dots{}
\\)}}構成の、2番目の意味とは異なる機能です。実際には、これら2つの機能が衝突することは、通常はありません。もし衝突するようなら、以下で説明する、shy(内気)なグループ化を使うことができます。

@item \(?: @dots{} \)
@cindex shy group, in regexp
マッチした部分文字列を記録しない、@dfn{shy(内気)なグループ化}を指定します。マッチした部分文字列は、@samp{\@var{d}}により後方参照できません(以下参照)。この機能は正規表現を機械的にまとめるときに役立ちます。これにより後方参照するためのグループにたいする番号づけに影響することなく、文法的な目的によるグループ化を行うことができます。

@item \@var{d}
@cindex back reference, in regexp
@var{d}番目に@samp{\( @dots{} \)}構成にマッチしたテキストと同じテキストにマッチします。これは@dfn{後方参照(back
reference)}と呼ばれます。

最後の@samp{\( @dots{}
\)}構成の後で、マッチ処理はこの構成にマッチしたテキストの最初と最後を記録します。そして正規表現の後の部分で@samp{\}の後に数字@var{d}を使うことにより、@var{d}番目の@samp{\(
@dots{} \)}構成にマッチしたテキストと同じテキストにマッチさせることができます。

正規表現に記述された最初の9つの@samp{\( @dots{}
\)}にマッチしたテキストは、正規表現で開きカッコが出現した順に、1から9までの数字が割り当てられます。そのため@samp{\1}から@samp{\9}を使うことにより、@samp{\(
@dots{} \)}構成にマッチした、対応するテキストを参照することができます。

たとえば@samp{\(.*\)\1}は改行を含まない、前半と後半が同一の文字列にマッチします。@samp{\(.*\)}は、そのテキストが何であろうと前半にマッチしますが、@samp{\1}は前半と正確に同じテキストにマッチしなければなりません。

もし特定の@samp{\( @dots{}
\)}構成が１回以上マッチする場合(これは@samp{*}が後置されているとき簡単に発生します)、最後のマッチだけが記録されます。

@item @kbd{\@{@var{m}\@}}
これは@var{m}回の繰り返しを指定する接尾演算子です。つまり前置される正規表現に、正確に@var{m}回連続でマッチしなければなりません。たとえば@samp{x\@{4\@}}は、文字列@samp{xxxx}だけにマッチします。

@item @kbd{\@{@var{m},@var{n}\@}}
これは@var{m}回から@var{n}回の繰り返しを指定する接尾演算子です。つまり前置される正規表現が最低@var{m}回、最大@var{n}回マッチしなければなりません。@var{n}が省略されたときはマッチ回数の上限はありませんが、前置される正規表現は少なくとも@var{m}回マッチしなければなりません。@*
@samp{\@{0,1\@}}は@samp{?}と同じです。@* @samp{\@{0,\@}}は@samp{*}と同じです.@*
@samp{\@{1,\@}}は@samp{+}と同じです。

@item \`
空の文字列にマッチしますが、文字列またはバッファー(またはアクセスできる部分)の先頭に限定されます。

@item \'
空の文字列にマッチしますが、文字列またはバッファー(またはアクセスできる部分)の最後に限定されます。

@item \=
空の文字列にマッチしますが、ポイント位置に限定されます。

@item \b
空の文字列にマッチしますが単語の先頭または最後に限定されます。したがって@samp{\bfoo\b}は、区切られた単語@samp{foo}にマッチします。@samp{\bballs?\b}は、別々の単語@samp{ball}または@samp{balls}にマッチします。

@samp{\b}は、そこにどんなテキストが出現しようと、バッファーの先頭または最後にもマッチします。

@item \B
空の文字列にマッチしますが、単語の最初と最後@emph{以外}にマッチします。

@item \<
空の文字列にマッチしますが、単語の先頭に限定されます。@samp{\<}は単語の構成文字が続く場合に限り、バッファーの先頭にマッチします。

@item \>
空の文字列にマッチしますが、単語の最後に限定されます。@samp{\<}は内容が単語の構成文字で終わる場合に限りバッファーの最後にマッチします。

@item \w
任意の単語構成文字にマッチします。どの文字が該当するかは、構文テーブル(syntax table)により決定されます。@ref{Syntax
Tables,, Syntax Tables, elisp, The Emacs Lisp Reference Manual}を参照してください。

@item \W
単語構成文字以外の任意の文字にマッチします。

@item \_<
空の文字列にマッチしますが、シンボルの先頭に限られます。シンボルは１文字以上のシンボル構成文字からなります。シンボル構成文字は、@samp{w}と@samp{_}の構文をもつ文字です。@samp{\_<}はシンボル構成文字が続く場合に限り、バッファーの先頭にもマッチします。単語にたいしては、構文テーブル(syntax
table)が、どの文字がシンボル構成文字かを判断します。

@item \_>
空の文字列にマッチしますが、シンボルの最後に限定されます。@samp{\_>}は内容がシンボル構成文字で終わる場合に限り、バッファーの最後にマッチします。

@item \s@var{c}
構文が@var{c}である、任意の文字にマッチします。ここで@var{c}とは、特定の構文クラスを表す文字です。したがって@samp{w}は単語構成文字、@samp{-}または@samp{
}は空白文字、@samp{.}は通常の区切り文字、などとなります。@ref{Syntax Class Table,, Syntax Class
Table, elisp, The Emacs Lisp Reference Manual}を参照してください。

@item \S@var{c}
構文が@var{c}以外の、任意の文字にマッチします。

@cindex categories of characters
@cindex characters which belong to a specific language
@findex describe-categories
@item \c@var{c}
カテゴリー@var{c}に属する、任意の文字にマッチします。たとえば@samp{\cc}は中国文字、@samp{\cg}はギリシャ文字にマッチします。既知のカテゴリーについての説明は、@kbd{M-x
describe-categories @key{RET}}をタイプしてください。

@item \C@var{c}
カテゴリー@var{c}に@emph{属さない}、任意の文字にマッチします。
@end table

  単語と構文に関係する構成は構文テーブルのセッティングにより制御されます。@xref{Syntax Tables,, Syntax Tables,
elisp, The Emacs Lisp Reference Manual}.

@node Regexp Example
@section 正規表現の例

  以下にregexpの例を示します。これはEmacsがセンテンスの最後(末尾の空白は含まない)を認識するために、デフォルトで使用するregexp(たとえば変数@code{sentence-end-base})と似ています。

@example
@verbatim
[.?!][]\"')}]*
@end verbatim
@end example

@noindent
これには2つの連続する部分があります。1つは@samp{.}、@samp{?}、@samp{!}にマッチする文字です。もう1つは閉じカッコ、クォート、カッコの0回以上の繰り返しです。

@node Lax Search
@section 検索中のLaxマッチング

@cindex lax search
@cindex character equivalence in search
  あなたは通常、タイプした文字と、検索されるテキストの間にある、特定の瑣末な違いを、検索コマンドが無視することを望むでしょう。たとえば長さが異なる空白文字シーケンスは通常、等しいとみなされ、大文字小文字の違いは通常問題にならない、などです。これは@dfn{等価文字(character
equivalence)}として知られています。

  このセクションではEmacsのlax search(緩い検索)機能と、それを必要に応じて調整する方法について説明します。

@cindex lax space matching in search
@kindex M-s SPC @r{(Incremental search)}
@kindex SPC @r{(Incremental search)}
@findex isearch-toggle-lax-whitespace
@vindex search-whitespace-regexp
  デフォルトでは、検索コマンドは@dfn{lax space
matching(緩いスペースマッチング)}を行います。この検索ではスペースおよび一連のスペースは、テキスト中の1つ以上の空白文字にマッチします。正確に言うと、Emacsは検索文字列内の空白文字のシーケンスそれぞれにたいして、ユーザーオプション@code{search-whitespace-regexp}で指定されている正規表現をマッチします。このオプションのデフォルトには、スペースとタブのシーケンスすべてを空白とみなす値がセットされています。したがって@w{@samp{foo
bar}}は@w{@samp{foo bar}}、@w{@samp{foo@ @ bar}}、@w{@samp{foo@ @ @
bar}}、...にマッチします(@samp{foobar}にはマッチしない)。スペースやタブと同じように一連の改行をスペースとしてマッチさせるには、このオプションの値を正規表現@samp{[[:space:]\\n]+}をカスタマイズしてください(インクリメンタルなregexp検索のデフォルトの振る舞いは異なる。@ref{Regexp
Search}を参照)。

  空白文字を正確にマッチさせたい場合は、インクリメンタル検索中に@kbd{M-s @key{SPC}}
(@code{isearch-toggle-lax-whitespace})とタイプすることにより、lax space
matchingをオフに切り替えることができます。もう1度@kbd{M-s @key{SPC}}とタイプすると、lax space
matchingふぁオンに切り替わります。すべての検索でlax space
matchingを無効にするには、@code{search-whitespace-regexp}を@code{nil}に変更します。これにより検索文字列の中のスペースは、正確に1つのスペースにマッチするようになります。

@cindex case folding in search
@cindex case-sensitivity and search
  Emacsでの検索では、検索文字列を小文字で指定した場合、デフォルトでは検索するテキストの大文字小文字は区別されません。したがって@samp{foo}を検索すると、@samp{Foo}や@samp{fOO}もマッチします。regexp、特に文字集合でも同様に振る舞います。つまり@samp{[ab]}は、@samp{a}、@samp{A}、@samp{b}、@samp{B}もマッチします。この機能は@dfn{case
folding}として知られており、これはインクリメンタル検索と非インクリメンタル検索の両方でサポートされています。

@vindex search-upper-case
  検索文字列のどこかに大文字があると、検索はcase-sensitive(大文字小文字を区別する)になります。したがって@samp{Foo}を検索すると、@samp{foo}や@samp{FOO}は検索されません。これは正規表現検索でもリテラル文字列検索と同様に適用されます。検索文字列から大文字を削除すると、効果はなくなります。変数@code{search-upper-case}がこれを制御します。この変数が非@code{nil}の場合、検索文字列の中の大文字は検索をcase-sensitiveにします。これを@code{nil}にセットすることにより、大文字によるこの効果は無効になります。この変数のデフォルト値は検索文字列中に大文字があれば検索をcase-sensitiveにして、検索文字列にyankするテキスト(@ref{Isearch
Yank}を参照)を小文字にする(そうすればデフォルトで検索がcase-insensitiveになる)@code{not-yanks}です。

@vindex case-fold-search
  変数@code{case-fold-search}に@code{nil}をセットすると、すべての文字は大文字小文字を含めて、完全にマッチしなければなりません。これはバッファーごとの変数で、変数の変更はデフォルト値を変えない限り、通常はカレントバッファーだけが影響を受けます。@ref{Locals}を参照してください。これは置換コマンド(@ref{Replace}を参照してください)や、ミニバッファーのヒストリー検索(@ref{Minibuffer
History}を参照してください)を処理する、非インクリメンタル検索にも適用されます。

@kindex M-c @r{(Incremental search)}
@kindex M-s c @r{(Incremental search)}
@findex isearch-toggle-case-fold
  インクリメンタル検索で@kbd{M-c}、または@kbd{M-s c}
(@code{isearch-toggle-case-fold})とタイプすると、検索が大文字小文字を区別するかが、切り替わります。この効果は、現在の検索を超えて引き継がれませんが、カレントの検索にたいして大文字を追加・削除したときの効果をオーバーライドします.

  特定のコマンドや操作にたいする検索やマッチングにおいて、大文字小文字の区別を制御する変数がいくつかあります。たとえば@code{tags-case-fold-search}は、@code{find-tag}での大文字小文字の区別を制御します。これらの変数を探すには、@kbd{M-x
apropos-variable @key{RET} case-fold-search @key{RET}}とタイプしてください。

@cindex character folding in search
@cindex equivalent character sequences
  case foldingでは、文字の大文字小文字の違いを無視するので、大文字は小文字にマッチし、その逆もマッチします。case
foldingを一般化したものが@dfn{character
folding}で、これは類似した文字間の違いの、より広いクラスを無視します。たとえばcharacter
foldingでは、文字@code{a}は@code{@"a}や@code{@'a}のようなアクセント付きの類似文字にもマッチし、これらの変種を区別するための特殊記号も無視します。加えて@code{a}は、@code{a}に似ている他の文字、それにU+00AA
@sc{feminine ordinal indicator} (訳注:
スペイン語などで女性形の序数を表すために数字の後に加えられる上付きの小さな@code{a})やU+24D0 @sc{circled latin
small letter a}
(丸で囲まれた小さい@code{a}のような外観)のように文字のグラフィカルな外観の一部に@code{a}をもつ文字にもマッチします。同様に@acronym{ASCII}のダブルクォート文字@code{"}は、ダブルクォートの変種としてUnicode標準で定義されている、他のすべての変種にマッチします。最後に、character
foldingにより、1つ以上の文字シーケンスは違う長さの他の文字にもマッチするようになります。たとえば2つの文字@code{ff}は@sc{U+FB00
latin small ligature ff}、@code{(a)}というシーケンスはU+249C @sc{parenthesized latin
small letter a}にマッチします。文字シーケンスはまったく同じではありませんが、character
foldingでのマッチは@dfn{equivalent character sequences(等価文字シーケンス)}として知られています。

@kindex M-s ' @r{(Incremental Search)}
@findex isearch-toggle-char-fold
  一般的にEmacsの検索コマンドは、デフォルトでは等価な文字シーケンスのマッチのためにcharacter
foldingを行ないません。変数@code{search-default-mode}を@code{char-fold-to-regexp}にカスタマイズすることにより、この振る舞いを有効にできます。@ref{Search
Customizations}を参照してください。インクリメンタル検索では、@kbd{M-s '}
(@code{isearch-toggle-char-fold})とタイプすることによりcharacter
foldingが切り替わりますが、これはその検索だけです(置換コマンドは別のオプションによる異なるデフォルトをもちます。@ref{Replacement
and Lax Matches}を参照してください)。

@vindex char-fold-symmetric
  デフォルトでは@code{@"a}のような文字の明示的な変種を検索文字列の一部としてタイプしても、それは@code{a}のようなベース文字とはマッチしません。しかし変数@code{char-fold-symmetric}を@code{t}にカスタマイズすれば、検索コマンドは等価な文字を同一に扱い、検索文字列内での等価な文字集合の使用により、検索するテキスト内の等価な文字を検索するので、アクセントつきの文字@code{@"a}は文字@code{a}と同じように@code{@'a}のようなすべての変種にもマッチします。

@vindex char-fold-include
@vindex char-fold-exclude
@vindex char-fold-override
  カスタマイズ可能な変数@code{char-fold-include}を使用して新たなfoldingを追加したり、カスタマイズ可能な変数@code{char-fold-exclude}を使用して既存のfoldingを削除できます。@code{char-fold-override}を@code{t}にカスタマイズすれば、@code{char-fold-include}を用いて追加したもの以外の等価文字すべてを無効にすることができます。

@node Replace
@section 置換コマンド
@cindex replacement
@cindex search-and-replace commands
@cindex string substitution
@cindex global substitution

  Emacsは検索と置換を行うコマンドをいくつか提供します。単純な@kbd{M-x
replace-string}コマンドに加えて、出現する検索パターンごとに置換するかを問い合わせる@kbd{M-%}
(@code{query-replace})も提供します。

  置換コマンドは通常、ポイント位置からバッファーの最後までのテキストにたいして処理を行います。リージョンがアクティブのときは、リージョンにたいして処理を行います(@ref{Mark}を参照してください)。基本的な置換コマンドは1つの@dfn{検索文字列}(またはregexp)を、1つの@dfn{置換文字列}で置き換えます。コマンド@code{expand-region-abbrevs}を使用して、複数の置換を並行して処理することが可能です(@ref{Expanding
Abbrevs}を参照してください)。

@menu
* Unconditional Replace::    文字列にマッチするすべて置換する。
* Regexp Replace::           regexpにマッチするすべてを置換する。
* Replacement and Lax Matches::  置換するテキストにたいするlax検索。
* Query Replace::            問い合わせの使い方。
@end menu

@node Unconditional Replace
@subsection 無条件の置換
@findex replace-string

@table @kbd
@item M-x replace-string @key{RET} @var{string} @key{RET} @var{newstring} @key{RET}
すべての@var{string}を@var{newstring}で置換します。
@end table

  ポイントの後にある@samp{foo}のすべてのインスタンスを@samp{bar}に置換するには、コマンド@kbd{M-x
replace-string}に2つの引数@samp{foo}と@samp{bar}を指定します。置換はポイントの後だけで発生するので、バッファー全体を置換したい場合は、最初にバッファーの先頭に移動しなければなりません。バッファーの最後までのすべてが置換されます。置換をバッファーの一部に制限したいときは、そのリージョン部分をアクティブにします。リージョンがアクティブのときは、置換はそのリージョンに制限されます(@ref{Mark}を参照してください)。

  @code{replace-string}が終了したとき、ポイントは最後に置換された位置に留まります。以前のポイント位置(@code{replace-string}コマンドを実行した場所)はマークリングに追加されるので(マークは非アクティブ)、@kbd{C-u
C-@key{SPC}}で戻ることができます。@ref{Mark Ring}を参照してください。

  プレフィクス引数を指定すると、置換対象は単語単位に制限されます。

  置換コマンドでのcase-sensitivity(大文字小文字の区別)とcharacter foldingについては、@ref{Replacement
and Lax Matches}を参照してください。

@node Regexp Replace
@subsection 正規表現の置換
@findex replace-regexp

  @kbd{M-x replace-string}コマンドは、正確にマッチする単一の文字列を置換します。同様なコマンド@kbd{M-x
replace-regexp}は、指定した正規表現パターン(@ref{Regexps}を参照してください)にマッチするすべてを置換します。

@table @kbd
@item M-x replace-regexp @key{RET} @var{regexp} @key{RET} @var{newstring} @key{RET}
@var{regexp}にマッチするすべてを@var{newstring}で置換します。
@end table

@cindex back reference, in regexp replacement
  @code{replace-regexp}では、@var{newstring}が定数である必要はありません。@var{regexp}にマッチした全体、または部分を参照することができます。@var{newstring}での@samp{\&}は、置換されるマッチ全体を表します。@var{newstring}での@samp{\@var{d}}(@var{d}は1から始まる数字)は、@var{regexp}内でカッコでグループ化されたものの、@var{d}番目にマッチします(これは``後方参照(back
reference)と呼ばれます'')。@samp{\#}は、このコマンドですでに置換された件数を10進数で参照します。最初の置換では@samp{\#}は@samp{0}で、2番目の置換では@samp{1}、...のようになります。たとえば、

@example
M-x replace-regexp @key{RET} c[ad]+r @key{RET} \&-safe @key{RET}
@end example

@noindent
これは@samp{cadr}を@samp{cadr-safe}に、@samp{cddr}を@samp{cddr-safe}に置き換えます。

@example
M-x replace-regexp @key{RET} \(c[ad]+r\)-safe @key{RET} \1 @key{RET}
@end example

@noindent
これは逆向きの置換をします。置換するテキストに@samp{\}を含めるときは、@samp{\\}と入力しなければなりません。

  置換する文字列の一部を毎回手入力したいときは、置換文字列で@samp{\?}を使用します。すると置換ごとにミニバッファーで置換文字列を編集できます(ポイント位置は@samp{\?}を記述した場所です。)

  このサブセクションの残りの部分は、Lispの知識が必要となる特別な処理を念頭に書かれています。大半の読者はスキップしても構いません。

  置換文字列の一部を計算するために、Lisp式を使うことができます。これを行うには、置換文字列の中で、@samp{\,}に続けてLisp式を記述します。各置換において式の値が計算され、それをクォートされていない文字列に変換します(もし文字列の場合は、その文字列の内容が使われることを意味します)。そしてそれを置換文字列内で、式が記述された場所に使用します。もし式がシンボルのときは、シンボル名と、置換文字列中のシンボル名の後にあるの間に1つスペースは、両方シンボルの値に置換されます。

  このような式の中では、いくつかの特別なシーケンスを使うことができます。式の中での@samp{\&}や@samp{\@var{d}}は、通常のようにマッチした文字列全体と、部分マッチした文字列を参照します。@var{d}には複数桁の数字を記述でき、カッコでグループ化された@var{d}番目の正規表現がマッチしなかったとき、@samp{\@var{d}}は@code{nil}になります。@samp{\#&}と@samp{\#@var{d}}を使って、それらのマッチを数字で参照することもできます(これはマッチまたは部分マッチが数字書式の場合に有効です)。ここでの@samp{\#}も、すでに置換された数を意味します。

  たとえば@samp{x}と@samp{y}の入れ替えは、以下の方法で行うことができます:

@example
M-x replace-regexp @key{RET} \(x\)\|y @key{RET}
\,(if \1 "y" "x") @key{RET}
@end example

  @samp{\,}により置換する文字列を計算するには、@code{format}関数が便利なときがあります(@ref{Formatting
Strings,,, elisp, The Emacs Lisp Reference
Manual}を参照してください)。たとえば73列目@w{から80列目}(もしそこに何もなければ)に、@samp{ABC00042}のような連番を振りたいときは、以下を使うことができます。

@example
M-x replace-regexp @key{RET} ^.\@{0,72\@}$ @key{RET}
\,(format "%-72sABC%05d" \& \#) @key{RET}
@end example

@node Replacement and Lax Matches
@subsection 置換コマンドとLaxマッチ

  このサブセクションではlaxマッチに関する置換コマンドの振る舞いと、それをカスタマイズする方法を説明します。一般的には、ほとんどの置換は、それと同等な検索コマンドに比べて、デフォルトではより厳密なマッチを行ないます。

@cindex lax space matching in replace commands
@vindex replace-lax-whitespace
  インクリメンタル検索とは異なり、置換コマンドはデフォルトではlax space matching(緩いスペースマッチング)を行いません(@ref{Lax
Search, lax space matching}を参照してください)。置換でlax space
matchingを有効にするには、変数@code{replace-lax-whitespace}を非@code{nil}に変更してください(これはEmacsが置換文字列ではなく、置換するテキストを検索する方法だけに影響を与えます)。

@vindex replace-regexp-lax-whitespace
  @code{query-replace-regexp}がパターンを検索するときlax whitespace
matchingを使うかどうかを制御するのは、それに対応する変数@code{replace-regexp-lax-whitespace}です。

@cindex case folding in replace commands
  置換コマンドの最初の引数がすべて小文字の場合、置換のための検索において大文字小文字の違いを無視します。これは@code{case-fold-search}と@code{search-upper-case}がいずれも非@code{nil}の場合です。@code{search-upper-case}
(@ref{Lax Search,
search-upper-case}を参照)が@code{nil}なら、検索が大文字小文字を無視するかどうかは、コマンドの1つ目の引数が小文字かどうかと無関係に@code{case-fold-search}単独で決定されます。@code{case-fold-search}を@code{nil}にセットすると、すべての検索において常に大文字小文字の違いが有効になります。

@vindex case-replace
@cindex case preservation in replace commands
  さらに置換コマンドの2つ目の引数のすべて、または一部が小文字の場合には、置換コマンドは大文字小文字が出現するパターンを維持しようと試みます。したがって以下のコマンド、

@example
M-x replace-string @key{RET} foo @key{RET} bar @key{RET}
@end example

@noindent
は小文字の@samp{foo}を小文字の@samp{bar}で置換し、すべて大文字の@samp{FOO}を@samp{BAR}、そして最初が大文字の@samp{Foo}を@samp{Bar}に置換します。(これら3つの候補、すなわち小文字、すべて大文字、先頭が大文字は、@code{replace-string}が認識できる唯一のパターンです)。Emacsは置換されるテキストの単語それぞれを解析することによって、大文字あるいは先頭を大文字のどちらでテキストを置換するか判断すること、そしてcase(大文字小文字)が保たれるのは置換されるテキストの@emph{すべて}の単語が同じcaseの場合だけであることに注意してください。

@example
M-x replace-string @key{RET} foo bar @key{RET} baz quux @key{RET}
@end example

@noindent
@samp{Foo Bar}はどちらも先頭が大文字なので、@samp{Foo Bar}が@samp{Baz
Quux}に置換されます。これとは対照的に同じコマンドなのに@samp{Foo bar}は@samp{baz
quux}に置換されます(置換するテキストのあせは未変更のまま)。これは@samp{Foo
bar}という2つの単語で異なるcapitalize(先頭だけ大文字化)が用いられているからです。正確には何をもって``単語(word)''とみなさすのかは、カレントバッファーで効力をもつ構文テーブル次第です(@ref{Syntax
Tables,,, elisp, The Emacs Lisp Reference
Manual}を参照)。すなわちTextモードでは@samp{Foo_Bar}は2つの単語ですが、プログラミング言語をサポートするメジャーモードでは1つの単語かもしれません。

  置換文字列に大文字が使われている場合、テキストが挿入されるときは、常に大文字のままとなります。大文字が最初の引数で使用されている場合、大文字小文字の変換なしで、2番目の引数に与えられたとおりに置換されます。同様に@code{case-replace}と@code{case-fold-search}の両方が@code{nil}にセットされている場合、大文字小文字の変換なしで置換されます。

@cindex character folding in replace commands
  デフォルトでは置換コマンドは、置換するテキストを探すとき、character folding(@ref{Lax Search, character
folding}を参照してください)を使用しません。@code{query-replace}と@code{replace-string}でのマッチングでcharacter
foldingを有効にするには、変数@code{replace-char-fold}に非@code{nil}値をセットします(このセッティングは、Emacsが置換するテキストを探す方法だけに影響し、置換するテキストには影響を与えません。また、@code{replace-regexp}にも影響を与えません)。

@node Query Replace
@subsection 問い合わせつき置換
@cindex query replace

@table @kbd
@item M-% @var{string} @key{RET} @var{newstring} @key{RET}
任意の@var{string}を@var{newstring}で置換します。
@item C-M-% @var{regexp} @key{RET} @var{newstring} @key{RET}
@var{regexp}にたいする任意のマッチを@var{newstring}で置換します。
@end table

@kindex M-%
@findex query-replace
  @samp{foo}を@samp{bar}に置換するとき、すべてではなく、そのうちのいくつかだけを置換したいときは、@kbd{M-%}
(@code{query-replace})を使います。このコマンドは@samp{foo}を1つずつ検索して、それを置換するかを毎回尋ねます。この問い合わせを別とすれば、@code{query-replace}は@code{replace-string}と同様に機能します(@ref{Unconditional
Replace}を参照)。特に@code{case-replace}が非@code{nil}のときは、通常のように大文字小文字を区別します(@ref{Replacement
and Lax Matches}を参照)。数引数を指定すると、単語区切り文字で区切られた単語だけを考慮します。負のプレフィクス引数は後方に置換します。

@kindex C-M-%
@findex query-replace-regexp
  @kbd{C-M-%}
(@code{query-replace-regexp})は、regexpの検索と置換を行います。これは@code{query-replace}のように問い合わせを行う以外は、@code{replace-regexp}と同様に機能します。

@vindex query-replace-from-to-separator
  これらのコマンドで行なった以前の置換を再利用できます。@code{query-replace}や@code{query-replace-regexp}が検索文字列の入力を求めるプロンプトを表示しているとき、@kbd{M-p}と@kbd{M-n}を使用することにより、@samp{@var{from}
->
@var{to}}という形式で、以前の置換を表示できます。ここで@var{from}は検索パターン、@var{to}はそれの置換、これらの間に表示されるセパレータは変数@code{query-replace-from-to-separator}の値により決定されます。望む置換が表示されたら、@key{RET}とタイプしてそれを選択します。この変数の値が@code{nil}の場合、置換はコマンドヒストリーに追加されず、再利用できません。

@cindex faces for highlighting query replace
@cindex @code{query-replace} face
@cindex @code{lazy-highlight} face, in replace
@vindex query-replace-highlight
@vindex query-replace-highlight-submatches
@vindex query-replace-lazy-highlight
@vindex query-replace-show-replacement
  これらのコマンドは、カレントのマッチを、フェイス@code{query-replace}を使ってハイライトします。変数@code{query-replace-highlight}を@code{nil}にセットすることにより、このハイライトを無効にできます。他のマッチのハイライトにはインクリメンタル検索(@ref{Incremental
Search}を参照してください)と同様に、フェイス@code{lazy-highlight}が使われます。変数@code{query-replace-lazy-highlight}を@code{nil}にセットすることにより、このハイライトを無効にできます。デフォルトでは@code{query-replace-regexp}は、カレントマッチを置換する展開後の文字列を、ミニバッファーに表示します。特別なシーケンス@samp{\&}および@samp{\@var{n}}を展開せずに維持するには、@code{query-replace-show-replacement}変数をカスタマイズしてください。インクリメンタル検索中に@code{search-highlight-submatches}が副式(subexpression)をハイライトするように(@ref{Search
Customizations}を参照)、変数@code{query-replace-highlight-submatches}はregexpの置換コマンド中で副式をハイライトするかどうかを定義します。

@vindex query-replace-skip-read-only
  変数@code{query-replace-skip-read-only}に非@code{nil}がセットされている場合、置換コマンドはread-only(読み取り専用)のテキスト内のマッチを無視します。デフォルトでは、それらを無視しません。

  以下は文字列またはregexpにたいするマッチが表示されているときにタイプできる文字です:

@ignore @c Not worth it.
@kindex SPC @r{(query-replace)}
@kindex DEL @r{(query-replace)}
@kindex , @r{(query-replace)}
@kindex RET @r{(query-replace)}
@kindex . @r{(query-replace)}
@kindex ! @r{(query-replace)}
@kindex ^ @r{(query-replace)}
@kindex C-r @r{(query-replace)}
@kindex C-w @r{(query-replace)}
@kindex C-l @r{(query-replace)}
@end ignore

@c WideCommands
@table @kbd
@item @key{SPC}
@itemx y
マッチを@var{newstring}で置き換えます。

@item @key{DEL}
@itemx @key{Delete}
@itemx @key{BACKSPACE}
@itemx n
カレントマッチを置換せずに次のマッチへスキップします。

@item , @r{(カンマ)}
カレントマッチを置換して、結果を表示します。そして次に何をするかを文字入力するよう促します。置換がすでに行われているので、この状況では@key{DEL}と@key{SPC}は等価で、どちらも次のマッチへ移動します。

ここで@kbd{C-r}(以下を参照)をタイプして、置換されたテキストを編集できます。
@code{undo}コマンド(@kbd{C-x
u}とタイプする。@ref{Undo}を参照されたい)で置換をアンドゥすることもできます。置換を取り消すこともできます。これは@code{query-replace}を終了させるので、さらに置換を行う場合は、@kbd{C-x
@key{ESC} @key{ESC} @key{RET}}で置換を再開しなければなりません(@ref{Repetition}を参照)。

@item @key{RET}
@itemx q
これ以上の置換を行わずに終了します。

@item .@: @r{(ピリオド)}
カレントマッチを置換してから、これ以上の検索を行わずに終了します。

@item !
これ以上の問い合わせをせずに、残りのマッチをすべて置換します。

@item ^
前のマッチの位置に戻ります。これは間違えて変更したときや、再検証したい場合に使います。

@item u
最後の置換をアンドゥ(undo: 取り消し)して、その置換が行われた位置に戻ります。

@item U
すべての置換をアンドゥして、最初の置換が行われた位置に戻ります。

@item C-r
再帰編集レベル(recursive editing
level)に入ります。これはマッチを@var{newstring}で置換するだけでなく、編集したい場合に使用します。編集を終えたら@kbd{C-M-c}で再帰編集レベルを抜けて、次のマッチを処理します。@ref{Recursive
Edit}を参照してください。

@item C-w
マッチを削除してから、@kbd{C-r}と同様に再帰編集レベルに入ります。これは@var{string}を削除してから、テキストを挿入することにより置換を行う場合に使用します。編集を終えたら@kbd{C-M-c}で再帰編集レベルを抜けて、次のマッチを処理します。

@item e
置換文字列をミニバッファーで編集します。@key{RET}でミニバッファーを抜けると、カレントマッチをミニバッファーの内容で置換します。この新しい置換文字列は、残りのマッチにたいしても適用されます。

@item E
これは@kbd{e}と似ていますが、次の置換をcase(大文字小文字)に厳格に行います。つまり@samp{foo}から@samp{bar}に@code{query-replace}していたら、@samp{Foo}のようなテキストは通常は@samp{Bar}に置き換えられます。カレントの置換をcaseに厳格に行うには、このコマンドを使用してください。

@item C-l
スクリーンを再描画します。その後でカレントマッチにたいして何を行うか、別の文字をタイプして指定しなければなりません。

@item Y @r{(大文字)}
複数バッファーの置換で、残りのバッファーの、残りのマッチをすべて置換します(これは選択したファイルにたいして問い合わせつきの置換を行う、Diredの@kbd{Q}コマンドと似ています)。これはすべての一連の問い合わせにたいして、これ以上のユーザーとの対話なしに``yes''を答えます。

@item N @r{(大文字)}
複数バッファーの置換で、カレントバッファーの残りのマッチを置換せずに、次のバッファーへスキップします。これはカレントバッファーのマッチにたいする問い合わせに``no''を答えて、次のバッファーへと処理を続けます。

@item C-h
@itemx ?
@itemx @key{F1}
上述したオプションの要約を表示します。その後でカレントマッチにたいして何を行うか、別の文字をタイプして指定しなければなりません。
@end table

  これらのエイリアス文字以外の文字は、@code{query-replace}を終了してから、キーシーケンスの残りの部分を読みとります。したがって@kbd{C-k}とタイプすると、@code{query-replace}を終了してから、行末までをkillします。特に、@kbd{C-g}は単に@code{query-replace}をexitします。

  一度終了した@code{query-replace}を再開するには、@kbd{C-x @key{ESC}
@key{ESC}}を使います。@code{query-replace}は引数の読み取りにミニバッファーを使っているので、このキーシーケンスで再開させることができます。@ref{Repetition,
C-x @key{ESC} @key{ESC}}を参照してください。

@cindex invisible text, and query-replace
  オプション@code{search-invisible}は、@code{query-replace}が非表示のテキストを扱う方法を決定します。@ref{Outline
Search}を参照してください。

  選択されたファイルにたいして問い合わせつきの置換を行う、Diredの@kbd{Q}コマンドについては、@ref{Operating on
Files}を参照してください。regexpにマッチするファイル名にたいして、ファイル名の変更、ファイルのコピー、ファイルのリンクを行うDiredのコマンドについては、@ref{Transforming
File Names}を参照してください。

@node Other Repeating Search
@section その他の検索およびループコマンド

  ここでは正規表現にたいするマッチを検索する、その他のコマンドを説明します。これらのコマンドは、パターンに大文字が含まれていないか、@code{case-fold-search}が非@code{nil}のときは、マッチングで大文字小文字を区別しません。常にバッファー全体を検索する@code{multi-occur}と@code{multi-occur-in-matching-buffers}をのぞき、これらのコマンドはすべてポイント位置からバッファーの最後まで、リージョンがアクティブなときはそのリージョンにたいして処理を行います。

@table @kbd
@findex multi-isearch-buffers
@cindex isearch multiple buffers
@cindex multiple-buffer isearch
@item M-x multi-isearch-buffers
１つ以上のバッファー名の入力を求め(@key{RET}で終了)、それらのバッファーにたいして複数バッファーのインクリメンタル検索を開始します(あるバッファーでの検索に失敗すると、次の@kbd{C-s}により、指定された次のバッファーへと検索を試みます)。プレフィクス引数を指定すると、regexpの入力を求め、regexpにマッチするバッファーにたいして、複数バッファーでのインクリメンタル検索を開始します。

@findex multi-isearch-buffers-regexp
@item M-x multi-isearch-buffers-regexp
このコマンドは@code{multi-isearch-buffers}と同様ですが、インクリメンタルなregexp検索を行います。

@findex multi-isearch-files
@cindex isearch multiple files
@cindex multiple-file isearch
@item M-x multi-isearch-files
１つ以上のファイル名の入力を求め(@key{RET}で終了)、それらのファイルにたいして複数ファイルのインクリメンタル検索を開始します(あるファイルで検索に失敗すると、次の@kbd{C-s}により、指定された次のファイルへと検索を試みます)。プレフィクス引数を指定すると、regexpの入力を求め、regexpにマッチするファイルにたいして、複数ファイルでのインクリメンタル検索を開始します。

@findex multi-isearch-files-regexp
@item M-x multi-isearch-files-regexp
このコマンドは@code{multi-isearch-files}と同様ですが、インクリメンタルなregexp検索を行います。

バッファーローカルな変数@code{multi-isearch-next-buffer-function}をセットするいくつかのモード(たとえばChange
Logモード)では、複数ファイルにたいするインクリメンタル検索は自動的にアクティブになります。

@cindex Occur mode
@cindex mode, Occur
@cindex match (face name)
@vindex list-matching-lines-default-context-lines
@vindex list-matching-lines-jump-to-current-line
@c Too long.
@c @cindex list-matching-lines-current-line-face (face name)
@kindex M-s o
@findex occur
@item M-x occur
@itemx M-s o
regexpの入力を求め、それへのマッチを含むバッファー内の各行をリスト表示します。プロンプトで@kbd{M-n}をタイプした場合は、前のインクリメンタル検索から検索文字列を再利用できます。マッチするテキストは、@code{match}フェイスを使用してハイライトされます。数引数@var{n}を指定すると、そのコンテキストでマッチした各行の、前後@var{n}行を表示します。

コンテキスト行のデフォルト行数は、変数@code{list-matching-lines-default-context-lines}により指定されます。@code{list-matching-lines-jump-to-current-line}が非@code{nil}のとき、カレント行はフェイス@code{list-matching-lines-current-line-face}でハイライト表示され、ポイントはその行の最初のマッチの後にセットされます。

インクリメンタル検索がアクティブのときは@kbd{M-s o}を実行して、カレントのサーチリングを使うこともできます。

あなたがタイプしたregexpにたいするマッチは完全な行を含むように拡張され、1つ前のマッチの終了の前から開始するマッチは考慮されないことに注意してください。

@kindex RET @r{(Occur mode)}
@kindex o @r{(Occur mode)}
@kindex C-o @r{(Occur mode)}
@file{*Occur*}バッファーはメジャーモードとしてOccurモードを使用します。次または前のマッチに移動するために@kbd{n}および@kbd{p}のキーを使うことができます。プレフィックス数引数を指定した場合には、その個数分のマッチを移動します。数字キーは@code{digit-argument}にバインドされているので、@kbd{5
n}なら次の5番目のマッチに移動します(@kbd{C-u}のタイプは不要)。@key{SPC}および@key{DEL}はそれぞれ@file{*Occur*}バッファーを上または下へとスクロールします。マッチをクリックするかそこにポイントを移動して@key{RET}をタイプすれば、検索した元バッファーの対応する位置をvisitします。@kbd{o}および@kbd{C-o}はマッチを別ウィンドウに表示しますが、@kbd{C-o}はソンウィンドウを選択しません。マッチを1つずつvisitするために、かわりに@kbd{M-g
M-n} (@code{next-error})を使用できます(@ref{Compilation
Mode}を参照)。最後に@kbd{q}は@file{*Occur*}バッファーを表示しているウィンドウをquitするとともに、そのバッファーをバリーします。

@cindex Occur Edit mode
@cindex mode, Occur Edit
@file{*Occur*}バッファーで@kbd{e}をタイプすることにより、バッファーを編集可能にするとともにOccur
Editモードに切り替えます。このモードではマッチした行を編集することができ、更に編集結果は元のバッファーのテキストに適用されます。@kbd{C-c
C-c}とタイプすることにOccur Editモードを抜けてOccurモードに戻ります。

@findex list-matching-lines
コマンド@kbd{M-x list-matching-lines}は、@kbd{M-x occur}の別名です。

@findex multi-occur
@item M-x multi-occur
このコマンドは@code{occur}と同じですが、複数のバッファーを検索する点が異なります。このコマンドは、1つずつバッファー名の入力を求めます。

@findex multi-occur-in-matching-buffers
@item M-x multi-occur-in-matching-buffers
このコマンドは@code{multi-occur}と似ていますが、visitしているファイル名にマッチする正規表現を指定することにより、検索するバッファーを指定する点が異なります。プレフィクス引数を指定すると、正規表現にマッチするバッファー名となります。

@findex how-many
@item M-x how-many
regexpの入力を求め、バッファーのポイント位置以降に、何個のマッチがあるか表示します。リージョンがアクティブのときは、リージョンにたいして操作を行います。

@findex flush-lines
@item M-x flush-lines
regexpの入力を求めて、ポイントの後のテキストでマッチを含む各行を削除します。コマンドの終了時には削除したマッチ行の行数をプリントします。

カレント行のポイント以降にマッチする文字列が含まれているときはカレント行を削除します。リージョンがアクティブのときはリージョンにたいして操作を行います。行の一部ににリージョンが含まれていて、さらにマッチの全体がリージョンに含まれているときには行は削除されます。

マッチが行をまたいでいる場合、@code{flush-lines}はそれらの行すべてを削除します。このコマンドは行を削除してから、次のマッチを検索します。したがって、1行にマッチ全体と、次の行にまたがるマッチが両方含まれるとき、次の行にまたがるマッチは無視されます。

@findex keep-lines
@item M-x keep-lines
regexpの入力を求め、ポイント以降にあるテキストにたいして、マッチを@emph{含まない}行を削除します。ポイントが行の先頭でない場合、このコマンドは常にカレント行を維持します。リージョンがアクティブのときは、リージョンにたいして操作を行います。このコマンドは一部がリージョンに含まれるだけの行は削除しません(行を終端する改行は、その行の一部と判断します)。

マッチが行をまたぐ場合、このコマンドはそれらすべての行を維持します。

@findex kill-matching-lines
@item M-x kill-matching-lines
@code{flush-lines}と同様ですがマッチした行はkillリングへも追加されます。このコマンドは行区切りの改行を含めて、マッチした行を単一の文字列としてkillリングに追加します。

@findex copy-matching-lines
@item M-x copy-matching-lines
@code{kill-matching-lines}と同様ですが、マッチした行をバッファーから削除しません。
@end table

@node Search Customizations
@section 必要に応じて検索を調整する
@cindex search customizations

  このセクションでは、他では説明されていない、その他の検索に関連した機能を説明します。

@cindex default search mode
@cindex search mode, default
  インクリメンタル検索にたいするデフォルトの検索モードは、変数@code{search-default-mode}により指定されます。この変数には、@code{nil}、@code{t}、または関数を指定できます。@code{nil}の場合、デフォルトのモードはcharacter
foldingなしのリテラル検索です。しかし、case
foldingにたいしては@code{case-fold-search}、lax-whitespace
matchにたいしては@code{search-whitespace-regexp}により決定されます(@ref{Lax
Search}を参照してください)。値が@code{t}の場合、インクリメンタル検索のデフォルトはregexp検索になります。デフォルト値には、case
foldingとlax-whitespace matchingだけを行なう関数が指定されています。

@vindex search-highlight
  継続的なインクリメンタル検索でのカレントマッチは、@code{isearch}フェイスでハイライトされます。変数@code{search-highlight}を@code{nil}にセットすることにより、このハイライトを無効にできます。

@vindex search-highlight-submatches
  (たとえば@kbd{C-M-s}による)正規表現の検索時には、@code{search-highlight-submatches}変数に応じて部分式は特別にハイライトされます。この変数の値が@code{nil}なら特別なハイライトは行われませんが、値が非@code{nil}なら正規表現内の@samp{\(
@dots{}
\)}構文にマッチするテキスト(いわゆる``部分式'')は異なるフェイスでハイライトされます。デフォルトでは@code{isearch-group-1}および@code{isearch-group-2}という名前の2つの異なるフェイスが定義されています。これら2つのフェイスでは奇数番目の部分式は@code{isearch-group-1}フェイス、偶数番目の部分式は@code{isearch-group-2}フェイスを使用してハイライトされます。たとえば@samp{foo-\([0-9]+\)\([a-z]+\)}の検索時には@samp{[0-9]+}がマッチする部分が@code{isearch-group-1}フェイス、@samp{[a-z]+}がマッチする部分は@code{isearch-group-2}フェイスを使用してハイライトされます。@code{isearch-group-3}、@code{isearch-group-4}、@dots{}のようにこの同じ番号付けスキームを使用してフェイスを追加定義する場合には@var{M}、@code{@var{N}+@var{M}}、@code{2@var{N}+@var{M}}、@dots{}番目の部分式のハイライトにフェイス@code{isearch-group-@var{M}}が使用されます。ここで@var{N}は@code{isearch-group-@var{M}}形式のフェイス総数です。

@cindex lazy highlighting customizations
@vindex isearch-lazy-highlight
@cindex @code{lazy-highlight} face
  ディスプレイに表示されている、検索文字列にたいするその他のマッチは、@code{lazy-highlight}フェイスを使用してハイライトされます。変数@code{isearch-lazy-highlight}をセットして、このハイライトを無効にできます。以下はlazy-highlightをカスタマイズする、その他の変数です:

@table @code
@item lazy-highlight-initial-delay
@vindex lazy-highlight-initial-delay
可視なマッチをハイライトする前に待機する秒数です。検索文字列が@code{lazy-highlight-no-delay-length}文字より短い場合のみ適用されます。

@item lazy-highlight-no-delay-length
@vindex lazy-highlight-no-delay-length
検索文字列の長さが少なくともこの変数の値であれば、マッチの遅延ハイライトは即座に開始されます。

@item lazy-highlight-interval
@vindex lazy-highlight-interval
マッチをハイライトする秒数です。

@item lazy-highlight-max-at-a-time
@vindex lazy-highlight-max-at-a-time
入力をチェックする前にハイライトする、マッチの最大数です。大きな数を指定するとハイライトに時間を要するかもしれず、その間に検索を継続するために@kbd{C-s}や@kbd{C-r}をタイプしても、それらすべてのマッチのハイライトを終了するまで、Emacsは反応しないでしょう。したがって小さな数を指定することにより、Emacsの反応を改善できます。

@item isearch-lazy-count
@vindex isearch-lazy-count
検索プロンプトにカレントマッチ数とマッチ総数を表示します。

@item lazy-count-prefix-format
@itemx lazy-count-suffix-format
@vindex lazy-count-prefix-format
@vindex lazy-count-suffix-format
これらの2つの変数は@code{isearch-lazy-count}の表示にたいするカレントマッチ数とマッチ総数のフォーマットを決定します。
@end table

@vindex search-nonincremental-instead
  インクリメンタル検索で検索文字列が空のときに@key{RET}を入力すると、通常これは非インクリメンタル検索を開始します(実際には、これにより検索文字列の編集が開始され、次の@key{RET}で検索を行ないます)。しかし、変数@code{search-nonincremental-instead}を@code{nil}にセットした場合、検索文字列が空でも、@key{RET}のタイプは常にインクリメンタル検索をexitします。

@vindex isearch-hide-immediately
  デフォルトではインクリメンタル検索および問い合わせ付き置換コマンドは不可視のテキストにもマッチしますが、そのようなマッチは隠され、不可視のテキストの外にできるだけ早くカレントマッチを移動させます。変数@code{isearch-hide-immediately}を@code{nil}にカスタマイズした場合、マッチが見つかった任意の不可視テキストは、検索または置換コマンドがexitするまで表示され続けます。

@cindex search display on slow terminals
@vindex search-slow-speed
@vindex search-slow-window-lines
  遅い回線で接続されたリモートマシンのディスプレイなど、遅い端末でインクリメンタルな検索をすると、検索によりディスプレイの大きな範囲を再描画しなければならないことが、煩わしくなるかもしれません。Emacsは、遅い端末にたいして特別なディスプレイモードを提供します。これは検索が別の小さなウィンドウをポップアップして、マッチの周辺テキストをそのウィンドウに表示します。小さいウィンドウは早く表示できるので、遅いスピードの影響による煩わしさは軽減されます。変数@code{search-slow-speed}は、Emacsがこのディスプレイモードを使用する、ボーレートの下限値を決定します。変数@code{search-slow-window-lines}は、Emacsがポップアップして検索結果を表示するウィンドウの行数を制御します(デフォルトは1)。このウィンドウは通常、検索を開始したバッファーを表示するウィンドウの下部にポップアップされますが、@code{search-slow-window-lines}の値が負の場合、ウィンドウは上部に配され、@code{search-slow-window-lines}の絶対値が表示される行数になります。
