@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================

@c This is part of the Emacs manual.
@c Copyright (C) 1985--2024 Free Software Foundation, Inc.
@c See file emacs-ja.texi for copying conditions.
@iftex
@chapter その他のコマンド

  このチャプターには、他のどこにも適さないような、複数のトピックについての概略が含まれています。それらには以下のものが含まれます:
Usenetニュースの購読、ホストとネットワークのセキュリティー、PDFおよび類似のドキュメントの閲覧、ウェブのブラウジング、シェルコマンドおよびシェルサブプロセスの実行、エディターをサブプロセスとして実行するユーティリティーとして1つの共有Emacsを使用する、印刷、テキストのソート、バイナリーファイルの編集、後で再開するためにEmacsセッションを保存する、再帰編集レベル、ハイパーリンクをフォローする、およびさまざまな気晴らしと娯楽、などです。

@end iftex

@ifnottex
@raisesections
@end ifnottex

@node Gnus
@section GnusによるEメールとUsenetニュース
@cindex Gnus
@cindex Usenet news
@cindex newsreader

  Gnusは、主にUsenetニュースを読んだりポストするためにデザインされた、Emacsパッケージです。これはいくつかの異なるソース ---
電子メール、リモートディレクトリー、ダイジェスト、などを読んだり、メッセージを返すためにも使うことができます。以下はGnusの紹介と、いくつかの基本的な機能の説明です。
@ifnottex
完全な詳細に付いては、@ref{Top, Gnus,, gnus, The Gnus Manual}を参照してください。
@end ifnottex
@iftex
Gnusについての完全な詳細は、@kbd{C-h i}とタイプしてから、Gnus manualを選択してください。
@end iftex

@menu
* Buffers of Gnus::          グループ、サマリー、アーティクルバッファー。
* Gnus Startup::             Gnusの開始するにあたって知っておくべきこと。
* Gnus Group Buffer::        Gnusグループコマンドの短い説明。
* Gnus Summary Buffer::      Gnusサマリーコマンドの短い説明。
@end menu

@node Buffers of Gnus
@subsection Gnusバッファー

  Gnusは、情報を表示したり返信コマンドのために、複数のバッファーを使用します。もっとも一般的に使用される3つのGnusバッファーは@dfn{グループバッファー(group
buffer)}、@dfn{サマリーバッファー(summary buffer)}、@dfn{アーティクルバッファー(article
buffer)}です。

  @dfn{グループバッファー}は、アーティクルソースのリスト(たとえばニュースグループや電子メールのinbox)を含んでおり、それらは@dfn{グループ}として参照されます。これはGnusを開始したときに最初に表示されるバッファーです。これは通常、あなたが登録したグループと、未読のアーティクルだけを表示します。このバッファーから、読みたいグループを選択できます。

  @dfn{サマリーバッファー}は1つのグループのアーティクルをリストし、1行に1つのアーティクルを表示します。デフォルトでは、アーティクルの作者、subject、
@iftex
行数が表示されます。
@end iftex
@ifnottex
行数が表示されますが、これはカスタマイズできます。@ref{Summary Buffer Format,,, gnus, The Gnus
Manual}を参照してください。
@end ifnottex
サマリーバッファーは、グループバッファーでグループを選択すると作成され、グループを抜けるとkillされます。

  サマリーバッファーから、閲覧するアーティクルを選択できます。アーティクルは@dfn{アーティクルバッファー}で表示されます。通常のGnusの使い方では、このバッファーを閲覧はしますが選択はしません
---
すべての便利なGnusコマンドはサマリーバッファーから呼び出すことができます。しかし望むなら、アーティクルバッファーを選択して、そこからGnusコマンドを実行することもできます。

@node Gnus Startup
@subsection Gnusを起動したとき

@findex gnus
@cindex @file{.newsrc} file
  あなたのシステムがUsenetニュースをよむためにセットアップされていれば、Gnusを始めるのは簡単です --- @kbd{M-x
gnus}とタイプするだけです。

  起動時に、Gnusはホームディレクトリーにある@file{.newsrc}という名前の@dfn{ニュース初期化ファイル(news
initialization
file)}を読み込みます。これにはあなたのUsenetニュースグループと購読状況がリストされています(これはGnus固有のファイルではありません。他の多くのニュースリーダープログラムにより使用されています)。その後システムのデフォルトのニュースサーバーへの接続を試みます。これは通常、環境変数@env{NNTPSERVER}により指定されます。

  あなたのシステムがデフォルトのニュースサーバーをもっていない場合、または電子メールを読むためにGnusを使いたい場合は、@kbd{M-x
gnus}を呼び出す前に、どこでニュースおよび/またはメールを取得するか、Gnusに指示する必要があります。これを行なうには、変数@code{gnus-select-method}および/または@code{gnus-secondary-select-methods}をカスタマイズします。
@iftex
詳細は、Gnusのマニュアルを参照してください。
@end iftex
@ifnottex
@ref{Finding the News,,, gnus, The Gnus Manual}を参照してください。
@end ifnottex

  1度Gnusを開始すると、グループバッファーを表示します。デフォルトでは少数の@dfn{subscribedグループ(subscribed
groups: 登録されたグループ)}だけが表示されます。他の状態 ---
@dfn{unsubscribed}、@dfn{killed}、@dfn{zombie} ---
のグループは表示されません。最初にGnusを開始したとき、登録していないグループはkilledグループになります。その後にニュースサーバーに現れたグループはzombieグループになります。

  先に進むには、グループバッファーでグループを選択して、そのグループのサマリーバッファーを開かなければなりません。その後サマリーバッファーのアーティクルを選択して、別のウィンドウでアーティクルバッファーを閲覧します。以下のセクションでは、これを行なうための、グループバッファーとサマリーバッファーの使用について説明します。

  Gnusを終了するには、グループバッファーで@kbd{q}とタイプします。これは自動的にグループの状態をファイル@file{.newsrc}ト@file{.newsrc.eld}に記録するので、その後のGnusセッションでも効果があります。

@node Gnus Group Buffer
@subsection Gnus Groupバッファーの使用

  以下のコマンドは、Gnusグループバッファーで利用可能です:

@table @kbd
@kindex SPC @r{(Gnus Group mode)}
@findex gnus-group-read-group
@item @key{SPC}
カレント行のグループの、サマリーバッファーに切り替えます(@code{gnus-group-read-group})。

@kindex l @r{(Gnus Group mode)}
@kindex A s @r{(Gnus Group mode)}
@findex gnus-group-list-groups
@item l
@itemx A s
eグループバッファーでは、未読のアーティクルを含む登録したグループだけをリストします(@code{gnus-group-list-groups}。これはデフォルトの一覧方法である)。

@kindex L @r{(Gnus Group mode)}
@kindex A u @r{(Gnus Group mode)}
@findex gnus-group-list-all-groups
@item L
@itemx A u
すべてのsubscribed(登録)およびunsubscribed(未登録)のグループをリストしますが、killedまたはzombieのグループは表示しません(@code{gnus-group-list-all-groups})。

@kindex A k @r{(Gnus Group mode)}
@findex gnus-group-list-killed
@item A k
killされたグループをリストします(@code{gnus-group-list-killed})。

@kindex A z @r{(Gnus Group mode)}
@findex gnus-group-list-zombies
@item A z
ゾンビ状態のグループをリストします(@code{gnus-group-list-zombies})。

@kindex u @r{(Gnus Group mode)}
@findex gnus-group-toggle-subscription-at-point
@cindex subscribe groups
@cindex unsubscribe groups
@item u
グループの登録状態を切り替えます(@code{gnus-group-toggle-subscription-at-point})。killedまたはzombieのグループにたいしてこれを呼び出すと、そのグループをunsubscribedグループにします。

@kindex C-k @r{(Gnus Group mode)}
@findex gnus-group-kill-group
@item C-k
カレント行のグループをkillします(@code{gnus-group-kill-group})。killedとなったグループは@file{.newsrc}ファイルに記録され、@kbd{l}または@kbd{L}のリストには表示されなくなります。

@kindex DEL @r{(Gnus Group mode)}
@item @key{DEL}
未読アーティクルを含む、前のグループにポイントを移動します(@code{gnus-group-prev-unread-group})。

@kindex n @r{(Gnus Group mode)}
@findex gnus-group-next-unread-group
@item n
次の未読グループにポイントを移動します(@code{gnus-group-next-unread-group})。

@kindex p @r{(Gnus Group mode)}
@findex gnus-group-prev-unread-group
@item p
前の未読グループにポイントを移動します(@code{gnus-group-prev-unread-group})。

@kindex q @r{(Gnus Group mode)}
@findex gnus-group-exit
@item q
Gnusのセッティングを更新してGnusを終了します(@code{gnus-group-exit})。
@end table

@node Gnus Summary Buffer
@subsection Gnus Summaryバッファーの使用

  以下のコマンドは、Gnusサマリーバッファーで利用可能です:

@table @kbd
@kindex SPC @r{(Gnus Summary mode)}
@findex gnus-summary-next-page
@item @key{SPC}
選択されたアーティクルがない場合、カレント行のアーティクルを選択して、それをアーティクルバッファーに表示します。そうでない場合、選択されたアーティクルバッファーのウィンドウでスクロールを試みます。バッファーの最後に到達した場合、次の未読アーティクルを選択します(@code{gnus-summary-next-page})。

したがって、繰り返し@key{SPC}をタイプすることにより、すべてのアーティクルを読むことができます。

@kindex DEL @r{(Gnus Summary mode)}
@findex gnus-summary-prev-page
@item @key{DEL}
アーティクルのテキストを後方にスクロールします(@code{gnus-summary-prev-page})。

@kindex n @r{(Gnus Summary mode)}
@findex gnus-summary-next-unread-article
@item n
次の未読アーティクルを選択します(@code{gnus-summary-next-unread-article})。

@kindex p @r{(Gnus Summary mode)}
@findex gnus-summary-prev-unread-article
@item p
前の未読アーティクルを選択します(@code{gnus-summary-prev-unread-article})。

@kindex s @r{(Gnus Summary mode)}
@findex gnus-summary-isearch-article
@item s
選択されたアーティクルバッファーで、あたかもそのバッファーに切り替えて@kbd{C-s}(@ref{Incremental
Search}を参照してください)とタイプしたかのように、インクリメンタル検索を行ないます(@code{gnus-summary-isearch-article})。

@kindex M-s M-s @r{(Gnus Summary mode)}
@findex gnus-summary-search-article-forward
@item M-s M-s @var{regexp} @key{RET}
@var{regexp}へのマッチを含むアーティクルを、前方に検索します(@code{gnus-summary-search-article-forward})。

@kindex M-s M-r @r{(Gnus Summary mode)}
@findex gnus-summary-search-article-backward
@item M-r @var{regexp} @key{RET}
@var{regexp}へのマッチを含むアーティクルを、後方に検索します(@code{gnus-summary-search-article-backward})。

@kindex q @r{(Gnus Summary mode)}
@item q
サマリーバッファーをexitして、グループバッファーに戻ります(@code{gnus-summary-exit})。
@end table

@node Host Security
@section ホストのセキュリティ
@cindex security

EmacsはGNU/Linuxのようなオペレーティングシステムの内部で実行され、ファイルアクセスのようなセキュリティー制限のチェックはオペレーティングシステムに依存します。Emacsのデフォルトセッティングは、通常の使用のためにデザインされています。通常よりセキュリティーが重要な場合、または重要でない環境では、何らかの調整が必要になるでしょう。たとえばファイルローカル変数(file-local
variables)が危険な場合もあるので、変数@code{enable-local-variables}に@code{:safe}や、(より安全に)@code{nil}をセットできます。ファイルがすべて信用でき、それらの変数にたいするデフォルトのチェックが煩わしいときには、@code{enable-local-variables}に@code{:all}をセットできます。@ref{Safe
File Variables}を参照してください。

大きなアプリケーションの一部としてEmacsを使用する場合の、セキュリティー考慮についての情報は、@ref{Security
Considerations,,, elisp, The Emacs Lisp Reference Manual}を参照してください。

@node Network Security
@section ネットワークのセキュリティ
@cindex network security manager
@cindex NSM
@cindex encryption
@cindex SSL
@cindex TLS
@cindex Transport Layer Security
@cindex STARTTLS

Emacsがネットワーク接続を確立するときは、常にその確立された接続を@acronym{NSM}(@dfn{Network Security
Manager})に渡します。@acronym{NSM}は、あなたのコントロールのもとにセットワークセキュリティーを実施する責任があります。現在のところ、これは@acronym{TLS}(Transport
Layer Security)の機能を使用して動作します。

@vindex network-security-level
変数@code{network-security-level}は@acronym{NSM}が実施するセキュリティーレベルを決定します。変数の値が@code{low}ならセキュリティーのチェックは行なわれません。これは必須ではなく。基本的にはそのネットワーク接続が信頼できないことを意味しています。しかしネットワークの問題テスト時のように制限された状況ではこのセッティングは便利かもしれません。

この変数が@code{medium}(デフォルト)の場合、いくつかのチェックが行なわれます。チェックの結果、@acronym{NSM}がそのネットワーク接続を信頼できないと判断した場合は、それを知らせて、そのネットワーク接続にたいして何を行なうか尋ねます。

証明されていない接続(unverified connection)にたいして、永続的なセキュリティー例外(security
exception)を登録したり、一時的な例外(temporary exception)とするか、接続を完全に拒絶することができます。

@vindex network-security-protocol-checks
証明書の基本的な正当性チェック加えて、いくつかの@acronym{TLS}アルゴリズムによるチェックが利用可能です。
以前は安全だと思われていたいくつかの暗号化技術で脆弱性が判明しているものについては、(デフォルトでは)Emacsは問題に関して警告します。

プロトコルネットワークのチェックは@code{network-security-protocol-checks}変数を介して制御されます。

これは各連想値の最初の要素がチェックの名前、2つ目の要素がチェックの使用を要するセキュリティレベルであるようなalistです。

関数@code{nsm-protocol-check--rc4}の結果内の@code{(rc4
medium)}のような要素は@w{@code{(nsm-protocol-check--rc4 host port status
settings)}}のように呼び出します。この関数は接続を継続するなら非@code{nil}、それ以外は非@code{nil}をリターンします。

以下はデフォルトの@code{medium}で行なわれるチェックのリストです。

@table @asis

@item @acronym{TLS}認証が検証できない(unable to verify a @acronym{TLS} certificate)
その接続が@acronym{TLS}、@acronym{SSL}、@acronym{STARTTLS}接続の場合、@acronym{NSM}は接続しようとしているサーバーの同一性(identity)を証明するために使用される認証が、検証できるかどうかチェックします。

無効な認証が懸念される場合(Man-in-the-Middleによりネットワーク接続がハイジャックて、あなたのパスワードが盗まれるかもしれません)や、とにかく接続を行なう正当な理由があるかもしれません。たとえばサーバーが自己署名された認証(self-signed
certificate)を使用していたり、認証の期限が切れている場合もあるでしょう。接続の継続を容認するかどうかの決定は、あなたに任されています。

@item 自己署名された認証が変更されている(a self-signed certificate has changed)
以前自己署名された認証を許容したが、今回はそれが変更されていて、それはそのサーバーが単に認証を変更しただけかもしれませんが、ネットワーク接続がハイジャックされている可能性もあります。

@item 以前は暗号化されていた接続が、暗号化されていない(previously encrypted connection now unencrypted)
接続が暗号化されていないが、以前のセッションでは暗号化されていた場合、あなたとそのサーバーの間に@acronym{STARTTLS}アナウンス(@acronym{STARTTLS}
announcements)を剥奪して、接続を非暗号化するプロキシーがあることを意味するかもしれません。これは通常とても疑わしいです。

@item パスワードを送信するとき暗号化されていないサービスと通信する(talking to an unencrypted service when sending a password)
@acronym{IMAP}や@acronym{POP3}のサーバーに接続するとき、ネットワーク越しにパスワードを送信するのが一般的なので、接続は通常暗号化されています。同様に、パスワードを要求する@acronym{SMTP}を通じてemailを送信する場合は通常、その接続が暗号化されていることを望むでしょう。その接続が暗号化されていない場合、@acronym{NSM}は警告します。

@item Diffie-Hellmanロープライムビット(Diffie-Hellman low prime bits)
パグリックキーの交換を行なう際、そのチャンネルが第三者により盗聴できないことを確実にするために、プライムビット(prime
bits)の数は十分に高くあるべきです。この数があまりに低い(low)場合にはEmacsは警告を発するでしょう(これは@code{network-security-protocol-checks}の@code{diffie-hellman-prime-bits}チェック)。

@item @acronym{RC4}ストリーム暗号(@acronym{RC4} stream cipher)
@acronym{RC4}ストリーム暗号は低品質とされており、第三者による盗聴を許すかもしれません(これは@code{network-security-protocol-checks}の@code{rc4}チェック)。

@item ホスト証明書や中間証明書の@acronym{SHA1}
中間証明書(intermediate
certificate)が@acronym{SHA1}ハッシュアルゴリズムを使用していれば、第三者がその発行インスタンスを偽装して証明書を発行できると考えられています。したがってこれらの接続は中間者攻撃にたいして脆弱です(これらは@code{network-security-protocol-checks}の@code{signature-sha1}と@code{intermediate-sha1}チェック)。

@item @acronym{SSL1}、@acronym{SSL2}、@acronym{SSL3}
@acronym{TLS1.0}より古いプロトコルは、様々な攻撃にたいして脆弱とされており、あなたが行なうことがより高いセキュリティーを要する場合は、使用を避けたいと思うかもしれません(これは@code{network-security-protocol-checks}の@code{ssl}チェック)。

@end table

@code{network-security-level}が@code{high}の場合、上記に加えて以下のチェックが行なわれます:

@table @asis
@item @acronym{3DES}暗号
@acronym{3DES}ストリーム暗号は最大112ビットの効果的なセキュリティーを提供してローエンド向きと考えられています(これは@code{network-security-protocol-checks}の@code{3des}チェック)。

@item 有効な認証がパブリックキーを変更した(a validated certificate changes the public key)
サーバーはキーを変更するときがあり、通常それは心配することはありません。しかし、サードパーティーのサービスにたいして新しい認証を発行する、偽装しやすい証明期間(pliable
Certificate
Authorities)へのアクセスをもつエージェントにより、ネットワーク接続がハイジャックされているか心配なときは、これらの変更を追跡したいと思うかもしれません。

@end table

最後に、@code{network-security-level}が@code{paranoid}の場合は、最初に@acronym{NSM}が新たな認証に遭遇したときに、それが通知されます。これによりEmacsによるすべての接続のすべての認証を検証することができるでしょう。

以下の追加の変数は、@acronym{NSM}操作の詳細を制御するために使用できます。

@table @code
@item nsm-settings-file
@vindex nsm-settings-file
これは@acronym{NSM}が接続の詳細を保存するファイルです。デフォルトは@file{~/.emacs.d/network-security.data}です。

@item nsm-save-host-names
@vindex nsm-save-host-names
デフォルトでは、非@code{STARTTLS}接続ではホスト名は保存されません。接続の識別には、かわりにホストとポートによるハッシュ値(host/port
hash)が使用されます。ユーザーがどのサーバーに接続しているか確認するために、誰かが気軽に設定ファイルを読めないことを意味します。この変数が@code{t}の場合、@acronym{NSM}は@code{nsm-settings-file}にもホスト名を保存します。

@end table


@node Document View
@section ドキュメントの閲覧
@cindex DVI file
@cindex PDF file
@cindex PS file
@cindex PostScript file
@cindex OpenDocument file
@cindex Microsoft Office file
@cindex EPUB file
@cindex CBZ file
@cindex FB2 file
@cindex XPS file
@cindex OXPS file
@cindex DocView mode
@cindex mode, DocView
@cindex document viewer (DocView)
@findex doc-view-mode

  DocViewモードは、DVI、PostScript(PS)、PDF、OpenDocument、Microsoft
Office、EPUB、CBZ、FB2、XPS、OXPSといったドキュメントを閲覧するためのメジャーモードです。このモードはスライス、ズーム、ドキュメント内の検索などの機能を提供します。これは、@command{gs}
(GhostScript)、@command{pdfdraw}/@command{mutool draw}
(MuPDF)といったコマンド、およびその他の外部ツールを使用してドキュメントを一連のイメージに変換、それらのイメージを表示することにより機能します。

@findex doc-view-toggle-display
@findex doc-view-minor-mode
  DocViewモードで表示可能なドキュメントをvisitすると、Emacsは自動的にそのモードを使用します@footnote{そのドキュメントに必要な外部ツールが利用可能でなければならず、Emacsがグラフィカルなフレームで実行されていて、PNGイメージをサポートしなければなりません。これらの条件が満たされなければ、Emacsは他のメジャーモードにフォールバックします。}。例外として、PostScriptファイルをvisitしたとき、EmacsはPostScriptファイルをテキストとして編集するためのメジャーモードの、PSモードに切り替わります。しかし、これはDocView
minorモードも有効にするので、@kbd{C-c
C-c}とタイプして、そのドキュメントを閲覧することができます。DocViewモードまたはDocView minorモードでは、@kbd{C-c
C-c}
(@code{doc-view-toggle-display})を繰り返すことにより、DocViewとその背後にあるファイル内容を切り替えることができます。

@findex doc-view-open-text
  いくつかの要件が満たされないとき(たとえばテキスト端末のフレームを操作していたり、そのEmacsはPNGをサポートしないときなど)に、通常DocViewモードで処理されるファイルをvisitした場合は、そのドキュメントの内容をプレーンテキストとして閲覧したいか問い合わせます。これに同意すると、そのバッファーはtextモードとなり、DocView
minorモードがアクティブになります。したがって@kbd{C-c
C-c}とタイプすることにより、fallbackモードに切り替わります。もう1度@kbd{C-c
C-c}とタイプすると、DocViewモードに戻ります。DocViewモードで@kbd{C-c C-t}
(@code{doc-view-open-text})とタイプすることにより、プレーンテキストで内容を表示することもできます。

  コマンド@kbd{M-x doc-view-mode}で、DocViewモードを明示的に有効にすることができます。また、@kbd{M-x
doc-view-minor-mode}で、DocView minorモードに切り替えることができます。

  DocViewモードを開始したときは、ウェルカム画面を表示して、そのファイルを1ページずつフォーマットしていきます。最初のページがフォーマットされると、そのページを表示します。

  DocViewバッファーをkillするには、@kbd{k}
(@code{doc-view-kill-proc-and-buffer})とタイプします。バッファーを隠す(bury)には、@kbd{q}
(@code{quit-window})とタイプします。

@menu
* Navigation: DocView Navigation.  DocViewバッファーの操作。
* Searching: DocView Searching.  ドキュメント内の検索。
* Slicing: DocView Slicing.  ページのどの部分を表示するか指定する。
* Conversion: DocView Conversion.  変換に影響を与えたり、それを誘発するもの。
@end menu

@node DocView Navigation
@subsection DocViewの操作

  DocViewモードでは通常のEmacs移動キー、つまり@kbd{C-p}、@kbd{C-n}、@kbd{C-b}、@kbd{C-f}、および矢印キーを使って、ページをスクロールできます。

@vindex doc-view-continuous
  デフォルトでは、行移動キーの@kbd{C-p}と@kbd{C-n}は、カレントページの先頭または最後でスクロールを止めます。しかし、変数@code{doc-view-continuous}を非@code{nil}値に変更した場合、カレントページの先頭で@kbd{C-p}とタイプすると前のページを表示し、カレントページの最後で@kbd{C-n}とタイプすると次のページを表示します。

@findex doc-view-next-page
@findex doc-view-previous-page
@kindex n @r{(DocView mode)}
@kindex p @r{(DocView mode)}
@kindex PageDown @r{(DocView mode)}
@kindex PageUp @r{(DocView mode)}
@kindex next @r{(DocView mode)}
@kindex prior @r{(DocView mode)}
@kindex C-x ] @r{(DocView mode)}
@kindex C-x [ @r{(DocView mode)}
  @kbd{n}、@key{PageDown}、@key{next}、@kbd{C-x
]}をタイプすることにより、次のページを表示することもできます(@code{doc-view-next-page})。前のページを表示するには、@kbd{p}、@key{PageUp}、@key{prior}、@kbd{C-x
[}をタイプします(@code{doc-view-previous-page})。

@findex doc-view-scroll-up-or-next-page
@findex doc-view-scroll-down-or-previous-page
@kindex SPC @r{(DocView mode)}
@kindex DEL @r{(DocView mode)}
  @key{SPC}
(@code{doc-view-scroll-up-or-next-page})は、ドキュメントを順に読んでいくのに便利な方法です。これはカレントページをスクロールするか、次のページに移動します。@key{DEL}
(@code{doc-view-scroll-down-or-previous-page})は、同様の方法で後方に移動します。

@findex doc-view-first-page
@findex doc-view-last-page
@findex doc-view-goto-page
@kindex M-< @r{(DocView mode)}
@kindex M-> @r{(DocView mode)}
  最初のページに移動するには、@kbd{M-<}
(@code{doc-view-first-page})とタイプします。最後のページに移動するには、@kbd{M->}
(@code{doc-view-last-page})とタイプします。ページ番号を指定して移動するには、@kbd{M-g M-g}または@kbd{M-g
g} (@code{doc-view-goto-page})とタイプしてください。

@findex doc-view-enlarge
@findex doc-view-shrink
@vindex doc-view-resolution
@vindex doc-view-scale-internally
@kindex + @r{(DocView mode)}
@kindex - @r{(DocView mode)}
  @kbd{+} (@code{doc-view-enlarge})と@kbd{-}
(@code{doc-view-shrink})で、ドキュメントを拡大したり縮小することができます。これらのコマンドはデフォルトではすでに描画済みのイメージを再スケールします。かわりにイメージを新たなサイズに再描画するには@code{doc-view-scale-internally}を@code{nil}にセットしてください。DocViewにたいするデフォルトサイズを指定するには、変数@code{doc-view-resolution}をカスタマイズしてください。

@vindex doc-view-imenu-enabled
@vindex doc-view-imenu-flatten
@vindex doc-view-imenu-format
  DocViewは@code{imenu}機能(@ref{Imenu}を参照)を通じてアクセスできるように、@command{mutool}プログラムが利用可能な場合にはそれを使ってoutlineメニュー用のエントリーを生成します。システムに@command{mutool}が存在する場合であってもこの機能を無効にしたい場合には、変数@code{doc-view-imenu-enabled}を@code{nil}値にカスタマイズしてください。@code{doc-view-imenu-format}や@code{doc-view-flatten}といった変数を使えば、@code{imenu}がアイテムをどのようにフォーマット、表示するかを更にカスタマイズすることができます。

@node DocView Searching
@subsection DocViewの検索

  DocViewモードでは、ファイルのテキストにたいして正規表現の検索を行なうことができます(@ref{Regexps}を参照してください)。検索のインターフェースは@code{isearch}が元になっています(@ref{Incremental
Search}を参照してください)。

@findex doc-view-search
@findex doc-view-search-backward
@findex doc-view-show-tooltip
  検索を開始するには、@kbd{C-s} (@code{doc-view-search})または@kbd{C-r}
(@code{doc-view-search-backward})とタイプします。これはミニバッファーを使用して正規表現を読み取り、そのドキュメントでマッチした数をエコーします。@kbd{C-s}または@kbd{C-r}とタイプすることにより、マッチ間を前方または後方に移動できます。DocViewモードはページイメージの中でマッチを表示できません。かわりに、カレントページのマッチするすべての行を一覧するツールチップを、(マウス位置に)表示します。このツールチップを強制的に表示するには@kbd{C-t}
(@code{doc-view-show-tooltip})とタイプしてください。

  新しい検索を開始するには、たとえば前方検索では@kbd{C-u C-s}、後方検索では@kbd{C-u
C-r}のように、検索コマンドにプレフィクス引数を使用します。

@node DocView Slicing
@subsection DocViewのスライス

印刷のために広い余白をもつドキュメントもあります。これらはスクリーンでドキュメントを読むとき邪魔になることがあります。なぜならこれらは画面スペースを消費して、スクロールが不便になるからです。

@findex doc-view-set-slice
@findex doc-view-set-slice-using-mouse
  DocViewでは、表示するページの@dfn{スライス(slice)}を選択することにより、これらの余白を隠すことができます。スライスはページ内の矩形領域です。DocViewで1度スライスを指定すると、閲覧するすべてのページに適用されます。

@c ??? how does this work?
  数値でスライスを指定するには、@kbd{c s}
(@code{doc-view-set-slice})とタイプします。その後、スライスの左上のピクセル位置(pixel
position)と、スライスの幅(width)と高さ(height)を入力します。

  スライスを指定するための、もっと便利でグラフィカルな方法は、@kbd{c m}
(@code{doc-view-set-slice-using-mouse})で、スライスの選択にマウスを使う方法です。これは単に、スライスにしたいリージョンの左上隅で左マウスボタンを押して、そのまま右下隅にマウスポインターを移動してマウスボタンを離します。

  最適なスライスをセットする一番簡単な方法は、@kbd{c b}
(@code{doc-view-set-slice-from-bounding-box})とタイプすることにより、そのドキュメントから自動的に判断されるBoundingBox情報を使う方法です。

@findex doc-view-reset-slice
  選択されたスライスを取り消すには、@kbd{c r}
(@code{doc-view-reset-slice})とタイプします。するとDocViewは、余白全体を含めたページ全体を表示します。

@node DocView Conversion
@subsection DocViewの変換

@vindex doc-view-cache-directory
@findex doc-view-clear-cache
  効率のために、DocViewは@command{gs}により生成されたイメージをキャッシュします。イメージをキャッシュするディレクトリーの名前は、変数@code{doc-view-cache-directory}により与えられます。@kbd{M-x
doc-view-clear-cache}とタイプすることにより、キャッシュディレクトリーをクリアーできます。

@findex doc-view-kill-proc
@findex doc-view-kill-proc-and-buffer
  現在閲覧中のドキュメントを強制的に再変換するには、type @kbd{r}または@kbd{g}
(@code{revert-buffer})とタイプします。カレントバッファーに関連付けられた変換プロセスをkillするには、@kbd{K}
(@code{doc-view-kill-proc})とタイプします。コマンド@kbd{k}
(@code{doc-view-kill-proc-and-buffer})は、変換プロセスとDocViewバッファーをkillします。

@node Shell
@section Emacsからのシェルコマンドの実行
@cindex subshell
@cindex shell commands

  Emacsには、シェルサブプロセスに1つのコマンドラインを渡したり、入出力にEmacsバッファーを使用して対話的にシェルを実行するコマンドや、端末エミュレーターウィンドウでシェルを実行するコマンドがあります。

@table @kbd
@item M-! @var{cmd} @key{RET}
シェルコマンド@var{cmd}を実行して、出力を表示します(@code{shell-command})。
@item M-| @var{cmd} @key{RET}
リージョンの内容を入力としてシェルコマンド@var{cmd}を実行します。オプションでリージョンを出力で置き換えます(@code{shell-command-on-region})。
@item M-& @var{cmd} @key{RET}
シェルコマンド@var{cmd}を非同期で実行し、出力を表示します(@code{async-shell-command})。
@item M-x shell
Emacsバッファーを通じて入出力を行なう、サブシェルを実行します。その後で、コマンドを対話的に与えることができます。
@item M-x term
Emacsバッファーを通じて入出力を行なう、サブシェルを実行します。その後でコマンドを対話的に与えることができます。完全な端末エミュレーションが利用できます。
@end table

@vindex exec-path
  (上記のコマンドの@var{cmd}引数、または他のコンテキストにおいて)実行可能プログラムとして相対ファイル名を指定したときは、Emacsは変数@code{exec-path}により指定されるディレクトリーのプログラムを検索します。この変数の値は、ディレクトリーのリストでなければなりません。デフォルト値は、Emacsが開始されたときの環境変数@env{PATH}により初期化されます(@ref{General
Variables}を参照してください)。

  @kbd{M-x
eshell}は、Emacsで完全に実装されたシェルを呼び出します。eshellについては、自身のマニュアルにドキュメントされています。
@ifnottex
@ref{Top,Eshell,Eshell, eshell, Eshell: The Emacs Shell}を参照してください。
@end ifnottex
@iftex
Emacsと共に配布される、Eshell Infoマニュアルを参照してください。
@end iftex

@menu
* Single Shell::             シェルコマンドを実行してから、戻る方法。
* Interactive Shell::        Emacsを通じて入力を行なう永続的なシェル。
* Shell Mode::               永続的なシェルで使用される特別なEmacsコマンド。
* Shell Prompts::            シェルプロンプトを認識する2つの方法。
* History: Shell History.    シェルバッファーで前のコマンドを繰り返す。
* Directory Tracking::       サブシェルでのディレクトリーの変更の追跡。
* Options: Shell Options.    Shellモードをカスタマイズするオプション。
* Terminal emulator::        端末エミュレーターとしてのEmacsウィンドウ。
* Term Mode::                Termモードで使用される特別なEmacsコマンド。
* Remote Host::              他のコンピューターへの接続。
* Serial Terminal::          シリアルポートへの接続。
@end menu

@node Single Shell
@subsection 単一のシェルコマンド

@kindex M-!
@findex shell-command
@vindex shell-command-buffer-name
  @kbd{M-!}
(@code{shell-command})は、ミニバッファーを使って1行のテキストを読み取り、それをシェルコマンドとして、そのコマンドのためだけに作成されたサブシェルで実行します。そのコマンドの標準入力はnullデバイスです。シェルコマンドが出力を生成する場合、その出力はエコーエリア(出力が短い場合)、または別ウィンドウに表示される@samp{"*Shell
Command Output*"}
(@code{shell-command-buffer-name})という名前のEmacsバッファー(出力が長い場合)に表示されます。変数@code{resize-mini-windows}と@code{max-mini-window-height}は、出力がエコーエリアにたいして長過ぎるとEmacsが判断した場合に、ウィンドウのサイズ変更を制御します(@ref{Minibuffer
Edit}を参照)。エコーエリアに何が表示されるかは、以下で説明する@code{shell-command-dont-erase-buffer}をカスタマイズすることによって影響を受けるかもしれないことに注意してください。

  たとえば@file{foo.gz}という名前のファイルを解凍する1つの方法は、@kbd{M-! gunzip foo.gz
@key{RET}}とタイプすることです。このシェルコマンドは通常、ファイル@file{foo}を作成して、端末出力を生成しません。

  たとえば@kbd{M-1
M-!}のように@code{shell-command}に数引数を指定した場合、別のバッファーではなく、カレントバッファーに端末出力を挿入します。これはデフォルトではポイントを出力の前、出力の後にマークを配置します(しかし以下の非デフォルト値@code{shell-command-dont-erase-buffer}でこれを変更できます)。たとえば@kbd{M-1
M-! gunzip < foo.gz @key{RET}}は、カレントバッファーにファイル@file{foo.gz}の解凍された内容を挿入します。

  最後が@samp{&}でないシェルコマンドを指定した場合、コマンドは@dfn{同期(synchronously)}で実行され、Emacsを継続して使用するには、コマンドがexitするのを待たなければなりません。待つのを中止するには、@kbd{C-g}とタイプします。これはシェルコマンドを終了するために、シグナル@code{SIGINT}を送ります(これは通常、シェルで@kbd{C-c}とタイプしたときに生成されるのと同じシグナルです)。その後、Emacsはコマンドが実際に終了するまで待ちます。シェルコマンドが終了しない場合(そのコマンドがシグナル@code{SIGINT}を無視する場合)は、再度@kbd{C-g}とタイプします。これは　そのコマンドにたいして、無視することが不可能なシグナル@code{SIGKILL}を送ります。

@kindex M-&
@findex async-shell-command
@vindex shell-command-buffer-name-async
  @samp{&}で終わるシェルコマンドは@dfn{非同期(asynchronously)}で実行され、それを実行した後でも、継続してEmacsを使用できます。シェルコマンドを非同期で実行する前に、@kbd{M-&}
(@code{async-shell-command})とタイプすることもできます。これは最後の@samp{&}が必要ない点を除き、最後に@samp{&}を指定して@kbd{M-!}を呼び出すことと同じです。非同期シェルコマンドからの出力は、デフォルトでは@samp{"*Async
Shell Command*"}
(@code{shell-command-buffer-name-async})という名前のバッファーに送られます。このバッファーがウィンドウに表示されているかに関わらず、Emacsは出力をこのバッファーに挿入します。

@vindex async-shell-command-buffer
  同時に複数の非同期シェルコマンドを実行した場合、出力バッファーが競合します。この場合どのようにするか ---
たとえば既存の出力バッファーをリネームしたり、新しいコマンドに異なるバッファーを使用する ---
を、オプション@code{async-shell-command-buffer}で指定できます。他の可能なオプションについては、この変数のドキュメントを参照してください。

@vindex async-shell-command-display-buffer
  非同期シェルコマンドが出力を生成したときだけ出力バッファーが表示されるようにしたい場合は、@code{async-shell-command-display-buffer}を@code{nil}にセットしてください。

@vindex async-shell-command-width
  オプション@code{async-shell-command-width}は非同期シェルコマンドの出力に利用可能な表示列数を定義します。正の整数はコマンド出力にその列数を使用するようシェルに指示します。デフォルト値@code{nil}はシェルが提供する列数と同じ列数の使用を意味します。

@vindex shell-command-prompt-show-cwd
  上記コマンドにプロンプトにカレントディレクトリーを表示するようにさせるには変数@code{shell-command-prompt-show-cwd}を非@code{nil}値にカスタマイズしてください。

@kindex M-|
@findex shell-command-on-region
  @kbd{M-|}
(@code{shell-command-on-region})は@kbd{M-!}と同様ですが、入力を与えないかわりに、リージョンの内容をシェルコマンドの標準入力として渡します。数引数を指定した場合、古いリージョンの内容を、シェルコマンドの出力で置き換えます。

  たとえば@kbd{M-|}で@command{gpg}プログラムを使用して、そのバッファーのキーが何かを見ることができます。そのバッファーがGnuPGキーを含む場合、@kbd{C-x
h M-| gpg
@key{RET}}とタイプして、バッファー全体の内容を@command{gpg}に送ることができます。これはキーのリストを@code{shell-command-buffer-name}の値であるような名前のバッファーに出力します。

@vindex shell-file-name
@cindex @env{SHELL} environment variable
  上記のコマンドは、変数@code{shell-file-name}で指定されたシェルを使用します。この変数のデフォルト値は、Emacsが開始されたときの環境変数@env{SHELL}により決定されます。相対ファイル名の場合、Emacsは@code{exec-path}にリストされたディレクトリーを検索します(@ref{Shell}を参照してください)。

  デフォルトディレクトリーがリモート(@ref{Remote
Files}を参照)ならデフォルト値は@file{/bin/sh}です。これは接続ローカルに@code{shell-file-name}を宣言することにより変更可能です(@ref{Connection
Variables}を参照)。

  @kbd{M-!}または@kbd{M-|}にたいするコーディングシステムを指定するには、あらかじめコマンド@kbd{C-x @key{RET}
c}を使用します。@ref{Communication Coding}を参照してください。

@vindex shell-command-default-error-buffer
  デフォルトでは、出力バッファーではエラー出力と標準出力が混ざって出力されます。しかし変数@code{shell-command-default-error-buffer}の値を文字列に変更すると、エラー出力はその名前のバッファーに出力されます。

@vindex shell-command-dont-erase-buffer
  デフォルトではカレントバッファーに出力される場合を除き、シェルコマンド間に出力バッファーは消去されます。オプション@code{shell-command-dont-erase-buffer}の値を@code{erase}に変更すると出力バッファーは常に消去されます。それ以外の非@code{nil}値なら出力バッファーの消去は抑制されて、(出力バッファーがカレントバッファーでなければ)シェルコマンドの出力の挿入後にポイントを配置する位置を制御します:

@table @code
@item beg-last-out
ポイントを最後のシェルコマンドの出力の先頭に配置します。
@item end-last-out
ポイントを最後のシェルコマンドの出力の最後(出力バッファー終端)に配置します。
@item save-point
シェルコマンドの出力の挿入前の位置にポイントをリストアします。
@end table

このオプションが非@code{nil}の場合には出力バッファーの一部だけがエコーエリアに表示されるので、表示される出力は最後のコマンド以外の出力がエコーエリアに表示されるかもしれないことに注意してください。

出力バッファーがカレントバッファーでない場合には、そのバッファーの終端にシェルコマンドの出力が追加されます。

@node Interactive Shell
@subsection 対話的なサブシェル

@findex shell
  対話的にサブシェルを実行するには、@kbd{M-x
shell}とタイプします。これは@file{*shell*}という名前のバッファーを作成(または再使用)して、そのバッファーにたいして入出力を行なう、シェルのサブプロセスを実行します。つまりサブシェルからの端末出力はポイントの後に挿入されてポイントを進め、サブシェルにたいする端末入力はそのバッファーのテキストになります。サブシェルにたいして入力を与えるには、バッファーの最後に移動して入力をタイプし、@key{RET}で終了します。

  デフォルトでは、サブシェルが対話的に呼び出された際、カレントウィンドウですでに@file{*shell*}バッファーを表示していない場合は、新たなウィンドウに@file{*shell*}バッファーが表示されます。この動作は@code{display-buffer-alist}(@ref{Window
Choice}を参照)を通じてカスタマイズできます。

  サブシェルがコマンドの実行を待つ間、ウィンドウまたはバッファーを切り替えてEmacsで他の編集を行なうことができます。Emacsはそれを処理するときがきたら(たとえばキーボード入力待ちになったとき)、サブシェルからの出力をShellバッファーに挿入します。

@cindex @code{comint-highlight-input} face
@cindex @code{comint-highlight-prompt} face
  Shellバッファーでは、プロンプトはフェイス@code{comint-highlight-prompt}で表示され、サブミットされた入力行はフェイス@code{comint-highlight-input}で表示されます。これにより入力行とシェル出力を容易に区別することができます。@ref{Faces}を参照してください。

  複数のサブシェルを作成するには、(@kbd{C-u M-x shell})のように)プレフィクス引数を指定して@kbd{M-x
shell}を呼び出します。その後、このコマンドはバッファー名を読み取り、そのバッファーでサブシェルを作成(または再使用)します。@kbd{M-x
rename-uniquely}を使用して@file{*shell*}バッファーをリネームしてから、@kbd{M-x
shell}で新しい@file{*shell*}バッファーを作成することもできます。異なるバッファーのサブシェルは、並行して独立に実行されます。

  Emacsはあなたがエンターしたコマンドを調べて@samp{cd}といったコマンドを探すことによってカレントディレクトリーの追跡を試みます。カレントディレクトリーを変更する方法は多数存在するために、これはエラーの起きやすい解決手段です。したがってEmacsはこの情報をより信頼性の高い流儀で伝達するようデザインされた特別な@acronym{OSC}
(Operating System Commands:
オペレーティングシステムコマンド)のエスケープシーケンスも探します。たとえば以下のコマンドによって、シェルがそれぞれのプロンプトに適切なエスケープシーケンスをプリントするようアレンジする必要があります:

@example
printf "\e]7;file://%s%s\e\\" "$HOSTNAME" "$PWD"
@end example

@vindex explicit-shell-file-name
@cindex environment variables for subshells
@cindex @env{ESHELL} environment variable
  @kbd{M-x
shell}によりシェルファイル名を指定するには、変数@code{explicit-shell-file-name}をカスタマイズします。これが@code{nil}(デフォルト)の場合、もし存在すればEmacsは環境変数@env{ESHELL}を使用します。そうでない場合は通常、変数@code{shell-file-name}を使用します(@ref{Single
Shell}を参照してください)。しかしデフォルトディレクトリーがリモートの場合(@ref{Remote
Files}を参照してください)、シェルファイル名の入力を求めます。リモートファイル名を正しくタイプする方法に関するヒントは、@ref{Minibuffer
File}を参照してください。

  Emacsは新しいシェルにたいする入力として、もしそれが存在すればファイル@file{~/.emacs_@var{shellname}}の内容を送ります。ここで@var{shellname}は、そのシェルがロードされたファイルの名前です。たとえばbashを使う場合、送られるファイルは@file{~/.emacs_bash}になります。ファイルが見つからない場合、Emacsは@file{~/.emacs.d/init_@var{shellname}.sh}の使用を試みます。

  シェルにたいしてコーディングシステムを指定するには、@kbd{M-x shell}の直前にコマンド@kbd{C-x @key{RET}
c}を使用します。@kbd{C-x @key{RET}
p}とタイプすることにより、実行されているサブシェルにたいするコーディングシステムを変更することもできます。@ref{Communication
Coding}を参照してください。

@cindex @env{INSIDE_EMACS} environment variable
  サブシェルでは、Emacsは環境変数@env{INSIDE_EMACS}に@samp{@var{version},comint}をセットします。ここで@var{version}は、Emacsのバージョン(たとえば@samp{28.1})です。プログラムはこの変数をチェックして、Emacsの内部で実行されているかを判断することができます。

@node Shell Mode
@subsection Shellモード
@cindex Shell mode
@cindex mode, Shell

  ShellバッファーのためのメジャーモードはShellモードです。このモードの特別なコマンドは@kbd{C-c}プレフィクスにバインドされており、最初に@kbd{C-c}をタイプしなければならない点を除けば、通常のシェルでの編集やジョブ制御文字と共通点があります。以下はShellモードのコマンドのリストです:

@table @kbd
@item @key{RET}
@kindex RET @r{(Shell mode)}
@findex comint-send-input
サブシェルの入力にカレント行を送ります(@code{comint-send-input})。行頭のシェルプロンプトは省略されます(@ref{Shell
Prompts}を参照してください)。ポイントがバッファーの最後にある場合、これは通常の対話的なシェルにおいてコマンド行をサブミットするのに似ています。しかし、シェルバッファーの他の場所でも、@key{RET}を呼び出してカレント行を入力としてサブミットできます。

@item @key{TAB}
@kindex TAB @r{(Shell mode)}
@findex completion-at-point@r{, in Shell Mode}
@cindex shell completion
シェルバッファーのポイントの前のコマンド名、またはファイル名を補完します(@code{completion-at-point})。これは通常のEmacs補完ルールを使用します(@ref{Completion}を参照してください)。ファイル名、環境変数名、シェルコマンドヒストリー、ヒストリー参照が補完候補になります(@ref{History
References}を参照してください)。補完を制御するオプションについては、@ref{Shell Options}を参照してください。

@item M-?
@kindex M-? @r{(Shell mode)}
@findex comint-dynamic-list-filename@dots{}
ポイントの前のファイル名にたいして、可能性のある補完リストを一時的に表示します(@code{comint-dynamic-list-filename-completions})。

@item C-d
@kindex C-d @r{(Shell mode)}
@findex comint-delchar-or-maybe-eof
delete文字、または@acronym{EOF}文字を送ります(@code{comint-delchar-or-maybe-eof})。シェルバッファーの最後でこれをタイプすると、サブシェルに@acronym{EOF}が送られます。バッファーの他の場所でタイプすると、通常どおり文字を削除します。

@item C-c C-a
@kindex C-c C-a @r{(Shell mode)}
@findex comint-bol-or-process-mark
行の先頭に移動しますが、プロンプトがある場合はプロンプトの後に移動します(@code{comint-bol-or-process-mark})。このコマンドを連続して繰り返すと、2回目はプロセスマーク(process
mark)に戻ります。これはサブシェルにまだ送信されていない入力の開始位置のことです(通常これは同じ場所 --- その行のプロンプトの最後 ---
ですが、@kbd{C-c @key{SPC}}の後では、プロセスマークは前の行にあるかもしれません)。

@item C-c @key{SPC}
複数行の入力を累積して、それらを合わせて送ります(@code{comint-accumulate})。このコマンドはポイントの前に改行を挿入しますが、その前のテキストをサブシェルの入力として
--- 少なくともその時点では ---
送りません。改行の前後の行は両方、(それらを分割する改行も含めて)@key{RET}をタイプしたとき一緒に送られます。

@item C-c C-u
@kindex C-c C-u @r{(Shell mode)}
@findex comint-kill-input
まだ入力として送られていない、バッファーの最後のすべてのテキストをkillします(@code{comint-kill-input})。ポイントがバッファーの最後にない場合、これはポイントの前のテキストだけをkillします。

@item C-c C-w
@kindex C-c C-w @r{(Shell mode)}
ポイントの前の単語をkillします(@code{backward-kill-word})。

@item C-c C-c
@kindex C-c C-c @r{(Shell mode)}
@findex comint-interrupt-subjob
シェルまたは(もしあれば)カレントのサブジョブに割り込み(interrupt)ます(@code{comint-interrupt-subjob})。このコマンドはシェルバッファーの最後の、まだ送られていない任意のシェル入力もkillします。

@item C-c C-z
@kindex C-c C-z @r{(Shell mode)}
@findex comint-stop-subjob
シェルまたは(もしあれば)カレントのサブジョブを停止(stop)します。(@code{comint-stop-subjob})。このコマンドはシェルバッファーの最後の、まだ送られていない任意のシェル入力もkillします。

@item C-c C-\
@findex comint-quit-subjob
@kindex C-c C-\ @r{(Shell mode)}
シェルまたは(もしあれば)カレントのサブジョブに、シグナルQUITを送ります(@code{comint-quit-subjob})。このコマンドはシェルバッファーの最後の、まだ送られていない任意のシェル入力もkillします。

@item C-c C-o
@kindex C-c C-o @r{(Shell mode)}
@findex comint-delete-output
前のシェルコマンドからの出力の一群を削除します(@code{comint-delete-output})。これはシェルコマンドが大量の出力を吐くときに便利です。プレフィクス引数を指定すると、このコマンドは後でどこかにyank
(@ref{Yanking}を参照)できるように削除したテキストを@code{kill-ring} (@ref{Kill
Ring}を参照)に保存します。

@item C-c C-s
@kindex C-c C-s @r{(Shell mode)}
@findex comint-write-output
前のシェルコマンドからの出力の一群をファイルに書き込みます(@code{comint-write-output})。プレフィクス引数を指定した場合は、ファイルに追加で書き込みます。出力の最後のプロンプトは書き込まれません。

@item C-c C-r
@itemx C-M-l
@kindex C-c C-r @r{(Shell mode)}
@kindex C-M-l @r{(Shell mode)}
@findex comint-show-output
前の一群の出力の最初がウィンドウの最上部になるようにスクロールし、カーソルもそこに移動します(@code{comint-show-output})。

@item C-c C-e
@kindex C-c C-e @r{(Shell mode)}
@findex comint-show-maximum-output
バッファーの最後の行がウィンドウの最下部になるようにスクロールします(@code{comint-show-maximum-output})。

@item C-c C-f
@kindex C-c C-f @r{(Shell mode)}
@findex shell-forward-command
@vindex shell-command-regexp
シェルコマンド1つ分、前方に移動しますが、カレント行を超えては移動しません(@code{shell-forward-command})。変数@code{shell-command-regexp}は、コマンドの最後を認識する方法を指定します。

@item C-c C-b
@kindex C-c C-b @r{(Shell mode)}
@findex shell-backward-command
シェルコマンド1つ分、後方に移動しますが、カレント行を超えて移動はしません(@code{shell-backward-command})。

@item M-x dirs
シェルに作業ディレクトリーを尋ね、Shellバッファーのデフォルトディレクトリーを更新します。@ref{Directory
Tracking}を参照してください。

@item M-x comint-send-invisible @key{RET} @var{text} @key{RET}
@findex comint-send-invisible
エコーなしで@var{text}を読み取った後、それをシェルの入力として送ります。これはシェルコマンドでパスワードを尋ねるプログラムを実行するとき便利です。

デフォルトではEmacsはパスワードをエコーしないことに注意してください。もし本当にエコーさせたいときは、以下のLisp式を評価します(@ref{Lisp
Eval}を参照してください):

@example
(remove-hook 'comint-output-filter-functions
             'comint-watch-for-password-prompt)
@end example

@item M-x comint-continue-subjob
@findex comint-continue-subjob
シェルプロセスを継続します。これは間違ってシェルプロセスをサスペンドしてしまったときなどに便利です。@footnote{シェルプロセスをサスペンドするべきではありません。これはシェルのサブジョブのサスペンドとはまったく違います。サブジョブのサスペンドは通常行なわれますが、サブジョブを継続するためにはシェルを使用しなければなりません。このコマンドはそれを行ないません。}

@item M-x comint-strip-ctrl-m
@findex comint-strip-ctrl-m
シェル出力のカレントグループから、すべてのcontrol-M文字を破棄します。このコマンドを使うもっとも便利な方法は、サブシェルからの出力を受け取ったときに自動的に実行されるようにする方法です。これを行なうには、以下のLisp式を評価します:

@example
(add-hook 'comint-output-filter-functions
          'comint-strip-ctrl-m)
@end example

@item M-x comint-truncate-buffer
@findex comint-truncate-buffer
このコマンドはシェルバッファーを、変数@code{comint-buffer-maximum-size}により指定される、特定の最大行数に切り詰めます。以下は、サブシェルから出力を受けとるとき、毎回自動的にこれを行なう方法です:

@example
(add-hook 'comint-output-filter-functions
          'comint-truncate-buffer)
@end example
@end table

デフォルトでは、Shellモードは(たとえばテキストカラーの変更等に)一般的な@acronym{ANSI}エスケープコードを使います。initファイルに以下を記述すれば、Emacsはオプションで@acronym{OSC}
(Operating System Codes： オペレーティングシステムコード)のような拡張エスケープコードもいくつかサポートします:

@lisp
(add-hook 'comint-output-filter-functions 'comint-osc-process-output)
@end lisp

これを有効にすれば、たとえば@code{ls --hyperlink}からの出力からShellモードバッファーにクリック可能ボタンが作成されるでしょう。

@cindex Comint mode
@cindex mode, Comint
  Shellモードは、サブプロセスと対話的に通信を行なう一般的な用途向けのComintモードから派生したモードです。上記のコマンド名からも判るとおり、Shellモードのほとんどの機能は、実際にはComintモードが由来です。Shellモードの特別な機能には、ディレクトリー追跡機能、およびいくつかのユーザーコマンドが含まれます。

  Comintモードの変種を使う他のEmacs機能には、GUD (@ref{Debuggers}を参照してください)や、@kbd{M-x
run-lisp} (@ref{External Lisp}を参照してください)が含まれます。

@findex comint-run
  サブプロセスとして選択した任意のプログラムを実行するために、Shellモードに特化しない未修正のComintモードを使用するには、@kbd{M-x
comint-run}を使用することができます。プログラムに引数を渡すには@kbd{C-u M-x comint-run}を使用します。

@node Shell Prompts
@subsection Shellプロンプト

@cindex prompt, shell
  プロンプトとは、新しいユーザー入力を受け取る準備ができたことを表す、プログラムによるテキスト出力のことです。Comintモード(したがってShellモードも)は通常、サブプロセスからの出力にもとづいて、バッファーの一部をプロンプトとして自動的に判断します(具体的には、改行で終端されていない任意の出力行を受け取ったときは、プロンプトとみなします)。

  Comintモードは、バッファーを2つのタイプの@dfn{フィールド(fields)}に分けます。1つは入力フィールド(ユーザーの入力がタイプされるところ)で、もう1つは出力フィールド(入力フィールド以外)です。プロンプトは出力フィールドの一部です。ほとんどのEmacs移動コマンドは、そのコマンドが複数行を移動しない限り、フィールド境界を超えることはありません。たとえば、ポイントがシェルコマンドの入力フィールドにある場合、@kbd{C-a}はポイントを入力フィールドの先頭、プロンプトの後に配します。内部的には、フィールドはテキストプロパティ@code{field}を使って実装されています(@ref{Text
Properties,,, elisp, the Emacs Lisp Reference Manual}を参照してください)。

@vindex comint-use-prompt-regexp
@vindex shell-prompt-pattern
  変数@code{comint-use-prompt-regexp}を非@code{nil}値に変更した場合、Comintモードは正規表現を使ってプロンプトを認識します(@ref{Regexps}を参照してください)。Shellモードでは、その正規表現は変数@code{shell-prompt-pattern}により指定されます。@code{comint-use-prompt-regexp}のデフォルト値は@code{nil}です。なぜならプロンプト認識のためのこの方法は信頼性が低いためです。しかし特殊な状況では、これを非@code{nil}値にセットしたいと思うこともあるでしょう。そのような場合、EmacsはComintバッファーをフィールドに分割しないので、一般的な移動コマンドは、テキストプロパティを使用せず、それらのコマンドがバッファーで通常行なうように振る舞います。しかし、バッファーを便利に操作するために、パラグラフ移動コマンドを使うことができます(@ref{Paragraphs}を参照してください)。Shellモードでは、Emacsはパラグラフ境界に@code{shell-prompt-pattern}を使用します。

@node Shell History
@subsection Shellコマンドヒストリー

  Shellバッファーは、以前のコマンドを繰り返す3つの方法をサポートします。1つ目はミニバッファーヒストリーにたいして使うのと同じようなキーを使う方法です。つまり、これらはミニバッファーで行なうのと同じように、前のコマンドからテキストを挿入して、ポイントを常にバッファーの最後に保ちます。2つ目は、バッファーを移動して元の場所から前の入力を取得して、それらを再実行したり、バッファーの最後にコピーする方法です。3つ目は@samp{!}スタイルのヒストリー参照を使う方法です。

@menu
* Ring: Shell Ring.          ヒストリーリストからコマンドを取り出す。
* Copy: Shell History Copying.  コマンドに移動して、それをコピーする。
* History References::       @samp{!}スタイルのヒストリー参照の展開。
@end menu

@node Shell Ring
@subsubsection Shellヒストリーリング

@table @kbd
@findex comint-previous-input
@kindex M-p @r{(Shell mode)}
@item M-p
@itemx C-@key{UP}
以前のシェルコマンドから、次に古いコマンドを取り出します(@code{comint-previous-input})。

@kindex M-n @r{(Shell mode)}
@findex comint-next-input
@item M-n
@itemx C-@key{DOWN}
以前のシェルコマンドから、次に新しいコマンドを取り出します(@code{comint-next-input})。

@kindex M-r @r{(Shell mode)}
@findex comint-history-isearch-backward-regexp
@item M-r
以前のシェルコマンドにたいして、インクリメンタルregexp検索を開始します(@code{comint-history-isearch-backward-regexp})。

@item C-c C-x
@kindex C-c C-x @r{(Shell mode)}
@findex comint-get-next-from-history
ヒストリーから次のコマンドを取り出します(@code{comint-get-next-from-history})。

@item C-c .
@kindex C-c . @r{(Shell mode)}
@findex comint-insert-previous-argument
以前のシェルコマンドから引数を1つ取り出します(@code{comint-input-previous-argument})。

@item C-c C-l
@kindex C-c C-l @r{(Shell mode)}
@findex comint-dynamic-list-input-ring
そのバッファーのシェルコマンドのヒストリーを、別のウィンドウに表示します(@code{comint-dynamic-list-input-ring})。
@end table

  Shellバッファーは、以前に入力したシェルコマンドのヒストリーを提供します。ヒストリーからシェルコマンドを再利用するには、編集コマンド@kbd{M-p}、@kbd{M-n}、@kbd{M-r}を使用します。これらは、ミニバッファーではなくShellバッファーを操作する点を除き、ミニバッファーヒストリーコマンド(@ref{Minibuffer
History}を参照してください)と同じように機能します。またShellバッファー内での@code{M-r}は、シェルコマンドヒストリーにたいするインクリメンタル検索を呼び出します。

  @kbd{M-p}は、シェルバッファーの最後から以前のシェルコマンドを取り出します。連続して@kbd{M-p}を使用すると、古いシェルコマンドを連続して取り出し、その度にシェル入力の候補として表示されているテキストを置き換えます。@kbd{M-n}も同様に機能しますが、これはバッファーから、より新しいシェルコマンドを連続して探します。@kbd{C-@key{UP}}は@kbd{M-p}と同様に機能し、@kbd{C-@key{DOWN}}は@kbd{M-n}と同様に機能します。

  ヒストリー検索コマンド@kbd{M-r}は、以前のシェルコマンドにたいしてインクリメンタル正規表現検索を開始します。@kbd{M-r}とタイプした後に、検索したい文字列か正規表現のタイプを開始します。するとマッチする最後のシェルコマンドがカレント行に表示されます。インクリメンタル検索コマンドは通常の効果をもちます
--- たとえば@kbd{C-s}および@kbd{C-r}は前方または後方に、次のマッチを検索します(@ref{Incremental
Search}を参照してください)。探している入力が見つかったら、検索を終了するために@key{RET}をタイプします。これにより、入力がコマンドラインに配されます。ヒストリーリストを操作する前にタイプしていた入力の一部は、ヒストリーリングの先頭または最後に達したときに復元されます。

  以前に実行した一連のシェルコマンドを、同じ順番で再実行できたら便利なこともあります。これを行なうには、最初に順番に再実行する1番目のコマンドを検索します。その後@kbd{C-c
C-x}とタイプします。これは次のコマンド ---
つまり再実行したコマンドの次のコマンドを取り出します。それから@key{RET}でそのコマンドを実行します。@kbd{C-c C-x
@key{RET}}を繰り返しタイプすることにより、連続する複数のコマンドを再実行することができます。

  コマンド@kbd{C-c .}
(@code{comint-insert-previous-argument})は、Bashの@kbd{@key{ESC}
.}のように、以前のコマンドから個別に引数をコピーします。一番簡単な使い方は、以前のシェルコマンドから最後の引数をコピーする方法です。プレフィクス引数@var{n}を指定すると、@var{n}番目の引数をコピーします。繰り返し@kbd{C-c
.}とタイプすることにより、さらに古いシェルコマンドからコピーします。この場合、常に同じ@var{n}の値を使用します(@kbd{C-c
.}を繰り返すときは、プレフィクス引数を与えないでください)。

@vindex comint-insert-previous-argument-from-end
  @code{comint-insert-previous-argument-from-end}を非@code{nil}値にセットすると、@kbd{C-c
.}はかわりに最後から数えて@var{n}番目の引数をコピーします。これは@command{zsh}の@kbd{@key{ESC}
.}をエミュレートしたものです。

  これらのコマンドは、以前のシェルコマンドのテキストを、シェルバッファー自身からではなく、特別なヒストリーリストから取得します。したがってシェルバッファーを編集したり、広い範囲をkillしても、これらのコマンドがアクセスするヒストリーに影響はありません。

@vindex comint-input-ring-file-name
  シェルの中には、コマンドヒストリーをファイルに保存して、以前のシェルセッションからコマンドを参照できるようにするものがあります。Emacsは選択されたシェルにたいして、コマンドヒストリーを初期化するために、コマンドヒストリーファイルを読み込みます。ヒストリーファイル名は、bashでは@file{~/.bash_history}、kshでは@file{~/.sh_history}、他のシェルでは@file{~/.history}です。

@vindex tramp-histfile-override
  リモートホストでシェルを実行した場合には、このセッティングは変数@code{tramp-histfile-override}に上書きされるかもしれません。この変数は@code{nil}にセットすることを推奨します。

@node Shell History Copying
@subsubsection Shellヒストリーのコピー

@table @kbd
@kindex C-c C-p @r{(Shell mode)}
@findex comint-previous-prompt
@item C-c C-p
前のプロンプトにポイントを移動します(@code{comint-previous-prompt})。

@kindex C-c C-n @r{(Shell mode)}
@findex comint-next-prompt
@item C-c C-n
次のプロンプトにポイントを移動します(@code{comint-next-prompt})。

@kindex C-c RET @r{(Shell mode)}
@findex comint-copy-old-input
@item C-c @key{RET}
ポイント位置の入力コマンドをコピーして、そのコピーをバッファーの最後に挿入します(@code{comint-copy-old-input})。これは以前のコマンドにポイントを移動したときに便利です。コマンドをコピーした後、@key{RET}でそのコピーを入力として実行することができます。再実行する前に、そのコピーを編集することもできます。このコマンドを出力行で使用した場合、その行をバッファーの最後にコピーします。

@item mouse-2
@code{comint-use-prompt-regexp}が@code{nil}(デフォルト)の場合、クリックした以前の入力コマンドをコピーして、そのコピーをバッファーの最後に挿入します(@code{comint-insert-input})。@code{comint-use-prompt-regexp}が非@code{nil}、または以前の入力以外の場所をクリックしたときは、通常のようにyankします。
@end table

  以前の入力に移動して、@kbd{C-c
@key{RET}}または@kbd{mouse-2}でコピーすることは、@kbd{M-p}を充分な回数使用して、ヒストリーリングから以前の入力を取り出したときと同じ結果
--- つまり同じバッファー内容 --- を生成します。しかし@kbd{C-c
@key{RET}}は、バッファーからテキストをコピーするので、入力をシェルに送信した後に入力テキストを編集していた場合は、ヒストリーリストと異なります。

@node History References
@subsubsection Shellヒストリーの参照
@cindex history reference

  cshやbashを含むさまざまなシェルは、@samp{!}や@samp{^}で始まる@dfn{ヒストリー参照(history
references)}をサポートします。Shellモードはこれらを認識して、ヒストリーの置き換える処理をします。

  ヒストリー参照を挿入して@key{TAB}とタイプすると、これは入力ヒストリーからマッチするコマンドを検索して、必要なら置換を行い、結果をバッファー内のヒストリー参照の場所に配します。たとえば、一番最近の@samp{mv}で始まるコマンドを取り出すには、@kbd{!
m v @key{TAB}}とタイプします。必要ならコマンドを編集して、@key{RET}でシェルにたいしてコマンドを再実行できます。

@vindex comint-input-autoexpand
@findex comint-magic-space
  Shellモードはヒストリー参照をシェルに送るとき、オプションでヒストリー参照を展開できます。これを行なうには、変数@code{comint-input-autoexpand}を@code{input}にセットします。@key{SPC}を@code{comint-magic-space}にバインドすれば、@key{SPC}でヒストリー参照を展開できます。@ref{Rebinding}を参照してください。

  Shellモードは、ヒストリー参照がプロンプトの後にあればヒストリー参照を認識します。Shellモードがプロンプトを認識する方法については、@ref{Shell
Prompts}を参照してください。

@node Directory Tracking
@subsection ディレクトリーの追跡
@cindex directory tracking

@vindex shell-pushd-regexp
@vindex shell-popd-regexp
@vindex shell-cd-regexp
  Shellモードは、Shellバッファーのデフォルトディレクトリー(@ref{File
Names}を参照してください)をシェルの作業ディレクトリーと同一に保つために、サブシェルに与えられる@samp{cd}、@samp{pushd}、@samp{popd}のコマンドを追跡します。これは、送信する入力行を調べることにより認識されます。

  これらのコマンドにたいしてエイリアスを使用する場合、変数@code{shell-pushd-regexp}、@code{shell-popd-regexp}、@code{shell-cd-regexp}に適切な正規表現(@ref{Regexps}を参照してください)をセットすることにより、それらも認識するようEmacsに指示できます。たとえば、@code{shell-pushd-regexp}がシェルコマンドラインの先頭にマッチした場合、その行は@code{pushd}コマンドとして記録されます。これらのコマンドは、シェルコマンドラインの先頭だけで認識されます。

@findex dirs
  Emacsが作業ディレクトリーの変更に際して混乱した場合は、@kbd{M-x
dirs}を試してください。このコマンドはシェルに作業ディレクトリーを尋ねて、それに対応してデフォルトディレクリーを更新します。これは、一般的なコマンド構文のほとんどをサポートするシェルでは機能しますが、特殊なシェルでは機能しないかもしれません。

@findex dirtrack-mode
@cindex Dirtrack mode
@cindex mode, Dirtrack
@vindex dirtrack-list
  シェルの作業ディレクトリーを追跡する他の方法を実装した、バッファーローカルなマイナーモードの、Dirtrackモードを使うこともできます。この方法を使うには、シェルプロンプトに常に作業ディレクトリーが含まれていなければならず、プロンプトのどの部分が作業ディレクトリーを含むか認識するための正規表現を与えなければなりません。詳細は、変数@code{dirtrack-list}のドキュメントを参照してください。Dirtrackモードを使用するには、Shellバッファーで@kbd{M-x
dirtrack-mode}とタイプするか、@code{shell-mode-hook}に@code{dirtrack-mode}を追加します(@ref{Hooks}を参照してください)。

@node Shell Options
@subsection Shellモードのオプション

@vindex comint-scroll-to-bottom-on-input
  変数@code{comint-scroll-to-bottom-on-input}が非@code{nil}の場合、挿入およびyankコマンドは、挿入する前に選択されたウィンドウを、バッファーの最後までスクロールします。デフォルトは@code{nil}です。

@vindex comint-scroll-show-maximum-output
  @code{comint-scroll-show-maximum-output}が非@code{nil}の場合、ポイントが最後にあるとき到着した出力は、可能な限り有用なテキストを表示するために、テキストの最後の行がウィンドウの一番下になるようなスクロールを試みます(これはほとんどの端末のスクロール動作を真似た動作です)。デフォルトは@code{t}です。

@vindex comint-move-point-for-output
  @code{comint-move-point-for-output}をセットすることにより、出力が到着したときにバッファーの最後にポイントをジャンプさせることができます
---
その前にポイントがバッファーのどこにあろうと関係ありません。値が@code{this}の場合、選択されたウィンドウ内でポイントがジャンプします。値が@code{all}の場合、Comintバッファーを表示するすべてのウィンドウでポイントがジャンプします。値が@code{other}の場合、カレントバッファーを表示する、選択されていないすべてのウィンドウでポイントがジャンプします。デフォルト値は@code{nil}で、これはポイントが最後にジャンプしないことを意味します。

@vindex comint-prompt-read-only
  @code{comint-prompt-read-only}をセットした場合、Comintバッファーのプロンプトは読み取り専用になります。

@vindex comint-input-ignoredups
  変数@code{comint-input-ignoredups}は、連続する同じ入力を入力ヒストリーに保存するかを制御します。非@code{nil}値は、入力が前の入力と同じ場合は省略することを意味します。デフォルトは@code{nil}で、これは入力が前の入力と同じでも保存することを意味します。

@vindex comint-completion-addsuffix
@vindex comint-completion-recexact
@vindex comint-completion-autolist
  ファイル名の補完をカスタマイズする3つの変数があります。変数@code{comint-completion-addsuffix}は、完全に補完されたファイル名またはディレクトリー名の最後にスペースまたはスラッシュを挿入するかを制御します(非@code{nil}は、スペースまたはスラッシュを挿入することを意味します)。@code{comint-completion-recexact}が非@code{nil}の場合、通常のEmacs補完アルゴリズムが1文字も追加できないようなときは、@key{TAB}で一番短い利用可能な補完を選択するよう指示します。@code{comint-completion-autolist}が非@code{nil}の場合、補完が完全でないときは、利用可能なすべての候補をリストするよう指示します。

@vindex shell-completion-execonly
  コマンド補完は通常、実行可能ファイルだけを考慮します。@code{shell-completion-execonly}を@code{nil}にセットした場合は、実行可能ファイル以外も同様に考慮します。

@vindex shell-completion-fignore
@vindex comint-completion-fignore
変数@code{shell-completion-fignore}は、Shellモードで無視するファイル名の拡張子のリストを指定します。デフォルトは@code{nil}ですが、@samp{~}、@samp{#}、@samp{%}で終わるファイル名を無視するために@code{("~"
"#"
"%")}をセットするユーザーもいます。他のComintモードに関連するモードは、かわりに変数@code{comint-completion-fignore}を使用します。

@findex shell-dynamic-complete-command
シェルコマンド補完の実装の詳細は、@code{shell-dynamic-complete-command}関数のlispドキュメントで見ることもできます。

@findex shell-pushd-tohome
@findex shell-pushd-dextract
@findex shell-pushd-dunique
  @samp{pushd}の動作を設定することができます。@code{shell-pushd-tohome}は、引数を与えない場合に@samp{pushd}が@samp{cd}のように振る舞うかを制御します。@code{shell-pushd-dextract}は、数引数を与えたときローテートするのではなくpopするかを制御します。@code{shell-pushd-dunique}は、ディレクトリースタックにディレクトリーがない場合だけ追加するかを制御します。もちろん選択する値は背後のシェルに適合する必要があります。

@vindex comint-terminfo-terminal
@vindex system-uses-terminfo
@vindex TERM@r{, environment variable, in sub-shell}
Comintモードは、環境変数@env{TERM}の値を安全なデフォルト値にセットしますが、この値はいくつかの有用な機能を無効にします。たとえばカラーがサポートされているかの判断に@env{TERM}を使用するため、アプリケーションではカラーが無効になっています。したがってシステムのterminfoデータベースで定義されている、より高度な機能をもつ端末を選択できるように、Emacsはオプション@code{comint-terminfo-terminal}を提供します。@code{system-uses-terminfo}が非@code{nil}の場合には、Emacsはこのオプションの値を@env{TERM}として使用します。

@code{comint-terminfo-terminal}と@code{system-uses-terminfo}はいずれも、リモートシステムの期待にこれらのオプションを合致させられるように接続ローカル変数として定義できます(@ref{Connection
Variables}を参照)。

@node Terminal emulator
@subsection Emacsの端末エミュレーター
@findex term

  テキスト端末エミュレーターでサブシェルを実行するには、@kbd{M-x
term}を使用します。これは@file{*terminal*}という名前のバッファーを作成(または再利用)して、キーボードを入力とするサブシェルを実行し、出力はそのバッファーになります。

@cindex line mode @r{(terminal emulator)}
@cindex char mode @r{(terminal emulator)}
  端末エミュレーターは、2つの入力モードをもつTermモードを使用します。@dfn{lineモード(line
mode)}では、Termは基本的にShellモードのように振る舞います(@ref{Shell
Mode}を参照してください)。@dfn{charモード(char
mode)}では、文字は端末入力として直接サブシェルに送られます。唯一の例外は端末エスケープ文字で、デフォルトは@kbd{C-c}です(@ref{Term
Mode}を参照してください)。入力をエコーするのはサブシェルの役目です。サブシェルからの端末出力は、バッファーのポイントの後に送られます。

  (Emacsのような)いくつかのプログラムでは、端末スクリーンで詳細に外観を制御する必要があります。これらのプログラムは特別な制御コードを送ることによりこれを行ないます。Termモードは、@command{xterm}を含むほとんどの現代的な端末で使用できる、ANSI標準のVT100スタイルのエスケープシーケンスを認識・処理します(したがって、実際にEmacsのTermウィンドウ内でEmacsを実行することもできます)。

  @code{term}フェイスは、端末エミュレーターのテキストのデフォルトの外観を指定します(デフォルトは@code{default}フェイスと同じ外観です)。端末の制御コードがテキストの外観を変更するために使用される場合、これらは端末エミュレーター内で、フェイス@code{term-color-black}、@code{term-color-red}、@code{term-color-green}、@code{term-color-yellow}、@code{term-color-blue}、@code{term-color-magenta}、@code{term-color-cyan}、@code{term-color-white}、@code{term-color-underline}、@code{term-color-bold}で表示されます。@ref{Faces}を参照してください。

  シリアルポートに接続されたデバイスと通信するために、Termモードを使うこともできます。@ref{Serial Terminal}を参照してください。

  サブシェルをロードするために使用されるファイル名は、Shellモードと同じ方法で決定されます。複数の端末エミュレーターを作成するには、Shellモードと同じように、@kbd{M-x
rename-uniquely}を使って、バッファー@file{*terminal*}を違う名前にリネームします。

  Shellモードとは異なり、Termモードは入力を調べてカレントディレクトリーを追跡することはしません。しかし、いくつかのシェルはカレントディレクトリーをTermに告げることができます。これは@code{bash}のバージョン1.15以降では自動的に行なわれます。

@node Term Mode
@subsection Termモード
@cindex Term mode
@cindex mode, Term

  Termモードでlineモードとcharモードを切り替えるには、以下のコマンドを使用します:

@table @kbd
@kindex C-c C-j @r{(Term mode)}
@findex term-line-mode
@item C-c C-j
lineモードに切り替えます(@code{term-line-mode})。すでにlineモードのときは何もしません。

@kindex C-c C-k @r{(Term mode)}
@findex term-char-mode
@item C-c C-k
charモードに切り替えます(@code{term-char-mode})。すでにcharモードのときは何もしません。
@end table

  以下のコマンドはcharモードだけで利用可能です:

@table @kbd
@item C-c C-c
サブシェルに、リテラルの@kbd{C-c}を送ります(@code{term-interrupt-subjob})。

@item C-c @var{char}
これは通常のEmacsでの@kbd{C-x @var{char}}と等価です。たとえば@kbd{C-c o}は、通常@kbd{C-x
o}にグローバルにバインドされている@samp{other-window}を呼び出します。
@end table

@cindex paging in Term mode
  Termモードにはpage-at-a-time(1度に1ページ)機能があります。これが有効な場合、出力の画面の最後で一時停止します。

@table @kbd
@kindex C-c C-q @r{(Term mode)}
@findex term-pager-toggle
@item C-c C-q
page-at-a-time機能を切り替えます(@code{term-pager-toggle})。このコマンドはlineモードとcharモードの両方で機能します。この機能が有効な場合、モードラインには単語@samp{page}が表示され、Termが1画面に収まらない出力を受け取ったときは、一時停止してモードラインに@samp{**MORE**}を表示します。@key{SPC}とタイプすると次の1画面分の出力を表示し、@kbd{?}でオプションを見ることができます。このインターフェースは、@code{more}プログラムと同様です。
@end table

@node Remote Host
@subsection リモートホストのシェル
@cindex remote host
@cindex connecting to remote host
@cindex Telnet
@cindex SSH

  通常の端末から使うコマンド(たとえば@command{ssh}コマンド)を使用して、Termウィンドウからリモートコンピューターにログインすることができます。

  パスワードを尋ねるようなプログラムは、通常パスワードをエコーしないので、パスワードはバッファーにも表示されません。バッファーがcharモードの場合、実際の端末で使用しているのと同じ動作になります。lineモードの場合、パスワードは一時的に表示されますが、リターンをタイプするとパスワードは消去されます(これは自動的に行なわれます。特別なパスワード処理は行なっていません)。

  別のマシンにログインしているときは、リモートログインコマンドのために、環境変数@env{TERM}をセットすることにより、端末タイプを指定する必要があります(bashを使用している場合、リモートログインコマンドの前に、カンマで区切らず値割り当てを記述することにより、これを行なうことができます)。端末タイプ@samp{ansi}または@samp{vt100}は、ほとんどのシステムで動作するでしょう。

@node Serial Terminal
@subsection シリアル端末
@cindex terminal, serial
@findex serial-term

  コンピューターに、シリアルポートに接続されたデバイスがあるとき、@kbd{M-x
serial-term}とタイプすることにより、デバイスと通信することができます。このコマンドは新しいTermモードのバッファーのために、ポート番号、スピード、スイッチを尋ねます。Emacsは、通常のTermモードの端末で行なうのと同じように、このバッファーを通じてシリアルデバイスと通信します。

  シリアルポートのスピードはビット毎秒で計ります。もっとも一般的なスピードは9600ビット毎秒です。モードラインをクリックすることにより、このスピードを対話的に変更できます。

  シリアルポートはモードラインの@samp{8N1}をクリックしても設定できます。デフォルトでは、シリアルポートは@samp{8N1}に設定されており、これは各バイトは8ビットからなり、パリティービットチェックなし、ストップビットが1であることを意味します。

  スピードや設定が間違っている場合、デバイスと通信できず、おそらくウィンドウにはゴミが出力されるでしょう。

@node Emacs Server
@section サーバーとしてのEmacsの使用
@pindex emacsclient
@cindex Emacs as a server
@cindex server, using Emacs as
@cindex @env{EDITOR} environment variable

  さまざまなプログラムが、特定のテキスト断片を編集するために、あなたが選択したエディターを呼び出すことができます。たとえば、バージョンコントロールシステム(@ref{Version
Control}を参照してください)は、バージョンコントロールログを入力するためのエディターを呼び出し、Unixの@command{mail}ユーティリティーは送信メッセージの入力にエディターを呼び出します。慣例により、選択するエディターは、環境変数@env{EDITOR}で指定されます。しかし@env{EDITOR}を@samp{emacs}にセットした場合、Emacsが呼び出されますが、これは便利な方法ではありません
---
なぜなら新しいEmacsプロセスが開始されるからです。なぜこれが不便かというと、新たなEmacsプロセスは、既存のEmacsプロセスのバッファー、コマンドヒストリー、その他の情報を共有しないからです。

  Emacsを@dfn{edit
server(編集サーバー)}としてセットアップして、Emacsが外部からの編集リクエストを``listen''し、それに応じて動作させることにより、この問題を解決できます。Emacsサーバーを開始するにはさまざまな方法があります:

@itemize
@findex server-start
@item
@kbd{M-x server-start}とタイプするか、initファイル(@ref{Init
File}を参照してください)に式@code{(server-start)}を記述して、既存のEmacsプロセスでコマンド@code{server-start}を実行します。既存のEmacsプロセスがサーバーになり、Emacsを終了すると、サーバーはそのEmacsプロセスとともに終了します。

@cindex daemon, Emacs
@item
コマンドラインオプション@samp{--daemon}のいずれか1つを使用して、Emacsを@dfn{daemon}として実行します。@ref{Initial
Options}を参照してください。Emacsがこの方法で開始された場合、初期化の後に@code{server-start}を呼び出して、初期フレームを開きません。その後クライアントからの編集リクエストをwaitします。

@item
コマンドラインオプション@samp{--alternate-editor=""}でコマンド@code{emacsclient}を実行します。Emacsデーモンがまだ実行されていない場合に限りEmacsデーモンを開始します。

@cindex systemd unit file
@item
オペレーティングシステムがスタートアップ管理に@command{systemd}を使用する場合、提供される@dfn{systemdユニットファイル(systemd
unit file)}を使用して、ログイン時に自動的にデーモンモードのEmacsを開始できます。これをアクティブにするには:
@example
systemctl --user enable emacs
@end example
(Emacsが標準的な場所にインストールされていない場合は、@file{~/.config/systemd/user/}のような標準的なディレクトリーに@file{emacs.service}をコピーする必要があるかもしれません。)

@cindex socket activation, systemd, Emacs
@item
指定されたソケットに接続イベントが発生したとき、外部プロセスはEmacsサーバーを呼び出して、そのソケットを新たなEmacsサーバーのプロセスに渡すことができます。このインスタンスは@command{systemd}のソケット機能です。@command{systemd}サービスはソケットを作成して、そのソケットへの接続をlistenします。@command{emacsclient}が最初にこれに接続したとき、@command{emacsclient}による接続のために、@command{systemd}はEmacsサーバーを起動して、そのソケットを渡すことができます。@command{emacsclient}が最初にこれに接続したとき、@command{emacsclient}による接続のために、@command{systemd}はEmacsサーバーを起動して、そのソケットを渡すことができます。この機能を使用するためのセットアップは:

@file{~/.config/systemd/user/emacs.socket}:
@example
[Socket]
ListenStream=/path/to/.emacs.socket
DirectoryMode=0700

[Install]
WantedBy=sockets.target
@end example

(上述のファイル@file{emacs.service}もインストールされていなければなりません。)

パス@code{ListenStream}は、Emacsが@command{emacsclient}からの接続をlistenするパスです。これは、あなたが選択するファイルです。
@end itemize

@cindex @env{TEXEDIT} environment variable
  Emacsサーバーを一度開始すると、@command{emacsclient}というシェルコマンドを使用してEmacsに接続して、ファイルをvisitするよう指示できます。環境変数@env{EDITOR}に@samp{emacsclient}をセットすれば、外部プログラムは編集のために既存のEmacsプロセスを使用できます。@footnote{別の環境変数を使うプログラムもいくつかあります。たとえば、@TeX{}が@samp{emacsclient}を使うようにするには、環境変数@env{TEXEDIT}を@samp{emacsclient
+%d %s}にセットします。}

@vindex server-name
  変数@code{server-name}を使って、一意な@dfn{サーバー名}を与えることにより、同一マシン上で複数のEmacsサーバーを実行することができます。たとえば@kbd{M-x
set-variable @key{RET} server-name @key{RET} "foo"
@key{RET}}は、サーバー名を@samp{foo}にセットします。@code{emacsclient}プログラムはTCPソケット使用の有無に応じて@samp{-s}オプション、または@samp{-f}オプション(@ref{emacsclient
Options}を参照)で、名前によりサーバーを指定できます(@ref{emacsclient Options}を参照)。

  複数のEmacsデーモン(@ref{Initial
Options}を参照)を実行したい場合には、以下のようにデーモンごとにそれぞれ独自のサーバー名を与えることができます:

@example
  emacs --daemon=foo
@end example

@findex server-stop-automatically
  オプションとして特定の条件が満足された際に、Emacsサーバーを自動的に停止できます。これを行うには、initファイルで以下の引数のいずれかを指定して関数@code{server-stop-automatically}を呼び出してください(@ref{Init
File}を参照)。

@itemize
@item
引数が@code{empty}ならクライアント、ファイルをvisitしている未保存のバッファー、実行中プロセスがすべて無くなるとサーバーは停止します。

@item
引数が@code{delete-frame}なら、最後のクライアントフレームが閉じられる際にファイルをvisitしている未保存のバッファーを保存するか、終了していないプロセスそれぞれについて停止してよいか尋ねて、問題なければサーバーを停止します。

@item
引数が@code{kill-terminal}なら、@kbd{C-x C-c}
(@code{save-buffers-kill-terminal})で最後のクライアントフレームが閉じられる際にファイルをvisitしている未保存のバッファーを保存するか、終了していないプロセスそれぞれについて停止してよいか尋ねて、問題なければサーバーを停止します。
@end itemize

@findex server-eval-at
  一意なサーバー名によりサーバーを定義した場合、他のEmacsインスタンスからそのサーバーに接続し、@code{server-eval-at}関数を使用して、そのサーバーでLisp式を評価できます。たとえば@code{(server-eval-at
"foo" '(+ 1 2))}は、式@code{(+ 1
2)}をサーバー@samp{foo}で評価して、@code{3}を返します(そのような名前のサーバーが存在しない場合はエラーをシグナルします)。現在のところ、これは主に開発者に有用な機能です。

  オペレーティングシステムのデスクトップ環境が@url{https://www.freedesktop.org/wiki/Specifications/,,freedesktop.org-compatible}
(これはほとんどのGNU/Linuxやその他の最近のUnix風GUIが該当する)なら、@command{emacsclient}でEmacsサーバーに接続するために@samp{Emacs
(Client)}メニューエントリーを使用できます。デーモンがすでに実行中でなければ開始されます。

@menu
* TCP Emacs server::         TCPソケットのlisten。
* Invoking emacsclient::     Emacsサーバーへの接続。
* emacsclient Options::      Emacsクライアントの開始オプション。
@end menu

@node TCP Emacs server
@subsection TCP Emacs server
@cindex TCP Emacs server

@vindex server-use-tcp
  Emacsサーバーは通常、接続にたいしてローカルのUnixドメインソケットをlistenします。
MS-Windowsのようないくつかのオペレーティングシステムは、ローカルソケットをサポートしません。そのような場合、サーバーはかわりにTCPソケットをlistenします。ローカルソケットがサポートされている場合でも、サーバーにTCPソケットをlistenさせるほうが便利な場合があります(たとえばリモートマシンからEmacsサーバーに接続する必要がある場合)。ローカルソケットのかわりにTCPソケットをEmacsにlistenさせる場合は、@code{server-use-tcp}に非@code{nil}をセットできます。これはOSがローカルソケットをサポートしない場合は、デフォルトです。

@vindex server-host
@vindex server-port
  EmacsサーバーがTCPを使うように設定されている場合は、デフォルトではlocalhostインターフェイスのランダムなポートをlistenします。@code{server-host}と@code{server-port}を使用して、これを他のインターフェイス、および/または固定されたポートに変更できます。

@vindex server-auth-key
  TCPソケットは、ファイルシステムのパーミッションの対象ではありません。TCPソケットを通じて、誰がEmacsサーバーと通信できるか何らかの制御を得るには、@command{emacsclient}プログラムがサーバーに認証キーを送信しなければなりません。このキーは通常、Emacsサーバーによりランダムに生成されます。これが推奨されるモードです。

@findex server-generate-key
  必要なら、@code{server-auth-key}変数をセットすることにより、認証キーに静的な値をセットできます。このキーは、スペースを除くプリント可能な64文字のASCII文字(これは@samp{!}から@samp{~}、10進コードの33から126を意味します)から構成されなければなりません。ランダムキーを得るために、@kbd{M-x
server-generate-key}を使用できます。

@vindex server-auth-dir
@cindex server file
  TCP
Emacsサーバーを開始したとき、Emacsは@command{emacsclient}がサーバーに接続するために使用する、TCP情報を含む@dfn{サーバーファイル(server
file)}を作成します。変数@code{server-auth-dir}は、サーバーファイルを含むデフォルトディレクトリーを指定します。デフォルトでは、これは@file{~/.emacs.d/server/}です。アクセス権限(file
permission)をもつlocalソケットが存在しない場合は、このディレクトリーのパーミッションにより、どのユーザーの@command{emacsclient}プロセスがEmacsサーバーと対話(talk)できるか判断されます。@code{server-name}がー絶対ファイル名なら、サーバーファイルはそのファイル名で作成されます。

@vindex EMACS_SERVER_FILE@r{, environment variable}
  特定のserverファイルによりTCPサーバーに接続するよう@command{emacsclient}に指示するには、オプション@samp{-f}または@samp{--server-file}を使用するか、環境変数@env{EMACS_SERVER_FILE}をセットします(@ref{emacsclient
Options}を参照)。@code{server-auth-dir}が非標準的な値にセットされていたり、@code{server-name}に絶対ファイル名がセットされていると、デフォルトの@code{server-auth-dir}は、相対ファイル名を解決するために使用するディレクトリーとして、@command{emacsclient}内にハードコーディングされているため、serverファイルにたいする絶対ファイル名が必要になります。

@node Invoking emacsclient
@subsection @code{emacsclient}の呼び出し
@cindex @code{emacsclient} invocation

  @command{emacsclient}プログラムを使う一番簡単な方法は、シェルコマンド@samp{emacsclient
@var{file}}を実行する方法です。ここで@var{file}はファイル名です。これはEmacsサーバーに接続して、Emacsプロセスの既存のフレームの1つ
--- グラフィカルなフレーム、またはテキスト端末のフレーム(@ref{Frames}を参照してください) ---
で@var{file}をvisitするよう指示します。それから、そのフレームを選択して編集を開始できます。

  Emacsサーバーが存在しない場合、@command{emacsclient}はエラーメッセージと共に終了します(このハプニングによるエラー終了は、@command{emacsclient}にたいして@samp{--alternate-editor=\"\"}オプションを使用して回避できる。@ref{emacsclient
Options}を参照されたい)。Emacsプロセスに既存のフレームがない場合 --- これはサーバーがデーモン(@ref{Emacs
Server}を参照してください)として開始されたときに発生し得ます ---
は、@command{emacsclient}を呼び出した端末でEmacsフレームをオープンします。

  オプション@samp{-c}でグラフィカルなディスプレイ、@samp{-t}を使用しテキスト端末で新しいフレームを開くように、@command{emacsclient}に強制することもできます。@ref{emacsclient
Options}を参照してください。

  単一のテキスト端末で実行している場合、@command{emacsclient}のシェルとEmacsサーバーを、次の2つの方法で切り替えることができます。1つ目は、Emacsサーバーと、別の仮想端末で@command{emacsclient}を実行して、@command{emacsclient}を呼び出した後にEmacsサーバーの仮想端末に切り替える方法です。2つ目は、Emacsサーバー自身からShellモード(@ref{Interactive
Shell}を参照してください)、またはTermモード(@ref{Term
Mode}を参照してください)を使って@command{emacsclient}を呼び出す方法です。@command{emacsclient}は、Emacs配下のサブシェルのときだけブロックするので、依然としてファイルの編集にEmacsを使用できます。

@kindex C-x #
@findex server-edit
  Emacsサーバーで@var{file}の編集を終えたら、そのバッファーで@kbd{C-x #}
(@code{server-edit})とタイプします。これはファイルを保存して、@command{emacsclient}プログラムに終了を告げるメッセージを送り返します。通常、@env{EDITOR}を使うプログラムは、何か他のことを行なう前にエディター
--- この場合は@command{emacsclient} --- の終了を待ちます。

@findex server-edit-abort
  かわりに編集をキャンセルしたければ、@w{@kbd{M-x
server-edit-abort}}コマンドを使用します。これは@command{emacsclient}プログラムにメッセージを送り返して、バッファーを何も保存せずにabnormalなexitステータスでexitするよう指示します。

  複数のファイル名を引数にして@command{emacsclient}を呼び出すこともできます。@samp{emacsclient
@var{file1} @var{file2}
...}は、Emacsサーバーに@var{file1}、@var{file2}、...をvisitするよう指示します。Emacsは@var{file1}をvisitしているバッファーを選択して、他のバッファーをバッファーリストの最後に隠します(@ref{Buffers}を参照してください)。指定されたすべてのファイルを終了したら(たとえば各サーバーバッファーで@kbd{C-x
#}をタイプしたら)、@command{emacsclient}プログラムは終了します。

@vindex server-kill-new-buffers
@vindex server-temp-file-regexp
  サーバーバッファーを終了すると、そのバッファーがサーバーバッファーを作成する前から存在していたバッファーでないかぎり、そのバッファーもkillされます。しかし@code{server-kill-new-buffers}を@code{nil}にセットした場合、別の基準が使用されます。この場合、サーバーバッファーの終了は、ファイル名が正規表現@code{server-temp-file-regexp}にマッチするときは、バッファーをkillします。これはある種の一時ファイルを区別するための仕組みです。

  各@kbd{C-x
#}は、さまざまなファイルを編集する、保留されている外部要求が他にないかチェックして、次のそのようなファイルを選択します。サーバーバッファーに辿り着くのに、@kbd{C-x
#}だけを使わなければならない訳ではありません。サーバーバッファーに手動で切り替えることもできます。しかし@kbd{C-x
#}は、@command{emacsclient}に終了したことを告げる方法なのです。

@vindex server-window
  変数@code{server-window}の値をウィンドウやフレームにした場合、@kbd{C-x
#}は常に次のサーバーバッファーを、そのウィンドウまたはそのフレームに表示します。

@vindex server-client-instructions
  @command{emacsclient}が接続した際には、サーバーは通常はクライアントフレームのexit方法を告げるメッセージを出力します。@code{server-client-instructions}を@code{nil}にセットすると、このメッセージは抑制されます。

@node emacsclient Options
@subsection @code{emacsclient}のオプション
@cindex @code{emacsclient} options

  以下のようなオプション引数を@command{emacsclient}プログラムに渡すことができます:

@example
emacsclient -c +12 @var{file1} +4:3 @var{file2}
@end example

@noindent
引数@samp{+@var{line}}および@samp{+@var{line}:@var{column}}は、その後に続くファイルの行番号、または行番号と列番号を指定します。これらはEmacs自身に対するコマンドライン引数と同じように機能します。
@ref{Action Arguments}を参照してください。

  その他の@command{emacsclient}により認識されるオプション引数を以下にリストします:

@table @samp
@item -a @var{command}
@itemx --alternate-editor=@var{command}
@command{emacsclient}が、Emacsとの接続に失敗したとき実行するシェルコマンドを指定します。これはスクリプト内で@code{emacsclient}を実行するとき便利です。このコマンドには、\"like
this\"のようにクォートされた引数が含まれるかもしれません。現在のところ、クォートのエスケープはサポートされていません。

特別な例外として、@var{command}が空文字列の場合、接続に失敗したら@command{emacsclient}は(@samp{emacs
--daemon}のように)Emacsをデーモンモードで開始して、再度接続を試みます。

@cindex @env{ALTERNATE_EDITOR} environment variable
環境変数@env{ALTERNATE_EDITOR}は、@samp{-a}オプションと同じ効果をもちます。両方が指定された場合は、後者のオプションが優先されます。

@cindex client frame
@item -c
@itemx --create-frame
既存のEmacsフレームを使うかわりに、新しいグラフィカルな@dfn{クライアントフレーム(client
frame)}を作成します。クライアントフレームでの、@kbd{C-x
C-c}の特別な振る舞いについては、以下を参照してください。(Xサーバーに接続できない等で)新たにグラフィカルなフレームを作成しない場合、あたかも@samp{-t}オプションが指定されたかのように、テキスト端末でクライアントフレームの作成を試みます。

MS-Windowsでは、単一のEmacsセッションがグラフィカルなフレームとテキスト端末のフレームの両方を表示することはできず、複数のテキスト端末のフレームを表示することもできません。したがってEmacsサーバーがテキスト端末で実行されている場合、@samp{-c}オプションは@samp{-t}オプションのように、サーバーのカレントテキスト端末で新たなフレームを作成します。@ref{Windows
Startup}を参照してください。

@samp{-c}オプションを指定するときに、ファイル名の引数を省略した場合、新しいフレームはデフォルトで@file{*scratch*}バッファーを表示します。変数@code{initial-buffer-choice}でこの振る舞いをカスタマイズできます(@ref{Entering
Emacs}を参照してください)。

@item -r
@itemx --reuse-frame
グラフィカルなクライアントフレームが存在しなければ新たに作成、存在する場合には既存のEmacsフレームを使用します。

@item -F @var{alist}
@itemx --frame-parameters=@var{alist}
新たに作成される、グラフィカルなフレームのパラメーターをセットします(@ref{Frame Parameters}を参照してください)。

@item -d @var{display}
@itemx --display=@var{display}
与えられたファイルを、(複数のXディスプレイがあることを想定して)Xディスプレイ@var{display}で開くようEmacsに指示します。

@item -e
@itemx --eval
ファイルをvisitするかわりに、Emacs
Lispコードを評価するようEmacsに指示します。このオプションが与えられた場合、@command{emacsclient}は引数をvisitするファイルではなく、式のリストと解釈します。

@item -f @var{server-file}
@itemx --server-file=@var{server-file}
TCPを通じてEmacsサーバーに接続するためのserverファイル(@ref{TCP Emacs
server}を参照)を指定します。かわりにserverファイルを示すように、環境変数@env{EMACS_SERVER_FILE}をセットできます(コマンドラインオプションは、環境変数をオーバーライドする)。

Emacsサーバーは通常は接続にたいしてローカルソケットをlistenしますが、TCPを通じた接続もサポートします。TCPによりEmacsサーバーに接続するためには、@command{emacsclient}がEmacsサーバーへの接続に関する詳細を含む@dfn{serverファイル(server
file)}を読み込む必要があります。このオプションでserverファイル名を指定します。これは@file{~/.emacs.d/server}からの相対ファイル名か、絶対ファイル名です。@ref{TCP
Emacs server}を参照してください。

@item -n
@itemx --no-wait
すべてのサーバーバッファーが終了するのを待つかわりに、@command{emacsclient}が即座に終了するようにします。Emacsのサーバーバッファーで編集したいときに、このオプションを指定します。@kbd{C-x
#}をタイプしても、これらはkillされません。

@item -w
@itemx --timeout=@var{N}
Emacsからの応答を諦めるまで@var{N}秒待機します。この待機の間に応答がなければ、@command{emacsclient}は警告を表示してexitします。デフォルトの@samp{0}は永遠に待機することを意味します。

@item --parent-id=@var{id}
XEmbedプロトコルを通じて、IDが@var{id}の親Xウィンドウでクライアントフレームとして、@command{emacsclient}フレームをオープンします。現在のところ、これは主に開発者に有用なオプションです。

@item -q
@itemx --quiet
@command{emacsclient}がEmacsを待つメッセージ、またはリモートのサーバーソケットに接続するメッセージを表示しないようにします。

@item -u
@itemx --suppress-output
サーバーからリターンされた結果を、@command{emacsclient}が表示しないようにします。これは主に@samp{-e}と併用し、評価が結果ではなく副作用を目的としているとき有用です。

@item -s @var{server-name}
@itemx --socket-name=@var{server-name}
名前が@var{server-name}のEmacsサーバーに接続します(このオプションはMS-Windowsではサポートされない)。サーバー名は、Emacsサーバー上の変数@code{server-name}により与えられます。このオプションが省略された場合、@command{emacsclient}はデフォルトソケットに接続します。Emacsサーバーの@code{server-name}に絶対ファイル名をセットした場合は、@command{emacsclient}がそのサーバーに接続するよう指示するために、@var{server-name}に同じ絶対ファイル名を与えてください。Emacsをデーモンとして開始(@ref{Initial
Options}を参照)して、そのデーモンにより開始されたサーバーに名前を指定した場合には、このオプションを使用する必要があります。

かわりにserverソケットを示すように、環境変数@env{EMACS_SOCKET_NAME}をセットできます(コマンドラインオプションは環境変数をオーバーライドする)。

@item -t
@itemx --tty
@itemx -nw
既存のEmacsフレームを使うかわりに、カレントテキスト端末に新たなクライアントフレームを作成します。これはテキスト端末のフレームを作成する点を除き、上記で説明した@samp{-c}と同じように振る舞います(@ref{Text
Terminals}を参照してください)。

MS-Windowsでは、Emacsサーバーがグラフィカルなディスプレイを使っている場合は@samp{-c}のように振る舞いますが、Emacsサーバーがテキスト端末で実行されている場合は、カレントテキスト端末に新たなフレームを作成します。

@item -T @var{tramp-prefix}
@itemx --tramp-prefix=@var{tramp-prefix}
EmacsがTRAMP (@ref{Top, The Tramp Manual,, tramp, The Tramp
Manual}を参照)を使用してリモートマシンにファイルを配すとき(@ref{Remote
Files}を参照)、ファイル名に追加されるプレフィクスをセットします。これは主に、TCP上でのEmacsサーバーの使用と併用すると有用です(@ref{TCP
Emacs
server}を参照)。listenするポートをsshフォワードして、リモートマシンで@var{server-file}を利用可能にすることにより、リモートマシン上のプログラムは@env{EDITOR}、および同種の環境変数にたいする値に@command{emacsclient}を使用できますが、リモートマシンからEmacsサーバーと通信するかわりに、そのファイルはTRAMPを使用してローカルのEmacsセッションによりvisitされます。

@vindex EMACSCLIENT_TRAMP@r{, environment variable}
環境変数@env{EMACSCLIENT_TRAMP}は、@samp{-T}オプションと同じ効果をもちます。両方が指定された場合は、コマンドラインのオプションが優先されます。

たとえば２つのホスト@samp{local}および@samp{remote}があり、ローカルのEmacsはTCPポート12345をlistenしているとします。さらに@file{/home}が共有ファイルシステム上にあるとすると、serverファイル@file{~/.emacs.d/server/server}は両方のホストから読み込めることになります。

@example
local$ ssh -R12345:localhost:12345 remote
remote$ export EDITOR="emacsclient \
        --server-file=server \
        --tramp=/ssh:remote:"
remote$ $EDITOR /tmp/foo.txt #Should open in local emacs.
@end example

@end table

  オプション@samp{-c}または@samp{-t}で作成された、グラフィカルなフレームおよびテキスト端末のフレームは、@dfn{クライアントフレーム(client
frames)}とみなされます。クライアントフレームから作成した新たなフレームも、クライアントフレームとみなされます。クライアントフレームで@kbd{C-x
C-c}
(@code{save-buffers-kill-terminal})とタイプした場合、それが通常行なうようなEmacsセッションのkill(@ref{Exiting}を参照してください)は行なわれません。かわりにEmacsはクライアントフレームを削除します。さらに、制御を取り戻すために待っている@command{emacsclient}をクライアントフレームがもつ場合(たとえば@samp{-n}オプションを与えなかった場合)、Emacsは同じくクライアントの他のすべてのフレームを削除し、(それらすべてにたいして@kbd{C-x
#}をタイプしたかのように)クライアントのサーバーバッファーが終了したとマークします。クライアントフレームが削除された後、残ったフレームが存在しない場合、Emacsセッションは終了します。

  例外として、Emacsがデーモンとして開始された場合、すべてのフレームはクライアントフレームとみなされ、@kbd{C-x
C-c}がEmacsをkillすることはありません。デーモンセッションを終了するには、@kbd{M-x kill-emacs}とタイプします。

  @samp{-t}と@samp{-n}は、矛盾するオプションであることに注意してください。@samp{-t}はカレントテキスト端末に新たにクライアントフレームを作成して制御することを指示し、@samp{-n}はテキスト端末で制御を行なわないことを指示するからです。両方のオプションを与えた場合、@samp{-t}の効果は打ち消されて、Emacsは新たにフレームを作成せず、既存のフレームで指定されたファイルをvisitします。

@node Printing
@section ハードコピーの印刷
@cindex hardcopy
@cindex printing

  Emacsは、バッファーの全体、または一部のハードコピーを印刷するコマンドを提供します。以下で詳しく述べるとおり、直接印刷コマンドを呼び出したり、メニューバーの@samp{File}メニューを使うことができます。

@findex htmlfontify-buffer
  このセクションで説明するコマンドとは別に、Dired(@ref{Operating on
Files}を参照してください)からハードコピーを印刷したり、ダイアリー(@ref{Displaying the
Diary}を参照してください)から印刷することもできます。コマンド@kbd{M-x
htmlfontify-buffer}で、EmacsバッファーをHTMLに``印刷''することもできます。これはEmacsのフェイスをCSSベースのマークアップに置換して、カレントバッファーをHTMLに変換します。さらにOrgモード(@ref{Org
Mode}を参照してください)では、OrgファイルをPDFのような様々なフォーマットに印刷できます。

@table @kbd
@item M-x print-buffer
ファイル名を含むページヘッダーとともに、カレントバッファーのハードコピーを印刷します。
@item M-x lpr-buffer
ページヘッダーなしで、カレントバッファーのハードコピーを印刷します。
@item M-x print-region
@code{print-buffer}と同様ですが、カレントリージョンだけを印刷します。
@item M-x lpr-region
@code{lpr-buffer}と同様ですが、カレントリージョンだけを印刷します。
@end table

@findex print-buffer
@findex print-region
@findex lpr-buffer
@findex lpr-region
@vindex lpr-switches
@vindex lpr-commands
  ほとんどのオペレーティングシステムでは、上記のハードコピーコマンドは、@command{lpr}プログラムを呼び出して、印刷のためにファイルをサブミットします。印刷プログラムを変更するには、変数@code{lpr-command}をカスタマイズします。追加のスイッチを指定して、印刷プログラムにに与えるには、リスト変数@code{lpr-switches}をカスタマイズします。この変数の値はオプション文字列のリストで、それぞれが@samp{-}で始まります(たとえばオプション文字列@code{"-w80"}は1行に80列を指定します)。デフォルトは、空リスト@code{nil}です。

@vindex printer-name
@vindex lpr-printer-switch
  使用するプリンターを指定するには、変数@code{printer-name}をセットします。デフォルトは@code{nil}で、これはデフォルトプリンターを指定します。これにプリンター名(文字列)をセットした場合、その名前は@samp{-P}スイッチとともに@command{lpr}に渡されます。@command{lpr}コマンドを使用しない場合は、スイッチを@code{lpr-printer-switch}で指定する必要があります。

@vindex lpr-headers-switches
@vindex lpr-add-switches
  同様に変数@code{lpr-headers-switches}は、ページヘッダーを作成するために使用する追加のスイッチを指定します。変数@code{lpr-add-switches}は、印刷プログラムに@samp{-T}および@samp{-J}オプション(@command{lpr}向きのオプションです)を渡すかどうかを制御します。@code{nil}は、これらを追加しないことを意味します(印刷プログラムが@command{lpr})互換でない場合は、この値を使用するべきです)。

@menu
* PostScript::               バッファーまたはリージョンを、PostScriptとして印刷する。
* PostScript Variables::     PostScript印刷コマンドのカスタマイズ。
* Printing Package::         オプションの上級向け印刷インターフェース。
@end menu

@node PostScript
@subsection PostScriptのハードコピー

  これらのコマンドはバッファーの内容をPostScriptに変換して、それを印刷または別のEmacsバッファーに出力します。

@table @kbd
@item M-x ps-print-buffer
PostScript形式で、カレントバッファーのハードコピーを印刷します。
@item M-x ps-print-region
PostScript形式で、カレントリージョンのハードコピーを印刷します。
@item M-x ps-print-buffer-with-faces
PostScript形式で、カレントバッファーのハードコピーを印刷し、テキストで使用されているフェイスはPostScript機能により表示します。
@item M-x ps-print-region-with-faces
PostScript形式で、カレントリージョンのハードコピーを印刷し、テキストで使用されているフェイスで表示します。
@item M-x ps-spool-buffer
カレントバッファーのテキストにたいするPostScriptイメージを生成およびスプールします。
@item M-x ps-spool-region
カレントリージョンにたいするPostScriptイメージを生成およびスプールします。
@item M-x ps-spool-buffer-with-faces
カレントバッファーにたいするPostScriptイメージを生成およびスプールし、使用されているフェイスで表示します。
@item M-x ps-spool-region-with-faces
カレントリージョンにたいするPostScriptイメージを生成およびスプールし、使用されているフェイスで表示します。
@item M-x ps-despool
Send the spooled PostScript to the printer.
@item M-x handwrite
カレントバッファーにたいして、手書きされたようなPostScriptを生成・印刷します。
@end table

@findex ps-print-region
@findex ps-print-buffer
@findex ps-print-region-with-faces
@findex ps-print-buffer-with-faces
  @code{ps-print-buffer}および@code{ps-print-region}コマンドは、バッファーの内容をPostScript形式で印刷します。一方はバッファー全体を印刷し、もう一方はリージョンだけを印刷します。コマンド@code{ps-print-buffer-with-faces}および@code{ps-print-region-with-faces}も同様に振る舞いますが、バッファーテキストのフェイス(フォントとカラー)を表示するためにPostScript機能を使用します。

  プレフィクス引数(@kbd{C-u})を使用した場合、これらのコマンドは対話的にユーザーにファイル名の入力を求め、PostScriptイメージをプリンターに送るかわりに、そのファイルに保存します。

@findex ps-spool-region
@findex ps-spool-buffer
@findex ps-spool-region-with-faces
@findex ps-spool-buffer-with-faces
  @samp{print}のかわりに@samp{spool}が名前につくコマンドは、PostScript出力をプリンターに送るかわりに、Emacsバッファーに出力することを意味します。

@findex ps-despool
  コマンド@code{ps-despool}を使用して、スプールされたイメージをプリンターに送ります。このコマンドは@samp{-spool-}コマンド(上記コマンド参照)により生成されたPostScriptをプリンターに送ります。プレフィクス引数(@kbd{C-u})を指定した場合は、ファイル名の入力を求め、スプールされたPostScriptイメージをプリンターに送るかわりに、そのファイルに保存します。

@findex handwrite
@cindex handwriting
  @kbd{M-x
handwrite}はもっと他愛ない機能です。これはカレントバッファーのPostScript表現を、草書体の手書きドキュメントのように生成します。これはグループ@code{handwrite}でカスタマイズできます。この関数はISO
8859-1文字だけサポートします。

@node PostScript Variables
@subsection PostScriptハードコピーにたいする変数

@vindex ps-lpr-command
@vindex ps-lpr-switches
@vindex ps-printer-name
  すべてのPostScriptハードコピーコマンドは、どのように出力を印刷するかの指定に、変数@code{ps-lpr-command}と@code{ps-lpr-switches}を使用します。@code{ps-lpr-command}は実行するコマンド名、@code{ps-lpr-switches}は使用するコマンドラインオプション、@code{ps-printer-name}はプリンターを指定します。最初の2つの変数をセットしない場合、変数の初期値を@code{lpr-command}と@code{lpr-switches}から取得します。@code{ps-printer-name}が@code{nil}の場合、@code{printer-name}が使用されます。

@vindex ps-print-header
  変数@code{ps-print-header}は、これらのコマンドが各ページにヘッダー行を追加するかを制御します。これを@code{nil}にセットするとヘッダーはオフになります。

@cindex color emulation on black-and-white printers
@vindex ps-print-color-p
  プリンターがカラーをサポートしない場合は、@code{ps-print-color-p}を@code{nil}にセットして、カラー処理をオフにするべきです。デフォルトでは、ディスプレイがカラーをサポートしていれば、Emacsはカラー情報をもったハードコピー出力を生成します。モノクロプリンターでは、カラーはグレーの濃淡でエミュレートされます。スクリーンカラーがグレーの濃淡だけしか使用していなくても、これはほとんど読み取れないか、読みにくい出力を生成するかもしれません。

@vindex ps-black-white-faces
  モノクロプリンターでより良いカラー表示を得るために、@code{ps-print-color-p}に@code{black-white}をセットすることもできます。これはboldとitalicのフェイス属性で補強された、カスタマイズ可能なグレースケールのリストによりカラーを表現するための@code{ps-black-white-faces}お情報を使用することにより機能します。

@vindex ps-use-face-background
  デフォルトでは、変数@code{ps-use-face-background}が非@code{nil}でなければ、PostScript印刷はフェイスのバックグラウンドカラーは無視します。これは望ましくないゼブラストライプや、バックグラウンドイメージとテキストの干渉を避けるためです。

@vindex ps-paper-type
@vindex ps-page-dimensions-database
  変数@code{ps-paper-type}は、フォーマットする用紙サイズを指定します。妥当な値には@code{a4}、@code{a3}、@code{a4small}、@code{b4}、@code{b5}、@code{executive}、@code{ledger}、@code{legal}、@code{letter}、@code{letter-small}、@code{statement}、@code{tabloid}が含まれます。デフォルトは@code{letter}です。変数@code{ps-page-dimensions-database}を変更することにより、追加の用紙サイズを定義できます。

@vindex ps-landscape-mode
  変数@code{ps-landscape-mode}は、ページの印刷向きを指定します。デフォルトは@code{nil}で、これは縦向き印刷モード(portrait
mode)を意味します。非@code{nil}値は横向き印刷モード(landscape mode)を指定します。

@vindex ps-number-of-columns
  変数は列番号を指定します。この変数は横向きモードと縦向きモードの両方で効果をもちます。デフォルトは1です。

@vindex ps-font-family
@vindex ps-font-size
@vindex ps-font-info-database
  変数@code{ps-font-family}は、通常のテキストを印刷するために使用するフォントファミリーを指定します。妥当な値には、@code{Courier}、@code{Helvetica}、@code{NewCenturySchlbk}、@code{Palatino}、@code{Times}が含まれます。変数@code{ps-font-size}は、通常のテキストのためのフォントサイズを指定し、デフォルトは8.5ポイントです。@code{ps-font-size}の値には、2つの浮動小数点によるコンスでも指定できます。その場合、1つは縦向き印刷モード、もう一方は横向き印刷モードでの指定です。

@vindex ps-multibyte-buffer
@cindex Intlfonts for PostScript printing
@cindex fonts for PostScript printing
  Emacsは、通常のPostScriptプリンターより多くのスクリプトと文字をサポートします。したがってバッファーのいくつかの文字は、プリンターに組み込まれたフォントを使って印刷できないかもしれません。プリンターが提供するフォントをGNU
Intlfontsパッケージのフォントで増強したり、EmacsにIntlfontsフォントだけを使うように命令できます。変数@code{ps-multibyte-buffer}がこれを制御します。デフォルト値の@code{nil}は、@acronym{ASCII}およびLatin-1文字を印刷するのに適しています。@code{non-latin-printer}は、プリンターに@acronym{ASCII}、Latin-1、Japanese、Korean文字にたいするフォントが組み込まれている場合の値です。@emph{すべて}の文字にたいして使用される、IntlfontsパッケージのBDFフォントのための値が@code{bdf-font}です。最後に値@code{bdf-font-except-latin}は、@acronym{ASCII}およびLatin-1文字にたいしては組み込みフォントを使用し、それ以外の文字にたいしてはIntlfontsのBDFフォントを使用するよう指示します。

@vindex bdf-directory-list
  BDFフォントを使えるようにするには、それをどこで見つけることができるかを、Emacsが知る必要があります。変数@code{bdf-directory-list}は、Emacsがこれらのフォントを探すべきディレクトリーのリストを保持します。デフォルト値には、1つのディレクトリー@file{/usr/local/share/emacs/fonts/bdf}が含まれます。

  これらのコマンドに対する、その他多くのカスタマイズ変数は、Lispファイル@file{ps-print.el}および@file{ps-mule.el}で定義・説明されています。

@node Printing Package
@subsection 印刷のためのパッケージ
@cindex Printing package

  ハードコピーを印刷するためのEmacsの基本的な機能は、Printingパッケージを使って拡張できます。これは何を印刷するかの選択、印刷前のPostScriptファイルのプレビュー、プリントヘッダーなどのさまざまな印刷オプションの設定、横向きモードや縦向きモード、duplexモードにたいする使いやすいインターフェースを提供します。GNU/LinuxシステムまたはUnixシステムでは、Printingパッケージは、GhostScriptプログラムの一部として配布される、@file{gs}および@file{gv}ユーティリティーに依存しています。MS-Windowsでは、Ghostscriptのポート版の@file{gstools}が使用されます。

@findex pr-interface
  Printingパッケージを使用するには、initファイル(@ref{Init File}を参照してください)に@code{(require
'printing)}を追加して、その後に@code{(pr-update-menus)}と記述します。この関数はメニューバーの通常の印刷コマンドを、さまざまな印刷オプションを含む@samp{Printing}サブメニューに置き換えます。@kbd{M-x
pr-interface @key{RET}}とタイプすることもできます。これはカスタマイズバッファーに似た@file{*Printing
Interface*}バッファーを作成し、そこで印刷オプションをセットできます。何をどのようにして印刷するかセットした後、@samp{Print}ボタン(それを@kbd{mouse-2}でクリックするか、その上にポイントを移動して@key{RET}をタイプします)で印刷ジョブを開始します。さまざまなオプションについての詳細は、@samp{Interface
Help}ボタンを使用してください。

@node Sorting
@section テキストのソート
@cindex sorting

  Emacsは、バッファーのテキストをソートするためのコマンドをいくつか提供しています。これらはすべて、リージョンの内容にたいして処理を行ないます。これらのコマンドはリージョンのテキストを、多数の@dfn{ソートレコード(sort
records)}に分割し、各レコードを@dfn{ソートキー(sort
key)}で識別した後、ソートキーにより決定される順序にレコードを並び替えます。レコードは並び替えられ、レコードのキーはアルファベット順、または数値ソートでは数値順になります。アルファベット順のソートでは、@acronym{ASCII}文字順にしたがい、@samp{A}から@samp{Z}のすべての大文字は、小文字の@samp{a}の前になります。(しかし、以下で説明する@code{sort-fold-case}はこれを変更する)。

  種々のソートコマンドは、テキストをどのようにソートレコードに分割するか、そして各レコードのどの部分がソートキーとして使用されるかという点で異なります。ほとんどのコマンドは行ごとにソートレコードを分割しますが、ソートレコードとしてパラグラフやページを使うコマンドもあります。ほとんどのソートコマンドは、ソートレコード全体をソートキーとして使用しますが、レコードの一部をソートキーとして使用するものもあります。

@findex sort-lines
@findex sort-paragraphs
@findex sort-pages
@findex sort-fields
@findex sort-numeric-fields
@vindex sort-numeric-base
@table @kbd
@item M-x sort-lines
リージョンを行に分割して、行のテキスト全体を比較してソートします。数引数は降順でソートすることを意味します。

@item M-x sort-paragraphs
リージョンをパラグラフに分割して、パラグラフのテキスト全体(先頭の空行は除く)を比較してソートします。数引数は降順にソートすることを意味します。

@item M-x sort-pages
リージョンをページに分割して、ページのテキスト全体(先頭の空行は除く)を比較してソートします。数引数は降順にソートすることを意味します。

@item M-x sort-fields
リージョンを行に分割して、各行のあるフィールドの内容を比較することによりソートします。フィールドは空白で区切ることにより定義されるので、ある行の最初の連続する非空白文字がフィールド1を構成し、2番目のそのような文字構成がフィールド2、...となります。

どのフィールドでソートするかは数引数で指定します。1はフィールド1、2はフィールド2、...となります。デフォルトは1です。負の引数はフィールドを左からではなく右から数えることを意味します。したがって、-1は最後のフィールドでソートするという意味です。ソートされるフィールドの内容が同じ行が複数存在する場合、バッファーの元の並び順が維持されます。

@item M-x sort-numeric-fields
@kbd{M-x
sort-fields}と同様ですが、各行の指定されたフィールドを整数に変換して、その数字を比較します。テキストとして比較したとき@samp{10}は@samp{2}の前になりますが、数字として比較すると@samp{2}の後になります。デフォルトでは、数字は@code{sort-numeric-base}により解釈されますが、@samp{0x}または@samp{0}で始まる数字は16進および8進で解釈されます。

@item M-x sort-columns
@kbd{M-x
sort-fields}と同様ですが、各行で比較に使用されるテキストは固定長の列範囲です。プレフィクス引数を指定した場合は、逆順でソートします。このコマンドの詳細は以下を参照してください。

@findex reverse-region
@item M-x reverse-region
リージョンの行を逆順にソートします。フィールドでソートするコマンドは降順でソートする機能がないので、フィールドまたは列で降順にソートできるのは便利です。
@end table

  たとえば、以下のようなバッファー内容のとき:

@smallexample
On systems where clash detection (locking of files being edited) is
implemented, Emacs also checks the first time you modify a buffer
whether the file has changed on disk since it was last visited or
saved.  If it has, you are asked to confirm that you want to change
the buffer.
@end smallexample

@noindent
バッファー全体に@kbd{M-x sort-lines}を適用すると以下のようになります:

@smallexample
On systems where clash detection (locking of files being edited) is
implemented, Emacs also checks the first time you modify a buffer
saved.  If it has, you are asked to confirm that you want to change
the buffer.
whether the file has changed on disk since it was last visited or
@end smallexample

@noindent
大文字の@samp{O}はすべての小文字の前にソートされます。かわりに@kbd{C-u 2 M-x
sort-fields}を使用すると、以下が得られます:

@smallexample
implemented, Emacs also checks the first time you modify a buffer
saved.  If it has, you are asked to confirm that you want to change
the buffer.
On systems where clash detection (locking of files being edited) is
whether the file has changed on disk since it was last visited or
@end smallexample

@noindent
ここで、ソートキーは@samp{Emacs}、@samp{If}、@samp{buffer}、@samp{systems}、@samp{the}です。

@findex sort-columns
  @kbd{M-x
sort-columns}は説明が必要でしょう。ある列にポイントを配し、別の列をマークして、ソート列を指定します。ソートしたいテキストの最初の行の先頭にポイントまたはマークを配すことはできないので、このコマンドは特殊な``リージョン''の定義を使用します。ポイントがある行はすべてリージョンの一部と判断されます。マークがある行もすべてリージョンの一部と判断されます。同様にその間にあるすべての行もリージョンの一部となります。

  たとえば、10列目から15列目までの情報でテーブルをソートするには、テーブルの最初の行の10列目にマークを置き、最後の行の15列目にポイントを置いて、@code{sort-columns}を実行します。最初の行の15列目にマークを置き、最後の行の10列目にポイントを置いても、同じように実行できます。

  これはポイントとマークで指定された矩形領域をソートすると考えることができます。1つ違うのは、各行の矩形領域の左右にあるテキストも、矩形領域内のテキストとともに移動するという点です。@ref{Rectangles}を参照してください。

@vindex sort-fold-case
  @code{sort-fold-case}が非@code{nil}の場合、多くのソートコマンドは比較時の大文字小文字の違いを無視します。

@c Picture Mode documentation
@ifnottex
@include picture-xtra-ja.texi
@end ifnottex


@node Editing Binary Files
@section バイナリーファイルの編集

@cindex Hexl mode
@cindex mode, Hexl
@cindex editing binary files
@cindex hex editing
  バイナリーファイルを編集する特別なメジャーモードに、Hexlモードがあります。これを使用するには、ファイルをvisitするために@kbd{C-x
C-f}のかわりに、@kbd{M-x
hexl-find-file}を使用します。このコマンドはファイル内容を16進に変換して、その変換結果を編集できるようにします。ファイルを保存するときは、自動的にバイナリーに変換されます。

  既存のバッファーを16進(hex)に変換するために、@kbd{M-x
hexl-mode}を使用することもできます。これは普通にファイルをvisitしてから、それがバイナリーファイルだと気づいた場合などに便利です。

  Hexlモードでは、テキスト挿入は常に上書きとなります。これは、アクシデントによりファイル内データのアラインメントを破壊する危険を軽減します。通常のテキスト文字は、それらの文字自身をを挿入(それらの文字で上書き)します。文字コードにより特殊文字を挿入するコマンドあります。Hexlモードでは、ほとんどのカーソル移動キー、同様に@kbd{C-x
C-s}は、同じ効果を生むコマンドにバインドされています。以下は、特にHexlモードで重要なその他コマンドです:

@c I don't think individual index entries for these commands are useful--RMS.
@table @kbd
@item C-M-d
10進でタイプされたバイトコードを挿入します。

@item C-M-o
8進でタイプされたバイトコードを挿入します。

@item C-M-x
16進でタイプされたバイトコードを挿入します。

@item C-M-a
512バイトページの先頭に移動します。

@item C-M-e
512バイトページの最後に移動します。

@item C-x [
1Kバイトページの先頭に移動します。

@item C-x ]
1Kバイトページの最後に移動します。

@item M-g
16進で指定されたアドレスに移動します。

@item M-j
10進で指定されたアドレスに移動します。

@item C-c C-c
Hexlモードを抜けて、@code{hexl-mode}モードを呼び出す前の、このバッファーのメジャーモードに戻ります。
@end table

@noindent
他のHexlコマンドには、バイナリーバイトの文字列(シーケンス)の挿入、@code{short}、@code{int}単位での移動などがあります。詳細については、@kbd{C-h
a hexl- @key{TAB}}とタイプしてください。

  Hexlモードをテキストファイルの編集にも使えます。これはテキストファイルに変わった文字が含まれていたり、変わったエンコーディング(@ref{Coding
Systems}を参照)が使用されている場合に便利かもしれません。この目的用にバイトを挿入するHexlコマンドは@acronym{ASCII}文字、およびマルチバイト文字を含む非@acronym{ASCII}文字も挿入できます。Hexlでテキストファイルを編集するには通常通りにファイルをvisitしてから、@w{@kbd{M-x
hexl-mode
@key{RET}}}とタイプしてHexlモードに切り替えます。これでテキスト文字をタイプして挿入することができます。しかし無効なマルチバイトシーケンスを作成する危険を避けるために、マルチバイト文字の挿入には特別な配慮が必要です。ファイル中のマルチバイトシーケンスの開始バイトにポイントがあるときに、そのような文字のタイプを開始する必要があります。

@node Saving Emacs Sessions
@section Emacsセッションの保存
@cindex saving sessions
@cindex restore session
@cindex remember editing session
@cindex reload files

@cindex desktop configuration
  デスクトップライブラリーを使用して、あるセッションから別のセッションにEmacsの状態を保存することができます。保存されるEmacsの@dfn{デスクトップ構成(desktop
configuration)}にはバッファーとそのファイル名、メジャーモード、バッファー位置、ウィンドウおよびフレームの構成、それにいくつかの重要なグローバル変数が含まれます。

@vindex desktop-save-mode
@findex desktop-save-mode
  この機能を有効にするにはCustomizationバッファー(@ref{Easy
Customization}を参照)を使用して@code{desktop-save-mode}を@code{t}にセットするか、initファイル(@ref{Init
File}を参照)に以下の行を追加します:

@example
(desktop-save-mode 1)
@end example

@vindex desktop-path
@vindex desktop-auto-save-timeout
  initファイルで@code{desktop-save-mode}をオンにしていれば、Emacsが起動時に@code{desktop-path}
(デフォルトはまず@code{user-emacs-directory}、次にホームディレクトリー)から保存されたデスクトップを探して、見つかった最初のデスクトップを使用します。@code{desktop-save-mode}がオンの状態でEmacsが実行されている間は、デスクトップ構成の変更時は常にデスクトップが自動的に保存されます。Emacsがデスクトップの変更をチェックする頻度は、変数@code{desktop-auto-save-timeout}によって決定されます。デスクトップはEmacsをexitする際にも保存されます。

@cindex disable restoring of desktop configuration
  保存されたデスクトップ構成をリロードしたくないときは、Emacsを実行するコマンドラインでオプション@samp{--no-desktop}を指定します。これはカレントセッションにたいして、@code{desktop-save-mode}をオフにします。@samp{--no-init-file}オプションを指定してEmacsを開始することにより、通常@code{desktop-save-mode}をオンにしているinitファイルをバイパスして、デスクトップのリロードを無効にすることもできます。

@findex desktop-change-dir
@findex desktop-revert
  別のディレクトリーに別個にデスクトップ構成を保存することができます。@code{desktop-path}にセットされているディレクトリーの前に@file{.}
(カレントディレクトリー)を追加するようカスタマイズすることによって、保存済みのデスクトップ構成のあるディレクトリーからEmacsを起動した際にその構成がリストアされるようになります。@kbd{M-x
desktop-change-dir}とタイプすれば、カレントのデスクトップを保存して別のディレクトリーに保存されているデスクトップをリストアできます。前にリロードしたデスクトップをリバートするには@kbd{M-x
desktop-revert}とタイプしてください。

@vindex desktop-load-locked-desktop
  Emacsがデスクトップを保存するファイルは、他のEmacsセッションによる意図せぬ上書きを防ぐためにそのセッションの実行中はロックされます。このロックは通常はEmacsのexit時に解除されますが、Emacsまたはシステムがクラッシュするとそのロックが残ってしまい、デフォルトではEmacsの再起動時にロックされたデスクトップファイルのどちらを使用するか尋ねます。この質問は変数@code{desktop-load-locked-desktop}を@code{nil}
(デスクトップをロードしない)、または@code{t}
(確認なしでデスクトップをロードする)のいずれかにカスタマイズすることにより抑止できます。@code{check-pid}という特別な値にカスタマイズすることもできます。これはローカルマシン上でそのデスクトップをロックしたEmacsが実行されていなければそのファイルをロードすることを意味します。この値はロックしたEmacsが別のマシンでまだ実行中という状況で使用するべきではありません。マルチユーザー環境において、NFS等を用いてホームディレクトリーがリモートにマウントされているのかもしれません。

@cindex desktop restore in daemon mode
  Emacsがデーモンモードで起動する際にはユーザーに質問することができないので、ロックされたデスクトップが見つかっても@code{desktop-load-locked-desktop}が@code{t}以外であればロードしません。デーモンモードでのデスクトップのリストアは、その他の理由により問題になりがちなことに注意してください。たとえばデーモンはGUI機能を使用できないので、フレーム位置やサイズ、装飾のようなパラメーターはリストアできません。この理由により@code{server-after-make-frame-hook}にフック関数@code{desktop-read}
(下記参照)を追加して、それが呼び出されることにより最初のクライアントが接続するまで、デスクトップのリストアを遅延させたいと思うかもしれません(@ref{Creating
Frames,,, elisp, The Emacs Lisp Reference Manual}を参照)。

@findex desktop-save
@findex desktop-read
  カレントデスクトップを即座に強制的に保存したければ、任意のタイミングでコマンド@kbd{M-x
desktop-save}を使うことができます。これはデスクトップを自動リストアしたくないので@code{desktop-save-mode}をオンにしていない、あるいはデスクトップに重要な変更を施し、その構成をEmacsやシステムのクラッシュで失わないよう確実にしたい場合に役に立ちます。Emacsのカレントセッションがまだデスクトップを何もロードしていなければ、@kbd{M-x
desktop-read}を使用して以前に保存したデスクトップをリストアできます。

@vindex desktop-restore-frames
  デフォルトでは、デスクトップはフレームとウィンドウの構成の保存とリストアを試みます。これを無効にするには、@code{desktop-restore-frames}を@code{nil}にセットしてください(この振る舞いを調整するためにマスタマイズできる関連オプションについては変数のドキュメントを参照のこと)。

@vindex frameset-filter-alist
  desktopがフレームとウィンドウの設定をリストアするときは、フレームパラメーターの記録された値を使用します。initファイル(@ref{Init
File}を参照)でそれらのパラメーターに何をセットしていても無視されます。これは、リストアされたフレームにたいするフォントやフェイスのようなフレームパラメーターは、前のEmacsセッションを終了したときに保存されたdesktopファイルから取得され、initファイルでのそれらのパラメーターにたいするセッティングは無視されることを意味します。これを無効にするには、リストアしたくないフレームパラメーターを除外するように、@code{frameset-filter-alist}の値をカスタマイズしてください。その後はinitファイルで行ったカスタマイズに応じてパラメーターがセットされる筈です。

@vindex desktop-files-not-to-save
  デフォルトでは、リモートファイルをvisitしているバッファーに関する情報は保存されません。変数@code{desktop-files-not-to-save}をカスタマイズして、これを変更することができます。

@vindex desktop-restore-eager
  デフォルトでは、デスクトップのすべてのバッファーは1度に復元されます。しかし、デスクトップにたくさんのバッファーがあるときは遅くなるかもしれません。変数@code{desktop-restore-eager}で、即座に復元するバッファーの最大数を指定できます。残りのバッファーはEmacsのアイドル時に、ゆっくり(lazily)と復元されます。

@findex desktop-clear
@vindex desktop-globals-to-clear
@vindex desktop-clear-preserve-buffers-regexp
  Emacsのデスクトップを空にするには、@kbd{M-x desktop-clear}とタイプします。これはたとえば次に@kbd{M-x
desktop-read}を呼び出して別のデスクトップに切り替えたい場合に役に立つかもしれません。@code{desktop-clear}コマンドは内部バッファーを除くすべてのバッファーをkillして、@code{desktop-globals-to-clear}にリストされたグローバル変数をクリアーします。特定のバッファーを残したい場合は、変数@code{desktop-clear-preserve-buffers-regexp}をカスタマイズします。この変数の値には、killしないバッファーの名前にマッチする正規表現を指定します。

@vindex desktop-globals-to-save
  あるセッションから別のセッションにミニバッファーのヒストリーを保存したければ、@code{savehist}ライブラリーを使用してください。選択されているミニバッファーヒストリーの変数を@code{desktop-globals-to-save}の値として追加して、@code{desktop-save-mode}に属する変数として保存することもできます。

@node Recursive Edit
@section 再帰編集レベル
@cindex recursive editing level
@cindex editing level, recursive

  @dfn{再帰編集(recursive
edit)}とは、あるEmacsコマンドの途中で、別のEmacsコマンドを使用して自由に編集を行なうような状況を指します。たとえば@code{query-replace}の途中で@kbd{C-r}をタイプすると、カレントバッファーを変更することができる再帰編集に入ります。再帰編集から抜けると、@code{query-replace}に戻ります。@ref{Query
Replace}を参照してください。

@kindex C-M-c
@findex exit-recursive-edit
@cindex exiting recursive edit
  再帰編集を@dfn{抜ける(exit)}とは、実行を継続中の、終了していないコマンドに戻ることを意味します。再帰編集を抜けるコマンドは@kbd{C-M-c}
(@code{exit-recursive-edit})です。

  再帰編集を@dfn{中断(abort)}することもできます。これはexitと似ていますが、終了していないコマンドも即座に終了します。これを行なうには、コマンド@kbd{C-]}
(@code{abort-recursive-edit})を使用します。@ref{Quitting}を参照してください

  モードラインで常にメジャーモードとマイナーモードの周りを囲む丸カッコ(parentheses)を、さらに角カッコ(square
brackets)で囲んで表示することにより、再帰編集中であることが示されます。再帰編集は特定のウィンドウやバッファーにたいするものではなく、Emacs全体が再帰編集中であるため、すべてのウィンドウのモードラインは同じように表示されます。

  再帰編集中に、さらに再帰編集に入ることも可能です。たとえば@code{query-replace}の途中で@kbd{C-r}とタイプした後、デバッガーに入るコマンドをタイプしたとします。これは@kbd{C-r}にたいする再帰編集レベルから、デバッガーにたいする再帰編集を開始します。モードラインには、現在進行中の再帰編集レベルが角カッコのペアで表示されます。

  (デバッガーでの@kbd{c}コマンドのように)内側の再帰編集を抜けると、次に上のレベルのコマンドの実行が再開されます。コマンドが終了したら、他の再帰編集レベルに抜けるために@kbd{C-M-c}を使用することができます。exitは最内レベルだけに適用されます。abortも1レベルの再帰編集だけを抜けて、前の再帰編集レベルのコマンドに即座に戻ります。もし望むなら次の再帰編集レベルもabortできます。

  かわりにコマンド@kbd{M-x
top-level}は、すべてのレベルの再帰編集をabortして、即座にトップレベルのコマンドリーダーに戻ります。ミニバッファーがアクティブなときは、ミニバッファーも抜けます。

  再帰編集の中で編集されるテキストは、トップレベルで編集しているテキストと同じである必要はありません。これは、何にたいしての再帰編集かに依存します。再帰編集を呼び出したコマンドが最初に別のバッファーを選択する場合、そのバッファーが再帰編集を行なうバッファーになります。どんな場合でも再帰編集中に、(バッファーを切り替えるキーがリバインドされていないかぎり)通常の方法でバッファーを切り替えることができます。再帰編集の中で、ファイルをvisitしたりその他のことを行ない、残りのすべての編集を行なうことも、おそらく可能です。しかしこれは、(スタックオーバーフローのような)驚くべき効果をもたらすことがあります。そのため必要なくなったときは、再帰編集をexitまたはabortすることを忘れないでください。

  一般的に、わたしたちはGNU Emacsでは再帰編集レベルを最小限にしようと努めています。これは、特定の順 ---
最内のレベルからトップレベルに向かって ---
で戻ることをあなたに強いるからです。可能な場合は、異なる作業には別のバッファーを供し、それらを切り替えられるようにします。いくつかのコマンドは、元のメジャーモードに戻るコマンドを提供する、新しいメジャーモードに切り替えます。これらの試みは、あなたの選択にしたがい、まだ終了していないタスクにもどる、柔軟性を与えます。


@node Hyperlinking
@section ハイパーリンクとWebナビゲーション機能

  以下のサブセクションでは、URLや、Emacsバッファーのテキスト内にある他の種類のリンクを扱う便利な機能を説明します。

@menu
* EWW::                      Emacs内のウェブブラウザ。
* Embedded WebKit Widgets::  Emacsバッファー内に埋め込まれたブラウザウィジェット。
* Browse-URL::               URLをフォローするには。
* Goto Address mode::        URLのアクティブ化について。
* FFAP::                     ポイント位置のファイルを探す、など。
@end menu

@node EWW
@subsection EWWによるウェブブラウズ

@findex eww
@findex eww-open-file
  @dfn{EWW}(Emacs Web
Wowser)は、Emacs用のウェブブラウザーのパッケージです。これはEmacsバッファーでURLブラウズすることを可能にします。コマンド@kbd{M-x
eww}により、URLを開いたり、ウェブを検索します。コマンド@kbd{M-x
eww-open-file}を使用して、ファイルを開くことができます。@code{browse-url}にたいするウェブブラウザーとして。EWWを使うことができます(@ref{Browse-URL}を参照してください)。完全な詳細に付いては、@ref{Top,
EWW,, eww, The Emacs Web Wowser Manual}を参照してください。

@node Embedded WebKit Widgets
@subsection 埋め込みWebKitウィジェット
@cindex xwidget
@cindex webkit widgets
@cindex embedded widgets

@findex xwidget-webkit-browse-url
@findex xwidget-webkit-mode
@cindex Xwidget-WebKit mode
  Emacsが適切なサポートパッケージとともにコンパイルされている場合、Emacsのバッファーにブラウザーウィジェット(browser
widgets)を表示できます。コマンド@kbd{M-x
xwidget-webkit-browse-url}は、ブラウザーウィジェットに表示するURLを尋ねます。通常はポイント位置、またはポイント位置の前にあるURLがデフォルトのURLになります。しかしアクティブなリージョン(@ref{Mark}を参照してください)がある場合は、余分な空白文字を削除してから、そのリージョンからデフォルトのURLを取得します。コマンドはその後、指定されたURLを表示するめ込みブラウザー(embedded
browser)をもつ、新しいバッファーを作成します。このパッファーはXwidget-WebKitモード(Imageモードと似ています。@pxref{Image
Mode}を参照してください)で、ウィジェットのスクロール、サイズ変更、リロードを1-keyで行なうコマンドを提供します。キーバインドを確認するには、そのバッファーで@w{@kbd{C-h
b}}とタイプしてください。

@findex xwidget-webkit-edit-mode
@cindex xwidget-webkit-edit-mode
  デフォルトではxwidgetのwebkitバッファー内部で自己挿入文字をタイプしても何も行われないか、あるいは何か特別なアクションがトリガーされます。これらの自己挿入文字やその他の一般的な編集キーが押されたらその文字が挿入されるようにするために、それらの文字をWebKit
xwidgetに渡すように再定義する@code{xwidget-webkit-edit-mode}を有効にできます。

xwidget
webkitバッファー内部で@kbd{e}をタイプして@code{xwidget-webkit-edit-mode}を有効にすることもできます。

@findex xwidget-webkit-isearch-mode
@cindex searching in webkit buffers
  @code{xwidget-webkit-isearch-mode}はインクリメンタル検索(@ref{Incremental
Search}を参照)のように振る舞いますが、カレントバッファーではなくWebKit
widgetのコンテンツを処理するマイナーモードです。xwidget-webkitバッファーの内部では@kbd{C-s}と@kbd{C-r}にバインドされています。@kbd{C-r}で呼び出されると初期の検索方向は逆向きに行われます。

任意の自己挿入文字列をタイプすることで、その文字がカレントけの問い合わせつき検索に挿入されます。WebKitウィジェットは@kbd{C-s}とタイプすれば次の検索結果、@kbd{C-r}なら前の検索結果を表示します。

インクリメンタル検索を終えるには@kbd{C-g}をタイプしてください。

@findex xwidget-webkit-browse-history
@cindex history of webkit buffers
  @code{xwidget-webkit-browse-history}はカレントのWebKitバッファーが以前にロードしたページを含むバッファーを表示して、@kbd{RET}を押してそれらのページに移動するためのコマンドです。

このコマンドは@kbd{H}にバインドされています。

@node Browse-URL
@subsection URLのフォロー
@cindex World Wide Web
@cindex Web
@findex browse-url
@findex browse-url-at-point
@findex browse-url-at-mouse
@cindex Browse-URL
@cindex URLs

@table @kbd
@item M-x browse-url @key{RET} @var{url} @key{RET}
ウェブブラウザーへのURLのロード。
@end table

  Browse-URLパッケージは、Emacsで簡単にURLをフォロー(辿る)することを可能にします。ほとんどのURLは、ウェブブラウザーを呼び出すことによりフォローされます。@samp{mailto:}のURLは、指定されたアドレスにメールを送るために、Emacsコマンドの@code{compose-mail}でフォローされます。

  コマンド@kbd{M-x
browse-url}は、URLの入力を求め、それをフォローします。ポイントがURLのようなテキストの近くにある場合、そのURLがデフォルトとして提示されます。Browse-URLパッケージは、@code{browse-url-at-point}や@code{browse-url-at-mouse}のような、キーにバインドしたいと思うような、他のコマンドも提供します。

@vindex browse-url-mailto-function
@vindex browse-url-browser-function
  Customizeグループ@code{browse-url}の、さまざまなオプションを通じて、Browse-URLの振る舞いをカスタマイズできます。特にオプション@code{browse-url-mailto-function}では@samp{mailto:}のURLをフォローする方法の定義、@code{browse-url-browser-function}ではデフォルトブラウザを指定します。詳細は@kbd{C-h
P browse-url @key{RET}}とタイプしてパッケージのコメントを参照してください。

@vindex browse-url-handlers
  @code{browse-url-handlers}をカスタマイズすることにより、特定のURLを他の関数で閲覧するように定義できます。これは正規表現か述語、およびマッチしたURLをブラウズするための関数のペアからなるalistです。

より詳細な情報は@kbd{C-h P browse-url @key{RET}}とタイプしてパッケージのコメントを参照してください。

@findex url-handler-mode
  Emacsには@acronym{URL}をファイルであるかのように処理するためのサポートをもつマイナーモードもあります。@code{url-handler-mode}はファイル名を扱うEmacsのほとんどのコマンドとプリミティブに効果があります。このモードに切り替え後は、たとえばウェブページの@acronym{HTML}を閲覧するために@kbd{C-x
C-f https://www.gnu.org/ RET}とタイプして、それを編集してローカルファイルに保存することができます。

@node Goto Address mode
@subsection URLのアクティブ化
@findex goto-address-mode
@cindex mode, Goto Address
@cindex Goto Address mode
@cindex URLs, activating

@table @kbd
@item M-x goto-address-mode
カレントバッファーのURLとメールアドレスをアクティブにします。

@item M-x global-goto-address-mode
すべてのバッファーで@code{goto-address-mode}をアクティブにします。
@end table

@kindex C-c RET @r{(Goto Address mode)}
@findex goto-address-at-point
  @kbd{M-x
goto-address-mode}とタイプすることにより、EmacsにカレントバッファーのURLを特別にマークさせることができます。このバッファーローカルなマイナーモードが有効な場合、バッファーのすべてのURLを探して、それらをハイライトするとともに、クリックできるボタンに変更します。そのようなテキストの上にポイントを移動して@kbd{C-c
@key{RET}}
(@code{goto-address-at-point})とタイプするか、@kbd{mouse-2}をクリック、または@kbd{mouse-1}を素早くクリックすることにより(@ref{Mouse
References}を参照してください)、そのURLをフォローできます。URLのフォローは、@code{browse-url}をサブルーチンとして呼び出すことにより行なわれます(@ref{Browse-URL}を参照してください)。

  モードフックや受信メッセージを表示するフック(たとえばRmailの@code{rmail-show-message-hook})に@code{goto-address-mode}を追加するのは便利かもしれません。GnusやMH-Eには独自に類似の機能があるので必要ありません。

@node FFAP
@subsection ポイント位置のファイルやURLを開く
@findex find-file-at-point
@findex ffap
@findex dired-at-point
@findex ffap-next
@findex ffap-menu
@cindex finding file at point

  FFAPパッケージは、@kbd{C-x
C-f}のようなファイルを探すためのキーにバインドされているコマンドを、より直感的なデフォルトを提供するコマンドに置き換えます。これらのコマンドにプレフィクス引数を与えたときは、通常のコマンドと同様に振る舞います。それ以外の場合、ポイント周辺のテキストからデフォルトのファイル名を取得します。バッファーから見つかったのがファイル名ではなくURLの場合、このコマンドはそれを閲覧するために@code{browse-url}を使用します(@ref{Browse-URL}を参照してください)。

  この機能は、メールバッファーやニュースバッファー内の参照、@file{README}ファイル、@file{MANIFEST}ファイルなどをフォローするのに便利です。詳細については、@kbd{C-h
P ffap @key{RET}}とタイプして、パッケージのコメントを参照してください。

@cindex FFAP minor mode
@findex ffap-mode
  FFAPを有効にするには、@kbd{M-x
ffap-bindings}とタイプします。これにより、以下のキーバインドが作成され、Rmail、Gnus、VMアーティクルバッファーでの、追加FFAP機能にたいするフックもインストールされます。

@table @kbd
@item C-x C-f @var{filename} @key{RET}
@kindex C-x C-f @r{(FFAP)}
@var{filename}を検索します(@code{find-file-at-point})。デフォルトのファイル名は、ポイント周辺のテキストから推測します。
@item C-x C-r @var{filename} @key{RET}
@kindex C-x C-r @r{(FFAP)}
@code{ffap-read-only}。@code{find-file-read-only}に相当します。
@item C-x C-v @var{filename} @key{RET}
@kindex C-x C-v @r{(FFAP)}
@code{ffap-alternate-file}。@code{find-alternate-file}に相当します。
@item C-x d @var{directory} @key{RET}
@kindex C-x d @r{(FFAP)}
ポイント位置のディレクトリーをデフォルトとして、@var{directory}でDiredを開始します(@code{dired-at-point})。
@item C-x C-d @var{directory} @key{RET}
@code{ffap-list-directory}。@code{list-directory}に相当します。
@item C-x 4 f @var{filename} @key{RET}
@kindex C-x 4 f @r{(FFAP)}
@code{ffap-other-window}。@code{find-file-other-window}に相当します。
@item C-x 4 r @var{filename} @key{RET}
@code{ffap-read-only-other-window}。@code{find-file-read-only-other-window}に相当します。
@item C-x 4 d @var{directory} @key{RET}
@code{ffap-dired-other-window}。@code{dired-other-window}と同様です。
@item C-x 5 f @var{filename} @key{RET}
@kindex C-x 5 f @r{(FFAP)}
@code{ffap-other-frame}。@code{find-file-other-frame}に相当します。
@item C-x 5 r @var{filename} @key{RET}
@code{ffap-read-only-other-frame}。@code{find-file-read-only-other-frame}に相当します。
@item C-x 5 d @var{directory} @key{RET}
@code{ffap-dired-other-frame}。@code{dired-other-frame}に相当します。
@kindex C-x t C-f @r{(FFAP)}
@item C-x t C-f @var{filename} @key{return}
@code{ffap-other-tab}。@code{find-file-other-tab}に相当します。
, analogous to .
@item C-x t C-r @var{filename} @key{return}
@code{ffap-read-only-other-tab}。@code{find-file-read-only-other-tab}に相当します。
@item M-x ffap-next
バッファーから次のファイル名またはURLを検索して、そのファイルまたはURLを開きます。
@item S-mouse-3
@kindex S-mouse-3 @r{(FFAP)}
@code{ffap-at-mouse}は、マウスがクリックされた周辺のテキストから推測されたファイルを開きます。
@item C-S-mouse-3
@kindex C-S-mouse-3 @r{(FFAP)}
カレントバッファーに記述されたファイルとURLのメニューを表示して、選択されたものを開きます(@code{ffap-menu})。
@end table

@node Amusements
@section ゲーム、その他の娯楽
@cindex boredom
@cindex games

@findex animate-birthday-present
@cindex animate
  @code{animate}パッケージは、テキストをダンスさせます(たとえば@kbd{M-x animate-birthday-present})。

@findex blackbox
@findex mpuz
@findex 5x5
@cindex puzzles
  @kbd{M-x blackbox}、@kbd{M-x mpuz}、@kbd{M-x
5x5}はパズルです。@code{blackbox}はボックス内のボールの位置を、トモグラフィー(断層撮影)により当てるパズルです。@code{mpuz}は掛け算パズルを表示します。掛け算の中の英字が何の数字かを当てなければなりません。数字を入力するには、英字をタイプしてから、その数字をタイプします。@code{5x5}の目標は、すべてのマスを埋めることです。

@findex bubbles
@cindex bubbles
  @kbd{M-x bubbles}は、より少ない回数の移動で、多くのbubble(シャボン玉)を取り除くゲームです。

@findex decipher
@cindex ciphers
@cindex cryptanalysis
  @kbd{M-x decipher}は、単純なアルファベット置換で暗号化されたバッファーを解読するのに役立ちます。

@findex dissociated-press
  @kbd{M-x
dissociated-press}は、Emacsのカレントバッファーのテキストをスクランブルします。スクランブルは単語単位または文字単位で行なわれ、@file{*Dissociation*}という名前のバッファーに出力されます。正の引数は文字単位での操作を指定し、数にはオーバーラップする文字数を指定します。負の引数は単語単位での操作を指定し、数にはオーバーラップする単語数を指定します。Dissociated
Pressはマルコフ連鎖と酷似した結果を生成しますが、それとは独自のigオリジナルな創案です。手法としては、単語または文字の後ろにランダムにジャンプするマルコフ連鎖とは異なり、ランダムなジャンプの間にあるサンプルから、連続する複数の文字をコピーします。ユーザーに受け入れられ、正確でありたいなら、ドキュメントにはdissociwordsを使用しないでください。

@findex dunnet
@cindex dunnet
  @kbd{M-x dunnet}は、テキストベースのアドベンチャーゲームを開始します。

@findex gomoku
@cindex Go Moku
  個人的な満足感を得たいなら、@kbd{M-x gomoku}に挑戦してみてください。これはあなたと五目並べゲームを対戦します。

@cindex tower of Hanoi
@findex hanoi
  少し退屈していたら@kbd{M-x
hanoi}に挑戦してみてください。かなり退屈しているなら、数引数を指定します。とてもとても退屈なら、引数9に挑戦してみましょう。さあ、座って眺めましょう。

@findex life
@cindex Life
  @kbd{M-x life}は、ConwayのLife cellular automatonを実行します。

@findex morse-region
@findex unmorse-region
@findex nato-region
@cindex Morse code
@cindex --/---/.-./.../.
  @kbd{M-x morse-region}は、リージョンのテキストをモールス信号に変換し、@kbd{M-x
unmorse-region}で元に戻します。@kbd{M-x nato-region}は、リージョンのテキストをNATO発音記号(NATO
phonetic alphabet)に変換し、@kbd{M-x denato-region}で元に戻します。

@findex pong
@cindex Pong game
@findex tetris
@cindex Tetris
@findex snake
@cindex Snake
  @kbd{M-x pong}、@kbd{M-x snake}、@kbd{M-x tetris}は、有名なPong、Snake、Tetrisの実装です。

@findex solitaire
@cindex solitaire
  @kbd{M-x solitaire}はソリティアーゲームをプレーします。これはピンを他のピンを超えてジャンプさせるゲームです。

@findex zone
@cindex zone
  @kbd{M-x zone}は、Emacsがアイドル時にプレーするゲームです。

@findex butterfly
@cindex butterfly
  円盤状記憶媒体のビットのフリップにbutterflies(蝶々)を使用する``真のプログラマー''は、@kbd{M-x
butterfly}をデプロイします。@uref{https://xkcd.com/378}を参照してください。

@findex doctor
@cindex Eliza
  最後に、もし不満を感じているときは、有名な精神分析医のElizaに問題の説明を試みてください。これは@kbd{M-x
doctor}とタイプするだけです。各入力の最後には、@key{RET}を2回タイプしてください。

@ifnottex
@lowersections
@end ifnottex
