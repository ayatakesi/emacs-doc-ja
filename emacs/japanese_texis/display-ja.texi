@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================

@c -*- coding: utf-8 -*-
@c This is part of the Emacs manual.
@c Copyright (C) 1985--1987, 1993--1995, 1997, 2000--2024 Free Software
@c Foundation, Inc.

@c See file emacs-ja.texi for copying conditions.
@node Display
@chapter ディスプレイの制御

  ウィンドウに入りきらない大きなバッファーでは、Emacsはその一部しか表示できません。このチャプターでは、見たい部分のテキストを指定するコマンドや変数と、どのようにしてテキストが表示されるかを説明します。

@menu
* Scrolling::                ウィンドウのテキストを上下に移動させるコマンド。
* Recentering::              カレント行を中央にするスクロールコマンド。
* Auto Scrolling::           必要なときテキストをスクロールして再表示する。
* Horizontal Scrolling::     ウィンドウの左右にテキストを移動させる。
* Narrowing::                表示を制限してバッファーの一部を編集する。
* View Mode::                読み取り専用バッファーの表示。
* Follow Mode::              Followモードで2つのウィンドウを1つとしてスクロールさせる。
* Faces::                    フェイスを使って表示スタイルを変更する方法。
* Colors::                   フェイスのカラーを指定する。
* Standard Faces::           主要な既定のフェイス。
* Icons::                    How to change how icons look.
* Text Scale::               バッファーのテキストサイズの拡大と縮小。
* Font Lock::                フェイスを使って文法をハイライトするマイナーモード。
* Highlight Interactively::  Emacsにハイライトするテキストを指示する。
* Fringes::                  ウィンドウフリンジの有効と無効。
* Displaying Boundaries::    バッファーの先頭と最後を表示する。
* Useless Whitespace::       行末の不要な空白文字の表示。
* Selective Display::        インデントの大きな行を隠す。
* Optional Mode Line::       モードラインの表示機能のオプション。
* Text Display::             テキスト文字が通常表示される方法。
* Cursor Display::           カーソル表示の機能。
* Line Truncation::          複数のスクリーン行で継続表示させずにスクリーン幅に行を切り詰める。
* Visual Line Mode::         単語の折り返しとスクリーン行にもとづく編集。
* Display Custom::           ディスプレイをカスタマイズする変数の情報。
@end menu

@node Scrolling
@section スクロール
@cindex scrolling

  ウィンドウがバッファーのすべてのテキストを表示するには小さい場合、その一部だけが表示されます。@dfn{スクロール}コマンドは、バッファーで表示される部分を変更します。

  前方(forward)または上(up)へのスクロールは、ウィンドウに表示される部分を先に進めます。これはウィンドウに表示されるバッファーのテキストを、上に移動させるのと同じです。後方(backward)または下(down)へのスクロールは、ウィンドウに表示される部分を前に戻します。これはウィンドウに表示されるバッファーのテキストを下に移動させます。

  Emacsでのupとdownは、ウィンドウでテキストが移動する方向に基づいており、テキストにたいしてウィンドウが移動する方向では@emph{ありません}。この用語は現在のscrolling
upやscrolling
downが広まる前に、Emacsで採用されました。そのため@key{PageDown}は、Emacs的には上(up)にスクロールするという、奇妙な結果となりました。

  ウィンドウに表示されているバッファー部分には、常にポイントが含まれています。もしウィンドウの下端か上端を越えてポイントを移動させると、ポイントを画面に表示させるために自動的にスクロールが発生します(@ref{Auto
Scrolling}を参照してください)。以下のコマンドで明示的にスクロールができます:

@table @kbd
@item C-v
@itemx @key{PageDown}
@itemx @key{next}
ウィンドウのほぼ全画面分、前方にスクロールします(@code{scroll-up-command})。
@item M-v
@itemx @key{PageUp}
@itemx @key{prior}
後方にスクロールします(@code{scroll-down-command})。
@end table

@kindex C-v
@kindex M-v
@kindex PageDown
@kindex PageUp
@kindex next
@kindex prior
@findex scroll-up-command
@findex scroll-down-command
  @kbd{C-v}
(@code{scroll-up-command})は、ウィンドウ全体の高さに近い量、前方にスクロールします。これにより下端の2行が上端になるようスクロールして、それに続く表示されていなかった行を表示します。ポイントが上端より上になってしまう場合、ウィンドウの新たな上端の行に移動します。The
@key{PageDown}(または@key{next})は、@kbd{C-v}と同じです。

  @kbd{M-v}
(@code{scroll-down-command})は、同様の方法で後方にスクロールします。@key{PageUp}(または@key{prior})は、@kbd{M-v}と同じです。

@vindex next-screen-context-lines
  スクロールコマンドでオーバーラップして表示される行数は、変数@code{next-screen-context-lines}で制御され、デフォルトは2です。数引数@var{n}を与えたときは、@var{n}行スクロールします。Emacsはポイントを変更しないよう試みるので、テキストとポイントは一緒に上または下に動きます。@kbd{C-v}に負の引数を与えると、@kbd{M-v}のように反対方向へスクロールします。

@vindex scroll-error-top-bottom
  デフォルトでは、ウィンドウがバッファーの先頭または最後に到達していて、これ以上スクロールできない場合、これらのコマンドは(beep音をならしたり画面をフラッシュして)エラーをシグナルします。変数@code{scroll-error-top-bottom}を@code{t}に変更すると、コマンドは可能な限り、つまりバッファーの先頭の文字または最後の文字にポイントを移動します。ポイントがすでにそこにあるときは、エラーをシグナルします。

@vindex scroll-preserve-screen-position
@cindex @code{scroll-command} property
  スクロールしたとき、ポイントが同じスクリーン位置に留まることを好むユーザーもいます。そうすれば同じスクリーンにスクロールして戻ったとき、ポイントが元の位置にあると便利だからです。この動作は変数@code{scroll-preserve-screen-position}を通じて利用可能です。変数の値が@code{t}のとき、スクロールコマンドによりポイントがウィンドウの外にでるような場合、Emacsはポイントを先頭行または最終行に移動させるのではなく、同じスクリーン位置にポイントを調整して、カーソルを維持します。その他の非@code{nil}値の場合、Emacsはスクロールコマンドによりポイントがウィンドウに残っている場合にも、この方法でポイントを調整します。この変数はこのセクションで説明するすべてのスクロールコマンド、同様にマウスホイールによるスクロール(@ref{Mouse
Commands}を参照してください)に影響を与えます。一般的にいうと、この変数は@code{scroll-command}プロパティが非@code{nil}のコマンドに影響を及ぼします。@ref{Property
Lists,,, elisp, The Emacs Lisp Reference
Manual}を参照してください。インクリメンタル検索においてこのプロパティが非@code{nil}のコマンドが呼び出された際に、@code{isearch-allow-scroll}が非@code{nil}であればインクリメンタル検索を終了させないという効果もあります(@ref{Not
Exiting Isearch}を参照)。

@vindex fast-but-imprecise-scrolling
  ときどき、特に@kbd{C-v}や@kbd{M-v}のようなキーを押したままにすると、キーボードのオートリピートがアクティブになり、要求された高レートのスクロール要求にEmacsが対応できなくなるときがあります。そのような場合、表示は更新されず、かなり長時間の間、Emacsが応答しなくなる可能性があります。変数@code{fast-but-imprecise-scrolling}を非@code{nil}値にセットすることにより、この状況に対処できます。これはスクロールコマンドにフォント表示化(@ref{Font
Lock}を参照してください)を行なわないように指示します。スクロールされるテキストは、それらがデフォルトフェイスをもつと仮定されなくなり、フォント表示化されなくなります。これにより、そのフェイスがすべて同じサイズのフォントを使用していない場合には、(たとえばオートリピートではない)1回のスクロールでも、Emacsが誤ったバッファー位置にスクロールするかもしれません。

@vindex jit-lock-defer-time
@code{fast-but-imprecise-scrolling}をセットするかわりにJIT
Lockによる遅延されたフォント表示化の有効化のほうが好ましいと思うかもしれません(@ref{Font
Lock}を参照)。これを行うには@code{jit-lock-defer-time}に0.25、タイプ速度が速い場合には0.1のように小さい正の数値をセットします。これにより@kbd{C-v}押下時のぎくしゃくしたスクロールが幾分改善されますが、バッファーの新たな部分へスクロールするようなアクション後のウィンドウのコンテンツは一時的に非フォント化されるでしょう。

@vindex redisplay-skip-fontification-on-input
最後にこれらの変数にかわる3つ目の選択肢が@code{redisplay-skip-fontification-on-input}です。この変数が非@code{nil}なら、保留中の入力がある場合にはいくつかのフォント表示化をスキップします。いずれにせよ入力の保留中は再表示を完全にスキップするので通常なら表示に影響はありませんが、不要なフォント表示化を避けることでスクロールがスムーズになる可能性があります。

@vindex scroll-up
@vindex scroll-down
@findex scroll-up-line
@findex scroll-down-line
  コマンド@kbd{M-x scroll-up}および@kbd{M-x
scroll-down}は、@code{scroll-up-command}および@code{scroll-down-command}と同様に動作しますが、@code{scroll-error-top-bottom}を考慮しません。これらのコマンドは、Emacs
24以前ではスクロールアップおよびスクロールダウンのためのデフォルトでした。コマンド@kbd{M-x
scroll-up-line}および@kbd{M-x
scroll-down-line}は、現在のウィンドウを1行スクロールさせます。もしこれらのコマンドを使う場合は、それにキーバインドを割り当てたくなるでしょう(@ref{Init
Rebinding}を参照してください)。

@node Recentering
@section センタリング

@table @kbd
@item C-l
選択されているウィンドウで、現在行が中央になるようスクロールします。連続して呼び出すと、次は現在行が上端になり、その次は現在行が下端に、という順番で循環します。画面の再描画が行われる可能性があります(@code{recenter-top-bottom})。

@item C-M-S-l
他のウィンドウをスクロールします。これは他のウィンドウに作用する@kbd{C-l}と等価です。

@item M-x recenter
選択されているウィンドウで、現在行が中央になるようにスクロールします。画面の再描画が行われる可能性があります。

@item C-M-l
有用な情報が表示されるよう、発見的な手法でスクロールします(@code{reposition-window})。
@end table

@kindex C-l
@findex recenter-top-bottom
  @kbd{C-l}
(@code{recenter-top-bottom})コマンドは、選択されたウィンドウにたいして@dfn{センタリング(recenters)}をします。これにより現在のスクリーン行がウィンドウの中央、または中央に一番近い行になります。

  (@kbd{C-l
C-l})のように@kbd{C-l}を2回タイプすると、ポイントのある行が上端になるようにスクロールします。@kbd{C-l}を3回タイプするとポイントのある行が下端になるようにスクロールします。連続して@kbd{C-l}をタイプすることにより、上記の3つの位置を循環してスクロールできます。

@vindex recenter-positions
  リスト変数@code{recenter-positions}をカスタマイズすることにより、循環する順序を変更できます。リスト要素にはシンボル@code{top}、@code{middle}、@code{bottom}または数値を指定します。数値に整数を指定すると、現在行が指定したスクリーン行になるようスクロールします。数値に0.0から1.0の浮動小数点数は、ウィンドウの上端から現在行までを割合で指定します。デフォルトは@code{(middle
top
bottom)}で、これは上述した循環順序です。さらに変数@code{scroll-margin}を、0以外の値@var{n}に変更すると、@kbd{C-l}は常にウィンドウの上端または下端からスクリーン行で、@var{n}行を残してスクロールします(@ref{Auto
Scrolling}を参照してください)。

  @kbd{C-l}にプレフィクス引数を指定することもできます。@kbd{C-u
C-l}のようにプレフィクス引数だけを指定すると、単にポイントを示す行を中央にします。正の引数@var{n}は、ポイントを示す行がウィンドウの上端から@var{n}行目になるようにスクロールします。0を指定すると、ポイントのある行がウィンドウ上端になるようにスクロールします。負の引数@minus{}@var{n}は、ポイントのある行がウィンドウの下端から@var{n}行目になるようにスクロールします。引数を与えたときは、@kbd{C-l}は画面をクリアーせず、異なるスクリーン位置への循環も行いません。

@vindex recenter-redisplay
  変数@code{recenter-redisplay}が非@code{nil}値の場合、@kbd{C-l}はスクリーンのクリアーと再描画を行います。特別な値@code{tty}(デフォルト)は、これをテキスト端末上のフレームだけに限定します。再描画はスクリーンが何らかの理由により文字化けしてしまったときなどに便利です(@ref{Screen
Garbled}を参照してください)。

@findex recenter
  より原始的なコマンド@kbd{M-x
recenter}は、@code{recenter-top-bottom}と同じように振る舞いますが、スクリーン位置を循環しません。

@kindex C-M-l
@findex reposition-window
  @kbd{C-M-l}
(@code{reposition-window})は、有用な情報がスクリーンに表示されるように、現在のウィンドウを発見的な手法によりスクロールします。たとえばLispファイルの場合、このコマンドは可能な限り現在のdefun全体がスクリーン上に表示されるよう試みます。

@node Auto Scrolling
@section 自動スクロール

@cindex automatic scrolling
  ポイントが表示されているテキスト部分から外に移動すると、Emacsは@dfn{自動スクロール(automatic
scrolling)}の処理を行います。通常自動スクロールは、ウィンドウの垂直方向の中央にポイントをセンタリングしますが、この振る舞いを変えるいくつかの方法があります。

@vindex scroll-conservatively
@vindex scroll-minibuffer-conservatively
  @code{scroll-conservatively}に小さい数字@var{n}をセットすると、ポイントが少し(@var{n}行以下)スクリーンの外に出たら、Emacsはポイントがスクリーンに表示されるのに充分なだけスクロールします。これでもしポイントの表示に失敗した場合、Emacsはそのウィンドウの中央にポイント行が表示されるのに充分なだけのスクロールをします。@code{scroll-conservatively}に大きな数字(100より大)も数字をセットすると、どれだけポイントを移動させようと、自動スクロールはポイント行を中央にセンタリングしなくなります。Emacsはポイントが表示されるように常にテキストをスクロールします。ウィンドウの上端または下端かはスクロールの方向に依存します。デフォルトでは@code{scroll-conservatively}は@tie{}0で、これは常にポイント行がウィンドウの中央にセンタリングされることを意味します。つまりミニバッファーウィンドウでは、@code{scroll-conservatively}より優先される@code{scroll-minibuffer-conservatively}がデフォルトでは非@code{nil}なので、常にconservative(保守的)なスクロールになると言うことです。

@vindex scroll-step
  自動スクロールを制御する他の方法は、変数@code{scroll-step}をカスタマイズすることです。この変数の値はポイントがスクリーンから外れたとき、何行を自動スクロールさせるかを決定します。その行数スクロールしてもポイントが表示されない場合、かわりにポイント行が中央にきます。デフォルト値は0で、スクロール後は常にポイント行が中央にきます。

@cindex aggressive scrolling
@vindex scroll-up-aggressively
@vindex scroll-down-aggressively
  自動コントロールを制御する3番目の方法は、変数@code{scroll-up-aggressively}と@code{scroll-down-aggressively}をカスタマイズすることで、これは直接スクロール後のポイントの垂直位置を指定します。@code{scroll-up-aggressively}の値には、@code{nil}(デフォルト)、または0から1までの浮動小数点数@var{f}を指定します。ポイントがウィンドウの下端を越えたとき(たとえば前方にスクロールしたとき)、Emacsはウィンドウの高さとウィンドウの下端からポイント行までの割合が、@var{f}になるようスクロールします。つまり@var{f}を大きくするとより積極的(aggressive)、つまり新しいテキストがより多く表示されることを意味します。デフォルト値@code{nil}は0.5と同じです。

  同様に@code{scroll-down-aggressively}は、ポイントがウィンドウの上端を越えたとき(たとえば後方にスクロールしたとき)の振る舞いを設定します。値にはスクロール後のウィンドウの上端からポイント行までのマージンを指定します。つまり@code{scroll-up-aggressively}を大きくすると、より積極的になります。

  変数@code{scroll-conservatively}、@code{scroll-step}、および@code{scroll-up-aggressively}と@code{scroll-down-aggressively}は、互いに矛盾する方法で自動スクロールを制御します。したがって自動スクロールをカスタマイズする場合は、2つ以上の手法を選ぶべきではありません。もし2つ以上の変数をカスタマイズする場合は、@code{scroll-conservatively}、次に@code{scroll-step}、そして最後に@code{scroll-up-aggressively}と@code{scroll-down-aggressively}という優先順でカスタマイズしてください。

@vindex scroll-margin
@vindex maximum-scroll-margin
  変数@code{scroll-margin}は(たとえscroll-up-aggressivelyやscroll-down-aggressivelyに、上端または下端からのマージンがウィンドウにたいして占める割合より大きくなるような@var{f}を指定していても)、ポイントがウィンドウの上端または下端にどれだけ近づけるかを制限します。変数の値にはスクリーン行の行数です。もしポイントがウィンドウの上端または下端から指定した行数の位置にくると、Emacsは自動的にスクロールします。デフォルトでは@code{scroll-margin}は0です。デフォルトではそのウィンドウの高さの1/4に制限されていますが、@code{maximum-scroll-margin}をカスタマイズすることにより1/2まで増加(または0まで減少)させることができます。 

@node Horizontal Scrolling
@section 水平スクロール
@cindex horizontal scrolling

@vindex auto-hscroll-mode
  @dfn{水平スクロール(Horizontal
scrolling)}は、ウィンドウの行を右方向に移動させます。そのため左端の近くのテキストは表示されなくなります。ウィンドウのテキストが水平スクロールされると、テキスト行は折り返されるのではなく、切り詰め(truncated)られます。ウィンドウが切り詰められた行を表示しているとき、ポイントがスクリーンの左端か右端を越えて移動すると、Emacsは自動的に水平スクロールを行います。デフォルトではそのウィンドウ内のすべての行は一緒に水平スクロールされますが、変数@code{auto-hscroll-mode}に特別な値@code{current-line}をセットした場合は、カーソルを表示する行だけがスクロールされます。自動的な水平スクロールを完全に無効にするには、変数@code{auto-hscroll-mode}に@code{nil}をセットしてください。また自動的な水平スクロールがオフになっている場合、ポイントがスクリーンの端を越えると、それを知らせるためにカーソルが表示されなくなることに注意してください(テキスト端末の場合カーソルは端に残されます)。

@vindex hscroll-margin
  変数@code{hscroll-margin}は、自動的なスクロールが起こる前に、ポイントがウィンドウの左端または右端に、どれだけ近づけるかを制御します。変数の値は列数で指定します。たとえば変数の値が5のときは、端から5列目にポイントが移動すると、水平スクロールが発生します。

@vindex hscroll-step
  変数@code{hscroll-step}はmポイントが端に近づきすぎたときに、何列スクロールするかを決定します。デフォルト値の0は、ポイントがウィンドウの中央になるようにスクロールされることを意味します。正の整数はスクロールされる列数を指定します。浮動小数点数(0から1の値であること)は、スクロールされる量を、ウィンドウの幅にたいする割合で指定します。

  以下のコマンドで明示的に水平スクロールすることもできます:

@table @kbd
@item C-x <
現在のウィンドウのテキストを左にスクロールします(@code{scroll-left})。
@item C-x >
右にスクロールします(@code{scroll-right})。
@end table

@kindex C-x <
@kindex C-x >
@findex scroll-left
@findex scroll-right
  @kbd{C-x <}
(@code{scroll-left})は選択された、ウィンドウをウィンドウ幅から2列少ない列数、左にスクロール(いいかえればウィンドウのテキストは左に移動)します。数引数@var{n}を指定すると、@var{n}列スクロールします。

  テキストが左にスクロールされて、ポイントがウィンドウの左端を越えると、ポイントが表示されているテキストに戻るまで、カーソルはフリーズします。これは@code{auto-hscroll-mode}の設定とは独立しています(これはテキストを左にスクロールするときのウィンドウの右端での振る舞いだけに影響します)。

  @kbd{C-x >}
(@code{scroll-right})は、同様に右にスクロールします。ウィンドウが通常の表示(行の先頭がウィンドウの左端に表示されている状態)のときは、それ以上スクロールできないので何も起こりません。これは@w{@kbd{C-x
>}}の引数を正確に計算する必要がないことを意味します。充分に大きな引数を与えれば、通常の表示が復元されます。

  これらのコマンドでウィンドウを水平方向にスクロールすると、自動水平スクロールの下限値がセットされます。自動スクロールはウィンドウのスクロールを続けますが、前に@code{scroll-left}にセットされた値を越えて右にスクロールできなくなります。@code{auto-hscroll-mode}が@code{current-line}にセットされているときは、カーソルを表示する行以外の行は、最小限度だけスクロールされるでしょう。

@node Narrowing
@section ナローイング
@cindex widening
@cindex restriction
@cindex narrowing
@cindex accessible portion

  @dfn{ナローイング(Narrowing)}とはバッファーのある範囲にフォーカスを置き、他の部分を一時的にアクセス不能にすることを意味します。扱うことのできる範囲のことを、@dfn{アクセス可能範囲(accessible
portion)}と呼びます。ナローイングを取り消すと、バッファー全体に再びアクセスできるようになります。これを@dfn{ワイドニング(widening)}と呼びます。バッファーにたいして、ナローイングにより境界を設けることを、バッファーの@dfn{制限(restriction)}と呼びます。

  ナローイングにより、他の部分に気を取られずに、1つのサブルーチンやパラグラフに集中することが容易になります。ナローイングは、置換コマンドやキーボードマクロの繰り返しにより操作される範囲を制限するためにも使われます。

@table @kbd
@item C-x n n
ポイントとマークの間にナローイングします(@code{narrow-to-region})。
@item C-x n w
バッファー全体をワイドニングして、再びアクセス可能にします(@code{widen})。
@item C-x n p
現在のページにナローイングします(@code{narrow-to-page})。
@item C-x n d
現在のdefunにナローイングします(@code{narrow-to-defun})。
@end table

  バッファーをナローイングしているときは、表示されている範囲がすべてです。残りの部分を見ることはできず、移動もできず(移動コマンドによりアクセス可能範囲の外に移動することはできません)、変更もできません。しかし残りの部分がなくなったわけではないので、ファイルを保存するとアクセス不能範囲のテキストもすべて保存されます。ナローイングが有効なときは、モードラインに@samp{Narrow}という単語が表示されます。

@kindex C-x n n
@findex narrow-to-region
  主要なナローイングコマンドは、@kbd{C-x n n}
(@code{narrow-to-region})です。これは現在のバッファーを制限するので、現在のリージョンだけがアクセス可能になり、リージョンの前後のすべてのテキストはアクセス不能になります。ポイントとマークは変化しません。

@kindex C-x n p
@findex narrow-to-page
@kindex C-x n d
@findex narrow-to-defun
  かわりに@kbd{C-x n p}
(@code{narrow-to-page})を使うと、現在のページにナローイングされます。ページの定義については、@ref{Pages}を参照してください。@kbd{C-x
n d}
(@code{narrow-to-defun})は、ポイントを含むdefunにナローイングします(@ref{Defuns}を参照してください)。

@kindex C-x n w
@findex widen
  ナローイングを取り消す方法は、@kbd{C-x n w}
(@code{widen})です。これにより再びバッファーのテキストすべてにアクセス可能になります。

  バッファーのどの範囲にナローイングされているかは、@kbd{C-x =}コマンドを使って情報を得ることができます。@ref{Position
Info}を参照してください。

  ナローイングは、それを理解していないユーザーを容易に混乱させるので、通常@code{narrow-to-region}コマンドは無効になっています。このコマンドを使おうとすると、Emacsは確認を求め、有効にするオプションを提供します。このコマンドを有効にすると、それ以降は確認を求められなくなります。@ref{Disabling}を参照してください。

@node View Mode
@section Viewモード
@cindex View mode
@cindex mode, View

@kindex s @r{(View mode)}
@kindex SPC @r{(View mode)}
@kindex DEL @r{(View mode)}
  Viewモードは、バッファーをスクリーン上でスキャンするためのマイナーモードです。このモードは、バッファーを変更せずにスクロールする、便利なコマンドを提供します。Emacsのカーソル移動コマンドとは別に、@key{SPC}で前方にスクロール、@kbd{S-@key{SPC}}または@key{DEL}で後方にスクロール、@kbd{s}でインクリメンタルサーチができます。

@kindex q @r{(View mode)}
@kindex e @r{(View mode)}
@findex View-quit
@findex View-exit
  @kbd{q}
(@code{View-quit})とタイプするとViewモードが無効になり、Viewモードが有効になる前のパッファーの位置に戻ります。@kbd{e}
(@code{View-exit})とタイプするとViewモードが無効になり、現在のバッファーと位置は維持されます。

@findex view-buffer
@findex view-file
  @kbd{M-x
view-buffer}は、既存のEmacsバッファー名を入力として求め、そのバッファーに切り替えてViewモードを有効にします。@kbd{M-x
view-file}はファイル名を入力として求め、そのファイルをvisitしてViewモードを有効にします。

@node Follow Mode
@section Followモード
@cindex Follow mode
@cindex mode, Follow
@findex follow-mode
@cindex windows, synchronizing
@cindex synchronizing windows

  @dfn{Followモード}は、同じバッファーを表示する2つのウィンドウを、1つの仮想ウィンドウとしてスクロールするマイナーモードです。Followモードを使うには、ウィンドウが1つだけのフレームを選択して、それを@kbd{C-x
3}を使って縦に並べて2分割してから、@kbd{M-x
follow-mode}とタイプします。それ以降はバッファーをどちらのウィンドウでも編集でき、どちらかのウィンドウをスクロールすると、他方のウィンドウも追従してスクロールします。

  Followモードでは、一方のウィンドウで表示されている部分の外にポイントを移動して、もう一方のウィンドウで表示されている部分にポイントを移動させると、そのウィンドウが選択されます。つまり2つのウィンドウを1つの大きなウィンドウとして扱えるのです。

  Followモードをオフにするには、もう一度@kbd{M-x follow-mode}とタイプしてください。

@node Faces
@section テキストのフェイス
@cindex faces

  Emacsは@dfn{フェイス(faces)}と呼ばれる仕組みを通じて、テキストをいくつかの異なるスタイルで表示できます。フェイスにはfont(フォント)、height(高さ)、weight(太さ)、slant(傾き)、foreground(前景)およびbackground(背景)、underline(アンダーライン)、overline(オーバーライン)などの様々な@dfn{フェイス属性(face
attributes)}を指定できます。ほとんどのメジャーモードはFont
Lockモードを通じて、テキストに自動的にフェイスを割り当てます。これらのフェイスを割り当てる方法については、@ref{Font
Lock}を参照してください。

@findex list-faces-display
  現在定義されているフェイスと、それがどのような外観なのかを見るには、@kbd{M-x
list-faces-display}とタイプします。プレフィクス引数を指定すると、このコマンドは正規表現の入力を求め、その正規表現にマッチするフェイスだけを表示します(@ref{Regexps}を参照してください)。

@vindex frame-background-mode
  あるフェイスが、フレームが異なると違って見えるのことがあり得ます。たとえばいくつかのテキスト端末ではすべてのフェース属性、特に特にfont、height、widthはサポートされておらず、指定できるcolorも限られているものがあります。加えて、ほとんどのEmacsフェースは視認性をよくするために、フレームのバックグラウンドが明るい(light)か暗い(dark)かで属性が異なります。デフォルトでは、Emacsはフレームの現在のバックグラウンドカラーに基づいて、表示するフェイスの属性を自動的に選択します。しかし変数@code{frame-background-mode}に非@code{nil}値を与えると、これをオーバーライドできます。値@code{dark}ではすべてのフレームの背景色が暗い色であるかのように処理し、値@code{light}ではすべてのフレームの背景色が明るい色であるかのように処理させることができます。

@cindex background color
@cindex @code{default face}
  フェイスの属性を変えてフェイスをカスタマイズして、将来のEmacsセッション用にカスタマイズ結果を保存することができます。詳細については、@ref{Face
Customization}を参照してください。

  @code{default}フェイスはテキストを表示するデフォルトのフェイスで、そのすべての属性は指定されています。バックグラウンドカラーは、フレームのバックグラウンドカラーとしても使用されます。@ref{Colors}を参照してください。

@cindex @code{cursor} face
  他の特別なフェイスとしては、@code{cursor}フェイスがあります。グラフィカルなディスプレイでは、このフェイスのバックグラウンドカラーは、テキストカーソルを描画するのに使用されます。このフェイスで効果があるのはこの属性だけです。カーソルの下のテキストのフォアグラウンドカラーには、そのテキストのバックグラウンドカラーが使われます。テキスト端末でのテキストカーソルの外観は、@code{cursor}フェイスではなく端末により決定されます。

  特定のフェイスの属性を指定するのにXのリソースを使うこともできます。@ref{Resources}を参照してください。

  Emacsは可変幅フォント(variable-width
fonts)を表示できますが、いくつかのコマンド、特にインデントを行うコマンドは、可変幅の文字幅の表示をうまく処理できません。そのため、ほとんどのフェイスにたいして可変幅フォントを使わないこと、特にそれがFont
Lockモードに割り当てられている場合は、使わないことを推奨します。

@node Colors
@section フェイスのカラー

  フェイスには、さまざまなフォアグラウンドカラーとバックグラウンドカラーをもたせることができます。フェイスにカラーを指定するとき、たとえばフェイスをカスタマイズ(@ref{Face
Customization}を参照してください)するときは、@dfn{カラーネーム(color name)}か、@dfn{RGBトリプレット(RGB
triplet)}で指定することができます。

@subsection カラー名
@cindex color name
@findex list-colors-display
@vindex list-colors-sort
  カラーネームとは、@samp{dark orange}や@samp{medium sea
green}のような、事前に定義された名前です。カラーネームの一覧を見るには、@kbd{M-x
list-colors-display}とタイプします。表示されるカラーの順番を制御するには、@code{list-colors-sort}をカスタマイズします。このコマンドをグラフィカルなディスプレイで実行すると、Emacsで既知のカラーネームのすべてが表示されます(これらは標準のX11のカラーネームで、Xの@file{rgb.txt}で定義されています)。コマンドをテキスト端末で実行すると、端末で安全に表示することができる一部のカラーだけが表示されます。フェイスには、さまざまなフォアグラウンドカラーとバックグラウンドカラーを持たせることができます。しかしEmacsは、テキスト端末でもX11のカラーネームを理解できます。もしフェイスにX11のカラーネームが指定されている場合、最も近い端末の色で表示されます。

@subsection RGBトリプレット
@cindex RGB triplet
  RGBトリプレットは@samp{#RRGGBB}という形式の文字列で指定します。主要カラーコンポーネントはそれぞれ@samp{00}
(色強度0)から@samp{FF}
(最大強度)の16進数として表現されます。各コンポーネントにたいして1桁、3桁、あるいは4桁の16進数を使用することもできるので@samp{red}は@samp{#F00}、@samp{#fff000000}、あるいは@samp{#ffff00000000}と表すことができます。各コンポーネントは同じ桁数でなければなりません。16進数のAからFは、大文字小文字を区別しません。

  @kbd{M-x
list-colors-display}は、カラーネームと、それに相当するRGBトリプレットを表示します。たとえば@samp{medium sea
green}は@samp{#3CB371}と同じです。

@cindex face colors, setting
@findex set-face-foreground
@findex set-face-background
  @kbd{M-x set-face-foreground}と@kbd{M-x
set-face-background}で、フェイスのフォアグラウンドとバックグラウンドのカラーを変更できます。これらのコマンドは、ミニバッファーでフェイス名とカラーの入力を求め(補完機能あり)、指定したカラーをフェイスにセットします。フェイスのカラーは全フレームに影響しますが、カスタマイズバッファーやXリソースを使うのとは異なり、将来のEmacsセッションには引き継がれません。フレームパラメーターを使って、特定のフレームのフォアグラウンドとバックグラウンドのカラーをセットすることもできます。@ref{Frame
Parameters}を参照してください。

@node Standard Faces
@section 標準フェイス
@cindex standard faces

  以下はテキストの外見を指定する標準フェイスです。これらのフェイスの効果が欲しい場合は、特定のテキストに適用することができます。

@table @code
@item default
このフェイスは特定のフェイスをもたない普通のテキストに使われます。フェイスのバックグラウンドカラーは、フレームのバックグラウンドカラーとして使用されます。

@item bold
このフェイスは、デフォルトフォントのbold(太字)バージョンです。

@item italic
このフェイスはデフォルトフォントのitalic(斜体)バージョンです。

@item bold-italic
このフェイスはデフォルトフォントのbold italic(太字斜体)バージョンです。

@item underline
このフェイスはunderline(下線)のテキストです。

@item fixed-pitch
このフェイスはfixed-width
font(固定幅フォント)の使用を強制します。もし望むなら、このフェイスから他の固定幅フォントにカスタマイズするのは妥当ですが、可変幅フォントにするべきではありません。

@item fixed-pitch-serif
このフェイスは@code{fixed-pitch}と似ていますが、フォントはセリフ(serif:
HやIなどの上下のひげ飾り)をもち、伝統的なタイプライター文字に、より似ています。

@cindex @code{variable-pitch} face
@item variable-pitch
このフェイスは可変幅のフォント(プロポーショナルフォント)の使用を強制します。このフォント用に選択されたフォントのサイズは、デフォルトのフォント(通常は固定幅)として選択されたフォントのサイズと一致します。

@item variable-pitch-text
これは@code{variable-pitch}
(継承元)と似ていますが、若干大きめのフェイスです。プロポーショナルフォントは通常は同じ高さのモノスペースフォントよりも視覚的に小さい外観になるので、読み難くなる可能性があります。長いテキストを表示する際には、(小さめの)@code{variable-pitch}フェイスよりも、こちらのフェイスのほうが良い選択かもしれません。

@cindex @code{shadow} face
@item shadow
このフェースはまわりのテキストに比べて、そのテキストを目立たなくします。通常これはデフォルトの黒または白のフォアグラウンドカラーではなく、グレーが使われます。
@end table

  以下は特別な目的のために、一時的にテキストの一部をハイライトするのに使われるフェイスの、不完全なリストです(他にも多くのモードが、そのモードの目的のために、独自のフェイスを定義しています)。

@table @code
@item highlight
このフェイスはさまざまなコンテキスト、たとえばハイパーリンク上をマウスカーソルが通過したときなどに、テキストをハイライトするのに使われます。
@item isearch
このフェイスは、現在のIsearch(インクリメンタル検索)のマッチをハイライトするのに使われます(@ref{Incremental
Search}を参照してください)。
@item query-replace
このフェイスは、現在の問い合わせ置換(Query
Replace)のマッチをハイライトするのに使われます(@ref{Replace}を参照してください)。
@item lazy-highlight
このフェイスは、Isearchおよび問い合わせ置換で、カレントのマッチ(現在カーソルがあるマッチ)以外のマッチ(lazy
matches)をハイライトするのに使われます。
@item region
このフェイスは、アクティブなリージョンを表示するのに使われます(@ref{Mark}を参照してください)。EmacsをGTK+サポートつきでビルドした場合、カラーは現在のGTK+のテーマから提供されます。
@item secondary-selection
このフェイスは、Xのセカンダリー選択(secondary X selection)を表示するのに使われます(@ref{Secondary
Selection}を参照してください)。
@item trailing-whitespace
このフェイスは、@code{show-trailing-whitespace}は非@code{nil}のとき、行末の余分なスペースやタブをハイライトするためのものです(@ref{Useless
Whitespace}を参照してください)。
@item escape-glyph
このフェイスは、制御文字やエスケープシーケンスを表示するためのものです(@ref{Text Display}を参照してください)。
@item homoglyph
このフェイスは、類似文字(表示しようとする文字と似ているが異なる文字)を表示するためのものです(@ref{Text Display}を参照)。 
@item nobreak-space
このフェイスは、no-breakスペース文字を表示するためのものです(@ref{Text Display}を参照してください)。
@item nobreak-hyphen
このフェイスは、no-breakハイフン文字を表示するためのものです(@ref{Text Display}を参照してください)。
@end table

  以下のフェイスは、Emacsフレームの一部の外見を制御します:

@table @code
@item mode-line
@cindex @code{mode-line} face
これはモードラインやヘッダーライン、およびツールキットのメニューを使っていない際のメニューバーに使用される基本フェイスです。デフォルトでは、グラフィカルなウィンドウではraised(浮き彫り)効果をだすため影つきで描画され、テキスト端末ではデフォルトのフェイスを反転して描画されます。

(モードラインに使用されている)@code{mode-line-active}と@code{mode-line-inactive}はこのフェイスから派生したフェイスです。

@item mode-line-active
@cindex faces for mode lines
@code{mode-line}と似ていますが、カレントで選択されているウィンドウのモードラインに使用されます。このフェイスは@code{mode-line}を継承するので、フェイスを変更するとすべてのウィンドウのモードラインが影響を受けます。

@item mode-line-inactive
@cindex @code{mode-line-inactive} face
@code{mode-line}と似ていますが、選択されていないウィンドウのモードラインに使われます(@code{mode-line-in-non-selected-windows}が非@code{nil}のとき)。このフェイスは@code{mode-line}を継承するので、フェイスを変更するとすべてのウィンドウのモードラインが影響を受けます。

@item mode-line-highlight
@cindex @code{mode-line-highlight} face
@code{highlight}と似ていますが、モードライン上でマウスセンシティブ(マウスに感応する)なテキスト範囲に使われます。通常このようなテキスト範囲は上にマウスポインターがくると、ツールチップ(@ref{Tooltips}を参照してください)をポップアップします。

@item mode-line-buffer-id
@cindex @code{mode-line-buffer-id} face
このフェイスは、モードライン上でバッファーを識別する部分に使われます。

@item header-line
@cindex @code{header-line} face
@code{mode-line}と似ていますが、ウィンドウのヘッダーラインのためのものです。モードラインがウィンドウの一番下に表示されるように、ヘッダーラインはウィンドウの一番上に表示されます。ほとんどのウィンドウはヘッダーラインを持ちません。Infoモードのような特別なモードだけがヘッダーラインを持ちます。

@item header-line-highlight
@cindex @code{header-line-highlight} face
@code{highlight}や@code{mode-line-highlight}と似ていますが、ヘッダー行のマウスに感応する部分に使用されます。@code{header-line}フェイスは@code{highlight}とは無関係にカスタマイズされるかもしれないので、このフェイスが別に設けられています。 

@item tab-line
@cindex @code{tab-line} face
@code{mode-line}と似ていますが、ウィンドウのタブラインのためのものです。タブラインはウィンドウのバッファーを表し、ウィンドウの上端に表示されます。@ref{Tab
Line}を参照してください。

@item vertical-border
@cindex @code{vertical-border} face
このフェイスは、テキスト端末上でウィンドウを縦に分割するとき使われます。

@item minibuffer-prompt
@cindex @code{minibuffer-prompt} face
@vindex minibuffer-prompt-properties
このフェイスは、ミニバッファーで入力を求めるプロンプトのテキストに使われます。デフォルトでは、Emacsは自動的にプロンプトのテキストの、テキストプロパティ(@ref{Text
Properties,,, elisp, the Emacs Lisp Reference
Manual}を参照してください)のリスト@code{minibuffer-prompt-properties}に、このフェイスを追加します(この変数はミニバッファーに入ったときに効果をあらわします)。

@item fringe
@cindex @code{fringe} face
グラフィカルなウィンドウでの、左右のフリンジのためのフェイスです(フリンジはEmacsフレームで、テキストエリアとウィンドウの左右の境界線の間にある、狭い領域です)。@ref{Fringes}を参照してください。

@item cursor
このフェイスの@code{:background}属性は、テキストカーソルのカラーを指定します。@ref{Cursor
Display}を参照してください。

@item tooltip
このフェイスは、ツールチップのテキストに使われます。デフォルトでは、EmacsがGTK+サポートつきでビルドされた場合、ツールチップはGTK+を通じて描画されるので、このフェイスは効果がありません。@ref{Tooltips}を参照してください。

@item mouse
このファイスは、マウスポインターのカラーを決定します。
@end table

  以下のフェイスは、Emacsフレームの一部の外見を制御するときと同様ですが、テキスト端末またはEmacsをXサポートつき(ただしツールキットサポートなし)でビルドしたときだけ使われます(それ以外の場合、フレームの対応する各要素は広義なシステム設定により決定されます)。

@table @code
@item scroll-bar
このフェイスは、スクロールバーの外見を決定します。@ref{Scroll Bars}を参照してください。
@item tool-bar
このフェイスは、ツールバーのアイコンのカラーを決定します。@ref{Tool Bars}を参照してください。
@item tab-bar
このフェイスはタブバーのアイコンのカラーを決定します。@ref{Tab Bars}を参照してください。
@item menu
@cindex menu bar appearance
@cindex @code{menu} face, no effect if customized
@cindex customization of @code{menu} face
このフェイスはEmacsメニューのカラーとフォントを決定します。@ref{Menu Bars}を参照してください。
@item tty-menu-enabled-face
@cindex faces for text-mode menus
@cindex TTY menu faces
このフェイスは、テキスト端末で利用可能なメニューアイテムを表示するのに使われます。
@item tty-menu-disabled-face
このフェイスは、テキスト端末で利用不可なメニューアイテムを表示するのに使われます。
@item tty-menu-selected-face
このフェイスは、テキスト端末でマウスをクリックするか、@key{RET}を押せば選択できるメニューアイテムを表示するのに使われます。
@end table

@node Icons
@section アイコン
@cindex icons, on clickable buttons

Emacsはクリックできるボタン(あるいは情報を提供するためのアイコン)を表示するときがあり、これらの表示のされかたをカスタマイズできます。

@vindex icon-preference
ここでのカスタマイズにおける主要ポイントはユーザーオプション@code{icon-preference}です。これを使うことによって、アイコンにたいするあなたの全般的な嗜好を伝えることができるのです。このユーザーオプションはアイコンのタイプのリストで、サポートされている最初のアイコンタイプが使用されます。サポートされているタイプは:

@table @code
@item image
アイコンにイメージを使用します。

@item emoji
アイコンにカラフルな絵文字を使用します。

@item symbol
アイコンに白黒のシンボルを使用します。

@item text
アイコンにシンプルなテキストを使用します。
@end table

更に個々のアイコンを@kbd{M-x customize-icon}でカスタマイズでき、テーマによってアイコンの見栄えを大きく変えることができます。

あるアイコンについての説明を手早く入手するには、@kbd{M-x describe-icon}コマンドを使用してください。

@node Text Scale
@section テキストのスケール

@cindex adjust buffer font size
@cindex font size of @code{default} face, increase or decrease
@findex text-scale-adjust
@kindex C-x C-+
@kindex C-x C--
@kindex C-x C-=
@kindex C-x C-0
@kindex C-wheel-down
@kindex C-wheel-up
  カレントバッファーの@code{default}フェイスのフォントサイズを大きくするには、@kbd{C-x C-+}または@kbd{C-x
C-=}、小さくするには@kbd{C-x C--}をタイプします。デフォルトのフォントサイズ(グローバル)に復元するには、@kbd{C-x
C-0}とタイプします。これらのキーは、すべて同じコマンド@code{text-scale-adjust}にバインドされています。このコマンドは最後にタイプされたキーを判断してどの処理を行うかを判断、処理に応じてデフォルトフェイスの高さを変更してフォントサイズを調節します。

  多くのフェイスの@code{:height}属性には明確なセッティングがされておらず、高さを@code{default}フェイスから継承するものがほとんどです。したがって上記のコマンドによってこれらのフェイスもスケーリングされます。

  @code{default}以外で@code{:height}属性に明確なセッティングをもつフェイスでは、これらのフォントサイズの影響を受けません。ただし@code{header-line}フェイスは例外です。たとえ@code{:height}属性に明確なセッティングがあっても、このフェイはスケーリングされます。

  同様にマウスポインターがバッファーテキスト上にある際に@kbd{Ctrl}修飾キーを押下してマウスホイールをスクロールすると、スクロール方向に応じて影響を受けるフェイスのフォントサイズを増加あるいは減少します。

  これらのコマンドの最後のキーは、@kbd{C-x}を前置せず修飾キーなしで繰り返すことができます。たとえば@w{@kbd{C-x C-= C-=
C-=}}と@w{@kbd{C-x C-= =
=}}は、どちらもフェイスの大きさを3段階に大きくします。各ステップで大きくなる倍率は1.2です。この倍率を変更するには、変数@code{text-scale-mode-step}をカスタマイズします。@code{text-scale-adjust}コマンドに数引数0を指定すると、@kbd{C-x
C-0}とタイプしたのと同様に、デフォルトの大きさに復元します。

@cindex adjust global font size
@findex global-text-scale-adjust
@vindex global-text-scale-adjust-resizes-frames
@kindex C-x C-M-+
@kindex C-x C-M-=
@kindex C-x C-M--
@kindex C-x C-M-0
@kindex C-M-wheel-down
@kindex C-M-wheel-up
  同様にフォントサイズをグローバルに変更するには@kbd{C-x C-M-+}、@kbd{C-x C-M-=}、@kbd{C-x
C-M--}、@kbd{C-x
C-M-0}、あるいは修飾キーの@kbd{Ctrl}と@kbd{Meta}を両方押したままマウスホイールをスクロールしてください。フォントのサイズがグローバルに変更された際のフレーズのリサイズを有効にするには、変数@code{global-text-scale-adjust-resizes-frames}をカスタマイズしてください(@ref{Easy
Customization}を参照)。

@cindex increase buffer font size
@findex text-scale-increase
@cindex decrease buffer font size
@findex text-scale-decrease
  コマンド@code{text-scale-increase}と@code{text-scale-decrease}は、@kbd{C-x
C-+}や@kbd{C-x
C--}と同じようにカレントバッファーのフォントサイズを増加または減少させます。キーをバインドする場合には、これらのコマンドのほうが@code{text-scale-adjust}より便利でしょう。

@cindex set buffer font size
@findex text-scale-set
  コマンド@code{text-scale-set}は、数引数でカレントバッファーのフォントサイズを絶対倍率で指定します。

@findex text-scale-mode
  上記のコマンドは、現在のフォント倍率が1以外のときは、自動的にマイナーモード@code{text-scale-mode}を有効にし、そうでない場合は無効にします。

@cindex pinch to scale
@findex text-scale-pinch
  コマンド@code{text-scale-pinch}はタッチパッドに2本の指を置いて、互いに近づけたり離したりというピンチジェスチャーを行った際に、指の間の距離にもとづいてテキストのサイズを拡大あるいは縮小します。このコマンドはサポートされているハードウェアをもつ一部のシステムでのみ利用できます。

@findex mouse-wheel-text-scale
  コマンド@code{mouse-wheel-text-scale}でもテキストのスケールの変更ができます。このコマンドは、通常は@key{Ctrl}を押したままマウスホイールを動かすことにより実行されます。テキストのスケーリングはホイールを下方に動かすと拡大、上方に動かすと縮小されます。

@node Font Lock
@section Font Lockモード
@cindex Font Lock mode
@cindex mode, Font Lock
@cindex syntax highlighting and coloring

  Font
Lockモードはマイナーモードで、常に特定のバッファーにローカルで、バッファーのテキストにフェイスを割り当てます(または@dfn{フォント表示化(fontifies)します})。各バッファーのメジャーモードは、Font
Lockモードにどのテキストをフォント表示可するか指示します。たとえばプログラム言語のモードは、コメントや文字列、関数名のような、構文に関連する構成をフォント表示化します。

@findex font-lock-mode
  Font
Lockモードは、それをサポートするメジャーモードでは、デフォルトで有効になっています。カレントバッファーでこれを切り替えるには、@kbd{M-x
font-lock-mode}とタイプします。正の数引数は無条件にFont Lockモードを有効にし、負または0の数引数を指定すると無効になります。

@findex global-font-lock-mode
@vindex global-font-lock-mode
  @kbd{M-x global-font-lock-mode}とタイプすると、すべてのバッファーでFont
Lockモードを切り替えます。このセッティングを将来のEmacsセッションに引き継ぐには、変数@code{global-font-lock-mode}をカスタマイズ(@ref{Easy
Customization}を参照してください)するか、以下の行をinitファイルに追加します。

@example
(global-font-lock-mode 0)
@end example

@noindent
Global Font Lockモードを無効にしていたとしても、モードフック(mode
hooks)に関数を追加することにより、特定のメジャーモードでFont Lockモードを有効にできます。たとえばCファイルの編集でFont
Lockモードを有効にするには、以下のように記述します:

@example
(add-hook 'c-mode-hook 'font-lock-mode)
@end example

  Font
Lockモードは、@code{font-lock-string-face}、@code{font-lock-comment-face}のような、いくつかの特別な名前のフェイスを使って処理を行います。これらすべてを簡単に探す方法には、@kbd{M-x
customize-group @key{RET} font-lock-faces
@key{RET}}を使います。それからカスタマイズバッファーでそれらのフェイスの外見をカスタマイズできます。@ref{Face
Customization}を参照してください。

@cindex just-in-time (JIT) font-lock
@cindex background syntax highlighting
  非常に大きいバッファーのフォント表示化には、長い時間を要することもあります。ファイルをvisitしたとき大きな遅延を避けるには、Emacsが最初はバッファーの表示された部分だけをフォント表示化するようにします。バッファーをスクロールすると、新たに表示される部分がフォント表示化されます。このタイプのFont
Lockは、@dfn{Just-In-Time}(または@dfn{JIT})
Lockと呼ばれます。カスタマイズグループ@samp{jit-lock}の値をカスタマイズすることにより、アイドル状態のときにフォント表示可を行うことも含めて、JIT
Lockがどのように振る舞うか制御できます。@ref{Specific Customization}を参照してください。

  バッファーのどの部分のテキストをフォント表示するか、そしてどのフェイスを使用するかをメジャーモードが判断するために用いるのは、異なる複数のテキスト分析手法にもとづく情報かもしれません:

@itemize @bullet
@item
正規表現によるキーワードやその他テキストパターンの検索(@ref{Regexp Search,, Regular Expression
Search}を参照)。

@item
組み込み構文テーブルにもとづき構文的に異なる部分をテキストから検索(@ref{Syntax Tables,,, elisp, The Emacs
Lisp Reference Manual}を参照)。

@item
tree-sitterライブラリーのような特殊用途用ライブラリーや外部プログラムを通じて、本格的パーサーが生成した構文木を使用する(@ref{Parsing
Program Source,,, elisp, The Emacs Lisp Reference Manual}を参照)。
@end itemize

@menu
* Traditional Font Lock::    正規表現や構文テーブルにもとづくフォントロック。
* Parser-based Font Lock::   外部パーサーにもとづくフォントロック。
@end menu

@node Traditional Font Lock
@subsection 伝統的なFont Lock
@cindex traditional font-lock

  フォントロック情報を提供するための``伝統的''な手法は正規表現検索、およびEmacsに組み込まれた構文テーブルを用いた構文解析にもとづいています。このサブセクションでは、これら伝統的手法を用いるメジャーモードでのフォントロックの用法とカスタマイズについて説明します。

@vindex font-lock-maximum-decoration
  変数@code{font-lock-maximum-decoration}をカスタマイズして、この機能をサポートするメジャーモードにたいして、Font
Lockモードで適用されるフォント表示化の量を制御できます。この変数の値には数字を指定します(1は最小限のフォント表示化で、3という高いレベルのモードもあります)。@code{t}は``可能な限り高く''という意味です(デフォルト)。効果を得るには、そのファイルがvisitされる@emph{前}に@code{font-lock-maximum-decoration}をカスタマイズするべきです。この変数をカスタマイズする時点で、すでにそのファイルをバッファーでvisitしている場合は、そのバッファーをkillしてから、スタマイズ後に再度そのファイルをvisitしてください。

特定のモードに異なる数字を指定することもできます。たとえばC/C++モードにはレベル1を指定して、他のモードにはデフォルトのレベルを適用するには、以下の値を使います

@example
'((c-mode . 1) (c++-mode . 1)))
@end example

@cindex incorrect fontification
@cindex parenthesis in column zero and fontification
@cindex brace in column zero and fontification
  コメントと文字列のフォント表示化(または``構文的''なフォント表示化)は、バッファーのテキストの構文構造の解析に依存します。速度向上のため、Lispモードを含めたいくつかのモードでは、特別な慣習に依存しています。たとえば一番左の列の開きカッコ(open-parenthesis)または開き大カッコ(open-brace)は常にdefunの開始であり、すなわち常に文字列またはコメントの外部にあるとみなす、というように解析します。したがって文字列やコメントの中で、一番左の列に開きカッコや開き大カッコを記述するのは避けるべきです。詳細については、@ref{Left
Margin Paren}を参照してください。

@findex font-lock-add-keywords
  Font
Lockは、ほとんどのモードで既存のパターンをハイライトしますが、追加のパターンをフォント表示化したいときもあるでしょう。特定のモードでハイライトするパターンを追加するには、関数@code{font-lock-add-keywords}を使うことができます。たとえばCコメント中の@samp{FIXME:}という単語をハイライトするには、以下を使います:

@example
(add-hook 'c-mode-hook
          (lambda ()
           (font-lock-add-keywords nil
            '(("\\<\\(FIXME\\):" 1
               font-lock-warning-face t)))))
@end example

@findex font-lock-remove-keywords
@vindex font-lock-ignore
@noindent
font-lockのハイライトパターンからキーワードを削除するには、関数@code{font-lock-remove-keywords}を使います。@ref{Search-based
Fontification,,, elisp, The Emacs Lisp Reference
Manual}を参照してください。かわりに@code{font-lock-ignore}オプションをカスタマイズすれば、いくつかのキーワードによって選択的にハイライトを無効にすることもできます。@ref{Customizing
Keywords,,, elisp, The Emacs Lisp Reference Manual}を参照してください。

@node Parser-based Font Lock
@subsection パーサーベースのFont Lock
@cindex font-lock via tree-sitter
@cindex parser-based font-lock
  Emacsをtree-sitterライブラリーとともにビルドした場合には、フォント表示化に際してそのライブラリーがバッファーのテキストをパースした結果を使うことができます。tree-sitterライブラリーはサポートしているプログラミング言語やその他のフォーマットされたテキストにたいして本格的なパーサーを提供するので、通常は前のサブセクションで説明した``伝統的''な手法より高速かつ正確です。tree-sitterライブラリーを利用するメジャーモードには@code{@var{foo}-ts-mode}という名前がつけられています(@samp{-ts-}の部分がそのライブラリーを使用することを示す)。このサブセクションでは、tree-sitterライブラリーにもとづくFont
Lockサポートについて説明します。

@vindex treesit-font-lock-level
  変数@code{treesit-font-lock-level}をカスタマイズして、tree-sitterにもとづくメジャーモードのFont
Lockモードに適用するフォント表示化の量を制御できます。変数の値は1から4の数値です:

@table @asis
@item Level 1
このレベルでは、通常はコメントおよび関数定義の関数名だけをフォント表示します。
@item Level 2
このレベルではキーワード、文字列、データタイプへのフォント表示化が追加されます。
@item Level 3
デフォルトのレベルです。割り当て、数値等のフォント表示化が追加されます。
@item Level 4
このレベルでは演算子、区切り文字、カッコ、その他の句読点文字、関数呼び出し内の関数名、プロパティ参照、変数などフォント表示化が可能なすべてが追加されます。
@end table

@vindex treesit-font-lock-feature-list
@noindent
上記で示した構文的カテゴリーそれぞれが正確には何によって構成するかはメジャーモード、およびそのメジャーモードの言語にたいしてtree-sitterが使用するパーサーグラマー(parser
grammar:
解析文法)に依存します。とはいうものの、このカテゴリーは一般的にはそのメジャーモードによってサポートされるプログラミング言語やファイルフォーマットの規約にしたがいます。変数@code{treesit-font-lock-feature-list}のバッファーローカル値には、tree-sitterベースのメジャーモードがサポートしているフォント表示化機能が保持されています。このリストの要素は、その要素が対応するフォント表示化レベルが提供する機能を示すリストです(訳注:
GNU Emacsのソースに含まれるadmin/notes/tree-sitter/starter-guideに値の例があるので参考にしてください)。

  @w{@kbd{M-x customize-variable}} (@ref{Specific
Customization}を参照)を通じて@code{treesit-font-lock-level}の値を変更すれば既存のすべてのバッファー、および同一セッションにおいて今後visitするすべてのファイルに即座に効果が表れます。


@node Highlight Interactively
@section インタラクティブなハイライト
@cindex highlighting by matching
@cindex interactive highlighting
@cindex Highlight Changes mode

@findex highlight-changes-mode
Highlight
Changesモードは、最近変更されたバッファー部分のテキストに、異なるフェイスを与えることにより@dfn{ハイライト}するマイナーモードです。Highlight
Changesモードを有効または無効にするには、@kbd{M-x highlight-changes-mode}を使います。

@cindex Hi Lock mode
@findex hi-lock-mode
  Hi
Lockモードは、指定した正規表現にマッチするテキストをハイライトする、マイナーモードです。たとえば、プログラムのソースファイルで、特定の変数へのすべての参照をハイライトしたり、何らかのプログラムの大量の出力の一部をハイライトしたり、記事中の特定の名前をハイライトするために使用できます。Hi
Lockモードを有効または無効にするには、コマンド@kbd{M-x hi-lock-mode}を使います。すべてのバッファーでHi
Lockモードを有効にするには、@kbd{M-x
global-hi-lock-mode}を使うか、@file{.emacs}ファイルに@code{(global-hi-lock-mode
1)}と記述してください。

  Hi LockモードはFont Lockモード(@ref{Font
Lock}を参照してください)と同じように動作しますが、ハイライトするパターンを明示的に正規表現で指定します。これらは以下のコマンドで制御できます(@kbd{C-x
w}で始まるキーバインドは、@kbd{M-s
h}で始まるグローバルなバインドが優先されるため推奨されておらず、将来のEmacsのバージョンで廃止されるでしょう)。

@table @kbd
@item M-s h r @var{regexp} @key{RET} @var{face} @key{RET}
@itemx C-x w h @var{regexp} @key{RET} @var{face} @key{RET}
@kindex M-s h r
@kindex C-x w h
@findex highlight-regexp
@var{regexp}にマッチするテキストを、フェイス@var{face}を使ってハイライトします(@code{highlight-regexp})。ハイライトはバッファーがロードされている限り残ります。たとえば単語``whim''をデフォルトのフェイス(黄色いバックグラウンドカラー)でハイライトするには、@kbd{M-s
h r whim @key{RET} @key{RET}}とタイプします。ハイライトには任意のフェイスを使うことができますが、Hi
Lockモードはモード自身でいくつかのフェイスを提供しており、それらはデフォルト値のリストに事前ロードされています。フェイスの入力プロンプトで@kbd{M-n}と@kbd{M-p}を使うことにより、それらを巡回することができます。プレフィクス数引数は対応する部分式にハイライトを制限します。

@vindex hi-lock-auto-select-face
オプション@code{hi-lock-auto-select-face}に非@code{nil}値をセットすることにより、このコマンド(およびその他のフェイスを読みとるHi
Lockコマンド)は、入力を求めることなく、デフォルト値のリストから次のフェイスを自動的に選択します。

このコマンドを複数回使用して、さまざまな正規表現を指定し、それぞれを異なる方法でハイライトできます。

@item M-s h u @var{regexp} @key{RET}
@itemx C-x w r @var{regexp} @key{RET}
@kindex M-s h u
@kindex C-x w r
@findex unhighlight-regexp
@var{regexp}のハイライトを解除します(@code{unhighlight-regexp})。メニューから呼び出した場合、ハイライト解除する正規表現をリストから選択します。キーボードから呼び出した場合は、ミニバッファーを使います。一番最近追加された正規表現を表示し、@kbd{M-n}を使って次に古い正規表現、@kbd{M-p}で次に新しい正規表現を表示できます(手入力もでき、その場合は補完機能つきです)。ハイライト解除したい正規表現がミニバッファーに表示されたら、@kbd{@key{RET}}を押してミニバッファーを抜けだし、ハイライトを解除できます。

@item M-s h l @var{regexp} @key{RET} @var{face} @key{RET}
@itemx C-x w l @var{regexp} @key{RET} @var{face} @key{RET}
@kindex M-s h l
@kindex C-x w l
@findex highlight-lines-matching-regexp
@cindex lines, highlighting
@cindex highlighting lines of text
@var{regexp}とのマッチを含む行全体を、フェイス@var{face}を使ってハイライトします(@code{highlight-lines-matching-regexp})。

@item M-s h p @var{phrase} @key{RET} @var{face} @key{RET}
@itemx C-x w p @var{phrase} @key{RET} @var{face} @key{RET}
@kindex M-s h p
@kindex C-x w p
@findex highlight-phrase
@cindex phrase, highlighting
@cindex highlighting phrase
@var{phrase}にマッチするフレーズを、フェイス@var{face}でハイライトします(@code{highlight-phrase})。@var{phrase}には正規表現を指定できますが、スペースは空白文字にマッチする正規表現に置き換えられます。また、先頭に小文字を使用することにより、大文字小文字を区別しなくなります。

@item M-s h .
@itemx C-x w .
@kindex M-s h .
@kindex C-x w .
@findex highlight-symbol-at-point
@cindex symbol, highlighting
@cindex highlighting symbol at point
ポイントの近くで見つかったシンボルを、次に利用可能なフェイスでハイライトします(@code{highlight-symbol-at-point})。

@item M-s h w
@itemx C-x w b
@kindex M-s h w
@kindex C-x w b
@findex hi-lock-write-interactive-patterns
現在ハイライトを行っている正規表現/フェイスのペアを、バッファーのポイント位置に挿入します。挿入はプログラムを変更してしまわないように、コメント文字列でコメント化されます(このキーバインドは@code{hi-lock-write-interactive-patterns}コマンドを実行します)。

これらのパターンは、コメントからも逆抽出されます。それは、コメントに記述されたテキストが適正で、@kbd{M-x
hi-lock-find-patterns}を呼び出した、あるいはHi
Lockモードが有効なときファイルをvisit(これは@code{hi-lock-find-patterns}を実行します)したときです。

@item M-s h f
@itemx C-x w i
@kindex M-s h f
@kindex C-x w i
@findex hi-lock-find-patterns
正規表現/フェイスのペアを、現在のバッファーのコメントから抽出します(@code{hi-lock-find-patterns})。これらのコマンドを使えば、@code{highlight-regexp}でパターンを対話的に入力、@code{hi-lock-write-interactive-patterns}でそれをファイルに保存、それらを編集(あるマッチのフェイスを別のフェイスにしたり)、そして最後にこのコマンド(@code{hi-lock-find-patterns})で編集済みのパターンを、Hi
Lockのハイライトに適用することができます。

@vindex hi-lock-file-patterns-policy
変数@code{hi-lock-file-patterns-policy}はファイルをvisitしたとき、Hi
Lockモードがパターンを探して、それを自動的に抽出するべきかを制御します。値には@code{nil}(ハイライトしない)、@code{ask}(ユーザーに尋ねる)、または関数を指定します。関数の場合、@code{hi-lock-find-patterns}はパターンを引数としてその関数を呼び出します。関数が非@code{nil}を返した場合、パターンを使用します。デフォルトは@code{ask}です。直接@code{hi-lock-find-patterns}を呼び出した場合、この変数の値に関係なく、常にパターンはハイライトされることに注意してください。

@vindex hi-lock-exclude-modes
現在のメジャーモードのシンボルが、リスト@code{hi-lock-exclude-modes}のメンバーの場合、@code{hi-lock-find-patterns}は何もしません。
@end table

@node Fringes
@section ウィンドウのフリンジ
@cindex fringes

@findex set-fringe-style
@findex fringe-mode
@vindex fringe-mode @r{(variable)}
  グラフィカルなディスプレイでは、通常Emacsの各ウィンドウの左右の端に、狭い@dfn{フリンジ(fringes:
縁、へり)}があります。フリンジは、ウィンドウのテキストに関する情報を提供するシンボルの表示に使用されます。@kbd{M-x
fringe-mode}とタイプしてフリンジ表示を切り替えたり、幅を変更できます。このコマンドは全フレームのフリンジに影響します。選択されたフレームのフリンジだけを変更するには、@kbd{M-x
set-fringe-style}を使います。変数@code{fringe-mode}をカスタマイズして、フリンジへの変更を永続化できます。

  フリンジのもっとも一般的な使われかたは、継続行の表示です(@ref{Continuation
Lines}を参照してください)。テキストの1行が複数のスクリーン行に分割されるとき、最初の行を除いた各行の左フリンジには曲矢印が表示され、その行の先頭が実際の行頭ではないことを示します。そして、最後の行を除いた各行の右フリンジにも曲矢印が表示され、その行の最後が実際の行末ではないことを示します。行の方向が右から左(@ref{Bidirectional
Editing}を参照してください)の場合、フリンジの曲矢印の意味は逆になります。

  行が切り詰められているとき(@ref{Line
Truncation}を参照してください)は水平方向の直矢印を表示して、この行には水平スクロールしなければ見ることのできないテキストがあることを示します。矢印の上でマウスをクリックすれば、矢印の指す方向に水平スクロールします。

  フリンジはバッファーの境界(@ref{Displaying
Boundaries}を参照)やウィンドウ下端付近の使用されていない行、デバッグ(@ref{Debuggers}を参照)しているプログラムが実行中であることを示すためにも使われます。

@vindex overflow-newline-into-fringe
  現在の行がウィンドウの幅と正確に一致して、ポイントがその行の行末にある場合、フリンジにはカーソルが描画されます。これを無効にするには、変数@code{overflow-newline-into-fringe}を@code{nil}に変更します。これによりEmacsはウィンドウ幅と同じ長さの行にたいしても、継続または切り詰めを行います。

  表示されているウィンドウの片側、または両側のフリンジを削除するために@code{fringe-mode}をカスタマイズする場合、フリンジ上にに表示する機能は利用できなくなりますが、行の継続と切り詰めの標識は例外です。フリンジが利用できない場合、Emacsは特別なASCII文字(@ref{Continuation
Lines}、および@ref{Line
Truncation}を参照してください)により、行の継続と切り詰めを示すために、最左および最右の文字セルを使用します。行の継続と切り詰めの標識に使用される文字セルは、この目的のために予約されるので、各行に表示するテキストのための列数は減少します。バッファーのテキストには双方向のテキスト、およびleft-to-right(左から右)とright-to-left(右から左)の両方のパラグラフ(@ref{Bidirectional
Editing}を参照してください)が含まれるかもしれないので、、片側のフリンジを削除しただけでは依然として2つの文字セルが予約されます。つまり行の継続と切り詰めの標識のために、ウィンドウの両側にそれぞれ1つの文字セルが予約されます。なぜなら、right-to-leftのパラグラフでは、これらの標識はウィンドウの反対側に表示されるからです。

@node Displaying Boundaries
@section バウンダリーの表示

@cindex mode, display-fill-column-indicator
@findex display-fill-column-indicator-mode
@findex global-display-fill-column-indicator-mode
  Emacsに@code{fill-column}の位置(@ref{Fill
Commands}を参照)を表示するインジケーターを追加できます。フィル列インジケーターは特に@code{prog-mode}とその派生モード(@ref{Major
Modes}を参照)においてプログラムのソースコードのフォーマットにたいして特別な意味をもつ特定の列位置を示すために有用な機能です。これは等幅フォント(fixed-ｐpitch
font)のすべての文字を想定した機能です。ここで等幅フォントとはすべての文字の幅が等しいフォントのことです(全角文字は例外かもしれない)。可変幅フォント(variable-pitch
font)を使用バッファーでは、行が異なればフィル列インジケーターは不揃いに表示されるかもしれません。

  フィル列インジケーターの表示を有効にするには、インジケーターをローカルまたはグローバルに有効にする、@code{display-fill-column-indicator-mode}または@code{global-display-fill-column-indicator-mode}のマイナーモードを使用します。

かわりにインジケーターの有効化とインジケートに使用する文字の制御に、@code{display-fill-column-indicator}と@code{display-fill-column-indicator-character}という2つのバッファーローカル変数セットできます。インジケーターを表示するためには、これらの変数がどちらも非@code{nil}でなければならないことに注意してください(マイナーモードをオンにすることによりこれらの変数がセットされる)。

このモードをカスタマイズするために2つのバッファーローカル変数と1つのフェイスがあります:

@table @code
@item display-fill-column-indicator-column
@vindex display-fill-column-indicator-column
インジケーターをセットするべき列数を指定します。列にたいする正の数値、あるいは変数@code{fill-column}の値の使用を意味する@code{t}を指定できます。

それ以外の値ではインジケーターは無効になります。デフォルト値は@code{t}です。

@item display-fill-column-indicator-character
@vindex display-fill-column-indicator-character
インジケーターに使用する文字を指定します。フォントがサポートすれば、Unicode文字を含む任意の文字を指定できます。値@code{nil}はインジケーターを無効にします。@code{display-fill-column-indicator-mode}や@code{global-display-fill-column-indicator-mode}でモードを有効にしたときは、値が非@code{nil}ならばこの変数が指定する文字が使用されます。それ以外ならEmacsは文字U+2502
@sc{box drawings light vertical}、U+2502が表示できなければフォールバックとして@samp{|}を使用します。

@item fill-column-indicator
@vindex fill-column-indicator
インジケーターの表示に使用するフェイスを指定します。これはバックグラウンドカラーを除くデフォルト値をフェイス@code{shadow}から継承します。インジケーターのカラーを変更するために必要なのは、このフェイスのフォアグラウンドカラーのセットだけです。
@end table

@vindex indicate-buffer-boundaries
  グラフィカルなディスプレイでは、Emacsはバッファーのバウンダリー(boundary:
境界)を、フリンジに表示することもできます。この機能を有効にすると、最初の行と最後の行ではフリンジに、かぎカッコが表示されます。上矢印または下矢印の場合、それはウィンドウをその方向に、もっとスクロールできることを示します。

  バッファーローカルな変数@code{indicate-buffer-boundaries}は、バッファーのバウンダリーととウィンドウのスクロールが、フリンジでどのように表示されるかを制御します。値が@code{left}(または@code{right})の場合、かぎカッコと矢印のビットマップは、左フリンジ(または右フリンジ)に表示されます。

  値がalist(association list: 連想リスト。@ref{Association Lists,,, elisp, the Emacs
Lisp Reference Manual}を参照してください)の場合、各要素の@code{(@var{indicator} .
@var{position})}で、標識(indicator)の位置(position)を指定します。@var{indicator}には@code{top}、@code{bottom}、@code{up}、@code{down}、または@code{t}(指定されていない標識のデフォルト位置)を指定します。@var{position}には@code{left}、@code{right}、または@code{nil}(標識を表示しない)を指定します。

  たとえば@code{((top . left) (t
.
right))}は、最上行の左フリンジにかぎカッコを表示し、右フリンジには最下行のかぎカッコとスクロール矢印を表示します。左フリンジにかぎカッコだけを表示させる場合は、@code{((top
.  left)  (bottom . left))}を使います。

@node Useless Whitespace
@section 不要なスペース

@cindex trailing whitespace
@cindex whitespace, trailing
@vindex show-trailing-whitespace
  意識せずに不必要なスペースを行末に残してしまったり、バッファーの最後に空行を残してしまうことはよくあります。ほとんどの場合、そのような@dfn{行末の空白文字(trailing
whitespace)}は何の影響も及ぼしませんが、厄介物になる場合もあります。

@cindex @code{trailing-whitespace} face
  バッファーローカルな変数@code{show-trailing-whitespace}を@code{t}にセットすることにより、行末の空白文字を可視化できます。これによりEmacsはフェイス@code{trailing-whitespace}で、行末の空白文字を表示します。

  この機能は行末に空白文字を含む行の、行末にポイントがあるときは適用されません。厳密にいえば、これも行末の空白文字なのですが、それを特別に表示してしまうと、新しいテキストをタイプするとき面倒です。このような特別なケースでは、ポイントの位置に表示されるカーソルより、空白文字があることが自明だからです。

@findex delete-trailing-whitespace
@vindex delete-trailing-lines
  @kbd{M-x
delete-trailing-whitespace}とタイプすると、すべての行末の空白文字を削除します。このコマンドは、バッファー内の各行の行末にあるすべての余分なスペースと、バッファーの最後にある空行を削除します。バッファー内の空行を削除しない場合は、変数@code{delete-trailing-lines}を@code{nil}に変更してください。リージョンがアクティブのときは、リージョン内の各行の行末の余分なスペースを削除します。

@vindex indicate-empty-lines
@cindex unused lines
@cindex fringes, and unused line indication
@anchor{indicate-empty-lines}
  グラフィカルなディスプレイでは、Emacsはウィンドウの最後の使われていない行の左フリンジに小さなイメージを表示して、それを示すことができます。このイメージはバッファーのテキストが何も含まれていないスクリーン行に表示されるので、バッファーの最後にある空行は、このイメージが表示されないことで見分けることができます。この機能を有効にするにはバッファーローカルな変数@code{indicate-empty-lines}に非@code{nil}値をセットします。すべての新しいバッファーでこの機能を有効または無効にするには、この変数のデフォルト値をセットします(例
@code{(setq-default indicate-empty-lines t)})

@cindex Whitespace mode
@cindex mode, Whitespace
@findex whitespace-mode
@vindex whitespace-style
@findex whitespace-toggle-options
  Whitespaceモードはバッファーローカルなマイナーモードで、バッファー内にある多くの種類の空白文字を視覚化します。これは空白文字を特別なフェイスで描画するか、特別なグリフで表示することにより行われます。このモードを切り替えるには、@kbd{M-x
whitespace-mode}とタイプします。視覚化される空白文字の種類は、リスト変数@code{whitespace-style}により決定されます。@w{@kbd{M-x
whitespace-toggle-options}}とタイプして、カレントバッファーでこのリスト内の個々の要素のオンとオフを切り替えることができます。以下はリストに指定できる要素の一部です(完全なリストは変数のドキュメントを参照してください)。

@table @code
@item face
特別なフェイスを使った視覚化をすべて有効にします。この要素には特別な意味があります。もしこれがリストに含まれていない場合、@code{space-mark}、@code{tab-mark}、@code{newline-mark}を除く他の視覚化は効果がなくなります。

@item trailing
行末の空白文字をハイライトします。

@item tabs
タブ文字をハイライトします。

@item spaces
スペースおよびnon-breaking space文字をハイライトします。

@item lines
@vindex whitespace-line-column
80列以上の行をハイライトします。列の上限を変更するには、変数@code{whitespace-line-column}をカスタマイズします。

@item newline
改行をハイライトします。

@item missing-newline-at-eof
バッファーが改行で終端されていなければ最後の文字をハイライトします。

@item empty
バッファーの先頭、および/または終端の空行をハイライトします。

@item big-indent
@vindex whitespace-big-indent-regexp
非常に深いインデントをハイライトします。デフォルトでは、少なくとも4個の連続するTAB文字と、32個の連続するスペースからなる、任意のシーケンスがハイライトされます。これを変更するには、正規表現@code{whitespace-big-indent-regexp}をカスタマイズしてください。

@item space-mark
スペースとnon-breaking文字を特別なグリフで描画します。

@item tab-mark
タブ文字を特別なグリフで描画します。

@item newline-mark
改行文字を特別なグリフで描画します。
@end table

@findex global-whitespace-toggle-options
@findex global-whitespace-mode
Global
Whitespaceモードは、すべてのバッファーで空白文字を視覚化する、グローバルなマイナーモードです。この機能を個別に切り替えるには、@kbd{M-x
global-whitespace-toggle-options}を使用してください。

@node Selective Display
@section 選択的な表示
@cindex selective display
@findex set-selective-display
@kindex C-x $

  Emacsには、与えられたレベルより多くインデントされた行を隠す機能があります。これをプログラムの概要を理解するのに使うことができます。

  現在のバッファーの行を隠すには、数引数@var{n}を指定して@kbd{C-x $}
(@code{set-selective-display})をタイプします。すると少なくとも@var{n}列のインデントをもつ行は、スクリーンに表示されなくなります。隠された行の存在を示すのは、表示されている行末に表示された3つのドット(@samp{@dots{}})だけで、これは1行以上の行が後に隠されていることを意味します。

  コマンド@kbd{C-n}および@kbd{C-p}は、隠された行が存在しないかのように、隠された行をスキップして移動します。

  隠された行は依然としてバッファーに存在し、ほとんどの編集コマンドはそれらを見ることができるので、隠されな行にポイントを移動することもありえます。これが起こるとカーソルは前の行の最後、つまり3つのドットの後ろに表示されます。ポイントが表示されている行の行末、つまり改行の前にある場合、カーソルは3つのドットの前に表示されます。

  隠された行のすべてを再び表示するには、引数を指定せずに@kbd{C-x $}とタイプしてください。

@vindex selective-display-ellipses
  変数@code{selective-display-ellipses}に@code{nil}をセットすると、隠された行があることを示す3つのドットは表示されなくなり、隠された行があることを示す視覚的な表示はなくなります。変数がセットされると、それは自動的にローカルになります。

  バッファーのテキストの一部を隠す他の方法については、@ref{Outline Mode}を参照してください。

@node Optional Mode Line
@section モードラインのオプション

@cindex buffer size display
@cindex display of buffer size
@findex size-indication-mode
  バッファーのパーセント表示@var{pos}は、ウィンドウの上端がバッファーのどの場所にあるかを100分率で示します。@kbd{M-x
size-indication-mode}とタイプしてSize
Indicationモードをオンにすることにより、バッファーのサイズを追加で表示できます。サイズは以下のようにパーセント表示のすぐ後に表示されます:

@example
@var{pos} of @var{size}
@end example

@noindent
@var{size}は、バッファーの文字数を人間が理解しやすい形式(@samp{k}は10^3、@samp{M}は10^6、@samp{G}は10^9などの短縮形が使用されます)で表示します。

@cindex line number display
@cindex display of current line number
@findex line-number-mode
  Line Numberモードが有効なとき、ポイント位置の現在の行番号はモードラインに表示されます。@kbd{M-x
line-number-mode}コマンドを使って、Line
Numberモードのオンとオフを切り替えることができます(通常はオンです)。行番号はそれが何であるかを示す文字@samp{L}とともに、バッファーのパーセント表示@var{pos}の後ろに表示されます。

@cindex Column Number mode
@cindex mode, Column Number
@findex column-number-mode
  同様に、@kbd{M-x column-number-mode}でColumn
Numberモードをオンにすることにより、現在の列番号を表示できます。列番号は文字@samp{C}で示されます。しかし両方のモードが有効になっているときは、行番号と列番号は@samp{L}や@samp{C}ではなく、@samp{(561,2)}のようにカッコつきで表示されます。マイナーモードとこれらのコマンドの使い方については、@ref{Minor
Modes}を参照してください。

@vindex column-number-indicator-zero-based
  Column
Numberモードでは、列番号はそのウィンドウの左マージンより0からカウントされます。1からカウントした列番号を表示したい場合は、@code{column-number-indicator-zero-based}を@code{nil}にセットしてください。

@cindex narrowing, and line number display
  ナローイング(@ref{Narrowing}を参照してください)によりバッファーを制限している場合、アクセスできる部分にもとづいた行番号が表示されます。そのため、これは@code{goto-line}の引数として使用するには適しません(コマンド@code{what-line}はファイル全体にたいする相対行番号を表示する)。ナローされたバッファーのアクセス可能範囲に相対的な行へポイントを移動するには@code{goto-line-relative}コマンドを使用できます。

@vindex line-number-display-limit
  バッファーが非常に大きい場合(@code{line-number-display-limit}の値より大)、速度が遅くなるのでEmacsは行番号を計算しません。そのためモードラインに行番号は表示されません。この制限を取り除くには、@code{line-number-display-limit}に@code{nil}をセットします。

@vindex line-number-display-limit-width
  バッファーの行が長いときも、行番号の計算が遅くなります。この理由により、Emacsはポイントの近くの行の幅の平均文字数が、@code{line-number-display-limit-width}より大きいときは、行番号を表示しません。デフォルト値は200文字です。

@findex display-time
@cindex time (on mode line)
  Emacsはオプションで、時刻とシステムロードを、すべてのモードラインで表示できます。この機能を有効にするには、@kbd{M-x
display-time}とタイプするか、オプション@code{display-time-mode}をカスタマイズします。モードラインに追加される情報は以下のような形式です:

@example
@var{hh}:@var{mm}PM @var{l.ll}
@end example

@noindent
@vindex display-time-24hr-format
ここで@var{hh}と@var{mm}は時間と分で、後ろに@samp{AM}と@samp{PM}がつきます。@var{l.ll}は、過去数分間における、システム全体で実行中または実行準備ができている(例:
利用可能なプロセッサー待ち)プロセスの平均数です(オペレーティングシステムがサポートしないフィールドは表示されません)。時刻を24時間表示にしたいときは、変数@code{display-time-24hr-format}に@code{t}をセットしてください。

@cindex mail (on mode line)
@vindex display-time-use-mail-icon
@vindex display-time-mail-face
@vindex display-time-mail-file
@vindex display-time-mail-directory
  もし未読メールがある場合、ロードレベルの後ろに@samp{Mail}という単語が表示されます。グラフィカルなディスプレイでは、@code{display-time-use-mail-icon}をカスタマイズすることにより、@samp{Mail}のかわりにアイコンを使うことができます。これによりモードラインのスペースが多少節約できます。@code{display-time-mail-face}をカスタマイズして、メールの表示を目立たせることができます。@code{display-time-mail-file}を使ってチェックするメールファイルを指定したり、@code{display-time-mail-directory}で受信メールのディレクトリーを指定できます(ディレクトリー内の空でない普通のファイルは、新しい受信メールと判断されます)。

@cindex battery status (on mode line)
@findex display-battery-mode
@vindex display-battery-mode
@vindex battery-mode-line-format
  Emacsをラップトップコンピューターで実行している場合、コマンド@code{display-battery-mode}を使うか、変数@code{display-battery-mode}をカスタマイズすることにより、モードラインにバッテリー充電状況を表示できます。変数@code{battery-mode-line-format}は、バッテリーの充電状況の表示方法を決定します。モードラインに表示されるメッセージの正確さはオペレーティングシステムに依存しており、通常はバッテリーの充電トータルにたいする現在のバッテリー充電率が表示されます。@code{battery-update-functions}の関数の実行はモードラインの更新後であり、バッテリー状況にもとづいたアクションをトリガーするために使用できます。

@cindex mode line, 3D appearance
@cindex attributes of mode line, changing
@cindex non-integral number of lines in a window
  グラフィカルなディスプレイでは、モードラインは立体的に描画されます。この効果が気に入らない場合は、@code{mode-line}フェイスをカスタマイズして、@code{box}属性に@code{nil}をセットすることにより無効にできます。@ref{Face
Customization}を参照してください。

@cindex non-selected windows, mode line appearance
  デフォルトでは、選択されていないウィンドウのモードラインは、@code{mode-line-inactive}と呼ばれる、別のフェイスで表示されます。選択されたウィンドウのモードラインだけが、@code{mode-line}フェイスで表示されます。これにより、どのウィンドウが選択されているかがわかりやすくなります。モードラインがないミニバッファーが選択されているときは、ミニバッファーをアクティブにしたウィンドウのモードラインが、@code{mode-line}で表示されます。結果として通常のミニバッファーの使用では、モードラインは変化しません。

@vindex mode-line-in-non-selected-windows
  変数@code{mode-line-in-non-selected-windows}を@code{nil}にセットすることにより、@code{mode-line-inactive}の使用を無効にできます。これによりすべてのモードラインが、@code{mode-line}フェイスで表示されます。

@vindex eol-mnemonic-unix
@vindex eol-mnemonic-dos
@vindex eol-mnemonic-mac
@vindex eol-mnemonic-undecided
  モードラインに表示される改行フォーマットは、変数@code{eol-mnemonic-unix}、@code{eol-mnemonic-dos}、@code{eol-mnemonic-mac}、および@code{eol-mnemonic-undecided}をセットすることにより、カスタマイズできます。

@node Text Display
@section テキストが表示される方法
@cindex characters (in text)
@cindex printing character

  ほとんどの文字は、@dfn{印字文字(printing
characters)}です。これらの文字がバッファーに存在すると、スクリーンにそのまま表示されます。印字文字には@acronym{ASCII}の数字、文字、区切り文字、同様に多くの非@acronym{ASCII}文字が含まれます。

@vindex tab-width
@cindex control characters on display
  @acronym{ASCII}文字セットには、印字されない@dfn{制御文字(control
characters)}が含まれます。その中でも特別に表示されるものが2つあります。1つ目は改行文字(UnicodeのコードポイントU+000A)で、新しい行を開始するのに表示されます。2つ目はタブ文字(U+0009)で、次のタブストップ(通常は8文字ごと)までをスペースで表示します。タブを何文字のスペースで表示するかは、バッファーローカルな変数@code{tab-width}で制御され、1から1000の整数で指定しなければなりません。バッファーのタブ文字が表示される方法は、コマンドとしての@key{TAB}の定義には関係ないことに注意してください。

  他の@acronym{ASCII}制御文字としては、U+0020(8進の40、10進の32)より下のコードがあり、それらはカレット(@samp{^})と、その後ろに非制御文字バージョンの文字を続けて、@code{escape-glyph}フェイスで表示されます。たとえば文字@samp{control-A}(U+0001)は、@samp{^A}と表示されます。

@cindex octal escapes
@vindex ctl-arrow
  コードU+0080(8進の200)からU+009F(8進の237)までのrawバイトは、@code{escape-glyph}フェイスにより@dfn{8進エスケープシーケンス(octal
escape
sequences)}で表示されます。たとえば文字コードU+0098(8進の230)は@samp{\230}と表示されます。バッファーローカルな変数@code{ctl-arrow}を@code{nil}に変更すると、@acronym{ASCII}制御文字もカレットエスケープシーケンスではなく8進エスケープシーケンスで表示されます(rawバイトを16進表示するように要求することも可能。@ref{Display
Custom, display-raw-bytes-as-hex}を参照)。

@vindex nobreak-char-display
@cindex non-breaking space
@cindex non-breaking hyphen
@cindex soft hyphen
@cindex @code{escape-glyph} face
@cindex @code{nobreak-space} face
  非@acronym{ASCII}文字の中には、@acronym{ASCII}のスペースやハイフン(マイナス記号)と同じ外観を持つものがあります。そのような文字は、意識せずにバッファーに入力されたとき(たとえばyankなどで)、問題となることがあります。たとえばソースコードコンパイラーは通常、非@acronym{ASCII}のスペースを、空白文字として扱いません。この問題に対処するため、Emacsはそのような文字を特別な方法(U+00A0
@sc{no-break space}および他のUnicode horizontal space
class由来の文字は@code{nobreak-space}フェイス、U+00AD @sc{soft hyphen}、U+2010
@sc{hyphen}、およびU+2011 @sc{non-breaking
hyphen}は@code{nobreak-hyphen}フェイス)で表示します。これを無効にするには、変数@code{nobreak-char-display}を@code{nil}に変更します。この変数に非@code{nil}かつ非@code{t}の値を与えると、Emacsはハイライトされたバックスラッシュの後に、スペースまたはハイフンを表示します。

  特定の文字コードの表示のカスタマイズは、ディスプレイテーブル(display table)によって行われます。@ref{Display Tables,,
Display Tables, elisp, The Emacs Lisp Reference Manual}を参照してください。

@cindex glyphless characters
@cindex characters with no font glyphs
@cindex @code{glyphless-char} face
  グラフィカルなディスプレイでは、Emacsが利用可能なフォントにグリフがない文字がいくつかあります。これらの@dfn{グリフがない文字(glyphless
characters)}は、通常16進文字を含むボックスで表示されます。テキスト端末では、端末エンコーディング(@ref{Terminal
Coding}を参照してください)で表示できない文字は、通常クエスチョン記号で表示されます。表示方法は、変数@code{glyphless-char-display-control}で制御できます。これらの文字の表示がより目立つように、@code{glyphless-char}フェイスをカスタマイズすることもできます。詳細は、@ref{Glyphless
Chars,, Glyphless Character Display, elisp, The Emacs Lisp Reference
Manual}を参照してください。

@findex glyphless-display-mode
  マイナーモード@code{glyphless-display-mode}を使えば、カレントバッファーにおけるグリフなし文字の表示を切り替えることができます。グリフのない文字は、中にその文字の名前の頭文字が入ったボックスとして表示されます。

@cindex curly quotes, and terminal capabilities
@cindex curved quotes, and terminal capabilities
@cindex @code{homoglyph} face

Emacsはカレントのディスプレイでcurved
quotes(@t{‘}と@t{’})が表示可能か判断を試みます。デフォルトでは、表示可能ならEmacsはメッセージやヘルプテキスト内の@acronym{ASCII}クォート(@w{(@samp{`}と@samp{'})})をcurved
quotesに変換します。ユーザーオプション@code{text-quoting-style}をカスタマイズすることにより、この変換を有効または無効にできます(@ref{Keys
in Documentation,,, elisp, The Emacs Lisp Reference Manual}を参照)。

  curved
quotes(@t{‘}、@t{’}、@t{“}、@t{”})を@acronym{ASCII}文字と同様な外観で見ることができる場合、それらは@code{homoglyph}フェイスで表示されます。表示できないことが既知のcurved
quotesは、それらの@acronym{ASCII}による代替である@samp{`}、@samp{'}、@samp{"}が@code{homoglyph}で表示されます。

@node Cursor Display
@section カーソルの表示
@cindex text cursor

@vindex visible-cursor
  テキスト端末では、カーソルの外見は端末により制御され、大部分はEmacsの制御が及びません。いくつかの端末は、普通の固定的なカーソルと、目立つ点滅カーソルの2種類を提供します。デフォルトではEmacsは目立つカーソルを使い、Emacsを開始または再開したときは、そのカーソルに切り替えます。変数@code{visible-cursor}が@code{nil}の場合、Emacsを開始または再開したとき、普通のカーソルを使います。

@vindex cursor-type
  グラフィカルなディスプレイでは、より多くのテキストカーソルのプロパティを変更できます。カラーを変えるには、フェイス@code{cursor}の、属性@code{:background}を変更します(このフェイスの他の属性には、何を指定しても効果はありません。カーソルの下にあるテキストはフレームのバックグラウンドカラーを使って描画されます)。外見を変更するには、バッファーローカルな変数@code{cursor-type}をカスタマイズします。有効な値は@code{box}
(デフォルト)、
@code{(box . @var{size})}
(いずれかの次元において@var{size}ピクセルより大なマスクされたイメージ下で中抜きのボックスになるボックスカーソル)、@code{hollow}
(中抜きのボックス)、@code{bar} (垂直のバー)、@code{(bar . @var{n})} (幅が@var{n}ピクセルの垂直バー),
@code{hbar} (水平バー)、@code{(hbar . @var{n})}
(高さが@var{n}ピクセルの水平バー)、または@code{nil} (カーソルなし)です。

@findex blink-cursor-mode
@cindex cursor, blinking
@cindex blinking cursor
@vindex blink-cursor-mode
@vindex blink-cursor-blinks
@vindex blink-cursor-alist
  デフォルトでは、カーソルは10回点滅する間にEmacsに何も入力がないと、点滅をストップします。そして何らかの入力イベントがあると、また0からカウントを再開します。変数@code{blink-cursor-blinks}をカスタマイズして、これを制御できます。変数の値には、何の入力もないとき点滅をストップする点滅回数を指定します。変数に0または負の値をセットすると、カーソルはずっと点滅したままになります。カーソルの点滅を無効にするには、変数@code{blink-cursor-mode}を@code{nil}に変更するか(@ref{Easy
Customization}を参照してください)、initファイルに以下の行を追加します:

@lisp
  (blink-cursor-mode 0)
@end lisp

@noindent
リスト変数@code{blink-cursor-alist}をカスタマイズして、カーソルが点滅をストップしたとき、どのように見えるかを変更できます。リストの各要素は、@code{(@var{on-type}
.
@var{off-type})}という形式を指定します。@var{on-type}には、点滅しているときのカーソルを指定します(@var{on-type}には、上で説明したカーソルタイプを指定します)。そして@var{off-type}には、点滅していないときのカーソルを指定します。

@vindex x-stretch-cursor
@cindex wide block cursor
  タブ文字のように、特別に幅が広い文字もあります。そのような文字上にカーソルがあるとき、通常はデフォルトの文字幅で描画されます。カーソルを文字幅に伸ばすには、変数@code{x-stretch-cursor}を非@code{nil}値に変更してください。

@cindex cursor in non-selected windows
@vindex cursor-in-non-selected-windows
  選択されていないウィンドウのカーソルは、通常点滅していない中抜きのボックスで表示されます(カーソルにバーを使っている場合、より細いバーで表示されます)。選択されていないウィンドウでカーソルを非表示にするには、変数@code{cursor-in-non-selected-windows}を@code{nil}に変更してください。

@findex hl-line-mode
@findex global-hl-line-mode
@cindex highlight current line
  カーソルをよりはっきりと表示させるために、HL
Lineモードを使用できます。このモードでは、ポイントを含む行がハイライトされます。現在のバッファーで有効または無効にするには、@kbd{M-x
hl-line-mode}を使います。このモードをグローバルに有効または無効にするには、@kbd{M-x
global-hl-line-mode}を使用してください。

@node Line Truncation
@section 行の切り詰め

@cindex truncation
@cindex line truncation
  Emacsは行を継続(@ref{Continuation
Lines}を参照してください)するかわりに、長い行を@dfn{切り詰めて}表示できます。これは、スクリーンやウィンドウの幅より長い行は、全体が表示されないことを意味します。グラフィカルなディスプレイでは、行が切り詰められている場合、フリンジに小さな直矢印が表示されます。テキスト端末では、右端および/または左端の列に@samp{$}が表示されます。

@kindex C-x x t
@vindex truncate-lines
@findex toggle-truncate-lines
  水平スクロールは、自動的に行の切り詰めを引き起こします(@ref{Horizontal
Scrolling}を参照してください)。特定のバッファーにたいして行の切り詰めを明示的に有効にするには、コマンド@kbd{C-x x t}
(@code{toggle-truncate-lines})を使います。これは変数@code{truncate-lines}をローカルに変更することで機能します。値が非@code{nil}のときは、長い行は切り詰められ、@code{nil}のときは複数のスクリーン行に分けられます。変数@code{truncate-lines}をセットすると、現在のバッファーにローカルに適用されます。値を変更するまでは、デフォルト値(@code{nil})が使われます。

  行切り詰めと単語折り返し(次セクションで説明)は排他なので、@code{toggle-truncate-lines}で行切り詰めをオンにすると単語折り返しが無効になります。

  ウィンドウを分割して狭くなりすぎたとき、Emacsは自動的に行の切り詰めを有効にします。これを制御する変数@code{truncate-partial-width-windows}については、@ref{Split
Window}を参照してください。

@node Visual Line Mode
@section Visual Lineモード

@cindex word wrap
  このモードでは、通常の行継続の代わりに、@dfn{単語での折り返し} (@ref{Continuation
Lines}を参照)が使われます。通常の行継続のように、長い論理行は2行以上のスクリーン行に分割されます。しかしEmacsはウィンドウの右端(RTL言語:Right-To-Leftlanguageでは左端)の近くの、単語の境界で折り返すよう試みます。これは単語の途中で折り返さないことにより、可読性を高めるためです。

@cindex mode, Visual Line
@cindex Visual Line mode
@findex visual-line-mode
@findex global-visual-line-mode
  単語での折り返しは、オプションのマイナーモードである、Visual Lineモードで有効になります。現在のバッファーでVisual
Lineモードの有効と無効を切り替えるには、@kbd{M-x visual-line-mode}とタイプします。メニューバーからVisual
Lineモードを有効にすることもできます(Optionsメニューから、サブメニュー@samp{Line Wrapping in this
Buffer}の、メニューアイテム@samp{Word Wrap (Visual Line Mode)}を選択します)。Visual
Lineモードが有効なときは、モードラインのモード表示に@samp{wrap}という文字が表示されます。コマンド@kbd{M-x
global-visual-line-mode}は、全バッファーのVisual Lineモードを切り替えます。

  単語折り返し(前セクションで説明)と行切り詰めは排他なので、@code{visual-line-mode}をオンにすると行切り詰めが無効になります。

@findex beginning-of-visual-line
@findex end-of-visual-line
@findex next-logical-line
@findex previous-logical-line
  Visual Lineモードでは、いくつかのコマンドは論理行ではなくスクリーン行に作用します。@kbd{C-a}
(@code{beginning-of-visual-line})はスクリーン行の先頭に移動し、@kbd{C-e}
(@code{end-of-visual-line})はスクリーン行の最後に移動、@kbd{C-k}
(@code{kill-visual-line})はテキストをスクリーン行の最後までkillします。

  論理行単位で移動するには、コマンド@kbd{M-x next-logical-line}または@kbd{M-x
previous-logical-line}を使います。これらのコマンドはVisual
Lineモードが有効であるかにかかわらず、次または前の論理行に移動します。これらのコマンドを頻繁に使う場合は、キーを割り当てると便利でしょう。@ref{Init
Rebinding}を参照してください。

  デフォルトでは、単語の折り返し表示はフリンジに表示されません。Visual
Lineモードは、長い論理行を含むファイルを編集するときに使われる場合があり、折り返し行すべてにフリンジの表示をすると見にくくなるためです。これを変更するには、変数@code{visual-line-fringe-indicators}をカスタマイズしてください。

@vindex word-wrap-whitespace-mode
  デフォルトではEmacsは@key{SPC}や@key{TAB}のような空白文字の後でのみ行ブレークを行い、@key{EN
QUAD}のような空白文字の後での行ブレークは行いません。Emacsはカレントモードでの単語折り返しを切り替える@code{word-wrap-whitespace-mode}と呼ばれるマイナーモードを提供しています。このモードはどの文字で行の折り返しを行うかをユーザーオプション@code{word-wrap-whitespace-characters}にもとづいてセットアップします。

@vindex word-wrap-by-category
@findex modify-category-entry
@findex char-category-set
@findex category-set-mnemonics
  CJKとLatinが混ざったテキストでは、空白文字の後でのみブレークすると正しくない結果を生成するかもしれません(CJKは単語区切りに空白文字を使用しないため)。CJK文字にたいしてより良いサポートを提供するために任意の@samp{|}カテゴリー(@ref{Categories,,,
elisp, the Emacs Lisp Reference
Manual}を参照)の文字の後でEmacsが行ブレークできるように、オプション@code{word-wrap-by-category}をカスタマイズできます。この変数がCustomizeを使用してセットされていると、Emacsは自動的に@file{kinsoku.el}をロードします。@file{kinsoku.el}のロード時には、Emacsは行ブレークする際に禁足規則にしたがいます。これは@samp{>}カテゴリーの文字(たとえばU+FF0C
@sc{fullwidth comma})が行頭、@samp{<}カテゴリーの文字(たとえばU+300A @sc{left double angle
bracket})が行末に出現しないことを意味します。コマンド@code{char-category-set}か@code{category-set-mnemonics}を使用してカテゴリーを閲覧したり、あるいはポイント上で@kbd{C-u
C-x
=}とタイプして結果の``category''セクションを調べることができます。コマンド@code{modify-category-entry}を使用して、文字にカテゴリーを追加できます。

@node Display Custom
@section ディスプレイのカスタマイズ

  このセクションでは、Emacsスクリーンの外観を制御するさまざまな変数を説明します。初心者はスキップして構いません。

@vindex display-line-numbers
@cindex number lines in a buffer
@cindex display line numbers
  Emacsにバッファー内の各行にたいして行番号を表示させたい場合は、バッファーローカルな変数@code{display-line-numbers}(デフォルトは@code{nil})をカスタマイズします。この変数は行番号表示のさまざまなモードをサポートするために、いくつかの異なる値をもつことができます。

@table @asis
@item @code{t}
バッファーテキストを表示する継続行ではないスクリーン各行の前に、、(絶対)行番号を表示します。その行が継続行の場合、またはスクリーン行全体がディスプレイ文字列(display
string)、またはオーバーレイ文字列(overlay string)の場合、その行に番号は振られません。

@item @code{relative}
バッファーテキストを表示する非継続行の前に、相対行番号(relative line
number)を表示します。行番号はポイントを表示する行にたいして相対的なので、カレント行から遠ざかるにしたがって、行番号は増加または減少します。

@item @code{visual}
この値により、Emacsにビジュアル的に行をカウントさせます。実際にディスプレイに表示されている行だけがカウントされ、ラップして複数行を占めるスクリーン行は、複数回番号付けされます。表示される番号は、上述の値@code{relative}のように相対的です。これはOutlineモード(@ref{Outline
Mode}を参照)のような、テキストをフォールド(fold: 折り畳む)するモードで、正確なスクリーン行の番号により移動するときに役立つでしょう。

@item その他
その他の非@code{nil}値は、@code{t}として扱われます。
@end table

@findex display-line-numbers-mode
@findex global-display-line-numbers-mode
@vindex display-line-numbers-type
コマンド@kbd{M-x
display-line-numbers-mode}は、行番号表示を切り替える便利な方法を提供します。このモードのグローバル版は、@code{global-display-line-numbers-mode}です。ユーザーオプション@code{display-line-numbers-type}は、上述した行番号表示のサブモードのどのモードをアクティブにするかを制御します。

@noindent
たとえグローバルに@code{display-line-numbers-mode}をオンにしていても、ミニバッファーやツールチップ内に行番号は表示されないことに注意してください。

@vindex display-line-numbers-current-absolute
Emacsが相対行番号を表示しているとき、カレント行(ポイントを表示している行)の前に表示される番号を制御できます。デフォルトでは、Emacsはカレント行にたいしては、他のすべての行が相対行番号であっても、絶対行番号を表示します。変数@code{display-line-numbers-current-absolute}を@code{nil}値にカスタマイズした場合、カレント行に表示される番号は0になります。これはカレント行の番号が重要ではなく、大きなバッファー内のテキストにたいして、より多くの水平方向の空きを残したいとき便利でしょう。

@vindex display-line-numbers-widen
ナロー(@ref{Narrowing}を参照)されたバッファーでは通常、ナローイングの先頭から番号が開始されます。しかし、変数@code{display-line-numbers-widen}を非@code{nil}値にカスタマイズした場合、ナローイングは無視されて、そのバッファーの最初の文字から行番号が開始されます。

@vindex display-line-numbers-offset
@code{display-line-numbers-offset}の値が非0なら、各絶対行番号に追加されて、行はあたかも@code{display-line-numbers-widen}が非@code{nil}であるかのようにバッファー先頭から計数されます。0にセットされた場合、あるいは行番号が絶対でない場合には影響はありません。

@vindex display-line-numbers-width-start
@vindex display-line-numbers-grow-only
@vindex display-line-numbers-width
Selective Display(選択的表示)モード(@ref{Selective
Display}を参照)、およびその他の(OutlineモードやOrgモードのような)ディスプレイから多くの行を隠すモードでは、行番号のために予約済みのスペースにたいする法則性のない計算ミスを避けるために、変数@code{display-line-numbers-width-start}および@code{display-line-numbers-grow-only}のカスタマイズ、または@code{display-line-numbers-width}に十分大きな値をセットしたいと思うかもしれません。

@cindex @code{line-number} face
行番号は特別なフェイス@code{line-number}で表示されます。カレント行番号は異なるフェイス@code{line-number-current-line}で表示されるので、ポイントを表示する行を見つける助けとなるようにカレント行番号に異なる外観を与えることができます。特定の数値の倍数であるような行番号をハイライトするために、追加フェイスの@code{line-number-major-tick}と@code{line-number-minor-tick}を使用できます。それらの数値に@code{display-line-numbers-major-tick}と@code{display-line-numbers-minor-tick}をカスタマイズしてください。

@vindex visible-bell
  変数@code{visible-bell}が非@code{nil}の場合、Emacsは通常ベルサウンドを鳴らす場面で、スクリーン全体を点滅するよう試みます。端末がスクリーンを点滅させる方法を持たないとき、この変数は効果がありません。

@vindex echo-keystrokes
  変数@code{echo-keystrokes}は、複数文字キーのエコー表示を制御します。値にはエコーが開始されるまでの秒数を指定します。0の場合、エコーされません。何かエコーされるべきものがあるときは、この変数の値が効果をもちます。@ref{Echo
Area}を参照してください。

@vindex echo-keystrokes-help
  変数@code{echo-keystrokes-help}が非@code{nil}
(デフォルト)の場合には、すでにタイプしたプレフィクスにたいするコマンドリストを表示する@code{describe-prefix-bindings}
(@ref{Misc
Help}を参照)を呼び出すキーに関する短いヘルプテキストを、@code{echo-keystrokes}に応じた複数文字のキーシーケンスとともにエコー表示します。関連するヘルプ機能については、@ref{which-key}を参照してください。

@cindex mouse pointer
@cindex hourglass pointer display
@vindex display-hourglass
@vindex hourglass-delay
  グラフィカルなディスプレイでは、Emacsはビジーのときにマウスポインターを砂時計で表示します。この機能を無効にするには、変数@code{display-hourglass}に@code{nil}をセットします。変数@code{hourglass-delay}は、砂時計が表示されるまでのビジーな時間を、秒数で指定します。デフォルトは1です。

@vindex make-pointer-invisible
  マウスポインターがEmacsのフレーム内にある場合、文字をタイプしてテキストを挿入するまでの間、テキストを隠さないよう、Emacsはマウスポインターを非表示にします(正確に言うとマウスポインターの非表示は、自己挿入的(self-inserting)な文字をタイプしたときです。@ref{Inserting
Text}を参照してください)。マウスポインターを動かすと、再び表示されます。この機能を無効にするには、変数@code{make-pointer-invisible}に@code{nil}をセットしてください。

@vindex underline-minimum-offset
@vindex x-underline-at-descent-line
  グラフィカルなディスプレイでは、変数@code{underline-minimum-offset}は、アンダーラインされたテキストの、アンダーラインから文字の基底線までの最小距離を、ピクセルで決定します。デフォルトでは値は1です。この変数を増加させると、特定のフォントにおいて、アンダーラインされたテキストの可読性が向上します(しかしEmacsは、カレント行にはアンダーラインを描画しません)。変数@code{x-underline-at-descent-line}は、テキストにアンダーラインを引く方法を決定します。デフォルトは@code{nil}で、これはフォントの基底線と同じレベルに描画されることを意味します。これを@code{t}に変更すると、Emacsはフォントが同じ大きさになるよう、アンダーラインを少し下に描画します。(アンダーラインされるテキストにたいして非デフォルトの行間が指定された場合、Emacsは追加される行間の下にアンダーラインを描画する。@ref{Line
Height,,, elisp, The Emacs Lisp Reference Manual}を参照されたい。)

@vindex overline-margin
  変数@code{overline-margin}は、テキストの上のオーバーラインの垂直位置を、オーバーライン自身の高さも含めて、ピクセルで指定します。デフォルトは2です。

@findex tty-suppress-bold-inverse-default-colors
  テキスト端末には、bold(太字)かつ反転されたテキストが読みにくいものがあります。関数@code{tty-suppress-bold-inverse-default-colors}に、引数非@code{nil}を与えて呼び出すと、このような場合のbold-faceの効果を抑制します。

@vindex display-raw-bytes-as-hex
  デフォルトではrawバイトは、たとえば10進で128という値をもつバイトは@code{\200}といったように8進形式で表示されます。これを@code{\x80}のように16進形式で表示するよう変更するには、変数@code{display-raw-bytes-as-hex}に@code{t}をセットしてください。Emacsセッションを含む端末からテキストをコピーしたり、端末の@code{escape-glyph}Careフェイスの外観がデフォルトフェイスに似ている際には、rawバイトの解釈に注意が必要かもしれません。たとえばEmacsが@samp{\}、@samp{2}、@samp{0}、@samp{0}という4つの文字を表示するのは、値が10進で128であるようなバイトを表示する際と同じ文字です。更に悪いことに16進の表示ではrawバイトの128の後に文字@samp{7}がある場合には、Emacs
LispはこれをU+0807、すなわちSAMARITAN LETTER
ITという単一の文字として読み取ってしまいます。8進エスケープでは最大で3桁なので、これに相当する8進の@code{\2007}という表示でも混乱は生じません。
