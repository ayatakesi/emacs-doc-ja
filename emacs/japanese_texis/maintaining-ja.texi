@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================

@c This is part of the Emacs manual., Abbrevs, This is part of the Emacs manual., Top
@c Copyright (C) 1985--1987, 1993--1995, 1997, 1999--2024 Free Software
@c Foundation, Inc.
@c See file emacs-ja.texi for copying conditions.
@node Maintaining
@chapter 大きなプログラムの保守
@cindex maintaining large programs
@cindex large programming projects, maintaining

  このチャプターでは、中規模から大規模のプログラムやパッケージを保守するためのEmacsの機能を説明します。これらの機能には、以下が含まれます:

@itemize @minus
@item
ソースファイルへの変更履歴を記録するバージョンコントロールシステム(@acronym{VCS}: Version Control
Systems)にたいする、統一されたインターフェースのサポート。

@item
プログラミングプロジェクトを扱うためのコマンド。

@item
プログラムの変更にたいして日時順のログを提供する、@file{ChangeLog}の保守に特化したモード。

@item
シンボル定義(``識別子(identifiers)''とも言います)を表示する一連のコマンドである、@acronym{Xref}。

@item
Emacs自身のIDEである、@acronym{EDE}。

@ifnottex
@item
開発の別ブランチで行なわれたプログラム変更をマージするためのモード。
@end ifnottex

@item
バグリファレンスのハイライト、およびissue tracker(問題追跡システム)内で参照されるバグレポートのvisit。
@end itemize

Lispの大きなプログラムをメンテナンスしている場合は、ここで説明している機能に加え、@acronym{ERT}(Emacs Lisp
Regression Testing)ライブラリーも便利だと思うかもしれません(@ref{Top,,ERT,ert, Emacs Lisp
Regression Testing}を参照してください)。

@menu
* Version Control::          バージョンコントロールシステムの使用。
* Projects::                 プロジェクト内のソースファイルを扱うコマンド。
* Change Log::               プログラムの変更履歴をメンテナンスする。
* Xref::                     プログラム内の関数、メソッド、構造体、マクロ、...にたいする定義の検索と参照。
* EDE::                      Emacsのための統合開発環境。
@ifnottex
* Emerge:: 2つのバージョンのプログラムをマージする便利な方法。
@end ifnottex
* Bug Reference::            バグレポートへの参照のハイライトとissue 
                               trackerでの閲覧。
@end menu

@node Version Control
@section バージョンコントロール
@cindex version control

  @dfn{バージョンコントロールシステム(version control
system)}は、ソースファイルの複数のバージョンを記録したり、それらのバージョンの作成日時などや、誰が作成したか、何が変更されたかの説明などを記録できるプログラムのことです。

@cindex VC
  Emacsのバージョンコントロールのためのインターフェースは、@dfn{VC}と呼ばれます。VCコマンドは、複数の異なるバージョンコントロールシステムで機能します。現在のところ、Bazaar、CVS、Git、Mercurial、Monotone、RCS、SRC、SCCS/CSSC、Subversionがサポートされます。これらの中で、GNUプロジェクトのディストリビューションはCVS、RCS、Bazaarです。

  バージョン管理システムで生成されたファイルをvisitすると、自動的にVCが有効になります。VCを無効にするには、カスタマイズ可能な変数@code{vc-handled-backends}を@code{nil}をセットします
@iftex
(@ref{Customizing VC,,,emacs-xtra, Specialized Emacs Features}を参照してください)。
@end iftex
@ifnottex
(@ref{Customizing VC}を参照してください)。
@end ifnottex

@findex vc-refresh-state
@findex vc-state-refresh
  カレントバッファーでvisitされているファイルにたいするVC状態の情報を更新するには、コマンド@code{vc-refresh-state}を使用します。Emacsの外(たとえばシェルプロンプト)でバージョンコントロールコマンドを実行したときや、そのバッファーのファイルを別のバージョンコントロールシステム下に置いたとき、バージョンコントロールからそのファイルを完全に削除したときに、このコマンドは有用です。

@cindex VC commands, in Dired buffers
@cindex filesets, VC, in Dired buffers
  VCSの制御下にあるファイルを含んだディレクトリーを表示しているDiredバッファー(@ref{Dired}を参照)では、VCも自動的に有効になります。そのようなDiredでは、このセクションで説明するすべてのVCコマンドを呼び出すことができます。Diredでマークされたすべてのファイル(@ref{Marks
vs
Flags}を参照)はカレントのファイルセットに属しているものとみなされて、そのファイルセットのファイルにたいしてVCコマンドが処理を行うのです。これによりファイルのVC状態(VC
state)に関わらず、含めたい任意のファイルからVCファイルセットを構築することができます(DiredバッファーからVCコマンドを呼び出した際にマークされたファイルがなければ、バッファーのカレント行に表示されているファイルがそのファイルセットで唯一のファイルとみなされる)。

@menu
* Introduction to VC::       バージョンコントロールが機能する一般的な方法。
* VC Mode Line::             モードラインがバージョンコントロールの状態を表示する方法。
* Basic VC Editing::         バージョンコントロール下のファイルの編集方法。
* Log Buffer::               logエントリーバッファーで利用可能な機能。
* Registering::              バージョンコントロール下にファイルを置く。
* Old Revisions::            古いバージョンの調査と比較。
* VC Change Log::            VC Change Logの閲覧。
* VC Undo::                  コミット前後の変更の取り消し。
* VC Ignore::                バージョンコントロール下のファイルの無視。
* VC Directory Mode::        バージョンコントロールで管理されたファイルの一覧。
* Branches::                 開発における複数行。
@ifnottex
* Miscellaneous VC:: その他のVCのさまざまなコマンドと機能。
* Customizing VC:: VCの動作を変更する変数。
@end ifnottex
@end menu

@node Introduction to VC
@subsection バージョンコントロールの紹介

  VCは、Emacsからのバージョンコントロールシステムの使用、およびバージョンコントロールの操作と編集をスムーズに統合します。VCは、多くのバージョンコントロールシステムでの一般的な操作にたいする、統一されたインターフェースを提供します。

  レポジトリ設定の変更など、非一般的または複雑なバージョンコントロールの操作は、VCではサポートされません。そのようなタスクは、VCの外(たとえばコマンドライン)で処理する必要があります。

  このセクションは、バージョンコントロールの一般的な概観を提供し、VCがサポートするバージョンコントロールを説明します。すでに使いたいバージョンコントロールシステムをよく知っている場合、このセクションはスキップできます。

@menu
* Why Version Control?::     問題が示すところを理解するには。
* Version Control Systems::  バックエンドシステムとしてサポートされるバージョンコントロール。
* VCS Concepts::             バージョンコントロールに関連する単語と概念。
* VCS Merging::              ファイルの衝突を処理する方法。
* VCS Changesets::           変更がグループ化される方法。
* VCS Repositories::         バージョンコントロールのレポジトリが格納される場所。
* Types of Log File::        VCS logとChangeLogの違い。
@end menu

@node Why Version Control?
@subsubsection 問題の背景を理解する

  バージョンコントロールシステムは、3つの重要な能力を提供します。

@itemize @bullet
@item
@dfn{Reversibility(可逆性)}: ある変更が間違い、または間違えた考えにもとづくものだと気づいたときに、前の状態に戻す能力です。

@item
@dfn{Concurrency(並列性)}: 多くの人が同じファイルコレクションを変更するとき、変更の衝突を検知して解決する能力です。

@item
@dfn{History(履歴)}:
それを変更した背後の意図を説明するコメントなど、履歴データをデータに付す能力です。1人で作業するプログラマーでさえ、変更履歴は記憶を助けるのに重要です。複数人のプロジェクトでは、開発者間のコミュニケーション形式として、とても重要です。
@end itemize

@node Version Control Systems
@subsubsection サポートされるバージョンコントロールシステム

@cindex back end (version control)
  VCは現在のところ、多くの異なるバージョンコントロールで機能し、それらを@dfn{バックエンド(back ends)}として参照します:

@itemize @bullet

@cindex git
@item
Gitは、最初にLinus
TorvaldsによりLinux(彼のkernel)の開発をサポートするために考案された分散型バージョンコントロールシステムです。VCは多くのGit操作をサポートしますが、その他のレポジトリの同期などはコマンドラインを使わなければなりません。

@cindex CVS
@item
CVSは、フリーなバージョンコントロールシステムであり、2008年y頃まではフリーソフトウェアプロジェクトの大半で使われていました。それ以降は、新しいシステムに徐々に置き換えらました。CVSではローカルまたはネットワーク越しの、複数ユーザーによる並列開発が可能です。新しいシステムとは異なり、アトミックなコミットとファイルの移動・リネームにたいするサポートがありません。VCはCVS下での基本的な編集操作をサポートします。

@cindex SVN
@cindex Subversion
@item
Subversion(svn)は、CVSと同じようにデザインされた、フリーなバージョンコントロールシステムですが、CVSのもつ問題はありません(たとえば、これはファイルセットのアトミックなコミット、ディレクトリーのバージョニング、シンボリックリンク、メタデータ、リネーム、コピー、削除をサポートします)。

@cindex SCCS
@item
SCCSは、これまでに構築された一番最初のバージョンコントロールシステムで、ずっと以前に、もっと進んだものに取って代わられました。SCCSにない特定の機能のためのVCコンポーネントは、それら自身により実装されています。複数ブランチなど、その他のVC機能は単に利用不可です。SCCSはフリーではないので、これを避けることを推奨します。

@cindex CSSC
@item
CSSCはSCCSのフリーな置き換えです。何らかの理由により、もっと新しい、より良いデザインのバージョンコントロールシステムを使うことができないときだけ、CSSCを使うべきです。

@cindex RCS
@item
RCSは、VCが最初に構築された頃の、フリーなバージョンコントロールシステムです。これは比較的に初期のものです。これはネットワークを超えて使うことはできず、ファイルに個別のレベルで機能します。RCSでできるほとんどのことは、VCを通じて行うことができます。

@cindex hg
@cindex Mercurial
@item
Mercurial(hg)は、Gitに酷似した分散化されたバージョンコントロールシステムです。VCは、レポジトリの同期操作を除いて、ほとんどのMercurialコマンドをサポートします。

@cindex bzr
@cindex Bazaar
@item
Bazaar(bzr)は、レポジトリベースと分散化されたバージョニングの両方をサポートする、分散化されたバージョンコントロールシステムです。VCはBazaar下でのほとんどの基本的な編集操作をサポートします。

@cindex SRC
@cindex src
@item
SRC
(src)はRCSの再実装で、1人による単一ファイルのプロジェクトために特化してデザインされたバージョンコントロールシステムです。これは1つのディレクトリーの中に、独立したバージョンコントロール履歴をもつ複数ファイルを許容します。したがって、これは小さなドキュメントやスクリプト、ドットファイルを保守するのに適しています。これはRCSのリビジョンストレージを使用するので、非lock操作(lockless
operation)や、シーケンシャルな整数リビジョン番号をもつ、現代的なユーザーインターフェースを提供します。
@end itemize

@node VCS Concepts
@subsubsection バージョンコントロールの概念

@cindex repository
@cindex registered file
   ファイルがバージョンコントロールの配下にある時、それがバージョンコントロールシステムに@dfn{登録されている(registered)}と言います。バージョンコントロールシステムは、@dfn{レポジトリ(repository)}をもちます。これはファイルの現在の状態、および古いバージョンから現在のバージョンを再構成するのに充分な変更履歴の、両方を保存します。レポジトリには、各ファイルに行われた変更の説明である@dfn{ログエントリー(log
entries)}など、その他の情報も含まれます。

@cindex work file
@cindex checking out files
  実際に編集する、バージョンコントロールされたファイルのコピーのことを、@dfn{作業ファイル(work
file)}と呼びます。作業ファイルは、通常のファイルを同じように変更できます。一連の変更を終えた後、その変更を@dfn{コミット(commit)}または@dfn{チェックイン(check
in)}します。これにより、その変更はログエントリーの記述とともに、レポジトリに記録されます。

@cindex working tree
  作業ファイルのディレクトリツリーを、@dfn{作業ツリー(working tree)}と呼びます。

@cindex revision
@cindex revision ID
  commitするたびに、レポジトリに新しい@dfn{リビジョン(revision)}が作成されます。バージョンコントロールシステムは、過去のすべてのリビジョンと、各リビジョンで行われた変更を記録します。各リビジョンには、@dfn{リビジョンID(revision
ID)}により名前がつけられます。リビジョンIDのフォーマットは、バージョンコントロールシステムに依存します。もっとも簡単なケースでは、リビジョンIDは単なる整数です。

  これらの基本的な概念を超えるにつれ、各バージョンコントロールシステムの違いの、3つの様相を理解する必要がでてくるでしょう。以降の3つのセクションで説明するように、各バージョンコントロールシステムには、ロックベース(lock-based)とマージベース(merge-based)、ファイルベース(file-based)と変更セットベース(changeset-based)、集中型(centralized)と分散型(decentralized)の違いがあります。VCはこれらすべてのモードの操作を処理しますが、それらの違いを隠蔽することはできません。

@node VCS Merging
@subsubsection バージョンコントロールにおけるマージベースとロックベース

  バージョンコントロールシステムは通常、同じファイルを変更したい複数ユーザーを調整するために、何らかのメカニズムをもちます。これを行うには2つの方法
--- マージとロック --- があります。

@cindex merging-based version
  マージを使うバージョンコントロールシステムでは、各ユーザーはいつでも作業ファイルを変更します。バージョンコントロールシステムは、コミットされていない変更を含むユーザーの作業ファイルを、他のユーザーによりコミットされた最新の変更とマージします。

@cindex locking-based version
  古いバージョンコントロールシステムは、かわりに@dfn{ロック(locking)}を使います。この場合、作業ファイルは通常は読み取り専用です。ファイルを編集するには、それを@dfn{ロック}することにより書き込み可能にできるか、バージョンコントロールシステムに尋ねます。ある時点で、そのファイルをロックできるユーザーは1人だけです。この手順は、通常のファイルの同時編集をEmacsが検知する方法と類似しているようですが、異なります(@ref{Interlocking}を参照してください)。変更をコミットすると、ファイルはアンロック(unlocks)され、作業ファイルは再び読み取り専用になります。他のユーザーは、変更するためにそのファイルをロックすることができます。

  ロックおよびマージの両方のシステムは、複数ユーザーが同じときに同じファイルの変更を試みたときに問題が発生し得ます。ロックを使うシステムには、@dfn{ロックの衝突(lock
conflicts)}があります。あるユーザーはファイルのチェックアウトを試みますが、それがすでにロックされている場合はロックできません。マージを使うシステムには、@dfn{マージの衝突(merge
conflicts)}があります。これはファイルに行った変更をコミットするとき、それが後からチェックアウトした他の誰かによる変更のコミットと衝突するときに発生します。どちらの衝突も、人間の判断と意思疎通により解決する必要があります。経験から、開発者に取っての利便性と、実際に発生する衝突の重大性と数を最小にするという両方の点で、マージはロックに優ります。

  SCCSは常にロックを使います。RCSはデフォルトではロックベースですが、マージスタイルで処理するように指示できます。CVSとSubversionはデフォルトではマージベースですが、ロックモードで処理するように指示できます。Git、Mercurialのような分散型のバージョンコントロールシステムは、マージベースだけです。

  VCはロックとマージの両方のバージョンコントロールをサポートします。``commit(コミット)''と``update(更新)''という用語は、新しいバージョンコントロールシステムで使用されます。古いロックベースのシステムでは、``check
in(チェックイン)''と``check out(チェックアウト)''という用語が使用されます。VCはこれらの違いをできる限り隠蔽します。

@node VCS Changesets
@subsubsection バージョンコントロールにおける変更セットベースとファイルベース

@cindex file-based version control
  SCCS、RCS、CVS、およびその他の初期のバージョンコントロールシステム(SRCも含む)では、バージョンコントロールの操作は@dfn{ファイルベース(file-based)}です。各ファイルは、他のすべてのファイルとは別に、ファイル自身のコメントとリビジョン履歴をもちます。Subversionで始まる新しいシステムは、@dfn{変更セットベース(changeset-based)}です。コミットは複数ファイルにたいする変更を含むときがあり、一連の変更全体を1つの単位として扱います。変更にたいするコメントは1つのファイルではなく、変更セットに属します。

@cindex changeset-based version control
  変更セットベースのバージョンコントロールは、ファイルベースのバージョンコントロールより、柔軟で強力です。通常、複数ファイルの変更を元に戻す必要がある時、それを簡単に識別してすべてを削除できます。

@node VCS Repositories
@subsubsection レポジトリにおける分散型と集中型

@cindex centralized version control
@cindex decentralized version control
@cindex distributed version control
  初期のバージョンコントロールシステムは、@dfn{集中型(centralized)}モデルでデザインされていて、各プロジェクトはすべての開発者が使用するただ1つのレポジトリをもちます。SCCS、RCS、CVS、Subversion、SRCはこの種のモデルを共有します。このモデルの欠点の1つは、レポジトリが信頼性と効率の要衝となることです。

  GNU
Archは、@dfn{分配型(distributed)}または@dfn{分散型(decentralized)}のバージョンコントロールの先駆で、後にGit、Mercurial、Bazaarで実装されました。プロジェクトは複数の異なるレポジトリをもつことができ、これらのシステムはレポジトリ間で変更履歴を調停する、ある種のスーパーマージをサポートします。開発者ごとに1つのレポジトリがあり、レポジトリのマージがコミット操作を代行します。

  VCは個人の作業ファイルと、レポジトリとの間で行われる通信を管理する手助けをします。VCは、レポジトリが唯一のマスターなのか、それともネットワークのピアーのレポジトリの1つなのかは関知しません。

@node Types of Log File
@subsubsection ログファイルのタイプ
@cindex types of log file
@cindex log File, types of
@cindex version control log

  バージョンコントロールシステムを使うプロジェクトは、変更にたいする2つのタイプのログをもつことができます。1つはバージョンコントロールシステムで保守されるログです。変更をコミットするたびに、変更にたいする@dfn{ログエントリー(log
entry)}を入力します(@ref{Log Buffer}を参照してください)。これは@dfn{バージョンコントロールログ(version
control log)}と呼ばれます。

  もう1つの種類のログは、@file{ChangeLog}です(@ref{Change
Log}を参照してください)。これはプログラムの大きな部分(通常は1つのディレクトリーと、そのサブディレクトリー)にたいする変更の記録を、年代順に記録します。小さなプログラムは、1つの@file{ChangeLog}を使用するでしょう。大きなプログラムは、主要なディレクトリーごとに@file{ChangeLog}をもつかもしれません。@ref{Change
Log}を参照してください。プログラマーは、バージョンコントロールシステムのずっと前からChangeLogを使ってきました。

  変更セットベースのバージョンシステムは、通常システム全体にたいして変更セットベースの修正ログを保守します。これはChangeLogを冗長なものにします。ChangeLogを残す利点の1つは、他のディレクトリーとは別に、1つのディレクトリーの履歴トランザクションが見れるのは便利なときがあるからです。他の利点として、多くのバージョンコントロールシステムはコミットログを特定できないからです。

  バージョンコントロールで管理されるプロジェクトは、バージョンコントロールログだけを使用するか、両方の種類のログを使用します。あるファイルにたいしては1つのログを使い、他のファイルにたいしては別の方法を使うこともできます。プロジェクトごとに、したがうべきポリシーがあります。

  両方を使うというポリシーの場合は通常、変更にたいして1度だけエントリーを書いて、それを両方のログに書き込みたいと思うでしょう。@file{ChangeLog}にエントリーを記述して、変更をコミットするときに@kbd{C-c
C-a}でログバッファーにコピーできます。または変更をコミットするときログバッファーにエントリーを記述して、(@kbd{C-c
C-w}の助けを借りて)後で@kbd{C-x v a}コマンドでそれを@file{ChangeLog}にコピーできます
@iftex
(@ref{Change Logs and VC,,,emacs-xtra, Specialized Emacs
Features}を参照してください)。
@end iftex
@ifnottex
(@ref{Change Logs and VC}を参照してください)。
@end ifnottex

@node VC Mode Line
@subsection バージョンコントロールとモードライン
@cindex VC mode line indicator

  バージョンコントロール配下のファイルをvisitしたとき、Emacsはモードラインにそれを示します。たとえば@samp{Bzr-1223}と表示された場合、そのファイルにBazaarが使用され、カレントのリビジョンIDが1223であることを示します。

@cindex version control status
  バックエンド名とリビジョンIDの間の文字は、作業ファイルの@dfn{バージョンコントロール状態(version control
status)}を示します。マージベースのバージョンコントロールシステムでは、文字@samp{-}は作業ファイルが変更されていないことを示し、文字@samp{:}は作業ファイルが変更されていることを示します。文字@samp{!}は最新のマージ処理の結果により、そのファイルに衝突が含まれていることを示すか(@ref{Merging}を参照してください)、そのファイルがバージョンコントロールから削除されたことを示します。最後に、文字@samp{?}は、そのファイルがバージョンコントロールの配下にあるが、作業ツリーにないことを示します。

  ロックベースのシステムでは、@samp{-}はファイルがロックされていないことを示し、@samp{:}はファイルが他のユーザー(たとえば@samp{jim})にロックされていることを示し、@samp{RCS:jim:1.3}のように表示されます。@samp{@@}は、そのファイルがローカルに追加されたが、まだマスターレポジトリにコミットされていないことを示します。

  グラフィカルなディスプレイでは、モードラインのインジケーターの上にマウスを移動すると、ツールチップが表示され、それにはバージョンコントロール状態の、より多くの説明が表示されます。インジケーターを@kbd{mouse-1}でクリックすると、メニューバーの@samp{Tools
/ Version Control}と同じVCコマンドがのメニューがポップアップします。

@vindex auto-revert-check-vc-info
  Auto
Revertモード(@ref{Reverting}を参照してください)がバージョンコントロール配下のバッファーをリバートするとき、これはモードラインのバージョンコントロール情報を更新します。しかし、Auto
Revertモードは、作業ファイルの変更をともなわない、カレントのEmacsセッションの外でのバージョンコントロール状態の変化の情報は、正しく更新しないかもしれません。@code{auto-revert-check-vc-info}を@code{t}にセットすると、Auto
Revertモードは、作業ファイル自身を変更していなくても、@code{auto-revert-interval}秒ごとにバージョンコントロール状態の情報を更新します。CPU使用率はバージョンコントロールシステムに依存しますが、通常はそれほど高価な処理ではありません。

@node Basic VC Editing
@subsection バージョンコントロール下での基本的な編集

@cindex filesets, VC
@cindex VC filesets
   ほとんどのVCコマンドは、@dfn{VCファイルセット(VC
filesets)}にたいして処理を行います。VCファイルセットは、VC操作が機能する1つ以上のファイルのコレクションです。バージョンコントロールされたファイルをvisitしているバッファーでVCコマンドをタイプすると、VCファイルセットは単にそのファイル1つだけになります。VC
Directoryバッファーで、いくつかのファイルをマークしているときにVCコマンドをタイプしたときは、VCファイルセットはマークされたファイルです(@ref{VC
Directory Mode}を参照)。DiredバッファーからVCコマンドを呼び出した際にも、マークされたファイル(@ref{Marks vs
Flags}を参照)からVCファイルセットが構成されます(マークされたファイルがなければカレント行に表示されているファイルがデフォルト)。

  Git、Mercurial、Bazaarのような現代的な変更セットベースのバージョンコントロールシステム(@ref{VCS
Changesets}を参照)では、VCコマンドは複数ファイルからなるVCファイルセットを1つのグループとして扱います。たとえば複数ファイルからなるVCファイルセットをコミットすると、それらすべてのファイルにたいする変更を含む、1つのリビジョンが生成されます。CVSのような古いファイルベースのバージョンコントロールシステムでは、複数ファイルからなるVCファイルセットの各ファイルは個別に処理されます。したがってファイルセットをコミットすると、ファイルセット内の変更されたファイルそれぞれにたいして1つのリビジョンが生成されます。

@table @kbd
@item C-x v v
カレントVCファイルセットにたいして、次の適切なバージョンコントロール操作を処理します。
@end table

@findex vc-next-action
@kindex C-x v v
  重要なVCコマンド@kbd{C-x v v}
(@code{vc-next-action})は多目的なもので、カレントのVCファイルセットにたいして、もっとも適切な操作を処理します。このコマンドは、それをバージョンコントロールシステムに登録するか、コミットするか、ロックを外すか、変更をマージします。それぞれの状況にたいする正確な動作の詳細は、以下のサブセクションで説明します。@kbd{C-x
v v}は、ファイルをvisitしているバッファー、Diredバッファー、またはVC
Directoryバッファーのいずれかで使うことができます。後者の2つのバッファーにおいては、マークされたファイルから構成されるファイルセットにたいして処理を行います。patchであるようなDiffモード(@ref{Diff
Mode}を参照)のバッファーで@kbd{C-x v
v}を使用することもできます。この場合には、バッファーにdiffが表示されているファイルにたいして処理を行います。

  VCファイルセットは、ファイルを閲覧したりvisitするためのグループ機能として使用される、名前つきファイルセット(named
filesets)とは別の物だということに注意してください(@ref{Filesets}を参照してください)。名前つきファイルセットとは異なり、VCファイルセットは名前をもたず、セッションをまたいで持続しません。

@menu
* VC With A Merging VCS::    ロックしない: 
                               Git、Hg、SVN、CVSのデフォルトモード。
* VC With A Locking VCS::    RCSのデフォルトモード、SCCS、オプションでCVS。
* Advanced C-x v v::         プレフィクス引数で利用可能な上級機能。
@end menu

@node VC With A Merging VCS
@subsubsection マージでの基本的なバージョンコントロール

  マージベースの現代的なバージョンコントロールシステム(GitやHgのようなVCS; @ref{VCS
Merging}を参照)では、バージョンコントロールされたファイルをvisitしているバッファー、あるいはVC
DirectoryバッファーやDiredバッファーから呼び出されると@kbd{C-x v v}は以下のことを行います:

@itemize @bullet
@item
VCファイルセットに1つ以上のファイルがあり、そのファイルがバージョンコントロール状態と矛盾する場合、エラーをシグナルします(ただしファイルセットには新しく追加されたファイルと、変更されたファイルを含むことができることに注意;
@ref{Registering}を参照)。ファイルセット中のファイルが欠落している(依然としてバージョンコントロールに追跡されているにも関わらずファイルシステムから削除された)場合や、バージョンコントロールから無視されている場合にもエラーをシグナルします。

@item
VCファイルセットのすべてのファイルが登録済みで、最終リビジョンに照らして未変更の場合には何もしません。

@item
VCファイルセットにバージョンコントロールシステムに登録されたファイルがない場合には、VCファイルセット内に新たに追加されたファイルを登録します(バージョンコントロールの配下に置く)。@ref{Registering}を参照してください。Emacsが登録すべきシステムを見つけられない場合にはレポジトリタイプの入力を求めて新しいレポジトリを作成、VCファイルセットをそれに登録します。明示的にシステムを指定することもできます。@ref{Advanced
C-x v v}を参照してください。ファイルの登録はコミットではないことに注意してください。コミットするためにはもう一度@w{@kbd{C-x v
v}}を呼び出さなければなりません(以下参照)。

@item
VCファイルセットのすべてのファイルがそれぞれ新たに追加されたり変更されている場合には、変更されたファイルをコミットします。これを行うには、Emacsが@file{*vc-log*}バッファーをポップアップするので、その変更にたいするログエントリーをタイプしてから、@kbd{C-c
C-c}でコミットします。@ref{Log Buffer}を参照してください。

現代的な分散型バージョンコントロールシステム(Git、Mercurial等)での変更のコミットはローカルに行われます、アップストリームのレポジトリ(通常はリモートホスト上にある)に自動的に伝播されることはありません。このような場合には、あなたが最後に更新してからレポジトリが変更されていると、コミットが失敗するかもしれません。その場合にはまずアップストリームから更新を取得して、もう一度試行しなければなりません。これを行うには@kbd{C-x
v +} (@ref{Pulling / Pushing})、あるいは@kbd{C-x v m} (@ref{Merging})を使用してください。

集中型バージョンコントロールシステムではアップストリームの変更によってコミットが失敗すると、もう一度@kbd{C-x v
v}とタイプすることによってアップストリームのレポジトリの変更をマージします。

@item
最後に集中型のバージョンコントロールシステムでは、アップストリームのレポジトリに照らしてVCファイルセットのファイルが古ければ、そのリポジトリからのファイルセットの更新を提案します。
@end itemize

  これらのルールは、変更はレポジトリから自動的にマージされない点をのぞき、RCSを非ロックモードで使用している場合も適用されます。あなたがファイルの編集を始めた後に、他のユーザーが同じファイルをコミットした場合、何の情報も与えられません。あなたのリビジョンをコミットしたとき、他のユーザーの変更は失われます(しかし、それはレポジトリには残るので、決定的に失われるわけではありません)。したがって、変更をコミットする前に、カレントリビジョンが変更されていないことを調べなければなりません。それに加えて、このモードでもRCSでロックすることが可能です。変更されていないファイルでの@kbd{C-x
v v}は、RCSの通常のロックモードのようにそのファイルをロックします。(@ref{VC With A Locking VCS}を参照してください)。

  Diffモードのバッファーから@kbd{C-x v
v}を呼び出すと、このコマンドはそのバッファーに1つ以上のファイルにたいするpatchセットがあるとみなします。そして変更をそれぞれのファイルに適用して、適切なコミットログメッセージをタイプできるように@file{*vc-log*}バッファーをポップアップした後にそれらの変更をコミットします。

@node VC With A Locking VCS
@subsubsection ロックでの基本的なバージョンコントロール

  ロックベースのバージョンコントロールシステム(SCCSやRCSのデフォルトモードなど)では、@kbd{C-x v v}は以下のことを行います:

@itemize @bullet
@item
VCファイルセットに1つ以上のファイルがあり、そのファイルがバージョンコントロール状態と矛盾する場合、エラーをシグナルします。ファイルセットのファイルが欠落している(ファイルシステムから削除されたものの依然としてバージョンコントロールによって追跡されている)場合にもエラーをシグナルします。

@item
VCファイルセットに、バージョンコントロールシステムに登録されたファイルがない場合、ファイルセットの新たに追加されたファイルを登録します。@ref{Registering}を参照してください。Emacsが登録すべきシステムを見つけられない場合、レポジトリタイプの入力を求め、新しいレポジトリを作成して、VCファイルセットをそれに登録します。明示的にシステムを指定することもできます。@ref{Advanced
C-x v v}を参照してください。

@item
各ファイルが登録されていてロックされていなければファイルをチェックアウト(書き込み可能にするためにロックして編集を開始できるように)します。

@item
各ファイルのロックを獲得していて、それらが変更を含む場合にはその変更をコミットします(``チェックイン''とも呼ばれる)。これを行うことにより、Emacsは@file{*vc-log*}バッファーをポップアップするので、新しいリビジョンのログエントリーをタイプしてから、C-c
C-cでコミットします(@ref{Log Buffer}を参照してください)。

@item
各ファイルのロックをすでに獲得していて変更がない場合には、ファイルを再び読み取り専用にするためにロックを開放します。これはチェックアウト以降に変更されていないファイルにたいする以前のチェックアウト操作も取り消します。

@item
各ファイルが他のユーザーによりロックされている場合、ロックを横取りする(steal the
lock)か、確認を求めます。これにyesと応えると、あなたがロックを獲得して、その前にファイルをロックしていたユーザーに、警告メッセージが送られます。

@item
ファイルセット内のファイルがロックされていないにも関わらず、それらの最後のリビジョンから変更されている場合には、そのようなファイルそれぞれにたいするロックの要求、もしくは最後にチェックインされたリビジョンへのファイルのリバートを提案します(これは例外的な状況であり通常なら起こり得ない筈)。
@end itemize

  このルールは、CVSがロックの横取りをサポートしない点をのぞき、CVSをロックモードで使用している場合も適用されます。

@node Advanced C-x v v
@subsubsection @kbd{C-x v v}の高度な制御

@cindex revision ID in version control
  @code{vc-next-action}にプレフィクス引数を与えた場合(@kbd{C-u C-x v
v})、論理的に次のバージョンコントロール操作を処理する点に変わりはありませんが、どのように操作を行うかを正確に指定するために、追加の引数を指定できるようになります。

@itemize @bullet
@item
@cindex specific version control system
バージョンコントロールシステムの名前を指定できます。これは、ファイルセットが複数のバージョンコントロールシステムで管理されていて、Emacsが正しいものを検知するのに失敗するとき便利です。

@item
そうでない場合で、CVS、RCS、SRCを使用しているときは、リビジョンIDを指定できます。

ファイルセットが変更(またはロック)されている場合、Emacsは指定したリビジョンIDでファイルをコミットします。適切なリビジョンIDを与えることにより、新しいブランチを作成できます(@ref{Branches}を参照してください)。

ファイルセットが変更(またはロック)されていない場合、これは指定したリビジョンを作業ツリーにチェックアウトします。リビジョンIDまたはブランチIDを与えることにより、他のブランチのリビジョンを指定できます(@ref{Switching
Branches}を参照してください)。空の引数(例: @kbd{C-u C-x v v
@key{RET}})は、カレントブランチの最新のリビジョン(``head''とも呼ばれる)をチェックアウトします。

この手法によるリビジョンIDの指定は、分散型のバージョンコントロールシステムでは単に無視されます。これらのシステムでは独自のリビジョンIDは指定できず、個別のファイルを``チェックアウト''するという概念も使いません。
@end itemize

@node Log Buffer
@subsection Log Entryバッファーの機能

@kindex C-c C-c @r{(Log Edit mode)}
@findex log-edit-done
  VCに変更のコミットを指示したとき、@file{*vc-log*}という名前のバッファーがポップアップします。このバッファーには、行った変更を説明する@dfn{ログエントリー(log
entry)}を書き込みます。書き込んだら@kbd{C-c C-c} (@code{log-edit-done})とタイプして,
そのバッファーを抜けて、ログエントリーとともに変更をコミットします。

@cindex Log Edit mode
@cindex mode, Log Edit
@vindex vc-log-mode-hook
@c FIXME: Mention log-edit-mode-hook here?  --xfq
  @file{*vc-log*}バッファーのためのメジャーモードはLog Editモードで、これはTextモードの変種です(@ref{Text
Mode}を参照してください)。Log
Editモードに入ると、Emacsはフック@code{text-mode-hook}および@code{vc-log-mode-hook}を実行します(@ref{Hooks}を参照してください)。

  @file{*vc-log*}バッファーでは、１行以上の@dfn{ヘッダー行(header
lines)}を記入できます。これにはバージョンコントロールシステムにより提供される、追加の情報を指定します。各ヘッダー行は、そのバッファーの最初の1行を占めなければなりません。ヘッダー行でない最初の行は、ログエントリーの開始として扱われます。たとえば以下のヘッダー行は、その変更が他の開発者によるものだということを示します:

@smallexample
Author: J. R. Hacker <jrh@@example.com>
@end smallexample

@noindent
@samp{Author}ヘッダーとは別に、Emacsは@samp{Summary}ヘッダー(changesetの1行要約)、@samp{Date}ヘッダー(手入力で指定されたコミット日時)、@samp{Fixes}ヘッダー(変更によるバグフィクスへの参照)を認識します。すべてのバージョンコントロールシステムが、すべてのヘッダーを認識するわけではありません。そのシステムでサポートされていないヘッダーを指定した場合、それはログエントリーの一部として扱われます。

@kindex C-c C-f @r{(Log Edit mode)}
@findex log-edit-show-files
@kindex C-c C-d @r{(Log Edit mode)}
@findex log-edit-show-diff
  @file{*vc-log*}バッファーにいる間は、カレントVCファイルセット(current VC fileset)とは、@w{@kbd{C-c
C-c}}とタイプすることによりコミットされるファイルセットだと考えられます。そのVCファイルセットのファイル一覧を閲覧するには、@w{@kbd{C-c
C-f}}
(@code{log-edit-show-files})とタイプします。そのVCファイルセットと、編集を開始したバージョンとのdiffを閲覧するには、@kbd{C-c
C-d} (@code{log-edit-show-diff})とタイプしてください。

@kindex C-c C-w @r{(Log Edit mode)}
@findex log-edit-generate-changelog-from-diff
@vindex diff-add-log-use-relative-names
  VCファイルセットのdiffにもとづいて変更されたすべてのファイルと関数をリストする雛形(skeleton)となるChangeLogエントリーを生成してChangeLogエントリー生成の助けとするには、@kbd{C-c
C-w}
(@code{log-edit-generate-changelog-from-diff})とタイプします。空のままの連続したエントリーは@kbd{M-q}
(@code{fill-paragraph})によって結合されます。この雛形には、デフォルトではディレクトリー部分がないファイル名だけが含まれます。VCルートまでのディレクトリー部分を前置したければ、@code{diff-add-log-use-relative-names}をカスタマイズしてください。

@kindex C-c C-a @r{(Log Edit mode)}
@findex log-edit-insert-changelog
  VCファイルセットが1つ以上の@file{ChangeLog}(@ref{Change Log}を参照してください)ファイルを含む場合、@kbd{C-c
C-a}
(@code{log-edit-insert-changelog})とタイプすると、関連するエントリーを、@file{*vc-log*}バッファーに引用します。各@file{ChangeLog}ファイルの一番上のアイテムが、今日の日付でユーザー名があなたの場合、このコマンドはコミットされるファイルにマッチするエントリーのアイテムを検索して、それを挿入します。
@ifnottex
CVSまたはRCSを使用している場合は、反対のこと --- Log EditバッファーからChangeLogエントリーを生成 ---
を行います。@ref{Change Logs and VC}を参照してください。
@end ifnottex

  コミットを中止するには、そのバッファーで単に@kbd{C-c
C-c}を@emph{タイプしない}で、バッファーを切り替えて他の編集を行うことができます。他のコミットを試みなければ、編集していたエントリーは@file{*vc-log*}に残っているので、後でそのバッファーに戻ってコミットを完了できます。

@kindex M-n @r{(Log Edit mode)}
@kindex M-p @r{(Log Edit mode)}
@kindex M-s @r{(Log Edit mode)}
@kindex M-r @r{(Log Edit mode)}
  コミットコメントをコピーするために、以前のログエントリーの履歴を閲覧することもできます。これは、似たようなコメントで複数のコミットを行いたいとき便利です。これを行うコマンド@kbd{M-n}、@kbd{M-p}、@kbd{M-s}、@kbd{M-r}は、これらがミニバッファーの外で使用される点を除けば、ミニバッファーのヒストリーコマンド(@ref{Minibuffer
History}を参照してください)と同様です。

@node Registering
@subsection バージョンコントロールへのファイルの登録

@table @kbd
@item C-x v i
visitしているファイルを、バージョンコントロールに登録します。
@end table

@kindex C-x v i
@findex vc-register
  コマンド@kbd{C-x v i}
(@code{vc-register})は、カレントVCファイルセットの各ファイルを、バージョンコントロールの配下に置きます。これは登録されていないVCファイルセットにたいして、@kbd{C-x
v v}が行う動作と基本的に同じですが、VCファイルセットがすでに登録されているとき(@ref{Basic VC
Editing}を参照してください)、@kbd{C-x v v}は他の操作を処理しますが、@kbd{C-x v
i}はエラーをシグナルする、という点が異なります。

  ファイルを登録するために、Emacsはバージョンコントロールシステムを選択しなければなりません。複数ファイルのVCファイルセットにたいしては、VC
Directoryバッファーが使用するシステムを指定します(@ref{VC Directory
Mode}を参照してください)。VCファイルセットのファイルが1つで、そのファイルのディレクトリーがすでにバージョンコントロールシステムに登録されたファイルを含むか、そのディレクトリーがバージョンコントロールシステムにより制御される作業ツリーの一部の場合、Emacsはそのシステムを選択します。複数のバージョンコントロールシステムが当てはまる場合、Emacsは変数
@iftex
@code{vc-handled-backends}に最初に表れるシステムを使用します。
@end iftex
@ifnottex
@code{vc-handled-backends}に最初に表れるシステムを使用します(@ref{Customizing VC}を参照)。
@end ifnottex
Emacsがファイルを登録するバージョンコントロールシステムを見つけられなかった場合、レポジトリタイプの入力を求め、新しいレポジトリを作成して、そのレポジトリにファイルを登録します。

@cindex added files, VC
@cindex files added to VCS
  ほとんどのバージョンコントロールシステムでは@w{@kbd{C-x v i}}や@w{@kbd{C-x v
v}}によってファイルを登録することでファイルが作業ツリーに追加されますが、コミットは行われません(レポジトリには追加されない)。そのようなファイルはVC
Directoryバッファーでは@dfn{added}というラベルがつき、そのようなファイルをvisitしているバッファーのモードラインには@samp{@@@@}というリビジョンIDが表示されます。そのレポジトリにおいて登録の効果を有効にするには、新たに追加したファイルをコミットしなければなりません(@ref{Basic
VC Editing}を参照)。ファイルの追加と編集は、VCSが関知するものについては両方とも単一のコミットに含められます。

  ロックベースのバージョンコントロールシステム(@ref{VCS
Merging}を参照してください)では、ファイルの登録により、ファイルはロックされていない読み取り専用の状態に留まります。ファイルをチェックアウトして編集を開始するには、@kbd{C-x
v v}とタイプします。

@node Old Revisions
@subsection 古いリビジョンの調査と比較

@table @kbd
@item C-x v =
カレントVCファイルセットの作業ファイルと、編集を開始したバージョンを比較します(@code{vc-diff})。プレフィクス引数を指定した場合、カレントVCファイルセットの2つのリビジョンの入力を求め、それらを比較します。このコマンドをDiredバッファーから呼び出すこともできます(@ref{Dired}を参照してください)。

@ifnottex
@item M-x vc-ediff
@kbd{C-x v =}と同様ですが、Ediffを使用します。@ref{Top,, Ediff, ediff, The Ediff
Manual}を参照してください。
@end ifnottex

@item C-x v D
編集を開始したリビジョンの、作業ツリー全体を比較します(@code{vc-root-diff})。プレフィクス引数を指定した場合、2つのリビジョンの入力を求め、それらのツリーを比較します。

@item C-x v ~
カレントファイルのリビジョンの入力を求め、それを別のバッファーでvisitします(@code{vc-revision-other-window})。

@item C-x v g
カレントファイルの、注釈付きのバージョンを表示します。各行には、その行が変更された最新のリビジョンが表示されます(@code{vc-annotate})。
@end table

@findex vc-diff
@kindex C-x v =
  @kbd{C-x v =}
(@code{vc-diff})は、@dfn{diff}を表示します。これはカレントVCファイルセットの各作業ファイルを、編集を開始したときのバージョンと比較します。diffは別のウィンドウに、@file{*vc-diff*}という名前のDiff
modeモードのバッファー(@ref{Diff
Mode}を参照してください)で表示されます。このバッファーでは、通常のDiffモードコマンドが利用可能です。特に@kbd{g}
(@code{revert-buffer})コマンドは、ファイル比較を再び行い、新しいdiffを生成します。

@kindex C-u C-x v =
  カレントVCファイルセットの、任意の2つのリビジョンを比較するには、@kbd{C-u C-x v
=}のようにプレフィクス引数を指定して、@code{vc-diff}を呼び出します。これは2つのリビジョンID(@ref{VCS
Concepts}を参照してください)の入力を求め、ファイルセットのそれらのバージョンの間のdiffを表示します。このコマンドは、バージョンコントロールシステムが変更セットベースではなくファイルベースの場合(たとえばCVS)に、複数ファイルのVCファイルセットにたいして確実に動作しません。なぜなら同じリビジョンIDをもつ異なるファイル同士を、意味のある方法で関連させることができないからです。

  リビジョンIDではなく、他のフォーマットでリビジョンを指定するバージョンコントロールシステムもいくつかあります。たとえばBazaarでは、@kbd{C-u
C-x v
=}(および関連するコマンド)に@samp{date:yesterday}と入力でき、これは昨日以降コミットされた最初のリビジョンを指定します。詳細については、バージョンコントロールシステムのドキュメントを参照してください。

  Diredバッファー(@ref{Dired}を参照してください)で@kbd{C-x v =}または@kbd{C-u C-x v
=}を呼び出すと、カレント行にリストされたファイルが、カレントVCファイルセットとして扱われます。VCファイルセットにはマークした複数のファイルを含めることもできます。

@ifnottex
@findex vc-ediff
  @kbd{M-x vc-ediff}は、@kbd{C-x v =}と同じように機能しますが、Ediffセッションを使用します。@ref{Top,,
Ediff, ediff, The Ediff Manual}を参照してください。
@end ifnottex

@findex vc-root-diff
@kindex C-x v D
  @kbd{C-x v D} (@code{vc-root-diff})は、@kbd{C-x v
=}と似ていますが、カレント作業ツリー全体の変更を表示します(たとえばカレントVCファイルセットを含む作業ツリー)。このコマンドをDiredバッファーから呼び出すと、そのディレクトリーを含む作業ツリーに適用されます。

@findex vc-root-version-diff
@kindex C-u C-x v D
  ツリー全体の任意の2つのリビジョンを比較するには、@kbd{C-u C-x v
=}のようにプレフィクス引数を指定して@code{vc-root-diff}を呼び出します。これは2つのリビジョンID(@ref{VCS
Concepts}を参照)の入力を求めて、バージョンコントロールされたディレクトリー全体のバージョン間のdiffを表示します(RCS、SCCS、CVS、SRCはこの機能をサポートしない)。

@vindex vc-diff-switches
  @kbd{C-x v =}および@kbd{C-x v
D}が、diffを生成するために使用する@command{diff}オプションをカスタマイズできます。オプションには、変数@code{vc-@var{backend}-diff-switches}、@code{vc-diff-switches}、@code{diff-switches}(@ref{Comparing
Files}を参照)の順に、最初の非@code{nil}の値が使用されます。ここで@var{backend}は、関連するバージョンコントロールシステムで、たとえばBazaarの場合は@code{bzr}です。@code{nil}は順番に次の変数をチェックすることを意味するので、スイッチを指定しない場合は最初の2つの値を@code{t}にします。ほとんどの@code{vc-@var{backend}-diff-switches}変数のデフォルトは@code{nil}ですが、いくつかのbackendのデフォルトは@code{t}です。Subversionのように、これらのバージョンコントロールシステムの@code{diff}実装は、一般的なdiffオプションを受け付けません。

@findex vc-revision-other-window
@kindex C-x v ~
  ファイルの古いバージョンを直接調べるには、作業ファイルをvisitして、@kbd{C-x v ~ @var{revision} @key{RET}}
(@code{vc-revision-other-window})とタイプします。これは@var{revision}に対応するバージョンのファイルを取得して、それを@file{@var{filename}.~@var{revision}~}に保存してから、別のウィンドウでvisitします。

@findex vc-annotate
@vindex vc-annotate-background-mode
@kindex C-x v g
  多くのバージョンコントロールシステムでは、@kbd{C-x v g}
(@code{vc-annotate})とタイプして、行ごとにリビジョン情報の@dfn{注釈付き(annotated)}でファイルを閲覧できます。これは新しい``annotate''バッファーを作成して、各行に古さを示すカラーをつけて、ファイルのテキストを表示します。赤いテキストは新しく、古いものは青、その中間色は中間のバージョンを示します。デフォルトでは、一番古い変更を青、一番新しい変更を赤で、すべてのバージョンレンジにカラーをスケーリングします。変数@code{vc-annotate-background-mode}が非@code{nil}の場合、各行の世代を表すカラーはバックグラウンドカラーに適用され、フォアグラウンドカラーはデフォルトのカラーのままです。

@vindex vc-annotate-switches
  @kbd{C-x v
g}が使用する@code{annotate}オプションは@code{vc-@var{backend}-annotate-switches}と@code{vc-annotate-switches}でカスタマイズできます。これらの関数は上述した@code{vc-@var{backend}-diff-switches}および@code{vc-diff-switches}と同じように機能します。

  @kbd{C-x v
g}にプレフィクス引数を指定した場合には、Emacsはミニバッファーを使って、表示および注釈つけする(カレントファイル内容のかわりの)リビジョンと、カラーレンジがカバーすべきタイムスパンという2つの引数を読み取ります。

  ``annotate''バッファーでは、@samp{VC-Annotate}メニューから、これら、または他のカラースケールオプションが利用可能です。このバッファーでは、過去のリビジョンの注釈の表示、diffの閲覧、ログエントリーの閲覧を行うために、以下のキーを使うこともできます:

@table @kbd
@item p
前のリビジョン(たとえば現在の注釈付きのリビジョンの1つ前のリビジョン)に注釈を付けます。数引数は繰り返し回数となるので、@kbd{C-u 10
p}は10個前のリビジョンに注釈を付けます。

@item n
次のリビジョン(たとえば現在の注釈付きのリビジョンの1つ後のリビジョン)に注釈を付けます。数引数は繰り返し回数です。

@item j
カレント行に示されたリビジョンに解釈を付けます。

@item a
カレント行に示されたリビジョンの、1つ前のリビジョンに注釈を付けます。これはカレント行が変更される前の状態のファイルを見るとき便利です。

@item f
カレント行に示されたリビジョンのファイルを、バッファーに表示します。

@item d
カレント行のリビジョンと、その前のリビジョンの間のdiffを表示します。これはカレント行のリビジョンが実際にどのように変更されたか、ファイルを見るとき便利です。

@item D
カレント行のリビジョンと、その前のリビジョンの間で、(変更セットをサポートするバージョンコントロールシステムの)変更セットのすべてのファイルのdiffを表示します。これはカレント行のリビジョンが、実際にどのように変更されたかツリー内を見るとき便利です。

@item l
カレント行のリビジョンのログを表示します。これはカレント行のリビジョンの変更にたいする執筆者(author)の説明を見るのに便利です。

@item w
作業中のリビジョン(編集中のもの)に注釈を付けます。@kbd{p}や@kbd{n}を使って他のリビジョンを表示している場合、このキーで作業中のリビジョンに戻ることができます。

@item v
注釈の表示・非表示を切り替えます。これは邪魔になる注釈抜きでファイル内容だけを見たいとき便利です。
@end table

@node VC Change Log
@subsection VC Change Log
@cindex VC change log

@table @kbd
@item C-x v l
カレントファイルセットの変更履歴を表示します(@code{vc-print-log})。

@item C-x v L
カレントレポジトリの変更履歴を表示します(@code{vc-print-root-log})。

@item C-x v b l
別ブランチの変更履歴を表示します(@code{vc-print-branch-log})

@item C-x v I
pull操作が取り込む変更を表示します(@code{vc-log-incoming})。

@item C-x v O
push操作が送信する変更を表示します(@code{vc-log-outgoing})。

@item C-x v h
カレントバッファーがvisit中のファイルのリージョンにたいして行われた変更の履歴を表示します(@code{vc-region-history})。

@item M-x vc-log-search @key{RET}
指定したパターンの変更履歴を検索します。
@end table

@kindex C-x v l
@findex vc-print-log
  @kbd{C-x v l}
(@code{vc-print-log})は、@file{*vc-change-log*}という名前のバッファーを表示して、誰が変更したのか、その日時、各変更のログエントリー(これらは@file{*vc-log*}バッファーを通じて入力したログエントリーと同じです。@ref{Log
Buffer}を参照)を含む、カレントファイルセットに行われた変更の履歴を長い形式で表示します。ファイルをvisitしているバッファーから呼び出した際には、そのファイル単独でカレントファイルセットが構成されるとともに、表示中の@file{*vc-change-log*}バッファーでは、そのファイルのリビジョンの中央にポイントが配置されます。VC
Directoryバッファー(@ref{VC Directory
Mode}を参照)やDiredバッファー(@ref{Dired}を参照)から呼び出された場合には、マークされているすべてのファイル(マークされているファイルがなければディレクトリーバッファーのカレント行に表示されているファイルがデフォルト)からファイルセットが構成されることになります。

  ファイルセットに1つ以上のディレクトリーが含まれる場合には、VCバックエンドがサポートしていれば短い変更ログ、サポートしていなければ長い形式のログを表示する@file{*vc-change-log*}バッファーが得られます。

  プレフィックス引数を指定すると、@file{*vc-change-log*}バッファーで中央に表示するリビジョン、および表示するリビジョンの最大数の入力を求めます。

@kindex C-x v L
@findex vc-print-root-log
@findex log-view-toggle-entry-display
  @kbd{C-x v L}
(@code{vc-print-root-log})はバージョンコントロールされたディレクトリーツリー全体の履歴を示す@file{*vc-change-log*}バッファーを表示します(RCS、SCCS、CVS、SRCはこの機能をサポートしない)。コマンドにプレフィクス引数を与えると表示するリビジョンの最大数の入力を求めます。プレフィクス数引数は入力を求めることなくリビジョンの最大数を指定します。@w{@kbd{C-1
C-x v L}}や@w{@kbd{C-u 1 C-x v
L}}のようにプレフィクス数引数が1ならコマンドはリビジョンIDの入力を求めて、そのリビジョンで導入された変更(diff)とともにリビジョンのログエントリーを表示します(RCSやCVSのように機能に劣るバージョンコントロールシステムにはdiffとともにリビジョンログを表示するコマンドがなく、このコマンドはそれらにたいしてはログエントリーだけを表示するので、以下の@kbd{d}や@kbd{D}をタイプしてdiffを要求できる)。

  @kbd{C-x v
L}では履歴は簡略化された形式で表示され、通常は各ログエントリーの最初の行だけが表示されます。しかし@file{*vc-change-log*}バッファーで@key{RET}
(@code{log-view-toggle-entry-display})とタイプすると、ポイント位置のリビジョンのログエントリー全体を表示します。2回目の@key{RET}で、再びそれを隠します。

@kindex C-x v b l
@findex vc-print-branch-log
  @kbd{C-x v b l @var{branch-name} @key{RET}}
(@code{vc-print-branch-log})は@code{vc-print-root-log}と同様にバージョンコントロールされているディレクトリーツリーの履歴を@file{*vc-change-log*}バッファーに表示しますが、カレントブランチではなく別ブランチの履歴を表示します。そのためこのコマンドは履歴を表示するブランチの入力を求めます。

@kindex C-x v I
@kindex C-x v O
@findex vc-log-incoming
@findex vc-log-outgoing
  分散型のバージョンコントロールシステムでは、@kbd{C-x v I}
(@code{vc-log-incoming})コマンドは、次回にバージョンコントロールのpullコマンドを実行するときに、他所のリモートから受け取る新しいリビジョンにより適用される変更をログバッファーに表示します(@ref{Pulling
/
Pushing}を参照)。ここで他所のリモートとは、バージョンコントロールシステムで定義された変更をpullするデフォルトのリモートのことです。プレフィクス引数を指定すると、@code{vc-log-incoming}は特定のリモートの入力を求めます。同様に、@kbd{C-x
v O}
(@code{vc-log-outgoing})は、次回にpushコマンドを実行するときに、リモートに送る変更を表示します。プレフィクス引数を指定すると、送信先となる特定のリモート入力を求めます。一部のバージョンコントロールシステムではブランチ名かもしれません。 

@cindex VC log buffer, commands in
@cindex vc-log buffer
  @file{*vc-change-log*}バッファーでは、リビジョンのログまたはファイル間の移動や、過去のリビジョン(@ref{Old
Revisions}を参照してください)を調べたり比較するために、以下のキーを使うことができます:

@table @kbd
@item p
前のリビジョンエントリーに移動します(logバッファーのリビジョンエントリーは通常、日時の降順になっているので、前のリビジョンアイテムは通常、もっと新しいリビジョンに対応します)。数引数は繰り返し回数です。

@item n
次のリビジョンエントリーに移動します。数引数は繰り返し回数です。

@item a
カレント行のリビジョンに注釈を付けます(@ref{Old Revisions}を参照してください)。

@item e
ポイント位置に表示された変更コメントを修正します。すべてのバージョンコントロールシステムが、変更コメントの修正をサポートするわけではないことに注意してください。

@item f
カレント行に示されたリビジョンをvisitします。

@item d
ポイント位置のリビジョンと、次に古いリビジョンとの間で、特定のファイルにたいするdiffを表示します。

@item D
ポイント位置のリビジョンと、次に古いリビジョンとの間で、変更セットのdiffを表示します。これは、そのリビジョンですべてのファイルにたいして行われた変更を表示します。

@item @key{RET}
簡略形式のlogバッファー(たとえば@kbd{C-x v
L}で作成されたバッファー)で、ポイント位置のログエントリーにたいして、完全なログエントリーの表示・非表示を切り替えます。
@end table

@vindex vc-log-show-limit
多くのログエントリーを取得するには時間がかかるので、@file{*vc-change-log*}バッファーは、デフォルトで2000を超えるリビジョンは表示しません。変数@code{vc-log-show-limit}はこの制限を指定します。この値を0にセットすると、制限が削除されます。既存の@file{*vc-change-log*}で、バッファーの最後のボタン@samp{Show
2X entries}または@samp{Show unlimited
entries}をクリックして、表示するリビジョン数を増やすこともできます。しかしRCS、SCCS、CVS、SRCはこの機能をサポートしません。

@kindex C-x v h
@findex vc-region-history
変更履歴を確認する有用な変種はコマンド@kbd{vc-region-history} (デフォルトでは@kbd{C-x v
h}にバインド)により提供されます。これはカレントバッファーのファイルのポイントとマーク(@ref{Mark}を参照)の間にあるリージョンに行われた変更の履歴を@file{*VC-history*}バッファーに表示します。変更履歴にはコミットログメッセージ(commit
log messages)と変更自体のDiff形式も含まれます。

カレントバッファーの興味がある変更にたいしてリージョンをマークした後に、このコマンドを呼び出します。このコマンドがポップアップする@file{*VC-history*}バッファーでは、上述した@file{*vc-change-log*}バッファーで利用可能なコマンドすべてと、Diffモード(@ref{Diff
Mode}を参照)で定義されたコマンドも使用できます。

このコマンドは現在のところGitとMercurial(hg)だけで利用可能です。

@findex vc-log-search
コマンド@code{vc-log-search}により変更ログのパターンによる検索が可能になります。これはパターン(正規表現)の入力を求めて、パターンにマッチするログメッセージをもつ変更履歴内のすべてのエントリーを表示します。プレフィクス引数とともに呼び出された際には、コマンドはこの目的にたいして実行する固有のVCSシェルコマンドの入力も求めます。

@node VC Undo
@subsection バージョンコントロール操作のアンドゥ

@table @kbd
@item C-x v u
カレントVCファイルセットの作業ファイルを、最後のリビジョンにリバートします(@code{vc-revert})。
@end table

@kindex C-x v u
@findex vc-revert
@vindex vc-revert-show-diff
  カレントVCファイルセットにたいするすべての変更を破棄したい場合、@kbd{C-x v u}
(@code{vc-revert})とタイプします。これは変更を破棄する前に同意を求めます。同意するとそのファイルセットはリバートされます。

  @code{vc-revert-show-diff}が非@code{nil}ならは、このコマンドは作業ファイル(複数可)と編集を開始したリビジョンとの間のdiffを表示します。その後でdiffバッファーは(この変数が@code{kill}なら)kill、あるいは(それ以外の非@code{nil}値なら)バリーされます。@kbd{C-x
v u}でdiffを表示させたくない場合は、この変数に@code{nil}をセットしてください(この設定をしても@kbd{C-x v
=}で直接diffを表示できる。@ref{Old Revisions}を参照)。

  ロックベースのバージョンコントロールシステムでは、@kbd{C-x v
u}はファイルをロックしないまま残します。編集を再開するには、再度ロックしなければなりません。ファイルをロックしてから、やはりそれを変更しないと決めたときも、@kbd{C-x
v u}でファイルのロックを開放できます。

@node VC Ignore
@subsection バージョンコントロールファイルを無視する

@table @kbd
@item C-x v G
カレントのバージョンコントロールシステム配下のファイルを無視します(@code{vc-ignore})。
@end table

@kindex C-x v G
@findex vc-ignore
  ソースツリーの多くは、エディターのバックアップや、オブジェクトファイル、バイトコードファイル、ビルドされるプログラムなどの、バージョン管理する必要のないファイルを含みます。これらは単に追加しないだけでも構いませんが、常に不明なファイルとして現れるでしょう。ツリーのトップの、無視するファイルのリストにこれらのファイルを追加して、それらを無視するようにバージョンコントロールシステムに指示することもできます。これを行うには@kbd{C-x
v G} (@code{vc-ignore})が助けとなるでしょう。プレフィクス引数を指定すると、無視するファイルリストからファイルを削除できます。

@node VC Directory Mode
@subsection VC Directoryモード

@cindex VC Directory buffer
  @dfn{VC
Directoryバッファー}は、ディレクトリーツリーにあるファイルのバージョンコントロール状態を見て、それらのファイルにバージョンコントロール操作を実行するために特化したバッファーです。特に複数ファイルのVCファイルセットにたいして、@w{@kbd{C-x
v v}}のようなコマンドを適用するのに使用されます(@ref{VC Directory Commands}を参照してください)。

@kindex C-x v d
@findex vc-dir
  VC Directoryバッファーを使用するには、@kbd{C-x v d}
(@code{vc-dir})とタイプします。これはミニバッファーを使用してディレクトリーの名前を読み取り、そのディレクトリーにたいするVC
Directoryバッファーに切り替えます。デフォルトでは、バッファーの名前は@file{*vc-dir*}です。その内容については、
@iftex
以下で説明します。
@end iftex
@ifnottex
@ref{VC Directory Buffer}で説明します。
@end ifnottex

  @code{vc-dir}コマンドは、指定したディレクトリーで使用されているバージョンコントロールシステムを自動的に検知します。そのディレクトリーにたいして複数のバージョンコントロールシステムが使用されている場合、@kbd{C-u
C-x v d}のようにプレフィクス引数を指定して、このコマンドを呼び出す必要があるでしょう。これはVC
Directoryバッファーが使用すべきバージョンコントロールシステムの入力を求めます。

@ifnottex
@cindex PCL-CVS
@pindex cvs
@cindex CVS directory mode
  VC Directoryバッファーに加えて、EmacsにはCVSに特化したPCL-CVSと呼ばれる似た機能があります。@ref{Top, , About
PCL-CVS, pcl-cvs, PCL-CVS---The Emacs Front-End to CVS}を参照してください。
@end ifnottex

  Diredバッファー(@ref{Dired}を参照)からVCコマンドを呼び出すこともできます。この場合には、呼び出したVCコマンドはマークされているファイル(マークされているファイルがなければカレント行のファイルがデフォルト)をカレントファイルセットとみなします(@ref{Basic
VC Editing}を参照)。

@menu
* Buffer: VC Directory Buffer.  バッファーの外観と意味。
* Commands: VC Directory Commands.  VC 
                                      directoryバッファーで使用するコマンド。
@end menu

@node VC Directory Buffer
@subsubsection VC Directoryバッファー

  VC Directoryバッファーは、バージョンコントロールされたファイルと、それらのバージョンコントロール状態を含みます。これは、(@kbd{C-x
v
d}を呼び出すことにより指定される)カレントディレクトリーの、注目すべき状態のファイルとサブディレクトリーをだけリストします。最新のファイル(レポジトリのものと同じ)は省略されます。サブディレクトリーのファイルがすべて最新の場合、そのサブディレクトリーもリストされません。例外として、VCコマンドの直接の結果として最新になったファイルはリストされます。

  以下はVC Directoryバッファーのリストの例です:

@smallexample
@group
                     ./
    edited           configure.ac
*   added            README
    unregistered     temp.txt
                     src/
*   edited           src/main.c
@end group
@end smallexample

@noindent
2つの作業ファイル、カレントディレクトリーの@file{configure.ac}と、サブディレクトリー@file{src/}の@file{main.c}は、変更されていますがコミットされていません。@file{README}という名前のファイルは追加されましたが、まだコミットされていません。そして@file{temp.txt}はバージョンコントロールの配下にありません(@ref{Registering}を参照してください)。

エントリー@file{README}および@file{src/main.c}の隣の@samp{*}という文字は、ユーザーがそれらのファイルをカレントVCファイルセットとしてマークしたことを示します
@iftex
(以下を参照してください)。
@end iftex
@ifnottex
(@ref{VC Directory Commands}を参照してください)。
@end ifnottex

  上記は、Bazaar、Git、Mercurialのような分散型のバージョンコントロールシステムでの典型的な例です。他のシステムでは、他の状態も見られます。たとえばCVSは、レポジトリが変更されていて、それがまだ作業ファイルに適用されていないときは、@samp{needs-update}という状態を表示します。RCSとSCCSは、ロックされているファイルの状態に、ロックしているユーザーの名前を表示します。

@ifnottex
  CVSでは通常、@code{vc-dir}コマンドは更新のチェックのために、おそらくはリモートマシン上にあるであろうレポジトリにアクセスします。変数@code{vc-cvs-stay-local}を@code{nil}
(@ref{CVS Options}を参照)に変更すると、EmacsはVC
Directoryバッファーが生成されるときのリモートのレポジトリへのアクセスを避けます(コミットを行うときなど、必要なときはアクセスします)。これは、オフラインで作業していたり、ネットワークが遅いときは望ましいでしょう。
@end ifnottex

@vindex vc-directory-exclusion-list
  VC
Directoryバッファーは、変数@code{vc-directory-exclusion-list}にリストされているサブディレクトリーを省略します。この変数のデフォルト値には、バージョンコントロールシステムにより内部的に使用されるディレクトリーが含まれています。

@node VC Directory Commands
@subsubsection VC Directoryコマンド

  EmacsはVC
Directoryバッファーの操作と、カレントVCファイルセットに属させるために、ファイルをマークするためのコマンドをいくつか提供します。

@table @kbd
@item n
@itemx @key{SPC}
次のエントリーにポイントを移動します(@code{vc-dir-next-line})。

@item p
前のエントリーにポイントを移動します(@code{vc-dir-previous-line})。

@item @key{TAB}
次のディレクトリーエントリーに移動します(@code{vc-dir-next-directory})。

@item S-@key{TAB}
前のディレクトリーエントリーに移動します(@code{vc-dir-previous-directory})。

@item @key{RET}
@itemx f
カレント行にリストされたファイル、またはディレクトリーをvisitします(@code{vc-dir-find-file})。

@item o
カレント行にリストされたファイル、またはディレクトリーを別のウィンドウでvisitします(@code{vc-dir-find-file-other-window})。

@item m
カレント行のファイルまたはディレクトリーをマークして、それをカレントVCファイルセットに加えます(@code{vc-dir-mark})。リージョンがアクティブのときは、リージョンの中のすべてのファイルをマークします。

すでにマークされたディレクトリーの中のファイル、またはそのサブディレクトリーは、このコマンドではマークされません。同様に、ツリーの中のいくつかのファイルがマークされているディレクトリーは、このコマンドではマークされません。

@item M
ポイントがファイルエントリーにあるときは、同じ状態のすべてのファイルをマークします。ポイントがディレクトリーエントリーにあるときは、そのディレクトリーツリーのすべてのファイルをマークします(@code{vc-dir-mark-all-files})。プレフィクス引数を指定した場合、リストされたファイルとディレクトリーのすべてをマークします。

@findex vc-dir-mark-by-regexp
@item % m
@itemx * %
regexpでファイルをマークするためにこのコマンドを使用できます(@code{vc-dir-mark-by-regexp})。プレフィックス引数が与えられた場合にはマークではなくマークを解除します。

@findex vc-dir-mark-registered-files
@item * r
このコマンドは編集済み(edited)、追加済み(added)、削除済み(removed)を含む登録済み(registered)のいずれかの状態にあるファイルをマークするために用いることができます(@code{vc-dir-mark-registered-files})。

@item G
ポイントの下にあるファイルをVCが無視(ignore)すべきファイルのリストに追加します(@code{vc-dir-ignore})。たとえばVCがGitなら、そのファイル@file{.gitignore}ファイルに追加します。プレフィクスが与えられたら、マークしたすべてのファイルにこれを行います。

@item q
VC Directoryバッファーを終了して、隠します(@code{quit-window})。

@item u
カレント行のファイル、またはディレクトリーのマークを外します(@code{vc-dir-unmark})。リージョンがアクティブのときは、リージョンの中のすべてのファイルのマークを外します。

@item U
ポイントがファイルエントリーにあるときは。同じ状態のすべてのファイルのマークを外し、ポイントがディレクトリーエントリーにあるときは、そのディレクトリーツリーのすべてのファイルのマークを外します(@code{vc-dir-unmark-all-files})。プレフィクス引数を指定した場合、すべてのファイルおよびディレクトリーのマークを外します。

@item x
状態が@samp{up-to-date}、または@samp{ignored}のファイルを隠します(@code{vc-dir-hide-up-to-date})。プレフィクス引数を指定した場合、状態がポイント位置のアイテムと同じアイテムを隠します。
@end table

@findex vc-dir-mark
@findex vc-dir-mark-all-files
  VC Directoryバッファーでは、@kbd{m} (@code{vc-dir-mark})または@kbd{M}
(@code{vc-dir-mark-all-files})でマークしたすべてのファイルが、カレントVCファイルセットになります。ディレクトリーエントリーを@kbd{m}でマークした場合、そのディレクトリーツリーにリストされたすべてのファイルが、カレントVCファイルセットになります。カレントVCファイルセットに属するファイルとディレクトリーは、VC
Directoryではバージョンコントロール状態の隣に、文字@samp{*}が示されます。この方法により@w{@kbd{C-x v v}}
(@ref{Basic VC Editing}を参照してください)、@w{@kbd{C-x v =}} (@ref{Old
Revisions}を参照してください)、@w{@kbd{C-x v u}} (@ref{VC
Undo}を参照してください)のようなVCコマンドが作用する、複数ファイルのVCファイルセットをセットアップできます。

  VC Directoryバッファーは、@kbd{C-x
v}というプレフィクスをもつコマンドを、1キーで入力するショートカット(@kbd{=}、@kbd{+}、@kbd{l}、@kbd{i}、@kbd{D}、@kbd{L}、@kbd{G}、@kbd{I}、@kbd{O}、@kbd{v})を定義します。

  たとえば、VC
Directoryバッファーで開いて編集された一連のファイルは、@samp{edited}という状態でリストされ、それらのファイルをマークして、@kbd{v}または@kbd{C-x
v v}
(@code{vc-next-action})でコミットできます。バージョンコントロールシステムが変更セットベースの場合、Emacsはそれらのファイルを1つのリビジョンとしてコミットします。

  VC Directoryバッファーでは、以下のコマンドによりカレントVCファイルセットの検索と置換を処理することもできます:

@table @kbd
@item S
ファイルセットを検索します(@code{vc-dir-search})。

@item Q
ファイルセットにたいして、正規表現による問い合わせ置換を行います(@code{vc-dir-query-replace-regexp})。

@item M-s a C-s
ファイルセットにたいして、インクリメンタル検索を行います(@code{vc-dir-isearch})。

@item M-s a C-M-s
ファイルセットにたいして、インクリメンタルな正規表現検索を行います(@code{vc-dir-isearch-regexp})。
@end table

@noindent
複数ファイルに作用する点を除けば、これらのコマンドは1つのバッファーに作用する同等のコマンドに似ています(@ref{Search}を参照してください)。

  VC Directoryバッファーは追加でブランチ関連のコマンドを定義しており、それらはプレフィックス@kbd{b}で始まります:

@table @kbd
@item b c
新たにブランチを作成します(@code{vc-create-branch})。@ref{Creating Branches}を参照してください。

@item b l
ブランチ名の入力を求め、そのブランチの変更履歴を表示します(@code{vc-print-branch-log})。

@item b s
ブランチを切り替えます(@code{vc-switch-branch})。@ref{Switching Branches}を参照してください。

@item d
マークされたファイル、マークされたファイルがなければカレントファイルを削除します(@code{vc-dir-clean-delete)}。バージョンコントロールシステムではマークされたファイルが削除される訳ではないので、これは主としてバージョンコントロールシステムに未登録のファイルにたいして有用です。
@end table

@cindex stashes in version control
@cindex shelves in version control
  上記のコマンドは、メニューバーおよび@kbd{mouse-2}によるコンテキストメニューを通じても利用可能です。さらにVCのバックエンドのいくつかは、そのバックエンド特有のコマンドを提供するメニューを使用します。たとえばGitとBazaarでは、@dfn{stashes(隠してあるもの)}と@dfn{shelves(棚)}(コミットされていない変更を一時的に除外して、後でそれを戻すコマンド)を操作できます。

@node Branches
@subsection バージョンコントロールのブランチ
@cindex branch (version control)

  バージョンコントロールの活用法の1つとして、@dfn{ブランチ(branches)}と呼ばれる複数の独立した開発ラインのサポートがあります。中でもとりわけブランチは、プログラムの安定版(stable)と開発版(development)を個別に保守したり、関係のない機能を他の版から隔離して開発するのに使用されます。

  現在のところVCのブランチ操作にたいするサポートは、かなり制限されています。分散型のバージョンコントロールシステムにたいしては、あるブランチを他のブランチのコンテンツで@dfn{更新}するコマンドと、2つの異なるブランチの変更を@dfn{マージ}するコマンドを提供します。集中型のバージョンコントロールシステムにたいしては、異なるブランチからチェックアウトして、新規または異なるブランチにコミットするコマンドを提供します。

@menu
* Switching Branches::       既存のブランチを取得する方法。
* Pulling / Pushing::        他の場所からの変更を受信、変更の送信。
* Merging::                  ブランチ間での変更の転送。
* Creating Branches::        新しいブランチを開始する方法。
@end menu

@node Switching Branches
@subsubsection ブランチ間の切り替え

  さまざまなバージョンコントロールシステムにおいて、ブランチが実装される方法は異なり、VCはこれらの違いを完全に隠蔽することはできません。

  BazaarとMercurialを含む分散型バージョンコントロールシステムのいくつかは、ノーマルモードの操作では、各ブランチは自身の作業ディレクトリーツリーをもつので、ブランチの切り替えは単にディレクトリーを切り替えるだけです。Gitでは、ブランチは通常、同じディレクトリーの@dfn{共通ロケーション(co-located)}を使用し、ブランチの切り替えは、作業ツリーの内容をそのブランチに一致するように変更する@kbd{git
checkout}を使用して行われます。Bazaarも共通ロケーションをサポートしており、この場合はコマンド@kbd{bzr
switch}によりカレントディレクトリーでブランチを切り替えます。Subversionでは他のブランチへの切り替えにはコマンド@kbd{svn
switch}を使用します。Mercurialでは他のブランチへの切り替えにはコマンド@kbd{hg update}を使用します。

@kindex C-x v b s
@findex vc-switch-branch
  カレントディレクトリーの他のブランチに切り替えるVCコマンドは、@kbd{C-x v b s @var{branch-name} @key{RET}}
(@code{vc-switch-branch})です。

  集中型のバージョンコントロールシステムでは、最新の作業ファイルで@kbd{C-u C-x v v}とタイプして(@ref{Advanced C-x v
v}を参照してください)、他のブランチのリビジョンIDを入力することにより、ブランチ間を切り替えることもできます。たとえばCVSでは、@dfn{trunk(幹の意。開発の主要ラインを示します)}のリビジョンは通常、1.1、1.2、1.3、@dots{}という形式をもち、最初のブランチがリビジョン1.2から作成された場合、リビジョン1.2は1.2.1.1、1.2.1.2、@dots{}というリビジョンIDをもち、さらに2番目のブランチが同じくリビジョン1.2から作成された場合、それは1.2.2.1、1.2.2.2、@dots{}という形式になります。ブランチのリビジョンIDから最後の部分を除いた(たとえば1.2.1)、@dfn{ブランチID(branch
ID)}を指定して、そのブランチの最新のリビジョンに切り替えることもできます。

  ロックベースのシステムでは、他のブランチに切り替えることにより、作業ツリーのロックが解除(書き込み禁止)になります。

  1度ブランチを切り替えると、そのブランチを他に切り替えるまで、VCコマンドはそのブランチに適用されます。たとえば任意のVCファイルセットをコミットすると、そのブランチにコミットされるようになります。

@node Pulling / Pushing
@subsubsection ブランチへ/からの変更のpull/push

@table @kbd
@cindex push changes to upstream (VC)
@item C-x v P
分散型のバージョンコントロールシステムでは、カレントブランチでローカルにコミットされた変更で他のレポジトリを更新します(変更の@dfn{push}とも呼ばれる)。この概念は集中型のバージョンコントロールシステムには存在しません。

@cindex pull changes from upstream (VC)
@item C-x v +
分散型のバージョンコントロールシステムでは他のレポジトリから変更を@dfn{pull}することにより、ローカルレポジトリのカレントブランチを更新します。

集中型のバージョンコントロールシステムでは、そのレポジトリからカレントVCファイルセットを更新します。
@end table

@kindex C-x v P
@findex vc-push
@cindex upstream repository
分散型のバージョンコントロールシステムでは、コマンド@kbd{C-x v P}
(@code{vc-push})は、カレントブランチでローカルにコミットされた変更により他のロケーション(一般的には@dfn{アップストリームのレポジトリ(upstream
repository)}と呼ばれる)を更新します。プレフィクス引数を与えた場合、このコマンドは実行する正確なバージョンコントロールコマンドの入力をもとめます。これにより変更をどこにpushするか指定できます。デフォルトは、Bazaarでは@kbd{bzr
push}、Gitでは@kbd{git push}、Mercurialでは@kbd{hg
push}です。デフォルトのコマンドは常に、ブランチ設定からバージョンコントロールシステムにより決定されるデフォルトのロケーションのレポジトリにpushします。

pullする前に@kbd{C-x v O}
(@code{vc-log-outgoing})を使用して、アップストリーム送信される変更のlogバッファーを閲覧できます。@ref{VC Change
Log}を参照してください。

@cindex bound branch (Bazaar VCS)
現在のところ、このコマンドはBazaar、Git、Mercurialだけでサポートされます。``push''という概念は集中型のバージョンコントロールシステムには存在しません。なぜなら、この操作は変更セットのコミットの一部なので、集中型のVCSでこのコマンドを呼び出すと、エラーをシグナルします。Bazaarの@dfn{bound
branch}でこのコマンドを試みたときもエラーをシグナルします。変更セットのコミットは、自動的に変更を(ローカルのブランチがバインドされている)リモートのレポジトリにpushするからです。

@kindex C-x v +
@findex vc-pull
  分散型のバージョンコントロールシステムでは、コマンド@kbd{C-x v +}
(@code{vc-pull})はアップストリームのレポジトリに施された変更によって、ローカルレポジトリのカレントブランチと作業ツリーを更新します。これは通常だとリモートブランチのコピー(@dfn{clone}とも呼ばれる)を更新するために使用されます。プレフィクス引数を与えた場合には、このコマンドは使用する正確なバージョンコントロールコマンドの入力をもとめます。これによりどこから変更をpullするか指定することが可能になります。プレフィクス引数を指定しなければ、ブランチの構成からバージョンコントロールシステムにより決定されるデフォルトロケーションのレポジトリからpullすることになります。

  分散型のバージョンコントロールシステムの中で、現在@kbd{C-x v
+}がサポートするのはBazaar、Git、Mercurialだけです。Bazaarでは、これは通常のブランチにたいしては、(マスターブランチをミラーリングされたブランチにpullするために)
@kbd{bzr pull}を呼び出し、バインドされたブランチにたいしては、(中心となるレポジトリからpullするために) @kbd{bzr
update}を呼び出します。Gitでは、これはリモートのレポジトリから変更を取得して、それをカレントブランチにマージするために@kbd{git
pull}を呼び出します。Mercurialでは、デフォルトのリモートレポジトリから変更を取得して、作業ディレクトリーを更新するために@kbd{hg
pull -u}を呼び出します。

  pullする前に@kbd{C-x v I}
(@code{vc-log-incoming})を使用して、適用される変更のlogバッファーを閲覧できます。@ref{VC Change
Log}を参照してください。

  CVSのような集中型のバージョンコントロールシステムでは、@kbd{C-x v +}はレポジトリからカレントVCファイルセットを更新します。

@node Merging
@subsubsection ブランチのマージ
@cindex merging changes

@table @kbd
@item C-x v m
分散型のバージョンコントロールシステムでは、カレントのブランチに他のブランチの変更をマージします。

集中型のバージョンコントロールシステムでは、カレントVCファイルセットに他のブランチの変更をマージします。
@end table

  ブランチで開発している場合、すでに他のブランチで行われた変更を@dfn{マージ(merge)}する必要があるときがあります。これは2つのブランチでの変更が重なっていたり競合する場合もあるため、些細な操作とはいえません。

  分散型のバージョンコントロールシステムでは、コマンド@kbd{C-x v m}
(@code{vc-merge})でマージします。Bazaarでは、これはコマンド@command{bzr
merge}に渡す正確な引数の入力を求めます。そのとき、可能であれば目的にかなったデフォルトを提示します。Gitでは、これはマージするブランチ名の入力を求めます。このとき、(カレントレポジトリが知っているブランチ名にもとづく)補完を行います。Mercurialでは@command{hg
merge}に渡す引数の入力を求めます。マージコマンドの実行による出力は、他のバッファーに表示されます。

  CVSのような集中型のバージョンコントロールシステムでは、@kbd{C-x v
m}はブランチID、または2つのリビジョンIDの入力を求めます。コマンドはそのブランチからの変更点、または指定した2つのリビジョン間の差分を探して、それらの変更をカレントVCファイルセットにマージします。@kbd{@key{RET}}だけをタイプした場合、Emacsは単にそのファイルをチェックアウトしたブランチに行われた変更をマージします。

@cindex conflicts, VC
@cindex resolving conflicts
  マージを処理した直後は、作業ツリーだけが変更されており、@kbd{C-x v
D}および関連するコマンドで、マージにより生成された変更をレビューできます(@ref{Old
Revisions}を参照してください)。2つのブランチが重なった変更をもつ場合、マージは@dfn{衝突(conflict)}を生成します。その場合、マージコマンドの出力には警告が現れ。影響のある作業ファイルの、衝突する2つの変更の周囲に、@dfn{衝突マーカー(conflict
markers)}が挿入されます。衝突を解決するには、衝突するファイルを編集しなければなりません。EmacsはデフォルトではVCで衝突が生じたバッファーをSmergeという特別なモードにします。これはマージの衝突を解決するために特別なコマンドを提供するモードです。衝突を解決したファイルを保存したらマージが効果を発揮するように、通常の方法により変更したファイルをコミットしなければなりません(@ref{Basic
VC Editing}を参照)。

@node Creating Branches
@subsubsection 新しいブランチの作成

  CVSのような集中型のバージョンコントロールシステムでは、Emacsはコミット操作の一部として、新しいブランチの作成をサポートします。変更されたVCファイルセットをコミットするとき、@kbd{C-u
C-x v v} (@code{vc-next-action}のようにプレフィクス引数を指定します。@ref{Advanced C-x v
v}を参照してください).すると、Emacsは新しいリビジョンのリビジョンIDの入力を求めます。ここでカレントリビジョンから開始するブランチの。適切なブランチIDを指定する必要があります。たとえば、カレントリビジョンIDが2.5の場合、ブランチIDは2.5.1、2.5.2、...となるべきでしょう。ブランチIDは、その時点での既存のブランチの番号に依存します。

@kindex C-x v b c
@findex vc-create-branch
  この手順はgitやMercurialのような、分散型バージョンコントロールシステムでは機能しないでしょう。これらのシステムでは、かわりにコマンド@code{vc-create-branch}
(@w{@kbd{C-x v b c @var{branch-name} @key{RET}}})を使用する必要があります。

  (すでにブランチのヘッドではない)古いリビジョンに新しいブランチを作成するには、最初にそのリビジョンを選択します(@ref{Switching
Branches}を参照してください)。その後の手順は、ロックベースのバージョンコントロールシステムを使っているか、マージベースのものを使っているかで異なります。

  ロックベースのバージョンコントロールシステムでは、@kbd{C-x v
v}で古いリビジョンのブランチを選択します。古いリビジョンを選択する場合、本当に新しいブランチを作成したいのか確認を求めます。これにnoと応えた場合、かわりに最新のリビジョンをロックする機会が与えられます。マージベースのバージョンコントロールシステムでは、このステップはスキップします。

  変更を行なってから、再び@kbd{C-x v
v}とタイプして、新しいリビジョンをコミットします。これは選択されたリビジョンから始まる、新しいブランチを作成します。

  ブランチが作成された後は、それ以降のコミットは、そのブランチに新しいリビジョンを作成します。ブランチを離れるには、@kbd{C-u C-x v
v}で明示的に異なるリビジョンを選択しなければなりません。

@ifnottex
@include vc1-xtra-ja.texi
@end ifnottex

@node Projects
@section プロジェクトで作業する
@cindex projects

@cindex project root
  @dfn{プロジェクト(project)}とは1つ以上のプログラムを生成するために使用するファイルのコレクションです。プロジェクトに属するファイルは、通常はディレクトリー階層に格納されます。この階層のトップレベルのディレクトリーは@dfn{プロジェクトルート(project
root)}として知られています。

@cindex project back-end
  与えられたディレクトリーが何らかのプロジェクトのルートかどうかは、@dfn{プロジェクトバックエンド(project
back-end)}として知られているプロジェクト固有のインフラストラクチャーにより判断されます。Emacsが現在のところサポートするバックエンドはVCSレポジトリをプロジェクトとみなしたVCを考慮するプロジェクト
(@ref{Version Control}を参照)、およびEDE
(@ref{EDE}を参照)の2つです。将来的には追加のプロジェクトタイプをサポートするように拡張される予定です。

  ファイルがプロジェクトに属するかどうかもプロジェクトバックエンドにより判断されます。たとえばVCを考慮するバクエンドは``無視(ignored)''されたファイル(@ref{VC
Ignore}を参照)、更にデフォルトでは``未追跡(untracked)''のファイルもプロジェクトの一部とはみなしません。この挙動は変数@code{project-vc-include-untracked}で制御できます。

@menu
* Project File Commands::    プロジェクトファイルを扱うためのコマンド。
* Project Buffer Commands::  プロジェクトファイルを扱うためのコマンド。
* Switching Projects::       プロジェクト間の切り替え
* Managing Projects::        プロジェクトリストファイルの管理。
@end menu

@node Project File Commands
@subsection ファイルを操作するプロジェクトコマンド

@table @kbd
@item C-x p f
msgid "Visit a file that belongs to the current project ."
カレントプロジェクトに属するファイルをvisitします(@code{project-find-file})。
@item C-x p g
カレントプロジェクトに属するすべてのファイルにたいしてregexpにたいするマッチを検索します(@code{project-find-regexp})。
@item M-x project-search
カレントプロジェクトに属するすべてのファイルにたいしてインタラクティブにregexpにたいするマッチを検索します。
@item C-x p r
カレントプロジェクトに属するすべてのファイルにたいして、regexpにたいする問い合わせつき置換を行います(@code{project-query-replace-regexp})。
@item C-x p d
カレントプロジェクトのルートディレクトリーにたいしてDiredを実行します(@code{project-dired})。
@item C-x p v
カレントプロジェクトのルートディレクトリーで@code{vc-dir}を実行します(@code{project-vc-dir})。
@item C-x p s
カレントプロジェクトのルートディレクトリーで下位シェルを開始します(@code{project-shell})。
@item C-x p e
カレントプロジェクトのルートディレクトリーでEshellを開始します(@code{project-eshell})。
@item C-x p c
カレントプロジェクトのルートディレクトリーでコンパイルを実行します(@code{project-compile})。
@item C-x p !
カレントプロジェクトのルートディレクトリーでシェルコマンドを実行します(@code{project-shell-command})。
@item C-x p &
カレントプロジェクトのルートディレクトリーでシェルコマンドを非同期に実行します(@code{project-async-shell-command})。
@end table

  Emacsはプロジェクトファイルを手軽に扱うためのコマンドを提供します。このサブセクションではそれらのコマンドについて説明します。

@cindex current project
  ここで説明するすべてのコマンドは@dfn{カレントプロジェクト(current
project)}という概念を共有します。カレントプロジェクトはコマンド呼び出し時にカレントだったバッファーの@code{default-directory}
(@ref{File
Names}を参照)により判断されます。そのディレクトリーが認識可能なプロジェクトに属していないようなら、これらのコマンドはプロジェクトディレクトリーの入力を求めます。

@findex project-find-file
@vindex vc-directory-exclusion-list
  コマンド@kbd{C-x p f}
(@code{project-find-file})はカレントプロジェクトに属するファイルをvisit(@ref{Visiting}を参照)する手軽な手段です。@kbd{C-x
C-f}とは異なり、このコマンドはvisitするファイルの完全な名前のタイプを要求せず、ファイルのベース名(先頭のディレクトリー部分を省略)だけでタイプできます。それに加えてコマンドが補完候補とみなすのはカレントプロジェクトに属するファイルだけであり、それ以外は含まれません。ポイント位置にファイル名があれば、このコマンドは``将来のヒストリー(future
history)''の最初の要素としてそのファイルを提案します。プレフィックス引数が与えられた場合には、@code{vc-directory-exclusion-list}にリストされている@acronym{VCS}ディレクトリーを除く、プロジェクトルート配下のすべてのファイルが含められます。

@findex project-find-regexp
  コマンド@kbd{C-x p g} (@code{project-find-regexp})は@code{rgrep} (@ref{Grep
Searching}を参照)と似ていますが、カレントプロジェクトに属するファイルだけを検索します。このコマンドは検索する正規表現の入力を求めて、検索結果をXrefモードのコマンドを使用してマッチの選択が可能なXrefモードのバッファーでポップアップします。このコマンドをプレフィクス引数とともに呼び出した際には、検索を開始するベースディレクトリーの入力を追加で求めます。これはたとえばプロジェクトルートの特定のサブディレクトリー配下のファイルに検索を制限することを可能にします。このコマンドがマッチを表示する方法は@code{xref-auto-jump-to-first-xref}の値の影響を受けます(@ref{Identifier
Search}を参照)。

@findex project-search
  @kbd{M-x
project-search}は@code{project-find-regexp}の一連の変種です。これはカレントプロジェクトのファイルを検索するために正規表現の入力を求めますが、すべてのマッチを探して表示するかわりに、マッチしたファイルを編集できるようにマッチを見つけたら停止してマッチしたファイルのマッチしたlocusをvisitします。マッチの残りを探すには@w{@kbd{M-x
fileloop-continue @key{RET}}}とタイプしてください。

@findex project-query-replace-regexp
  @kbd{C-x p r}
(@code{project-query-replace-regexp})は@code{project-search}と似ていますが、@code{query-replace}
(@ref{Query
Replace}を参照)が行うように見つかったそれぞれのマッチにたいして置き換えるかどうかを尋ねて、それに応答した後は次のマッチへと継続します。その応答によりEmacsがquery-replaceループをexitしてしまったら、@w{@kbd{M-x
fileloop-continue @key{RET}}}で後から継続することができます。

@findex project-find-dir
  コマンド@kbd{C-x p d}
(@code{project-dired})は補完付きでカレントプロジェクト内部のディレクトリーの選択を求めます。そしてその中にあるファイルをリストするDiredバッファー(@ref{Dired}を参照)をオープンします。

@findex project-dired
  コマンド@kbd{C-x p D}
(@code{project-dired})はカレントプロジェクトのルートディレクトリーのファイルをリストするDiredバッファー(@ref{Dired}を参照)をオープンします。

@findex project-vc-dir
  コマンド@kbd{C-x p v}
(@code{project-vc-dir})はカレントプロジェクトのルートディレクトリー配下にあるディレクトリーツリー内のファイルのバージョンコントロール状態をリストするVC
Directoryバッファー(@ref{VC Directory Mode}を参照)をオープンします。

@findex project-shell
  コマンド@kbd{C-x p s}
(@code{project-shell})はカレントプロジェクトのルートディレクトリーを作業ディレクトリーとするシェルセッション(@ref{Shell}を参照)を新たなバッファーで開始します。

@findex project-eshell
  コマンド@kbd{C-x p e}
(@code{project-eshell})はカレントプロジェクトのルートディレクトリーを作業ディレクトリーとするEshellセッションを新たなバッファーで開始します。@ref{Top,Eshell,Eshell,
eshell, Eshell: The Emacs Shell}を参照してください。

@findex project-compile
  コマンド@kbd{C-x p c}
(@code{project-compile})はカレントプロジェクトのルートディレクトリーでコンパイル(@ref{Compilation}を参照)を実行します。

@findex project-shell-command
  コマンド@kbd{C-x p !}
(@code{project-shell-command})はカレントプロジェクトのルートディレクトリーで@code{shell-command}を実行します。

@findex project-async-shell-command
  コマンド@kbd{C-x p &}
(@code{project-async-shell-command})はカレントプロジェクトのルートディレクトリーで@code{async-shell-command}を実行します。

@node Project Buffer Commands
@subsection バッファーを操作するプロジェクトコマンド

@table @kbd
@item C-x p b
カレントプロジェクトに属する他のバッファーに切り替えます(@code{project-switch-to-buffer})。
@item C-x p C-b
プロジェクトバッファーをリストします(@code{project-list-buffers})。
@item C-x p k
カレントプロジェクトに属するすべての生きたバッファーをkillします(@code{project-kill-buffers})。
@end table

@findex project-switch-to-buffer
  プロジェクトでの作業ではプロジェクトに属するファイルをvisitするバッファーや、(@code{project-compile}が作成する@file{*compilation*}バッファーのように)プロジェクトには属するものの何のファイルもvisitしないバッファーを多数もつ可能性があります。コマンド@kbd{C-x
p b}
(@code{project-switch-to-buffer})はカレントプロジェクトに属するバッファーのみを補完候補とみなしてバッファーの入力を求めることにより、カレントプロジェクトに属するバッファー間の切り替えを助けます。

@findex project-list-buffers
  @kbd{C-x p C-b} (@code{project-list-buffers})はコマンド@code{list-buffers}
(@pxref{List
Buffers})と同じように既存のバッファーのリストを表示しますが、カレントプロジェクトに属するバッファーだけをリストするコマンドです。

@findex project-kill-buffers
@vindex project-kill-buffer-conditions
@vindex project-kill-buffers-display-buffer-list
  プロジェクトの作業が終わった際には、Emacsセッションを小さく保つためにプロジェクトに属するすべてのバッファーをkillしたいと思うかもしれません。コマンド@kbd{C-x
p k}
(@code{project-kill-buffers})によりこれを行うことができます。これはカレントプロジェクトに属する@code{project-kill-buffer-conditions}のいずれかを満足するすべてのバッファーをkillします。@code{project-kill-buffers-display-buffer-list}が非@code{nil}の場合には、まずkillされるバッファーを表示します。

@node Switching Projects
@subsection プロジェクトの切り替え

@table @kbd
@item C-x p p
他のプロジェクトにたいしてEmacsコマンドを実行します(@code{project-switch-project})。
@end table

@findex project-switch-project
@vindex project-switch-commands
  プロジェクトファイルを処理するコマンド(@ref{Project File
Commands}を参照)は、カレントプロジェクトがなければ、利便性のためにプロジェクトディレクトリーの入力を求めます。何らかのプロジェクト内部にいるものの別プロジェクトを操作したいときには、@kbd{C-x
p
p}コマンド(@code{project-switch-project})を使用します。このコマンドは既知のプロジェクトルートの中からディレクトリーの選択を求めて、選択したプロジェクトを操作するために利用可能なコマンドのメニューを表示します。変数@code{project-switch-commands}はメニュー内で利用できるコマンドと、各コマンドを呼び出すキーを制御します。

@vindex project-list-file
  変数@code{project-list-file}はEmacsが既知プロジェクトのリストを記録するファイルを指定します。デフォルトは@code{user-emacs-directory}にあるファイル@file{projects}です(@ref{Find
Init}を参照)。

@node Managing Projects
@subsection プロジェクトリストファイルの管理

@table @kbd
@item M-x project-forget-project
@code{project-list-file}から既知のプロジェクトを削除する。
@end table

@findex project-forget-project
  Emacsは通常は自動的に@code{project-list-file}へのプロジェクトの追加と削除を行いますが、利用可能なプロジェクトを手編集したいときもあるかもしれません。@kbd{M-x
project-forget-project}は利用可能なプロジェクトからプロジェクトの入力を求めて、そのプロジェクトをファイルから削除します。

@node Change Log
@section 変更ログ

@cindex change log
  多くのソフトウェアプロジェクトでは、@dfn{変更ログ(change
log)}を管理します。これは通常、いつどのようにして、そのプログラムが変更されたかの日付順の記録を含む、@file{ChangeLog}という名前のファイルです。これらのファイルは、バージョンコントロールシステムに保存された変更ログエントリーから自動的に生成されたり、それらの変更ログエントリーを自動的に生成するのに使われる場合もあります。複数の変更ログファイルがあり、それぞれが1つのディレクトリー、またはディレクトリーツリーに対応する場合もあります。

@menu
* Change Log Commands::      変更ログファイルを編集するためのコマンド。
* Format of ChangeLog::      変更ログファイルがどのように見えるか。
@end menu

@node Change Log Commands
@subsection 変更ログコマンド

@kindex C-x 4 a
@findex add-change-log-entry-other-window
  Emacsコマンド@kbd{C-x 4
a}は、編集しているファイルにたいする新しいエントリーを、変更ログファイルに追加します(@code{add-change-log-entry-other-window})。そのファイルが実際にはバックアップファイルの場合、このコマンドはそのファイルの元のファイルのエントリーを適切に作成します
--- これはカレントバージョンから削除された関数のログエントリーを作成するとき便利です。

  @kbd{C-x 4
a}は変更ログファイルをvisitして、一番最近のエントリーが今日の日付であなたの名前でない場合は、新しいエントリーを作成します。これはカレントファイルにたいする、新しいアイテムも作成します。このコマンドは多くの言語にたいして、変更された関数またはその他のオブジェクトを推測することすらできます。

@c Not worth it.
@c @vindex change-log-directory-files
変更ログファイルを探すために、Emacsは編集中ファイルのディレクトリーからディレクトリー構造を上方に検索します。デフォルトでは、バージョンコントロールディレクトリーのルートと思われるディレクトリーが見つかると、検索はストップします。これを変更するには、@code{change-log-directory-files}をカスタマイズしてください。

@vindex add-log-keep-changes-together
  変数@code{add-log-keep-changes-together}が非@code{nil}の場合、@kbd{C-x 4
a}は新しいアイテムを開始せず、そのファイルにたいする既存のアイテムに追加します。

同じ性質の複数の変更を1つにまとめることができます。最初の@kbd{C-x 4 a}の後にテキストを何も入力せずに、続けて@kbd{C-x 4
a}をタイプしていくと、他のシンボルが変更ログエントリーに追加されます。

@vindex add-log-always-start-new-record
  @code{add-log-always-start-new-record}が非@code{nil}の場合、最後のエントリーが同じ日付のあなたによる変更だったときでも、@kbd{C-x
4 a}は常に新しいエントリーを作成します。

@vindex change-log-version-info-enabled
@vindex change-log-version-number-regexp-list
@cindex file version in change log entries
  変数@code{change-log-version-info-enabled}の値が非@code{nil}の場合、@kbd{C-x 4
a}は、ファイルのバージョン番号を変更ログのエントリーに追加します。これは変数@code{change-log-version-number-regexp-list}の正規表現を使用して、ファイルの最初の10%から、バージョン番号を探します。

@cindex Change Log mode
@findex change-log-mode
  変更ログファイルは、Change
Logモードでvisitされます。このメジャーモードでは、グループ化されたアイテムの集まりは1つのパラグラフと扱われ。各エントリーはページとみなされます。これはエントリーの編集を容易にします。@kbd{C-j}およびauto-fillは、新しい行を前の行と同様にインデントします。これはエントリーの内容を入力するとき便利です。

@findex change-log-goto-source
  Change Logモードがオンのときには、ポイント近傍の変更ログエントリーのソース位置に移動するために、(デフォルトで@kbd{C-c
C-c}にバインドされている)
@code{change-log-goto-source}を使用できます。その後の@code{next-error}コマンド(デフォルトで@kbd{M-g
M-n}と@kbd{C-x
`}にバインドされている)は、変更ログ間のエントリーを移動します。次の変更ログエントリーだけではなく、変更されたファイルの実際のサイトにジャンプするでしょう。ヘンコウログエントリーも戻るために@code{previous-error}も使用できます。

@findex change-log-merge
  コマンド@kbd{M-x change-log-merge}を使用して、他のログファイルを、エントリーの日付順を保持したまま、Change
Logモードのバッファーにマージできます。

@vindex add-log-dont-create-changelog-file
  バージョンコントロールシステムはプログラム変更の追跡と変更ログを維持する別の手段です。VCSを使用する多くのプロジェクトは、今日ではバージョンごとの変更ログファイルを個別に保持しないので、そのようなファイルをレポジトリ内に保有することを避けたいと思うかもしれません。@code{add-log-dont-create-changelog-file}の値が非@code{nil}なら、@kbd{C-x
4 a}
(@code{add-change-log-entry-other-window})のようなコマンドは、すでにそのようなファイルが存在しなければファイルではなく適切に命名された一時バッファーに変更を記録します。

変更ログファイルかある場合や変更ログに一時バッファーを使用する場合のいずれにおいても、それらが存在すれば関連する変更ログエントリーを挿入するために、VC
Logバッファで@kbd{C-c C-a}
(@code{log-edit-insert-changelog})をタイプすることができます。@ref{Log Buffer}を参照してください。

@node Format of ChangeLog
@subsection ChangeLogの書式

  変更ログエントリーは、現在の日付、名前(変数@code{add-log-full-name}より取得)、電子メールアドレス(変数@code{add-log-mailing-address}より取得)を含むヘッダー行から開始されます。ヘッダー行を除いた変更ログの各行は、スペースまたはタブで開始されます。エントリーの大部分は、空白文字とアスタリスクで行が開始される、@dfn{アイテム(items)}から構成されます。以下は2つのアイテムおよび1つのアイテムをもつ、日付が1993年5月の、2つのエントリーの例です。

@iftex
@medbreak
@end iftex
@smallexample
1993-05-25  Richard Stallman  <rms@@gnu.org>

        * man.el: Rename symbols 'man-*' to 'Man-*'.
        (manual-entry): Make prompt string clearer.

        * simple.el (blink-matching-paren-distance):
        Change default to 12,000.

1993-05-24  Richard Stallman  <rms@@gnu.org>

        * vc.el (minor-mode-map-alist): Don't use it if it's void.
        (vc-cancel-version): Doc fix.
@end smallexample

  1つのエントリーで複数の変更を記述できます。変更はそれぞれアイテム、またはアイテムの中の行を占めます。アイテムの間には通常、空行があります。アイテムが関連している場合(異なる場所での同じ変更など)、それらの間に空行を置かずにそれらをグループ化します。

  変更ログファイルの最後には、著作権表示と使用許諾を配すべきです。以下は例です:

@smallexample
Copyright 1997, 1998 Free Software Foundation, Inc.
Copying and distribution of this file, with or without modification, are
permitted provided the copyright notice and this notice are preserved.
@end smallexample

@noindent
これはもちろん、正しい年と版権所有者に置き換えて使う必要があります。

@node Xref
@section 識別子のリファレンスを探す
@cindex xref

@cindex tag
  @dfn{識別子(identifier)}とは、プログラムの構文的なサブユニットの名前であり、関数(function)、サブルーチン(subroutine)、メソッド(method)、クラス(class)、データ型(data
type)、マクロ(macro)などが該当します。プログラミング言語では、識別子はその言語の構文をもつシンボルです。識別子は@dfn{タグ(tags)}という名前でも知られています。

プログラムの開発と保守では、プロジェクト全体を横断して識別子をリネームする等から、識別子がどこで定義されているか(defined)、どこから参照されているか(referenced)を素早く見つける能力が求められます。これらの能力は、プログラミング言語をサポートするよう定義されたモード以外のメジャーモードでも、リファレンスを見つけるために有用です。たとえばテキストや@TeX{}ドキュメントのチャプター(chapters)、セクション(sections)、アペンディクス(appendices)も同様にサブユニットとなり得るし、それらの名前も識別子として使用できます。このチャプターでは、プログラムのソース、同様に他の種類のテキストの中の、任意の種類のサブユニットの名前を正確に参照するために、``識別子(identifiers)''という用語を使用します。

これらの能力のために、Emacsは@samp{xref}と呼ばれる統一されたインターフェースを提供します。

@cindex xref backend
@code{xref}が処理を行なうには、そのメジャーモード特有の情報とメソッドを使用する必要があります。どのファイルから識別子を検索するか、識別子にたいするリファレンス(references:
参照)を探す方法、識別子を補完する方法、これら(およびそれ以上のこと)は、モード固有の知識です。@code{xref}は処理のモード固有な部分を、そのモードにより提供される@dfn{バックエンド(backend)}に委託します。これには、いくつかのコマンドにたいするデフォルトや、そのモード自体が提供しないモードにたいするデフォルトも含まれます。

バックエンドはこれらの能力をさまざまな方法で実装できます。いくつかの例を示します:

@enumerate a
@item
その言語のシンボルを探すために、ビルトインの方法を提供するモードがいくつかあります。たとえばEmacs
Lispのシンボルは、パッケージのロード履歴からの検索から識別され、Emacs
Lispインタープリターにより保守され、ビルトインのドキュメント文字列(built-in documentation
strings)で調べます。シンボル定義を探すために、Emacs
Lispモードは、モードのバックエンドの中の、これらの機能を使用します(この種のバックエンドの不利な点の1つは、インタープリターにロードされたサブユニットしか認識しないことです)。

@item
カレントバッファーのプロジェクト(@ref{Projects}を参照)とメジャーモードにたいしてEglotが有効なら、Eglotはプロジェクト内の識別子の定義について外部の言語サーバープログラムに照会を行い、そのサーバーから得たデータを提供します。@ref{Eglot
Features,,, eglot, Eglot: The Emacs LSP Client}を参照してください。

@item
外部プログラムは関連するファイルをスキャンしてリファレンスを抽出して、これらにたいするデータベースをビルドすることができます。リファレンスをリストしたり調べるために、バックエンドは必要なときにこのデータベースにアクセスできます。Emacsのディストリビューションには@command{etags}が含まれています。これはプログラム中の識別子の定義にタグ付けするコマンドで、リファレンスを@dfn{タグテーブル(tags
tables)}に抽出することにより、多くのプログラミング言語、およびHTMLのようなその他のモードをサポートします。@ref{Create Tags
Table}を参照してください。@command{etags}によりサポートされた言語にたいするメジャーモードは、そのバックエンドの基準でタグテーブルを使用できます(この種のバックエンドの不利な点の1つは、タグテーブルは有効性を維持するために最新である必要があり、度々リビルドしなければならないことです)。
@end enumerate

@menu
* Find Identifiers::         識別子のリスト等のために、識別子がどこで定義されているか、どこから参照されているかを探すコマンド。
* Tags Tables::              タグテーブルはシンボルがどのファイルで定義されているかを記録します。
* Select Tags Table::        特定のタグテーブルをvisitする方法。
@end menu

@node Find Identifiers
@subsection 識別子を探す

  このサブセクションでは識別子にたいするリファレンスを探したり、識別子にたいしてさまざまな問い合わせを行なうコマンドを説明します。リファレンスは識別子を@emph{定義(define)}するかもしれません(プログラム内のサブユニットを実装、ドキュメントのセクションのテキストなど)。あるいは識別子を@emph{使用(use)}するかもしれません(関数やメソッドの呼び出し、変数への値の割り当て、クロスリファレンスで引用されるチャプターなど)。

@menu
* Looking Up Identifiers::   識別子の定義を見つけるコマンド。
* Xref Commands::            @file{*xref*}バッファーでのコマンド。
* Identifier Search::        識別子の検索と置換。
* List Identifiers::         識別子をリストして、それらを補完する。
@end menu

@node Looking Up Identifiers
@subsubsection 識別子の照合
@cindex find definition of symbols
@cindex identifier, finding definition of
@cindex find references to symbols

  @code{xref}が可能にすることの中で一番重要なのは、指定した識別子の定義を探すことです。

@table @kbd
@item M-.@:
識別子の最初の定義を探します(@code{xref-find-definitions})。
@item C-M-. @var{pattern} @key{RET}
@var{pattern}にマッチする名前の識別子を探します(@code{xref-find-apropos})。
@item C-x 4 .@: @key{RET}
識別子の最初の定義を探して、他のウィンドウに表示します(@code{xref-find-definitions-other-window})。
@item C-x 5 .@: @key{RET}
識別子の定義を探して、それを新しいフレームに表示します(@code{xref-find-definitions-other-frame})。
@item M-x xref-find-definitions-at-mouse
マウスでクリックした識別子の最初の定義を探します。
@item M-,
前に@kbd{M-.}または同種のコマンドを呼び出した場所に戻ります(@code{xref-go-back})。
@item C-M-,
前に@kbd{M-.}または同種のコマンドを呼び出した場所に戻ります(@code{xref-go-forward})。
@item M-x xref-etags-mode
@code{etags}バックエンドを使用するように、@code{xref}を切り替えます。
@end table

@kindex M-.
@findex xref-find-definitions
@vindex xref-prompt-for-identifier
  @kbd{M-.}@:
(@code{xref-find-definitions})は、ポイント位置の識別子の定義を表示します。プレフィックス引数を与えた、またはポイント位置に識別子がない場合は、識別子の入力を求めます(常に識別子を尋ねるようにしたい場合は、@code{xref-prompt-for-identifier}を@code{t}にカスタマイズする)。

  @kbd{M-.}の引数に識別子を入力する際には、既知の識別子の名前を補完候補として通常のミニバッファーの補完コマンドを使用できます(@ref{Completion}を参照)。

@kindex C-x 4 .
@findex xref-find-definitions-other-window
@kindex C-x 5 .
@findex xref-find-definitions-other-frame
  バッファーを切り替えるほとんどのコマンドと同様に、@code{xref-find-definitions}は新しいバッファーを他のウィンドウ、または新しいバッファーのために新しいフレームを作成する変種をもっています。前者は@w{@kbd{C-x
4 .}} (@code{xref-find-definitions-other-window})、後者は@w{@kbd{C-x 5 .}}
(@code{xref-find-definitions-other-frame})です。

  コマンド@code{xref-find-definitions-at-mouse}は@code{xref-find-definitions}と同じように機能しますが、マウスイベントがあった箇所周辺の識別子を探します。このコマンドはたとえば@kbd{C-M-mouse-1}のようなマウスイベントにバインドされることを意図しています。

@kindex C-M-.
@findex xref-find-apropos
@vindex tags-apropos-additional-actions
  コマンド@kbd{C-M-.} (@code{xref-find-apropos})はtags用の@code{apropos}
(@ref{Apropos}を参照)のようなコマンドです。これは指定された@var{regexp}にマッチする名前の選択済みtagsテーブル内の識別子リストを表示します。これは@kbd{M-.}と似ていますが、シンボル名(固定文字列)ではなく識別子regexpマッチングを行う点が異なります。デフォルトでは@kbd{M-.}のように@file{*xref*}バッファーをポップアップしますが、変数@code{tags-apropos-additional-actions}をカスタマイズして追加の出力を表示できます。詳細はこの変数のドキュメントを参照してください。

@vindex xref-auto-jump-to-first-definition
  上記コマンドのいずれかがマッチする1つ以上の定義を見つけると、デフォルトではマッチ候補を表示する@file{*xref*}バッファーをポップアップして、そのバッファーのウィンドウを選択します(@kbd{C-M-.}は少なくともマッチを1つ見つけたら@emph{常に}@file{*xref*}バッファーをポップアップする)。候補はそれぞれ通常はファイル名とそのファイル内のマッチした識別子として、そのバッファーに表示されます。そのバッファーでは表示する任意の候補を選択でき、@ref{Xref
Commands}で説明する追加のコマンドもあります。ただし変数@code{xref-auto-jump-to-first-definition}の値が@code{move}なら、Emacsは@file{*xref*}バッファー内の最初の候補にポイントを移動するので、@key{RET}をタイプするだけでその候補の定義を表示できます。変数の値が@code{t}や@code{show}なら、最初の候補のウィンドウ自体に候補が自動的に表示されます。@code{show}では@file{*xfer*}バッファーのウィンドウは選択されたままですが、@code{t}の場合には更に最初の候補の定義を表示中のウィンドウの選択も行います。デフォルト値の@code{nil}では@file{*xref*}バッファーに候補を表示しますが、@file{*xref*}バッファーで候補を選択するまではどの候補も選択しないし候補定義も表示しません。

@findex next-error, in @file{*xref*} buffer
@findex previous-error, in @file{*xref*} buffer
@kindex M-g M-n, for navigation in @file{*xref*} buffer
@kindex M-g M-p, for navigation in @file{*xref*} buffer
  複数の候補を表示中に@file{*xref*}バッファーを表示しているウィンドウを切り替えた場合には、@w{@kbd{M-g M-n}}
(@code{next-error})と@w{@kbd{M-g M-p}}
(@code{previous-error})のコマンドを用いて候補から別の候補へと移動できます。@ref{Compilation
Mode}を参照してください。

@kindex M-,
@findex xref-go-back
  定義を@emph{表示した場所}に戻るには、@kbd{M-,}
(@code{xref-go-back})を使用します。これは最後に@kbd{M-.}を呼び出したポイントにジャンプします。したがって、@kbd{M-.}により何らかの定義を見つけて確認したら、@kbd{M-,}で戻ることができます。変数@code{xref-marker-ring-length}で決定される深さ(デフォルトは16)まで、@kbd{M-,}を用いてステップを再トレースすることができます。@kbd{M-,}を使えばあなたが辿ってきた場所の履歴を逐一再トレースすることによって最初に@kbd{M-.}を呼び出した場所、あるいはそこに至るまでの任意の場所まで遡ることができます。

@kindex C-M-,
@findex xref-go-forward
  @kbd{M-,}で戻りすぎてしまったり、あるいは戻った場所から再検証したい場合には、再度履歴を進むために@kbd{C-M-,}
(@code{xref-go-forward})を使うことができます。これは@kbd{M-.}と似ていますが、定義を調べたい識別子にいちいちポイントを移動する必要はありません。@kbd{C-M-,}を使えばあなたが遡ってきた場所の履歴を逐一再トレースすることによって履歴の最後の場所、あるいはそこに至るまでの任意の場所まで辿ることができます。

@findex xref-etags-mode
  いくつかのメジャーモードは、特定の識別子の検索に失敗するかもしれない@code{xref}サポート機能をインストールするかもしれません。たとえば、Emacs
Lispモード(@ref{Lisp
Eval}を参照)では、デフォルトでは@kbd{M-.}はカレントEmacsセッションにロードされた、あるいは自動ロード(@ref{Autoload,,,
elisp, The Emacs Lisp Reference
Manual}を参照)されるLispパッケージの関数と変数だけを検索します。@kbd{M-.}が何らかの識別子の検索に失敗する場合は、@code{xref}に@code{etags}バックエンド(@ref{Xref}を参照)の使用を強制することができます。これを行うには、@w{@kbd{M-x
xref-etags-mode}}を呼び出してXref
Etagsマイナーモードをオンに切り替えて、再度@kbd{M-.}を呼び出します(これが機能するためには、ソースファイルのディレクトリーツリー内でtagテーブルを作成するために、必ず@command{etags}を実行すること。@ref{Create
Tags Table}を参照されたい)。

@node Xref Commands
@subsubsection @file{*xref*}バッファーで利用可能なコマンド
@cindex commands in @file{*xref*} buffers
@cindex XREF mode

  以下のコマンドは@file{*xref*}バッファーのXREFモードにより提供されるコマンドです:

@table @kbd
@item @key{RET}
@itemx mouse-1
カレント行のリファレンスを表示します(@code{xref-goto-xref})。プレフィックス引数を指定すると@file{*xref*}バッファーも隠し(bury)ます。

@item mouse-2
@findex xref-select-and-show-xref
@code{mouse-1}と同様ですが@file{*xref*}を表示中のウィンドウを選択されたウィンドウにします(@code{xref-select-and-show-xref})。

@item n
@itemx .
@findex xref-next-line
次のリファレンスに移動して、それを別のウィンドウに表示します(@code{xref-next-line})。

@item N
@findex xref-next-group
次のリファレンスグループの最初のリファレンスに移動して、別ウィンドウに表示します(@code{xref-next-line})。

@item p
@itemx ,
@findex xref-prev-line
前のリファレンスに移動して、それを別のウィンドウに表示します(@code{xref-prev-line})。

@item P
@findex xref-prev-group
前のリファレンスグループの最初のリファレンスに移動して別ウィンドウに表示します(@code{xref-prev-line})。

@item C-o
@findex xref-show-location-at-point
カレント行のリファレンスを別のウィンドウに表示します(@code{xref-show-location-at-point})。

@item r @var{pattern} @key{RET} @var{replacement} @key{RET}
@var{pattern}にマッチするリファレンスにたいしてインタラクティブな問い合わせつき置換(query-replace)を行ない、マッチを@var{replacement}に置換します。このコマンドは関係のあるすべてのファイルにおける識別子への全マッチを表示している@file{*xref*}バッファーでのみ使用できます。@ref{Identifier
Search}を参照してください。

@item g
@findex xref-revert-buffer
@file{*xref*}バッファーのコンテンツをリフレッシュします(@code{xref-revert-buffer})。

@item M-,
@findex xref-quit-and-pop-marker-stack
@file{*xref*}バッファーを表示しているウィンドウをquitして、Xrefの前のスタック位置にジャンプします(@code{xref-quit-and-pop-marker-stack})。

@item q
@findex xref-quit
@file{*xref*}バッファーを表示しているウィンドウをquitします(@code{xref-quit})。
@end table

これらに加えて、リファレンスを表示せずにバッファー内を移動するために、@kbd{C-n}や@kbd{C-p}のような、通常のナビゲーションコマンドも利用可能です。

@node Identifier Search
@subsubsection 識別子の検索と置換
@cindex search and replace in multiple source files
@cindex multiple source file search and replace

  このセクションのコマンドは、識別子自身、またはファイル内の識別子にたいするリファレンスにたいして、様々な検索と置換を行ないます。

@table @kbd
@item M-?
ポイント位置の識別子にたいする、すべてのリファレンスを探します。

@item r
@itemx M-x xref-query-replace-in-results @key{RET} @var{replacement} @key{RET}
@itemx C-u M-x xref-query-replace-in-results @key{RET} @var{regexp} @key{RET} @var{replacement} @key{RET}
@file{*xref*}バッファーに表示されているすべての識別子の名前にたいして、@var{regexp}を@var{replacement}にインタラクティブに置換します。

@item M-x xref-find-references-and-replace @key{RET} @var{from} @key{RET} @var{to} @key{RET}
識別子@var{from}のすべてのインスタンスを、新たな名前@var{to}にインタラクティブにリネームします。

@item M-x tags-search @key{RET} @var{regexp} @key{RET}
選択されたタグテーブルのファイルから、@var{regexp}を検索します。

@item M-x tags-query-replace @key{RET} @var{regexp} @key{RET} @var{replacement} @key{RET}
選択されたタグテーブルの各ファイルにたいして、@code{query-replace-regexp}を実行します。

@item M-x fileloop-continue
ポイントのカレント位置から、上記コマンドの最後の2つを再開します。
@end table

@kindex M-?
@findex xref-find-references
  @kbd{M-?}は、ポイント位置の識別子にたいして、必要に応じて補完つきで識別子の入力を促しつつ、すべてのリファレンスを探します。カレントのバックエンド(@ref{Xref}を参照)に依存して、ポイント位置に有効な識別子を見つけた場合でも、このコマンドは識別子の入力を促すかもしれません。プレフィクス引数が指定された場合、このコマンドは常に識別子の入力を求めます(常に入力を求めるようにしたい場合は@code{xref-prompt-for-identifier}を@code{t}、ポイント位置に利用できる識別子がない場合のみ入力を求めるようにするには@code{nil}にカスタマイズすればよい)。それからこのコマンドは、その識別子にたいするすべてのリファレンスについて、ファイル名と識別子が参照されている行を、@file{*xref*}バッファーに表示します。このバッファーではXREFモードのコマンドが利用可能です。@ref{Xref
Commands}を参照してください。

@vindex xref-auto-jump-to-first-xref
  変数@code{xref-auto-jump-to-first-xref}の値が@code{t}なら、@code{xref-find-references}は@file{*xref*}バッファーの最初の結果に自動的にジャンプして、そのリファレンスを表示するウィンドウを選択します。@w{@kbd{M-g
M-n}} (@code{next-error})や@w{@kbd{M-g M-p}}
(@code{previous-error})で他の結果を選択することもできます(@ref{Compilation
Mode}を参照)。値が@code{show}なら最初の結果を表示しますが、@file{*xref*}バッファーを表示するウィンドウが選択されたままになります。値が@code{move}なら@file{*xref*}バッファーで最初の結果を選択しますが表示はしません。@key{RET}を用いることによってそのリファレンスを実際に表示できます。デフォルト値の@code{nil}では@file{*xref*}バッファーに結果を表示するだけで、結果を何も選択しないし結果のリファレンスも表示しません。

@findex xref-query-replace-in-results
  @kbd{r} (@code{xref-query-replace-in-results})は通常の@kbd{M-x
query-replace-regexp}のように、@var{replacement}文字列を読み取ります。そして@file{*xref*}バッファーに表示されたその識別子を参照するすべてのファイル、すべての箇所において、その識別子を新たな名前@var{replacement}に置き換えます。これはリファクタリングの一環として識別子の名称を変更する際に役に立つでしょう。このコマンドは@kbd{M-?}で生成された@file{*xref*}バッファーで呼び出す必要があります。このコマンドはデフォルトでは識別子の名前全体を@var{replacement}で置き換えますが、プレフィックス引数とともに呼び出した場合には識別子の名前にマッチさせるregexpの入力を求めて、識別子の名称からregexpにマッチした部分だけを@var{replacement}で置き換えます。

@findex xref-find-references-and-replace
  @kbd{M-x
xref-find-references-and-replace}は@code{xref-query-replace-in-results}と似ていますが、これは名前@var{from}で指定される単一の識別子をリネームしたい場合に特に便利なコマンドです。

@findex tags-search
  @kbd{M-x
tags-search}は、ミニバッファーを使用してregexpを読み取り、選択されたタグテーブルのすべてのファイルから、1ファイルずつマッチを検索します。これは検索しているファイル名を表示するので、進行状況を確認することができます。マッチが見つかった場合、@code{tags-search}はリターンします。このコマンドには利用可能なタグテーブル(@ref{Tags
Tables}を参照してください)が必要です。

@findex fileloop-continue
  @code{tags-search}で1つのマッチが見つかったら、おそらく残りのすべてについても検索したいと思うでしょう。@kbd{M-x
fileloop-continue}は、多くのマッチを探すために@code{tags-search}を再開します。これはカレントバッファーの残りの部分を検索して、その後タグテーブルの残りのファイルを検索します。

@findex tags-query-replace
  @kbd{M-x
tags-query-replace}は、タグテーブルのすべてのファイルにたいして、1つの@code{query-replace-regexp}を実行します。これは、通常の@kbd{M-x
query-replace-regexp}と同様、検索するregexpと、それを置換する文字列を読み取ります。この検索はむしろ@kbd{M-x
tags-search}に似ていますが、入力へのマッチを繰り返し処理します。問い合わせ付き置換については、@ref{Query
Replace}を参照してください。

@vindex tags-case-fold-search
@cindex case-sensitivity and tags search
  変数@code{tags-case-fold-search}の値をカスタマイズすることにより、タグ検索コマンドの大文字小文字の扱いを制御できます。デフォルトには、@code{case-fold-search}の値と同じ設定が使用されます(@ref{Lax
Search}を参照してください)。

  1回の@kbd{M-x
tags-query-replace}の呼び出しで、タグテーブルのすべてのファイルを検索することが可能です。しかし、一時的に検索を抜けられると便利なときもあります。これは、問い合わせ付き置換として特別な意味をもたない入力イベントで行うことができます。つづけて問い合わせ付き置換を再開するには、@kbd{M-x
fileloop-continue}とタイプします。このコマンドは、最後のタグ検索または置換コマンドを再開します。たとえばカレントファイルの残りをスキップするには、@w{@kbd{M->
M-x fileloop-continue}}とタイプします。

  上記で説明したコマンドは、@code{xref-find-definitions}系の検索より広範な検索を行うことに注意してください。@code{xref-find-definitions}コマンドは、部分文字列または正規表現にマッチする識別子の定義だけを検索します。コマンド@code{xref-find-references}、@code{tags-search}、@code{tags-query-replace}は、通常の検索および置換コマンドがカレントバッファーにたいして行うように、識別子またはregexpにたいするマッチを検索します。

  @code{xref-find-references}や@code{tags-search}のかわりに、サブプロセスとして@command{grep}を実行して、Emacsにマッチした行を1つずつ表示させることができます。@ref{Grep
Searching}を参照してください。

@node List Identifiers
@subsubsection 識別子の照会

@table @kbd
@item C-M-i
@itemx M-@key{TAB}
タグテーブルがロードされているときは、できるだけ選択されたタグテーブルを使って、ポイント周囲のテキストの置換を行います(@code{completion-at-point})。

@item M-x list-tags @key{RET} @var{file} @key{RET}
プログラムファイル@var{file}で定義されている識別子のリストを表示します。

@item C-M-. @var{regexp} @key{RET}
@var{regexp}にマッチする、すべての識別子のリストを表示します(@code{xref-find-apropos})。@ref{Looking
Up Identifiers}を参照してください。

@item M-x tags-next-file
選択されたタグテーブルに記録されているファイルをvisitします。
@end table

  プログラミング言語のモードのほとんどでは、@kbd{C-M-i}または@kbd{M-@key{TAB}}
(@code{completion-at-point})とタイプして、ポイント位置のシンボルを補完できます。このコマンドのために、モードに特化した補完候補を提供するモードもあります。補完候補を提供しないモードでは、選択されたタグテーブルがある場合、補完候補を生成するためにこのコマンドを使用することができます。@ref{Symbol
Completion}を参照してください。

@findex list-tags
  @kbd{M-x
list-tags}は、選択されたタグテーブルでカバーされたファイルの名前を1つ読み取り、そのファイルで定義されたタグのリストを表示します。タグテーブルに記録されたファイル名にディレクトリーが含まれない場合は、ファイル名にディレクトリーを含めないでください。このコマンドはバックエンドがetagsのときだけ機能し、そのプロジェクトのために利用可能なタグテーブルが必要です。@ref{Tags
Tables}を参照してください。インタラクティブに使用すると、カレントバッファーのファイル名がデフォルトタグとして使用されます。

@findex tags-next-file
  @kbd{M-x
tags-next-file}は、選択されたタグテーブルでカバーされるファイルをvisitします。最初に呼び出したとき、テーブルでカバーされた最初のファイルをvisitします。続けて呼び出すことにより、次のカバーされたファイルをvisitしていきます。プレフィクス引数を指定した場合、最初のファイルに戻ります。このコマンドには、選択されたタグテーブルが必要です。

@node Tags Tables
@subsection tagsテーブル
@cindex tags and tag tables

  @dfn{タグテーブル(tags
table)}は、特定のプログラムまたはドキュメントのソースコードをスキャンすることにより抽出されたタグ@footnote{@dfn{tag}は、識別子リファレンスの同義語です。@code{etags}パッケージにもとづいたコマンドおよび機能では、伝統的に``tag''という用語をこの意味に使用します。以下のサブセクションでは、この伝統にしたがいます。}を記録します。生成されたファイルから抽出されたタグは、タグ抽出の際にスキャンされる生成されたファイルではなく、その元になるファイルを参照します。生成されたファイルの例として、Cwebソース、Yaccパーサー、Lexスキャナー定義から生成されたCファイルや、プリプロセスされたCファイルの@file{.i}、@file{.fpp}ソースファイルをプリプロセスすることにより生成されるFortranファイルがあります。

@cindex etags
  タグテーブルを生成するには、ドキュメントまたはソースコードファイルにたいして、シェルコマンド@command{etags}を実行します。@samp{etags}プログラムは、@dfn{タグテーブルファイル(tags
table file)}、または略記して@dfn{タグファイル(tags
file)}にタグを書き込みます。タグファイルは慣習的に@file{TAGS}という名前です。@ref{Create Tags
Table}を参照してください(同じフォーマットでこのようなテーブルを生成できる他のコマンドを使用して、タグテーブルを作成することも可能です)。

  Emacsは、@code{xref}にたいするサポートされたバックエンドとして、@code{etags}パッケージを通じてタグテーブルを使用します。タグテーブルはEmacsディストリビューションの一部である@command{etags}コマンドにより生成されるので、ここではタグテーブルについて、より詳細に説明します。

@cindex C++ class browser, tags
@cindex tags, C++
@cindex class browser, C++
@cindex Ebrowse
  Ebrowse機能は@command{etags}に似ていますが、C++に特化したものです。@ref{Top,, Ebrowse, ebrowse,
Ebrowse User's Manual}を参照してください。
Semanticパッケージは、@command{etags}機能とは別の、タグを生成して使用する他の方法を提供します。@ref{Semantic}を参照してください。

@menu
* Tag Syntax::               さまざまなタイプのコードおよびテキストファイルにたいするタグ構文。
* Create Tags Table::        @command{etags}によるタグテーブルの作成。
* Etags Regexps::            正規表現を使用した任意タグの作成。
@end menu

@node Tag Syntax
@subsubsection ソースファイルタグの構文

  以下は、もっともポピュラーな言語でタグ構文が定義される方法です:

@itemize @bullet
@item
Cコードでは、Cの関数やtypedefはタグなので、@code{struct}、@code{union}、@code{enum}の定義もタグです。タグテーブルを作成するとき、@samp{--no-defines}を指定しなければ、@code{#define}マクロ定義、@code{#undef}および@code{enum}定数もタグになります。同様に、@samp{--no-globals}を指定しなければグローバル変数もタグで、@samp{--no-members}を指定していなければ構造体のメンバーもタグです。@samp{--no-globals}、@samp{--no-defines}、@samp{--no-members}を使用することにより、タグテーブルを小さくすることができます。

@command{etags}に@samp{--declarations}オプションを与えることにより、関数定義(function
definitions)に加えて、関数宣言(function declarations)と外部変数(external
variables)もタグ付けできます。

@item
C++コードでは、Cコードのすべてのタグ構成に加えて、メンバー関数も認識されます。@samp{--no-members}オプションを使用しなければ、メンバー変数も認識されます。@code{operator}定義は、@samp{operator+}のような名前をもちます。@samp{--class-qualify}オプションを指定した場合、クラスの変数および関数にたいするタグは、@samp{@var{class}::@var{variable}}および@samp{@var{class}::@var{function}}という名前になります。デフォルトでは、クラスのメソッドとメンバーはクラス修飾されていません。これにより、ソース内でより正確に、それらの名前が識別可能になります。

@item
Javaコードでは、C++で認識されるのすべてのタグ構成に加えて、@code{interface}、@code{extends}、@code{implements}もタグとして認識されます。クラスの変数および関数にたいするタグは、@samp{@var{class}.@var{variable}}および@samp{@var{class}.@var{function}}という名前になります。

@item
@LaTeX{}ドキュメントでは、@code{\chapter}、@code{\section}、@code{\subsection}、@code{\subsubsection}、@code{\eqno}、@code{\label}、@code{\ref}、@code{\cite}、@code{\bibitem}、@code{\part}、@code{\appendix}、@code{\entry}、@code{\index}、@code{\def}、@code{\newcommand}、@code{\renewcommand}、@code{\newenvironment}、@code{\renewenvironment}にたいする引数がタグになります。

@command{etags}を呼び出す前に、環境変数@env{TEXTAGS}で指定することにより、他のコマンドも同様にタグにできます。この環境変数の値には、コロンで区切られたコマンド名のリストを指定します。たとえば、

@example
TEXTAGS="mycommand:myothercommand"
export TEXTAGS
@end example

@noindent
これは、(Bourneシェルの構文の使用して)コマンド@samp{\mycommand}と@samp{\myothercommand}もタグとして定義します。

@item
Lispコードでは、@code{defun}で定義された任意の関数、@code{defvar}および@code{defconst}で定義された任意の変数、および一般的に列0から@samp{(def}で始まる任意の式の最初の引数はタグです。例外として@code{(defvar
@var{foo})}という形式の式は、宣言として扱われ、@samp{--declarations}オプションが与えられたときだけタグになります。

@item
Schemeコードでは、@code{def}で定義されたすべて、または名前が@samp{def}で始まる構成がタグに含まれます。これらは、ファイルのトップレベルで@code{set!}でセットされる変数も含まれます。
@end itemize

  他の言語もいくつかサポートされます:

@itemize @bullet

@item
Adaコードでは、関数(functions)、プロシージャー(procedures)、パッケージ(packages)、タスク(tasks)、タイプ(types)がタグです。@samp{--packages-only}オプションを使用することにより、タグをパッケージにたいしてだけ作成できます。

Adaでは、異なる種類のエンティティー(たとえば関数とプロシージャー)に、同じ名前を使うことができます。またパッケージ、プロシージャー、関数と似たものに、スペック(spec、たとえばinterface)およびボディー(body、たとえばimplementation)があります。欲しい定義を簡単に取り出すために、Adaのタグ名にはエンティティーのタイプを示す接尾辞がつきます:

@table @samp
@item /b
パッケージのボディー(package body)。
@item /f
関数(function)
@item /k
タスク(task)。
@item /p
プロシージャー(procedure)。
@item /s
パッケージのスペック(package spec)。
@item /t
タイプ(type)。
@end table

  したがって、@kbd{M-x find-tag @key{RET} bidule
@key{RET}}は単に@code{bidule}という任意のタグを検索しますが、@kbd{M-x find-tag @key{RET}
bidule/b @key{RET}}は直接パッケージ@code{bidule}のボディーに移動します。

@item
アセンブラーコードでは、行の開始に現れ、後にコロンが続くラベルがタグです。

@item
BisonまたはYaccの入力ファイルでは、各構文規則で定義する非終端記号がタグです。ファイル内に含まれるCコードの部分は、Cコードとして解析します。

@item
Cobolコードでは、タグはパラグラフ名なので、列8から始まり、後にピリオドが続く任意の単語がタグです。

@item
Erlangコードでは、ファイルで定義された関数(functions)、レコード(records)、マクロ(macros)がタグです。

@item
Fortranコードでは、サブルーチン(subroutines)およびブロックデータ(block data)がタグです。

@item
Goコードでは、関数(functions)、タイプ(types)がタグです。

@item
HTML入力ファイルでは、@code{title}、および@code{h1}、@code{h2}、@code{h3}ヘッダーがタグです。アンカー内の@code{name=}、およびすべての@code{id=}もタグです。

@item
Lua入力ファイルでは、すべての関数(functions)がタグです。

@item
makefileでは、ターゲット(targets)がタグで、@samp{--no-globals}を指定しなければ変数(variables)もタグです。

@item
Objective Cコードでは、クラスにたいするObjective C定義、クラスカテゴリー(class
categories)、メソッド(methods)、プロトコル(protocols)が含まれます。クラスの変数および関数にたいするタグの名前は、@samp{@var{class}::@var{variable}}および@samp{@var{class}::@var{function}}になります。

@item
Pascalコードでは、ファイル内で定義された関数およびプロシージャーがタグです。

@item
Perlコードでは、パッケージ、サブルーチン、変数がタグで、キーワード@code{package}、@code{sub}、@code{use
constant}、@code{my}、@code{local}で定義されます。グローバル変数をタグ付けしたい場合、@samp{--globals}を使用します。サブルーチンにたいするタグの名前は、@samp{@var{package}::@var{sub}}になります。デフォルトのパッケージで定義されたサブルーチンの名前は、@samp{main::@var{sub}}になります。

@item
PHPコードでは、関数(functions)、クラス(classes)、定義(defines)がタグです。@samp{--no-members}オプションを使用しなければ、変数(vars)もタグです。

@item
PostScriptコードでは、関数がタグです。

@item
Prologコードでは、行頭の述語(predicates)とルール(rules)がタグです。

@item
Pythonコードでは、行頭の@code{def}および@code{class}はタグを生成します。

@item
Rubyコードでは、行の先頭にある@code{def}、@code{class}、@code{module}はタグを生成します。定数もタグを生成します。

@item
Rustコードでは@code{fn}、@code{enum}、@code{struct}、@code{macro_rules!}で定義されているものはすべてタグです。
@end itemize

  他の書式や言語を扱うために、regexpにたいするマッチにもとづいてタグを生成することもできます(@ref{Etags
Regexps}を参照してください)。

@node Create Tags Table
@subsubsection タグテーブルの作成
@cindex @command{etags} program

  @command{etags}プログラムは、タグテーブルファイルを作成するために使用されます。このコマンドは、
@iftex
前のセクションで説明している複数の構文を理解します。
@end iftex
@ifnottex
@ref{Tag Syntax}で説明している複数の構文を理解します。
@end ifnottex
以下は@command{etags}を実行する方法です:

@example
etags @var{inputfiles}@dots{}
@end example

@noindent
@command{etags}プログラムは、指定されたファイルを読み込んで、カレント作業ディレクトリーの@file{TAGS}という名前のファイルに、タグテーブルを書き込みます。@samp{--output=@var{file}}オプションを使用して、タグテーブルに異なる名前のファイル名を指定することもできます。ファイル名に@file{-}を指定すると、タグテーブルを標準出力に出力します。@samp{--append}オプションを使用して、既存のファイルに新たに作成したtagテーブルを追加することもできます。

  指定されたファイルが見つからない場合、@command{etags}はそれらの圧縮されたバージョンを探して、それらを解凍して読み込みます。MS-DOSでは、コマンドラインに@samp{mycode.c}が与えられ、@samp{mycode.c}が存在しないとき、@command{etags}は@file{mycode.cgz}のような名前のファイルを探します。

  ファイルの内容が変更されてタグテーブルが古くなったときは、@command{etags}を再び実行することにより、タグテーブルを更新できます。タグテーブルにタグが記録されていなかったり、間違ったファイルにたいして記録している場合、タグテーブルを更新するまで、Emacsはそれの定義を見つけることができません。しかしタグに記録されている位置が、(編集により)少し間違っているようなときは、少しの遅れは生じますがEmacsは正しい位置を見つけることができます。

   したがって、編集するたびにタグテーブルを更新する必要はありません。リストしたい新しいタグを定義したときや、タグ定義をあるファイルから他のファイルへ移動したとき、または大幅な変更を施したときは、タグテーブルを更新するべきです。

  @command{etags}に@samp{--include=@var{file}}オプションを渡すことにより、タグテーブルに他のタグテーブルを@dfn{インクルード(include)}できます。これによりインクルードされたタグファイルでカバーされる、すべてのファイルをカバーできます。

  @command{etags}を実行するとき、ソースファイルを相対ファイル名で指定した場合、タグファイルには、そのタグファイルが最初に書き込まれたディレクトリーにたいする相対ファイル名が含まれます。この方法を使えば、ディレクトリーツリー全体を移動しても、タグファイルは正しくソースファイルを参照します。しかしタグファイルが@file{-}または@file{/dev}のときは、ファイル名はカレント作業ディレクトリーにたいする相対ファイル名になります。これはタグを標準出力に書き込むときに便利です。

  相対ファイル名を使う場合、違うディレクトリーにあるタグファイルを指すシンボリックリンクを指定するべきではありません。なぜならこれは一般的にファイル名を無効にするからです。

  @command{etags}の引数に絶対ファイル名を指定した場合、タグファイルには絶対ファイル名が含まれます。この方法では、ソースファイルが同じ場所にある限り、タグファイルを移動してもタグファイルは同じ名前を参照します。絶対ファイル名は@samp{/}で開始されるか、MS-DOSおよびMS-Windowsでは@samp{@var{device}:/}で開始されます。

   非常に大きな数のファイルからタグテーブルを作成したい場合、それをコマンドラインに指定すると問題が発生するかもしれません。なぜならコマンドライン引数の長さに制限のあるシステムもあるからです。この制限は、以下のようにファイル名の場所にダッシュを指定して、@command{etags}にファイル名を標準入力から読み込むように指示して回避することができます。

@smallexample
find . -name "*.[chCH]" -print | etags -
@end smallexample

  @command{etags}はファイル名とファイル内容にもとづいて、入力ファイルで使用されている言語を認識します。これは最初に、特定の言語にたいして一般的に使用されるファイル名と拡張子にたいするマッチを試みます。いくつかの言語には、既知の名前のインタープリター(Perlの@command{perl}、Prologの@command{pl}など)があるので、@command{etags}は次に入力ファイルの最初の行でインタープリター指定@samp{#!@var{interp}}を調べて、既知のインタープリターとのマッチを行います。これが失敗、または言語の自動検知をオーバーライドしたい場合は、@samp{--language=@var{name}}オプションで、明示的に言語を指定できます。このオプションはファイル名に混ぜることができます。各指定はその後に続くファイル名に適用されます。@samp{--language=auto}の指定は、ファイル名とファイル内容から言語を推測するよう@command{etags}に指示します。@samp{--language=none}を指定すると、言語に特有の処理を完全にオフに切り替えます。この場合、@command{etags}はregexpのマッチングだけでタグを認識します(@ref{Etags
Regexps}を参照してください)。これは、@command{etags}がまだサポートしていない言語を使用するファイルが入力の際に、@command{etags}がデフォルト言語としてFortranおよびCにフォールバックするのを抑止します。

  オプション@samp{--parse-stdin=@var{file}}は、@command{etags}をプログラムから呼び出すときに便利です。これは、(1回だけ)コマンドラインからファイル名を読み取るとき使用できます。@command{etags}は標準入力から読み取り、生成されたタグがファイル@var{file}に属するとマークします。

  GNUコーディング規約を遵守しないソースファイルにおいて、関数や@code{struct}定義のようなトップレベルの定義だけに許されている列0の大カッコ(@samp{@{}および@samp{@}})が存在するようなら、@command{etags}が列0にある閉じ大カッコを誤って解釈することを防ぐためにオプション@samp{--ignore-indentation}を使うことをお勧めします。

  @samp{etags
--help}オプションは@command{etags}が認識する言語と、言語を推測するためのファイル名ルールのリストを出力します。これは利用可能な@command{etags}オプションと、簡単な説明のリストも出力します。このオプションの後に、1つ以上の@samp{--language=@var{lang}}を指定すると、@var{lang}にたいするタグの生成方法の詳細を出力します。

@node Etags Regexps
@subsubsection etagsのregexp

  @samp{--regex}オプションは、正規表現のマッチにもとづいて@command{etags}がタグを認識できるようにします。このオプションはファイル名と混ぜることができます。オプションは、それぞれのオプション後に続くソースファイルに適用されます。複数の@samp{--regex}を指定した場合、それらすべては並列に使用されます。構文は以下のとおりです:

@smallexample
--regex=[@var{@{language@}}]/@var{tagregexp}/[@var{nameregexp}/]@var{modifiers}
@end smallexample

@noindent
オプション値の肝心な部分は@var{tagregexp}で、これはタグにマッチするregexpです。これは常に位置が固定されており、行の開始だけにマッチします。インデントされたタグの場合、最初の空白文字にマッチさせるために、@samp{[
\t]*}で始まるregexpを使用します。

  これらの正規表現では、@samp{\}は次の文字をクォートします。またCのエスケープ文字シーケンスのすべて、すなわち@samp{\a}(bell)、@samp{\b}(back
space)、@samp{\e}(escape)、@samp{\f}(formfeed)、@samp{\n}(newline)、@samp{\r}(carriage
return)、@samp{\t}(tab)、and @samp{\v}(vertical
tab)がサポートされます。これらに加えて、@samp{\\d}は@code{DEL}文字を意味します。

  理想的には、@var{tagregexp}はタグとして認識させるのに必要な文字以上にマッチさせるべきではありません。構文がそれを求める場合、タグより多くの文字にマッチする@var{tagregexp}を記述して、そのマッチからタグだけをピックアップするために、@var{nameregexp}を追加するべきです。これはEmacsがより正しくタグを見つけて、タグ名の補完をより確実にすることを可能にします。@var{nameregexp}内においてはこれは、@var{tagregexp}内でのカッコによるグループ化にたいする``後方参照(back
references)'' (@ref{Regexp
Backslash}を参照)として有用であり、頻繁に使用されます。たとえば、@samp{\\1}はそのようなカッコによる最初のグループを参照します。以下でいくつかの例を見つけることができるでしょう。

  @var{modifiers}(修飾子)は、@command{etags}がマッチングを行う方法を変更するための0文字以上の文字シーケンスです。修飾子がないregexpは、大文字小文字を区別する方法で、入力ファイルの各行にたいして順番に適用されます。修飾子とその意味は以下のとおりです:

@table @samp
@item i
このregexpのマッチングで、大文字小文字を無視します。
@item m
この正規表現はファイル全体にマッチするので、複数行のマッチが可能です。
@item s
この正規表現はファイル全体にマッチし、@var{tagregexp}内の@samp{.}は改行にマッチします。
@end table

  @samp{-R}オプションは、それの前に@samp{--regex}で定義されたregexpをすべて取り消します。これは後に続くファイル名にも適用されます。以下は例です:

@smallexample
etags --regex=/@var{reg1}/i voo.doo --regex=/@var{reg2}/m \
    bar.ber -R --lang=lisp los.er
@end smallexample

@noindent
この例では、@command{etags}は@file{voo.doo}と@file{bar.ber}にたいして。ファイル内容に一致する解析用の言語を選択します。@command{etags}は、@file{voo.doo}内の追加のタグを認識するために@var{reg1}も使用し、@file{bar.ber}内の追加のタグを認識するために@var{reg1}と@var{reg2}の両方を使用します。@file{voo.doo}と@file{bar.ber}の各行にたいして大文字小文字を区別せずに@var{reg1}がチェックされ、@file{bar.ber}のファイル全体にたいして大文字小文字を区別して@var{reg2}がチェックされ、これは複数行へのマッチが許されます。@file{los.er}のタグの認識にはユーザー指定のregexpマッチは行わず、Lispのタグルールだけが使用されます。

  オプションのプレフィクス@var{@{language@}}を使用して、与えられた言語だけに@samp{--regex}オプションを制限できます(@samp{etags
--help}で@command{etags}が認識する言語のリストが表示されます)。これはファイルに、@command{etags}にたいして事前に定義された多くの正規表現が含まれている場合に便利です。以下の例は、EmacsのC言語のソースファイルの@code{DEFVAR}マクロにたいするタグです:

@smallexample
--regex='@{c@}/[ \t]*DEFVAR_[A-Z_ \t(]+"\([^"]+\)"/\1/'
@end smallexample

@noindent
正規表現が複雑な場合、そのリストをファイルに保存することができます。以下のオプション構文は、@command{etags}に正規表現が保存された2つのファイルを指示します。2つ目のファイルに含まれる正規表現は、大文字小文字を区別せずにマッチします。

@smallexample
--regex=@@@var{case-sensitive-file} --ignore-case-regex=@@@var{ignore-case-file}
@end smallexample

@noindent
@command{etags}にたいするregexファイルは、行ごとに1つの正規表現を含みます。空行およびスペースかタブで始まる行は無視されます。表の開始が@samp{@@}の場合、@command{etags}はその行の残りを他の正規表現ファイルとみなすので、そのようなファイルを他のファイルをインクルードできます。他のすべての行は正規表現です。最初の非空白文字が@samp{--}の場合、その行はコメントです。

  たとえば、以下の内容の@samp{emacs.tags}という名前のファイルを作成できます:

@smallexample
        -- This is for GNU Emacs C source files
@{c@}/[ \t]*DEFVAR_[A-Z_ \t(]+"\([^"]+\)"/\1/
@end smallexample

@noindent
これは以下のように使用します:

@smallexample
etags --regex=@@emacs.tags *.[ch] */*.[ch]
@end smallexample

  さらに例を示しましょう。regexpはシェルから解釈され内容にクォートされています。

@itemize @bullet

@item
Octaveファイルのタグ:

@smallexample
etags --language=none \
      --regex='/[ \t]*function.*=[ \t]*\([^ \t]*\)[ \t]*(/\1/' \
      --regex='/###key \(.*\)/\1/' \
      --regex='/[ \t]*global[ \t].*/' \
      *.m
@end smallexample

@noindent
タグはスクリプトにたいして生成されるので、そのスクリプトにジャンプしたいときは、あなた自身で@samp{###key
@var{scriptname}}という形式の行を追加する必要があることに注意してください。

@item
Tclファイルのタグ:

@smallexample
etags --language=none --regex='/proc[ \t]+\([^ \t]+\)/\1/' *.tcl
@end smallexample

@item
VHDLファイルのタグ:

@smallexample
etags --language=none \
  --regex='/[ \t]*\(ARCHITECTURE\|CONFIGURATION\) +[^ ]* +OF/' \
  --regex='/[ \t]*\(ATTRIBUTE\|ENTITY\|FUNCTION\|PACKAGE\
  \( BODY\)?\|PROCEDURE\|PROCESS\|TYPE\)[ \t]+\([^ \t(]+\)/\3/'
@end smallexample
@end itemize

@node Select Tags Table
@subsection タグテーブルの選択

@findex visit-tags-table
  Emacsは常に、@dfn{選択された}タグテーブルを最大で1つもちます。タグテーブルにたいして機能するすべてのコマンドは、選択されたタグテーブルをまず使用します。タグテーブルを選択するには引数としてタグテーブルファイル名を読み取る@kbd{M-x
visit-tags-table}をタイプします。この引数のデフォルトはデフォルトディレクトリーからディレクトリーを上方へ再帰的に検索して@file{TAGS}という名前のファイルを含む最初のディレクトリーです。

@vindex tags-file-name
  Emacsは、タグテーブルを使用するまでは実際にタグテーブルの内容を読み込みません。@code{visit-tags-table}が行うのは、ファイル名を変数@code{tags-file-name}に格納することだけです。この変数の初期値は@code{nil}です。この変数の値は、タグテーブルにたいして機能するすべてのコマンドに、使用するタグテーブルファイル名を知らせます。

  選択されたタグテーブルに加えて、Emacsは共に使用するいくつかのタグテーブルのリストを保守しています。たとえばライブラリーを使うプログラムを扱っているなら、Emacsが両方から容易に識別子を見つけられるように、そのプログラムの他にも利用可能なライブラリーのタグテーブルも欲しいかもしれません。識別子が選択されたタグテーブルになかったり、タグコマンドに必要となるソースファイルにたいする記述がない場合には、このコマンドはタグテーブルのカレントリストから他のすべてのタグテーブルの使用を試みます。

  他のタグテーブルがすでにロードされているときに@code{visit-tags-table}を使用した場合には選択肢が与えられます。つまり、タグテーブルのカレントリストに新しいタグを追加するか、あるいはカレントリストを破棄して新しいリストを開始することもできます。タグコマンドは、カレントリストのすべてのタグテーブルを使用します。新しいリストを開始した場合、他のものの@emph{かわりに}、新しいタグテーブルが使用されます。カレントリストに新しいタグテーブルを追加した場合、それは他のものと@emph{同じように}使用されます。

@vindex tags-table-list
  以下のようにして、変数@code{tags-table-list}にディレクトリー名のリストをセットすることにより、タグテーブルのリストを正確に指定できます:

@c keep this on two lines for formatting in smallbook
@example
@group
(setq tags-table-list
      '("~/.emacs.d" "/usr/local/lib/emacs/src"))
@end group
@end example

@noindent
This tells the tags commands to look at the @file{TAGS} files in your
@file{~/.emacs.d} directory and in the @file{/usr/local/lib/emacs/src}
directory.  The order depends on which file you are in and which tags table
mentions that file.

  @code{tags-file-name}と@code{tags-table-list}の両方をセットしてはいけません。

@node EDE
@section Emacs開発環境
@cindex EDE (Emacs Development Environment)
@cindex Emacs Development Environment
@cindex Integrated development environment

EDE(@dfn{Emacs Development Environment:
Emacs開発環境})は、Emacsでの大きなプログラムの作成、ビルド、デバッグなどのタスクを単純化するパッケージです。これはEmacsにおいて、IDE(@dfn{Integrated
Development Environment: 統合開発環境})の機能をいくつか提供します。

このセクションは、EDEの簡単な説明を提供します。
@ifnottex
完全な詳細については、@ref{Top, EDE,, ede, Emacs Development Environment}を参照してください。
@end ifnottex
@iftex
EDEの完全な詳細は、@kbd{C-h i}とタイプしてEDEのマニュアルを選択してください。
@end iftex

  EDEは、グローバルなマイナーモードとして実装されています(@ref{Minor Modes}を参照してください)。有効にするには@kbd{M-x
global-ede-mode}とタイプするか、@samp{Tools}メニューの@samp{Project Support
(EDE)}アイテムをクリックします。以下の行をinitファイルに追加することにより、Emacs開始時にEDEを有効にすることもできます。

@smallexample
(global-ede-mode t)
@end smallexample

@noindent
EDEを有効にすることにより、メニューバーに@samp{Development}という名前のメニューが追加されます。以下で説明するコマンドを含めて、多くのEDEコマンドをこのメニューから呼び出すことができます。

  EDEは、ファイルを@dfn{プロジェクト(projects)}に編成します。プロジェクトはディレクトリーに対応します。@dfn{プロジェクトルート(project
root)}は、プロジェクトの最上層のディレクトリーです。新しいプロジェクトを定義するには、プロジェクトルートのファイルをvisitして、@kbd{M-x
ede-new}とタイプします。このコマンドは@dfn{プロジェクトタイプ(project
type)}の入力を求めます。これはEDEがプロジェクトを背後で管理する方式です(@ref{Creating a project, EDE,, ede,
Emacs Development
Environment}を参照してください)。もっとも一般的なプロジェクトタイプは、Makefilesを使用する@samp{Make}、およびGNU
Automake(@ref{Top, Automake,, automake,
Automake}を参照してください)を使用する@samp{Automake}です。どちらの場合も、EDEはプロジェクトに関する情報を格納する、@file{Project.ede}という名前のファイルを作成します。

  プロジェクトには、1つ以上の@dfn{ターゲット(targets)}を含めることができます。ターゲットとは、プロジェクトの1つ以上のファイルからビルドされるオブジェクトファイル、実行ファイル、またはその他の種類のファイルです。

  プロジェクトに新しい@dfn{ターゲット(target)}を追加するには、@kbd{C-c . t} (@code{M-x
ede-new-target})とタイプします。このコマンドは、カレントファイルをそのターゲットに追加するか尋ねます。これはターゲットがそのファイルからビルドされることを意味します。ターゲットを定義した後は、@kbd{C-c
. a} (@code{ede-add-file})とタイプすることにより、ターゲットにファイルを追加することができます。

  ターゲットをビルドするには、@kbd{C-c . c}
(@code{ede-compile-target})とタイプします。プロジェクトのすべてのターゲットをビルドするには、@kbd{C-c . C}
(@code{ede-compile-project})とタイプします。EDEはターゲットがどのようにビルドされるべきか推測するために、ファイルタイプを使用します。

@ifnottex
@include emerge-xtra-ja.texi
@end ifnottex


@node Bug Reference
@section バグリファレンス
@cindex bug reference

ある程度のユーザーをもつプロジェクトのほとんどは、バグレポートを追跡するために一意で短い数値や識別子を割り当てる何らかの問題追跡ソフトウェアでバグレポートを追跡しています。これらはソースコード中でバグの修整コードのコメント、ドキュメントファイル、メーリングリストやIRCチャンネルでの議論において、与えられたバグにたいするリファレンスとして使用されます。

@findex bug-reference-mode
@findex bug-reference-prog-mode
  マイナーモード@code{bug-reference-mode}と@code{bug-reference-prog-mode}はそのようなバグリファレンスをハイライトして、対応するバグレポートをプロジェクトのissue
trackerへフォローできるようにします。@code{bug-reference-prog-mode}は、ソースコードのコメントおよび文字列内部のバグリファレンスだけをハイライトする@code{bug-reference-mode}の変種です。

@vindex bug-reference-bug-regexp
@vindex bug-reference-url-format
  これが機能するためには、バグリファレンスの構文(@code{bug-reference-bug-regexp})、およびバグレポートを照会できるトラッカーのURL(@code{bug-reference-url-format})をBug
Referenceモードが承知している必要があります。これらは通常はプロジェクト間で異なるので、@ref{Directory
Variables}や@ref{File Variables}で指定するのは理にかなっています。

たとえば自分たちのプロジェクトではバグレポートへのリファレンスを通常はbug#1234やBug-1234のように記述し、そのバグのissueトラッカーにおけるページが@url{https://project.org/issues/1234}なら、これらのローカル変数セクションは以下のようになります。

@smallexample
;; Local Variables:
;; bug-reference-bug-regexp: "\\([Bb]ug[#-]\\([0-9]+\\)\\)"
;; bug-reference-url-format: "https://project.org/issues/%s"
;; End:
@end smallexample

最初のregexpグループがキャプチャーした文字列は、オーバーレイbug-referenceの境界(ハイライトされてクリック可能になる部分)の作成を定義します。

@code{bug-reference-bug-regexp}の2つ目のregexpグループがキャプチャした文字列は、@code{bug-reference-url-format}内の@code{%s}テンプレートの置換に使用されます。

issueとマージリクエストが違うURLになるように、これらの区別にバグリファレンスの異なる部分を使用する必要がある等、より複雑なシナリオに対応するために@code{bug-reference-url-format}は関数でもよいことに注意してください。


@heading 自動セットアップ

@vindex bug-reference-auto-setup-functions
@code{bug-reference-mode}がアクティブな場合には、@code{bug-reference-mode-hook}が実行されますが、@code{bug-reference-bug-regexp}と@code{bug-reference-url-format}はどちらも依然として@code{nil}のままです。このモードは@code{bug-reference-auto-setup-functions}の中のいずれかの関数が成功するまで順次呼び出すことによって、これら2つの変数にたいする適切な値を自動的に見つけようと試みます。

@vindex bug-reference-setup-from-vc-alist
@vindex bug-reference-forge-alist
@vindex bug-reference-setup-from-mail-alist
@vindex bug-reference-setup-from-irc-alist
セットアップ関数には、現在のところ3つのタイプがあります。

@enumerate
@item
変数@code{bug-reference-forge-alist}および@code{bug-reference-setup-from-vc-alist}で設定できるバージョンコントロールされたファイルをセットアップする。デフォルトではissueを通常は@code{bug#13}のように参照(ただし他の多くの表記も考慮)するGNUプロジェクト(issueトラッカーとして@url{https://debbugs.gnu.org}を使用)、そしてGitLab、Gitea、SourceHut、GitHubのような複数種類のソフトウェアフォージをセットアップできる(訳注:
FOSS開発コミュニティーにおいてforgeとはコンピューターアプリケーションの開発および共有のためのウェブベースのグループウェアを意味する)。このようなフォージのインスタンスをセルフホスティングでデプロイしている場合には、@code{bug-reference-forge-alist}を通してそれをbug-referenceに伝えるのがもっとも簡単な方法である。

@item
メールフォルダーやmboxの名前から推察されるemail、および変数@code{bug-reference-setup-from-mail-alist}で設定できるメールヘッダー値をセットアップする。built-in、news-、およびメールヘッダー@ref{Gnus}と@ref{Rmail}がサポートされている。

@item
変数@code{bug-reference-setup-from-irc-alist}で設定できるIRCチャンネルをセットアップする。ビルトインのIRCクライアントであるRcirc
(@ref{Top, Rcirc,, rcirc, The Rcirc Manual})、およびERC (@ref{Top, ERC,, erc,
The ERC Manual})がサポートされている。
@end enumerate

これらのモードのほとんどは、すべて@code{bug-reference-mode}を有効にするだけで充分ですが、Rmailだけは若干異なるセットアップが必要になります。

@smallexample
;; バージョンコントロールされたファイルならVCベースのセットアップを使用
(add-hook 'prog-mode-hook #'bug-reference-prog-mode)

;; Gnus (summaryバッファーとarticleバッファー)
(add-hook 'gnus-mode-hook #'bug-reference-mode)

;; Rmail
(add-hook 'rmail-show-message-hook #'bug-reference-mode-force-auto-setup)

;; Rcirc
(add-hook 'rcirc-mode-hook #'bug-reference-mode)

;; ERC
(add-hook 'erc-mode-hook #'bug-reference-mode)
@end smallexample

Rmailの場合には、モードフックのかわりに関数@code{bug-reference-mode-force-auto-setup} (
@code{bug-reference-mode}をアクティブにして強制的に自動セットアップを行う)と組み合わせて@code{rmail-show-message-hook}を使う必要があります。その理由はRmailではすべてのメッセージが同じバッファーにありますが、セットアップは別のメッセージが表示されるたびに実行される必要があるからです。


@heading サードパーティ製パッケージへのサポートの追加

@vindex bug-reference-auto-setup-functions
bug-referenceのauto-setupにたいするサポートの追加は、通常ならとても単純です。必要な情報(MUAの場合にはList-Id/To/From/Ccのメールヘッダー値)を集める引数なしのセットアップ関数を記述して、以下のヘルパー関数のいずれかを呼び出します:

@itemize @bullet
@item
@code{bug-reference-setup-from-vc-alist}に応じたセットアップを行う@code{bug-reference-maybe-setup-from-vc}

@item
@code{bug-reference-setup-from-mail-alist}に応じたセットアップを行う@code{bug-reference-maybe-setup-from-mail}

@item
@code{bug-reference-setup-from-irc-alist}に応じたセットアップを行う@code{bug-reference-maybe-setup-from-irc}
@end itemize

セットアップ関数はbug-referenceモードをセットアップできるなら非@code{nil}をリターンします。これは上記のヘルパー関数のいずれかを呼び出すのが、関数が最後に行うこととなるケースです。

最後にそのセットアップ関数を@code{bug-reference-auto-setup-functions}に追加する必要があります。

これらのauto-setup関数は最初のステップとして、@code{major-mode}の値をチェックする等によりそれらが適用可能かチェックする必要があることに注意してください。


@heading デバッグパッケージとの統合

@findex debbugs-browse-mode
プロジェクトのissueがサーバー@url{https://debbugs.gnu.org}でトラックされていれば、Packageメニュー(@ref{Packages}を参照)でダウンロードできる@code{debbugs}パッケージを使用して、Emacsから直接レポートの閲覧や回答ができます。このパッケージは、以下のように@code{bug-reference-mode}と@code{bug-reference-prog-mode}の上にアクティブ化できるマイナーモード@code{debbugs-browse-mode}を追加します:

@smallexample
(add-hook 'bug-reference-mode-hook 'debbugs-browse-mode)
(add-hook 'bug-reference-prog-mode-hook 'debbugs-browse-mode)
@end smallexample
