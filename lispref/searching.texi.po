# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Emacs 25.1\n"
"POT-Creation-Date: 2019-10-14 22:49+0900\n"
"PO-Revision-Date: 2020-02-01 08:57+0900\n"
"Last-Translator: Ayanokoji Takesi <ayanokoji.takesi@gmail.com>\n"
"Language-Team: \n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: original_texis/searching.texi:6 original_texis/searching.texi:7
#, no-wrap
msgid "Searching and Matching"
msgstr "Searching and Matching"

#. type: cindex
#: original_texis/searching.texi:8
#, no-wrap
msgid "searching"
msgstr "searching"

#. type: Plain text
#: original_texis/searching.texi:15
msgid "GNU Emacs provides two ways to search through a buffer for specified text: exact string searches and regular expression searches.  After a regular expression search, you can examine the @dfn{match data} to determine which text matched the whole regular expression or various portions of it."
msgstr "GNU Emacsはバッファーから指定されたテキストを検索するために2つの手段を提供します。それは文字列の正確一致検索(exact string search)と正規表現検索(regular expression search)です。正規表現検索の後で、マッチしたテキストが正規表現全体にマッチしたのか、それとも正規表現のさまざまな部分に一致したかを判断するために@dfn{マッチデータ(match data)}を調べることができます。"

#. type: node
#: original_texis/searching.texi:26 original_texis/searching.texi:32
#, no-wrap
msgid "String Search"
msgstr "String Search"

#. type: menuentry
#: original_texis/searching.texi:26
msgid "Search for an exact match."
msgstr "正確なマッチの検索。"

#. type: section
#: original_texis/searching.texi:26 original_texis/searching.texi:191
#: original_texis/searching.texi:192
#, no-wrap
msgid "Searching and Case"
msgstr "Searching and Case"

#. type: menuentry
#: original_texis/searching.texi:26
msgid "Case-independent or case-significant searching."
msgstr "case-independentまたはcase-significantな検索。"

#. type: section
#: original_texis/searching.texi:26 original_texis/searching.texi:234
#: original_texis/searching.texi:235
#, no-wrap
msgid "Regular Expressions"
msgstr "Regular Expressions"

#. type: menuentry
#: original_texis/searching.texi:26
msgid "Describing classes of strings."
msgstr "文字列クラスの記述。"

#. type: node
#: original_texis/searching.texi:26 original_texis/searching.texi:1009
#, no-wrap
msgid "Regexp Search"
msgstr "Regexp Search"

#. type: menuentry
#: original_texis/searching.texi:26
msgid "Searching for a match for a regexp."
msgstr "regexpにたいするマッチの検索。"

#. type: node
#: original_texis/searching.texi:26 original_texis/searching.texi:1239
#, no-wrap
msgid "POSIX Regexps"
msgstr "POSIX Regexps"

#. type: menuentry
#: original_texis/searching.texi:26
msgid "Searching POSIX-style for the longest match."
msgstr "最長マッチにたいするPOSIXスタイルのマッチ。"

#. type: node
#: original_texis/searching.texi:26 original_texis/searching.texi:1284
#, no-wrap
msgid "Match Data"
msgstr "Match Data"

#. type: menuentry
#: original_texis/searching.texi:26
msgid "Finding out which part of the text matched, after a string or regexp search."
msgstr "文字列またはregexp検索後にテキストがマッチした部分を見つける。"

#. type: section
#: original_texis/searching.texi:26 original_texis/searching.texi:1694
#: original_texis/searching.texi:1695
#, no-wrap
msgid "Search and Replace"
msgstr "Search and Replace"

#. type: menuentry
#: original_texis/searching.texi:26
msgid "Commands that loop, searching and replacing."
msgstr "検索と置換を繰り返すコマンド。"

#. type: node
#: original_texis/searching.texi:26 original_texis/searching.texi:1898
#, no-wrap
msgid "Standard Regexps"
msgstr "Standard Regexps"

#. type: menuentry
#: original_texis/searching.texi:26
msgid "Useful regexps for finding sentences, pages,..."
msgstr "センテンスやページ等を探すために有用なregexp。"

#. type: Plain text
#: original_texis/searching.texi:31
msgid "The @samp{skip-chars@dots{}} functions also perform a kind of searching.  @xref{Skipping Characters}.  To search for changes in character properties, see @ref{Property Search}."
msgstr "@samp{skip-chars@dots{}}関連の関数もある種の検索を行います。@ref{Skipping Characters}を参照してください。文字プロパティ内の変更の検索は@ref{Property Search}を参照してください。"

#. type: section
#: original_texis/searching.texi:33
#, no-wrap
msgid "Searching for Strings"
msgstr "Searching for Strings"

#. type: cindex
#: original_texis/searching.texi:34
#, no-wrap
msgid "string search"
msgstr "string search"

#. type: Plain text
#: original_texis/searching.texi:42
msgid "These are the primitive functions for searching through the text in a buffer.  They are meant for use in programs, but you may call them interactively.  If you do so, they prompt for the search string; the arguments @var{limit} and @var{noerror} are @code{nil}, and @var{repeat} is 1.  For more details on interactive searching, @pxref{Search,, Searching and Replacement, emacs, The GNU Emacs Manual}."
msgstr "バッファー内のテキストを検索するためのプリミティブ関数が存在します。これらはプログラム内での使用を意図したものですがインタラクティブに呼び出すこともできます。これらをインタラクティブに呼び出すと検索文字列の入力を求めて、引数@var{limit}と@var{noerror}は@code{nil}、@var{repeat}は1になります。インタラクティブ検索に関するより詳細な情報は@ref{Search,, Searching and Replacement, emacs, The GNU Emacs Manual}を参照してください。"

#. type: Plain text
#: original_texis/searching.texi:46
msgid "These search functions convert the search string to multibyte if the buffer is multibyte; they convert the search string to unibyte if the buffer is unibyte.  @xref{Text Representations}."
msgstr "以下の検索関数はバッファーがマルチバイトバッファーならマルチバイト、ユニバイトバッファーならユニバイトに検索文字列を変換します。@ref{Text Representations}を参照してください。"

#. type: deffn
#: original_texis/searching.texi:47
#, no-wrap
msgid "Command search-forward string &optional limit noerror count"
msgstr "Command search-forward string &optional limit noerror count"

#. type: deffn
#: original_texis/searching.texi:52
msgid "This function searches forward from point for an exact match for @var{string}.  If successful, it sets point to the end of the occurrence found, and returns the new value of point.  If no match is found, the value and side effects depend on @var{noerror} (see below)."
msgstr "この関数は@var{string}にたいする正確なマッチをポイントから前方に検索する。成功したら見つかったマッチの終端にポイントをセットしてポイントの新たな値をリターンする。マッチが見つからない場合の値と副作用は@var{noerror} (以下参照)に依存する。"

#. type: deffn
#: original_texis/searching.texi:56
msgid "In the following example, point is initially at the beginning of the line.  Then @code{(search-forward \"fox\")} moves point after the last letter of @samp{fox}:"
msgstr "以下の例ではポイントは最初は行の先頭にある。その後の@code{(search-forward \"fox\")}によってポイントは@samp{fox}の最後の文字の後に移動する:"

#. type: group
#: original_texis/searching.texi:62
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"@point{}The quick brown fox jumped over the lazy dog.\n"
"---------- Buffer: foo ----------\n"
msgstr ""
"---------- Buffer: foo ----------\n"
"@point{}The quick brown fox jumped over the lazy dog.\n"
"---------- Buffer: foo ----------\n"

#. type: group
#: original_texis/searching.texi:67
#, no-wrap
msgid ""
"(search-forward \"fox\")\n"
"     @result{} 20\n"
"\n"
msgstr ""
"(search-forward \"fox\")\n"
"     @result{} 20\n"
"\n"

#. type: group
#: original_texis/searching.texi:71
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"The quick brown fox@point{} jumped over the lazy dog.\n"
"---------- Buffer: foo ----------\n"
msgstr ""
"---------- Buffer: foo ----------\n"
"The quick brown fox@point{} jumped over the lazy dog.\n"
"---------- Buffer: foo ----------\n"

#. type: deffn
#: original_texis/searching.texi:78
msgid "The argument @var{limit} specifies the bound to the search, and should be a position in the current buffer.  No match extending after that position is accepted.  If @var{limit} is omitted or @code{nil}, it defaults to the end of the accessible portion of the buffer."
msgstr "引数@var{limit}は検索の境界を指定するもので、それはカレントバッファー内の位置であること。その位置を超えるようなマッチは受け入れられない。@var{limit}が省略または@code{nil}の場合のデフォルトは、そのバッファーのアクセス可能範囲の終端。"

#. type: kindex
#: original_texis/searching.texi:79
#, no-wrap
msgid "search-failed"
msgstr "search-failed"

#. type: deffn
#: original_texis/searching.texi:88
msgid "What happens when the search fails depends on the value of @var{noerror}.  If @var{noerror} is @code{nil}, a @code{search-failed} error is signaled.  If @var{noerror} is @code{t}, @code{search-forward} returns @code{nil} and does nothing.  If @var{noerror} is neither @code{nil} nor @code{t}, then @code{search-forward} moves point to the upper bound and returns @code{nil}."
msgstr "検索失敗時に何が起こるかは@var{noerror}の値に依存する。@var{noerror}が@code{nil}なら@code{search-failed}はエラーをシグナルする。@var{noerror}が@code{t}なら@code{search-forward}は@code{nil}をリターンして何も行わない。@var{noerror}が@code{nil}と@code{t}いずれでもなければ、@code{search-forward}はポイントを境界上限に移動して@code{nil}をリターンする。"

#. type: deffn
#: original_texis/searching.texi:97 original_texis/searching.texi:1055
msgid "The argument @var{noerror} only affects valid searches which fail to find a match.  Invalid arguments cause errors regardless of @var{noerror}."
msgstr "引数@var{noerror}はマッチに失敗した有効な検索だけに影響する。無効な引数は@var{noerror}とは無関係にエラーとなる。"

#. type: deffn
#: original_texis/searching.texi:106 original_texis/searching.texi:1064
msgid "If @var{count} is a positive number @var{n}, the search is done @var{n} times; each successive search starts at the end of the previous match.  If all these successive searches succeed, the function call succeeds, moving point and returning its new value.  Otherwise the function call fails, with results depending on the value of @var{noerror}, as described above.  If @var{count} is a negative number -@var{n}, the search is done @var{n} times in the opposite (backward) direction."
msgstr "@var{repeat}が正の数@var{n}なら検索は@var{n}回繰り返される。一連の検索は前回のマッチの終端から毎回検索が開始される。これらの一連の検索が成功すると、関数呼び出しは成功となりポイントを移動して新たな値をリターンする。それ以外は関数の呼び出しは失敗となり、結果は上述のように@var{noerror}の値に依存する。@var{repeat}が負の数-@var{n}なら検索は逆方向(後方)へ@var{n}回行われる。"

#. type: deffn
#: original_texis/searching.texi:108
#, no-wrap
msgid "Command search-backward string &optional limit noerror count"
msgstr "Command search-backward string &optional limit noerror count"

#. type: deffn
#: original_texis/searching.texi:113
msgid "This function searches backward from point for @var{string}.  It is like @code{search-forward}, except that it searches backwards rather than forwards.  Backward searches leave point at the beginning of the match."
msgstr "この関数はポイントから後方に@var{string}を検索する。これは@code{search-forward}と似ているが、前方ではなく後方に検索する点が異なる。後方への検索ではポイントはマッチの先頭に残される。"

#. type: deffn
#: original_texis/searching.texi:115
#, no-wrap
msgid "Command word-search-forward string &optional limit noerror count"
msgstr "Command word-search-forward string &optional limit noerror count"

#. type: deffn
#: original_texis/searching.texi:119
msgid "This function searches forward from point for a word match for @var{string}.  If it finds a match, it sets point to the end of the match found, and returns the new value of point."
msgstr "この関数はポイントから前方に@var{string}にたいする単語(word)のマッチを検索する。マッチが見つかったら見つかったマッチの終端にポイントをセットしてポイントの新たな値をリターンする。"

#. type: deffn
#: original_texis/searching.texi:126
msgid "Word matching regards @var{string} as a sequence of words, disregarding punctuation that separates them.  It searches the buffer for the same sequence of words.  Each word must be distinct in the buffer (searching for the word @samp{ball} does not match the word @samp{balls}), but the details of punctuation and spacing are ignored (searching for @samp{ball boy} does match @samp{ball.  Boy!})."
msgstr "単語マッチは@var{string}を単語のシーケンスとみなし、それらを分割する句読点は無視する。これはバッファーから同じ単語シーケンスを検索する。単語はそれぞれバッファー内で明確に区別されていなければならない(単語@samp{ball}の検索は単語@samp{balls}にマッチしない)が、句読点やスペース等の細部は無視される(@samp{ball boy}を検索すると@samp{ball.  Boy!}にマッチする)。"

#. type: deffn
#: original_texis/searching.texi:129
msgid "In this example, point is initially at the beginning of the buffer; the search leaves it between the @samp{y} and the @samp{!}."
msgstr "以下の例ではポイントは最初バッファー先頭にある。検索によりポイントは@samp{y}と@samp{!}の間に残される。"

#. type: group
#: original_texis/searching.texi:136
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"@point{}He said \"Please!  Find\n"
"the ball boy!\"\n"
"---------- Buffer: foo ----------\n"
msgstr ""
"---------- Buffer: foo ----------\n"
"@point{}He said \"Please!  Find\n"
"the ball boy!\"\n"
"---------- Buffer: foo ----------\n"

#. type: group
#: original_texis/searching.texi:141
#, no-wrap
msgid ""
"(word-search-forward \"Please find the ball, boy.\")\n"
"     @result{} 39\n"
"\n"
msgstr ""
"(word-search-forward \"Please find the ball, boy.\")\n"
"     @result{} 39\n"
"\n"

#. type: group
#: original_texis/searching.texi:146
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"He said \"Please!  Find\n"
"the ball boy@point{}!\"\n"
"---------- Buffer: foo ----------\n"
msgstr ""
"---------- Buffer: foo ----------\n"
"He said \"Please!  Find\n"
"the ball boy@point{}!\"\n"
"---------- Buffer: foo ----------\n"

#. type: deffn
#: original_texis/searching.texi:152
msgid "If @var{limit} is non-@code{nil}, it must be a position in the current buffer; it specifies the upper bound to the search.  The match found must not extend after that position."
msgstr "@var{limit}が非@code{nil}なら、それはカレントバッファー内の位置であること。これはその検索の境界上限を指定する。見つかったマッチはその位置を超えてはならない。"

#. type: deffn
#: original_texis/searching.texi:158
msgid "If @var{noerror} is @code{nil}, then @code{word-search-forward} signals an error if the search fails.  If @var{noerror} is @code{t}, then it returns @code{nil} instead of signaling an error.  If @var{noerror} is neither @code{nil} nor @code{t}, it moves point to @var{limit} (or the end of the accessible portion of the buffer) and returns @code{nil}."
msgstr "@var{noerror}が@code{nil}なら@code{word-search-forward}はエラーをシグナルする。@var{noerror}が@code{t}なら、エラーをシグナルするかわりに@code{nil}をリターンする。@var{noerror}が@code{nil}と@code{t}いずれでもなければ、ポイントを@var{limit}(またはバッファーのアクセス可能範囲の終端)に移動して@code{nil}をリターンする。"

#. type: deffn
#: original_texis/searching.texi:163
msgid "If @var{count} is a positive number, it specifies how many successive occurrences to search for.  Point is positioned at the end of the last match.  If @var{count} is a negative number, the search is backward and point is positioned at the beginning of the last match."
msgstr "@var{count}が正の数なら、それは連続して検索する回数を指定する。ポイントは最後のマッチの終端に配置される。@var{count}が負の数なら、逆方向に検索してポイントは最後のマッチの先頭に配置される。"

#. type: findex
#: original_texis/searching.texi:164
#, no-wrap
msgid "word-search-regexp"
msgstr "word-search-regexp"

#. type: deffn
#: original_texis/searching.texi:168
msgid "Internally, @code{word-search-forward} and related functions use the function @code{word-search-regexp} to convert @var{string} to a regular expression that ignores punctuation."
msgstr "@code{word-search-forward}および関連する関数は、@var{string}から句読点を無視した正規表現に変換するために、内部的には関数@code{word-search-regexp}を使用する。"

#. type: deffn
#: original_texis/searching.texi:170
#, no-wrap
msgid "Command word-search-forward-lax string &optional limit noerror count"
msgstr "Command word-search-forward-lax string &optional limit noerror count"

#. type: deffn
#: original_texis/searching.texi:176
msgid "This command is identical to @code{word-search-forward}, except that the beginning or the end of @var{string} need not match a word boundary, unless @var{string} begins or ends in whitespace.  For instance, searching for @samp{ball boy} matches @samp{ball boyee}, but does not match @samp{balls boy}."
msgstr "このコマンドは@code{word-search-forward}と同じだが、@var{string}が空白で開始か終了していなければ、@var{string}の先頭か終端が単語境界にマッチする必要がない点が異なる。たとえば@samp{ball boy}の検索は@samp{ball boyee}にはマッチするが、@samp{balls boy}にはマッチしない。"

#. type: deffn
#: original_texis/searching.texi:178
#, no-wrap
msgid "Command word-search-backward string &optional limit noerror count"
msgstr "Command word-search-backward string &optional limit noerror count"

#. type: deffn
#: original_texis/searching.texi:183
msgid "This function searches backward from point for a word match to @var{string}.  This function is just like @code{word-search-forward} except that it searches backward and normally leaves point at the beginning of the match."
msgstr "この関数はポイントから後方へ@var{string}にマッチする単語を検索する。この関数は@code{word-search-forward}と同様だが、後方に検索して通常はマッチの先頭にポイントを残す点が異なる。"

#. type: deffn
#: original_texis/searching.texi:185
#, no-wrap
msgid "Command word-search-backward-lax string &optional limit noerror count"
msgstr "Command word-search-backward-lax string &optional limit noerror count"

#. type: deffn
#: original_texis/searching.texi:189
msgid "This command is identical to @code{word-search-backward}, except that the beginning or the end of @var{string} need not match a word boundary, unless @var{string} begins or ends in whitespace."
msgstr "このコマンドは@code{word-search-backward}と同じだが、文字列が空白で開始か終了していなければ、@var{string}の先頭か終端が単語境界にマッチする必要がない点が異なる。"

#. type: cindex
#: original_texis/searching.texi:193
#, no-wrap
msgid "searching and case"
msgstr "searching and case"

#. type: Plain text
#: original_texis/searching.texi:200
msgid "By default, searches in Emacs ignore the case of the text they are searching through; if you specify searching for @samp{FOO}, then @samp{Foo} or @samp{foo} is also considered a match.  This applies to regular expressions, too; thus, @samp{[aB]} would match @samp{a} or @samp{A} or @samp{b} or @samp{B}."
msgstr "デフォルトのEmacs検索では検索するテキストのcase(大文字と小文字)は無視されます。検索対象に@samp{FOO}を指定すると、@samp{Foo}や@samp{foo}もマッチとみなされます。これは正規表現にも適用されます。つまり@samp{[aB]}は@samp{a}、@samp{A}、@samp{b}、@samp{B}にもマッチするでしょう。"

#. type: Plain text
#: original_texis/searching.texi:208
msgid "If you do not want this feature, set the variable @code{case-fold-search} to @code{nil}.  Then all letters must match exactly, including case.  This is a buffer-local variable; altering the variable affects only the current buffer.  (@xref{Intro to Buffer-Local}.)  Alternatively, you may change the default value.  In Lisp code, you will more typically use @code{let} to bind @code{case-fold-search} to the desired value."
msgstr "この機能が望ましくなければ変数@code{case-fold-search}に@code{nil}をセットしてください。その場合にはすべての文字はcaseを含めて正確にマッチしなければなりません。これはバッファーローカル変数です。この変数の変更はカレントバッファーだけに影響を与えます(@ref{Intro to Buffer-Local}を参照)。かわりにデフォルト値を変更することもできます。Lispコードでは@code{let}を使用して@code{case-fold-search}を望む値にバインドするほうが、より一般的でしょう。"

#. type: Plain text
#: original_texis/searching.texi:216
msgid "Note that the user-level incremental search feature handles case distinctions differently.  When the search string contains only lower case letters, the search ignores case, but when the search string contains one or more upper case letters, the search becomes case-sensitive.  But this has nothing to do with the searching functions used in Lisp code.  @xref{Incremental Search,,, emacs, The GNU Emacs Manual}."
msgstr "ユーザーレベルのインクリメンタル検索機能ではcaseの区別が異なることに注意してください。検索文字列に含まれるのが小文字だけなら検索はcaseを無視しますが、検索文字列に1つ以上の大文字が含まれれば検索はcaseを区別するようになります。しかしLispコード内で使用される検索関数では、これは何も行いません。@ref{Incremental Search,,, emacs, The GNU Emacs Manual}を参照してください。"

#. type: defopt
#: original_texis/searching.texi:217
#, no-wrap
msgid "case-fold-search"
msgstr "case-fold-search"

#. type: defopt
#: original_texis/searching.texi:221
msgid "This buffer-local variable determines whether searches should ignore case.  If the variable is @code{nil} they do not ignore case; otherwise (and by default) they do ignore case."
msgstr "このバッファーローカル変数は検索がcaseを無視するべきかどうかを決定する。この変数が@code{nil}なら検索はcaseを無視しない。それ以外(とデフォルト)ではcaseを無視する。"

#. type: defopt
#: original_texis/searching.texi:223
#, no-wrap
msgid "case-replace"
msgstr "case-replace"

#. type: defopt
#: original_texis/searching.texi:229
msgid "This variable determines whether the higher-level replacement functions should preserve case.  If the variable is @code{nil}, that means to use the replacement text verbatim.  A non-@code{nil} value means to convert the case of the replacement text according to the text being replaced."
msgstr "この変数は高レベルの置換関数がcaseを保持するべきかどうかを決定する。この変数が@code{nil}なら、それは置換テキストをそのまま使用することを意味する。非@code{nil}値は置換されるテキストに応じて、置換テキストのcaseを変換することを意味する。"

#. type: defopt
#: original_texis/searching.texi:232
msgid "This variable is used by passing it as an argument to the function @code{replace-match}.  @xref{Replacing Match}."
msgstr "この変数は関数@code{replace-match}の引数として渡すことにより使用される。@ref{Replacing Match}を参照のこと。"

#. type: cindex
#: original_texis/searching.texi:236
#, no-wrap
msgid "regular expression"
msgstr "regular expression"

#. type: cindex
#: original_texis/searching.texi:237
#, no-wrap
msgid "regexp"
msgstr "regexp"

#. type: Plain text
#: original_texis/searching.texi:243
msgid "A @dfn{regular expression}, or @dfn{regexp} for short, is a pattern that denotes a (possibly infinite) set of strings.  Searching for matches for a regexp is a very powerful operation.  This section explains how to write regexps; the following section says how to search for them."
msgstr "@dfn{正規表現(regular expression)}、略して@dfn{regexp}は文字列の(もしかしたら無限の)セットを表すパターンのことです。regexpにたいするマッチの検索はとても強力な処理です。このセクションではregexpの記述方法、それ以降のセクションではそれらを検索する方法を示します。"

#. type: findex
#: original_texis/searching.texi:244
#, no-wrap
msgid "re-builder"
msgstr "re-builder"

#. type: cindex
#: original_texis/searching.texi:245
#, no-wrap
msgid "regular expressions, developing"
msgstr "regular expressions, developing"

#. type: Plain text
#: original_texis/searching.texi:253
msgid "For interactive development of regular expressions, you can use the @kbd{M-x re-builder} command.  It provides a convenient interface for creating regular expressions, by giving immediate visual feedback in a separate buffer.  As you edit the regexp, all its matches in the target buffer are highlighted.  Each parenthesized sub-expression of the regexp is shown in a distinct face, which makes it easier to verify even very complex regexps."
msgstr "正規表現を対話的に開発するために@kbd{M-x re-builder}コマンドを使用できます。このコマンドは別のバッファーに即座に視覚的なフィードバックを表示することにより、正規表現を作成するための便利なインターフェースを提供します。regexp編集とともにターゲットとなるバッファーのすべてのマッチがハイライトされます。カッコで括られたregexpの部分式(sub-expression)は別のフェイスで表示され、非常に複雑なregexpを簡単に検証することが可能になります。"

#. type: node
#: original_texis/searching.texi:258 original_texis/searching.texi:260
#, no-wrap
msgid "Syntax of Regexps"
msgstr "Syntax of Regexps"

#. type: menuentry
#: original_texis/searching.texi:258
msgid "Rules for writing regular expressions."
msgstr "正規表現の記述ルール。"

#. type: node
#: original_texis/searching.texi:258 original_texis/searching.texi:844
#, no-wrap
msgid "Regexp Example"
msgstr "Regexp Example"

#. type: menuentry
#: original_texis/searching.texi:258
msgid "Illustrates regular expression syntax."
msgstr "正規表現構文の説明。"

#. type: node
#: original_texis/searching.texi:258 original_texis/searching.texi:904
#, no-wrap
msgid "Regexp Functions"
msgstr "Regexp Functions"

#. type: menuentry
#: original_texis/searching.texi:258
msgid "Functions for operating on regular expressions."
msgstr "正規表現を操作する関数。"

#. type: subsection
#: original_texis/searching.texi:261
#, no-wrap
msgid "Syntax of Regular Expressions"
msgstr "Syntax of Regular Expressions"

#. type: cindex
#: original_texis/searching.texi:262
#, no-wrap
msgid "regexp syntax"
msgstr "regexp syntax"

#. type: cindex
#: original_texis/searching.texi:263
#, no-wrap
msgid "syntax of regular expressions"
msgstr "syntax of regular expressions"

#. type: Plain text
#: original_texis/searching.texi:276
msgid "Regular expressions have a syntax in which a few characters are special constructs and the rest are @dfn{ordinary}.  An ordinary character is a simple regular expression that matches that character and nothing else.  The special characters are @samp{.}, @samp{*}, @samp{+}, @samp{?}, @samp{[}, @samp{^}, @samp{$}, and @samp{\\}; no new special characters will be defined in the future.  The character @samp{]} is special if it ends a character alternative (see later).  The character @samp{-} is special inside a character alternative.  A @samp{[:} and balancing @samp{:]} enclose a character class inside a character alternative.  Any other character appearing in a regular expression is ordinary, unless a @samp{\\} precedes it."
msgstr "正規表現は少数の文字が特別な構成要素であり、残りは@dfn{通常}の文字であるような構文をもちます。通常の文字はその文字自身だけにマッチするシンプルな正規表現です。特別な文字は@samp{.}、@samp{*}、@samp{+}、@samp{?}、@samp{[}、@samp{^}、@samp{$}、および@samp{\\}です。将来に新たなスペシャル文字が定義されることはないでしょう。文字候補で終わる場合には@samp{]}はスペシャル文字です。文字候補の間では@samp{-}はスペシャル文字です。@samp{[:}と対応する@samp{:]}は文字候補内の文字クラスです。正規表現内に出現する他の文字は@samp{\\}が前置されていない限り通常の文字です。"

#. type: Plain text
#: original_texis/searching.texi:282
msgid "For example, @samp{f} is not a special character, so it is ordinary, and therefore @samp{f} is a regular expression that matches the string @samp{f} and no other string.  (It does @emph{not} match the string @samp{fg}, but it does match a @emph{part} of that string.)  Likewise, @samp{o} is a regular expression that matches only @samp{o}."
msgstr "たとえば@samp{f}はスペシャル文字ではなく通常文字なので、@samp{f}は文字列@samp{f}にマッチして他の文字にはマッチしない正規表現です(これは文字列@samp{fg}には@emph{マッチしない}が、その文字列の@emph{部分}にマッチする)。同様に@samp{o}は@samp{o}だけにマッチします。"

#. type: Plain text
#: original_texis/searching.texi:287
msgid "Any two regular expressions @var{a} and @var{b} can be concatenated.  The result is a regular expression that matches a string if @var{a} matches some amount of the beginning of that string and @var{b} matches the rest of the string."
msgstr "任意の2つの正規表現@var{a}と@var{b}を結合することができます。結合した結果は文字列の先頭からある長さの文字列が@var{a}にマッチして、残りの文字列が@var{b}にマッチするような文字列にマッチする正規表現になります。"

#. type: Plain text
#: original_texis/searching.texi:292
msgid "As a simple example, we can concatenate the regular expressions @samp{f} and @samp{o} to get the regular expression @samp{fo}, which matches only the string @samp{fo}.  Still trivial.  To do something more powerful, you need to use one of the special regular expression constructs."
msgstr "単純な例として文字列@samp{fo}だけにマッチする正規表現の構成要素@samp{fo}を取得するために正規表現@samp{f}と@samp{o}を結合できます。"

#. type: node
#: original_texis/searching.texi:297 original_texis/searching.texi:299
#, no-wrap
msgid "Regexp Special"
msgstr "Regexp Special"

#. type: menuentry
#: original_texis/searching.texi:297
msgid "Special characters in regular expressions."
msgstr "正規表現内のスペシャル文字。"

#. type: node
#: original_texis/searching.texi:297 original_texis/searching.texi:535
#, no-wrap
msgid "Char Classes"
msgstr "Char Classes"

#. type: menuentry
#: original_texis/searching.texi:297
msgid "Character classes used in regular expressions."
msgstr "正規表現内で使用される文字クラス。"

#. type: node
#: original_texis/searching.texi:297 original_texis/searching.texi:599
#, no-wrap
msgid "Regexp Backslash"
msgstr "Regexp Backslash"

#. type: menuentry
#: original_texis/searching.texi:297
msgid "Backslash-sequences in regular expressions."
msgstr "正規表現内のバックスラッシュシーケンス。"

#. type: subsubsection
#: original_texis/searching.texi:300
#, no-wrap
msgid "Special Characters in Regular Expressions"
msgstr "Special Characters in Regular Expressions"

#. type: cindex
#: original_texis/searching.texi:301
#, no-wrap
msgid "regexp, special characters in"
msgstr "regexp, special characters in"

#. type: Plain text
#: original_texis/searching.texi:305
msgid "Here is a list of the characters that are special in a regular expression."
msgstr "以下は正規表現内で特別な文字のリストです:"

#. type: item
#: original_texis/searching.texi:308
#, no-wrap
msgid "@samp{.}@: @r{(Period)}"
msgstr "@samp{.}@: @r{(Period)}"

#. type: cindex
#: original_texis/searching.texi:309
#, no-wrap
msgid "@samp{.} in regexp"
msgstr "@samp{.} in regexp"

#. type: table
#: original_texis/searching.texi:314
msgid "is a special character that matches any single character except a newline.  Using concatenation, we can make regular expressions like @samp{a.b}, which matches any three-character string that begins with @samp{a} and ends with @samp{b}."
msgstr "これは改行を除く1文字にマッチする。結合を使用して@samp{a.b}のような正規表現を作成できる。これは@samp{a}で始まり@samp{b}で終わる3文字の文字列にマッチする。"

#. type: samp{#1}
#: original_texis/searching.texi:315
#, no-wrap
msgid "*"
msgstr "*"

#. type: cindex
#: original_texis/searching.texi:316
#, no-wrap
msgid "@samp{*} in regexp"
msgstr "@samp{*} in regexp"

#. type: table
#: original_texis/searching.texi:321
msgid "is not a construct by itself; it is a postfix operator that means to match the preceding regular expression repetitively as many times as possible.  Thus, @samp{o*} matches any number of @samp{o}s (including no @samp{o}s)."
msgstr "これはそれ自身が構成要素ではない。これは前置された正規表現を可能な限り繰り返したものにマッチすることを意味する後置演算子である。したがって@samp{o*}は任意の個数の@samp{o}にマッチする(@samp{o}を含まない場合にもマッチする)。"

#. type: table
#: original_texis/searching.texi:325
msgid "@samp{*} always applies to the @emph{smallest} possible preceding expression.  Thus, @samp{fo*} has a repeating @samp{o}, not a repeating @samp{fo}.  It matches @samp{f}, @samp{fo}, @samp{foo}, and so on."
msgstr "@samp{*}は常に前置された表現の@emph{最小}の表現に適用される。つまり@samp{fo*}は@samp{o}の繰り返しであり@samp{fo}の繰り返しではない。これは@samp{f}、@samp{fo}、@samp{foo}、...にマッチする。"

#. type: cindex
#: original_texis/searching.texi:326
#, no-wrap
msgid "backtracking and regular expressions"
msgstr "backtracking and regular expressions"

#. type: table
#: original_texis/searching.texi:337
msgid "The matcher processes a @samp{*} construct by matching, immediately, as many repetitions as can be found.  Then it continues with the rest of the pattern.  If that fails, backtracking occurs, discarding some of the matches of the @samp{*}-modified construct in the hope that that will make it possible to match the rest of the pattern.  For example, in matching @samp{ca*ar} against the string @samp{caaar}, the @samp{a*} first tries to match all three @samp{a}s; but the rest of the pattern is @samp{ar} and there is only @samp{r} left to match, so this try fails.  The next alternative is for @samp{a*} to match only two @samp{a}s.  With this choice, the rest of the regexp matches successfully."
msgstr "マッチを行う処理は構成要素@samp{*}を、マッチングにより即座に見つけ得る回数分処理して、その後にパターンの残りを継続する。これが失敗したら残りのパターンのマッチが可能になるかもしれないという期待のもとに、@samp{*}の変更された構成のうちいくつかのマッチを破棄することによるバックトラッキングが発生する。たとえば文字列@samp{caaar}にたいして@samp{ca*ar}をマッチングすると、@samp{a*}はまず3つすべての@samp{a}へのマッチを試みる。しかし残りのパターンは@samp{ar}でありマッチ対象に残されているのは@samp{r}だけなのでこの試みは失敗する。@samp{a*}にたいする次の代替策は2つの@samp{a}だけへのマッチである。この選択では残りのregexpのマッチは成功する。"

#. type: table
#: original_texis/searching.texi:348
msgid "@strong{Warning:} Nested repetition operators can run for an indefinitely long time, if they lead to ambiguous matching.  For example, trying to match the regular expression @samp{\\(x+y*\\)*a} against the string @samp{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz} could take hours before it ultimately fails.  Emacs must try each way of grouping the @samp{x}s before concluding that none of them can work.  Even worse, @samp{\\(x*\\)*} can match the null string in infinitely many ways, so it causes an infinite loop.  To avoid these problems, check nested repetitions carefully, to make sure that they do not cause combinatorial explosions in backtracking."
msgstr "@strong{警告:} ネストされた繰り返し処理は、それらが曖昧なマッチとなるような場合には無期限な長時間の実行となり得る。たとえば文字列@samp{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz}にたいして正規表現@samp{\\(x+y*\\)*a}のマッチを試みると、それが最終的に失敗するまでに数時間を要す可能性がある。Emacsはその試みのいずれも機能しないと結論する前に、@samp{x}のグループ化のそれぞれを試みなければならない。さらに悪いことに@samp{\\(x*\\)*}は無数の方法でnull文字列にマッチ可能なので無限ループを引き起こす。これらの問題を避けるにはネストされた繰り返しがバックトラッキングでの組み合わせ爆発(combinatorial explosion)が発生しないことを確実にするために注意深くチェックすること。"

#. type: samp{#1}
#: original_texis/searching.texi:349
#, no-wrap
msgid "+"
msgstr "+"

#. type: cindex
#: original_texis/searching.texi:350
#, no-wrap
msgid "@samp{+} in regexp"
msgstr "@samp{+} in regexp"

#. type: table
#: original_texis/searching.texi:355
msgid "is a postfix operator, similar to @samp{*} except that it must match the preceding expression at least once.  So, for example, @samp{ca+r} matches the strings @samp{car} and @samp{caaaar} but not the string @samp{cr}, whereas @samp{ca*r} matches all three strings."
msgstr "これは@samp{*}のような後置演算子だが前置された表現に少なくとも1回マッチしなければならない点が異なる。たとえば@samp{ca+r}は文字列@samp{car}や@samp{caaaar}にマッチするが文字列@samp{cr}にはマッチせず、その一方で@samp{ca*r}はこれら3つすべての文字列にマッチする。"

#. type: samp{#1}
#: original_texis/searching.texi:356
#, no-wrap
msgid "?"
msgstr "?"

#. type: cindex
#: original_texis/searching.texi:357
#, no-wrap
msgid "@samp{?} in regexp"
msgstr "@samp{?} in regexp"

#. type: table
#: original_texis/searching.texi:361
msgid "is a postfix operator, similar to @samp{*} except that it must match the preceding expression either once or not at all.  For example, @samp{ca?r} matches @samp{car} or @samp{cr}; nothing else."
msgstr "これは@samp{*}のような後置演算子だが前置された表現に1回、またはマッチしないかのいずれかでなければならない点が異なる。例えば@samp{ca?r}は@samp{car}と@samp{cr}にマッチするが他にはマッチしない。"

#. type: item
#: original_texis/searching.texi:362
#, no-wrap
msgid "@samp{*?}, @samp{+?}, @samp{??}"
msgstr "@samp{*?}, @samp{+?}, @samp{??}"

#. type: cindex
#: original_texis/searching.texi:363
#, no-wrap
msgid "non-greedy repetition characters in regexp"
msgstr "non-greedy repetition characters in regexp"

#. type: table
#: original_texis/searching.texi:369
msgid "These are @dfn{non-greedy} variants of the operators @samp{*}, @samp{+} and @samp{?}.  Where those operators match the largest possible substring (consistent with matching the entire containing expression), the non-greedy variants match the smallest possible substring (consistent with matching the entire containing expression)."
msgstr "演算子 @samp{*}、@samp{+}、@samp{?}には@dfn{非欲張り(non-greedy)}な変種が存在する。これらの演算子が可能な最長の部分文字列(含まれる表現全体へのマッチと等しい)とマッチするのにたいして、非欲張りな変種は可能な最短の部分文字列(含まれる表現全体と等しい)にマッチする。"

#. type: table
#: original_texis/searching.texi:375
msgid "For example, the regular expression @samp{c[ad]*a} when applied to the string @samp{cdaaada} matches the whole string; but the regular expression @samp{c[ad]*?a}, applied to that same string, matches just @samp{cda}.  (The smallest possible match here for @samp{[ad]*?} that permits the whole expression to match is @samp{d}.)"
msgstr "たとえば正規表現@samp{c[ad]*a}を文字列@samp{cdaaada}に適用すると文字列全体にマッチするが、正規表現@samp{c[ad]*?a}を同じ文字列に適用すると@samp{cda}だけにマッチする(ここでマッチが許された表現全体にたいする@samp{[ad]*?}の可能な最短マッチは@samp{d})。"

#. type: samp{#1}
#: original_texis/searching.texi:376
#, no-wrap
msgid "[ @dots{} ]"
msgstr "[ @dots{} ]"

#. type: cindex
#: original_texis/searching.texi:377
#, no-wrap
msgid "character alternative (in regexp)"
msgstr "character alternative (in regexp)"

#. type: cindex
#: original_texis/searching.texi:378
#, no-wrap
msgid "@samp{[} in regexp"
msgstr "@samp{[} in regexp"

#. type: cindex
#: original_texis/searching.texi:379
#, no-wrap
msgid "@samp{]} in regexp"
msgstr "@samp{]} in regexp"

#. type: table
#: original_texis/searching.texi:383
msgid "is a @dfn{character alternative}, which begins with @samp{[} and is terminated by @samp{]}.  In the simplest case, the characters between the two brackets are what this character alternative can match."
msgstr "これは@samp{[}で始まり@samp{]}で終端される@dfn{文字候補(character alternative)}。もっとも単純なケースでは、この２つのカッコ(brackets)の間にある文字が、この文字候補がマッチ可能な文字。"

#. type: table
#: original_texis/searching.texi:388
msgid "Thus, @samp{[ad]} matches either one @samp{a} or one @samp{d}, and @samp{[ad]*} matches any string composed of just @samp{a}s and @samp{d}s (including the empty string).  It follows that @samp{c[ad]*r} matches @samp{cr}, @samp{car}, @samp{cdr}, @samp{caddaar}, etc."
msgstr "したがって@samp{[ad]}は1つの@samp{a}と1つの@samp{d}の両方にマッチし、@samp{[ad]*}は@samp{a}と@samp{d}だけで構成された任意の文字列(空文字列を含む)にマッチする。つまり@samp{c[ad]*r}は@samp{cr}、@samp{car}、@samp{cdr}、@samp{caddaar}等にマッチする。"

#. type: table
#: original_texis/searching.texi:395
msgid "You can also include character ranges in a character alternative, by writing the starting and ending characters with a @samp{-} between them.  Thus, @samp{[a-z]} matches any lower-case @acronym{ASCII} letter.  Ranges may be intermixed freely with individual characters, as in @samp{[a-z$%.]}, which matches any lower case @acronym{ASCII} letter or @samp{$}, @samp{%} or period."
msgstr "開始文字と終了文字の間に@samp{-}を記述することにより、文字候補内に文字範囲を含めることができる。つまり@samp{[a-z]}は小文字の@acronym{ASCII}アルファベット文字にマッチする。範囲は@samp{[a-z$%.]}のように個別の文字と自由に組み合わせることができる。これは任意の@acronym{ASCII}小文字アルファベットと@samp{$}、@samp{%}、またはピリオドとマッチする。"

#. type: table
#: original_texis/searching.texi:404
msgid "If @code{case-fold-search} is non-@code{nil}, @samp{[a-z]} also matches upper-case letters.  Note that a range like @samp{[a-z]} is not affected by the locale's collation sequence, it always represents a sequence in @acronym{ASCII} order."
msgstr "@code{case-fold-search}が非@code{nil}なら、@samp{[a-z]}は大文字アルファベットにもマッチする。@samp{[a-z]}のような範囲はそのlocaleの照合順に影響されず、常に@acronym{ASCII}順のシーケンスを表すことに注意。"

#. type: table
#: original_texis/searching.texi:408
msgid "Note also that the usual regexp special characters are not special inside a character alternative.  A completely different set of characters is special inside character alternatives: @samp{]}, @samp{-} and @samp{^}."
msgstr "さらに通常のregexpスペシャル文字は文字候補内では特別ではないことにも注意。文字候補内部では@samp{]}、@samp{-}、@samp{^}という完全に異なる文字セットが特別に扱われる。"

#. type: table
#: original_texis/searching.texi:416
msgid "To include a @samp{]} in a character alternative, you must make it the first character.  For example, @samp{[]a]} matches @samp{]} or @samp{a}.  To include a @samp{-}, write @samp{-} as the first or last character of the character alternative, or put it after a range.  Thus, @samp{[]-]} matches both @samp{]} and @samp{-}.  (As explained below, you cannot use @samp{\\]} to include a @samp{]} inside a character alternative, since @samp{\\} is not special there.)"
msgstr "文字候補内に@samp{]}を含めるには、それを最初の文字にしなければならない。たとえば@samp{[]a]}は@samp{]}と@samp{a}にマッチする。@samp{-}を含めるには文字候補の最初または最後の文字として@samp{-}を記述するか、範囲の後に配置すること。つまり@samp{[]-]}は@samp{]}と@samp{-}の両方にマッチする(以下で説明するように、ここでは@samp{\\}は特別ではないので、文字候補内に@samp{]}を含めるために@samp{\\]}は使用できない)。"

#. type: table
#: original_texis/searching.texi:419
msgid "To include @samp{^} in a character alternative, put it anywhere but at the beginning."
msgstr "文字候補内に@samp{^}を含めるには先頭以外のいずれかの場所に置くこと。"

#. type: table
#: original_texis/searching.texi:427
msgid "If a range starts with a unibyte character @var{c} and ends with a multibyte character @var{c2}, the range is divided into two parts: one spans the unibyte characters @samp{@var{c}..?\\377}, the other the multibyte characters @samp{@var{c1}..@var{c2}}, where @var{c1} is the first character of the charset to which @var{c2} belongs."
msgstr "ある範囲がユニバイト文字@var{c}で始まり、マルチバイト文字@var{c2}で終われば、その範囲は2つの部分に分割される。1つはユニバイト文字@samp{@var{c}..?\\377}、もう1つはマルチバイト文字@samp{@var{c1}..@var{c2}}。ここで@var{c1}は@var{c2}が属する文字セットの最初の文字。"

#. type: table
#: original_texis/searching.texi:434
msgid "A character alternative can also specify named character classes (@pxref{Char Classes}).  This is a POSIX feature.  For example, @samp{[[:ascii:]]} matches any @acronym{ASCII} character.  Using a character class is equivalent to mentioning each of the characters in that class; but the latter is not feasible in practice, since some classes include thousands of different characters."
msgstr "文字候補には名前付き文字クラスも指定できる(@ref{Char Classes}を参照)。これはPOSIXの機能である。たとえば@samp{[[:ascii:]]}は任意の@acronym{ASCII}文字にマッチする。文字クラスの使用は、そのクラス内すべての文字を記述するのと等しい。しかし異なる文字を数千含むクラスもあるので、後者は実際は実現可能ではない。"

#. type: samp{#1}
#: original_texis/searching.texi:435
#, no-wrap
msgid "[^ @dots{} ]"
msgstr "[^ @dots{} ]"

#. type: cindex
#: original_texis/searching.texi:436
#, no-wrap
msgid "@samp{^} in regexp"
msgstr "@samp{^} in regexp"

#. type: table
#: original_texis/searching.texi:441
msgid "@samp{[^} begins a @dfn{complemented character alternative}.  This matches any character except the ones specified.  Thus, @samp{[^a-z0-9A-Z]} matches all characters @emph{except} letters and digits."
msgstr "@samp{[^}は@dfn{補完文字候補(complemented character alternative)}を開始する。これは指定された以外の任意の文字とマッチする。つまり@samp{[^a-z0-9A-Z]}はアルファベットと数字@emph{以外}の、すべての文字にマッチする。"

#. type: table
#: original_texis/searching.texi:445
msgid "@samp{^} is not special in a character alternative unless it is the first character.  The character following the @samp{^} is treated as if it were first (in other words, @samp{-} and @samp{]} are not special there)."
msgstr "@samp{^}は文字クラス内では先頭に記述されない限り特別ではない。@samp{^}に続く文字は、あたかもそれが先頭にあるかのように扱われる(言い換えると@samp{-}や@samp{]}はここでは特別ではない)。"

#. type: table
#: original_texis/searching.texi:449
msgid "A complemented character alternative can match a newline, unless newline is mentioned as one of the characters not to match.  This is in contrast to the handling of regexps in programs such as @code{grep}."
msgstr "マッチしない文字の1つとして改行が記述されていなければ、補完文字候補は改行にマッチできる。これは@code{grep}のようなプログラム内でのregexpの扱いとは対照的である。"

#. type: table
#: original_texis/searching.texi:453
msgid "You can specify named character classes, just like in character alternatives.  For instance, @samp{[^[:ascii:]]} matches any non-@acronym{ASCII} character.  @xref{Char Classes}."
msgstr "文字候補のように名前付き文字クラスを指定できる。たとえば@samp{[^[:ascii:]]}は任意の非@acronym{ASCII}文字にマッチする。@ref{Char Classes}を参照のこと。"

#. type: samp{#1}
#: original_texis/searching.texi:454
#, no-wrap
msgid "^"
msgstr "^"

#. type: cindex
#: original_texis/searching.texi:455
#, no-wrap
msgid "beginning of line in regexp"
msgstr "beginning of line in regexp"

#. type: table
#: original_texis/searching.texi:461
msgid "When matching a buffer, @samp{^} matches the empty string, but only at the beginning of a line in the text being matched (or the beginning of the accessible portion of the buffer).  Otherwise it fails to match anything.  Thus, @samp{^foo} matches a @samp{foo} that occurs at the beginning of a line."
msgstr "バッファーのマッチングの際には@samp{^}は空文字列、ただしマッチ対象のテキスト内にある行の先頭(またはバッファーのアクセス可能範囲の先頭)だけにマッチする。それ以外のマッチはすべて失敗する。つまり@samp{^foo}は行の先頭に出現する@samp{foo}にマッチする。"

#. type: table
#: original_texis/searching.texi:464
msgid "When matching a string instead of a buffer, @samp{^} matches at the beginning of the string or after a newline character."
msgstr "バッファーではなく文字列とマッチする際には、@samp{^}は文字列の先頭か改行文字の後にマッチする。"

#. type: table
#: original_texis/searching.texi:468
msgid "For historical compatibility reasons, @samp{^} can be used only at the beginning of the regular expression, or after @samp{\\(}, @samp{\\(?:} or @samp{\\|}."
msgstr "歴史的な互換性という理由により@samp{^}は正規表現の先頭、または@samp{\\(}、@samp{\\(?:}、@samp{\\|}の後でのみ使用できる。"

#. type: samp{#1}
#: original_texis/searching.texi:469
#, no-wrap
msgid "$"
msgstr "$"

#. type: cindex
#: original_texis/searching.texi:470
#, no-wrap
msgid "@samp{$} in regexp"
msgstr "@samp{$} in regexp"

#. type: cindex
#: original_texis/searching.texi:471
#, no-wrap
msgid "end of line in regexp"
msgstr "end of line in regexp"

#. type: table
#: original_texis/searching.texi:475
msgid "is similar to @samp{^} but matches only at the end of a line (or the end of the accessible portion of the buffer).  Thus, @samp{x+$} matches a string of one @samp{x} or more at the end of a line."
msgstr "これは@samp{^}と似ているが、行の終端(またはバッファーのアクセス可能範囲の終端)だけにマッチする。つまり@samp{x+$}は行末にある1つ以上の@samp{x}からなる文字列にマッチする。"

#. type: table
#: original_texis/searching.texi:478
msgid "When matching a string instead of a buffer, @samp{$} matches at the end of the string or before a newline character."
msgstr "バッファーではなく文字列とマッチする際には、@samp{$}は文字列の終端か改行文字の前にマッチする。"

#. type: table
#: original_texis/searching.texi:481
msgid "For historical compatibility reasons, @samp{$} can be used only at the end of the regular expression, or before @samp{\\)} or @samp{\\|}."
msgstr "歴史的な互換性という理由により@samp{$}は正規表現の先頭、または@samp{\\(}、@samp{\\(?:}、@samp{\\|}の前でのみ使用できる。"

#. type: samp{#1}
#: original_texis/searching.texi:482
#, no-wrap
msgid "\\"
msgstr "\\"

#. type: cindex
#: original_texis/searching.texi:483
#, no-wrap
msgid "@samp{\\} in regexp"
msgstr "@samp{\\} in regexp"

#. type: table
#: original_texis/searching.texi:486
msgid "has two functions: it quotes the special characters (including @samp{\\}), and it introduces additional special constructs."
msgstr "これはスペシャル文字(@samp{\\}を含む)のクォートと、追加のスペシャル文字の導入という2つの機能をもつ。"

#. type: table
#: original_texis/searching.texi:490
msgid "Because @samp{\\} quotes special characters, @samp{\\$} is a regular expression that matches only @samp{$}, and @samp{\\[} is a regular expression that matches only @samp{[}, and so on."
msgstr "@samp{\\}はスペシャル文字をクォートするので@samp{\\$}は@samp{$}、@samp{\\[}は@samp{[}だけにマッチする正規表現のようになる。"

#. type: table
#: original_texis/searching.texi:498
msgid "Note that @samp{\\} also has special meaning in the read syntax of Lisp strings (@pxref{String Type}), and must be quoted with @samp{\\}.  For example, the regular expression that matches the @samp{\\} character is @samp{\\\\}.  To write a Lisp string that contains the characters @samp{\\\\}, Lisp syntax requires you to quote each @samp{\\} with another @samp{\\}.  Therefore, the read syntax for a regular expression matching @samp{\\} is @code{\"\\\\\\\\\"}."
msgstr "@samp{\\}はLisp文字列(@ref{String Type}を参照)の入力構文(read syntax)内でも特別な意味をもち、@samp{\\}でクォートしなければならないことに注意。たとえば文字@samp{\\}にマッチする正規表現は@samp{\\\\}。文字@samp{\\\\}を含むLisp文字列を記述するには、別の@samp{\\\\}で@samp{\\\\}をクォートすることをLisp構文は要求する。したがって@samp{\\}にマッチする正規表現にたいする入力構文は@code{\"\\\\\\\\\"}となる。"

#. type: Plain text
#: original_texis/searching.texi:506
msgid "@strong{Please note:} For historical compatibility, special characters are treated as ordinary ones if they are in contexts where their special meanings make no sense.  For example, @samp{*foo} treats @samp{*} as ordinary since there is no preceding expression on which the @samp{*} can act.  It is poor practice to depend on this behavior; quote the special character anyway, regardless of where it appears."
msgstr "@strong{注意してください:} 歴史的な互換性のために、スペシャル文字はそれらがもつ特別な意味が意味を成さないコンテキスト内にある場合には通常の文字として扱われます。たとえば@samp{*foo}は@samp{*}が作用可能な前置された表現がないので、通常の@samp{*}として扱われます。この挙動に依存するのは悪い習慣です。どこにそれが出現しようとスペシャル文字はすべてクォートしてください。"

#. type: Plain text
#: original_texis/searching.texi:514
msgid "As a @samp{\\} is not special inside a character alternative, it can never remove the special meaning of @samp{-} or @samp{]}.  So you should not quote these characters when they have no special meaning either.  This would not clarify anything, since backslashes can legitimately precede these characters where they @emph{have} special meaning, as in @samp{[^\\]} (@code{\"[^\\\\]\"} for Lisp string syntax), which matches any single character except a backslash."
msgstr "文字候補内で@samp{\\}は何ら特別ではないので、@samp{-}や@samp{]}の特別な意味を取り除くことは決してありません。特別な意味をもたないような場合でも、これらの文字をクォートするべきではありません。バックスラッシュ以外の任意の1文字にマッチする@samp{[^\\]} (Lisp文字列構文では@code{\"[^\\\\]\"})内でのように、これらの文字が@emph{特別な意味}をもつ箇所では、これらの文字にバックスラッシュを前置することには正当性があるので、何もそれほど明解にはしないでしょう。"

#. type: Plain text
#: original_texis/searching.texi:524
msgid "In practice, most @samp{]} that occur in regular expressions close a character alternative and hence are special.  However, occasionally a regular expression may try to match a complex pattern of literal @samp{[} and @samp{]}.  In such situations, it sometimes may be necessary to carefully parse the regexp from the start to determine which square brackets enclose a character alternative.  For example, @samp{[^][]]} consists of the complemented character alternative @samp{[^][]} (which matches any single character that is not a square bracket), followed by a literal @samp{]}."
msgstr "実際には正規表現内に出現する@samp{]}は文字候補に近接しており、それ故そのほとんどがスペシャル文字です。しかしリテラルの@samp{[}と@samp{]}の複雑なパターンにたいしてマッチを試みることも時にはあるかもしれません。そのような状況では文字候補を囲う角カッコがどれなのかを判断するために、regexpを最初から注意深く解析することが必要なときもあるかもしれません。たとえば@samp{[^][]]}は補完文字候補@samp{[^][]} (角カッコ以外の任意の1文字とマッチする)と、その後のリテラルの@samp{]}により構成されます。"

#. type: Plain text
#: original_texis/searching.texi:534
msgid "The exact rules are that at the beginning of a regexp, @samp{[} is special and @samp{]} not.  This lasts until the first unquoted @samp{[}, after which we are in a character alternative; @samp{[} is no longer special (except when it starts a character class) but @samp{]} is special, unless it immediately follows the special @samp{[} or that @samp{[} followed by a @samp{^}.  This lasts until the next special @samp{]} that does not end a character class.  This ends the character alternative and restores the ordinary syntax of regular expressions; an unquoted @samp{[} is special again and a @samp{]} not."
msgstr "厳密にはregexp先頭の@samp{[}は特別で、@samp{]}は特別ではないというのがルールです。これはクォートされていない最初の@samp{[}で終わり、その後は文字候補になります。(文字クラス開始を除き)@samp{[}はもはや特別ではありませんが、@samp{]}は直後にスペシャル文字@samp{[}があるか、その@samp{[}の後に@samp{^}がある場合を除いて特別です。これは文字クラス終了ではない次のスペシャル文字@samp{]}まで続きます。これは文字候補を終了させて、通常の正規表現の構文をリストアします。クォートされていない@samp{[}は再び特別となり、@samp{]}は特別ではなくなります。"

#. type: subsubsection
#: original_texis/searching.texi:536
#, no-wrap
msgid "Character Classes"
msgstr "Character Classes"

#. type: cindex
#: original_texis/searching.texi:537
#, no-wrap
msgid "character classes in regexp"
msgstr "character classes in regexp"

#. type: Plain text
#: original_texis/searching.texi:541
msgid "Here is a table of the classes you can use in a character alternative, and what they mean:"
msgstr "以下は文字候補内で使用できるクラスと、その意味についてのテーブルです:"

#. type: item
#: original_texis/searching.texi:543
#, no-wrap
msgid "[:ascii:]"
msgstr "[:ascii:]"

#. type: table
#: original_texis/searching.texi:545
msgid "This matches any @acronym{ASCII} character (codes 0--127)."
msgstr "これは任意の@acronym{ASCII}文字(コード0 -- 127)にマッチする。"

#. type: item
#: original_texis/searching.texi:545
#, no-wrap
msgid "[:alnum:]"
msgstr "[:alnum:]"

#. type: table
#: original_texis/searching.texi:550
msgid "This matches any letter or digit.  For multibyte characters, it matches characters whose Unicode @samp{general-category} property (@pxref{Character Properties}) indicates they are alphabetic or decimal number characters."
msgstr "これは任意の英数字にマッチする。マルチバイト文字では、アルファベット文字か数字であることを示すUnicodeプロパティ@samp{general-category} (@ref{Character Properties}を参照)をもつ文字にマッチする。"

#. type: item
#: original_texis/searching.texi:550
#, no-wrap
msgid "[:alpha:]"
msgstr "[:alpha:]"

#. type: table
#: original_texis/searching.texi:555
msgid "This matches any letter.  For multibyte characters, it matches characters whose Unicode @samp{general-category} property (@pxref{Character Properties}) indicates they are alphabetic characters."
msgstr "これは任意のアルファベットにマッチする。マルチバイト文字では、アルファベット文字であることを示すUnicodeプロパティ@samp{general-category} (@ref{Character Properties}を参照)をもつ文字にマッチする。"

#. type: item
#: original_texis/searching.texi:555
#, no-wrap
msgid "[:blank:]"
msgstr "[:blank:]"

#. type: table
#: original_texis/searching.texi:557
msgid "This matches space and tab only."
msgstr "これはスペースとタブだけにマッチする。"

#. type: item
#: original_texis/searching.texi:557
#, no-wrap
msgid "[:cntrl:]"
msgstr "[:cntrl:]"

#. type: table
#: original_texis/searching.texi:559
msgid "This matches any @acronym{ASCII} control character."
msgstr "これは@acronym{ASCII}制御文字にマッチする。"

#. type: item
#: original_texis/searching.texi:559
#, no-wrap
msgid "[:digit:]"
msgstr "[:digit:]"

#. type: table
#: original_texis/searching.texi:562
msgid "This matches @samp{0} through @samp{9}.  Thus, @samp{[-+[:digit:]]} matches any digit, as well as @samp{+} and @samp{-}."
msgstr "これは@samp{0}から@samp{9}までにマッチする。つまり@samp{[-+[:digit:]]}は@samp{+}と@samp{-}、同様に任意の数にマッチする。"

#. type: item
#: original_texis/searching.texi:562
#, no-wrap
msgid "[:graph:]"
msgstr "[:graph:]"

#. type: table
#: original_texis/searching.texi:568
msgid "This matches graphic characters---everything except whitespace, @acronym{ASCII} and non-@acronym{ASCII} control characters, surrogates, and codepoints unassigned by Unicode, as indicated by the Unicode @samp{general-category} property (@pxref{Character Properties})."
msgstr "これはUnicodeの@samp{general-category}プロパティで示されるようなグラフィック文字(空白文字、@acronym{ASCII}と非@acronym{ASCII}の制御文字、サロゲートードポイント、Unicodeで未割り当てのコードポイントを除くすべて)にマッチする(@ref{Character Properties}を参照)。"

#. type: item
#: original_texis/searching.texi:568
#, no-wrap
msgid "[:lower:]"
msgstr "[:lower:]"

#. type: table
#: original_texis/searching.texi:572
msgid "This matches any lower-case letter, as determined by the current case table (@pxref{Case Tables}).  If @code{case-fold-search} is non-@code{nil}, this also matches any upper-case letter."
msgstr "これはカレントのcaseテーブル(@ref{Case Tables}を参照)で小文字と判断される文字すべてにマッチする。@code{case-fold-search}が非@code{nil}なら大文字にもマッチする。"

#. type: item
#: original_texis/searching.texi:572
#, no-wrap
msgid "[:multibyte:]"
msgstr "[:multibyte:]"

#. type: table
#: original_texis/searching.texi:574
msgid "This matches any multibyte character (@pxref{Text Representations})."
msgstr "これは任意のマルチバイト文字にマッチする(@ref{Text Representations}を参照)。"

#. type: item
#: original_texis/searching.texi:574
#, no-wrap
msgid "[:nonascii:]"
msgstr "[:nonascii:]"

#. type: table
#: original_texis/searching.texi:576
msgid "This matches any non-@acronym{ASCII} character."
msgstr "これは非@acronym{ASCII}文字にマッチする。"

#. type: item
#: original_texis/searching.texi:576
#, no-wrap
msgid "[:print:]"
msgstr "[:print:]"

#. type: table
#: original_texis/searching.texi:579
msgid "This matches any printing character---either whitespace, or a graphic character matched by @samp{[:graph:]}."
msgstr "これは任意のプリント文字(空白文字か@samp{[:graph:]}でマッチされるグラフィック文字のいずれか)にマッチする。"

#. type: item
#: original_texis/searching.texi:579
#, no-wrap
msgid "[:punct:]"
msgstr "[:punct:]"

#. type: table
#: original_texis/searching.texi:582
msgid "This matches any punctuation character.  (At present, for multibyte characters, it matches anything that has non-word syntax.)"
msgstr "これは任意の句読点文字(punctuation character)にマッチする(現在のところマルチバイト文字では単語構文以外のすべてにマッチする)。"

#. type: item
#: original_texis/searching.texi:582
#, no-wrap
msgid "[:space:]"
msgstr "[:space:]"

#. type: table
#: original_texis/searching.texi:585
msgid "This matches any character that has whitespace syntax (@pxref{Syntax Class Table})."
msgstr "これは空白文字構文(@ref{Syntax Class Table}を参照)をもつ任意の文字にマッチする。"

#. type: item
#: original_texis/searching.texi:585
#, no-wrap
msgid "[:unibyte:]"
msgstr "[:unibyte:]"

#. type: table
#: original_texis/searching.texi:587
msgid "This matches any unibyte character (@pxref{Text Representations})."
msgstr "これは任意のユニバイト文字(@ref{Text Representations}を参照)にマッチする。"

#. type: item
#: original_texis/searching.texi:587
#, no-wrap
msgid "[:upper:]"
msgstr "[:upper:]"

#. type: table
#: original_texis/searching.texi:591
msgid "This matches any upper-case letter, as determined by the current case table (@pxref{Case Tables}).  If @code{case-fold-search} is non-@code{nil}, this also matches any lower-case letter."
msgstr "これはカレントのcaseテーブル(@ref{Case Tables}を参照)で大文字と判断される文字すべてにマッチする。@code{case-fold-search}が非@code{nil}ならこれは小文字にもマッチする。"

#. type: item
#: original_texis/searching.texi:591
#, no-wrap
msgid "[:word:]"
msgstr "[:word:]"

#. type: table
#: original_texis/searching.texi:594
msgid "This matches any character that has word syntax (@pxref{Syntax Class Table})."
msgstr "これは単語構文(@ref{Syntax Class Table}を参照)をもつ任意の文字にマッチする。"

#. type: item
#: original_texis/searching.texi:594
#, no-wrap
msgid "[:xdigit:]"
msgstr "[:xdigit:]"

#. type: table
#: original_texis/searching.texi:597
msgid "This matches the hexadecimal digits: @samp{0} through @samp{9}, @samp{a} through @samp{f} and @samp{A} through @samp{F}."
msgstr "これは16進数の数字@samp{0}から@samp{9}、@samp{a}から@samp{f}と@samp{A}から@samp{F}にマッチする。"

#. type: subsubsection
#: original_texis/searching.texi:600
#, no-wrap
msgid "Backslash Constructs in Regular Expressions"
msgstr "Backslash Constructs in Regular Expressions"

#. type: cindex
#: original_texis/searching.texi:601
#, no-wrap
msgid "backslash in regular expressions"
msgstr "backslash in regular expressions"

#. type: Plain text
#: original_texis/searching.texi:607
msgid "For the most part, @samp{\\} followed by any character matches only that character.  However, there are several exceptions: certain sequences starting with @samp{\\} that have special meanings.  Here is a table of the special @samp{\\} constructs."
msgstr "ほとんどの場合では、@samp{\\}の後の任意の文字はその文字だけにマッチします。しかし例外もいくつかあります。@samp{\\}で始まる特定のシーケンスには、特別な意味をもつものがあります。以下は特別な@samp{\\}構成要素のテーブルです。"

#. type: item
#: original_texis/searching.texi:609
#, no-wrap
msgid "\\|"
msgstr "\\|"

#. type: cindex
#: original_texis/searching.texi:610
#, no-wrap
msgid "@samp{|} in regexp"
msgstr "@samp{|} in regexp"

#. type: cindex
#: original_texis/searching.texi:611
#, no-wrap
msgid "regexp alternative"
msgstr "regexp alternative"

#. type: table
#: original_texis/searching.texi:616
msgid "specifies an alternative.  Two regular expressions @var{a} and @var{b} with @samp{\\|} in between form an expression that matches anything that either @var{a} or @var{b} matches."
msgstr "これは選択肢を指定する。2つの正規表現@var{a}と@var{b}、その間にある@samp{\\|}により、@var{a}か@var{b}のいずれかにマッチする表現が形成される。"

#. type: table
#: original_texis/searching.texi:619
msgid "Thus, @samp{foo\\|bar} matches either @samp{foo} or @samp{bar} but no other string."
msgstr "つまり@samp{foo\\|bar}は、@samp{foo}か@samp{bar}のいずれかにマッチして他の文字列にはマッチしない。"

#. type: table
#: original_texis/searching.texi:623
msgid "@samp{\\|} applies to the largest possible surrounding expressions.  Only a surrounding @samp{\\( @dots{} \\)} grouping can limit the grouping power of @samp{\\|}."
msgstr "@samp{\\|}は周囲の適用可能な最大の表現に適用される。@samp{\\|}を取り囲む@samp{\\( @dots{} \\)}でグループ化することによりグループ化の効力を制限できる。"

#. type: table
#: original_texis/searching.texi:627
msgid "If you need full backtracking capability to handle multiple uses of @samp{\\|}, use the POSIX regular expression functions (@pxref{POSIX Regexps})."
msgstr "複数の@samp{\\|}の処理するための完全なバックトラッキング互換が必要なら、POSIX正規表現関数を使用すること(@ref{POSIX Regexps}を参照)。"

#. type: item
#: original_texis/searching.texi:628
#, no-wrap
msgid "\\@{@var{m}\\@}"
msgstr "\\@{@var{m}\\@}"

#. type: table
#: original_texis/searching.texi:633
msgid "is a postfix operator that repeats the previous pattern exactly @var{m} times.  Thus, @samp{x\\@{5\\@}} matches the string @samp{xxxxx} and nothing else.  @samp{c[ad]\\@{3\\@}r} matches string such as @samp{caaar}, @samp{cdddr}, @samp{cadar}, and so on."
msgstr "これは前のパターンを正確に@var{m}回繰り返す後置演算子。つまり@samp{x\\@{5\\@}}は文字列@samp{xxxxx}にマッチして、それ以外にはマッチしない。@samp{c[ad]\\@{3\\@}r}は@samp{caaar}、@samp{cdddr}、@samp{cadar}等にマッチする。"

#. type: item
#: original_texis/searching.texi:634
#, no-wrap
msgid "\\@{@var{m},@var{n}\\@}"
msgstr "\\@{@var{m},@var{n}\\@}"

#. type: table
#: original_texis/searching.texi:639
msgid "is a more general postfix operator that specifies repetition with a minimum of @var{m} repeats and a maximum of @var{n} repeats.  If @var{m} is omitted, the minimum is 0; if @var{n} is omitted, there is no maximum."
msgstr "これは最小で@var{m}回、最大で@var{n}回の繰り返しを表す、より一般的な後置演算子。@var{m}省略時の最小は0、@var{n}省略時の最大は存在しない。"

#. type: table
#: original_texis/searching.texi:646
msgid "For example, @samp{c[ad]\\@{1,2\\@}r} matches the strings @samp{car}, @samp{cdr}, @samp{caar}, @samp{cadr}, @samp{cdar}, and @samp{cddr}, and nothing else.@* @samp{\\@{0,1\\@}} or @samp{\\@{,1\\@}} is equivalent to @samp{?}.@* @samp{\\@{0,\\@}} or @samp{\\@{,\\@}} is equivalent to @samp{*}.@* @samp{\\@{1,\\@}} is equivalent to @samp{+}."
msgstr "たとえば@samp{c[ad]\\@{1,2\\@}r}は文字列@samp{car}、@samp{cdr}、@samp{caar}、@samp{cadr}、@samp{cdar}、@samp{cddr}にマッチして、それ以外にはマッチしない。@*@samp{\\@{0,1\\@}}や@samp{\\@{,1\\@}}は@samp{?}と同じ。@*@samp{\\@{0,\\@}}や@samp{\\@{,\\@}}は@samp{*}と同じ。@*@samp{\\@{1,\\@}}は@samp{+}と同じ。"

#. type: item
#: original_texis/searching.texi:647
#, no-wrap
msgid "\\( @dots{} \\)"
msgstr "\\( @dots{} \\)"

#. type: cindex
#: original_texis/searching.texi:648
#, no-wrap
msgid "@samp{(} in regexp"
msgstr "@samp{(} in regexp"

#. type: cindex
#: original_texis/searching.texi:649
#, no-wrap
msgid "@samp{)} in regexp"
msgstr "@samp{)} in regexp"

#. type: cindex
#: original_texis/searching.texi:650
#, no-wrap
msgid "regexp grouping"
msgstr "regexp grouping"

#. type: table
#: original_texis/searching.texi:652
msgid "is a grouping construct that serves three purposes:"
msgstr "これは以下の3つの目的を果たす役目をもつグループ化構成要素:"

#. type: enumerate
#: original_texis/searching.texi:658
msgid "To enclose a set of @samp{\\|} alternatives for other operations.  Thus, the regular expression @samp{\\(foo\\|bar\\)x} matches either @samp{foox} or @samp{barx}."
msgstr "他の操作のために一連の@samp{\\|}選択肢を囲う。つまり正規表現@samp{\\(foo\\|bar\\)x}は、@samp{foox}か@samp{barx}のいずれかにマッチする。"

#. type: enumerate
#: original_texis/searching.texi:664
msgid "To enclose a complicated expression for the postfix operators @samp{*}, @samp{+} and @samp{?} to operate on.  Thus, @samp{ba\\(na\\)*} matches @samp{ba}, @samp{bana}, @samp{banana}, @samp{bananana}, etc., with any number (zero or more) of @samp{na} strings."
msgstr "後置演算子@samp{*}、@samp{+}、@samp{?}による複雑な表現を囲う。つまり@samp{ba\\(na\\)*}は@samp{ba}、@samp{bana}、@samp{banana}、@samp{bananana}、...等の任意の数(0以上)の文字列@samp{na}にマッチする。"

#. type: enumerate
#: original_texis/searching.texi:668
msgid "To record a matched substring for future reference with @samp{\\@var{digit}} (see below)."
msgstr "@samp{\\@var{digit}} (以下参照)による将来の参照にたいして、マッチする部分文字列を記録する。"

#. type: table
#: original_texis/searching.texi:676
msgid "This last application is not a consequence of the idea of a parenthetical grouping; it is a separate feature that was assigned as a second meaning to the same @samp{\\( @dots{} \\)} construct because, in practice, there was usually no conflict between the two meanings.  But occasionally there is a conflict, and that led to the introduction of shy groups."
msgstr "この最後の目的はカッコによるグループ化というアイデアによるものではない。これは同じ構成要素@samp{\\( @dots{} \\)}にたいする2つ目の目的に割当てられた別の機能だが、実際のところ2つの意味は衝突しない。しかし稀に衝突が発生することがあり、それが内気(shy)なグループの導入をもたらした。"

#. type: item
#: original_texis/searching.texi:677
#, no-wrap
msgid "\\(?: @dots{} \\)"
msgstr "\\(?: @dots{} \\)"

#. type: cindex
#: original_texis/searching.texi:678
#, no-wrap
msgid "shy groups"
msgstr "shy groups"

#. type: cindex
#: original_texis/searching.texi:679
#, no-wrap
msgid "non-capturing group"
msgstr "non-capturing group"

#. type: cindex
#: original_texis/searching.texi:680
#, no-wrap
msgid "unnumbered group"
msgstr "unnumbered group"

#. type: cindex
#: original_texis/searching.texi:681
#, no-wrap
msgid "@samp{(?:} in regexp"
msgstr "@samp{(?:} in regexp"

#. type: table
#: original_texis/searching.texi:689
msgid "is the @dfn{shy group} construct.  A shy group serves the first two purposes of an ordinary group (controlling the nesting of other operators), but it does not get a number, so you cannot refer back to its value with @samp{\\@var{digit}}.  Shy groups are particularly useful for mechanically-constructed regular expressions, because they can be added automatically without altering the numbering of ordinary, non-shy groups."
msgstr "これは@dfn{内気なグループ(shy group)}の構成要素。内気なグループは通常のグループの最初の2つの役目(他の演算子のネスト制御)を果たすが、これは番号を取得せず@samp{\\@var{digit}}でその値を後方参照できない。内気なグループは通常の非内気なグループを変更することなく自動的に追加できるので、機械的に正規表現を構築するのに特に適している。"

#. type: table
#: original_texis/searching.texi:692
msgid "Shy groups are also called @dfn{non-capturing} or @dfn{unnumbered groups}."
msgstr "内気なグループ化は@dfn{非キャプチャリング(non-capturing)}、@dfn{番号なしグループ(unnumbered groups)}とも呼ばれる。"

#. type: item
#: original_texis/searching.texi:693
#, no-wrap
msgid "\\(?@var{num}: @dots{} \\)"
msgstr "\\(?@var{num}: @dots{} \\)"

#. type: table
#: original_texis/searching.texi:702
msgid "is the @dfn{explicitly numbered group} construct.  Normal groups get their number implicitly, based on their position, which can be inconvenient.  This construct allows you to force a particular group number.  There is no particular restriction on the numbering, e.g., you can have several groups with the same number in which case the last one to match (i.e., the rightmost match) will win.  Implicitly numbered groups always get the smallest integer larger than the one of any previous group."
msgstr "これは@dfn{明示的番号付きグループ(explicitly numbered group)}の構成要素。通常のグループ化では位置をもとに番号が暗黙で取得されるが、これが不便な場合もあるだろう。この構成要素により特定のグループに番号を強制できる。番号の付与に特別な制限はなく、複数のグループに同じ番号を付与でき、その場合は最後の1つ(もっとも右のマッチ)がマッチとして採用される。暗黙に番号付けされたグループは、常に前のグループより大きい最小の整数となる番号を取得する。"

#. type: item
#: original_texis/searching.texi:703
#, no-wrap
msgid "\\@var{digit}"
msgstr "\\@var{digit}"

#. type: table
#: original_texis/searching.texi:706
msgid "matches the same text that matched the @var{digit}th occurrence of a grouping (@samp{\\( @dots{} \\)}) construct."
msgstr "これはグループ構成要素(@samp{\\( @dots{} \\)})の@var{digit}番目にマッチしたテキストと同じテキストにマッチする。"

#. type: table
#: original_texis/searching.texi:711
msgid "In other words, after the end of a group, the matcher remembers the beginning and end of the text matched by that group.  Later on in the regular expression you can use @samp{\\} followed by @var{digit} to match that same text, whatever it may have been."
msgstr "言い換えると最後のグループの後に、マッチ処理はそのグループによりマッチされたテキストの開始と終了を記憶する。その正規表現の先の箇所で@samp{\\}とその後に@var{digit}を使用すれば、それが何であれ同じテキストにマッチさせることができる。"

#. type: table
#: original_texis/searching.texi:718
msgid "The strings matching the first nine grouping constructs appearing in the entire regular expression passed to a search or matching function are assigned numbers 1 through 9 in the order that the open parentheses appear in the regular expression.  So you can use @samp{\\1} through @samp{\\9} to refer to the text matched by the corresponding grouping constructs."
msgstr "検索やマッチングを行う関数に渡される正規表現全体の中で、最初の9つのグループ化構成要素にマッチする文字列には、その正規表現内で開カッコが出現する順に1から9までの番号が割り当てられる。したがって@samp{\\1}から@samp{\\9}までを使用して、対応するグループ化構成要素によりマッチされたテキストを参照できる。"

#. type: table
#: original_texis/searching.texi:723
msgid "For example, @samp{\\(.*\\)\\1} matches any newline-free string that is composed of two identical halves.  The @samp{\\(.*\\)} matches the first half, which may be anything, but the @samp{\\1} that follows must match the same exact text."
msgstr "たとえば@samp{\\(.*\\)\\1}は、一方がもう一方と等しいような2つの文字列から構成される、改行を含まない任意の文字列にマッチする。@samp{\\(.*\\)}は前半分にマッチし、これは何でもよいが、それに続く@samp{\\1}はそれと同じテキストに正確にマッチしなければならない。"

#. type: table
#: original_texis/searching.texi:727
msgid "If a @samp{\\( @dots{} \\)} construct matches more than once (which can happen, for instance, if it is followed by @samp{*}), only the last match is recorded."
msgstr "構成要素@samp{\\( @dots{} \\)}が2回以上マッチする場合(これはたとえば後に@samp{*}をしたがえるとき発生し得る)には最後のマッチだけが記録される。"

#. type: table
#: original_texis/searching.texi:737
msgid "If a particular grouping construct in the regular expression was never matched---for instance, if it appears inside of an alternative that wasn't used, or inside of a repetition that repeated zero times---then the corresponding @samp{\\@var{digit}} construct never matches anything.  To use an artificial example, @samp{\\(foo\\(b*\\)\\|lose\\)\\2} cannot match @samp{lose}: the second alternative inside the larger group matches it, but then @samp{\\2} is undefined and can't match anything.  But it can match @samp{foobb}, because the first alternative matches @samp{foob} and @samp{\\2} matches @samp{b}."
msgstr "正規表現内の特定のグループ化構成要素がマッチしなかった場合には、たとえばそれが使用されない選択肢内にあったり、回数が0回の繰り返しの内部にあるなら、それに対応する@samp{\\@var{digit}}構文は何にもマッチしない。作為的な例を用いると@samp{\\(foo\\(b*\\)\\|lose\\)\\2}は@samp{lose}にマッチできない。外側のグループ内の2つ目の選択肢がマッチするが、@samp{\\2}が未定義となり何にたいしてもマッチできない。しかし@samp{foobb}にたいしては、1つ目の選択肢が@samp{foob}にマッチして、@samp{\\2}が@samp{b}にマッチするのでマッチが可能になる。"

#. type: item
#: original_texis/searching.texi:738
#, no-wrap
msgid "\\w"
msgstr "\\w"

#. type: cindex
#: original_texis/searching.texi:739
#, no-wrap
msgid "@samp{\\w} in regexp"
msgstr "@samp{\\w} in regexp"

#. type: table
#: original_texis/searching.texi:742
msgid "matches any word-constituent character.  The editor syntax table determines which characters these are.  @xref{Syntax Tables}."
msgstr "これは任意の単語構成文字にマッチする。エディターの構文テーブルが、どの文字が単語構成文字かを決定する。@ref{Syntax Tables}を参照のこと。"

#. type: item
#: original_texis/searching.texi:743
#, no-wrap
msgid "\\W"
msgstr "\\W"

#. type: cindex
#: original_texis/searching.texi:744
#, no-wrap
msgid "@samp{\\W} in regexp"
msgstr "@samp{\\W} in regexp"

#. type: table
#: original_texis/searching.texi:746
msgid "matches any character that is not a word constituent."
msgstr "これは任意の非単語構成文字にマッチする。"

#. type: item
#: original_texis/searching.texi:747
#, no-wrap
msgid "\\s@var{code}"
msgstr "\\s@var{code}"

#. type: cindex
#: original_texis/searching.texi:748
#, no-wrap
msgid "@samp{\\s} in regexp"
msgstr "@samp{\\s} in regexp"

#. type: table
#: original_texis/searching.texi:755
msgid "matches any character whose syntax is @var{code}.  Here @var{code} is a character that represents a syntax code: thus, @samp{w} for word constituent, @samp{-} for whitespace, @samp{(} for open parenthesis, etc.  To represent whitespace syntax, use either @samp{-} or a space character.  @xref{Syntax Class Table}, for a list of syntax codes and the characters that stand for them."
msgstr "これは構文が@var{code}であるような任意の文字にマッチする。ここで@var{code}は、構文コードを表す文字。@samp{w}は単語構成要素、@samp{-}は空白文字、@samp{(}は開カッコ、...等。空白文字構文を表すには、@samp{-}かスペース文字のいずれかを使用する。構文コードとそれらを意味する文字のリストは@ref{Syntax Class Table}を参照のこと。"

#. type: item
#: original_texis/searching.texi:756
#, no-wrap
msgid "\\S@var{code}"
msgstr "\\S@var{code}"

#. type: cindex
#: original_texis/searching.texi:757
#, no-wrap
msgid "@samp{\\S} in regexp"
msgstr "@samp{\\S} in regexp"

#. type: table
#: original_texis/searching.texi:759
msgid "matches any character whose syntax is not @var{code}."
msgstr "これは構文が@var{code}でないような任意の文字にマッチする。"

#. type: cindex
#: original_texis/searching.texi:760
#, no-wrap
msgid "category, regexp search for"
msgstr "category, regexp search for"

#. type: item
#: original_texis/searching.texi:761
#, no-wrap
msgid "\\c@var{c}"
msgstr "\\c@var{c}"

#. type: table
#: original_texis/searching.texi:769
msgid "matches any character whose category is @var{c}.  Here @var{c} is a character that represents a category: thus, @samp{c} for Chinese characters or @samp{g} for Greek characters in the standard category table.  You can see the list of all the currently defined categories with @kbd{M-x describe-categories @key{RET}}.  You can also define your own categories in addition to the standard ones using the @code{define-category} function (@pxref{Categories})."
msgstr "これはカテゴリーが@var{c}であるような任意の文字にマッチする。ここで@var{c}はカテゴリーを表す文字。つまり標準カテゴリーテーブルで@samp{c}はChinese(中国語)、@samp{g}はGreek(ギリシャ語)の文字となる。@kbd{M-x describe-categories @key{RET}}で現在定義済みの全カテゴリーのリストを確認できる。@code{define-category}関数を使用すれば、標準カテゴリーに加えてカテゴリーを独自に定義することもできる(@ref{Categories}を参照)。"

#. type: item
#: original_texis/searching.texi:770
#, no-wrap
msgid "\\C@var{c}"
msgstr "\\C@var{c}"

#. type: table
#: original_texis/searching.texi:772
msgid "matches any character whose category is not @var{c}."
msgstr "これはカテゴリーが@var{c}ではない任意の文字にマッチする。"

#. type: Plain text
#: original_texis/searching.texi:779
msgid "The following regular expression constructs match the empty string---that is, they don't use up any characters---but whether they match depends on the context.  For all, the beginning and end of the accessible portion of the buffer are treated as if they were the actual beginning and end of the buffer."
msgstr "以下は空文字列にマッチ(つまり文字を何も消費しない)しますが、マッチするかどうかはコンテキストに依存するような正規表現を構築します。これらすべてにたいして、そのバッファーのアクセス可能範囲の先頭と終端は、あたかもそのバッファーの実際の先頭と終端のように扱われます。"

#. type: item
#: original_texis/searching.texi:781
#, no-wrap
msgid "\\`"
msgstr "\\`"

#. type: cindex
#: original_texis/searching.texi:782
#, no-wrap
msgid "@samp{\\`} in regexp"
msgstr "@samp{\\`} in regexp"

#. type: table
#: original_texis/searching.texi:785
msgid "matches the empty string, but only at the beginning of the buffer or string being matched against."
msgstr "これは空文字列、ただしバッファー先頭またはマッチ対象の文字列の先頭だけにマッチする。"

#. type: item
#: original_texis/searching.texi:786
#, no-wrap
msgid "\\'"
msgstr "\\'"

#. type: cindex
#: original_texis/searching.texi:787
#, no-wrap
msgid "@samp{\\'} in regexp"
msgstr "@samp{\\'} in regexp"

#. type: table
#: original_texis/searching.texi:790
msgid "matches the empty string, but only at the end of the buffer or string being matched against."
msgstr "これは空文字列、ただしバッファー終端またはマッチ対象の文字列の終端だけにマッチする。"

#. type: item
#: original_texis/searching.texi:791
#, no-wrap
msgid "\\="
msgstr "\\="

#. type: cindex
#: original_texis/searching.texi:792
#, no-wrap
msgid "@samp{\\=} in regexp"
msgstr "@samp{\\=} in regexp"

#. type: table
#: original_texis/searching.texi:795
msgid "matches the empty string, but only at point.  (This construct is not defined when matching against a string.)"
msgstr "これは空文字列、ただしポイント位置だけにマッチする(この構成要素はマッチ対象が文字列なら定義されない)。"

#. type: item
#: original_texis/searching.texi:796
#, no-wrap
msgid "\\b"
msgstr "\\b"

#. type: cindex
#: original_texis/searching.texi:797
#, no-wrap
msgid "@samp{\\b} in regexp"
msgstr "@samp{\\b} in regexp"

#. type: table
#: original_texis/searching.texi:802
msgid "matches the empty string, but only at the beginning or end of a word.  Thus, @samp{\\bfoo\\b} matches any occurrence of @samp{foo} as a separate word.  @samp{\\bballs?\\b} matches @samp{ball} or @samp{balls} as a separate word."
msgstr "これは空文字列、ただし単語の先頭だけにマッチする。つまり@samp{\\bfoo\\b}は個別の単語として出現する@samp{foo}だけにマッチする。@samp{\\bballs?\\b}は、個別の単語として@samp{ball}か@samp{balls}にマッチする。"

#. type: table
#: original_texis/searching.texi:805
msgid "@samp{\\b} matches at the beginning or end of the buffer (or string)  regardless of what text appears next to it."
msgstr "@samp{\\b}は、隣接するテキストが何であるかと無関係に、バッファー(か文字列)の先頭または終端にマッチする。"

#. type: item
#: original_texis/searching.texi:806
#, no-wrap
msgid "\\B"
msgstr "\\B"

#. type: cindex
#: original_texis/searching.texi:807
#, no-wrap
msgid "@samp{\\B} in regexp"
msgstr "@samp{\\B} in regexp"

#. type: table
#: original_texis/searching.texi:810
msgid "matches the empty string, but @emph{not} at the beginning or end of a word, nor at the beginning or end of the buffer (or string)."
msgstr "これは空文字列、単語の先頭や終端、またはバッファー(か文字列)の先頭や終端@emph{以外}にマッチする。"

#. type: item
#: original_texis/searching.texi:811
#, no-wrap
msgid "\\<"
msgstr "\\<"

#. type: cindex
#: original_texis/searching.texi:812
#, no-wrap
msgid "@samp{\\<} in regexp"
msgstr "@samp{\\<} in regexp"

#. type: table
#: original_texis/searching.texi:816
msgid "matches the empty string, but only at the beginning of a word.  @samp{\\<} matches at the beginning of the buffer (or string) only if a word-constituent character follows."
msgstr "これは空文字列、ただし単語の先頭だけにマッチする。@samp{\\<}は後に単語構成文字が続く場合のみバッファー(か文字列)の先頭にマッチする。"

#. type: item
#: original_texis/searching.texi:817
#, no-wrap
msgid "\\>"
msgstr "\\>"

#. type: cindex
#: original_texis/searching.texi:818
#, no-wrap
msgid "@samp{\\>} in regexp"
msgstr "@samp{\\>} in regexp"

#. type: table
#: original_texis/searching.texi:822
msgid "matches the empty string, but only at the end of a word.  @samp{\\>} matches at the end of the buffer (or string) only if the contents end with a word-constituent character."
msgstr "これは空文字列、ただし単語の終端だけにマッチする。@samp{\\<}はコンテンツが単語構成文字で終わる場合のみバッファー(か文字列)の終端にマッチする。"

#. type: item
#: original_texis/searching.texi:823
#, no-wrap
msgid "\\_<"
msgstr "\\_<"

#. type: cindex
#: original_texis/searching.texi:824
#, no-wrap
msgid "@samp{\\_<} in regexp"
msgstr "@samp{\\_<} in regexp"

#. type: table
#: original_texis/searching.texi:829
msgid "matches the empty string, but only at the beginning of a symbol.  A symbol is a sequence of one or more word or symbol constituent characters.  @samp{\\_<} matches at the beginning of the buffer (or string) only if a symbol-constituent character follows."
msgstr "これは空文字列、ただしシンボルの先頭だけにマッチする。シンボルとは1つ以上の単語かシンボル構成文字のシーケンス。@samp{\\_<}は後にシンボル構成文字が続く場合のみバッファー(か文字列)の先頭にマッチする。"

#. type: item
#: original_texis/searching.texi:830
#, no-wrap
msgid "\\_>"
msgstr "\\_>"

#. type: cindex
#: original_texis/searching.texi:831
#, no-wrap
msgid "@samp{\\_>} in regexp"
msgstr "@samp{\\_>} in regexp"

#. type: table
#: original_texis/searching.texi:835
msgid "matches the empty string, but only at the end of a symbol.  @samp{\\_>} matches at the end of the buffer (or string) only if the contents end with a symbol-constituent character."
msgstr "これは空文字列、ただし単語の終端だけにマッチする。@samp{\\_>}はコンテンツがシンボル構成文字で終わる場合のみバッファー(か文字列)の終端にマッチする。"

#. type: kindex
#: original_texis/searching.texi:837
#, no-wrap
msgid "invalid-regexp"
msgstr "invalid-regexp"

#. type: Plain text
#: original_texis/searching.texi:843
msgid "Not every string is a valid regular expression.  For example, a string that ends inside a character alternative without a terminating @samp{]} is invalid, and so is a string that ends with a single @samp{\\}.  If an invalid regular expression is passed to any of the search functions, an @code{invalid-regexp} error is signaled."
msgstr "すべての文字列が、有効な正規表現な訳ではありません。たとえば終端の@samp{]}がない文字選択肢の内側で終わる文字列は無効であり、単一の@samp{\\}で終わる文字列も同様です。いずれかの検索関数にたいして無効な正規表現が渡されると@code{invalid-regexp}エラーがシグナルされます。"

#. type: subsection
#: original_texis/searching.texi:845
#, no-wrap
msgid "Complex Regexp Example"
msgstr "Complex Regexp Example"

#. type: Plain text
#: original_texis/searching.texi:852
msgid "Here is a complicated regexp which was formerly used by Emacs to recognize the end of a sentence together with any whitespace that follows.  (Nowadays Emacs uses a similar but more complex default regexp constructed by the function @code{sentence-end}.  @xref{Standard Regexps}.)"
msgstr "以下は後続の空白文字とともにセンテンスの終わりを認識するために、以前のEmacsで使用されていた複雑な正規表現の例です(現在のEmacsは関数@code{sentence-end}により構築される、同様のより複雑なregexpを使用する。@ref{Standard Regexps}を参照)。"

#. type: Plain text
#: original_texis/searching.texi:859
msgid "Below, we show first the regexp as a string in Lisp syntax (to distinguish spaces from tab characters), and then the result of evaluating it.  The string constant begins and ends with a double-quote.  @samp{\\\"} stands for a double-quote as part of the string, @samp{\\\\} for a backslash as part of the string, @samp{\\t} for a tab and @samp{\\n} for a newline."
msgstr "以下ではまず、(スペースとタブ文字を区別するために)Lisp構文の文字列としてregexpを示して、それを評価した結果を示します。文字列定数の開始と終了はダブルクォーテーションです。@samp{\\\"}は文字列の一部としてのダブルクォーテーション、@samp{\\\\}は文字列の一部としてのバックスラッシュ、@samp{\\t}はタブ、@samp{\\n}は改行を意味します。"

#. type: group
#: original_texis/searching.texi:865
#, no-wrap
msgid ""
"\"[.?!][]\\\"')@}]*\\\\($\\\\| $\\\\|\\t\\\\|@ @ \\\\)[ \\t\\n]*\"\n"
"     @result{} \"[.?!][]\\\"')@}]*\\\\($\\\\| $\\\\|  \\\\|@ @ \\\\)[\n"
"]*\"\n"
msgstr ""
"\"[.?!][]\\\"')@}]*\\\\($\\\\| $\\\\|\\t\\\\|@ @ \\\\)[ \\t\\n]*\"\n"
"     @result{} \"[.?!][]\\\"')@}]*\\\\($\\\\| $\\\\|  \\\\|@ @ \\\\)[\n"
"]*\"\n"

#. type: Plain text
#: original_texis/searching.texi:870
msgid "In the output, tab and newline appear as themselves."
msgstr "改行とタブは、それら自身として出力されます。"

#. type: Plain text
#: original_texis/searching.texi:873
msgid "This regular expression contains four parts in succession and can be deciphered as follows:"
msgstr "この正規表現は連続する4つのパートを含み、以下のように解読できます:"

#. type: item
#: original_texis/searching.texi:875
#, no-wrap
msgid "[.?!]"
msgstr "[.?!]"

#. type: table
#: original_texis/searching.texi:882
msgid "The first part of the pattern is a character alternative that matches any one of three characters: period, question mark, and exclamation mark.  The match must begin with one of these three characters.  (This is one point where the new default regexp used by Emacs differs from the old.  The new value also allows some non-@acronym{ASCII} characters that end a sentence without any following whitespace.)"
msgstr "この正規表現の1つ目のパートはピリオド、疑問符、感嘆符の3つのうちいずれか1つにマッチする文字選択肢。マッチはこれら3つの文字のいずれかで開始されなければならない(これは旧正規表現とEmacsが使用する新たなデフォルトregexpが異なる1つのポイントである。新たな値は後続の空白文字なしでセンテンスを終端する、いくつかの非@acronym{ASCII}文字を許容する)。"

#. type: item
#: original_texis/searching.texi:883
#, no-wrap
msgid "[]\\\"')@}]*"
msgstr "[]\\\"')@}]*"

#. type: table
#: original_texis/searching.texi:890
msgid "The second part of the pattern matches any closing braces and quotation marks, zero or more of them, that may follow the period, question mark or exclamation mark.  The @code{\\\"} is Lisp syntax for a double-quote in a string.  The @samp{*} at the end indicates that the immediately preceding regular expression (a character alternative, in this case) may be repeated zero or more times."
msgstr "パターンの2つ目のパートは任意の0個以上の閉カッコとクォーテーションマークであり、その後にピリオド、疑問符、感嘆符があるかもしれない。@code{\\\"}は文字列内でのダブルクォーテーションマークにたいするLisp構文。最後の@samp{*}は直前の正規表現(この場合は文字選択肢)の0回以上の繰り返しを示す。"

#. type: item
#: original_texis/searching.texi:891
#, no-wrap
msgid "\\\\($\\\\|@ $\\\\|\\t\\\\|@ @ \\\\)"
msgstr "\\\\($\\\\|@ $\\\\|\\t\\\\|@ @ \\\\)"

#. type: table
#: original_texis/searching.texi:898
msgid "The third part of the pattern matches the whitespace that follows the end of a sentence: the end of a line (optionally with a space), or a tab, or two spaces.  The double backslashes mark the parentheses and vertical bars as regular expression syntax; the parentheses delimit a group and the vertical bars separate alternatives.  The dollar sign is used to match the end of a line."
msgstr "パターンの3つ目のパートはセンテンスの後の空白文字、すなわち行の終端(スペースがあっても可)、タブ、または2つのスペースにマッチする。2連バックスラッシュはカッコと垂直バーを正規表現構文としてマークする。すなわちカッコはグループを句切り、垂直バーは選択肢を区別する。ダラー記号は行の終端へのマッチに使用される。"

#. type: item
#: original_texis/searching.texi:899
#, no-wrap
msgid "[ \\t\\n]*"
msgstr "[ \\t\\n]*"

#. type: table
#: original_texis/searching.texi:902
msgid "Finally, the last part of the pattern matches any additional whitespace beyond the minimum needed to end a sentence."
msgstr "最後にパターンの最終パートはセンテンスを終端させるために必要とされる以上の、余分な空白文字にマッチする。"

#. type: subsection
#: original_texis/searching.texi:905
#, no-wrap
msgid "Regular Expression Functions"
msgstr "Regular Expression Functions"

#. type: Plain text
#: original_texis/searching.texi:908
msgid "These functions operate on regular expressions."
msgstr "以下の関数は正規表現を扱います。"

#. type: cindex
#: original_texis/searching.texi:909
#, no-wrap
msgid "quote special characters in regexp"
msgstr "quote special characters in regexp"

#. type: defun
#: original_texis/searching.texi:910
#, no-wrap
msgid "regexp-quote string"
msgstr "regexp-quote string"

#. type: defun
#: original_texis/searching.texi:916
msgid "This function returns a regular expression whose only exact match is @var{string}.  Using this regular expression in @code{looking-at} will succeed only if the next characters in the buffer are @var{string}; using it in a search function will succeed if the text being searched contains @var{string}.  @xref{Regexp Search}."
msgstr "この関数は@var{string}だけに正確にマッチするような正規表現をリターンする。@code{looking-at}内でこの正規表現を使用すると、そのバッファー内の次の文字が@var{string}のときだけ成功するだろう。検索関数でのこの正規表現の使用は、検索されるテキストが@var{string}を含むなら成功するだろう。@ref{Regexp Search}を参照のこと。"

#. type: defun
#: original_texis/searching.texi:919
msgid "This allows you to request an exact string match or search when calling a function that wants a regular expression."
msgstr "これにより、その正規表現を求める関数呼び出し時に正確な文字列マッチや検索を要求できる。"

#. type: group
#: original_texis/searching.texi:924
#, no-wrap
msgid ""
"(regexp-quote \"^The cat$\")\n"
"     @result{} \"\\\\^The cat\\\\$\"\n"
msgstr ""
"(regexp-quote \"^The cat$\")\n"
"     @result{} \"\\\\^The cat\\\\$\"\n"

#. type: defun
#: original_texis/searching.texi:931
msgid "One use of @code{regexp-quote} is to combine an exact string match with context described as a regular expression.  For example, this searches for the string that is the value of @var{string}, surrounded by whitespace:"
msgstr "正規表現として記述されたコンテキストにおいて、正確な文字列マッチを結合することが@code{regexp-quote}の1つの使い方である。たとえば以下は空白文で囲まれた@var{string}の値であるような文字列を検索する:"

#. type: group
#: original_texis/searching.texi:936
#, no-wrap
msgid ""
"(re-search-forward\n"
" (concat \"\\\\s-\" (regexp-quote string) \"\\\\s-\"))\n"
msgstr ""
"(re-search-forward\n"
" (concat \"\\\\s-\" (regexp-quote string) \"\\\\s-\"))\n"

#. type: cindex
#: original_texis/searching.texi:940
#, no-wrap
msgid "optimize regexp"
msgstr "optimize regexp"

#. type: defun
#: original_texis/searching.texi:941
#, no-wrap
msgid "regexp-opt strings &optional paren"
msgstr "regexp-opt strings &optional paren"

#. type: defun
#: original_texis/searching.texi:950
msgid "This function returns an efficient regular expression that will match any of the strings in the list @var{strings}.  This is useful when you need to make matching or searching as fast as possible---for example, for Font Lock mode@footnote{Note that @code{regexp-opt} does not guarantee that its result is absolutely the most efficient form possible.  A hand-tuned regular expression can sometimes be slightly more efficient, but is almost never worth the effort.}."
msgstr "この関数はリスト@var{strings}の文字列だけにマッチする効果的な正規表現をリターンする。これはマッチングや検索を可能な限り高速にする必要があるとき、たとえばFont Lockモードで有用である@footnote{@code{regexp-opt}の結果が絶対的にもっとも効率的であるという保証はないことに注意してください。手作業でチューニングした正規表現のほうがわずかに効率的なこともありますが、これに努力する価値はほとんどないでしょう。}。"

#. type: defun
#: original_texis/searching.texi:952
msgid "The optional argument @var{paren} can be any of the following:"
msgstr "オプション引数@var{paren}には以下のいずれかを指定できる:"

#. type: defun
#: original_texis/searching.texi:957
msgid "a string the resulting regexp is preceded by @var{paren} and followed by @samp{\\)}, e.g. use @samp{\"\\\\(?1:\"} to produce an explicitly numbered group."
msgstr "文字列なら結果regexpは@var{paren}と後の@samp{\\)}により生成される。つまり番号付きグループを明示的に生成するためには@samp{\"\\\\(?1:\"}を使用する。"

#. type: defun
#: original_texis/searching.texi:960
msgid "@code{words} the resulting regexp is surrounded by @samp{\\<\\(} and @samp{\\)\\>}."
msgstr "@code{words}なら結果regexpは@samp{\\<\\(}と@samp{\\)\\>}で囲まれる。"

#. type: defun
#: original_texis/searching.texi:965
msgid "@code{symbols} the resulting regexp is surrounded by @samp{\\_<\\(} and @samp{\\)\\_>} (this is often appropriate when maching programming-language keywords and the like)."
msgstr "@code{symbols}ならなら結果regexpは@samp{\\_<\\(}と@samp{\\)\\_>}で囲まれる(これはプログラミング言語のキーワードやその類のマッチング時に適切なことが多い)。"

#. type: defun
#: original_texis/searching.texi:968
msgid "non-@code{nil} the resulting regexp is surrounded by @samp{\\(} and @samp{\\)}."
msgstr "非@code{nil}ならなら結果regexpは@samp{\\(}と@samp{\\)}で囲まれる。"

#. type: defun
#: original_texis/searching.texi:973
msgid "@code{nil} the resulting regexp is surrounded by @samp{\\(?:} and @samp{\\)}, if it is necessary to ensure that a postfix operator appended to it will apply to the whole expression."
msgstr "@code{nil}なら、追加される後置演算子が式全体に確実に適用させるために必要な場合には、結果regexpは@samp{\\(?:}と@samp{\\)}で囲まれる。"

#. type: defun
#: original_texis/searching.texi:976
msgid "The resulting regexp of @code{regexp-opt} is equivalent to but usually more efficient than that of a simplified version:"
msgstr "@code{regexp-opt}の結果regexpはその単純化されたバージョンと等価だが、通常はより効果的である。"

#. type: example
#: original_texis/searching.texi:987
#, no-wrap
msgid ""
"(defun simplified-regexp-opt (strings &optional paren)\n"
" (let ((parens (cond ((stringp paren)       (cons paren \"\\\\)\"))\n"
"                     ((eq paren 'words)    '(\"\\\\<\\\\(\" . \"\\\\)\\\\>\"))\n"
"                     ((eq paren 'symbols) '(\"\\\\_<\\\\(\" . \"\\\\)\\\\_>\"))\n"
"                     ((null paren)          '(\"\\\\(?:\" . \"\\\\)\"))\n"
"                     (t                       '(\"\\\\(\" . \"\\\\)\")))))\n"
"   (concat (car paren)\n"
"           (mapconcat 'regexp-quote strings \"\\\\|\")\n"
"           (cdr paren))))\n"
msgstr ""
"(defun simplified-regexp-opt (strings &optional paren)\n"
" (let ((parens (cond ((stringp paren)       (cons paren \"\\\\)\"))\n"
"                     ((eq paren 'words)    '(\"\\\\<\\\\(\" . \"\\\\)\\\\>\"))\n"
"                     ((eq paren 'symbols) '(\"\\\\_<\\\\(\" . \"\\\\)\\\\_>\"))\n"
"                     ((null paren)          '(\"\\\\(?:\" . \"\\\\)\"))\n"
"                     (t                       '(\"\\\\(\" . \"\\\\)\")))))\n"
"   (concat (car paren)\n"
"           (mapconcat 'regexp-quote strings \"\\\\|\")\n"
"           (cdr paren))))\n"

#. type: defun
#: original_texis/searching.texi:990
#, no-wrap
msgid "regexp-opt-depth regexp"
msgstr "regexp-opt-depth regexp"

#. type: defun
#: original_texis/searching.texi:994
msgid "This function returns the total number of grouping constructs (parenthesized expressions) in @var{regexp}.  This does not include shy groups (@pxref{Regexp Backslash})."
msgstr "この関数は@var{regexp}内のグループ化された構成要素(カッコで囲まれた正規表現)の総数をリターンする。これには内気なグループは含まれない(@ref{Regexp Backslash}を参照)。"

#. type: defun
#: original_texis/searching.texi:997
#, no-wrap
msgid "regexp-opt-charset chars"
msgstr "regexp-opt-charset chars"

#. type: defun
#: original_texis/searching.texi:1000
msgid "This function returns a regular expression matching a character in the list of characters @var{chars}."
msgstr "この関数は文字リスト@var{chars}内の文字にマッチする正規表現をリターンする。"

#. type: example
#: original_texis/searching.texi:1004
#, no-wrap
msgid ""
"(regexp-opt-charset '(?a ?b ?c ?d ?e))\n"
"     @result{} \"[a-e]\"\n"
msgstr ""
"(regexp-opt-charset '(?a ?b ?c ?d ?e))\n"
"     @result{} \"[a-e]\"\n"

#. type: section
#: original_texis/searching.texi:1010
#, no-wrap
msgid "Regular Expression Searching"
msgstr "Regular Expression Searching"

#. type: cindex
#: original_texis/searching.texi:1011
#, no-wrap
msgid "regular expression searching"
msgstr "regular expression searching"

#. type: cindex
#: original_texis/searching.texi:1012
#, no-wrap
msgid "regexp searching"
msgstr "regexp searching"

#. type: cindex
#: original_texis/searching.texi:1013
#, no-wrap
msgid "searching for regexp"
msgstr "searching for regexp"

#. type: Plain text
#: original_texis/searching.texi:1021
msgid "In GNU Emacs, you can search for the next match for a regular expression (@pxref{Syntax of Regexps}) either incrementally or not.  For incremental search commands, see @ref{Regexp Search, , Regular Expression Search, emacs, The GNU Emacs Manual}.  Here we describe only the search functions useful in programs.  The principal one is @code{re-search-forward}."
msgstr "GNU Emacsではインクリメンタルと非インクリメンタルの両方で正規表現(@ref{Syntax of Regexps}を参照)にたいする次のマッチを検索できます。インクリメンタル検索コマンドについては@ref{Regexp Search, , Regular Expression Search, emacs, The GNU Emacs Manual}を参照してください。ここではプログラム内で有用な検索関数だけを説明します。重要な関数は@code{re-search-forward}です。"

#. type: Plain text
#: original_texis/searching.texi:1025
msgid "These search functions convert the regular expression to multibyte if the buffer is multibyte; they convert the regular expression to unibyte if the buffer is unibyte.  @xref{Text Representations}."
msgstr "これらの検索関数はバッファーがマルチバイトならルチバイト、ユニバイトならユニバイトに正規表現を変換します。@ref{Text Representations}を参照してください。"

#. type: deffn
#: original_texis/searching.texi:1026
#, no-wrap
msgid "Command re-search-forward regexp &optional limit noerror count"
msgstr "Command re-search-forward regexp &optional limit noerror count"

#. type: deffn
#: original_texis/searching.texi:1032
msgid "This function searches forward in the current buffer for a string of text that is matched by the regular expression @var{regexp}.  The function skips over any amount of text that is not matched by @var{regexp}, and leaves point at the end of the first match found.  It returns the new value of point."
msgstr "この関数はカレントバッファー内で、正規表現@var{regexp}にマッチするテキスト文字列を前方へ検索する。この関数は@var{regexp}にマッチしない任意の量のテキストをスキップして、見つかった最初のマッチの終端にポイントを残す。これはポイントの新たな値をリターンする。"

#. type: deffn
#: original_texis/searching.texi:1038
msgid "If @var{limit} is non-@code{nil}, it must be a position in the current buffer.  It specifies the upper bound to the search.  No match extending after that position is accepted.  If @var{limit} is omitted or @code{nil}, it defaults to the end of the accessible portion of the buffer."
msgstr "引数@var{limit}は検索の境界を指定し、それはカレントバッファー内の位置であること。@var{limit}が非@code{nil}ならカレントバッファー内の位置でなければならない。これは検索の上限位置を指定するその位置を超えるようなマッチは、受け入れられない。@var{limit}が省略または@code{nil}の場合のデフォルトは、そのバッファーのアクセス可能範囲の終端である。"

#. type: deffn
#: original_texis/searching.texi:1041
msgid "What @code{re-search-forward} does when the search fails depends on the value of @var{noerror}:"
msgstr "検索失敗時に@code{re-search-forward}が何を行うかは@var{noerror}の値に依存する。"

#. type: code{#1}
#: original_texis/searching.texi:1043
#, no-wrap
msgid "nil"
msgstr "nil"

#. type: table
#: original_texis/searching.texi:1045
msgid "Signal a @code{search-failed} error."
msgstr "@code{search-failed}エラーをシグナルする。"

#. type: code{#1}
#: original_texis/searching.texi:1045
#, no-wrap
msgid "t"
msgstr "t"

#. type: table
#: original_texis/searching.texi:1047
msgid "Do nothing and return @code{nil}."
msgstr "何もせず@code{nil}をリターンする。"

#. type: item
#: original_texis/searching.texi:1047
#, no-wrap
msgid "anything else"
msgstr "その他"

#. type: table
#: original_texis/searching.texi:1050
msgid "Move point to @var{limit} (or the end of the accessible portion of the buffer) and return @code{nil}."
msgstr "ポイントを@var{limit} (またはバッファーのアクセス可能範囲の終端)に移動して@code{nil}をリターンする。"

#. type: deffn
#: original_texis/searching.texi:1068
msgid "In the following example, point is initially before the @samp{T}.  Evaluating the search call moves point to the end of that line (between the @samp{t} of @samp{hat} and the newline)."
msgstr "以下の例ではポイントは最初は@samp{T}の前にある。この検索を評価することにより、その行の終端( @samp{hat}の@samp{t}と改行の間)にポイントは移動する。"

#. type: group
#: original_texis/searching.texi:1075
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"I read \"@point{}The cat in the hat\n"
"comes back\" twice.\n"
"---------- Buffer: foo ----------\n"
msgstr ""
"---------- Buffer: foo ----------\n"
"I read \"@point{}The cat in the hat\n"
"comes back\" twice.\n"
"---------- Buffer: foo ----------\n"

#. type: group
#: original_texis/searching.texi:1080
#, no-wrap
msgid ""
"(re-search-forward \"[a-z]+\" nil t 5)\n"
"     @result{} 27\n"
"\n"
msgstr ""
"(re-search-forward \"[a-z]+\" nil t 5)\n"
"     @result{} 27\n"
"\n"

#. type: group
#: original_texis/searching.texi:1085
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"I read \"The cat in the hat@point{}\n"
"comes back\" twice.\n"
"---------- Buffer: foo ----------\n"
msgstr ""
"---------- Buffer: foo ----------\n"
"I read \"The cat in the hat@point{}\n"
"comes back\" twice.\n"
"---------- Buffer: foo ----------\n"

#. type: deffn
#: original_texis/searching.texi:1089
#, no-wrap
msgid "Command re-search-backward regexp &optional limit noerror count"
msgstr "Command re-search-backward regexp &optional limit noerror count"

#. type: deffn
#: original_texis/searching.texi:1093
msgid "This function searches backward in the current buffer for a string of text that is matched by the regular expression @var{regexp}, leaving point at the beginning of the first text found."
msgstr "この関数はカレントバッファー内で正規表現@var{regexp}にマッチするテキスト文字列を後方へ検索して、見つかった最初のマッチの先頭にポイントを残す。"

#. type: deffn
#: original_texis/searching.texi:1103
msgid "This function is analogous to @code{re-search-forward}, but they are not simple mirror images.  @code{re-search-forward} finds the match whose beginning is as close as possible to the starting point.  If @code{re-search-backward} were a perfect mirror image, it would find the match whose end is as close as possible.  However, in fact it finds the match whose beginning is as close as possible (and yet ends before the starting point).  The reason for this is that matching a regular expression at a given spot always works from beginning to end, and starts at a specified beginning position."
msgstr "この関数は@code{re-search-forward}と似ているが単なるミラーイメージ(mirror-image: 鏡像)ではない。@code{re-search-forward}は先頭が開始ポイントと可能な限り近いマッチを探す。@code{re-search-backward}が完全なミラーイメージなら終端が可能な限り近いマッチを探すだろう。しかし実際には先頭が可能な限り近い(かつ開始ポイントの前で終わる)マッチを探す。これは与えられた位置にたいする正規表現マッチングが常に正規表現の先頭から終端に機能して、指定された開始位置から開始されることが理由。"

#. type: deffn
#: original_texis/searching.texi:1107
msgid "A true mirror-image of @code{re-search-forward} would require a special feature for matching regular expressions from end to beginning.  It's not worth the trouble of implementing that."
msgstr "@code{re-search-forward}の真のミラーイメージには、正規表現を終端から先頭へマッチする特別な機能が要求されるだろう。それを実装することによる問題と比較して、値する価値はない。"

#. type: defun
#: original_texis/searching.texi:1109
#, no-wrap
msgid "string-match regexp string &optional start"
msgstr "string-match regexp string &optional start"

#. type: defun
#: original_texis/searching.texi:1114
msgid "This function returns the index of the start of the first match for the regular expression @var{regexp} in @var{string}, or @code{nil} if there is no match.  If @var{start} is non-@code{nil}, the search starts at that index in @var{string}."
msgstr "この関数は@var{string}内で正規表現@var{regexp}にたいする最初のマッチの開始位置のインデックスをリターンする。@var{string}内のそのインデックスから検索が開始される。"

#. type: defun
#: original_texis/searching.texi:1116
msgid "For example,"
msgstr "たとえば、"

#. type: group
#: original_texis/searching.texi:1122
#, no-wrap
msgid ""
"(string-match\n"
" \"quick\" \"The quick brown fox jumped quickly.\")\n"
"     @result{} 4\n"
msgstr ""
"(string-match\n"
" \"quick\" \"The quick brown fox jumped quickly.\")\n"
"     @result{} 4\n"

#. type: group
#: original_texis/searching.texi:1127 original_texis/searching.texi:1142
#, no-wrap
msgid ""
"(string-match\n"
" \"quick\" \"The quick brown fox jumped quickly.\" 8)\n"
"     @result{} 27\n"
msgstr ""
"(string-match\n"
" \"quick\" \"The quick brown fox jumped quickly.\" 8)\n"
"     @result{} 27\n"

#. type: defun
#: original_texis/searching.texi:1133
msgid "The index of the first character of the string is 0, the index of the second character is 1, and so on."
msgstr "文字列の最初の文字のインデックスは1、2文字目は2、...となる。"

#. type: defun
#: original_texis/searching.texi:1136
msgid "If this function finds a match, the index of the first character beyond the match is available as @code{(match-end 0)}.  @xref{Match Data}."
msgstr "この関数がマッチを見つけたら、そのマッチの先の最初の文字のインデックスは@code{(match-end 0)}で利用できる。@ref{Match Data}を参照のこと。"

#. type: group
#: original_texis/searching.texi:1147
#, no-wrap
msgid ""
"(match-end 0)\n"
"     @result{} 32\n"
msgstr ""
"(match-end 0)\n"
"     @result{} 32\n"

#. type: defun
#: original_texis/searching.texi:1151
#, no-wrap
msgid "string-match-p regexp string &optional start"
msgstr "string-match-p regexp string &optional start"

#. type: defun
#: original_texis/searching.texi:1154
msgid "This predicate function does what @code{string-match} does, but it avoids modifying the match data."
msgstr "この述語関数は@code{string-match}と同じことを行うが、マッチデータの変更を避ける。"

#. type: defun
#: original_texis/searching.texi:1156
#, no-wrap
msgid "looking-at regexp"
msgstr "looking-at regexp"

#. type: defun
#: original_texis/searching.texi:1162
msgid "This function determines whether the text in the current buffer directly following point matches the regular expression @var{regexp}.  ``Directly following'' means precisely that: the search is ``anchored'' and it can succeed only starting with the first character following point.  The result is @code{t} if so, @code{nil} otherwise."
msgstr "この関数はカレントバッファー内のポイント直後のテキストが正規表現@var{regexp}にマッチするかどうかを判断する。``直後''の正確な意味は、その検索が``固定''されていて、ポイントの後の最初の文字からマッチが開始する場合のみ成功するということ。成功なら結果は@code{t}、それ以外は@code{nil}。"

#. type: defun
#: original_texis/searching.texi:1166
msgid "This function does not move point, but it does update the match data.  @xref{Match Data}.  If you need to test for a match without modifying the match data, use @code{looking-at-p}, described below."
msgstr "この関数はポイントを移動しないがマッチデータは更新する。@ref{Match Data}を参照のこと。マッチデータを変更せずにテストする必要があるなら、以下で説明する@code{looking-at-p}を使用すること。"

#. type: defun
#: original_texis/searching.texi:1169
msgid "In this example, point is located directly before the @samp{T}.  If it were anywhere else, the result would be @code{nil}."
msgstr "以下の例ではポイントは@samp{T}の直前にある。それ以外の場所にあれば結果は@code{nil}になるだろう。"

#. type: group
#: original_texis/searching.texi:1176 original_texis/searching.texi:1201
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"I read \"@point{}The cat in the hat\n"
"comes back\" twice.\n"
"---------- Buffer: foo ----------\n"
"\n"
msgstr ""
"---------- Buffer: foo ----------\n"
"I read \"@point{}The cat in the hat\n"
"comes back\" twice.\n"
"---------- Buffer: foo ----------\n"
"\n"

#. type: group
#: original_texis/searching.texi:1179
#, no-wrap
msgid ""
"(looking-at \"The cat in the hat$\")\n"
"     @result{} t\n"
msgstr ""
"(looking-at \"The cat in the hat$\")\n"
"     @result{} t\n"

#. type: defun
#: original_texis/searching.texi:1183
#, no-wrap
msgid "looking-back regexp limit &optional greedy"
msgstr "looking-back regexp limit &optional greedy"

#. type: defun
#: original_texis/searching.texi:1186
msgid "This function returns @code{t} if @var{regexp} matches the text immediately before point (i.e., ending at point), and @code{nil} otherwise."
msgstr "この関数はポイントの直前の(ポイントで終わる)テキストが@var{regexp}とマッチしたら@code{t}、それ以外は@code{nil}をリターンする。"

#. type: defun
#: original_texis/searching.texi:1194
msgid "Because regular expression matching works only going forward, this is implemented by searching backwards from point for a match that ends at point.  That can be quite slow if it has to search a long distance.  You can bound the time required by specifying a non-@code{nil} value for @var{limit}, which says not to search before @var{limit}.  In this case, the match that is found must begin at or after @var{limit}.  Here's an example:"
msgstr "正規表現マッチングは前方だけに機能するので、ポイントで終わるマッチをポイントから後方へ検索するように実装された。長い距離を検索する必要がある場合には、これは極めて低速になり得る。非@code{nil}値を@var{limit}を指定してその前を検索しないよう告げることにより、検索に要する時間を制限できる。この場合には、マッチデータは@var{limit}かその後で始まらなければならない。以下は例:"

#. type: group
#: original_texis/searching.texi:1206
#, no-wrap
msgid ""
"(looking-back \"read \\\"\" 3)\n"
"     @result{} t\n"
"(looking-back \"read \\\"\" 4)\n"
"     @result{} nil\n"
msgstr ""
"(looking-back \"read \\\"\" 3)\n"
"     @result{} t\n"
"(looking-back \"read \\\"\" 4)\n"
"     @result{} nil\n"

#. type: defun
#: original_texis/searching.texi:1214
msgid "If @var{greedy} is non-@code{nil}, this function extends the match backwards as far as possible, stopping when a single additional previous character cannot be part of a match for @var{regexp}.  When the match is extended, its starting position is allowed to occur before @var{limit}."
msgstr "@var{greedy}が非@code{nil}なら、この関数は可能な限り後方へマッチを拡張して、前方の1文字が@var{regexp}がマッチの一部とならなければ停止する。マッチが拡張されたときには、マッチ開始位置が@var{limit}の前にあっても許される。"

#. type: defun
#: original_texis/searching.texi:1219
msgid "As a general recommendation, try to avoid using @code{looking-back} wherever possible, since it is slow.  For this reason, there are no plans to add a @code{looking-back-p} function."
msgstr "一般的に@code{looking-back}は低速なので、可能な限り使用を避けることを推奨する。この理由により@code{looking-back-p}の追加は計画されていない。"

#. type: defun
#: original_texis/searching.texi:1221
#, no-wrap
msgid "looking-at-p regexp"
msgstr "looking-at-p regexp"

#. type: defun
#: original_texis/searching.texi:1224
msgid "This predicate function works like @code{looking-at}, but without updating the match data."
msgstr "この述語関数は@code{looking-at}と同様に機能するがマッチデータを更新しない。"

#. type: defvar
#: original_texis/searching.texi:1226
#, no-wrap
msgid "search-spaces-regexp"
msgstr "search-spaces-regexp"

#. type: defvar
#: original_texis/searching.texi:1233
msgid "If this variable is non-@code{nil}, it should be a regular expression that says how to search for whitespace.  In that case, any group of spaces in a regular expression being searched for stands for use of this regular expression.  However, spaces inside of constructs such as @samp{[@dots{}]} and @samp{*}, @samp{+}, @samp{?} are not affected by @code{search-spaces-regexp}."
msgstr "この変数が非@code{nil}なら、それは空白文字を検索する方法を告げる正規表現であること。この場合には検索される正規表現内のすべてのスペース属は、この正規表現を使用することを意味する。しかし@samp{[@dots{}]}、@samp{*}@samp{+}、@samp{?}のような構文要素内のスペースは@code{search-spaces-regexp}の影響を受けない。"

#. type: defvar
#: original_texis/searching.texi:1237
msgid "Since this variable affects all regular expression search and match constructs, you should bind it temporarily for as small as possible a part of the code."
msgstr "この変数はすべての正規表現検索とマッチ構文要素に影響するので、コードの可能な限り狭い範囲にたいして一時的にバインドすること。"

#. type: section
#: original_texis/searching.texi:1240
#, no-wrap
msgid "POSIX Regular Expression Searching"
msgstr "POSIX Regular Expression Searching"

#. type: cindex
#: original_texis/searching.texi:1242
#, no-wrap
msgid "backtracking and POSIX regular expressions"
msgstr "backtracking and POSIX regular expressions"

#. type: Plain text
#: original_texis/searching.texi:1247
msgid "The usual regular expression functions do backtracking when necessary to handle the @samp{\\|} and repetition constructs, but they continue this only until they find @emph{some} match.  Then they succeed and report the first match found."
msgstr "通常の正規表現関数は、@samp{\\|}や繰り返しの構文要素を処理するために必要なときだけバックトラッキングを行いますが、@emph{何らか}のマッチが見つかるまでの間だけこれを継続します。そして成功した後に見つかった最初のマッチを報告します。"

#. type: Plain text
#: original_texis/searching.texi:1254
msgid "This section describes alternative search functions which perform the full backtracking specified by the POSIX standard for regular expression matching.  They continue backtracking until they have tried all possibilities and found all matches, so they can report the longest match, as required by POSIX@.  This is much slower, so use these functions only when you really need the longest match."
msgstr "このセクションでは正規表現にたいしてPOSIX標準で指定された完全なバックトラッキングを処理する他の検索関数を説明します。これらはPOSIXが要求する最長マッチを報告できるようにすべての可能なマッチを試みて、すべてのマッチが見つかるまでバックトラッキングを継続します。これは非常に低速なので、本当に最長マッチが必要なときだけこれらの関数を使用してください。"

#. type: Plain text
#: original_texis/searching.texi:1259
msgid "The POSIX search and match functions do not properly support the non-greedy repetition operators (@pxref{Regexp Special, non-greedy}).  This is because POSIX backtracking conflicts with the semantics of non-greedy repetition."
msgstr "POSIXの検索とマッチ関数は、非欲張りな繰り返し演算子(@ref{Regexp Special, non-greedy}を参照)を正しくサポートしません。これはPOSIXのバックトラッキングが非欲張りな繰り返しのセマンチックと競合するからです。"

#. type: deffn
#: original_texis/searching.texi:1260
#, no-wrap
msgid "Command posix-search-forward regexp &optional limit noerror count"
msgstr "Command posix-search-forward regexp &optional limit noerror count"

#. type: deffn
#: original_texis/searching.texi:1264
msgid "This is like @code{re-search-forward} except that it performs the full backtracking specified by the POSIX standard for regular expression matching."
msgstr "これは@code{re-search-forward}と似ているが、正規表現マッチングにたいしてPOSIX標準が指定する完全なバックトラッキングを行う点が異なる。"

#. type: deffn
#: original_texis/searching.texi:1266
#, no-wrap
msgid "Command posix-search-backward regexp &optional limit noerror count"
msgstr "Command posix-search-backward regexp &optional limit noerror count"

#. type: deffn
#: original_texis/searching.texi:1270
msgid "This is like @code{re-search-backward} except that it performs the full backtracking specified by the POSIX standard for regular expression matching."
msgstr "これは@code{re-search-backward}と似ているが、正規表現マッチングにたいしてPOSIX標準が指定する完全なバックトラッキングを行う点が異なる。"

#. type: defun
#: original_texis/searching.texi:1272
#, no-wrap
msgid "posix-looking-at regexp"
msgstr "posix-looking-at regexp"

#. type: defun
#: original_texis/searching.texi:1276
msgid "This is like @code{looking-at} except that it performs the full backtracking specified by the POSIX standard for regular expression matching."
msgstr "これは@code{looking-at}と似ているが、正規表現マッチングにたいしてPOSIX標準が指定する完全なバックトラッキングを行う点が異なる。"

#. type: defun
#: original_texis/searching.texi:1278
#, no-wrap
msgid "posix-string-match regexp string &optional start"
msgstr "posix-string-match regexp string &optional start"

#. type: defun
#: original_texis/searching.texi:1282
msgid "This is like @code{string-match} except that it performs the full backtracking specified by the POSIX standard for regular expression matching."
msgstr "これは@code{string-match}と似ているが、正規表現にたいしてPOSIX標準が指定する完全なバックトラッキングを行う点が異なる。"

#. type: section
#: original_texis/searching.texi:1285
#, no-wrap
msgid "The Match Data"
msgstr "The Match Data"

#. type: cindex
#: original_texis/searching.texi:1286
#, no-wrap
msgid "match data"
msgstr "match data"

#. type: Plain text
#: original_texis/searching.texi:1293
msgid "Emacs keeps track of the start and end positions of the segments of text found during a search; this is called the @dfn{match data}.  Thanks to the match data, you can search for a complex pattern, such as a date in a mail message, and then extract parts of the match under control of the pattern."
msgstr "Emacsは検索の間に見つかったテキスト片の開始と終了の位置を追跡します。これは@dfn{マッチデータ(match data)}と呼ばれます。このマッチデータのおかげで、メールメッセージ内のデータのような複雑なパターンを検索した後に、そのパターンの制御下でマッチ部分を抽出できるのです。"

#. type: Plain text
#: original_texis/searching.texi:1299
msgid "Because the match data normally describe the most recent search only, you must be careful not to do another search inadvertently between the search you wish to refer back to and the use of the match data.  If you can't avoid another intervening search, you must save and restore the match data around it, to prevent it from being overwritten."
msgstr "マッチデータには通常はもっとも最近の検索だけが記述されるので、後で参照したい検索とそのマッチデータの使用の間に誤って別の検索を行わないように注意しなければなりません。誤って別の検索を避けるのが不可能な場合には、マッチデータの上書きを防ぐために前後でマッチデータの保存とリストアを行わなければなりません。"

#. type: Plain text
#: original_texis/searching.texi:1305
msgid "Notice that all functions are allowed to overwrite the match data unless they're explicitly documented not to do so.  A consequence is that functions that are run implicitly in the background (@pxref{Timers}, and @ref{Idle Timers}) should likely save and restore the match data explicitly."
msgstr "上書きを行わないと明記されていない限り、すべての関数は上書きを許されていることに注意してください。結果としてバックグラウンド(@ref{Timers}と@ref{Idle Timers}を参照)で暗黙に実行される関数は、おそらく明示的にマッチデータの保存とリストアを行うべきでしょう。"

#. type: node
#: original_texis/searching.texi:1312 original_texis/searching.texi:1314
#, no-wrap
msgid "Replacing Match"
msgstr "Replacing Match"

#. type: menuentry
#: original_texis/searching.texi:1312
msgid "Replacing a substring that was matched."
msgstr "マッチされた部分文字列の置換。"

#. type: node
#: original_texis/searching.texi:1312 original_texis/searching.texi:1398
#, no-wrap
msgid "Simple Match Data"
msgstr "Simple Match Data"

#. type: menuentry
#: original_texis/searching.texi:1312
msgid "Accessing single items of match data, such as where a particular subexpression started."
msgstr "特定の部分式開始箇所のようなマッチデータの単一アイテムへのアクセス。"

#. type: node
#: original_texis/searching.texi:1312 original_texis/searching.texi:1544
#, no-wrap
msgid "Entire Match Data"
msgstr "Entire Match Data"

#. type: menuentry
#: original_texis/searching.texi:1312
msgid "Accessing the entire match data at once, as a list."
msgstr "リストとしてマッチデータ全体に一度にアクセスする。"

#. type: node
#: original_texis/searching.texi:1312 original_texis/searching.texi:1626
#, no-wrap
msgid "Saving Match Data"
msgstr "Saving Match Data"

#. type: menuentry
#: original_texis/searching.texi:1312
msgid "Saving and restoring the match data."
msgstr "マッチデータの保存とリストア。"

#. type: subsection
#: original_texis/searching.texi:1315
#, no-wrap
msgid "Replacing the Text that Matched"
msgstr "Replacing the Text that Matched"

#. type: cindex
#: original_texis/searching.texi:1316
#, no-wrap
msgid "replace matched text"
msgstr "replace matched text"

#. type: Plain text
#: original_texis/searching.texi:1320
msgid "This function replaces all or part of the text matched by the last search.  It works by means of the match data."
msgstr "以下の関数は、最後の検索でマッチされたテキストのすべて、または一部を置換します。これはマッチデータにより機能します。"

#. type: cindex
#: original_texis/searching.texi:1321
#, no-wrap
msgid "case in replacements"
msgstr "case in replacements"

#. type: defun
#: original_texis/searching.texi:1322
#, no-wrap
msgid "replace-match replacement &optional fixedcase literal string subexp"
msgstr "replace-match replacement &optional fixedcase literal string subexp"

#. type: defun
#: original_texis/searching.texi:1324
msgid "This function performs a replacement operation on a buffer or string."
msgstr "この関数はバッファーや文字列にたいして置換処理を行う。"

#. type: defun
#: original_texis/searching.texi:1331
msgid "If you did the last search in a buffer, you should omit the @var{string} argument or specify @code{nil} for it, and make sure that the current buffer is the one in which you performed the last search.  Then this function edits the buffer, replacing the matched text with @var{replacement}.  It leaves point at the end of the replacement text."
msgstr "あるバッファーで最後の検索を行った場合には、@var{string}引数を省略または@code{nil}を指定すること。また最後に検索を行ったバッファーがカレントバッファーであることを確認すること。その場合には、この関数はマッチしたテキストを@var{replacement}で置換することにより、そのバッファーを編集する。これは置換したテキスト終端にポイントを残す。"

#. type: defun
#: original_texis/searching.texi:1335
msgid "If you performed the last search on a string, pass the same string as @var{string}.  Then this function returns a new string, in which the matched text is replaced by @var{replacement}."
msgstr "文字列にたいして最後の検索を行った場合には、同じ文字列が@var{string}に渡される。その場合には、この関数はマッチしたテキストが@var{replacement}に置き換えられた新たなテキストをリターンする。"

#. type: defun
#: original_texis/searching.texi:1345
msgid "If @var{fixedcase} is non-@code{nil}, then @code{replace-match} uses the replacement text without case conversion; otherwise, it converts the replacement text depending upon the capitalization of the text to be replaced.  If the original text is all upper case, this converts the replacement text to upper case.  If all words of the original text are capitalized, this capitalizes all the words of the replacement text.  If all the words are one-letter and they are all upper case, they are treated as capitalized words rather than all-upper-case words."
msgstr "@var{fixedcase}が非@code{nil}なら@code{replace-match}は大文字小文字を変更せずに置換テキストを使用して、それ以外は置換されるテキストがcapitalize(先頭が大文字)されているかどうかに応じて、置換テキストを変換する。元のテキストがすべて大文字なら置換テキストを大文字に変換する。元のテキストの単語すべてがcapitalizeされていたら置換テキストのすべての単語をcapitalizeする。すべての単語が1文字かつ大文字なら、それらはすべて大文字の単語ではなくcapitalizeされた単語として扱われる。"

#. type: defun
#: original_texis/searching.texi:1351
msgid "If @var{literal} is non-@code{nil}, then @var{replacement} is inserted exactly as it is, the only alterations being case changes as needed.  If it is @code{nil} (the default), then the character @samp{\\} is treated specially.  If a @samp{\\} appears in @var{replacement}, then it must be part of one of the following sequences:"
msgstr "@var{literal}が非@code{nil}なら@var{replacement}はそのまま挿入されるが、必要に応じてcaseの変更だけが行われる。これが@code{nil}(デフォルト)なら文字@samp{\\}は特別に扱われる。@var{replacement}内に@samp{\\}が出現した場合には、それは以下のシーケンスのいずれかの一部でなければならない:"

#. type: samp{#1}
#: original_texis/searching.texi:1353
#, no-wrap
msgid "\\&"
msgstr "\\&"

#. type: cindex
#: original_texis/searching.texi:1354
#, no-wrap
msgid "@samp{&} in replacement"
msgstr "@samp{&} in replacement"

#. type: table
#: original_texis/searching.texi:1356
msgid "This stands for the entire text being replaced."
msgstr "これは置換されるテキスト全体を意味する。"

#. type: item
#: original_texis/searching.texi:1357
#, no-wrap
msgid "@samp{\\@var{n}}, where @var{n} is a digit"
msgstr "@samp{\\@var{n}} （@var{n}は数字)"

#. type: cindex
#: original_texis/searching.texi:1358
#, no-wrap
msgid "@samp{\\@var{n}} in replacement"
msgstr "@samp{\\@var{n}} in replacement"

#. type: table
#: original_texis/searching.texi:1363
msgid "This stands for the text that matched the @var{n}th subexpression in the original regexp.  Subexpressions are those expressions grouped inside @samp{\\(@dots{}\\)}.  If the @var{n}th subexpression never matched, an empty string is substituted."
msgstr "これは元のregexpの@var{n}番目の部分式にマッチするテキストを意味する。この部分式とは@samp{\\(@dots{}\\)}の内部にグループかされた式のこと。@var{n}番目のマッチがなければ空文字列が代用される。"

#. type: samp{#1}
#: original_texis/searching.texi:1364
#, no-wrap
msgid "\\\\"
msgstr "\\\\"

#. type: cindex
#: original_texis/searching.texi:1365
#, no-wrap
msgid "@samp{\\} in replacement"
msgstr "@samp{\\} in replacement"

#. type: table
#: original_texis/searching.texi:1367
msgid "This stands for a single @samp{\\} in the replacement text."
msgstr "これは置換テキスト内で単一の@samp{\\}を意味する。"

#. type: samp{#1}
#: original_texis/searching.texi:1368
#, no-wrap
msgid "\\?"
msgstr "\\?"

#. type: table
#: original_texis/searching.texi:1372
msgid "This stands for itself (for compatibility with @code{replace-regexp} and related commands; @pxref{Regexp Replace,,, emacs, The GNU Emacs Manual})."
msgstr "これはそれ自身を意味する(@code{replace-regexp}と関連するコマンドの互換用。@ref{Regexp Replace,,, emacs, The GNU Emacs Manual}を参照)。"

#. type: defun
#: original_texis/searching.texi:1376
msgid "Any other character following @samp{\\} signals an error."
msgstr "これら以外の@samp{\\}に続く文字はエラーをシグナルする。"

#. type: defun
#: original_texis/searching.texi:1380
msgid "The substitutions performed by @samp{\\&} and @samp{\\@var{n}} occur after case conversion, if any.  Therefore, the strings they substitute are never case-converted."
msgstr "@samp{\\&}や@samp{\\@var{n}}により行われる代替えは、もしあればcase変換の後に発生する。したがって代替えする文字列は決してcase変換されない。"

#. type: defun
#: original_texis/searching.texi:1386
msgid "If @var{subexp} is non-@code{nil}, that says to replace just subexpression number @var{subexp} of the regexp that was matched, not the entire match.  For example, after matching @samp{foo \\(ba*r\\)}, calling @code{replace-match} with 1 as @var{subexp} means to replace just the text that matched @samp{\\(ba*r\\)}."
msgstr "@var{subexp}が非@code{nil}なら、それは全体のマッチではなくマッチされたregexpの部分式番号@var{subexp}だけを置換することを指定する。たとえば@samp{foo \\(ba*r\\)}のマッチング後に@code{replace-match}を呼び出すと、@var{subexp}が1なら@samp{\\(ba*r\\)}にマッチしたテキストだけを置換することを意味する。"

#. type: defun
#: original_texis/searching.texi:1388
#, no-wrap
msgid "match-substitute-replacement replacement &optional fixedcase literal string subexp"
msgstr "match-substitute-replacement replacement &optional fixedcase literal string subexp"

#. type: defun
#: original_texis/searching.texi:1396
msgid "This function returns the text that would be inserted into the buffer by @code{replace-match}, but without modifying the buffer.  It is useful if you want to present the user with actual replacement result, with constructs like @samp{\\@var{n}} or @samp{\\&} substituted with matched groups.  Arguments @var{replacement} and optional @var{fixedcase}, @var{literal}, @var{string} and @var{subexp} have the same meaning as for @code{replace-match}."
msgstr "この関数は@code{replace-match}によりバッファーに挿入されるであろうテキストをリターンするがバッファーを変更しない。これは@samp{\\@var{n}}や@samp{\\&}のような構文要素をマッチしたグループで置き換えた実際の結果をユーザーに示したいとき有用。引数@var{replacement}、およびオプションの@var{fixedcase}、@var{literal}、@var{string}、@var{subexp}は@code{replace-match}のときと同じ意味をもつ。"

#. type: subsection
#: original_texis/searching.texi:1399
#, no-wrap
msgid "Simple Match Data Access"
msgstr "Simple Match Data Access"

#. type: Plain text
#: original_texis/searching.texi:1403
msgid "This section explains how to use the match data to find out what was matched by the last search or match operation, if it succeeded."
msgstr "このセクションでは最後の検索やマッチング操作で、それが成功した場合に何がマッチされたのかを調べるために、マッチデータを使用する方法について説明します。"

#. type: Plain text
#: original_texis/searching.texi:1409
msgid "You can ask about the entire matching text, or about a particular parenthetical subexpression of a regular expression.  The @var{count} argument in the functions below specifies which.  If @var{count} is zero, you are asking about the entire match.  If @var{count} is positive, it specifies which subexpression you want."
msgstr "マッチしたテキスト全体または正規表現のカッコで括られた特定の部分式にたいして問い合わせることができます。以下の関数では、@var{count}によりどの部分式かを指定できます。@var{count}が0ならマッチ全体、@var{count}が正なら望む部分式を指定します。"

#. type: Plain text
#: original_texis/searching.texi:1417
msgid "Recall that the subexpressions of a regular expression are those expressions grouped with escaped parentheses, @samp{\\(@dots{}\\)}.  The @var{count}th subexpression is found by counting occurrences of @samp{\\(} from the beginning of the whole regular expression.  The first subexpression is numbered 1, the second 2, and so on.  Only regular expressions can have subexpressions---after a simple string search, the only information available is about the entire match."
msgstr "正規表現での部分式とは、エスケープされたカッコ@samp{\\(@dots{}\\)}でグループ化された表現だったことを思い出してください。@var{count}番目の部分式は正規表現全体の先頭から@samp{\\(}を数えることで見つけられます。最初の部分式が1、2つ目が2、...となります。正規表現だけが部分式をもつことができ、単純な文字列検索の後で利用できるのはマッチ全体の情報だけです。"

#. type: Plain text
#: original_texis/searching.texi:1425
msgid "Every successful search sets the match data.  Therefore, you should query the match data immediately after searching, before calling any other function that might perform another search.  Alternatively, you may save and restore the match data (@pxref{Saving Match Data}) around the call to functions that could perform another search.  Or use the functions that explicitly do not modify the match data; e.g., @code{string-match-p}."
msgstr "成功したすべての検索はマッチデータをセットします。したがって検索後は別の検索を行うかもしれない関数を呼び出す前に、検索の直後にマッチデータを問い合わせるべきです。別の検索を呼び出すかもしれない関数の前後で、かわりにマッチデータの保存とリストアすることもできます(@ref{Saving Match Data}を参照)。または@code{string-match-p}のようなマッチデータを変更しないと明示されている関数を使用してください。"

#. type: Plain text
#: original_texis/searching.texi:1432
msgid "A search which fails may or may not alter the match data.  In the current implementation, it does not, but we may change it in the future.  Don't try to rely on the value of the match data after a failing search."
msgstr "検索が成功しようと失敗しようとマッチデータは変更されます。現在はこのように実装されていますが、これは将来変更されるかもしれません。失敗した後のマッチデータを信用しないでください。"

#. type: defun
#: original_texis/searching.texi:1433
#, no-wrap
msgid "match-string count &optional in-string"
msgstr "match-string count &optional in-string"

#. type: defun
#: original_texis/searching.texi:1438
msgid "This function returns, as a string, the text matched in the last search or match operation.  It returns the entire text if @var{count} is zero, or just the portion corresponding to the @var{count}th parenthetical subexpression, if @var{count} is positive."
msgstr "この関数は最後の検索やマッチ処理でマッチしたテキストを文字列としてリターンする。これは@var{count}が0ならテキスト全体、@var{count}が正なら@var{count}番目のカッコで括られた部分式に対応する部分だけをリターンする。"

#. type: defun
#: original_texis/searching.texi:1446
msgid "If the last such operation was done against a string with @code{string-match}, then you should pass the same string as the argument @var{in-string}.  After a buffer search or match, you should omit @var{in-string} or pass @code{nil} for it; but you should make sure that the current buffer when you call @code{match-string} is the one in which you did the searching or matching.  Failure to follow this advice will lead to incorrect results."
msgstr "そのような最後の処理が文字列にたいする@code{string-match}呼び出しなら、引数@var{in-string}には同じ文字列を渡すこと。バッファーの検索やマッチの後は、@var{in-string}を省略するか@code{nil}を渡すこと。しかし最後に検索やマッチを行ったバッファーが、@code{match-string}呼び出し時にカレントバッファーであることを確認すること。このアドバイスにしたがわなければ誤った結果となるだろう。"

#. type: defun
#: original_texis/searching.texi:1450
msgid "The value is @code{nil} if @var{count} is out of range, or for a subexpression inside a @samp{\\|} alternative that wasn't used or a repetition that repeated zero times."
msgstr "@var{count}が範囲外、@samp{\\|}選択肢内部の部分式が使用されない、または0回の繰り返しなら値は@code{nil}。"

#. type: defun
#: original_texis/searching.texi:1452
#, no-wrap
msgid "match-string-no-properties count &optional in-string"
msgstr "match-string-no-properties count &optional in-string"

#. type: defun
#: original_texis/searching.texi:1455
msgid "This function is like @code{match-string} except that the result has no text properties."
msgstr "この関数は@code{match-string}と似ているが結果がテキストプロパティをもたない点が異なる。"

#. type: defun
#: original_texis/searching.texi:1457
#, no-wrap
msgid "match-beginning count"
msgstr "match-beginning count"

#. type: defun
#: original_texis/searching.texi:1461
msgid "If the last regular expression search found a match, this function returns the position of the start of the matching text or of a subexpression of it."
msgstr "最後の正規表現検索がマッチを見つけたら、この関数はマッチしたテキストか部分式の開始位置をリターンする。"

#. type: defun
#: original_texis/searching.texi:1466
msgid "If @var{count} is zero, then the value is the position of the start of the entire match.  Otherwise, @var{count} specifies a subexpression in the regular expression, and the value of the function is the starting position of the match for that subexpression."
msgstr "@var{count}が0なら値はマッチ全体の開始位置。それ以外なら@var{count}は正規表現内の部分式を指定するので、この関数の値はその部分式にたいするマッチの開始位置。"

#. type: defun
#: original_texis/searching.texi:1469
msgid "The value is @code{nil} for a subexpression inside a @samp{\\|} alternative that wasn't used or a repetition that repeated zero times."
msgstr "使用されない、あるいは0回の繰り返しであるような@samp{\\|}選択肢内部の部分式にたいしての値は@code{nil}。"

#. type: defun
#: original_texis/searching.texi:1471
#, no-wrap
msgid "match-end count"
msgstr "match-end count"

#. type: defun
#: original_texis/searching.texi:1475
msgid "This function is like @code{match-beginning} except that it returns the position of the end of the match, rather than the position of the beginning."
msgstr "この関数は@code{match-beginning}と似ているがマッチの開始ではなく終了位置である点が異なる。"

#. type: Plain text
#: original_texis/searching.texi:1479
msgid "Here is an example of using the match data, with a comment showing the positions within the text:"
msgstr "以下はマッチデータを使用する例です。コメントの数字はテキスト内での位置を示しています:"

#. type: group
#: original_texis/searching.texi:1486
#, no-wrap
msgid ""
"(string-match \"\\\\(qu\\\\)\\\\(ick\\\\)\"\n"
"              \"The quick fox jumped quickly.\")\n"
"              ;0123456789\n"
"     @result{} 4\n"
msgstr ""
"(string-match \"\\\\(qu\\\\)\\\\(ick\\\\)\"\n"
"              \"The quick fox jumped quickly.\")\n"
"              ;0123456789\n"
"     @result{} 4\n"

#. type: group
#: original_texis/searching.texi:1495
#, no-wrap
msgid ""
"(match-string 0 \"The quick fox jumped quickly.\")\n"
"     @result{} \"quick\"\n"
"(match-string 1 \"The quick fox jumped quickly.\")\n"
"     @result{} \"qu\"\n"
"(match-string 2 \"The quick fox jumped quickly.\")\n"
"     @result{} \"ick\"\n"
msgstr ""
"(match-string 0 \"The quick fox jumped quickly.\")\n"
"     @result{} \"quick\"\n"
"(match-string 1 \"The quick fox jumped quickly.\")\n"
"     @result{} \"qu\"\n"
"(match-string 2 \"The quick fox jumped quickly.\")\n"
"     @result{} \"ick\"\n"

#. type: group
#: original_texis/searching.texi:1500
#, no-wrap
msgid ""
"(match-beginning 1)       ; @r{The beginning of the match}\n"
"     @result{} 4                 ;   @r{with @samp{qu} is at index 4.}\n"
msgstr ""
"(match-beginning 1)       ; @r{@samp{qu}にたいするマッチ先頭の}\n"
"     @result{} 4                 ;   @r{インデックスは4}\n"

#. type: group
#: original_texis/searching.texi:1505
#, no-wrap
msgid ""
"(match-beginning 2)       ; @r{The beginning of the match}\n"
"     @result{} 6                 ;   @r{with @samp{ick} is at index 6.}\n"
msgstr ""
"(match-beginning 2)       ; @r{@samp{ick}にたいするマッチ先頭の}\n"
"     @result{} 6                 ;   @r{インデックスは6}\n"

#. type: group
#: original_texis/searching.texi:1510
#, no-wrap
msgid ""
"(match-end 1)             ; @r{The end of the match}\n"
"     @result{} 6                 ;   @r{with @samp{qu} is at index 6.}\n"
"\n"
msgstr ""
"(match-end 1)             ; @r{@samp{qu}にたいするマッチ終端の}\n"
"     @result{} 6                 ;   @r{インデックスは6}\n"
"\n"

#. type: group
#: original_texis/searching.texi:1513
#, no-wrap
msgid ""
"(match-end 2)             ; @r{The end of the match}\n"
"     @result{} 9                 ;   @r{with @samp{ick} is at index 9.}\n"
msgstr ""
"(match-end 2)             ; @r{@samp{ick}にたいするマッチ終端の}\n"
"     @result{} 9                 ;   @r{インデックスは9}\n"

#. type: Plain text
#: original_texis/searching.texi:1521
msgid "Here is another example.  Point is initially located at the beginning of the line.  Searching moves point to between the space and the word @samp{in}.  The beginning of the entire match is at the 9th character of the buffer (@samp{T}), and the beginning of the match for the first subexpression is at the 13th character (@samp{c})."
msgstr "別の例を以下に示します。ポイントは最初は行の先頭にあります。検索の後はポイントはスペースと単語@samp{in}の間にあります。マッチ全体の先頭はバッファーの9つ目の文字@samp{T}、1つ目の部分式にたいするマッチの先頭は13番目の文字@samp{c}です。"

#. type: group
#: original_texis/searching.texi:1529
#, no-wrap
msgid ""
"(list\n"
"  (re-search-forward \"The \\\\(cat \\\\)\")\n"
"  (match-beginning 0)\n"
"  (match-beginning 1))\n"
"    @result{} (17 9 13)\n"
msgstr ""
"(list\n"
"  (re-search-forward \"The \\\\(cat \\\\)\")\n"
"  (match-beginning 0)\n"
"  (match-beginning 1))\n"
"    @result{} (17 9 13)\n"

#. type: group
#: original_texis/searching.texi:1537
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"I read \"The cat @point{}in the hat comes back\" twice.\n"
"        ^   ^\n"
"        9  13\n"
"---------- Buffer: foo ----------\n"
msgstr ""
"---------- Buffer: foo ----------\n"
"I read \"The cat @point{}in the hat comes back\" twice.\n"
"        ^   ^\n"
"        9  13\n"
"---------- Buffer: foo ----------\n"

#. type: Plain text
#: original_texis/searching.texi:1543
msgid "(In this case, the index returned is a buffer position; the first character of the buffer counts as 1.)"
msgstr "(この場合にはリターンされるインデックスはバッファー位置であり、バッファーの1つ目の文字を1と数える。)"

#. type: subsection
#: original_texis/searching.texi:1545
#, no-wrap
msgid "Accessing the Entire Match Data"
msgstr "Accessing the Entire Match Data"

#. type: Plain text
#: original_texis/searching.texi:1549
msgid "The functions @code{match-data} and @code{set-match-data} read or write the entire match data, all at once."
msgstr "関数@code{match-data}と@code{set-match-data}は、マッチデータ全体にたいして一度に読み取り、または書き込みを行います。"

#. type: defun
#: original_texis/searching.texi:1550
#, no-wrap
msgid "match-data &optional integers reuse reseat"
msgstr "match-data &optional integers reuse reseat"

#. type: defun
#: original_texis/searching.texi:1558
msgid "This function returns a list of positions (markers or integers) that record all the information on the text that the last search matched.  Element zero is the position of the beginning of the match for the whole expression; element one is the position of the end of the match for the expression.  The next two elements are the positions of the beginning and end of the match for the first subexpression, and so on.  In general, element"
msgstr "この関数は最後の検索によりマッチしたテキストのすべての情報を記録する位置(マーカーか整数)をリターンする。要素0は正規表現全体にたいするマッチの先頭の位置。要素1はその正規表現にたいするマッチの終端の位置。次の2つの要素は1つ目の部分式にたいするマッチの先頭と終了、...となる。一般的に要素番号"

#. type: ifnottex
#: original_texis/searching.texi:1560
msgid "number 2@var{n}"
msgstr "2@var{n}"

#. type: tex
#: original_texis/searching.texi:1563
#, no-wrap
msgid "number {\\mathsurround=0pt $2n$}\n"
msgstr "{\\mathsurround=0pt $2n$}\n"

#. type: defun
#: original_texis/searching.texi:1566
msgid "corresponds to @code{(match-beginning @var{n})}; and element"
msgstr "は@code{(match-beginning @var{n})}、要素番号"

#. type: ifnottex
#: original_texis/searching.texi:1568
msgid "number 2@var{n} + 1"
msgstr "2@var{n} + 1"

#. type: tex
#: original_texis/searching.texi:1571
#, no-wrap
msgid "number {\\mathsurround=0pt $2n+1$}\n"
msgstr "{\\mathsurround=0pt $2n+1$}\n"

#. type: defun
#: original_texis/searching.texi:1573
msgid "corresponds to @code{(match-end @var{n})}."
msgstr "は@code{(match-end @var{n})}に対応する。"

#. type: defun
#: original_texis/searching.texi:1581
msgid "Normally all the elements are markers or @code{nil}, but if @var{integers} is non-@code{nil}, that means to use integers instead of markers.  (In that case, the buffer itself is appended as an additional element at the end of the list, to facilitate complete restoration of the match data.)  If the last match was done on a string with @code{string-match}, then integers are always used, since markers can't point into a string."
msgstr "すべての要素は通常はマーカーか@code{nil}だが、もし@var{integers}が非@code{nil}ならマーカーのかわりに整数を使用することを意味する(この場合にはマッチデータの完全なリストアを容易にするために、リストの最後の要素としてバッファー自身が追加される)。最後の検索が@code{string-match}により文字列にたいして行われた場合には、マーカーは文字列の内部をポイントできないので常に整数が使用される。"

#. type: defun
#: original_texis/searching.texi:1590
msgid "If @var{reuse} is non-@code{nil}, it should be a list.  In that case, @code{match-data} stores the match data in @var{reuse}.  That is, @var{reuse} is destructively modified.  @var{reuse} does not need to have the right length.  If it is not long enough to contain the match data, it is extended.  If it is too long, the length of @var{reuse} stays the same, but the elements that were not used are set to @code{nil}.  The purpose of this feature is to reduce the need for garbage collection."
msgstr "@var{reuse}が非@code{nil}なら、それはリストであること。この場合には、@code{match-data}はマッチデータを@var{reuse}内に格納する。つまり@var{reuse}は破壊的に変更される。@var{reuse}が正しい長さである必要はない。特定のマッチデータにたいして長さが十分でなければリストは拡張される。@var{reuse}が長過ぎる場合には、長さはそのままで使用しない要素に@code{nil}がセットされる。この機能にはガベージコレクションの必要頻度を減らす目的がある。"

#. type: defun
#: original_texis/searching.texi:1593
msgid "If @var{reseat} is non-@code{nil}, all markers on the @var{reuse} list are reseated to point to nowhere."
msgstr "@var{reseat}が非@code{nil}なら、@var{reuse}リスト内のすべてのマーカーは存在しない場所を指すよう再設定される。"

#. type: defun
#: original_texis/searching.texi:1597
msgid "As always, there must be no possibility of intervening searches between the call to a search function and the call to @code{match-data} that is intended to access the match data for that search."
msgstr "他の場合と同じように検索関数とその検索のマッチデータへのアクセスを意図する@code{match-data}呼び出しの間に介入するような検索があってはならない。"

#. type: group
#: original_texis/searching.texi:1605
#, no-wrap
msgid ""
"(match-data)\n"
"     @result{}  (#<marker at 9 in foo>\n"
"          #<marker at 17 in foo>\n"
"          #<marker at 13 in foo>\n"
"          #<marker at 17 in foo>)\n"
msgstr ""
"(match-data)\n"
"     @result{}  (#<marker at 9 in foo>\n"
"          #<marker at 17 in foo>\n"
"          #<marker at 13 in foo>\n"
"          #<marker at 17 in foo>)\n"

#. type: defun
#: original_texis/searching.texi:1609
#, no-wrap
msgid "set-match-data match-list &optional reseat"
msgstr "set-match-data match-list &optional reseat"

#. type: defun
#: original_texis/searching.texi:1614
msgid "This function sets the match data from the elements of @var{match-list}, which should be a list that was the value of a previous call to @code{match-data}.  (More precisely, anything that has the same format will work.)"
msgstr "この関数は@var{match-list}の要素からマッチデータをセットする。@var{match-list}は前の@code{match-data}呼び出しの値であるようなリストであること(正確には同じフォーマットなら他のものでも機能するだろう)。"

#. type: defun
#: original_texis/searching.texi:1617
msgid "If @var{match-list} refers to a buffer that doesn't exist, you don't get an error; that sets the match data in a meaningless but harmless way."
msgstr "@var{match-list}が存在しないバッファーを参照する場合でもエラーとはならない。これは無意味だが害のない方法でマッチデータをセットする。"

#. type: defun
#: original_texis/searching.texi:1620
msgid "If @var{reseat} is non-@code{nil}, all markers on the @var{match-list} list are reseated to point to nowhere."
msgstr "@var{reseat}が非@code{nil}なら、リスト@var{match-list}内のすべてのマーカーは存在しない場所を指すよう再設定される。"

#. type: findex
#: original_texis/searching.texi:1622
#, no-wrap
msgid "store-match-data"
msgstr "store-match-data"

#. type: defun
#: original_texis/searching.texi:1624
msgid "@code{store-match-data} is a semi-obsolete alias for @code{set-match-data}."
msgstr "@code{store-match-data}は@code{set-match-data}の半ば時代遅れなエイリアス。"

#. type: subsection
#: original_texis/searching.texi:1627
#, no-wrap
msgid "Saving and Restoring the Match Data"
msgstr "Saving and Restoring the Match Data"

#. type: Plain text
#: original_texis/searching.texi:1633
msgid "When you call a function that may search, you may need to save and restore the match data around that call, if you want to preserve the match data from an earlier search for later use.  Here is an example that shows the problem that arises if you fail to save the match data:"
msgstr "以前に行った検索にたいするマッチデータを後で使用するために保護する必要があるなら、検索を行うかもしれない関数の呼び出し時に呼び出しの前後でマッチデータの保存とリストアを行う必要があるでしょう。以下はマッチデータ保存に失敗した場合に発生する問題を示す例です:"

#. type: group
#: original_texis/searching.texi:1641
#, no-wrap
msgid ""
"(re-search-forward \"The \\\\(cat \\\\)\")\n"
"     @result{} 48\n"
"(foo)                   ; @r{@code{foo} does more searching.}\n"
"(match-end 0)\n"
"     @result{} 61              ; @r{Unexpected result---not 48!}\n"
msgstr ""
"(re-search-forward \"The \\\\(cat \\\\)\")\n"
"     @result{} 48\n"
"(foo)                   ; @r{@code{foo}が他の検索を行うと}\n"
"(match-end 0)\n"
"     @result{} 61              ; @r{結果は期待する48と異なる!}\n"

#. type: Plain text
#: original_texis/searching.texi:1645
msgid "You can save and restore the match data with @code{save-match-data}:"
msgstr "@code{save-match-data}でマッチデータの保存とリストアができます:"

#. type: defmac
#: original_texis/searching.texi:1646
#, no-wrap
msgid "save-match-data body@dots{}"
msgstr "save-match-data body@dots{}"

#. type: defmac
#: original_texis/searching.texi:1650
msgid "This macro executes @var{body}, saving and restoring the match data around it.  The return value is the value of the last form in @var{body}."
msgstr "このマクロは@var{body}を実行して、その前後のマッチデータの保存とリストアを行う。リターン値は@var{body}内の最後のフォームの値。"

#. type: Plain text
#: original_texis/searching.texi:1655
msgid "You could use @code{set-match-data} together with @code{match-data} to imitate the effect of the special form @code{save-match-data}.  Here is how:"
msgstr "@code{set-match-data}と@code{match-data}を一緒に使用して、@code{save-match-data}の効果を模倣することができます。以下はその方法です:"

#. type: group
#: original_texis/searching.texi:1662
#, no-wrap
msgid ""
"(let ((data (match-data)))\n"
"  (unwind-protect\n"
"      @dots{}   ; @r{Ok to change the original match data.}\n"
"    (set-match-data data)))\n"
msgstr ""
"(let ((data (match-data)))\n"
"  (unwind-protect\n"
"      @dots{}   ; @r{元のマッチデータを変更してもOK}\n"
"    (set-match-data data)))\n"

#. type: Plain text
#: original_texis/searching.texi:1668
msgid "Emacs automatically saves and restores the match data when it runs process filter functions (@pxref{Filter Functions}) and process sentinels (@pxref{Sentinels})."
msgstr "プロセスフィルター関数(@ref{Filter Functions}を参照)、およびプロセスセンチネル(@ref{Sentinels}を参照)の実行時には、Emacsが自動的にマッチデータの保存とリストアを行います。"

#. type: group
#: original_texis/searching.texi:1681
#, no-wrap
msgid ""
"(defun restore-match-data (data)\n"
"  \"Restore the match data DATA unless the buffer is missing.\"\n"
"  (catch 'foo\n"
"    (let ((d data))\n"
msgstr ""
"(defun restore-match-data (data)\n"
"  \"Restore the match data DATA unless the buffer is missing.\"\n"
"  (catch 'foo\n"
"    (let ((d data))\n"

#. type: smallexample
#: original_texis/searching.texi:1685
#, no-wrap
msgid ""
"      (while d\n"
"        (and (car d)\n"
"             (null (marker-buffer (car d)))\n"
msgstr ""
"      (while d\n"
"        (and (car d)\n"
"             (null (marker-buffer (car d)))\n"

#. type: group
#: original_texis/searching.texi:1690
#, no-wrap
msgid ""
"             ;; @file{match-data} @r{buffer is deleted.}\n"
"             (throw 'foo nil))\n"
"        (setq d (cdr d)))\n"
"      (set-match-data data))))\n"
msgstr ""
"             ;; @file{match-data} @r{buffer is deleted.}\n"
"             (throw 'foo nil))\n"
"        (setq d (cdr d)))\n"
"      (set-match-data data))))\n"

#. type: cindex
#: original_texis/searching.texi:1696
#, no-wrap
msgid "replacement after search"
msgstr "replacement after search"

#. type: cindex
#: original_texis/searching.texi:1697
#, no-wrap
msgid "searching and replacing"
msgstr "searching and replacing"

#. type: Plain text
#: original_texis/searching.texi:1702
msgid "If you want to find all matches for a regexp in part of the buffer, and replace them, the best way is to write an explicit loop using @code{re-search-forward} and @code{replace-match}, like this:"
msgstr "バッファーのある部分でregexpにたいするすべてのマッチを見つけてそれらを置換したい場合には、以下のように@code{re-search-forward}と@code{replace-match}を使用して明示的なループを記述するのが最良の方法です:"

#. type: example
#: original_texis/searching.texi:1706
#, no-wrap
msgid ""
"(while (re-search-forward \"foo[ \\t]+bar\" nil t)\n"
"  (replace-match \"foobar\"))\n"
msgstr ""
"(while (re-search-forward \"foo[ \\t]+bar\" nil t)\n"
"  (replace-match \"foobar\"))\n"

#. type: Plain text
#: original_texis/searching.texi:1711
msgid "@xref{Replacing Match,, Replacing the Text that Matched}, for a description of @code{replace-match}."
msgstr "@code{replace-match}の説明は@ref{Replacing Match,, Replacing the Text that Matched}を参照してください。"

#. type: Plain text
#: original_texis/searching.texi:1715
msgid "However, replacing matches in a string is more complex, especially if you want to do it efficiently.  So Emacs provides a function to do this."
msgstr "しかし文字列内のマッチの置換、特に置換を効果的に行いたい場合には、より複雑になります。そのためにEmacsはこれを行うための関数を提供します。"

#. type: defun
#: original_texis/searching.texi:1716
#, no-wrap
msgid "replace-regexp-in-string regexp rep string &optional fixedcase literal subexp start"
msgstr "replace-regexp-in-string regexp rep string &optional fixedcase literal subexp start"

#. type: defun
#: original_texis/searching.texi:1722
msgid "This function copies @var{string} and searches it for matches for @var{regexp}, and replaces them with @var{rep}.  It returns the modified copy.  If @var{start} is non-@code{nil}, the search for matches starts at that index in @var{string}, so matches starting before that index are not changed."
msgstr "この関数は@var{string}をコピーして@var{regexp}にたいするマッチを検索、それらを@var{rep}に置き換える。これは変更されたコピーをリターンする。@var{start}が非@code{nil}ならマッチにたいする検索は@var{string}内のそのインデックスから開始されて、そのインデックスより前で始まるマッチは変更されない。"

#. type: defun
#: original_texis/searching.texi:1726
msgid "This function uses @code{replace-match} to do the replacement, and it passes the optional arguments @var{fixedcase}, @var{literal} and @var{subexp} along to @code{replace-match}."
msgstr "この関数は置換を行うためにオプション引数@var{fixedcase}、@var{literal}、@var{subexp}を渡して@code{replace-match}を使用する。"

#. type: defun
#: original_texis/searching.texi:1733
msgid "Instead of a string, @var{rep} can be a function.  In that case, @code{replace-regexp-in-string} calls @var{rep} for each match, passing the text of the match as its sole argument.  It collects the value @var{rep} returns and passes that to @code{replace-match} as the replacement string.  The match data at this point are the result of matching @var{regexp} against a substring of @var{string}."
msgstr "@var{rep}は文字列のかわりに関数でもよい。この場合には@code{replace-regexp-in-string}はそれぞれのマッチにたいして、そのテキストを単一の引数として@var{rep}を呼び出す。これは@var{rep}がリターンする値を収集して、それを置換文字列として@code{replace-match}に渡す。この時点でのマッチデータは@var{string}の部分文字列にたいする@var{regexp}のマッチ結果。"

#. type: Plain text
#: original_texis/searching.texi:1737
msgid "If you want to write a command along the lines of @code{query-replace}, you can use @code{perform-replace} to do the work."
msgstr "@code{query-replace}の行に関するコマンドを記述したい場合には、@code{perform-replace}を使用してこれを行うことができます。"

#. type: defun
#: original_texis/searching.texi:1738
#, no-wrap
msgid "perform-replace from-string replacements query-flag regexp-flag delimited-flag &optional repeat-count map start end"
msgstr "perform-replace from-string replacements query-flag regexp-flag delimited-flag &optional repeat-count map start end"

#. type: defun
#: original_texis/searching.texi:1745
msgid "This function is the guts of @code{query-replace} and related commands.  It searches for occurrences of @var{from-string} in the text between positions @var{start} and @var{end} and replaces some or all of them.  If @var{start} is @code{nil} (or omitted), point is used instead, and the end of the buffer's accessible portion is used for @var{end}."
msgstr "これは@code{query-replace}と関連するコマンドの根幹となる関数。これは位置@var{start}と@var{end}の間にあるテキスト内に出現する@var{from-string}の一部またはすべてを置換する。@var{start}が@code{nil} (または省略)ならかわりにポイント、@var{end}にはそのバッファーのアクセス可能範囲の終端が使用される。"

#. type: defun
#: original_texis/searching.texi:1748
msgid "If @var{query-flag} is @code{nil}, it replaces all occurrences; otherwise, it asks the user what to do about each one."
msgstr "@var{query-flag}が@code{nil}ならすべてのマッチを置換する。それ以外なら、それぞれにたいしてユーザーにたいして何をすべきか問い合わせる。"

#. type: defun
#: original_texis/searching.texi:1753
msgid "If @var{regexp-flag} is non-@code{nil}, then @var{from-string} is considered a regular expression; otherwise, it must match literally.  If @var{delimited-flag} is non-@code{nil}, then only replacements surrounded by word boundaries are considered."
msgstr "@var{regexp-flag}が非@code{nil}なら@var{from-string}は正規表現、それ以外はリテラルとしてマッチしなければならない。@var{delimited-flag}が非@code{nil}なら単語境界に囲まれた置換だけが考慮される。"

#. type: defun
#: original_texis/searching.texi:1757
msgid "The argument @var{replacements} specifies what to replace occurrences with.  If it is a string, that string is used.  It can also be a list of strings, to be used in cyclic order."
msgstr "引数@var{replacements}はマッチを何で置き換えるかを指定する。文字列ならその文字列を使用する。サイクル順に使用される文字列リストでもよい。"

#. type: defun
#: original_texis/searching.texi:1762
msgid "If @var{replacements} is a cons cell, @w{@code{(@var{function} . @var{data})}}, this means to call @var{function} after each match to get the replacement text.  This function is called with two arguments: @var{data}, and the number of replacements already made."
msgstr "@var{replacements}がコンスセル@w{@code{(@var{function} . @var{data})}}なら、置換テキストを取得するためにそれぞれのマッチ後に@var{function}を呼び出すことを意味する。この関数は@var{data}とすでに置換された個数という、2つの引数で呼び出される。"

#. type: defun
#: original_texis/searching.texi:1766
msgid "If @var{repeat-count} is non-@code{nil}, it should be an integer.  Then it specifies how many times to use each of the strings in the @var{replacements} list before advancing cyclically to the next one."
msgstr "@var{repeat-count}が非@code{nil}なら、それは整数であること。その場合にはサイクルを次に進める前に、@var{replacements}リスト内の各文字列を何度使用するかを指定する。"

#. type: defun
#: original_texis/searching.texi:1770
msgid "If @var{from-string} contains upper-case letters, then @code{perform-replace} binds @code{case-fold-search} to @code{nil}, and it uses the @var{replacements} without altering their case."
msgstr "@var{from-string}が大文字アルファベットを含む場合には、@code{perform-replace}は@code{case-fold-search}を@code{nil}にバインドして大文字小文字を変換せずに@var{replacements}を使用する。"

#. type: defun
#: original_texis/searching.texi:1775
msgid "Normally, the keymap @code{query-replace-map} defines the possible user responses for queries.  The argument @var{map}, if non-@code{nil}, specifies a keymap to use instead of @code{query-replace-map}."
msgstr "キーマップ@code{query-replace-map}は通常は問い合わせにたいして可能なユーザー応答を定義する。引数@var{map}が非@code{nil}なら、それは@code{query-replace-map}のかわりに使用するキーマップを指定する。"

#. type: defun
#: original_texis/searching.texi:1782
msgid "This function uses one of two functions to search for the next occurrence of @var{from-string}.  These functions are specified by the values of two variables: @code{replace-re-search-function} and @code{replace-search-function}.  The former is called when the argument @var{regexp-flag} is non-@code{nil}, the latter when it is @code{nil}."
msgstr "この関数は@var{from-string}の次のマッチを検索するために2つの関数のうちいずれか1つを使用する。これらの関数は2つの変数@code{replace-re-search-function}と@code{replace-search-function}により指定される。引数@var{regexp-flag}が非@code{nil}なら前者、@code{nil}なら後者が呼び出される。"

#. type: defvar
#: original_texis/searching.texi:1784
#, no-wrap
msgid "query-replace-map"
msgstr "query-replace-map"

#. type: defvar
#: original_texis/searching.texi:1789
msgid "This variable holds a special keymap that defines the valid user responses for @code{perform-replace} and the commands that use it, as well as @code{y-or-n-p} and @code{map-y-or-n-p}.  This map is unusual in two ways:"
msgstr "この変数は@code{perform-replace}にたいする有効なユーザー応答を定義するスペシャルキーマップを保持して、コマンドは@code{y-or-n-p}や@code{map-y-or-n-p}と同様にそれを使用する。このマップは2つの点において普通のマップと異なる。"

#. type: itemize
#: original_texis/searching.texi:1794
msgid "The key bindings are not commands, just symbols that are meaningful to the functions that use this map."
msgstr "キーバインディングはコマンドではなく、このマップを使用する関数にとって意味のある単なるシンボルであること。"

#. type: itemize
#: original_texis/searching.texi:1800
msgid "Prefix keys are not supported; each key binding must be for a single-event key sequence.  This is because the functions don't use @code{read-key-sequence} to get the input; instead, they read a single event and look it up ``by hand''."
msgstr "プレフィクスキーはサポートされない。各キーバインディングは単一イベントキーシーケンスでなければならない。この関数は入力を取得するために単一イベントを読み取って、それを``手動''で照合するので@code{read-key-sequence}を使用しないからである。"

#. type: Plain text
#: original_texis/searching.texi:1806
msgid "Here are the meaningful bindings for @code{query-replace-map}.  Several of them are meaningful only for @code{query-replace} and friends."
msgstr "@code{query-replace-map}にたいして意味をもつバインディングがあります。それらのうちいくつかは@code{query-replace}とその同族にたいしてのみ意味をもちます。"

#. type: item
#: original_texis/searching.texi:1808
#, no-wrap
msgid "act"
msgstr "act"

#. type: table
#: original_texis/searching.texi:1810
msgid "Do take the action being considered---in other words, ``yes''."
msgstr "判断している対象にたいしてアクションを起こす(言い換えると``yes'')。"

#. type: item
#: original_texis/searching.texi:1811
#, no-wrap
msgid "skip"
msgstr "skip"

#. type: table
#: original_texis/searching.texi:1813
msgid "Do not take action for this question---in other words, ``no''."
msgstr "この問いにたいしてアクションを起こさない(言い換えると``no'')。"

#. type: item
#: original_texis/searching.texi:1814
#, no-wrap
msgid "exit"
msgstr "exit"

#. type: table
#: original_texis/searching.texi:1817
msgid "Answer this question ``no'', and give up on the entire series of questions, assuming that the answers will be ``no''."
msgstr "この問いにたいして``no''を答えて、さらに一連の問いすべてにたいして``no''が応答されたとみなして問い合わせをあきらめる。"

#. type: item
#: original_texis/searching.texi:1818
#, no-wrap
msgid "exit-prefix"
msgstr "exit-prefix"

#. type: table
#: original_texis/searching.texi:1821
msgid "Like @code{exit}, but add the key that was pressed to @code{unread-command-events} (@pxref{Event Input Misc})."
msgstr "@code{exit}と似ているが、@code{unread-command-events}にたいして押下されたキーを追加する(@ref{Event Input Misc}を参照)。"

#. type: item
#: original_texis/searching.texi:1822
#, no-wrap
msgid "act-and-exit"
msgstr "act-and-exit"

#. type: table
#: original_texis/searching.texi:1825
msgid "Answer this question ``yes'', and give up on the entire series of questions, assuming that subsequent answers will be ``no''."
msgstr "この問いにたいして``yes''を答えて、さらに一連の問いすべてにたいして後続の問いに``no''が応答されるとみなして問い合わせをあきらめる。"

#. type: item
#: original_texis/searching.texi:1826
#, no-wrap
msgid "act-and-show"
msgstr "act-and-show"

#. type: table
#: original_texis/searching.texi:1829
msgid "Answer this question ``yes'', but show the results---don't advance yet to the next question."
msgstr "この問いに``yes''を答えるが、結果を表示してまだ次の問いへ進まない。"

#. type: item
#: original_texis/searching.texi:1830
#, no-wrap
msgid "automatic"
msgstr "automatic"

#. type: table
#: original_texis/searching.texi:1833
msgid "Answer this question and all subsequent questions in the series with ``yes'', without further user interaction."
msgstr "これ以上のユーザーとの対話を行わず、この問いと後続の問いにたいして``yes''を答える。"

#. type: item
#: original_texis/searching.texi:1834
#, no-wrap
msgid "backup"
msgstr "backup"

#. type: table
#: original_texis/searching.texi:1836
msgid "Move back to the previous place that a question was asked about."
msgstr "前に問い合わせた以前の場所に戻る。"

#. type: item
#: original_texis/searching.texi:1837
#, no-wrap
msgid "edit"
msgstr "edit"

#. type: table
#: original_texis/searching.texi:1840
msgid "Enter a recursive edit to deal with this question---instead of any other action that would normally be taken."
msgstr "この問いに対処するために、通常とられるアクションのかわりに再帰編集にエンターする。"

#. type: item
#: original_texis/searching.texi:1841
#, no-wrap
msgid "edit-replacement"
msgstr "edit-replacement"

#. type: table
#: original_texis/searching.texi:1843
msgid "Edit the replacement for this question in the minibuffer."
msgstr "ミニバッファー内で、この問いにたいする置換を編集する。"

#. type: item
#: original_texis/searching.texi:1844
#, no-wrap
msgid "delete-and-edit"
msgstr "delete-and-edit"

#. type: table
#: original_texis/searching.texi:1847
msgid "Delete the text being considered, then enter a recursive edit to replace it."
msgstr "検討中のテキストを削除して、それを置換するために再帰編集にエンターする。"

#. type: item
#: original_texis/searching.texi:1848
#, no-wrap
msgid "recenter"
msgstr "recenter"

#. type: itemx
#: original_texis/searching.texi:1849
#, no-wrap
msgid "scroll-up"
msgstr "scroll-up"

#. type: itemx
#: original_texis/searching.texi:1850
#, no-wrap
msgid "scroll-down"
msgstr "scroll-down"

#. type: itemx
#: original_texis/searching.texi:1851
#, no-wrap
msgid "scroll-other-window"
msgstr "scroll-other-window"

#. type: itemx
#: original_texis/searching.texi:1852
#, no-wrap
msgid "scroll-other-window-down"
msgstr "scroll-other-window-down"

#. type: table
#: original_texis/searching.texi:1856
msgid "Perform the specified window scroll operation, then ask the same question again.  Only @code{y-or-n-p} and related functions use this answer."
msgstr "指定されたウィンドウスクロール操作を行って同じ問いを再度尋ねる。この問いには@code{y-or-n-p}と関連する関数だけが使用される。"

#. type: item
#: original_texis/searching.texi:1857
#, no-wrap
msgid "quit"
msgstr "quit"

#. type: table
#: original_texis/searching.texi:1860
msgid "Perform a quit right away.  Only @code{y-or-n-p} and related functions use this answer."
msgstr "即座にquitを行う。この問いには@code{y-or-n-p}と関連する関数だけが使用される。"

#. type: item
#: original_texis/searching.texi:1861
#, no-wrap
msgid "help"
msgstr "help"

#. type: table
#: original_texis/searching.texi:1863
msgid "Display some help, then ask again."
msgstr "ヘルプを表示して再度尋ねる。"

#. type: defvar
#: original_texis/searching.texi:1865
#, no-wrap
msgid "multi-query-replace-map"
msgstr "multi-query-replace-map"

#. type: defvar
#: original_texis/searching.texi:1869
msgid "This variable holds a keymap that extends @code{query-replace-map} by providing additional keybindings that are useful in multi-buffer replacements.  The additional bindings are:"
msgstr "この変数はマルチバッファー置換で有用な追加キーバインディングを提供することにより@code{query-replace-map}を拡張するキーマップを保持する。追加されるバインディングは以下のとおり:"

#. type: item
#: original_texis/searching.texi:1871
#, no-wrap
msgid "automatic-all"
msgstr "automatic-all"

#. type: table
#: original_texis/searching.texi:1874
msgid "Answer this question and all subsequent questions in the series with ``yes'', without further user interaction, for all remaining buffers."
msgstr "残りすべてのバッファーにたいして、それ以上の対話をせずその問いと後続のすべての問いに``yes''を答える。"

#. type: item
#: original_texis/searching.texi:1875
#, no-wrap
msgid "exit-current"
msgstr "exit-current"

#. type: table
#: original_texis/searching.texi:1879
msgid "Answer this question ``no'', and give up on the entire series of questions for the current buffer.  Continue to the next buffer in the sequence."
msgstr "この問いに``no''を答えてカレントバッファーにたいする一連の問いすべてをあきらめる。そしてシーケンス内の次のバッファーへ問いを継続する。"

#. type: defvar
#: original_texis/searching.texi:1882
#, no-wrap
msgid "replace-search-function"
msgstr "replace-search-function"

#. type: defvar
#: original_texis/searching.texi:1888
msgid "This variable specifies a function that @code{perform-replace} calls to search for the next string to replace.  Its default value is @code{search-forward}.  Any other value should name a function of 3 arguments: the first 3 arguments of @code{search-forward} (@pxref{String Search})."
msgstr "この変数は置換する次の文字列を検索するために@code{perform-replace}が呼び出す関数を指定する。デフォルト値は@code{search-forward}。それ以外の値の場合には@code{search-forward}の最初の3つの引数を引数とする関数を指定すること(@ref{String Search}を参照)。"

#. type: defvar
#: original_texis/searching.texi:1890
#, no-wrap
msgid "replace-re-search-function"
msgstr "replace-re-search-function"

#. type: defvar
#: original_texis/searching.texi:1896
msgid "This variable specifies a function that @code{perform-replace} calls to search for the next regexp to replace.  Its default value is @code{re-search-forward}.  Any other value should name a function of 3 arguments: the first 3 arguments of @code{re-search-forward} (@pxref{Regexp Search})."
msgstr "この変数は置換する次のregexpを検索するために@code{perform-replace}が呼び出す関数を指定する。デフォルト値は@code{re-search-forward}。それ以外の値の場合には@code{re-search-forward}の最初の3つの引数を引数とする関数を指定すること(@ref{Regexp Search}を参照)。"

#. type: section
#: original_texis/searching.texi:1899
#, no-wrap
msgid "Standard Regular Expressions Used in Editing"
msgstr "Standard Regular Expressions Used in Editing"

#. type: cindex
#: original_texis/searching.texi:1900
#, no-wrap
msgid "regexps used standardly in editing"
msgstr "regexps used standardly in editing"

#. type: cindex
#: original_texis/searching.texi:1901
#, no-wrap
msgid "standard regexps used in editing"
msgstr "standard regexps used in editing"

#. type: Plain text
#: original_texis/searching.texi:1905
msgid "This section describes some variables that hold regular expressions used for certain purposes in editing:"
msgstr "このセクションでは、編集において特定の目的のために使用される正規表現を保持するいくつかの変数を説明します。"

#. type: defopt
#: original_texis/searching.texi:1906
#, no-wrap
msgid "page-delimiter"
msgstr "page-delimiter"

#. type: defopt
#: original_texis/searching.texi:1911
msgid "This is the regular expression describing line-beginnings that separate pages.  The default value is @code{\"^\\014\"} (i.e., @code{\"^^L\"} or @code{\"^\\C-l\"}); this matches a line that starts with a formfeed character."
msgstr "これはページを分割する行開始を記述する正規表現。デフォルト値は@code{\"^\\014\"} (@code{\"^^L\"}または@code{\"^\\C-l\"})。これはフォームフィード文字(改頁文字)で始まる行とマッチする。"

#. type: Plain text
#: original_texis/searching.texi:1921
msgid "The following two regular expressions should @emph{not} assume the match always starts at the beginning of a line; they should not use @samp{^} to anchor the match.  Most often, the paragraph commands do check for a match only at the beginning of a line, which means that @samp{^} would be superfluous.  When there is a nonzero left margin, they accept matches that start after the left margin.  In that case, a @samp{^} would be incorrect.  However, a @samp{^} is harmless in modes where a left margin is never used."
msgstr "以下の2つの正規表現が、常に行頭からマッチが始まる正規表現とみなすべきでは@emph{ありません}。これらを@samp{^}にマッチするアンカーとして使用するべきではありません。ほとんどの場合では、パラグラフコマンドは行頭にたいしてのみマッチのチェックを行うので、これは@samp{^}が不要であることを意味します。非0の左マージンが存在する場合には、これらは左マージンの後から始まるマッチに適用されます。その場合には、@samp{^}は不適切でしょう。しかし左マージンを決して使用しないモードでは@samp{^}は無害でしょう。"

#. type: defopt
#: original_texis/searching.texi:1922
#, no-wrap
msgid "paragraph-separate"
msgstr "paragraph-separate"

#. type: defopt
#: original_texis/searching.texi:1928
msgid "This is the regular expression for recognizing the beginning of a line that separates paragraphs.  (If you change this, you may have to change @code{paragraph-start} also.)  The default value is @w{@code{\"[@ \\t\\f]*$\"}}, which matches a line that consists entirely of spaces, tabs, and form feeds (after its left margin)."
msgstr "これはパラグラフを分割する行の開始を認識する正規表現(これを変更する場合は@code{paragraph-start}も変更する必要があるかもしれない)。デフォルト値は@w{@code{\"[@ \\t\\f]*$\"}}であり、これは(左マージン以降)すべてがスペース、タブ、フォームフィードで構成される行とマッチする。"

#. type: defopt
#: original_texis/searching.texi:1930
#, no-wrap
msgid "paragraph-start"
msgstr "paragraph-start"

#. type: defopt
#: original_texis/searching.texi:1935
msgid "This is the regular expression for recognizing the beginning of a line that starts @emph{or} separates paragraphs.  The default value is @w{@code{\"\\f\\\\|[ \\t]*$\"}}, which matches a line containing only whitespace or starting with a form feed (after its left margin)."
msgstr "これはパラグラフを開始@emph{または}分割する行の開始を認識する正規表現。デフォルト値は@w{@code{\"\\f\\\\|[ \\t]*$\"}}であり、これは(左マージン以降)すべてが空白文字で構成される行やフォームフィードで始まる行とマッチする。"

#. type: defun
#: original_texis/searching.texi:1937 original_texis/searching.texi:1948
#, no-wrap
msgid "sentence-end"
msgstr "sentence-end"

#. type: defopt
#: original_texis/searching.texi:1941
msgid "If non-@code{nil}, the value should be a regular expression describing the end of a sentence, including the whitespace following the sentence.  (All paragraph boundaries also end sentences, regardless.)"
msgstr "非@code{nil}なら、以降に続く空白文字を含めてセンテンスの終わりを記述する正規表現であること(これとは無関係にパラグラフ境界もセンテンスを終了させる)。"

#. type: defopt
#: original_texis/searching.texi:1946
msgid "If the value is @code{nil}, as it is by default, then the function @code{sentence-end} constructs the regexp.  That is why you should always call the function @code{sentence-end} to obtain the regexp to be used to recognize the end of a sentence."
msgstr "値が@code{nil} (デフォルト)なら、関数@code{sentence-end}がregexpを構築する。センテンス終端の認識に使用するregexpを得るために常に関数@code{sentence-end}を使用するべきなのはこれが理由。"

#. type: defun
#: original_texis/searching.texi:1955
msgid "This function returns the value of the variable @code{sentence-end}, if non-@code{nil}.  Otherwise it returns a default value based on the values of the variables @code{sentence-end-double-space} (@pxref{Definition of sentence-end-double-space}), @code{sentence-end-without-period}, and @code{sentence-end-without-space}."
msgstr "この関数は変数@code{sentence-end}が非@code{nil}ならその値をリターンする。それ以外なら変数@code{sentence-end-double-space} (@ref{Definition of sentence-end-double-space}を参照)、@code{sentence-end-without-period}、@code{sentence-end-without-space}にもとづくデフォルト値をリターンする。"
