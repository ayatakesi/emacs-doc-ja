# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Emacs 25.1\n"
"POT-Creation-Date: 2020-08-02 05:44+0900\n"
"PO-Revision-Date: 2020-07-20 02:54+0900\n"
"Last-Translator: Ayanokoji Takesi <ayanokoji.takesi@gmail.com>\n"
"Language-Team: \n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: original_texis/searching.texi:6 original_texis/searching.texi:7
#, no-wrap
msgid "Searching and Matching"
msgstr "Searching and Matching"

#. type: cindex
#: original_texis/searching.texi:8
#, no-wrap
msgid "searching"
msgstr "searching"

#. type: Plain text
#: original_texis/searching.texi:15
msgid "GNU Emacs provides two ways to search through a buffer for specified text: exact string searches and regular expression searches.  After a regular expression search, you can examine the @dfn{match data} to determine which text matched the whole regular expression or various portions of it."
msgstr "GNU Emacsはバッファーから指定されたテキストを検索するために2つの手段を提供します。それは文字列の正確一致検索(exact string search)と正規表現検索(regular expression search)です。正規表現検索の後で、マッチしたテキストが正規表現全体にマッチしたのか、それとも正規表現のさまざまな部分に一致したかを判断するために@dfn{マッチデータ(match data)}を調べることができます。"

#. type: node
#: original_texis/searching.texi:26 original_texis/searching.texi:32
#, no-wrap
msgid "String Search"
msgstr "String Search"

#. type: menuentry
#: original_texis/searching.texi:26
msgid "Search for an exact match."
msgstr "正確なマッチの検索。"

#. type: section
#: original_texis/searching.texi:26 original_texis/searching.texi:191
#: original_texis/searching.texi:192
#, no-wrap
msgid "Searching and Case"
msgstr "Searching and Case"

#. type: menuentry
#: original_texis/searching.texi:26
msgid "Case-independent or case-significant searching."
msgstr "case-independentまたはcase-significantな検索。"

#. type: section
#: original_texis/searching.texi:26 original_texis/searching.texi:234
#: original_texis/searching.texi:235
#, no-wrap
msgid "Regular Expressions"
msgstr "Regular Expressions"

#. type: menuentry
#: original_texis/searching.texi:26
msgid "Describing classes of strings."
msgstr "文字列クラスの記述。"

#. type: node
#: original_texis/searching.texi:26 original_texis/searching.texi:1841
#, no-wrap
msgid "Regexp Search"
msgstr "Regexp Search"

#. type: menuentry
#: original_texis/searching.texi:26
msgid "Searching for a match for a regexp."
msgstr "regexpにたいするマッチの検索。"

#. type: node
#: original_texis/searching.texi:26 original_texis/searching.texi:2073
#, no-wrap
msgid "POSIX Regexps"
msgstr "POSIX Regexps"

#. type: menuentry
#: original_texis/searching.texi:26
msgid "Searching POSIX-style for the longest match."
msgstr "最長マッチにたいするPOSIXスタイルのマッチ。"

#. type: node
#: original_texis/searching.texi:26 original_texis/searching.texi:2118
#, no-wrap
msgid "Match Data"
msgstr "Match Data"

#. type: menuentry
#: original_texis/searching.texi:26
msgid "Finding out which part of the text matched, after a string or regexp search."
msgstr "文字列またはregexp検索後にテキストがマッチした部分を見つける。"

#. type: section
#: original_texis/searching.texi:26 original_texis/searching.texi:2528
#: original_texis/searching.texi:2529
#, no-wrap
msgid "Search and Replace"
msgstr "Search and Replace"

#. type: menuentry
#: original_texis/searching.texi:26
msgid "Commands that loop, searching and replacing."
msgstr "検索と置換を繰り返すコマンド。"

#. type: node
#: original_texis/searching.texi:26 original_texis/searching.texi:2748
#, no-wrap
msgid "Standard Regexps"
msgstr "Standard Regexps"

#. type: menuentry
#: original_texis/searching.texi:26
msgid "Useful regexps for finding sentences, pages,..."
msgstr "センテンスやページ等を探すために有用なregexp。"

#. type: Plain text
#: original_texis/searching.texi:31
msgid "The @samp{skip-chars@dots{}} functions also perform a kind of searching.  @xref{Skipping Characters}.  To search for changes in character properties, see @ref{Property Search}."
msgstr "@samp{skip-chars@dots{}}関連の関数もある種の検索を行います。@ref{Skipping Characters}を参照してください。文字プロパティ内の変更の検索は@ref{Property Search}を参照してください。"

#. type: section
#: original_texis/searching.texi:33
#, no-wrap
msgid "Searching for Strings"
msgstr "Searching for Strings"

#. type: cindex
#: original_texis/searching.texi:34
#, no-wrap
msgid "string search"
msgstr "string search"

#. type: Plain text
#: original_texis/searching.texi:42
msgid "These are the primitive functions for searching through the text in a buffer.  They are meant for use in programs, but you may call them interactively.  If you do so, they prompt for the search string; the arguments @var{limit} and @var{noerror} are @code{nil}, and @var{repeat} is 1.  For more details on interactive searching, @pxref{Search,, Searching and Replacement, emacs, The GNU Emacs Manual}."
msgstr "バッファー内のテキストを検索するためのプリミティブ関数が存在します。これらはプログラム内での使用を意図したものですがインタラクティブに呼び出すこともできます。これらをインタラクティブに呼び出すと検索文字列の入力を求めて、引数@var{limit}と@var{noerror}は@code{nil}、@var{repeat}は1になります。インタラクティブ検索に関するより詳細な情報は@ref{Search,, Searching and Replacement, emacs, The GNU Emacs Manual}を参照してください。"

#. type: Plain text
#: original_texis/searching.texi:46
msgid "These search functions convert the search string to multibyte if the buffer is multibyte; they convert the search string to unibyte if the buffer is unibyte.  @xref{Text Representations}."
msgstr "以下の検索関数はバッファーがマルチバイトバッファーならマルチバイト、ユニバイトバッファーならユニバイトに検索文字列を変換します。@ref{Text Representations}を参照してください。"

#. type: deffn
#: original_texis/searching.texi:47
#, no-wrap
msgid "Command search-forward string &optional limit noerror count"
msgstr "Command search-forward string &optional limit noerror count"

#. type: deffn
#: original_texis/searching.texi:52
msgid "This function searches forward from point for an exact match for @var{string}.  If successful, it sets point to the end of the occurrence found, and returns the new value of point.  If no match is found, the value and side effects depend on @var{noerror} (see below)."
msgstr "この関数は@var{string}にたいする正確なマッチをポイントから前方に検索する。成功したら見つかったマッチの終端にポイントをセットしてポイントの新たな値をリターンする。マッチが見つからない場合の値と副作用は@var{noerror} (以下参照)に依存する。"

#. type: deffn
#: original_texis/searching.texi:56
msgid "In the following example, point is initially at the beginning of the line.  Then @code{(search-forward \"fox\")} moves point after the last letter of @samp{fox}:"
msgstr "以下の例ではポイントは最初は行の先頭にある。その後の@code{(search-forward \"fox\")}によってポイントは@samp{fox}の最後の文字の後に移動する:"

#. type: group
#: original_texis/searching.texi:62
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"@point{}The quick brown fox jumped over the lazy dog.\n"
"---------- Buffer: foo ----------\n"
msgstr ""
"---------- Buffer: foo ----------\n"
"@point{}The quick brown fox jumped over the lazy dog.\n"
"---------- Buffer: foo ----------\n"

#. type: group
#: original_texis/searching.texi:67
#, no-wrap
msgid ""
"(search-forward \"fox\")\n"
"     @result{} 20\n"
"\n"
msgstr ""
"(search-forward \"fox\")\n"
"     @result{} 20\n"
"\n"

#. type: group
#: original_texis/searching.texi:71
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"The quick brown fox@point{} jumped over the lazy dog.\n"
"---------- Buffer: foo ----------\n"
msgstr ""
"---------- Buffer: foo ----------\n"
"The quick brown fox@point{} jumped over the lazy dog.\n"
"---------- Buffer: foo ----------\n"

#. type: deffn
#: original_texis/searching.texi:78
msgid "The argument @var{limit} specifies the bound to the search, and should be a position in the current buffer.  No match extending after that position is accepted.  If @var{limit} is omitted or @code{nil}, it defaults to the end of the accessible portion of the buffer."
msgstr "引数@var{limit}は検索の境界を指定するもので、それはカレントバッファー内の位置であること。その位置を超えるようなマッチは受け入れられない。@var{limit}が省略または@code{nil}の場合のデフォルトは、そのバッファーのアクセス可能範囲の終端。"

#. type: kindex
#: original_texis/searching.texi:79
#, no-wrap
msgid "search-failed"
msgstr "search-failed"

#. type: deffn
#: original_texis/searching.texi:88
msgid "What happens when the search fails depends on the value of @var{noerror}.  If @var{noerror} is @code{nil}, a @code{search-failed} error is signaled.  If @var{noerror} is @code{t}, @code{search-forward} returns @code{nil} and does nothing.  If @var{noerror} is neither @code{nil} nor @code{t}, then @code{search-forward} moves point to the upper bound and returns @code{nil}."
msgstr "検索失敗時に何が起こるかは@var{noerror}の値に依存する。@var{noerror}が@code{nil}なら@code{search-failed}はエラーをシグナルする。@var{noerror}が@code{t}なら@code{search-forward}は@code{nil}をリターンして何も行わない。@var{noerror}が@code{nil}と@code{t}いずれでもなければ、@code{search-forward}はポイントを境界上限に移動して@code{nil}をリターンする。"

#. type: deffn
#: original_texis/searching.texi:97 original_texis/searching.texi:1887
msgid "The argument @var{noerror} only affects valid searches which fail to find a match.  Invalid arguments cause errors regardless of @var{noerror}."
msgstr "引数@var{noerror}はマッチに失敗した有効な検索だけに影響する。無効な引数は@var{noerror}とは無関係にエラーとなる。"

#. type: deffn
#: original_texis/searching.texi:106 original_texis/searching.texi:1896
msgid "If @var{count} is a positive number @var{n}, the search is done @var{n} times; each successive search starts at the end of the previous match.  If all these successive searches succeed, the function call succeeds, moving point and returning its new value.  Otherwise the function call fails, with results depending on the value of @var{noerror}, as described above.  If @var{count} is a negative number @minus{}@var{n}, the search is done @var{n} times in the opposite (backward) direction."
msgstr "@var{count}が正の数@var{n}なら、それは繰り返し回数の役目をもつ。検索は@var{n}回繰り返され、前回のマッチの終端から毎回検索が開始される。これらの連続する検索が成功した場合、関数は成功となりポイントを移動して新たな値をリターンする。それ以外は検索失敗となり、上述したように結果は@var{noerror}の値に依存する。@var{count}が負の数 @minus{}@var{n}なら、それは逆方向(後方)への検索の繰り返し回数@var{n}としての役目をもつ。"

#. type: deffn
#: original_texis/searching.texi:108
#, no-wrap
msgid "Command search-backward string &optional limit noerror count"
msgstr "Command search-backward string &optional limit noerror count"

#. type: deffn
#: original_texis/searching.texi:113
msgid "This function searches backward from point for @var{string}.  It is like @code{search-forward}, except that it searches backwards rather than forwards.  Backward searches leave point at the beginning of the match."
msgstr "この関数はポイントから後方に@var{string}を検索する。これは@code{search-forward}と似ているが、前方ではなく後方に検索する点が異なる。後方への検索ではポイントはマッチの先頭に残される。"

#. type: deffn
#: original_texis/searching.texi:115
#, no-wrap
msgid "Command word-search-forward string &optional limit noerror count"
msgstr "Command word-search-forward string &optional limit noerror count"

#. type: deffn
#: original_texis/searching.texi:119
msgid "This function searches forward from point for a word match for @var{string}.  If it finds a match, it sets point to the end of the match found, and returns the new value of point."
msgstr "この関数はポイントから前方に@var{string}にたいする単語(word)のマッチを検索する。マッチが見つかったら見つかったマッチの終端にポイントをセットしてポイントの新たな値をリターンする。"

#. type: deffn
#: original_texis/searching.texi:126
msgid "Word matching regards @var{string} as a sequence of words, disregarding punctuation that separates them.  It searches the buffer for the same sequence of words.  Each word must be distinct in the buffer (searching for the word @samp{ball} does not match the word @samp{balls}), but the details of punctuation and spacing are ignored (searching for @samp{ball boy} does match @samp{ball.  Boy!})."
msgstr "単語マッチは@var{string}を単語のシーケンスとみなし、それらを分割する句読点は無視する。これはバッファーから同じ単語シーケンスを検索する。単語はそれぞれバッファー内で明確に区別されていなければならない(単語@samp{ball}の検索は単語@samp{balls}にマッチしない)が、句読点やスペース等の細部は無視される(@samp{ball boy}を検索すると@samp{ball.  Boy!}にマッチする)。"

#. type: deffn
#: original_texis/searching.texi:129
msgid "In this example, point is initially at the beginning of the buffer; the search leaves it between the @samp{y} and the @samp{!}."
msgstr "以下の例ではポイントは最初バッファー先頭にある。検索によりポイントは@samp{y}と@samp{!}の間に残される。"

#. type: group
#: original_texis/searching.texi:136
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"@point{}He said \"Please!  Find\n"
"the ball boy!\"\n"
"---------- Buffer: foo ----------\n"
msgstr ""
"---------- Buffer: foo ----------\n"
"@point{}He said \"Please!  Find\n"
"the ball boy!\"\n"
"---------- Buffer: foo ----------\n"

#. type: group
#: original_texis/searching.texi:141
#, no-wrap
msgid ""
"(word-search-forward \"Please find the ball, boy.\")\n"
"     @result{} 39\n"
"\n"
msgstr ""
"(word-search-forward \"Please find the ball, boy.\")\n"
"     @result{} 39\n"
"\n"

#. type: group
#: original_texis/searching.texi:146
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"He said \"Please!  Find\n"
"the ball boy@point{}!\"\n"
"---------- Buffer: foo ----------\n"
msgstr ""
"---------- Buffer: foo ----------\n"
"He said \"Please!  Find\n"
"the ball boy@point{}!\"\n"
"---------- Buffer: foo ----------\n"

#. type: deffn
#: original_texis/searching.texi:152
msgid "If @var{limit} is non-@code{nil}, it must be a position in the current buffer; it specifies the upper bound to the search.  The match found must not extend after that position."
msgstr "@var{limit}が非@code{nil}なら、それはカレントバッファー内の位置であること。これはその検索の境界上限を指定する。見つかったマッチはその位置を超えてはならない。"

#. type: deffn
#: original_texis/searching.texi:158
msgid "If @var{noerror} is @code{nil}, then @code{word-search-forward} signals an error if the search fails.  If @var{noerror} is @code{t}, then it returns @code{nil} instead of signaling an error.  If @var{noerror} is neither @code{nil} nor @code{t}, it moves point to @var{limit} (or the end of the accessible portion of the buffer) and returns @code{nil}."
msgstr "@var{noerror}が@code{nil}なら@code{word-search-forward}はエラーをシグナルする。@var{noerror}が@code{t}なら、エラーをシグナルするかわりに@code{nil}をリターンする。@var{noerror}が@code{nil}と@code{t}いずれでもなければ、ポイントを@var{limit}(またはバッファーのアクセス可能範囲の終端)に移動して@code{nil}をリターンする。"

#. type: deffn
#: original_texis/searching.texi:163
msgid "If @var{count} is a positive number, it specifies how many successive occurrences to search for.  Point is positioned at the end of the last match.  If @var{count} is a negative number, the search is backward and point is positioned at the beginning of the last match."
msgstr "@var{count}が正の数なら、それは連続して検索する回数を指定する。ポイントは最後のマッチの終端に配置される。@var{count}が負の数なら、逆方向に検索してポイントは最後のマッチの先頭に配置される。"

#. type: findex
#: original_texis/searching.texi:164
#, no-wrap
msgid "word-search-regexp"
msgstr "word-search-regexp"

#. type: deffn
#: original_texis/searching.texi:168
msgid "Internally, @code{word-search-forward} and related functions use the function @code{word-search-regexp} to convert @var{string} to a regular expression that ignores punctuation."
msgstr "@code{word-search-forward}および関連する関数は、@var{string}から句読点を無視した正規表現に変換するために、内部的には関数@code{word-search-regexp}を使用する。"

#. type: deffn
#: original_texis/searching.texi:170
#, no-wrap
msgid "Command word-search-forward-lax string &optional limit noerror count"
msgstr "Command word-search-forward-lax string &optional limit noerror count"

#. type: deffn
#: original_texis/searching.texi:176
msgid "This command is identical to @code{word-search-forward}, except that the beginning or the end of @var{string} need not match a word boundary, unless @var{string} begins or ends in whitespace.  For instance, searching for @samp{ball boy} matches @samp{ball boyee}, but does not match @samp{balls boy}."
msgstr "このコマンドは@code{word-search-forward}と同じだが、@var{string}が空白で開始か終了していなければ、@var{string}の先頭か終端が単語境界にマッチする必要がない点が異なる。たとえば@samp{ball boy}の検索は@samp{ball boyee}にはマッチするが、@samp{balls boy}にはマッチしない。"

#. type: deffn
#: original_texis/searching.texi:178
#, no-wrap
msgid "Command word-search-backward string &optional limit noerror count"
msgstr "Command word-search-backward string &optional limit noerror count"

#. type: deffn
#: original_texis/searching.texi:183
msgid "This function searches backward from point for a word match to @var{string}.  This function is just like @code{word-search-forward} except that it searches backward and normally leaves point at the beginning of the match."
msgstr "この関数はポイントから後方へ@var{string}にマッチする単語を検索する。この関数は@code{word-search-forward}と同様だが、後方に検索して通常はマッチの先頭にポイントを残す点が異なる。"

#. type: deffn
#: original_texis/searching.texi:185
#, no-wrap
msgid "Command word-search-backward-lax string &optional limit noerror count"
msgstr "Command word-search-backward-lax string &optional limit noerror count"

#. type: deffn
#: original_texis/searching.texi:189
msgid "This command is identical to @code{word-search-backward}, except that the beginning or the end of @var{string} need not match a word boundary, unless @var{string} begins or ends in whitespace."
msgstr "このコマンドは@code{word-search-backward}と同じだが、文字列が空白で開始か終了していなければ、@var{string}の先頭か終端が単語境界にマッチする必要がない点が異なる。"

#. type: cindex
#: original_texis/searching.texi:193
#, no-wrap
msgid "searching and case"
msgstr "searching and case"

#. type: Plain text
#: original_texis/searching.texi:200
msgid "By default, searches in Emacs ignore the case of the text they are searching through; if you specify searching for @samp{FOO}, then @samp{Foo} or @samp{foo} is also considered a match.  This applies to regular expressions, too; thus, @samp{[aB]} would match @samp{a} or @samp{A} or @samp{b} or @samp{B}."
msgstr "デフォルトのEmacs検索では検索するテキストのcase(大文字と小文字)は無視されます。検索対象に@samp{FOO}を指定すると、@samp{Foo}や@samp{foo}もマッチとみなされます。これは正規表現にも適用されます。つまり@samp{[aB]}は@samp{a}、@samp{A}、@samp{b}、@samp{B}にもマッチするでしょう。"

#. type: Plain text
#: original_texis/searching.texi:208
msgid "If you do not want this feature, set the variable @code{case-fold-search} to @code{nil}.  Then all letters must match exactly, including case.  This is a buffer-local variable; altering the variable affects only the current buffer.  (@xref{Intro to Buffer-Local}.)  Alternatively, you may change the default value.  In Lisp code, you will more typically use @code{let} to bind @code{case-fold-search} to the desired value."
msgstr "この機能が望ましくなければ変数@code{case-fold-search}に@code{nil}をセットしてください。その場合にはすべての文字はcaseを含めて正確にマッチしなければなりません。これはバッファーローカル変数です。この変数の変更はカレントバッファーだけに影響を与えます(@ref{Intro to Buffer-Local}を参照)。かわりにデフォルト値を変更することもできます。Lispコードでは@code{let}を使用して@code{case-fold-search}を望む値にバインドするほうが、より一般的でしょう。"

#. type: Plain text
#: original_texis/searching.texi:216
msgid "Note that the user-level incremental search feature handles case distinctions differently.  When the search string contains only lower case letters, the search ignores case, but when the search string contains one or more upper case letters, the search becomes case-sensitive.  But this has nothing to do with the searching functions used in Lisp code.  @xref{Incremental Search,,, emacs, The GNU Emacs Manual}."
msgstr "ユーザーレベルのインクリメンタル検索機能ではcaseの区別が異なることに注意してください。検索文字列に含まれるのが小文字だけなら検索はcaseを無視しますが、検索文字列に1つ以上の大文字が含まれれば検索はcaseを区別するようになります。しかしLispコード内で使用される検索関数では、これは何も行いません。@ref{Incremental Search,,, emacs, The GNU Emacs Manual}を参照してください。"

#. type: defopt
#: original_texis/searching.texi:217
#, no-wrap
msgid "case-fold-search"
msgstr "case-fold-search"

#. type: defopt
#: original_texis/searching.texi:221
msgid "This buffer-local variable determines whether searches should ignore case.  If the variable is @code{nil} they do not ignore case; otherwise (and by default) they do ignore case."
msgstr "このバッファーローカル変数は検索がcaseを無視するべきかどうかを決定する。この変数が@code{nil}なら検索はcaseを無視しない。それ以外(とデフォルト)ではcaseを無視する。"

#. type: defopt
#: original_texis/searching.texi:223
#, no-wrap
msgid "case-replace"
msgstr "case-replace"

#. type: defopt
#: original_texis/searching.texi:229
msgid "This variable determines whether the higher-level replacement functions should preserve case.  If the variable is @code{nil}, that means to use the replacement text verbatim.  A non-@code{nil} value means to convert the case of the replacement text according to the text being replaced."
msgstr "この変数は高レベルの置換関数がcaseを保持するべきかどうかを決定する。この変数が@code{nil}なら、それは置換テキストをそのまま使用することを意味する。非@code{nil}値は置換されるテキストに応じて、置換テキストのcaseを変換することを意味する。"

#. type: defopt
#: original_texis/searching.texi:232
msgid "This variable is used by passing it as an argument to the function @code{replace-match}.  @xref{Replacing Match}."
msgstr "この変数は関数@code{replace-match}の引数として渡すことにより使用される。@ref{Replacing Match}を参照のこと。"

#. type: cindex
#: original_texis/searching.texi:236
#, no-wrap
msgid "regular expression"
msgstr "regular expression"

#. type: cindex
#: original_texis/searching.texi:237
#, no-wrap
msgid "regexp"
msgstr "regexp"

#. type: Plain text
#: original_texis/searching.texi:243
msgid "A @dfn{regular expression}, or @dfn{regexp} for short, is a pattern that denotes a (possibly infinite) set of strings.  Searching for matches for a regexp is a very powerful operation.  This section explains how to write regexps; the following section says how to search for them."
msgstr "@dfn{正規表現(regular expression)}、略して@dfn{regexp}は文字列の(もしかしたら無限の)セットを表すパターンのことです。regexpにたいするマッチの検索はとても強力な処理です。このセクションではregexpの記述方法、それ以降のセクションではそれらを検索する方法を示します。"

#. type: findex
#: original_texis/searching.texi:244
#, no-wrap
msgid "re-builder"
msgstr "re-builder"

#. type: cindex
#: original_texis/searching.texi:245
#, no-wrap
msgid "regular expressions, developing"
msgstr "regular expressions, developing"

#. type: Plain text
#: original_texis/searching.texi:253
msgid "For interactive development of regular expressions, you can use the @kbd{M-x re-builder} command.  It provides a convenient interface for creating regular expressions, by giving immediate visual feedback in a separate buffer.  As you edit the regexp, all its matches in the target buffer are highlighted.  Each parenthesized sub-expression of the regexp is shown in a distinct face, which makes it easier to verify even very complex regexps."
msgstr "正規表現を対話的に開発するために@kbd{M-x re-builder}コマンドを使用できます。このコマンドは別のバッファーに即座に視覚的なフィードバックを表示することにより、正規表現を作成するための便利なインターフェースを提供します。regexp編集とともにターゲットとなるバッファーのすべてのマッチがハイライトされます。カッコで括られたregexpの部分式(sub-expression)は別のフェイスで表示され、非常に複雑なregexpを簡単に検証することが可能になります。"

#. type: node
#: original_texis/searching.texi:257 original_texis/searching.texi:263
#, no-wrap
msgid "Syntax of Regexps"
msgstr "Syntax of Regexps"

#. type: menuentry
#: original_texis/searching.texi:257
msgid "Rules for writing regular expressions."
msgstr "正規表現の記述ルール。"

#. type: node
#: original_texis/searching.texi:257 original_texis/searching.texi:907
#, no-wrap
msgid "Regexp Example"
msgstr "Regexp Example"

#. type: menuentry
#: original_texis/searching.texi:257
msgid "Illustrates regular expression syntax."
msgstr "正規表現構文の説明。"

#. type: ifnottex
#: original_texis/searching.texi:259
msgid "* Rx Notation:: An alternative, structured regexp notation."
msgstr ""

#. type: node
#: original_texis/searching.texi:261 original_texis/searching.texi:1714
#, no-wrap
msgid "Regexp Functions"
msgstr "Regexp Functions"

#. type: menuentry
#: original_texis/searching.texi:261
msgid "Functions for operating on regular expressions."
msgstr "正規表現を操作する関数。"

#. type: subsection
#: original_texis/searching.texi:264
#, no-wrap
msgid "Syntax of Regular Expressions"
msgstr "Syntax of Regular Expressions"

#. type: cindex
#: original_texis/searching.texi:265 original_texis/searching.texi:990
#, no-wrap
msgid "regexp syntax"
msgstr "regexp syntax"

#. type: cindex
#: original_texis/searching.texi:266
#, no-wrap
msgid "syntax of regular expressions"
msgstr "syntax of regular expressions"

#. type: Plain text
#: original_texis/searching.texi:279
msgid "Regular expressions have a syntax in which a few characters are special constructs and the rest are @dfn{ordinary}.  An ordinary character is a simple regular expression that matches that character and nothing else.  The special characters are @samp{.}, @samp{*}, @samp{+}, @samp{?}, @samp{[}, @samp{^}, @samp{$}, and @samp{\\}; no new special characters will be defined in the future.  The character @samp{]} is special if it ends a character alternative (see later).  The character @samp{-} is special inside a character alternative.  A @samp{[:} and balancing @samp{:]} enclose a character class inside a character alternative.  Any other character appearing in a regular expression is ordinary, unless a @samp{\\} precedes it."
msgstr "正規表現は少数の文字が特別な構成要素であり、残りは@dfn{通常}の文字であるような構文をもちます。通常の文字はその文字自身だけにマッチするシンプルな正規表現です。特別な文字は@samp{.}、@samp{*}、@samp{+}、@samp{?}、@samp{[}、@samp{^}、@samp{$}、および@samp{\\}です。将来に新たなスペシャル文字が定義されることはないでしょう。文字候補で終わる場合には@samp{]}はスペシャル文字です。文字候補の間では@samp{-}はスペシャル文字です。@samp{[:}と対応する@samp{:]}は文字候補内の文字クラスです。正規表現内に出現する他の文字は@samp{\\}が前置されていない限り通常の文字です。"

#. type: Plain text
#: original_texis/searching.texi:285
msgid "For example, @samp{f} is not a special character, so it is ordinary, and therefore @samp{f} is a regular expression that matches the string @samp{f} and no other string.  (It does @emph{not} match the string @samp{fg}, but it does match a @emph{part} of that string.)  Likewise, @samp{o} is a regular expression that matches only @samp{o}."
msgstr "たとえば@samp{f}はスペシャル文字ではなく通常文字なので、@samp{f}は文字列@samp{f}にマッチして他の文字にはマッチしない正規表現です(これは文字列@samp{fg}には@emph{マッチしない}が、その文字列の@emph{部分}にマッチする)。同様に@samp{o}は@samp{o}だけにマッチします。"

#. type: Plain text
#: original_texis/searching.texi:290
msgid "Any two regular expressions @var{a} and @var{b} can be concatenated.  The result is a regular expression that matches a string if @var{a} matches some amount of the beginning of that string and @var{b} matches the rest of the string."
msgstr "任意の2つの正規表現@var{a}と@var{b}を結合することができます。結合した結果は文字列の先頭からある長さの文字列が@var{a}にマッチして、残りの文字列が@var{b}にマッチするような文字列にマッチする正規表現になります。"

#. type: Plain text
#: original_texis/searching.texi:295
msgid "As a simple example, we can concatenate the regular expressions @samp{f} and @samp{o} to get the regular expression @samp{fo}, which matches only the string @samp{fo}.  Still trivial.  To do something more powerful, you need to use one of the special regular expression constructs."
msgstr "単純な例として文字列@samp{fo}だけにマッチする正規表現の構成要素@samp{fo}を取得するために正規表現@samp{f}と@samp{o}を結合できます。"

#. type: node
#: original_texis/searching.texi:300 original_texis/searching.texi:302
#, no-wrap
msgid "Regexp Special"
msgstr "Regexp Special"

#. type: menuentry
#: original_texis/searching.texi:300
msgid "Special characters in regular expressions."
msgstr "正規表現内のスペシャル文字。"

#. type: node
#: original_texis/searching.texi:300 original_texis/searching.texi:577
#, no-wrap
msgid "Char Classes"
msgstr "Char Classes"

#. type: menuentry
#: original_texis/searching.texi:300
msgid "Character classes used in regular expressions."
msgstr "正規表現内で使用される文字クラス。"

#. type: node
#: original_texis/searching.texi:300 original_texis/searching.texi:654
#, no-wrap
msgid "Regexp Backslash"
msgstr "Regexp Backslash"

#. type: menuentry
#: original_texis/searching.texi:300
msgid "Backslash-sequences in regular expressions."
msgstr "正規表現内のバックスラッシュシーケンス。"

#. type: subsubsection
#: original_texis/searching.texi:303
#, no-wrap
msgid "Special Characters in Regular Expressions"
msgstr "Special Characters in Regular Expressions"

#. type: cindex
#: original_texis/searching.texi:304
#, no-wrap
msgid "regexp, special characters in"
msgstr "regexp, special characters in"

#. type: Plain text
#: original_texis/searching.texi:308
msgid "Here is a list of the characters that are special in a regular expression."
msgstr "以下は正規表現内で特別な文字のリストです:"

#. type: item
#: original_texis/searching.texi:311
#, no-wrap
msgid "@samp{.}@: @r{(Period)}"
msgstr "@samp{.}@: @r{(Period)}"

#. type: cindex
#: original_texis/searching.texi:312
#, no-wrap
msgid "@samp{.} in regexp"
msgstr "@samp{.} in regexp"

#. type: table
#: original_texis/searching.texi:317
msgid "is a special character that matches any single character except a newline.  Using concatenation, we can make regular expressions like @samp{a.b}, which matches any three-character string that begins with @samp{a} and ends with @samp{b}."
msgstr "これは改行を除く1文字にマッチする。結合を使用して@samp{a.b}のような正規表現を作成できる。これは@samp{a}で始まり@samp{b}で終わる3文字の文字列にマッチする。"

#. type: samp{#1}
#: original_texis/searching.texi:318
#, no-wrap
msgid "*"
msgstr "*"

#. type: cindex
#: original_texis/searching.texi:319
#, no-wrap
msgid "@samp{*} in regexp"
msgstr "@samp{*} in regexp"

#. type: table
#: original_texis/searching.texi:324
msgid "is not a construct by itself; it is a postfix operator that means to match the preceding regular expression repetitively as many times as possible.  Thus, @samp{o*} matches any number of @samp{o}s (including no @samp{o}s)."
msgstr "これはそれ自身が構成要素ではない。これは前置された正規表現を可能な限り繰り返したものにマッチすることを意味する後置演算子である。したがって@samp{o*}は任意の個数の@samp{o}にマッチする(@samp{o}を含まない場合にもマッチする)。"

#. type: table
#: original_texis/searching.texi:328
msgid "@samp{*} always applies to the @emph{smallest} possible preceding expression.  Thus, @samp{fo*} has a repeating @samp{o}, not a repeating @samp{fo}.  It matches @samp{f}, @samp{fo}, @samp{foo}, and so on."
msgstr "@samp{*}は常に前置された表現の@emph{最小}の表現に適用される。つまり@samp{fo*}は@samp{o}の繰り返しであり@samp{fo}の繰り返しではない。これは@samp{f}、@samp{fo}、@samp{foo}、...にマッチする。"

#. type: cindex
#: original_texis/searching.texi:329
#, no-wrap
msgid "backtracking and regular expressions"
msgstr "backtracking and regular expressions"

#. type: table
#: original_texis/searching.texi:340
msgid "The matcher processes a @samp{*} construct by matching, immediately, as many repetitions as can be found.  Then it continues with the rest of the pattern.  If that fails, backtracking occurs, discarding some of the matches of the @samp{*}-modified construct in the hope that this will make it possible to match the rest of the pattern.  For example, in matching @samp{ca*ar} against the string @samp{caaar}, the @samp{a*} first tries to match all three @samp{a}s; but the rest of the pattern is @samp{ar} and there is only @samp{r} left to match, so this try fails.  The next alternative is for @samp{a*} to match only two @samp{a}s.  With this choice, the rest of the regexp matches successfully."
msgstr "マッチを行う処理は構成要素@samp{*}をマッチングにより即座に見つけ得る回数分処理して、その後にパターンの残りを継続する。これが失敗したら残りのパターンのマッチが可能になるかもしれないという期待のもとに、@samp{*}の変更された構成のうちいくつかのマッチを破棄することでバックトラッキングが発生する。たとえば文字列@samp{caaar}にたいして@samp{ca*ar}をマッチングすると、@samp{a*}はまず3つすべての@samp{a}へのマッチを試みる。しかし残りのパターンは@samp{ar}であり、マッチ対象に残されているのは@samp{r}だけなので試みは失敗する。@samp{a*}にたいする次の代替策は、2つの@samp{a}だけへのマッチである。この選択では残りのregexpのマッチは成功する。"

#. type: table
#: original_texis/searching.texi:351
msgid "@strong{Warning:} Nested repetition operators can run for an indefinitely long time, if they lead to ambiguous matching.  For example, trying to match the regular expression @samp{\\(x+y*\\)*a} against the string @samp{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz} could take hours before it ultimately fails.  Emacs must try each way of grouping the @samp{x}s before concluding that none of them can work.  Even worse, @samp{\\(x*\\)*} can match the null string in infinitely many ways, so it causes an infinite loop.  To avoid these problems, check nested repetitions carefully, to make sure that they do not cause combinatorial explosions in backtracking."
msgstr "@strong{警告:} ネストされた繰り返し処理は、それらが曖昧なマッチとなるような場合には無期限な長時間の実行となり得る。たとえば文字列@samp{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz}にたいして正規表現@samp{\\(x+y*\\)*a}のマッチを試みると、それが最終的に失敗するまでに数時間を要す可能性がある。Emacsはその試みのいずれも機能しないと結論する前に、@samp{x}のグループ化のそれぞれを試みなければならない。さらに悪いことに@samp{\\(x*\\)*}は無数の方法でnull文字列にマッチ可能なので無限ループを引き起こす。これらの問題を避けるにはネストされた繰り返しがバックトラッキングでの組み合わせ爆発(combinatorial explosion)が発生しないことを確実にするために注意深くチェックすること。"

#. type: samp{#1}
#: original_texis/searching.texi:352
#, no-wrap
msgid "+"
msgstr "+"

#. type: cindex
#: original_texis/searching.texi:353
#, no-wrap
msgid "@samp{+} in regexp"
msgstr "@samp{+} in regexp"

#. type: table
#: original_texis/searching.texi:358
msgid "is a postfix operator, similar to @samp{*} except that it must match the preceding expression at least once.  So, for example, @samp{ca+r} matches the strings @samp{car} and @samp{caaaar} but not the string @samp{cr}, whereas @samp{ca*r} matches all three strings."
msgstr "これは@samp{*}のような後置演算子だが前置された表現に少なくとも1回マッチしなければならない点が異なる。たとえば@samp{ca+r}は文字列@samp{car}や@samp{caaaar}にマッチするが文字列@samp{cr}にはマッチせず、その一方で@samp{ca*r}はこれら3つすべての文字列にマッチする。"

#. type: samp{#1}
#: original_texis/searching.texi:359
#, no-wrap
msgid "?"
msgstr "?"

#. type: cindex
#: original_texis/searching.texi:360
#, no-wrap
msgid "@samp{?} in regexp"
msgstr "@samp{?} in regexp"

#. type: table
#: original_texis/searching.texi:364
msgid "is a postfix operator, similar to @samp{*} except that it must match the preceding expression either once or not at all.  For example, @samp{ca?r} matches @samp{car} or @samp{cr}; nothing else."
msgstr "これは@samp{*}のような後置演算子だが前置された表現に1回、またはマッチしないかのいずれかでなければならない点が異なる。例えば@samp{ca?r}は@samp{car}と@samp{cr}にマッチするが他にはマッチしない。"

#. type: anchor{#1}
#: original_texis/searching.texi:366
#, fuzzy
#| msgid "non-greedy repetition characters in regexp"
msgid "Non-greedy repetition"
msgstr "non-greedy repetition characters in regexp"

#. type: item
#: original_texis/searching.texi:366
#, no-wrap
msgid "@samp{*?}, @samp{+?}, @samp{??}"
msgstr "@samp{*?}, @samp{+?}, @samp{??}"

#. type: cindex
#: original_texis/searching.texi:367
#, no-wrap
msgid "non-greedy repetition characters in regexp"
msgstr "non-greedy repetition characters in regexp"

#. type: table
#: original_texis/searching.texi:373
msgid "These are @dfn{non-greedy} variants of the operators @samp{*}, @samp{+} and @samp{?}.  Where those operators match the largest possible substring (consistent with matching the entire containing expression), the non-greedy variants match the smallest possible substring (consistent with matching the entire containing expression)."
msgstr "演算子 @samp{*}、@samp{+}、@samp{?}には@dfn{非欲張り(non-greedy)}な変種が存在する。これらの演算子が可能な最長の部分文字列(含まれる表現全体へのマッチと等しい)とマッチするのにたいして、非欲張りな変種は可能な最短の部分文字列(含まれる表現全体と等しい)にマッチする。"

#. type: table
#: original_texis/searching.texi:379
msgid "For example, the regular expression @samp{c[ad]*a} when applied to the string @samp{cdaaada} matches the whole string; but the regular expression @samp{c[ad]*?a}, applied to that same string, matches just @samp{cda}.  (The smallest possible match here for @samp{[ad]*?} that permits the whole expression to match is @samp{d}.)"
msgstr "たとえば正規表現@samp{c[ad]*a}を文字列@samp{cdaaada}に適用すると文字列全体にマッチするが、正規表現@samp{c[ad]*?a}を同じ文字列に適用すると@samp{cda}だけにマッチする(ここでマッチが許された表現全体にたいする@samp{[ad]*?}の可能な最短マッチは@samp{d})。"

#. type: samp{#1}
#: original_texis/searching.texi:380
#, no-wrap
msgid "[ @dots{} ]"
msgstr "[ @dots{} ]"

#. type: cindex
#: original_texis/searching.texi:381
#, no-wrap
msgid "character alternative (in regexp)"
msgstr "character alternative (in regexp)"

#. type: cindex
#: original_texis/searching.texi:382
#, no-wrap
msgid "@samp{[} in regexp"
msgstr "@samp{[} in regexp"

#. type: cindex
#: original_texis/searching.texi:383
#, no-wrap
msgid "@samp{]} in regexp"
msgstr "@samp{]} in regexp"

#. type: table
#: original_texis/searching.texi:387
msgid "is a @dfn{character alternative}, which begins with @samp{[} and is terminated by @samp{]}.  In the simplest case, the characters between the two brackets are what this character alternative can match."
msgstr "これは@samp{[}で始まり@samp{]}で終端される@dfn{文字候補(character alternative)}。もっとも単純なケースでは、この２つのカッコ(brackets)の間にある文字が、この文字候補がマッチ可能な文字。"

#. type: table
#: original_texis/searching.texi:392
msgid "Thus, @samp{[ad]} matches either one @samp{a} or one @samp{d}, and @samp{[ad]*} matches any string composed of just @samp{a}s and @samp{d}s (including the empty string).  It follows that @samp{c[ad]*r} matches @samp{cr}, @samp{car}, @samp{cdr}, @samp{caddaar}, etc."
msgstr "したがって@samp{[ad]}は1つの@samp{a}と1つの@samp{d}の両方にマッチし、@samp{[ad]*}は@samp{a}と@samp{d}だけで構成された任意の文字列(空文字列を含む)にマッチする。つまり@samp{c[ad]*r}は@samp{cr}、@samp{car}、@samp{cdr}、@samp{caddaar}等にマッチする。"

#. type: table
#: original_texis/searching.texi:401
msgid "You can also include character ranges in a character alternative, by writing the starting and ending characters with a @samp{-} between them.  Thus, @samp{[a-z]} matches any lower-case @acronym{ASCII} letter.  Ranges may be intermixed freely with individual characters, as in @samp{[a-z$%.]}, which matches any lower case @acronym{ASCII} letter or @samp{$}, @samp{%} or period.  However, the ending character of one range should not be the starting point of another one; for example, @samp{[a-m-z]} should be avoided."
msgstr "開始文字と終了文字の間に@samp{-}を記述することにより文字候補内に文字範囲を含めることができる。つまり@samp{[a-z]}は小文字の@acronym{ASCII}アルファベット文字にマッチする。範囲は@samp{[a-z$%.]}のように個別の文字と自由に組み合わせることができる。これは任意の@acronym{ASCII}小文字アルファベットと@samp{$}、@samp{%}、またはピリオドとマッチする。しかし1つの範囲の終端文字が別の範囲の開始文字ではないこと。たとえば@samp{[a-m-z]}は使用しないこと。"

#. type: table
#: original_texis/searching.texi:410
msgid "A character alternative can also specify named character classes (@pxref{Char Classes}).  This is a POSIX feature.  For example, @samp{[[:ascii:]]} matches any @acronym{ASCII} character.  Using a character class is equivalent to mentioning each of the characters in that class; but the latter is not feasible in practice, since some classes include thousands of different characters.  A character class should not appear as the lower or upper bound of a range."
msgstr "文字候補には名前付き文字クラスも指定できる(@ref{Char Classes}を参照)。これはPOSIXの機能。たとえば@samp{[[:ascii:]]}は任意の@acronym{ASCII}文字にマッチする。文字クラスの使用は、そのクラス内すべての文字を記述するのと等しい。しかし異なる文字数千を含むクラスもあるので後者は実際は実現不可能。文字クラス範囲の上側や下側の境界に出現するべきではない。"

#. type: table
#: original_texis/searching.texi:419
msgid "The usual regexp special characters are not special inside a character alternative.  A completely different set of characters is special: @samp{]}, @samp{-} and @samp{^}.  To include @samp{]} in a character alternative, put it at the beginning.  To include @samp{^}, put it anywhere but at the beginning.  To include @samp{-}, put it at the end.  Thus, @samp{[]^-]} matches all three of these special characters.  You cannot use @samp{\\} to escape these three characters, since @samp{\\} is not special here."
msgstr ""

#. type: table
#: original_texis/searching.texi:423
msgid "The following aspects of ranges are specific to Emacs, in that POSIX allows but does not require this behavior and programs other than Emacs may behave differently:"
msgstr "以下の範囲にたいする側面はEmacs固有であり、POSIXはこの振る舞いを許容はするが必須ではなく、Emacs以外のプログラムは異なる振る舞いをするかもしれない。"

#. type: enumerate
#: original_texis/searching.texi:428
msgid "If @code{case-fold-search} is non-@code{nil}, @samp{[a-z]} also matches upper-case letters."
msgstr "@code{case-fold-search}が非@code{nil}なら@samp{[a-z]}は大文字にもマッチする。"

#. type: enumerate
#: original_texis/searching.texi:434
msgid "A range is not affected by the locale's collation sequence: it always represents the set of characters with codepoints ranging between those of its bounds, so that @samp{[a-z]} matches only ASCII letters, even outside the C or POSIX locale."
msgstr "範囲はlocaleの照合順の影響を受けない。範囲は常にその範囲の境界間に存在するコードポイントを文字セットで表現されるので、たとえCやPOSIXのlocale外部でも@samp{[a-z]}がマッチするのはASCII文字のみ。"

#. type: enumerate
#: original_texis/searching.texi:443
#, fuzzy
#| msgid "If the lower bound of a range is greater than its upper bound, the range is empty and represents no characters.  Thus, @samp{[b-a]} always fails to match, and @samp{[^b-a]} matches any character, including newline.  However, the lower bound should be at most one greater than the upper bound; for example, @samp{[c-a]} should be avoided."
msgid "If the lower bound of a range is greater than its upper bound, the range is empty and represents no characters.  Thus, @samp{[z-a]} always fails to match, and @samp{[^z-a]} matches any character, including newline.  However, a reversed range should always be from the letter @samp{z} to the letter @samp{a} to make it clear that it is not a typo; for example, @samp{[+-*/]} should be avoided, because it matches only @samp{/} rather than the likely-intended four characters."
msgstr "範囲の下側境界が上側境界より大きければ範囲は空であり何の文字も表現しない。したがって@samp{[b-a]}は常にマッチに失敗するし、@samp{[^b-a]}は改行を含む任意の文字にマッチする。しかし下側境界は最大でも上側境界より1大きいこと。たとえば@samp{[c-a]}は使用しないこと。"

#. type: table
#: original_texis/searching.texi:447
msgid "Some kinds of character alternatives are not the best style even though they have a well-defined meaning in Emacs.  They include:"
msgstr ""

#. type: enumerate
#: original_texis/searching.texi:457
msgid "Although a range's bound can be almost any character, it is better style to stay within natural sequences of ASCII letters and digits because most people have not memorized character code tables.  For example, @samp{[.-9]} is less clear than @samp{[./0-9]}, and @samp{[`-~]} is less clear than @samp{[`a-z@{|@}~]}.  Unicode character escapes can help here; for example, for most programmers @samp{[ก-ฺ฿-๛]} is less clear than @samp{[\\u0E01-\\u0E3A\\u0E3F-\\u0E5B]}."
msgstr ""

#. type: enumerate
#: original_texis/searching.texi:462
msgid "Although a character alternative can include duplicates, it is better style to avoid them.  For example, @samp{[XYa-yYb-zX]} is less clear than @samp{[XYa-z]}."
msgstr ""

#. type: enumerate
#: original_texis/searching.texi:468
msgid "Although a range can denote just one, two, or three characters, it is simpler to list the characters.  For example, @samp{[a-a0]} is less clear than @samp{[a0]}, @samp{[i-j]} is less clear than @samp{[ij]}, and @samp{[i-k]} is less clear than @samp{[ijk]}."
msgstr ""

#. type: enumerate
#: original_texis/searching.texi:475
msgid "Although a @samp{-} can appear at the beginning of a character alternative or as the upper bound of a range, it is better style to put @samp{-} by itself at the end of a character alternative.  For example, although @samp{[-a-z]} is valid, @samp{[a-z-]} is better style; and although @samp{[*--]} is valid, @samp{[*+,-]} is clearer."
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:477
#, no-wrap
msgid "[^ @dots{} ]"
msgstr "[^ @dots{} ]"

#. type: cindex
#: original_texis/searching.texi:478
#, no-wrap
msgid "@samp{^} in regexp"
msgstr "@samp{^} in regexp"

#. type: table
#: original_texis/searching.texi:483
#, fuzzy
#| msgid "@samp{[^} begins a @dfn{complemented character alternative}.  This matches any character except the ones specified.  Thus, @samp{[^a-z0-9A-Z]} matches all characters @emph{except} letters and digits."
msgid "@samp{[^} begins a @dfn{complemented character alternative}.  This matches any character except the ones specified.  Thus, @samp{[^a-z0-9A-Z]} matches all characters @emph{except} ASCII letters and digits."
msgstr "@samp{[^}は@dfn{補完文字候補(complemented character alternative)}を開始する。これは指定された以外の任意の文字とマッチする。つまり@samp{[^a-z0-9A-Z]}はアルファベットと数字@emph{以外}の、すべての文字にマッチする。"

#. type: table
#: original_texis/searching.texi:487
msgid "@samp{^} is not special in a character alternative unless it is the first character.  The character following the @samp{^} is treated as if it were first (in other words, @samp{-} and @samp{]} are not special there)."
msgstr "@samp{^}は文字クラス内では先頭に記述されない限り特別ではない。@samp{^}に続く文字は、あたかもそれが先頭にあるかのように扱われる(言い換えると@samp{-}や@samp{]}はここでは特別ではない)。"

#. type: table
#: original_texis/searching.texi:491
msgid "A complemented character alternative can match a newline, unless newline is mentioned as one of the characters not to match.  This is in contrast to the handling of regexps in programs such as @code{grep}."
msgstr "マッチしない文字の1つとして改行が記述されていなければ、補完文字候補は改行にマッチできる。これは@code{grep}のようなプログラム内でのregexpの扱いとは対照的である。"

#. type: table
#: original_texis/searching.texi:495
msgid "You can specify named character classes, just like in character alternatives.  For instance, @samp{[^[:ascii:]]} matches any non-@acronym{ASCII} character.  @xref{Char Classes}."
msgstr "文字候補のように名前付き文字クラスを指定できる。たとえば@samp{[^[:ascii:]]}は任意の非@acronym{ASCII}文字にマッチする。@ref{Char Classes}を参照のこと。"

#. type: samp{#1}
#: original_texis/searching.texi:496
#, no-wrap
msgid "^"
msgstr "^"

#. type: cindex
#: original_texis/searching.texi:497
#, no-wrap
msgid "beginning of line in regexp"
msgstr "beginning of line in regexp"

#. type: table
#: original_texis/searching.texi:503
msgid "When matching a buffer, @samp{^} matches the empty string, but only at the beginning of a line in the text being matched (or the beginning of the accessible portion of the buffer).  Otherwise it fails to match anything.  Thus, @samp{^foo} matches a @samp{foo} that occurs at the beginning of a line."
msgstr "バッファーのマッチングの際には@samp{^}は空文字列、ただしマッチ対象のテキスト内にある行の先頭(またはバッファーのアクセス可能範囲の先頭)だけにマッチする。それ以外のマッチはすべて失敗する。つまり@samp{^foo}は行の先頭に出現する@samp{foo}にマッチする。"

#. type: table
#: original_texis/searching.texi:506
msgid "When matching a string instead of a buffer, @samp{^} matches at the beginning of the string or after a newline character."
msgstr "バッファーではなく文字列とマッチする際には、@samp{^}は文字列の先頭か改行文字の後にマッチする。"

#. type: table
#: original_texis/searching.texi:510
msgid "For historical compatibility reasons, @samp{^} can be used only at the beginning of the regular expression, or after @samp{\\(}, @samp{\\(?:} or @samp{\\|}."
msgstr "歴史的な互換性という理由により@samp{^}は正規表現の先頭、または@samp{\\(}、@samp{\\(?:}、@samp{\\|}の後でのみ使用できる。"

#. type: samp{#1}
#: original_texis/searching.texi:511
#, no-wrap
msgid "$"
msgstr "$"

#. type: cindex
#: original_texis/searching.texi:512
#, no-wrap
msgid "@samp{$} in regexp"
msgstr "@samp{$} in regexp"

#. type: cindex
#: original_texis/searching.texi:513
#, no-wrap
msgid "end of line in regexp"
msgstr "end of line in regexp"

#. type: table
#: original_texis/searching.texi:517
msgid "is similar to @samp{^} but matches only at the end of a line (or the end of the accessible portion of the buffer).  Thus, @samp{x+$} matches a string of one @samp{x} or more at the end of a line."
msgstr "これは@samp{^}と似ているが、行の終端(またはバッファーのアクセス可能範囲の終端)だけにマッチする。つまり@samp{x+$}は行末にある1つ以上の@samp{x}からなる文字列にマッチする。"

#. type: table
#: original_texis/searching.texi:520
msgid "When matching a string instead of a buffer, @samp{$} matches at the end of the string or before a newline character."
msgstr "バッファーではなく文字列とマッチする際には、@samp{$}は文字列の終端か改行文字の前にマッチする。"

#. type: table
#: original_texis/searching.texi:523
msgid "For historical compatibility reasons, @samp{$} can be used only at the end of the regular expression, or before @samp{\\)} or @samp{\\|}."
msgstr "歴史的な互換性という理由により@samp{$}は正規表現の先頭、または@samp{\\(}、@samp{\\(?:}、@samp{\\|}の前でのみ使用できる。"

#. type: samp{#1}
#: original_texis/searching.texi:524
#, no-wrap
msgid "\\"
msgstr "\\"

#. type: cindex
#: original_texis/searching.texi:525
#, no-wrap
msgid "@samp{\\} in regexp"
msgstr "@samp{\\} in regexp"

#. type: table
#: original_texis/searching.texi:528
msgid "has two functions: it quotes the special characters (including @samp{\\}), and it introduces additional special constructs."
msgstr "これはスペシャル文字(@samp{\\}を含む)のクォートと、追加のスペシャル文字の導入という2つの機能をもつ。"

#. type: table
#: original_texis/searching.texi:532
msgid "Because @samp{\\} quotes special characters, @samp{\\$} is a regular expression that matches only @samp{$}, and @samp{\\[} is a regular expression that matches only @samp{[}, and so on."
msgstr "@samp{\\}はスペシャル文字をクォートするので@samp{\\$}は@samp{$}、@samp{\\[}は@samp{[}だけにマッチする正規表現のようになる。"

#. type: table
#: original_texis/searching.texi:540
msgid "Note that @samp{\\} also has special meaning in the read syntax of Lisp strings (@pxref{String Type}), and must be quoted with @samp{\\}.  For example, the regular expression that matches the @samp{\\} character is @samp{\\\\}.  To write a Lisp string that contains the characters @samp{\\\\}, Lisp syntax requires you to quote each @samp{\\} with another @samp{\\}.  Therefore, the read syntax for a regular expression matching @samp{\\} is @code{\"\\\\\\\\\"}."
msgstr "@samp{\\}はLisp文字列(@ref{String Type}を参照)の入力構文(read syntax)内でも特別な意味をもち、@samp{\\}でクォートしなければならないことに注意。たとえば文字@samp{\\}にマッチする正規表現は@samp{\\\\}。文字@samp{\\\\}を含むLisp文字列を記述するには、別の@samp{\\\\}で@samp{\\\\}をクォートすることをLisp構文は要求する。したがって@samp{\\}にマッチする正規表現にたいする入力構文は@code{\"\\\\\\\\\"}となる。"

#. type: Plain text
#: original_texis/searching.texi:548
msgid "@strong{Please note:} For historical compatibility, special characters are treated as ordinary ones if they are in contexts where their special meanings make no sense.  For example, @samp{*foo} treats @samp{*} as ordinary since there is no preceding expression on which the @samp{*} can act.  It is poor practice to depend on this behavior; quote the special character anyway, regardless of where it appears."
msgstr "@strong{注意してください:} 歴史的な互換性のために、スペシャル文字はそれらがもつ特別な意味が意味を成さないコンテキスト内にある場合には通常の文字として扱われます。たとえば@samp{*foo}は@samp{*}が作用可能な前置された表現がないので、通常の@samp{*}として扱われます。この挙動に依存するのは悪い習慣です。どこにそれが出現しようとスペシャル文字はすべてクォートしてください。"

#. type: Plain text
#: original_texis/searching.texi:556
msgid "As a @samp{\\} is not special inside a character alternative, it can never remove the special meaning of @samp{-} or @samp{]}.  So you should not quote these characters when they have no special meaning either.  This would not clarify anything, since backslashes can legitimately precede these characters where they @emph{have} special meaning, as in @samp{[^\\]} (@code{\"[^\\\\]\"} for Lisp string syntax), which matches any single character except a backslash."
msgstr "文字候補内で@samp{\\}は何ら特別ではないので、@samp{-}や@samp{]}の特別な意味を取り除くことは決してありません。特別な意味をもたないような場合でも、これらの文字をクォートするべきではありません。バックスラッシュ以外の任意の1文字にマッチする@samp{[^\\]} (Lisp文字列構文では@code{\"[^\\\\]\"})内でのように、これらの文字が@emph{特別な意味}をもつ箇所では、これらの文字にバックスラッシュを前置することには正当性があるので、何もそれほど明解にはしないでしょう。"

#. type: Plain text
#: original_texis/searching.texi:566
msgid "In practice, most @samp{]} that occur in regular expressions close a character alternative and hence are special.  However, occasionally a regular expression may try to match a complex pattern of literal @samp{[} and @samp{]}.  In such situations, it sometimes may be necessary to carefully parse the regexp from the start to determine which square brackets enclose a character alternative.  For example, @samp{[^][]]} consists of the complemented character alternative @samp{[^][]} (which matches any single character that is not a square bracket), followed by a literal @samp{]}."
msgstr "実際には正規表現内に出現する@samp{]}は文字候補に近接しており、それ故そのほとんどがスペシャル文字です。しかしリテラルの@samp{[}と@samp{]}の複雑なパターンにたいしてマッチを試みることも時にはあるかもしれません。そのような状況では文字候補を囲う角カッコがどれなのかを判断するために、regexpを最初から注意深く解析することが必要なときもあるかもしれません。たとえば@samp{[^][]]}は補完文字候補@samp{[^][]} (角カッコ以外の任意の1文字とマッチする)と、その後のリテラルの@samp{]}により構成されます。"

#. type: Plain text
#: original_texis/searching.texi:576
msgid "The exact rules are that at the beginning of a regexp, @samp{[} is special and @samp{]} not.  This lasts until the first unquoted @samp{[}, after which we are in a character alternative; @samp{[} is no longer special (except when it starts a character class) but @samp{]} is special, unless it immediately follows the special @samp{[} or that @samp{[} followed by a @samp{^}.  This lasts until the next special @samp{]} that does not end a character class.  This ends the character alternative and restores the ordinary syntax of regular expressions; an unquoted @samp{[} is special again and a @samp{]} not."
msgstr "厳密にはregexp先頭の@samp{[}は特別で、@samp{]}は特別ではないというのがルールです。これはクォートされていない最初の@samp{[}で終わり、その後は文字候補になります。(文字クラス開始を除き)@samp{[}はもはや特別ではありませんが、@samp{]}は直後にスペシャル文字@samp{[}があるか、その@samp{[}の後に@samp{^}がある場合を除いて特別です。これは文字クラス終了ではない次のスペシャル文字@samp{]}まで続きます。これは文字候補を終了させて、通常の正規表現の構文をリストアします。クォートされていない@samp{[}は再び特別となり、@samp{]}は特別ではなくなります。"

#. type: subsubsection
#: original_texis/searching.texi:578
#, no-wrap
msgid "Character Classes"
msgstr "Character Classes"

#. type: cindex
#: original_texis/searching.texi:579
#, no-wrap
msgid "character classes in regexp"
msgstr "character classes in regexp"

#. type: cindex
#: original_texis/searching.texi:580
#, fuzzy, no-wrap
#| msgid "character classes in regexp"
msgid "ascii character class, regexp"
msgstr "character classes in regexp"

#. type: cindex
#: original_texis/searching.texi:581
#, fuzzy, no-wrap
#| msgid "character classes in regexp"
msgid "alnum character class, regexp"
msgstr "character classes in regexp"

#. type: cindex
#: original_texis/searching.texi:582
#, fuzzy, no-wrap
#| msgid "character classes in regexp"
msgid "alpha character class, regexp"
msgstr "character classes in regexp"

#. type: cindex
#: original_texis/searching.texi:583
#, fuzzy, no-wrap
#| msgid "character classes in regexp"
msgid "xdigit character class, regexp"
msgstr "character classes in regexp"

#. type: Plain text
#: original_texis/searching.texi:592
msgid "Below is a table of the classes you can use in a character alternative, and what they mean.  Note that the @samp{[} and @samp{]} characters that enclose the class name are part of the name, so a regular expression using these classes needs one more pair of brackets.  For example, a regular expression matching a sequence of one or more letters and digits would be @samp{[[:alnum:]]+}, not @samp{[:alnum:]+}."
msgstr ""

#. type: item
#: original_texis/searching.texi:594
#, no-wrap
msgid "[:ascii:]"
msgstr "[:ascii:]"

#. type: table
#: original_texis/searching.texi:596
msgid "This matches any @acronym{ASCII} character (codes 0--127)."
msgstr "これは任意の@acronym{ASCII}文字(コード0 -- 127)にマッチする。"

#. type: item
#: original_texis/searching.texi:596
#, no-wrap
msgid "[:alnum:]"
msgstr "[:alnum:]"

#. type: table
#: original_texis/searching.texi:601
msgid "This matches any letter or digit.  For multibyte characters, it matches characters whose Unicode @samp{general-category} property (@pxref{Character Properties}) indicates they are alphabetic or decimal number characters."
msgstr "これは任意の英数字にマッチする。マルチバイト文字では、アルファベット文字か数字であることを示すUnicodeプロパティ@samp{general-category} (@ref{Character Properties}を参照)をもつ文字にマッチする。"

#. type: item
#: original_texis/searching.texi:601
#, no-wrap
msgid "[:alpha:]"
msgstr "[:alpha:]"

#. type: table
#: original_texis/searching.texi:606
msgid "This matches any letter.  For multibyte characters, it matches characters whose Unicode @samp{general-category} property (@pxref{Character Properties}) indicates they are alphabetic characters."
msgstr "これは任意のアルファベットにマッチする。マルチバイト文字では、アルファベット文字であることを示すUnicodeプロパティ@samp{general-category} (@ref{Character Properties}を参照)をもつ文字にマッチする。"

#. type: item
#: original_texis/searching.texi:606
#, no-wrap
msgid "[:blank:]"
msgstr "[:blank:]"

#. type: table
#: original_texis/searching.texi:612
msgid "This matches horizontal whitespace, as defined by Annex C of the Unicode Technical Standard #18.  In particular, it matches spaces, tabs, and other characters whose Unicode @samp{general-category} property (@pxref{Character Properties}) indicates they are spacing separators."
msgstr "これは Unicode Technical Standard #18のAnnex Cで定義される水平の空白文字(horizontal whitespace)にマッチする。特にスペース、タブ、およびスペース区切りであることをUnicodeの@samp{general-category}プロパティ(@ref{Character Properties}を参照)が示す他の文字にマッチする。"

#. type: item
#: original_texis/searching.texi:612
#, no-wrap
msgid "[:cntrl:]"
msgstr "[:cntrl:]"

#. type: table
#: original_texis/searching.texi:614
#, fuzzy
#| msgid "matches any character whose category is not @var{c}."
msgid "This matches any character whose code is in the range 0--31."
msgstr "これはカテゴリーが@var{c}ではない任意の文字にマッチする。"

#. type: item
#: original_texis/searching.texi:614
#, no-wrap
msgid "[:digit:]"
msgstr "[:digit:]"

#. type: table
#: original_texis/searching.texi:617
msgid "This matches @samp{0} through @samp{9}.  Thus, @samp{[-+[:digit:]]} matches any digit, as well as @samp{+} and @samp{-}."
msgstr "これは@samp{0}から@samp{9}までにマッチする。つまり@samp{[-+[:digit:]]}は@samp{+}と@samp{-}、同様に任意の数にマッチする。"

#. type: item
#: original_texis/searching.texi:617
#, no-wrap
msgid "[:graph:]"
msgstr "[:graph:]"

#. type: table
#: original_texis/searching.texi:623
msgid "This matches graphic characters---everything except whitespace, @acronym{ASCII} and non-@acronym{ASCII} control characters, surrogates, and codepoints unassigned by Unicode, as indicated by the Unicode @samp{general-category} property (@pxref{Character Properties})."
msgstr "これはUnicodeの@samp{general-category}プロパティで示されるようなグラフィック文字(空白文字、@acronym{ASCII}と非@acronym{ASCII}の制御文字、サロゲートードポイント、Unicodeで未割り当てのコードポイントを除くすべて)にマッチする(@ref{Character Properties}を参照)。"

#. type: item
#: original_texis/searching.texi:623
#, no-wrap
msgid "[:lower:]"
msgstr "[:lower:]"

#. type: table
#: original_texis/searching.texi:627
msgid "This matches any lower-case letter, as determined by the current case table (@pxref{Case Tables}).  If @code{case-fold-search} is non-@code{nil}, this also matches any upper-case letter."
msgstr "これはカレントのcaseテーブル(@ref{Case Tables}を参照)で小文字と判断される文字すべてにマッチする。@code{case-fold-search}が非@code{nil}なら大文字にもマッチする。"

#. type: item
#: original_texis/searching.texi:627
#, no-wrap
msgid "[:multibyte:]"
msgstr "[:multibyte:]"

#. type: table
#: original_texis/searching.texi:629
msgid "This matches any multibyte character (@pxref{Text Representations})."
msgstr "これは任意のマルチバイト文字にマッチする(@ref{Text Representations}を参照)。"

#. type: item
#: original_texis/searching.texi:629
#, no-wrap
msgid "[:nonascii:]"
msgstr "[:nonascii:]"

#. type: table
#: original_texis/searching.texi:631
msgid "This matches any non-@acronym{ASCII} character."
msgstr "これは非@acronym{ASCII}文字にマッチする。"

#. type: item
#: original_texis/searching.texi:631
#, no-wrap
msgid "[:print:]"
msgstr "[:print:]"

#. type: table
#: original_texis/searching.texi:634
msgid "This matches any printing character---either whitespace, or a graphic character matched by @samp{[:graph:]}."
msgstr "これは任意のプリント文字(空白文字か@samp{[:graph:]}でマッチされるグラフィック文字のいずれか)にマッチする。"

#. type: item
#: original_texis/searching.texi:634
#, no-wrap
msgid "[:punct:]"
msgstr "[:punct:]"

#. type: table
#: original_texis/searching.texi:637
msgid "This matches any punctuation character.  (At present, for multibyte characters, it matches anything that has non-word syntax.)"
msgstr "これは任意の句読点文字(punctuation character)にマッチする(現在のところマルチバイト文字では単語構文以外のすべてにマッチする)。"

#. type: item
#: original_texis/searching.texi:637
#, no-wrap
msgid "[:space:]"
msgstr "[:space:]"

#. type: table
#: original_texis/searching.texi:640
msgid "This matches any character that has whitespace syntax (@pxref{Syntax Class Table})."
msgstr "これは空白文字構文(@ref{Syntax Class Table}を参照)をもつ任意の文字にマッチする。"

#. type: item
#: original_texis/searching.texi:640
#, no-wrap
msgid "[:unibyte:]"
msgstr "[:unibyte:]"

#. type: table
#: original_texis/searching.texi:642
msgid "This matches any unibyte character (@pxref{Text Representations})."
msgstr "これは任意のユニバイト文字(@ref{Text Representations}を参照)にマッチする。"

#. type: item
#: original_texis/searching.texi:642
#, no-wrap
msgid "[:upper:]"
msgstr "[:upper:]"

#. type: table
#: original_texis/searching.texi:646
msgid "This matches any upper-case letter, as determined by the current case table (@pxref{Case Tables}).  If @code{case-fold-search} is non-@code{nil}, this also matches any lower-case letter."
msgstr "これはカレントのcaseテーブル(@ref{Case Tables}を参照)で大文字と判断される文字すべてにマッチする。@code{case-fold-search}が非@code{nil}ならこれは小文字にもマッチする。"

#. type: item
#: original_texis/searching.texi:646
#, no-wrap
msgid "[:word:]"
msgstr "[:word:]"

#. type: table
#: original_texis/searching.texi:649
msgid "This matches any character that has word syntax (@pxref{Syntax Class Table})."
msgstr "これは単語構文(@ref{Syntax Class Table}を参照)をもつ任意の文字にマッチする。"

#. type: item
#: original_texis/searching.texi:649
#, no-wrap
msgid "[:xdigit:]"
msgstr "[:xdigit:]"

#. type: table
#: original_texis/searching.texi:652
msgid "This matches the hexadecimal digits: @samp{0} through @samp{9}, @samp{a} through @samp{f} and @samp{A} through @samp{F}."
msgstr "これは16進数の数字@samp{0}から@samp{9}、@samp{a}から@samp{f}と@samp{A}から@samp{F}にマッチする。"

#. type: subsubsection
#: original_texis/searching.texi:655
#, no-wrap
msgid "Backslash Constructs in Regular Expressions"
msgstr "Backslash Constructs in Regular Expressions"

#. type: cindex
#: original_texis/searching.texi:656
#, no-wrap
msgid "backslash in regular expressions"
msgstr "backslash in regular expressions"

#. type: Plain text
#: original_texis/searching.texi:662
msgid "For the most part, @samp{\\} followed by any character matches only that character.  However, there are several exceptions: certain sequences starting with @samp{\\} that have special meanings.  Here is a table of the special @samp{\\} constructs."
msgstr "ほとんどの場合では、@samp{\\}の後の任意の文字はその文字だけにマッチします。しかし例外もいくつかあります。@samp{\\}で始まる特定のシーケンスには、特別な意味をもつものがあります。以下は特別な@samp{\\}構成要素のテーブルです。"

#. type: item
#: original_texis/searching.texi:664
#, no-wrap
msgid "\\|"
msgstr "\\|"

#. type: cindex
#: original_texis/searching.texi:665
#, no-wrap
msgid "@samp{|} in regexp"
msgstr "@samp{|} in regexp"

#. type: cindex
#: original_texis/searching.texi:666
#, no-wrap
msgid "regexp alternative"
msgstr "regexp alternative"

#. type: table
#: original_texis/searching.texi:671
msgid "specifies an alternative.  Two regular expressions @var{a} and @var{b} with @samp{\\|} in between form an expression that matches anything that either @var{a} or @var{b} matches."
msgstr "これは選択肢を指定する。2つの正規表現@var{a}と@var{b}、その間にある@samp{\\|}により、@var{a}か@var{b}のいずれかにマッチする表現が形成される。"

#. type: table
#: original_texis/searching.texi:674
msgid "Thus, @samp{foo\\|bar} matches either @samp{foo} or @samp{bar} but no other string."
msgstr "つまり@samp{foo\\|bar}は、@samp{foo}か@samp{bar}のいずれかにマッチして他の文字列にはマッチしない。"

#. type: table
#: original_texis/searching.texi:678
msgid "@samp{\\|} applies to the largest possible surrounding expressions.  Only a surrounding @samp{\\( @dots{} \\)} grouping can limit the grouping power of @samp{\\|}."
msgstr "@samp{\\|}は周囲の適用可能な最大の表現に適用される。@samp{\\|}を取り囲む@samp{\\( @dots{} \\)}でグループ化することによりグループ化の効力を制限できる。"

#. type: table
#: original_texis/searching.texi:682
msgid "If you need full backtracking capability to handle multiple uses of @samp{\\|}, use the POSIX regular expression functions (@pxref{POSIX Regexps})."
msgstr "複数の@samp{\\|}の処理するための完全なバックトラッキング互換が必要なら、POSIX正規表現関数を使用すること(@ref{POSIX Regexps}を参照)。"

#. type: item
#: original_texis/searching.texi:683
#, no-wrap
msgid "\\@{@var{m}\\@}"
msgstr "\\@{@var{m}\\@}"

#. type: table
#: original_texis/searching.texi:688
msgid "is a postfix operator that repeats the previous pattern exactly @var{m} times.  Thus, @samp{x\\@{5\\@}} matches the string @samp{xxxxx} and nothing else.  @samp{c[ad]\\@{3\\@}r} matches string such as @samp{caaar}, @samp{cdddr}, @samp{cadar}, and so on."
msgstr "これは前のパターンを正確に@var{m}回繰り返す後置演算子。つまり@samp{x\\@{5\\@}}は文字列@samp{xxxxx}にマッチして、それ以外にはマッチしない。@samp{c[ad]\\@{3\\@}r}は@samp{caaar}、@samp{cdddr}、@samp{cadar}等にマッチする。"

#. type: item
#: original_texis/searching.texi:689
#, no-wrap
msgid "\\@{@var{m},@var{n}\\@}"
msgstr "\\@{@var{m},@var{n}\\@}"

#. type: table
#: original_texis/searching.texi:695
msgid "is a more general postfix operator that specifies repetition with a minimum of @var{m} repeats and a maximum of @var{n} repeats.  If @var{m} is omitted, the minimum is 0; if @var{n} is omitted, there is no maximum.  For both forms, @var{m} and @var{n}, if specified, may be no larger than"
msgstr "これは最小で@var{m}回、最大で@var{n}回繰り返すより一般的な後置演算子。@var{m}省略時の最小は0、@var{n}省略時の最大は存在しない。いずれの形式でも@var{m}や@var{n}が指定された場合には、"

#. type: ifnottex
#: original_texis/searching.texi:697
#, fuzzy
#| msgid "2**15 @minus{} 1"
msgid "2**16 @minus{} 1"
msgstr "2**15 @minus{} 1"

#. type: tex
#: original_texis/searching.texi:700
#, fuzzy, no-wrap
#| msgid "@math{2^{15}-1}\n"
msgid "@math{2^{16}-1}\n"
msgstr "@math{2^{15}-1}\n"

#. type: table
#: original_texis/searching.texi:702
msgid "."
msgstr "より大きくなることはない。"

#. type: table
#: original_texis/searching.texi:709
msgid "For example, @samp{c[ad]\\@{1,2\\@}r} matches the strings @samp{car}, @samp{cdr}, @samp{caar}, @samp{cadr}, @samp{cdar}, and @samp{cddr}, and nothing else.@* @samp{\\@{0,1\\@}} or @samp{\\@{,1\\@}} is equivalent to @samp{?}.@* @samp{\\@{0,\\@}} or @samp{\\@{,\\@}} is equivalent to @samp{*}.@* @samp{\\@{1,\\@}} is equivalent to @samp{+}."
msgstr "たとえば@samp{c[ad]\\@{1,2\\@}r}は文字列@samp{car}、@samp{cdr}、@samp{caar}、@samp{cadr}、@samp{cdar}、@samp{cddr}にマッチして、それ以外にはマッチしない。@*@samp{\\@{0,1\\@}}や@samp{\\@{,1\\@}}は@samp{?}と同じ。@*@samp{\\@{0,\\@}}や@samp{\\@{,\\@}}は@samp{*}と同じ。@*@samp{\\@{1,\\@}}は@samp{+}と同じ。"

#. type: item
#: original_texis/searching.texi:710
#, no-wrap
msgid "\\( @dots{} \\)"
msgstr "\\( @dots{} \\)"

#. type: cindex
#: original_texis/searching.texi:711
#, no-wrap
msgid "@samp{(} in regexp"
msgstr "@samp{(} in regexp"

#. type: cindex
#: original_texis/searching.texi:712
#, no-wrap
msgid "@samp{)} in regexp"
msgstr "@samp{)} in regexp"

#. type: cindex
#: original_texis/searching.texi:713
#, no-wrap
msgid "regexp grouping"
msgstr "regexp grouping"

#. type: table
#: original_texis/searching.texi:715
msgid "is a grouping construct that serves three purposes:"
msgstr "これは以下の3つの目的を果たす役目をもつグループ化構成要素:"

#. type: enumerate
#: original_texis/searching.texi:721
msgid "To enclose a set of @samp{\\|} alternatives for other operations.  Thus, the regular expression @samp{\\(foo\\|bar\\)x} matches either @samp{foox} or @samp{barx}."
msgstr "他の操作のために一連の@samp{\\|}選択肢を囲う。つまり正規表現@samp{\\(foo\\|bar\\)x}は、@samp{foox}か@samp{barx}のいずれかにマッチする。"

#. type: enumerate
#: original_texis/searching.texi:727
msgid "To enclose a complicated expression for the postfix operators @samp{*}, @samp{+} and @samp{?} to operate on.  Thus, @samp{ba\\(na\\)*} matches @samp{ba}, @samp{bana}, @samp{banana}, @samp{bananana}, etc., with any number (zero or more) of @samp{na} strings."
msgstr "後置演算子@samp{*}、@samp{+}、@samp{?}による複雑な表現を囲う。つまり@samp{ba\\(na\\)*}は@samp{ba}、@samp{bana}、@samp{banana}、@samp{bananana}、...等の任意の数(0以上)の文字列@samp{na}にマッチする。"

#. type: enumerate
#: original_texis/searching.texi:731
msgid "To record a matched substring for future reference with @samp{\\@var{digit}} (see below)."
msgstr "@samp{\\@var{digit}} (以下参照)による将来の参照にたいして、マッチする部分文字列を記録する。"

#. type: table
#: original_texis/searching.texi:739
msgid "This last application is not a consequence of the idea of a parenthetical grouping; it is a separate feature that was assigned as a second meaning to the same @samp{\\( @dots{} \\)} construct because, in practice, there was usually no conflict between the two meanings.  But occasionally there is a conflict, and that led to the introduction of shy groups."
msgstr "この最後の目的はカッコによるグループ化というアイデアによるものではない。これは同じ構成要素@samp{\\( @dots{} \\)}にたいする2つ目の目的に割当てられた別の機能だが、実際のところ2つの意味は衝突しない。しかし稀に衝突が発生することがあり、それが内気(shy)なグループの導入をもたらした。"

#. type: item
#: original_texis/searching.texi:740
#, no-wrap
msgid "\\(?: @dots{} \\)"
msgstr "\\(?: @dots{} \\)"

#. type: cindex
#: original_texis/searching.texi:741
#, no-wrap
msgid "shy groups"
msgstr "shy groups"

#. type: cindex
#: original_texis/searching.texi:742
#, no-wrap
msgid "non-capturing group"
msgstr "non-capturing group"

#. type: cindex
#: original_texis/searching.texi:743
#, no-wrap
msgid "unnumbered group"
msgstr "unnumbered group"

#. type: cindex
#: original_texis/searching.texi:744
#, no-wrap
msgid "@samp{(?:} in regexp"
msgstr "@samp{(?:} in regexp"

#. type: table
#: original_texis/searching.texi:752
msgid "is the @dfn{shy group} construct.  A shy group serves the first two purposes of an ordinary group (controlling the nesting of other operators), but it does not get a number, so you cannot refer back to its value with @samp{\\@var{digit}}.  Shy groups are particularly useful for mechanically-constructed regular expressions, because they can be added automatically without altering the numbering of ordinary, non-shy groups."
msgstr "これは@dfn{内気なグループ(shy group)}の構成要素。内気なグループは通常のグループの最初の2つの役目(他の演算子のネスト制御)を果たすが、これは番号を取得せず@samp{\\@var{digit}}でその値を後方参照できない。内気なグループは通常の非内気なグループを変更することなく自動的に追加できるので、機械的に正規表現を構築するのに特に適している。"

#. type: table
#: original_texis/searching.texi:755
msgid "Shy groups are also called @dfn{non-capturing} or @dfn{unnumbered groups}."
msgstr "内気なグループ化は@dfn{非キャプチャリング(non-capturing)}、@dfn{番号なしグループ(unnumbered groups)}とも呼ばれる。"

#. type: item
#: original_texis/searching.texi:756
#, no-wrap
msgid "\\(?@var{num}: @dots{} \\)"
msgstr "\\(?@var{num}: @dots{} \\)"

#. type: table
#: original_texis/searching.texi:765
msgid "is the @dfn{explicitly numbered group} construct.  Normal groups get their number implicitly, based on their position, which can be inconvenient.  This construct allows you to force a particular group number.  There is no particular restriction on the numbering, e.g., you can have several groups with the same number in which case the last one to match (i.e., the rightmost match) will win.  Implicitly numbered groups always get the smallest integer larger than the one of any previous group."
msgstr "これは@dfn{明示的番号付きグループ(explicitly numbered group)}の構成要素。通常のグループ化では位置をもとに番号が暗黙で取得されるが、これが不便な場合もあるだろう。この構成要素により特定のグループに番号を強制できる。番号の付与に特別な制限はなく、複数のグループに同じ番号を付与でき、その場合は最後の1つ(もっとも右のマッチ)がマッチとして採用される。暗黙に番号付けされたグループは、常に前のグループより大きい最小の整数となる番号を取得する。"

#. type: item
#: original_texis/searching.texi:766
#, no-wrap
msgid "\\@var{digit}"
msgstr "\\@var{digit}"

#. type: table
#: original_texis/searching.texi:769
msgid "matches the same text that matched the @var{digit}th occurrence of a grouping (@samp{\\( @dots{} \\)}) construct."
msgstr "これはグループ構成要素(@samp{\\( @dots{} \\)})の@var{digit}番目にマッチしたテキストと同じテキストにマッチする。"

#. type: table
#: original_texis/searching.texi:774
msgid "In other words, after the end of a group, the matcher remembers the beginning and end of the text matched by that group.  Later on in the regular expression you can use @samp{\\} followed by @var{digit} to match that same text, whatever it may have been."
msgstr "言い換えると最後のグループの後に、マッチ処理はそのグループによりマッチされたテキストの開始と終了を記憶する。その正規表現の先の箇所で@samp{\\}とその後に@var{digit}を使用すれば、それが何であれ同じテキストにマッチさせることができる。"

#. type: table
#: original_texis/searching.texi:781
msgid "The strings matching the first nine grouping constructs appearing in the entire regular expression passed to a search or matching function are assigned numbers 1 through 9 in the order that the open parentheses appear in the regular expression.  So you can use @samp{\\1} through @samp{\\9} to refer to the text matched by the corresponding grouping constructs."
msgstr "検索やマッチングを行う関数に渡される正規表現全体の中で、最初の9つのグループ化構成要素にマッチする文字列には、その正規表現内で開カッコが出現する順に1から9までの番号が割り当てられる。したがって@samp{\\1}から@samp{\\9}までを使用して、対応するグループ化構成要素によりマッチされたテキストを参照できる。"

#. type: table
#: original_texis/searching.texi:786
msgid "For example, @samp{\\(.*\\)\\1} matches any newline-free string that is composed of two identical halves.  The @samp{\\(.*\\)} matches the first half, which may be anything, but the @samp{\\1} that follows must match the same exact text."
msgstr "たとえば@samp{\\(.*\\)\\1}は、一方がもう一方と等しいような2つの文字列から構成される、改行を含まない任意の文字列にマッチする。@samp{\\(.*\\)}は前半分にマッチし、これは何でもよいが、それに続く@samp{\\1}はそれと同じテキストに正確にマッチしなければならない。"

#. type: table
#: original_texis/searching.texi:790
msgid "If a @samp{\\( @dots{} \\)} construct matches more than once (which can happen, for instance, if it is followed by @samp{*}), only the last match is recorded."
msgstr "構成要素@samp{\\( @dots{} \\)}が2回以上マッチする場合(これはたとえば後に@samp{*}をしたがえるとき発生し得る)には最後のマッチだけが記録される。"

#. type: table
#: original_texis/searching.texi:800
msgid "If a particular grouping construct in the regular expression was never matched---for instance, if it appears inside of an alternative that wasn't used, or inside of a repetition that repeated zero times---then the corresponding @samp{\\@var{digit}} construct never matches anything.  To use an artificial example, @samp{\\(foo\\(b*\\)\\|lose\\)\\2} cannot match @samp{lose}: the second alternative inside the larger group matches it, but then @samp{\\2} is undefined and can't match anything.  But it can match @samp{foobb}, because the first alternative matches @samp{foob} and @samp{\\2} matches @samp{b}."
msgstr "正規表現内の特定のグループ化構成要素がマッチしなかった場合には、たとえばそれが使用されない選択肢内にあったり、回数が0回の繰り返しの内部にあるなら、それに対応する@samp{\\@var{digit}}構文は何にもマッチしない。作為的な例を用いると@samp{\\(foo\\(b*\\)\\|lose\\)\\2}は@samp{lose}にマッチできない。外側のグループ内の2つ目の選択肢がマッチするが、@samp{\\2}が未定義となり何にたいしてもマッチできない。しかし@samp{foobb}にたいしては、1つ目の選択肢が@samp{foob}にマッチして、@samp{\\2}が@samp{b}にマッチするのでマッチが可能になる。"

#. type: item
#: original_texis/searching.texi:801
#, no-wrap
msgid "\\w"
msgstr "\\w"

#. type: cindex
#: original_texis/searching.texi:802
#, no-wrap
msgid "@samp{\\w} in regexp"
msgstr "@samp{\\w} in regexp"

#. type: table
#: original_texis/searching.texi:805
msgid "matches any word-constituent character.  The editor syntax table determines which characters these are.  @xref{Syntax Tables}."
msgstr "これは任意の単語構成文字にマッチする。エディターの構文テーブルが、どの文字が単語構成文字かを決定する。@ref{Syntax Tables}を参照のこと。"

#. type: item
#: original_texis/searching.texi:806
#, no-wrap
msgid "\\W"
msgstr "\\W"

#. type: cindex
#: original_texis/searching.texi:807
#, no-wrap
msgid "@samp{\\W} in regexp"
msgstr "@samp{\\W} in regexp"

#. type: table
#: original_texis/searching.texi:809
msgid "matches any character that is not a word constituent."
msgstr "これは任意の非単語構成文字にマッチする。"

#. type: item
#: original_texis/searching.texi:810
#, no-wrap
msgid "\\s@var{code}"
msgstr "\\s@var{code}"

#. type: cindex
#: original_texis/searching.texi:811
#, no-wrap
msgid "@samp{\\s} in regexp"
msgstr "@samp{\\s} in regexp"

#. type: table
#: original_texis/searching.texi:818
msgid "matches any character whose syntax is @var{code}.  Here @var{code} is a character that represents a syntax code: thus, @samp{w} for word constituent, @samp{-} for whitespace, @samp{(} for open parenthesis, etc.  To represent whitespace syntax, use either @samp{-} or a space character.  @xref{Syntax Class Table}, for a list of syntax codes and the characters that stand for them."
msgstr "これは構文が@var{code}であるような任意の文字にマッチする。ここで@var{code}は、構文コードを表す文字。@samp{w}は単語構成要素、@samp{-}は空白文字、@samp{(}は開カッコ、...等。空白文字構文を表すには、@samp{-}かスペース文字のいずれかを使用する。構文コードとそれらを意味する文字のリストは@ref{Syntax Class Table}を参照のこと。"

#. type: item
#: original_texis/searching.texi:819
#, no-wrap
msgid "\\S@var{code}"
msgstr "\\S@var{code}"

#. type: cindex
#: original_texis/searching.texi:820
#, no-wrap
msgid "@samp{\\S} in regexp"
msgstr "@samp{\\S} in regexp"

#. type: table
#: original_texis/searching.texi:822
msgid "matches any character whose syntax is not @var{code}."
msgstr "これは構文が@var{code}でないような任意の文字にマッチする。"

#. type: cindex
#: original_texis/searching.texi:823
#, no-wrap
msgid "category, regexp search for"
msgstr "category, regexp search for"

#. type: item
#: original_texis/searching.texi:824
#, no-wrap
msgid "\\c@var{c}"
msgstr "\\c@var{c}"

#. type: table
#: original_texis/searching.texi:832
msgid "matches any character whose category is @var{c}.  Here @var{c} is a character that represents a category: thus, @samp{c} for Chinese characters or @samp{g} for Greek characters in the standard category table.  You can see the list of all the currently defined categories with @kbd{M-x describe-categories @key{RET}}.  You can also define your own categories in addition to the standard ones using the @code{define-category} function (@pxref{Categories})."
msgstr "これはカテゴリーが@var{c}であるような任意の文字にマッチする。ここで@var{c}はカテゴリーを表す文字。つまり標準カテゴリーテーブルで@samp{c}はChinese(中国語)、@samp{g}はGreek(ギリシャ語)の文字となる。@kbd{M-x describe-categories @key{RET}}で現在定義済みの全カテゴリーのリストを確認できる。@code{define-category}関数を使用すれば、標準カテゴリーに加えてカテゴリーを独自に定義することもできる(@ref{Categories}を参照)。"

#. type: item
#: original_texis/searching.texi:833
#, no-wrap
msgid "\\C@var{c}"
msgstr "\\C@var{c}"

#. type: table
#: original_texis/searching.texi:835
msgid "matches any character whose category is not @var{c}."
msgstr "これはカテゴリーが@var{c}ではない任意の文字にマッチする。"

#. type: Plain text
#: original_texis/searching.texi:842
msgid "The following regular expression constructs match the empty string---that is, they don't use up any characters---but whether they match depends on the context.  For all, the beginning and end of the accessible portion of the buffer are treated as if they were the actual beginning and end of the buffer."
msgstr "以下は空文字列にマッチ(つまり文字を何も消費しない)しますが、マッチするかどうかはコンテキストに依存するような正規表現を構築します。これらすべてにたいして、そのバッファーのアクセス可能範囲の先頭と終端は、あたかもそのバッファーの実際の先頭と終端のように扱われます。"

#. type: item
#: original_texis/searching.texi:844
#, no-wrap
msgid "\\`"
msgstr "\\`"

#. type: cindex
#: original_texis/searching.texi:845
#, no-wrap
msgid "@samp{\\`} in regexp"
msgstr "@samp{\\`} in regexp"

#. type: table
#: original_texis/searching.texi:848
msgid "matches the empty string, but only at the beginning of the buffer or string being matched against."
msgstr "これは空文字列、ただしバッファー先頭またはマッチ対象の文字列の先頭だけにマッチする。"

#. type: item
#: original_texis/searching.texi:849
#, no-wrap
msgid "\\'"
msgstr "\\'"

#. type: cindex
#: original_texis/searching.texi:850
#, no-wrap
msgid "@samp{\\'} in regexp"
msgstr "@samp{\\'} in regexp"

#. type: table
#: original_texis/searching.texi:853
msgid "matches the empty string, but only at the end of the buffer or string being matched against."
msgstr "これは空文字列、ただしバッファー終端またはマッチ対象の文字列の終端だけにマッチする。"

#. type: item
#: original_texis/searching.texi:854
#, no-wrap
msgid "\\="
msgstr "\\="

#. type: cindex
#: original_texis/searching.texi:855
#, no-wrap
msgid "@samp{\\=} in regexp"
msgstr "@samp{\\=} in regexp"

#. type: table
#: original_texis/searching.texi:858
msgid "matches the empty string, but only at point.  (This construct is not defined when matching against a string.)"
msgstr "これは空文字列、ただしポイント位置だけにマッチする(この構成要素はマッチ対象が文字列なら定義されない)。"

#. type: item
#: original_texis/searching.texi:859
#, no-wrap
msgid "\\b"
msgstr "\\b"

#. type: cindex
#: original_texis/searching.texi:860
#, no-wrap
msgid "@samp{\\b} in regexp"
msgstr "@samp{\\b} in regexp"

#. type: table
#: original_texis/searching.texi:865
msgid "matches the empty string, but only at the beginning or end of a word.  Thus, @samp{\\bfoo\\b} matches any occurrence of @samp{foo} as a separate word.  @samp{\\bballs?\\b} matches @samp{ball} or @samp{balls} as a separate word."
msgstr "これは空文字列、ただし単語の先頭だけにマッチする。つまり@samp{\\bfoo\\b}は個別の単語として出現する@samp{foo}だけにマッチする。@samp{\\bballs?\\b}は、個別の単語として@samp{ball}か@samp{balls}にマッチする。"

#. type: table
#: original_texis/searching.texi:868
msgid "@samp{\\b} matches at the beginning or end of the buffer (or string)  regardless of what text appears next to it."
msgstr "@samp{\\b}は、隣接するテキストが何であるかと無関係に、バッファー(か文字列)の先頭または終端にマッチする。"

#. type: item
#: original_texis/searching.texi:869
#, no-wrap
msgid "\\B"
msgstr "\\B"

#. type: cindex
#: original_texis/searching.texi:870
#, no-wrap
msgid "@samp{\\B} in regexp"
msgstr "@samp{\\B} in regexp"

#. type: table
#: original_texis/searching.texi:873
msgid "matches the empty string, but @emph{not} at the beginning or end of a word, nor at the beginning or end of the buffer (or string)."
msgstr "これは空文字列、単語の先頭や終端、またはバッファー(か文字列)の先頭や終端@emph{以外}にマッチする。"

#. type: item
#: original_texis/searching.texi:874
#, no-wrap
msgid "\\<"
msgstr "\\<"

#. type: cindex
#: original_texis/searching.texi:875
#, no-wrap
msgid "@samp{\\<} in regexp"
msgstr "@samp{\\<} in regexp"

#. type: table
#: original_texis/searching.texi:879
msgid "matches the empty string, but only at the beginning of a word.  @samp{\\<} matches at the beginning of the buffer (or string) only if a word-constituent character follows."
msgstr "これは空文字列、ただし単語の先頭だけにマッチする。@samp{\\<}は後に単語構成文字が続く場合のみバッファー(か文字列)の先頭にマッチする。"

#. type: item
#: original_texis/searching.texi:880
#, no-wrap
msgid "\\>"
msgstr "\\>"

#. type: cindex
#: original_texis/searching.texi:881
#, no-wrap
msgid "@samp{\\>} in regexp"
msgstr "@samp{\\>} in regexp"

#. type: table
#: original_texis/searching.texi:885
msgid "matches the empty string, but only at the end of a word.  @samp{\\>} matches at the end of the buffer (or string) only if the contents end with a word-constituent character."
msgstr "これは空文字列、ただし単語の終端だけにマッチする。@samp{\\<}はコンテンツが単語構成文字で終わる場合のみバッファー(か文字列)の終端にマッチする。"

#. type: item
#: original_texis/searching.texi:886
#, no-wrap
msgid "\\_<"
msgstr "\\_<"

#. type: cindex
#: original_texis/searching.texi:887
#, no-wrap
msgid "@samp{\\_<} in regexp"
msgstr "@samp{\\_<} in regexp"

#. type: table
#: original_texis/searching.texi:892
msgid "matches the empty string, but only at the beginning of a symbol.  A symbol is a sequence of one or more word or symbol constituent characters.  @samp{\\_<} matches at the beginning of the buffer (or string) only if a symbol-constituent character follows."
msgstr "これは空文字列、ただしシンボルの先頭だけにマッチする。シンボルとは1つ以上の単語かシンボル構成文字のシーケンス。@samp{\\_<}は後にシンボル構成文字が続く場合のみバッファー(か文字列)の先頭にマッチする。"

#. type: item
#: original_texis/searching.texi:893
#, no-wrap
msgid "\\_>"
msgstr "\\_>"

#. type: cindex
#: original_texis/searching.texi:894
#, no-wrap
msgid "@samp{\\_>} in regexp"
msgstr "@samp{\\_>} in regexp"

#. type: table
#: original_texis/searching.texi:898
msgid "matches the empty string, but only at the end of a symbol.  @samp{\\_>} matches at the end of the buffer (or string) only if the contents end with a symbol-constituent character."
msgstr "これは空文字列、ただし単語の終端だけにマッチする。@samp{\\_>}はコンテンツがシンボル構成文字で終わる場合のみバッファー(か文字列)の終端にマッチする。"

#. type: kindex
#: original_texis/searching.texi:900
#, no-wrap
msgid "invalid-regexp"
msgstr "invalid-regexp"

#. type: Plain text
#: original_texis/searching.texi:906
msgid "Not every string is a valid regular expression.  For example, a string that ends inside a character alternative without a terminating @samp{]} is invalid, and so is a string that ends with a single @samp{\\}.  If an invalid regular expression is passed to any of the search functions, an @code{invalid-regexp} error is signaled."
msgstr "すべての文字列が、有効な正規表現な訳ではありません。たとえば終端の@samp{]}がない文字選択肢の内側で終わる文字列は無効であり、単一の@samp{\\}で終わる文字列も同様です。いずれかの検索関数にたいして無効な正規表現が渡されると@code{invalid-regexp}エラーがシグナルされます。"

#. type: subsection
#: original_texis/searching.texi:908
#, no-wrap
msgid "Complex Regexp Example"
msgstr "Complex Regexp Example"

#. type: Plain text
#: original_texis/searching.texi:915
msgid "Here is a complicated regexp which was formerly used by Emacs to recognize the end of a sentence together with any whitespace that follows.  (Nowadays Emacs uses a similar but more complex default regexp constructed by the function @code{sentence-end}.  @xref{Standard Regexps}.)"
msgstr "以下は後続の空白文字とともにセンテンスの終わりを認識するために、以前のEmacsで使用されていた複雑な正規表現の例です(現在のEmacsは関数@code{sentence-end}により構築される、同様のより複雑なregexpを使用する。@ref{Standard Regexps}を参照)。"

#. type: Plain text
#: original_texis/searching.texi:922
msgid "Below, we show first the regexp as a string in Lisp syntax (to distinguish spaces from tab characters), and then the result of evaluating it.  The string constant begins and ends with a double-quote.  @samp{\\\"} stands for a double-quote as part of the string, @samp{\\\\} for a backslash as part of the string, @samp{\\t} for a tab and @samp{\\n} for a newline."
msgstr "以下ではまず、(スペースとタブ文字を区別するために)Lisp構文の文字列としてregexpを示して、それを評価した結果を示します。文字列定数の開始と終了はダブルクォーテーションです。@samp{\\\"}は文字列の一部としてのダブルクォーテーション、@samp{\\\\}は文字列の一部としてのバックスラッシュ、@samp{\\t}はタブ、@samp{\\n}は改行を意味します。"

#. type: group
#: original_texis/searching.texi:928
#, no-wrap
msgid ""
"\"[.?!][]\\\"')@}]*\\\\($\\\\| $\\\\|\\t\\\\|@ @ \\\\)[ \\t\\n]*\"\n"
"     @result{} \"[.?!][]\\\"')@}]*\\\\($\\\\| $\\\\|  \\\\|@ @ \\\\)[\n"
"]*\"\n"
msgstr ""
"\"[.?!][]\\\"')@}]*\\\\($\\\\| $\\\\|\\t\\\\|@ @ \\\\)[ \\t\\n]*\"\n"
"     @result{} \"[.?!][]\\\"')@}]*\\\\($\\\\| $\\\\|  \\\\|@ @ \\\\)[\n"
"]*\"\n"

#. type: Plain text
#: original_texis/searching.texi:933
msgid "In the output, tab and newline appear as themselves."
msgstr "改行とタブは、それら自身として出力されます。"

#. type: Plain text
#: original_texis/searching.texi:936
msgid "This regular expression contains four parts in succession and can be deciphered as follows:"
msgstr "この正規表現は連続する4つのパートを含み、以下のように解読できます:"

#. type: item
#: original_texis/searching.texi:938
#, no-wrap
msgid "[.?!]"
msgstr "[.?!]"

#. type: table
#: original_texis/searching.texi:945
msgid "The first part of the pattern is a character alternative that matches any one of three characters: period, question mark, and exclamation mark.  The match must begin with one of these three characters.  (This is one point where the new default regexp used by Emacs differs from the old.  The new value also allows some non-@acronym{ASCII} characters that end a sentence without any following whitespace.)"
msgstr "この正規表現の1つ目のパートはピリオド、疑問符、感嘆符の3つのうちいずれか1つにマッチする文字選択肢。マッチはこれら3つの文字のいずれかで開始されなければならない(これは旧正規表現とEmacsが使用する新たなデフォルトregexpが異なる1つのポイントである。新たな値は後続の空白文字なしでセンテンスを終端する、いくつかの非@acronym{ASCII}文字を許容する)。"

#. type: item
#: original_texis/searching.texi:946
#, no-wrap
msgid "[]\\\"')@}]*"
msgstr "[]\\\"')@}]*"

#. type: table
#: original_texis/searching.texi:953
msgid "The second part of the pattern matches any closing braces and quotation marks, zero or more of them, that may follow the period, question mark or exclamation mark.  The @code{\\\"} is Lisp syntax for a double-quote in a string.  The @samp{*} at the end indicates that the immediately preceding regular expression (a character alternative, in this case) may be repeated zero or more times."
msgstr "パターンの2つ目のパートは任意の0個以上の閉カッコとクォーテーションマークであり、その後にピリオド、疑問符、感嘆符があるかもしれない。@code{\\\"}は文字列内でのダブルクォーテーションマークにたいするLisp構文。最後の@samp{*}は直前の正規表現(この場合は文字選択肢)の0回以上の繰り返しを示す。"

#. type: item
#: original_texis/searching.texi:954
#, no-wrap
msgid "\\\\($\\\\|@ $\\\\|\\t\\\\|@ @ \\\\)"
msgstr "\\\\($\\\\|@ $\\\\|\\t\\\\|@ @ \\\\)"

#. type: table
#: original_texis/searching.texi:961
msgid "The third part of the pattern matches the whitespace that follows the end of a sentence: the end of a line (optionally with a space), or a tab, or two spaces.  The double backslashes mark the parentheses and vertical bars as regular expression syntax; the parentheses delimit a group and the vertical bars separate alternatives.  The dollar sign is used to match the end of a line."
msgstr "パターンの3つ目のパートはセンテンスの後の空白文字、すなわち行の終端(スペースがあっても可)、タブ、または2つのスペースにマッチする。2連バックスラッシュはカッコと垂直バーを正規表現構文としてマークする。すなわちカッコはグループを句切り、垂直バーは選択肢を区別する。ダラー記号は行の終端へのマッチに使用される。"

#. type: item
#: original_texis/searching.texi:962
#, no-wrap
msgid "[ \\t\\n]*"
msgstr "[ \\t\\n]*"

#. type: table
#: original_texis/searching.texi:965
msgid "Finally, the last part of the pattern matches any additional whitespace beyond the minimum needed to end a sentence."
msgstr "最後にパターンの最終パートはセンテンスを終端させるために必要とされる以上の、余分な空白文字にマッチする。"

#. type: ifnottex
#: original_texis/searching.texi:969
msgid "In the @code{rx} notation (@pxref{Rx Notation}), the regexp could be written"
msgstr ""

#. type: group
#: original_texis/searching.texi:979
#, no-wrap
msgid ""
"(rx (any \".?!\")                    ; Punctuation ending sentence.\n"
"    (zero-or-more (any \"\\\"')]@}\"))  ; Closing quotes or brackets.\n"
"    (or line-end\n"
"        (seq \" \" line-end)\n"
"        \"\\t\"\n"
"        \"  \")                      ; Two spaces.\n"
"    (zero-or-more (any \"\\t\\n \")))  ; Optional extra whitespace.\n"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:984
msgid "Since @code{rx} regexps are just S-expressions, they can be formatted and commented as such."
msgstr ""

#. type: node
#: original_texis/searching.texi:987
#, no-wrap
msgid "Rx Notation"
msgstr ""

#. type: subsection
#: original_texis/searching.texi:988
#, no-wrap
msgid "The @code{rx} Structured Regexp Notation"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:989
#, no-wrap
msgid "rx"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1000
msgid "As an alternative to the string-based syntax, Emacs provides the structured @code{rx} notation based on Lisp S-expressions.  This notation is usually easier to read, write and maintain than regexp strings, and can be indented and commented freely.  It requires a conversion into string form since that is what regexp functions expect, but that conversion typically takes place during byte-compilation rather than when the Lisp code using the regexp is run."
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1005
msgid "Here is an @code{rx} regexp@footnote{It could be written much simpler with non-greedy operators (how?), but that would make the example less interesting.} that matches a block comment in the C programming language:"
msgstr ""

#. type: group
#: original_texis/searching.texi:1015
#, no-wrap
msgid ""
"(rx \"/*\"                          ; Initial /*\n"
"    (zero-or-more\n"
"     (or (not (any \"*\"))          ;  Either non-*,\n"
"         (seq \"*\"                 ;  or * followed by\n"
"              (not (any \"/\")))))  ;  non-/\n"
"    (one-or-more \"*\")             ; At least one star,\n"
"    \"/\")                          ; and the final /\n"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1020
msgid "or, using shorter synonyms and written more compactly,"
msgstr ""

#. type: group
#: original_texis/searching.texi:1027
#, no-wrap
msgid ""
"(rx \"/*\"\n"
"    (* (| (not \"*\")\n"
"          (: \"*\" (not \"/\"))))\n"
"    (+ \"*\") \"/\")\n"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1032
msgid "In conventional string syntax, it would be written"
msgstr ""

#. type: example
#: original_texis/searching.texi:1035
#, no-wrap
msgid "\"/\\\\*\\\\(?:[^*]\\\\|\\\\*[^/]\\\\)*\\\\*+/\"\n"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1041
msgid "The @code{rx} notation is mainly useful in Lisp code; it cannot be used in most interactive situations where a regexp is requested, such as when running @code{query-replace-regexp} or in variable customization."
msgstr ""

#. type: node
#: original_texis/searching.texi:1046 original_texis/searching.texi:1048
#, no-wrap
msgid "Rx Constructs"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:1046
msgid "Constructs valid in rx forms."
msgstr ""

#. type: node
#: original_texis/searching.texi:1046 original_texis/searching.texi:1533
#, fuzzy, no-wrap
#| msgid "Regexp Functions"
msgid "Rx Functions"
msgstr "Regexp Functions"

#. type: menuentry
#: original_texis/searching.texi:1046
msgid "Functions and macros that use rx forms."
msgstr ""

#. type: node
#: original_texis/searching.texi:1046 original_texis/searching.texi:1559
#, no-wrap
msgid "Extending Rx"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:1046
msgid "How to define your own rx forms."
msgstr ""

#. type: subsubsection
#: original_texis/searching.texi:1049
#, no-wrap
msgid "Constructs in @code{rx} regexps"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1056
msgid "The various forms in @code{rx} regexps are described below.  The shorthand @var{rx} represents any @code{rx} form, and @var{rx}@dots{} means zero or more @code{rx} forms.  Where the corresponding string regexp syntax is given, @var{A}, @var{B}, @dots{} are string regexp subexpressions."
msgstr ""

#. type: subsubheading
#: original_texis/searching.texi:1057
#, no-wrap
msgid "Literals"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1060
#, no-wrap
msgid "\"some-string\""
msgstr ""

#. type: table
#: original_texis/searching.texi:1063
msgid "Match the string @samp{some-string} literally.  There are no characters with special meaning, unlike in string regexps."
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1064
#, fuzzy, no-wrap
#| msgid "?"
msgid "?C"
msgstr "?"

#. type: table
#: original_texis/searching.texi:1066
msgid "Match the character @samp{C} literally."
msgstr ""

#. type: subsubheading
#: original_texis/searching.texi:1068
#, no-wrap
msgid "Sequence and alternative"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1071
#, fuzzy, no-wrap
#| msgid "\\(?@var{num}: @dots{} \\)"
msgid "(seq @var{rx}@dots{})"
msgstr "\\(?@var{num}: @dots{} \\)"

#. type: cindex
#: original_texis/searching.texi:1072
#, no-wrap
msgid "@code{seq} in rx"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1073
#, fuzzy, no-wrap
#| msgid "\\(?@var{num}: @dots{} \\)"
msgid "(sequence @var{rx}@dots{})"
msgstr "\\(?@var{num}: @dots{} \\)"

#. type: cindex
#: original_texis/searching.texi:1074
#, no-wrap
msgid "@code{sequence} in rx"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1075
#, fuzzy, no-wrap
#| msgid "\\(?@var{num}: @dots{} \\)"
msgid "(: @var{rx}@dots{})"
msgstr "\\(?@var{num}: @dots{} \\)"

#. type: cindex
#: original_texis/searching.texi:1076
#, no-wrap
msgid "@code{:} in rx"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1077
#, fuzzy, no-wrap
#| msgid "\\(?@var{num}: @dots{} \\)"
msgid "(and @var{rx}@dots{})"
msgstr "\\(?@var{num}: @dots{} \\)"

#. type: cindex
#: original_texis/searching.texi:1078
#, no-wrap
msgid "@code{and} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1083
msgid "Match the @var{rx}s in sequence.  Without arguments, the expression matches the empty string.@* Corresponding string regexp: @samp{@var{A}@var{B}@dots{}} (subexpressions in sequence)."
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1084
#, fuzzy, no-wrap
#| msgid "\\(?@var{num}: @dots{} \\)"
msgid "(or @var{rx}@dots{})"
msgstr "\\(?@var{num}: @dots{} \\)"

#. type: cindex
#: original_texis/searching.texi:1085
#, no-wrap
msgid "@code{or} in rx"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1086
#, fuzzy, no-wrap
#| msgid "\\(?@var{num}: @dots{} \\)"
msgid "(| @var{rx}@dots{})"
msgstr "\\(?@var{num}: @dots{} \\)"

#. type: cindex
#: original_texis/searching.texi:1087
#, fuzzy, no-wrap
#| msgid "@samp{|} in regexp"
msgid "@code{|} in rx"
msgstr "@samp{|} in regexp"

#. type: table
#: original_texis/searching.texi:1095
msgid "Match exactly one of the @var{rx}s.  If all arguments are strings, characters, or @code{or} forms so constrained, the longest possible match will always be used.  Otherwise, either the longest match or the first (in left-to-right order) will be used.  Without arguments, the expression will not match anything at all.@* Corresponding string regexp: @samp{@var{A}\\|@var{B}\\|@dots{}}."
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1096
#, no-wrap
msgid "unmatchable"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1097
#, no-wrap
msgid "@code{unmatchable} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1100
msgid "Refuse any match.  Equivalent to @code{(or)}.  @xref{regexp-unmatchable}."
msgstr ""

#. type: subsubheading
#: original_texis/searching.texi:1102
#, no-wrap
msgid "Repetition"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1107
msgid "Normally, repetition forms are greedy, in that they attempt to match as many times as possible.  Some forms are non-greedy; they try to match as few times as possible (@pxref{Non-greedy repetition})."
msgstr ""

#. type: item
#: original_texis/searching.texi:1109
#, no-wrap
msgid "(zero-or-more @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1110
#, no-wrap
msgid "@code{zero-or-more} in rx"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:1111
#, fuzzy, no-wrap
#| msgid "\\(?@var{num}: @dots{} \\)"
msgid "(0+ @var{rx}@dots{})"
msgstr "\\(?@var{num}: @dots{} \\)"

#. type: cindex
#: original_texis/searching.texi:1112
#, fuzzy, no-wrap
#| msgid "@samp{+} in regexp"
msgid "@code{0+} in rx"
msgstr "@samp{+} in regexp"

#. type: table
#: original_texis/searching.texi:1116
msgid "Match the @var{rx}s zero or more times.  Greedy by default.@* Corresponding string regexp: @samp{@var{A}*} (greedy), @samp{@var{A}*?} (non-greedy)"
msgstr ""

#. type: item
#: original_texis/searching.texi:1117
#, no-wrap
msgid "(one-or-more @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1118
#, no-wrap
msgid "@code{one-or-more} in rx"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:1119
#, fuzzy, no-wrap
#| msgid "\\(?@var{num}: @dots{} \\)"
msgid "(1+ @var{rx}@dots{})"
msgstr "\\(?@var{num}: @dots{} \\)"

#. type: cindex
#: original_texis/searching.texi:1120
#, fuzzy, no-wrap
#| msgid "@samp{+} in regexp"
msgid "@code{1+} in rx"
msgstr "@samp{+} in regexp"

#. type: table
#: original_texis/searching.texi:1124
msgid "Match the @var{rx}s one or more times.  Greedy by default.@* Corresponding string regexp: @samp{@var{A}+} (greedy), @samp{@var{A}+?} (non-greedy)"
msgstr ""

#. type: item
#: original_texis/searching.texi:1125
#, no-wrap
msgid "(zero-or-one @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1126
#, no-wrap
msgid "@code{zero-or-one} in rx"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:1127
#, fuzzy, no-wrap
#| msgid "\\(?@var{num}: @dots{} \\)"
msgid "(optional @var{rx}@dots{})"
msgstr "\\(?@var{num}: @dots{} \\)"

#. type: cindex
#: original_texis/searching.texi:1128
#, no-wrap
msgid "@code{optional} in rx"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:1129
#, fuzzy, no-wrap
#| msgid "\\(?@var{num}: @dots{} \\)"
msgid "(opt @var{rx}@dots{})"
msgstr "\\(?@var{num}: @dots{} \\)"

#. type: cindex
#: original_texis/searching.texi:1130
#, no-wrap
msgid "@code{opt} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1134
msgid "Match the @var{rx}s once or an empty string.  Greedy by default.@* Corresponding string regexp: @samp{@var{A}?} (greedy), @samp{@var{A}??} (non-greedy)."
msgstr ""

#. type: item
#: original_texis/searching.texi:1135
#, fuzzy, no-wrap
#| msgid "\\(?@var{num}: @dots{} \\)"
msgid "(* @var{rx}@dots{})"
msgstr "\\(?@var{num}: @dots{} \\)"

#. type: cindex
#: original_texis/searching.texi:1136
#, fuzzy, no-wrap
#| msgid "@samp{*} in regexp"
msgid "@code{*} in rx"
msgstr "@samp{*} in regexp"

#. type: table
#: original_texis/searching.texi:1139
msgid "Match the @var{rx}s zero or more times.  Greedy.@* Corresponding string regexp: @samp{@var{A}*}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1140
#, fuzzy, no-wrap
#| msgid "\\(?@var{num}: @dots{} \\)"
msgid "(+ @var{rx}@dots{})"
msgstr "\\(?@var{num}: @dots{} \\)"

#. type: cindex
#: original_texis/searching.texi:1141
#, fuzzy, no-wrap
#| msgid "@samp{+} in regexp"
msgid "@code{+} in rx"
msgstr "@samp{+} in regexp"

#. type: table
#: original_texis/searching.texi:1144
msgid "Match the @var{rx}s one or more times.  Greedy.@* Corresponding string regexp: @samp{@var{A}+}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1145
#, fuzzy, no-wrap
#| msgid "\\(?@var{num}: @dots{} \\)"
msgid "(? @var{rx}@dots{})"
msgstr "\\(?@var{num}: @dots{} \\)"

#. type: cindex
#: original_texis/searching.texi:1146
#, fuzzy, no-wrap
#| msgid "@samp{?} in regexp"
msgid "@code{?} in rx"
msgstr "@samp{?} in regexp"

#. type: table
#: original_texis/searching.texi:1149
msgid "Match the @var{rx}s once or an empty string.  Greedy.@* Corresponding string regexp: @samp{@var{A}?}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1150
#, fuzzy, no-wrap
#| msgid "\\(?@var{num}: @dots{} \\)"
msgid "(*? @var{rx}@dots{})"
msgstr "\\(?@var{num}: @dots{} \\)"

#. type: cindex
#: original_texis/searching.texi:1151
#, fuzzy, no-wrap
#| msgid "@samp{?} in regexp"
msgid "@code{*?} in rx"
msgstr "@samp{?} in regexp"

#. type: table
#: original_texis/searching.texi:1154
msgid "Match the @var{rx}s zero or more times.  Non-greedy.@* Corresponding string regexp: @samp{@var{A}*?}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1155
#, fuzzy, no-wrap
#| msgid "\\(?@var{num}: @dots{} \\)"
msgid "(+? @var{rx}@dots{})"
msgstr "\\(?@var{num}: @dots{} \\)"

#. type: cindex
#: original_texis/searching.texi:1156
#, fuzzy, no-wrap
#| msgid "@samp{?} in regexp"
msgid "@code{+?} in rx"
msgstr "@samp{?} in regexp"

#. type: table
#: original_texis/searching.texi:1159
msgid "Match the @var{rx}s one or more times.  Non-greedy.@* Corresponding string regexp: @samp{@var{A}+?}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1160
#, fuzzy, no-wrap
#| msgid "\\(?@var{num}: @dots{} \\)"
msgid "(?? @var{rx}@dots{})"
msgstr "\\(?@var{num}: @dots{} \\)"

#. type: cindex
#: original_texis/searching.texi:1161
#, fuzzy, no-wrap
#| msgid "@samp{?} in regexp"
msgid "@code{??} in rx"
msgstr "@samp{?} in regexp"

#. type: table
#: original_texis/searching.texi:1164
msgid "Match the @var{rx}s or an empty string.  Non-greedy.@* Corresponding string regexp: @samp{@var{A}??}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1165
#, fuzzy, no-wrap
#| msgid "\\(?@var{num}: @dots{} \\)"
msgid "(= @var{n} @var{rx}@dots{})"
msgstr "\\(?@var{num}: @dots{} \\)"

#. type: cindex
#: original_texis/searching.texi:1166
#, fuzzy, no-wrap
#| msgid "@samp{\\=} in regexp"
msgid "@code{=} in rx"
msgstr "@samp{\\=} in regexp"

#. type: itemx
#: original_texis/searching.texi:1167
#, no-wrap
msgid "(repeat @var{n} @var{rx})"
msgstr ""

#. type: table
#: original_texis/searching.texi:1170
msgid "Match the @var{rx}s exactly @var{n} times.@* Corresponding string regexp: @samp{@var{A}\\@{@var{n}\\@}}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1171
#, fuzzy, no-wrap
#| msgid "\\(?@var{num}: @dots{} \\)"
msgid "(>= @var{n} @var{rx}@dots{})"
msgstr "\\(?@var{num}: @dots{} \\)"

#. type: cindex
#: original_texis/searching.texi:1172
#, no-wrap
msgid "@code{>=} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1175
msgid "Match the @var{rx}s @var{n} or more times.  Greedy.@* Corresponding string regexp: @samp{@var{A}\\@{@var{n},\\@}}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1176
#, fuzzy, no-wrap
#| msgid "\\(?@var{num}: @dots{} \\)"
msgid "(** @var{n} @var{m} @var{rx}@dots{})"
msgstr "\\(?@var{num}: @dots{} \\)"

#. type: cindex
#: original_texis/searching.texi:1177
#, fuzzy, no-wrap
#| msgid "@samp{*} in regexp"
msgid "@code{**} in rx"
msgstr "@samp{*} in regexp"

#. type: itemx
#: original_texis/searching.texi:1178
#, no-wrap
msgid "(repeat @var{n} @var{m} @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1179
#, no-wrap
msgid "@code{repeat} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1182
msgid "Match the @var{rx}s at least @var{n} but no more than @var{m} times.  Greedy.@* Corresponding string regexp: @samp{@var{A}\\@{@var{n},@var{m}\\@}}"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1187
msgid "The greediness of some repetition forms can be controlled using the following constructs.  However, it is usually better to use the explicit non-greedy forms above when such matching is required."
msgstr ""

#. type: item
#: original_texis/searching.texi:1189
#, no-wrap
msgid "(minimal-match @var{rx})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1190
#, no-wrap
msgid "@code{minimal-match} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1194
msgid "Match @var{rx}, with @code{zero-or-more}, @code{0+}, @code{one-or-more}, @code{1+}, @code{zero-or-one}, @code{opt} and @code{optional} using non-greedy matching."
msgstr ""

#. type: item
#: original_texis/searching.texi:1195
#, no-wrap
msgid "(maximal-match @var{rx})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1196
#, no-wrap
msgid "@code{maximal-match} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1200
msgid "Match @var{rx}, with @code{zero-or-more}, @code{0+}, @code{one-or-more}, @code{1+}, @code{zero-or-one}, @code{opt} and @code{optional} using greedy matching.  This is the default."
msgstr ""

#. type: subsubheading
#: original_texis/searching.texi:1202
#, no-wrap
msgid "Matching single characters"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1205
#, fuzzy, no-wrap
#| msgid "\\(?@var{num}: @dots{} \\)"
msgid "(any @var{set}@dots{})"
msgstr "\\(?@var{num}: @dots{} \\)"

#. type: cindex
#: original_texis/searching.texi:1206
#, no-wrap
msgid "@code{any} in rx"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1207
#, fuzzy, no-wrap
#| msgid "\\(?@var{num}: @dots{} \\)"
msgid "(char @var{set}@dots{})"
msgstr "\\(?@var{num}: @dots{} \\)"

#. type: cindex
#: original_texis/searching.texi:1208
#, no-wrap
msgid "@code{char} in rx"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1209
#, fuzzy, no-wrap
#| msgid "\\(?@var{num}: @dots{} \\)"
msgid "(in @var{set}@dots{})"
msgstr "\\(?@var{num}: @dots{} \\)"

#. type: cindex
#: original_texis/searching.texi:1210
#, no-wrap
msgid "@code{in} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1211 original_texis/searching.texi:1254
#, fuzzy, no-wrap
#| msgid "character classes in regexp"
msgid "character class in rx"
msgstr "character classes in regexp"

#. type: table
#: original_texis/searching.texi:1217
msgid "Match a single character from one of the @var{set}s.  Each @var{set} is a character, a string representing the set of its characters, a range or a character class (see below).  A range is either a hyphen-separated string like @code{\"A-Z\"}, or a cons of characters like @code{(?A . ?Z)}."
msgstr ""

#. type: table
#: original_texis/searching.texi:1222
msgid "Note that hyphen (@code{-}) is special in strings in this construct, since it acts as a range separator.  To include a hyphen, add it as a separate character or single-character string.@* Corresponding string regexp: @samp{[@dots{}]}"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1223
#, no-wrap
msgid "(not @var{charspec})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1224
#, no-wrap
msgid "@code{not} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1233
msgid "Match a character not included in @var{charspec}.  @var{charspec} can be a character, a single-character string, an @code{any}, @code{not}, @code{or}, @code{intersection}, @code{syntax} or @code{category} form, or a character class.  If @var{charspec} is an @code{or} form, its arguments have the same restrictions as those of @code{intersection}; see below.@* Corresponding string regexp: @samp{[^@dots{}]}, @samp{\\S@var{code}}, @samp{\\C@var{code}}"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1234
#, no-wrap
msgid "(intersection @var{charset}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1235
#, no-wrap
msgid "@code{intersection} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1240
msgid "Match a character included in all of the @var{charset}s.  Each @var{charset} can be a character, a single-character string, an @code{any} form without character classes, or an @code{intersection}, @code{or} or @code{not} form whose arguments are also @var{charset}s."
msgstr ""

#. type: item
#: original_texis/searching.texi:1241
#, no-wrap
msgid "@code{not-newline}, @code{nonl}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1242
#, no-wrap
msgid "@code{not-newline} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1243
#, no-wrap
msgid "@code{nonl} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1246
msgid "Match any character except a newline.@* Corresponding string regexp: @samp{.} (dot)"
msgstr ""

#. type: item
#: original_texis/searching.texi:1247
#, no-wrap
msgid "@code{anychar}, @code{anything}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1248
#, no-wrap
msgid "@code{anychar} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1249
#, no-wrap
msgid "@code{anything} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1252
msgid "Match any character.@* Corresponding string regexp: @samp{.\\|\\n} (for example)"
msgstr ""

#. type: item
#: original_texis/searching.texi:1253
#, fuzzy, no-wrap
#| msgid "character classes in regexp"
msgid "character class"
msgstr "character classes in regexp"

#. type: table
#: original_texis/searching.texi:1256
msgid "Match a character from a named character class:"
msgstr ""

#. type: item
#: original_texis/searching.texi:1258
#, no-wrap
msgid "@code{alpha}, @code{alphabetic}, @code{letter}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1262
#, fuzzy
#| msgid "This matches any letter.  For multibyte characters, it matches characters whose Unicode @samp{general-category} property (@pxref{Character Properties}) indicates they are alphabetic characters."
msgid "Match alphabetic characters.  More precisely, match characters whose Unicode @samp{general-category} property indicates that they are alphabetic."
msgstr "これは任意のアルファベットにマッチする。マルチバイト文字では、アルファベット文字であることを示すUnicodeプロパティ@samp{general-category} (@ref{Character Properties}を参照)をもつ文字にマッチする。"

#. type: item
#: original_texis/searching.texi:1263
#, no-wrap
msgid "@code{alnum}, @code{alphanumeric}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1267
#, fuzzy
#| msgid "This matches any letter or digit.  For multibyte characters, it matches characters whose Unicode @samp{general-category} property (@pxref{Character Properties}) indicates they are alphabetic or decimal number characters."
msgid "Match alphabetic characters and digits.  More precisely, match characters whose Unicode @samp{general-category} property indicates that they are alphabetic or decimal digits."
msgstr "これは任意の英数字にマッチする。マルチバイト文字では、アルファベット文字か数字であることを示すUnicodeプロパティ@samp{general-category} (@ref{Character Properties}を参照)をもつ文字にマッチする。"

#. type: item
#: original_texis/searching.texi:1268
#, no-wrap
msgid "@code{digit}, @code{numeric}, @code{num}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1270
msgid "Match the digits @samp{0}--@samp{9}."
msgstr ""

#. type: item
#: original_texis/searching.texi:1271
#, no-wrap
msgid "@code{xdigit}, @code{hex-digit}, @code{hex}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1274
#, fuzzy
#| msgid "This matches the hexadecimal digits: @samp{0} through @samp{9}, @samp{a} through @samp{f} and @samp{A} through @samp{F}."
msgid "Match the hexadecimal digits @samp{0}--@samp{9}, @samp{A}--@samp{F} and @samp{a}--@samp{f}."
msgstr "これは16進数の数字@samp{0}から@samp{9}、@samp{a}から@samp{f}と@samp{A}から@samp{F}にマッチする。"

#. type: item
#: original_texis/searching.texi:1275
#, no-wrap
msgid "@code{cntrl}, @code{control}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1277
#, fuzzy
#| msgid "matches any character whose category is not @var{c}."
msgid "Match any character whose code is in the range 0--31."
msgstr "これはカテゴリーが@var{c}ではない任意の文字にマッチする。"

#. type: code{#1}
#: original_texis/searching.texi:1278
#, fuzzy, no-wrap
#| msgid "[:blank:]"
msgid "blank"
msgstr "[:blank:]"

#. type: table
#: original_texis/searching.texi:1282
#, fuzzy
#| msgid "This matches any letter.  For multibyte characters, it matches characters whose Unicode @samp{general-category} property (@pxref{Character Properties}) indicates they are alphabetic characters."
msgid "Match horizontal whitespace.  More precisely, match characters whose Unicode @samp{general-category} property indicates that they are spacing separators."
msgstr "これは任意のアルファベットにマッチする。マルチバイト文字では、アルファベット文字であることを示すUnicodeプロパティ@samp{general-category} (@ref{Character Properties}を参照)をもつ文字にマッチする。"

#. type: item
#: original_texis/searching.texi:1283
#, no-wrap
msgid "@code{space}, @code{whitespace}, @code{white}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1286
#, fuzzy
#| msgid "This matches any character that has whitespace syntax (@pxref{Syntax Class Table})."
msgid "Match any character that has whitespace syntax (@pxref{Syntax Class Table})."
msgstr "これは空白文字構文(@ref{Syntax Class Table}を参照)をもつ任意の文字にマッチする。"

#. type: item
#: original_texis/searching.texi:1287
#, no-wrap
msgid "@code{lower}, @code{lower-case}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1291
#, fuzzy
#| msgid "This matches any lower-case letter, as determined by the current case table (@pxref{Case Tables}).  If @code{case-fold-search} is non-@code{nil}, this also matches any upper-case letter."
msgid "Match anything lower-case, as determined by the current case table.  If @code{case-fold-search} is non-nil, this also matches any upper-case letter."
msgstr "これはカレントのcaseテーブル(@ref{Case Tables}を参照)で小文字と判断される文字すべてにマッチする。@code{case-fold-search}が非@code{nil}なら大文字にもマッチする。"

#. type: item
#: original_texis/searching.texi:1292
#, no-wrap
msgid "@code{upper}, @code{upper-case}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1296
#, fuzzy
#| msgid "This matches any upper-case letter, as determined by the current case table (@pxref{Case Tables}).  If @code{case-fold-search} is non-@code{nil}, this also matches any lower-case letter."
msgid "Match anything upper-case, as determined by the current case table.  If @code{case-fold-search} is non-nil, this also matches any lower-case letter."
msgstr "これはカレントのcaseテーブル(@ref{Case Tables}を参照)で大文字と判断される文字すべてにマッチする。@code{case-fold-search}が非@code{nil}ならこれは小文字にもマッチする。"

#. type: item
#: original_texis/searching.texi:1297
#, no-wrap
msgid "@code{graph}, @code{graphic}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1302
#, fuzzy
#| msgid "This matches graphic characters---everything except whitespace, @acronym{ASCII} and non-@acronym{ASCII} control characters, surrogates, and codepoints unassigned by Unicode, as indicated by the Unicode @samp{general-category} property (@pxref{Character Properties})."
msgid "Match any character except whitespace, @acronym{ASCII} and non-@acronym{ASCII} control characters, surrogates, and codepoints unassigned by Unicode, as indicated by the Unicode @samp{general-category} property."
msgstr "これはUnicodeの@samp{general-category}プロパティで示されるようなグラフィック文字(空白文字、@acronym{ASCII}と非@acronym{ASCII}の制御文字、サロゲートードポイント、Unicodeで未割り当てのコードポイントを除くすべて)にマッチする(@ref{Character Properties}を参照)。"

#. type: item
#: original_texis/searching.texi:1303
#, no-wrap
msgid "@code{print}, @code{printing}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1305
#, fuzzy
#| msgid "This matches any printing character---either whitespace, or a graphic character matched by @samp{[:graph:]}."
msgid "Match whitespace or a character matched by @code{graph}."
msgstr "これは任意のプリント文字(空白文字か@samp{[:graph:]}でマッチされるグラフィック文字のいずれか)にマッチする。"

#. type: item
#: original_texis/searching.texi:1306
#, no-wrap
msgid "@code{punct}, @code{punctuation}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1309
#, fuzzy
#| msgid "This matches any punctuation character.  (At present, for multibyte characters, it matches anything that has non-word syntax.)"
msgid "Match any punctuation character.  (At present, for multibyte characters, anything that has non-word syntax.)"
msgstr "これは任意の句読点文字(punctuation character)にマッチする(現在のところマルチバイト文字では単語構文以外のすべてにマッチする)。"

#. type: item
#: original_texis/searching.texi:1310
#, no-wrap
msgid "@code{word}, @code{wordchar}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1312
#, fuzzy
#| msgid "This matches any character that has word syntax (@pxref{Syntax Class Table})."
msgid "Match any character that has word syntax (@pxref{Syntax Class Table})."
msgstr "これは単語構文(@ref{Syntax Class Table}を参照)をもつ任意の文字にマッチする。"

#. type: code{#1}
#: original_texis/searching.texi:1313
#, fuzzy, no-wrap
#| msgid "[:ascii:]"
msgid "ascii"
msgstr "[:ascii:]"

#. type: table
#: original_texis/searching.texi:1315
#, fuzzy
#| msgid "This matches any @acronym{ASCII} character (codes 0--127)."
msgid "Match any @acronym{ASCII} character (codes 0--127)."
msgstr "これは任意の@acronym{ASCII}文字(コード0 -- 127)にマッチする。"

#. type: code{#1}
#: original_texis/searching.texi:1316
#, fuzzy, no-wrap
#| msgid "[:nonascii:]"
msgid "nonascii"
msgstr "[:nonascii:]"

#. type: table
#: original_texis/searching.texi:1318
#, fuzzy
#| msgid "This matches any non-@acronym{ASCII} character."
msgid "Match any non-@acronym{ASCII} character (but not raw bytes)."
msgstr "これは非@acronym{ASCII}文字にマッチする。"

#. type: table
#: original_texis/searching.texi:1321
msgid "Corresponding string regexp: @samp{[[:@var{class}:]]}"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1322
#, no-wrap
msgid "(syntax @var{syntax})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1323
#, no-wrap
msgid "@code{syntax} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1326
msgid "Match a character with syntax @var{syntax}, being one of the following names:"
msgstr ""

#. type: multitable
#: original_texis/searching.texi:1329
msgid "@headitem Syntax name"
msgstr ""

#. type: multitable
#: original_texis/searching.texi:1329
msgid "Syntax character"
msgstr ""

#. type: item
#: original_texis/searching.texi:1329
#, no-wrap
msgid "@code{whitespace}        @tab @code{-}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1330
#, no-wrap
msgid "@code{punctuation}       @tab @code{.}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1331
#, no-wrap
msgid "@code{word}              @tab @code{w}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1332
#, no-wrap
msgid "@code{symbol}            @tab @code{_}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1333
#, no-wrap
msgid "@code{open-parenthesis}  @tab @code{(}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1334
#, no-wrap
msgid "@code{close-parenthesis} @tab @code{)}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1335
#, no-wrap
msgid "@code{expression-prefix} @tab @code{'}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1336
#, no-wrap
msgid "@code{string-quote}      @tab @code{\"}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1337
#, no-wrap
msgid "@code{paired-delimiter}  @tab @code{$}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1338
#, no-wrap
msgid "@code{escape}            @tab @code{\\}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1339
#, no-wrap
msgid "@code{character-quote}   @tab @code{/}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1340
#, no-wrap
msgid "@code{comment-start}     @tab @code{<}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1341
#, no-wrap
msgid "@code{comment-end}       @tab @code{>}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1342
#, no-wrap
msgid "@code{string-delimiter}  @tab @code{|}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1343
#, no-wrap
msgid "@code{comment-delimiter} @tab @code{!}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1350
msgid "For details, @pxref{Syntax Class Table}.  Please note that @code{(syntax punctuation)} is @emph{not} equivalent to the character class @code{punctuation}.@* Corresponding string regexp: @samp{\\s@var{code}}"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1351
#, no-wrap
msgid "(category @var{category})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1352
#, no-wrap
msgid "@code{category} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1355
msgid "Match a character in category @var{category}, which is either one of the names below or its category character."
msgstr ""

#. type: multitable
#: original_texis/searching.texi:1358
msgid "@headitem Category name"
msgstr ""

#. type: multitable
#: original_texis/searching.texi:1358
msgid "Category character"
msgstr ""

#. type: item
#: original_texis/searching.texi:1358
#, no-wrap
msgid "@code{space-for-indent}                 @tab space"
msgstr ""

#. type: item
#: original_texis/searching.texi:1359
#, no-wrap
msgid "@code{base}                             @tab @code{.}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1360
#, no-wrap
msgid "@code{consonant}                        @tab @code{0}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1361
#, no-wrap
msgid "@code{base-vowel}                       @tab @code{1}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1362
#, no-wrap
msgid "@code{upper-diacritical-mark}           @tab @code{2}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1363
#, no-wrap
msgid "@code{lower-diacritical-mark}           @tab @code{3}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1364
#, no-wrap
msgid "@code{tone-mark}                        @tab @code{4}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1365
#, no-wrap
msgid "@code{symbol}                           @tab @code{5}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1366
#, no-wrap
msgid "@code{digit}                            @tab @code{6}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1367
#, no-wrap
msgid "@code{vowel-modifying-diacritical-mark} @tab @code{7}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1368
#, no-wrap
msgid "@code{vowel-sign}                       @tab @code{8}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1369
#, no-wrap
msgid "@code{semivowel-lower}                  @tab @code{9}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1370
#, no-wrap
msgid "@code{not-at-end-of-line}               @tab @code{<}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1371
#, no-wrap
msgid "@code{not-at-beginning-of-line}         @tab @code{>}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1372
#, no-wrap
msgid "@code{alpha-numeric-two-byte}           @tab @code{A}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1373
#, no-wrap
msgid "@code{chinese-two-byte}                 @tab @code{C}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1374
#, no-wrap
msgid "@code{greek-two-byte}                   @tab @code{G}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1375
#, no-wrap
msgid "@code{japanese-hiragana-two-byte}       @tab @code{H}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1376
#, no-wrap
msgid "@code{indian-two-byte}                  @tab @code{I}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1377
#, no-wrap
msgid "@code{japanese-katakana-two-byte}       @tab @code{K}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1378
#, no-wrap
msgid "@code{strong-left-to-right}             @tab @code{L}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1379
#, no-wrap
msgid "@code{korean-hangul-two-byte}           @tab @code{N}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1380
#, no-wrap
msgid "@code{strong-right-to-left}             @tab @code{R}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1381
#, no-wrap
msgid "@code{cyrillic-two-byte}                @tab @code{Y}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1382
#, no-wrap
msgid "@code{combining-diacritic}              @tab @code{^}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1383
#, no-wrap
msgid "@code{ascii}                            @tab @code{a}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1384
#, no-wrap
msgid "@code{arabic}                           @tab @code{b}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1385
#, no-wrap
msgid "@code{chinese}                          @tab @code{c}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1386
#, no-wrap
msgid "@code{ethiopic}                         @tab @code{e}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1387
#, no-wrap
msgid "@code{greek}                            @tab @code{g}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1388
#, no-wrap
msgid "@code{korean}                           @tab @code{h}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1389
#, no-wrap
msgid "@code{indian}                           @tab @code{i}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1390
#, no-wrap
msgid "@code{japanese}                         @tab @code{j}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1391
#, no-wrap
msgid "@code{japanese-katakana}                @tab @code{k}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1392
#, no-wrap
msgid "@code{latin}                            @tab @code{l}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1393
#, no-wrap
msgid "@code{lao}                              @tab @code{o}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1394
#, no-wrap
msgid "@code{tibetan}                          @tab @code{q}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1395
#, no-wrap
msgid "@code{japanese-roman}                   @tab @code{r}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1396
#, no-wrap
msgid "@code{thai}                             @tab @code{t}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1397
#, no-wrap
msgid "@code{vietnamese}                       @tab @code{v}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1398
#, no-wrap
msgid "@code{hebrew}                           @tab @code{w}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1399
#, no-wrap
msgid "@code{cyrillic}                         @tab @code{y}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1400
#, no-wrap
msgid "@code{can-break}                        @tab @code{|}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1407
msgid "For more information about currently defined categories, run the command @kbd{M-x describe-categories @key{RET}}.  For how to define new categories, @pxref{Categories}.@* Corresponding string regexp: @samp{\\c@var{code}}"
msgstr ""

#. type: subsubheading
#: original_texis/searching.texi:1409
#, no-wrap
msgid "Zero-width assertions"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1412
msgid "These all match the empty string, but only in specific places."
msgstr ""

#. type: item
#: original_texis/searching.texi:1414
#, no-wrap
msgid "@code{line-start}, @code{bol}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1415
#, no-wrap
msgid "@code{line-start} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1416
#, no-wrap
msgid "@code{bol} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1419
msgid "Match at the beginning of a line.@* Corresponding string regexp: @samp{^}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1420
#, no-wrap
msgid "@code{line-end}, @code{eol}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1421
#, no-wrap
msgid "@code{line-end} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1422
#, no-wrap
msgid "@code{eol} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1425
msgid "Match at the end of a line.@* Corresponding string regexp: @samp{$}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1426
#, no-wrap
msgid "@code{string-start}, @code{bos}, @code{buffer-start}, @code{bot}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1427
#, no-wrap
msgid "@code{string-start} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1428
#, no-wrap
msgid "@code{bos} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1429
#, no-wrap
msgid "@code{buffer-start} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1430
#, no-wrap
msgid "@code{bot} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1433
msgid "Match at the start of the string or buffer being matched against.@* Corresponding string regexp: @samp{\\`}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1434
#, no-wrap
msgid "@code{string-end}, @code{eos}, @code{buffer-end}, @code{eot}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1435
#, no-wrap
msgid "@code{string-end} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1436
#, no-wrap
msgid "@code{eos} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1437
#, no-wrap
msgid "@code{buffer-end} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1438
#, no-wrap
msgid "@code{eot} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1441
msgid "Match at the end of the string or buffer being matched against.@* Corresponding string regexp: @samp{\\'}"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1442
#, no-wrap
msgid "point"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1443
#, no-wrap
msgid "@code{point} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1446
msgid "Match at point.@* Corresponding string regexp: @samp{\\=}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1447
#, no-wrap
msgid "@code{word-start}, @code{bow}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1448
#, no-wrap
msgid "@code{word-start} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1449
#, no-wrap
msgid "@code{bow} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1452
msgid "Match at the beginning of a word.@* Corresponding string regexp: @samp{\\<}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1453
#, no-wrap
msgid "@code{word-end}, @code{eow}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1454
#, no-wrap
msgid "@code{word-end} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1455
#, no-wrap
msgid "@code{eow} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1458
msgid "Match at the end of a word.@* Corresponding string regexp: @samp{\\>}"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1459
#, no-wrap
msgid "word-boundary"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1460
#, no-wrap
msgid "@code{word-boundary} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1463
msgid "Match at the beginning or end of a word.@* Corresponding string regexp: @samp{\\b}"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1464
#, no-wrap
msgid "not-word-boundary"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1465
#, no-wrap
msgid "@code{not-word-boundary} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1468
msgid "Match anywhere but at the beginning or end of a word.@* Corresponding string regexp: @samp{\\B}"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1469
#, fuzzy, no-wrap
#| msgid "symbols"
msgid "symbol-start"
msgstr "symbols"

#. type: cindex
#: original_texis/searching.texi:1470
#, no-wrap
msgid "@code{symbol-start} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1473
msgid "Match at the beginning of a symbol.@* Corresponding string regexp: @samp{\\_<}"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1474
#, fuzzy, no-wrap
#| msgid "symbols"
msgid "symbol-end"
msgstr "symbols"

#. type: cindex
#: original_texis/searching.texi:1475
#, no-wrap
msgid "@code{symbol-end} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1478
msgid "Match at the end of a symbol.@* Corresponding string regexp: @samp{\\_>}"
msgstr ""

#. type: subsubheading
#: original_texis/searching.texi:1480
#, fuzzy, no-wrap
#| msgid "non-capturing group"
msgid "Capture groups"
msgstr "non-capturing group"

#. type: item
#: original_texis/searching.texi:1483
#, fuzzy, no-wrap
#| msgid "\\(?@var{num}: @dots{} \\)"
msgid "(group @var{rx}@dots{})"
msgstr "\\(?@var{num}: @dots{} \\)"

#. type: cindex
#: original_texis/searching.texi:1484
#, no-wrap
msgid "@code{group} in rx"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:1485
#, fuzzy, no-wrap
#| msgid "\\(?@var{num}: @dots{} \\)"
msgid "(submatch @var{rx}@dots{})"
msgstr "\\(?@var{num}: @dots{} \\)"

#. type: cindex
#: original_texis/searching.texi:1486
#, no-wrap
msgid "@code{submatch} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1492
msgid "Match the @var{rx}s, making the matched text and position accessible in the match data.  The first group in a regexp is numbered 1; subsequent groups will be numbered one higher than the previous group.@* Corresponding string regexp: @samp{\\(@dots{}\\)}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1493
#, no-wrap
msgid "(group-n @var{n} @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1494
#, no-wrap
msgid "@code{group-n} in rx"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:1495
#, no-wrap
msgid "(submatch-n @var{n} @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1496
#, no-wrap
msgid "@code{submatch-n} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1500
msgid "Like @code{group}, but explicitly assign the group number @var{n}.  @var{n} must be positive.@* Corresponding string regexp: @samp{\\(?@var{n}:@dots{}\\)}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1501
#, no-wrap
msgid "(backref @var{n})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1502
#, no-wrap
msgid "@code{backref} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1506
msgid "Match the text previously matched by group number @var{n}.  @var{n} must be in the range 1--9.@* Corresponding string regexp: @samp{\\@var{n}}"
msgstr ""

#. type: subsubheading
#: original_texis/searching.texi:1508
#, no-wrap
msgid "Dynamic inclusion"
msgstr ""

#. type: item
#: original_texis/searching.texi:1511
#, no-wrap
msgid "(literal @var{expr})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1512
#, no-wrap
msgid "@code{literal} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1516
msgid "Match the literal string that is the result from evaluating the Lisp expression @var{expr}.  The evaluation takes place at call time, in the current lexical environment."
msgstr ""

#. type: item
#: original_texis/searching.texi:1517
#, no-wrap
msgid "(regexp @var{expr})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1518
#, no-wrap
msgid "@code{regexp} in rx"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:1519
#, no-wrap
msgid "(regex @var{expr})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1520
#, no-wrap
msgid "@code{regex} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1524
msgid "Match the string regexp that is the result from evaluating the Lisp expression @var{expr}.  The evaluation takes place at call time, in the current lexical environment."
msgstr ""

#. type: item
#: original_texis/searching.texi:1525
#, no-wrap
msgid "(eval @var{expr})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1526
#, no-wrap
msgid "@code{eval} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1531
msgid "Match the rx form that is the result from evaluating the Lisp expression @var{expr}.  The evaluation takes place at macro-expansion time for @code{rx}, at call time for @code{rx-to-string}, in the current global environment."
msgstr ""

#. type: subsubsection
#: original_texis/searching.texi:1534
#, no-wrap
msgid "Functions and macros using @code{rx} regexps"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1536
#, no-wrap
msgid "rx rx-expr@dots{}"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1541
msgid "Translate the @var{rx-expr}s to a string regexp, as if they were the body of a @code{(seq @dots{})} form.  The @code{rx} macro expands to a string constant, or, if @code{literal} or @code{regexp} forms are used, a Lisp expression that evaluates to a string."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1543
#, fuzzy, no-wrap
#| msgid "regexp-opt strings &optional paren"
msgid "rx-to-string rx-expr &optional no-group"
msgstr "regexp-opt strings &optional paren"

#. type: defun
#: original_texis/searching.texi:1548
#, fuzzy
#| msgid "The resulting regexp is surrounded by @samp{\\(?:} and @samp{\\)}, if it is necessary to ensure that a postfix operator appended to it will apply to the whole expression."
msgid "Translate @var{rx-expr} to a string regexp which is returned.  If @var{no-group} is absent or nil, bracket the result in a non-capturing group, @samp{\\(?:@dots{}\\)}, if necessary to ensure that a postfix operator appended to it will apply to the whole expression."
msgstr "後に付加する後置演算子が式全体に適用されるために必要なら、結果となるregexpは@samp{\\(?:}と@samp{\\)}で括られる。"

#. type: defun
#: original_texis/searching.texi:1551
msgid "Arguments to @code{literal} and @code{regexp} forms in @var{rx-expr} must be string literals."
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1555
msgid "The @code{pcase} macro can use @code{rx} expressions as patterns directly; @pxref{rx in pcase}."
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1558
msgid "For mechanisms to add user-defined extensions to the @code{rx} notation, @pxref{Extending Rx}."
msgstr ""

#. type: subsubsection
#: original_texis/searching.texi:1560
#, no-wrap
msgid "Defining new @code{rx} forms"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1567
msgid "The @code{rx} notation can be extended by defining new symbols and parameterized forms in terms of other @code{rx} expressions.  This is handy for sharing parts between several regexps, and for making complex ones easier to build and understand by putting them together from smaller pieces."
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1573
msgid "For example, you could define @code{name} to mean @code{(one-or-more letter)}, and @code{(quoted @var{x})} to mean @code{(seq ?' @var{x} ?')} for any @var{x}.  These forms could then be used in @code{rx} expressions like any other: @code{(rx (quoted name))} would match a nonempty sequence of letters inside single quotes."
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1576
msgid "The Lisp macros below provide different ways of binding names to definitions.  Common to all of them are the following rules:"
msgstr ""

#. type: itemize
#: original_texis/searching.texi:1581
msgid "Built-in @code{rx} forms, like @code{digit} and @code{group}, cannot be redefined."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:1586
msgid "The definitions live in a name space of their own, separate from that of Lisp variables.  There is thus no need to attach a suffix like @code{-regexp} to names; they cannot collide with anything else."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:1591
msgid "Definitions cannot refer to themselves recursively, directly or indirectly.  If you find yourself needing this, you want a parser, not a regular expression."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:1598
msgid "Definitions are only ever expanded in calls to @code{rx} or @code{rx-to-string}, not merely by their presence in definition macros.  This means that the order of definitions doesn't matter, even when they refer to each other, and that syntax errors only show up when they are used, not when they are defined."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:1605
msgid "User-defined forms are allowed wherever arbitrary @code{rx} expressions are expected; for example, in the body of a @code{zero-or-one} form, but not inside @code{any} or @code{category} forms.  They are also allowed inside @code{not} and @code{intersection} forms."
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1607
#, no-wrap
msgid "rx-define name [arglist] rx-form"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1611
msgid "Define @var{name} globally in all subsequent calls to @code{rx} and @code{rx-to-string}.  If @var{arglist} is absent, then @var{name} is defined as a plain symbol to be replaced with @var{rx-form}.  Example:"
msgstr ""

#. type: group
#: original_texis/searching.texi:1617
#, no-wrap
msgid ""
"(rx-define haskell-comment (seq \"--\" (zero-or-more nonl)))\n"
"(rx haskell-comment)\n"
"     @result{} \"--.*\"\n"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1625
msgid "If @var{arglist} is present, it must be a list of zero or more argument names, and @var{name} is then defined as a parameterized form.  When used in an @code{rx} expression as @code{(@var{name} @var{arg}@dots{})}, each @var{arg} will replace the corresponding argument name inside @var{rx-form}."
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1630
msgid "@var{arglist} may end in @code{&rest} and one final argument name, denoting a rest parameter.  The rest parameter will expand to all extra actual argument values not matched by any other parameter in @var{arglist}, spliced into @var{rx-form} where it occurs.  Example:"
msgstr ""

#. type: group
#: original_texis/searching.texi:1636
#, no-wrap
msgid ""
"(rx-define moan (x y &rest r) (seq x (one-or-more y) r \"!\"))\n"
"(rx (moan \"MOO\" \"A\" \"MEE\" \"OW\"))\n"
"     @result{} \"MOOA+MEEOW!\"\n"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1642
msgid "Since the definition is global, it is recommended to give @var{name} a package prefix to avoid name clashes with definitions elsewhere, as is usual when naming non-local variables and functions."
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1644
#, no-wrap
msgid "rx-let (bindings@dots{}) body@dots{}"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1647
msgid "Make the @code{rx} definitions in @var{bindings} available locally for @code{rx} macro invocations in @var{body}, which is then evaluated."
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1651
msgid "Each element of @var{bindings} is on the form @w{@code{(@var{name} [@var{arglist}] @var{rx-form})}}, where the parts have the same meaning as in @code{rx-define} above.  Example:"
msgstr ""

#. type: group
#: original_texis/searching.texi:1658
#, no-wrap
msgid ""
"(rx-let ((comma-separated (item) (seq item (0+ \",\" item)))\n"
"         (number (1+ digit))\n"
"         (numbers (comma-separated number)))\n"
"  (re-search-forward (rx \"(\" numbers \")\")))\n"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1664
msgid "The definitions are only available during the macro-expansion of @var{body}, and are thus not present during execution of compiled code."
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1670
msgid "@code{rx-let} can be used not only inside a function, but also at top level to include global variable and function definitions that need to share a common set of @code{rx} forms.  Since the names are local inside @var{body}, there is no need for any package prefixes.  Example:"
msgstr ""

#. type: group
#: original_texis/searching.texi:1678
#, no-wrap
msgid ""
"(rx-let ((phone-number (seq (opt ?+) (1+ (any digit ?-)))))\n"
"  (defun find-next-phone-number ()\n"
"    (re-search-forward (rx phone-number)))\n"
"  (defun phone-number-p (string)\n"
"    (string-match-p (rx bos phone-number eos) string)))\n"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1684
msgid "The scope of the @code{rx-let} bindings is lexical, which means that they are not visible outside @var{body} itself, even in functions called from @var{body}."
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1686
#, no-wrap
msgid "rx-let-eval bindings body@dots{}"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1690
msgid "Evaluate @var{bindings} to a list of bindings as in @code{rx-let}, and evaluate @var{body} with those bindings in effect for calls to @code{rx-to-string}."
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1695
msgid "This macro is similar to @code{rx-let}, except that the @var{bindings} argument is evaluated (and thus needs to be quoted if it is a list literal), and the definitions are substituted at run time, which is required for @code{rx-to-string} to work.  Example:"
msgstr ""

#. type: group
#: original_texis/searching.texi:1703
#, no-wrap
msgid ""
"(rx-let-eval\n"
"    '((ponder (x) (seq \"Where have all the \" x \" gone?\")))\n"
"  (looking-at (rx-to-string\n"
"               '(ponder (or \"flowers\" \"young girls\"\n"
"                            \"left socks\")))))\n"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1710
msgid "Another difference from @code{rx-let} is that the @var{bindings} are dynamically scoped, and thus also available in functions called from @var{body}. However, they are not visible inside functions defined in @var{body}."
msgstr ""

#. type: subsection
#: original_texis/searching.texi:1715
#, no-wrap
msgid "Regular Expression Functions"
msgstr "Regular Expression Functions"

#. type: Plain text
#: original_texis/searching.texi:1718
msgid "These functions operate on regular expressions."
msgstr "以下の関数は正規表現を扱います。"

#. type: cindex
#: original_texis/searching.texi:1719
#, no-wrap
msgid "quote special characters in regexp"
msgstr "quote special characters in regexp"

#. type: defun
#: original_texis/searching.texi:1720
#, no-wrap
msgid "regexp-quote string"
msgstr "regexp-quote string"

#. type: defun
#: original_texis/searching.texi:1726
msgid "This function returns a regular expression whose only exact match is @var{string}.  Using this regular expression in @code{looking-at} will succeed only if the next characters in the buffer are @var{string}; using it in a search function will succeed if the text being searched contains @var{string}.  @xref{Regexp Search}."
msgstr "この関数は@var{string}だけに正確にマッチするような正規表現をリターンする。@code{looking-at}内でこの正規表現を使用すると、そのバッファー内の次の文字が@var{string}のときだけ成功するだろう。検索関数でのこの正規表現の使用は、検索されるテキストが@var{string}を含むなら成功するだろう。@ref{Regexp Search}を参照のこと。"

#. type: defun
#: original_texis/searching.texi:1729
msgid "This allows you to request an exact string match or search when calling a function that wants a regular expression."
msgstr "これにより、その正規表現を求める関数呼び出し時に正確な文字列マッチや検索を要求できる。"

#. type: group
#: original_texis/searching.texi:1734
#, no-wrap
msgid ""
"(regexp-quote \"^The cat$\")\n"
"     @result{} \"\\\\^The cat\\\\$\"\n"
msgstr ""
"(regexp-quote \"^The cat$\")\n"
"     @result{} \"\\\\^The cat\\\\$\"\n"

#. type: defun
#: original_texis/searching.texi:1741
msgid "One use of @code{regexp-quote} is to combine an exact string match with context described as a regular expression.  For example, this searches for the string that is the value of @var{string}, surrounded by whitespace:"
msgstr "正規表現として記述されたコンテキストにおいて、正確な文字列マッチを結合することが@code{regexp-quote}の1つの使い方である。たとえば以下は空白文で囲まれた@var{string}の値であるような文字列を検索する:"

#. type: group
#: original_texis/searching.texi:1746
#, no-wrap
msgid ""
"(re-search-forward\n"
" (concat \"\\\\s-\" (regexp-quote string) \"\\\\s-\"))\n"
msgstr ""
"(re-search-forward\n"
" (concat \"\\\\s-\" (regexp-quote string) \"\\\\s-\"))\n"

#. type: defun
#: original_texis/searching.texi:1751
msgid "The returned string may be @var{string} itself if it does not contain any special characters."
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1753
#, no-wrap
msgid "optimize regexp"
msgstr "optimize regexp"

#. type: defun
#: original_texis/searching.texi:1754
#, no-wrap
msgid "regexp-opt strings &optional paren"
msgstr "regexp-opt strings &optional paren"

#. type: defun
#: original_texis/searching.texi:1763
msgid "This function returns an efficient regular expression that will match any of the strings in the list @var{strings}.  This is useful when you need to make matching or searching as fast as possible---for example, for Font Lock mode@footnote{Note that @code{regexp-opt} does not guarantee that its result is absolutely the most efficient form possible.  A hand-tuned regular expression can sometimes be slightly more efficient, but is almost never worth the effort.}."
msgstr "この関数はリスト@var{strings}の文字列だけにマッチする効果的な正規表現をリターンする。これはマッチングや検索を可能な限り高速にする必要があるとき、たとえばFont Lockモードで有用である@footnote{@code{regexp-opt}の結果が絶対的にもっとも効率的であるという保証はないことに注意してください。手作業でチューニングした正規表現のほうがわずかに効率的なこともありますが、これに努力する価値はほとんどないでしょう。}。"

#. type: defun
#: original_texis/searching.texi:1766
msgid "If @var{strings} is the empty list, the return value is a regexp that never matches anything."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1768
msgid "The optional argument @var{paren} can be any of the following:"
msgstr "オプション引数@var{paren}には以下のいずれかを指定できる:"

#. type: item
#: original_texis/searching.texi:1770
#, no-wrap
msgid "a string"
msgstr "文字列"

#. type: table
#: original_texis/searching.texi:1774
msgid "The resulting regexp is preceded by @var{paren} and followed by @samp{\\)}, e.g. use @samp{\"\\\\(?1:\"} to produce an explicitly numbered group."
msgstr "結果となるregexpの前に@var{paren}、後に@samp{\\)}が付加される。たとえば@samp{\"\\\\(?1:\"}を使用すると番号付きのグループを明示的に生成する。"

#. type: code{#1}
#: original_texis/searching.texi:1775
#, no-wrap
msgid "words"
msgstr "words"

#. type: table
#: original_texis/searching.texi:1777
msgid "The resulting regexp is surrounded by @samp{\\<\\(} and @samp{\\)\\>}."
msgstr "結果となるregexpは@samp{\\<\\(}と@samp{\\)\\>}で括られる。"

#. type: code{#1}
#: original_texis/searching.texi:1778
#, no-wrap
msgid "symbols"
msgstr "symbols"

#. type: table
#: original_texis/searching.texi:1782
msgid "The resulting regexp is surrounded by @samp{\\_<\\(} and @samp{\\)\\_>} (this is often appropriate when matching programming-language keywords and the like)."
msgstr "結果となるregexpは@samp{\\_<\\(}と@samp{\\)\\_>}で括られる(これはプログラミング言語のキーワードの類のマッチング時にしばしば適している)。"

#. type: item
#: original_texis/searching.texi:1783
#, no-wrap
msgid "non-@code{nil}"
msgstr "非@code{nil}"

#. type: table
#: original_texis/searching.texi:1785
msgid "The resulting regexp is surrounded by @samp{\\(} and @samp{\\)}."
msgstr "結果となるregexpは@samp{\\\\(}と@samp{\\\\)}で括られる。"

#. type: code{#1}
#: original_texis/searching.texi:1786 original_texis/searching.texi:1875
#, no-wrap
msgid "nil"
msgstr "nil"

#. type: table
#: original_texis/searching.texi:1790
msgid "The resulting regexp is surrounded by @samp{\\(?:} and @samp{\\)}, if it is necessary to ensure that a postfix operator appended to it will apply to the whole expression."
msgstr "後に付加する後置演算子が式全体に適用されるために必要なら、結果となるregexpは@samp{\\(?:}と@samp{\\)}で括られる。"

#. type: defun
#: original_texis/searching.texi:1794
msgid "The returned regexp is ordered in such a way that it will always match the longest string possible."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1798
#, fuzzy
#| msgid "The resulting regexp of @code{regexp-opt} is equivalent to but usually more efficient than that of a simplified version:"
msgid "Up to reordering, the resulting regexp of @code{regexp-opt} is equivalent to but usually more efficient than that of a simplified version:"
msgstr "@code{regexp-opt}の結果regexpはその単純化されたバージョンと等価だが、通常はより効果的である。"

#. type: example
#: original_texis/searching.texi:1811
#, no-wrap
msgid ""
"(defun simplified-regexp-opt (strings &optional paren)\n"
" (let ((parens\n"
"        (cond\n"
"         ((stringp paren)       (cons paren \"\\\\)\"))\n"
"         ((eq paren 'words)    '(\"\\\\<\\\\(\" . \"\\\\)\\\\>\"))\n"
"         ((eq paren 'symbols) '(\"\\\\_<\\\\(\" . \"\\\\)\\\\_>\"))\n"
"         ((null paren)          '(\"\\\\(?:\" . \"\\\\)\"))\n"
"         (t                       '(\"\\\\(\" . \"\\\\)\")))))\n"
"   (concat (car parens)\n"
"           (mapconcat 'regexp-quote strings \"\\\\|\")\n"
"           (cdr parens))))\n"
msgstr ""
"(defun simplified-regexp-opt (strings &optional paren)\n"
" (let ((parens\n"
"        (cond\n"
"         ((stringp paren)       (cons paren \"\\\\)\"))\n"
"         ((eq paren 'words)    '(\"\\\\<\\\\(\" . \"\\\\)\\\\>\"))\n"
"         ((eq paren 'symbols) '(\"\\\\_<\\\\(\" . \"\\\\)\\\\_>\"))\n"
"         ((null paren)          '(\"\\\\(?:\" . \"\\\\)\"))\n"
"         (t                       '(\"\\\\(\" . \"\\\\)\")))))\n"
"   (concat (car parens)\n"
"           (mapconcat 'regexp-quote strings \"\\\\|\")\n"
"           (cdr parens))))\n"

#. type: defun
#: original_texis/searching.texi:1814
#, no-wrap
msgid "regexp-opt-depth regexp"
msgstr "regexp-opt-depth regexp"

#. type: defun
#: original_texis/searching.texi:1818
msgid "This function returns the total number of grouping constructs (parenthesized expressions) in @var{regexp}.  This does not include shy groups (@pxref{Regexp Backslash})."
msgstr "この関数は@var{regexp}内のグループ化された構成要素(カッコで囲まれた正規表現)の総数をリターンする。これには内気なグループは含まれない(@ref{Regexp Backslash}を参照)。"

#. type: defun
#: original_texis/searching.texi:1821
#, no-wrap
msgid "regexp-opt-charset chars"
msgstr "regexp-opt-charset chars"

#. type: defun
#: original_texis/searching.texi:1824
msgid "This function returns a regular expression matching a character in the list of characters @var{chars}."
msgstr "この関数は文字リスト@var{chars}内の文字にマッチする正規表現をリターンする。"

#. type: example
#: original_texis/searching.texi:1828
#, no-wrap
msgid ""
"(regexp-opt-charset '(?a ?b ?c ?d ?e))\n"
"     @result{} \"[a-e]\"\n"
msgstr ""
"(regexp-opt-charset '(?a ?b ?c ?d ?e))\n"
"     @result{} \"[a-e]\"\n"

#. type: defvar
#: original_texis/searching.texi:1834
#, no-wrap
msgid "regexp-unmatchable"
msgstr ""

#. type: defvar
#: original_texis/searching.texi:1839
msgid "This variable contains a regexp that is guaranteed not to match any string at all.  It is particularly useful as default value for variables that may be set to a pattern that actually matches something."
msgstr ""

#. type: section
#: original_texis/searching.texi:1842
#, no-wrap
msgid "Regular Expression Searching"
msgstr "Regular Expression Searching"

#. type: cindex
#: original_texis/searching.texi:1843
#, no-wrap
msgid "regular expression searching"
msgstr "regular expression searching"

#. type: cindex
#: original_texis/searching.texi:1844
#, no-wrap
msgid "regexp searching"
msgstr "regexp searching"

#. type: cindex
#: original_texis/searching.texi:1845
#, no-wrap
msgid "searching for regexp"
msgstr "searching for regexp"

#. type: Plain text
#: original_texis/searching.texi:1853
msgid "In GNU Emacs, you can search for the next match for a regular expression (@pxref{Syntax of Regexps}) either incrementally or not.  For incremental search commands, see @ref{Regexp Search, , Regular Expression Search, emacs, The GNU Emacs Manual}.  Here we describe only the search functions useful in programs.  The principal one is @code{re-search-forward}."
msgstr "GNU Emacsではインクリメンタルと非インクリメンタルの両方で正規表現(@ref{Syntax of Regexps}を参照)にたいする次のマッチを検索できます。インクリメンタル検索コマンドについては@ref{Regexp Search, , Regular Expression Search, emacs, The GNU Emacs Manual}を参照してください。ここではプログラム内で有用な検索関数だけを説明します。重要な関数は@code{re-search-forward}です。"

#. type: Plain text
#: original_texis/searching.texi:1857
msgid "These search functions convert the regular expression to multibyte if the buffer is multibyte; they convert the regular expression to unibyte if the buffer is unibyte.  @xref{Text Representations}."
msgstr "これらの検索関数はバッファーがマルチバイトならルチバイト、ユニバイトならユニバイトに正規表現を変換します。@ref{Text Representations}を参照してください。"

#. type: deffn
#: original_texis/searching.texi:1858
#, no-wrap
msgid "Command re-search-forward regexp &optional limit noerror count"
msgstr "Command re-search-forward regexp &optional limit noerror count"

#. type: deffn
#: original_texis/searching.texi:1864
msgid "This function searches forward in the current buffer for a string of text that is matched by the regular expression @var{regexp}.  The function skips over any amount of text that is not matched by @var{regexp}, and leaves point at the end of the first match found.  It returns the new value of point."
msgstr "この関数はカレントバッファー内で、正規表現@var{regexp}にマッチするテキスト文字列を前方へ検索する。この関数は@var{regexp}にマッチしない任意の量のテキストをスキップして、見つかった最初のマッチの終端にポイントを残す。これはポイントの新たな値をリターンする。"

#. type: deffn
#: original_texis/searching.texi:1870
msgid "If @var{limit} is non-@code{nil}, it must be a position in the current buffer.  It specifies the upper bound to the search.  No match extending after that position is accepted.  If @var{limit} is omitted or @code{nil}, it defaults to the end of the accessible portion of the buffer."
msgstr "引数@var{limit}は検索の境界を指定し、それはカレントバッファー内の位置であること。@var{limit}が非@code{nil}ならカレントバッファー内の位置でなければならない。これは検索の上限位置を指定するその位置を超えるようなマッチは、受け入れられない。@var{limit}が省略または@code{nil}の場合のデフォルトは、そのバッファーのアクセス可能範囲の終端である。"

#. type: deffn
#: original_texis/searching.texi:1873
msgid "What @code{re-search-forward} does when the search fails depends on the value of @var{noerror}:"
msgstr "検索失敗時に@code{re-search-forward}が何を行うかは@var{noerror}の値に依存する。"

#. type: table
#: original_texis/searching.texi:1877
msgid "Signal a @code{search-failed} error."
msgstr "@code{search-failed}エラーをシグナルする。"

#. type: code{#1}
#: original_texis/searching.texi:1877
#, no-wrap
msgid "t"
msgstr "t"

#. type: table
#: original_texis/searching.texi:1879
msgid "Do nothing and return @code{nil}."
msgstr "何もせず@code{nil}をリターンする。"

#. type: item
#: original_texis/searching.texi:1879
#, no-wrap
msgid "anything else"
msgstr "その他"

#. type: table
#: original_texis/searching.texi:1882
msgid "Move point to @var{limit} (or the end of the accessible portion of the buffer) and return @code{nil}."
msgstr "ポイントを@var{limit} (またはバッファーのアクセス可能範囲の終端)に移動して@code{nil}をリターンする。"

#. type: deffn
#: original_texis/searching.texi:1900
msgid "In the following example, point is initially before the @samp{T}.  Evaluating the search call moves point to the end of that line (between the @samp{t} of @samp{hat} and the newline)."
msgstr "以下の例ではポイントは最初は@samp{T}の前にある。この検索を評価することにより、その行の終端( @samp{hat}の@samp{t}と改行の間)にポイントは移動する。"

#. type: group
#: original_texis/searching.texi:1907
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"I read \"@point{}The cat in the hat\n"
"comes back\" twice.\n"
"---------- Buffer: foo ----------\n"
msgstr ""
"---------- Buffer: foo ----------\n"
"I read \"@point{}The cat in the hat\n"
"comes back\" twice.\n"
"---------- Buffer: foo ----------\n"

#. type: group
#: original_texis/searching.texi:1912
#, no-wrap
msgid ""
"(re-search-forward \"[a-z]+\" nil t 5)\n"
"     @result{} 27\n"
"\n"
msgstr ""
"(re-search-forward \"[a-z]+\" nil t 5)\n"
"     @result{} 27\n"
"\n"

#. type: group
#: original_texis/searching.texi:1917
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"I read \"The cat in the hat@point{}\n"
"comes back\" twice.\n"
"---------- Buffer: foo ----------\n"
msgstr ""
"---------- Buffer: foo ----------\n"
"I read \"The cat in the hat@point{}\n"
"comes back\" twice.\n"
"---------- Buffer: foo ----------\n"

#. type: anchor{#1}
#: original_texis/searching.texi:1923
msgid "re-search-backward"
msgstr "re-search-backward"

#. type: deffn
#: original_texis/searching.texi:1923
#, no-wrap
msgid "Command re-search-backward regexp &optional limit noerror count"
msgstr "Command re-search-backward regexp &optional limit noerror count"

#. type: deffn
#: original_texis/searching.texi:1927
msgid "This function searches backward in the current buffer for a string of text that is matched by the regular expression @var{regexp}, leaving point at the beginning of the first text found."
msgstr "この関数はカレントバッファー内で正規表現@var{regexp}にマッチするテキスト文字列を後方へ検索して、見つかった最初のマッチの先頭にポイントを残す。"

#. type: deffn
#: original_texis/searching.texi:1937
msgid "This function is analogous to @code{re-search-forward}, but they are not simple mirror images.  @code{re-search-forward} finds the match whose beginning is as close as possible to the starting point.  If @code{re-search-backward} were a perfect mirror image, it would find the match whose end is as close as possible.  However, in fact it finds the match whose beginning is as close as possible (and yet ends before the starting point).  The reason for this is that matching a regular expression at a given spot always works from beginning to end, and starts at a specified beginning position."
msgstr "この関数は@code{re-search-forward}と似ているが単なるミラーイメージ(mirror-image: 鏡像)ではない。@code{re-search-forward}は先頭が開始ポイントと可能な限り近いマッチを探す。@code{re-search-backward}が完全なミラーイメージなら終端が可能な限り近いマッチを探すだろう。しかし実際には先頭が可能な限り近い(かつ開始ポイントの前で終わる)マッチを探す。これは与えられた位置にたいする正規表現マッチングが常に正規表現の先頭から終端に機能して、指定された開始位置から開始されることが理由。"

#. type: deffn
#: original_texis/searching.texi:1941
msgid "A true mirror-image of @code{re-search-forward} would require a special feature for matching regular expressions from end to beginning.  It's not worth the trouble of implementing that."
msgstr "@code{re-search-forward}の真のミラーイメージには、正規表現を終端から先頭へマッチする特別な機能が要求されるだろう。それを実装することによる問題と比較して、値する価値はない。"

#. type: defun
#: original_texis/searching.texi:1943
#, no-wrap
msgid "string-match regexp string &optional start"
msgstr "string-match regexp string &optional start"

#. type: defun
#: original_texis/searching.texi:1948
msgid "This function returns the index of the start of the first match for the regular expression @var{regexp} in @var{string}, or @code{nil} if there is no match.  If @var{start} is non-@code{nil}, the search starts at that index in @var{string}."
msgstr "この関数は@var{string}内で正規表現@var{regexp}にたいする最初のマッチの開始位置のインデックスをリターンする。@var{string}内のそのインデックスから検索が開始される。"

#. type: defun
#: original_texis/searching.texi:1950
msgid "For example,"
msgstr "たとえば、"

#. type: group
#: original_texis/searching.texi:1956
#, no-wrap
msgid ""
"(string-match\n"
" \"quick\" \"The quick brown fox jumped quickly.\")\n"
"     @result{} 4\n"
msgstr ""
"(string-match\n"
" \"quick\" \"The quick brown fox jumped quickly.\")\n"
"     @result{} 4\n"

#. type: group
#: original_texis/searching.texi:1961 original_texis/searching.texi:1976
#, no-wrap
msgid ""
"(string-match\n"
" \"quick\" \"The quick brown fox jumped quickly.\" 8)\n"
"     @result{} 27\n"
msgstr ""
"(string-match\n"
" \"quick\" \"The quick brown fox jumped quickly.\" 8)\n"
"     @result{} 27\n"

#. type: defun
#: original_texis/searching.texi:1967
msgid "The index of the first character of the string is 0, the index of the second character is 1, and so on."
msgstr "文字列の最初の文字のインデックスは1、2文字目は2、...となる。"

#. type: defun
#: original_texis/searching.texi:1970
msgid "If this function finds a match, the index of the first character beyond the match is available as @code{(match-end 0)}.  @xref{Match Data}."
msgstr "この関数がマッチを見つけたら、そのマッチの先の最初の文字のインデックスは@code{(match-end 0)}で利用できる。@ref{Match Data}を参照のこと。"

#. type: group
#: original_texis/searching.texi:1981
#, no-wrap
msgid ""
"(match-end 0)\n"
"     @result{} 32\n"
msgstr ""
"(match-end 0)\n"
"     @result{} 32\n"

#. type: defun
#: original_texis/searching.texi:1985
#, no-wrap
msgid "string-match-p regexp string &optional start"
msgstr "string-match-p regexp string &optional start"

#. type: defun
#: original_texis/searching.texi:1988
msgid "This predicate function does what @code{string-match} does, but it avoids modifying the match data."
msgstr "この述語関数は@code{string-match}と同じことを行うが、マッチデータの変更を避ける。"

#. type: defun
#: original_texis/searching.texi:1990
#, no-wrap
msgid "looking-at regexp"
msgstr "looking-at regexp"

#. type: defun
#: original_texis/searching.texi:1996
msgid "This function determines whether the text in the current buffer directly following point matches the regular expression @var{regexp}.  ``Directly following'' means precisely that: the search is ``anchored'' and it can succeed only starting with the first character following point.  The result is @code{t} if so, @code{nil} otherwise."
msgstr "この関数はカレントバッファー内のポイント直後のテキストが正規表現@var{regexp}にマッチするかどうかを判断する。``直後''の正確な意味は、その検索が``固定''されていて、ポイントの後の最初の文字からマッチが開始する場合のみ成功するということ。成功なら結果は@code{t}、それ以外は@code{nil}。"

#. type: defun
#: original_texis/searching.texi:2000
msgid "This function does not move point, but it does update the match data.  @xref{Match Data}.  If you need to test for a match without modifying the match data, use @code{looking-at-p}, described below."
msgstr "この関数はポイントを移動しないがマッチデータは更新する。@ref{Match Data}を参照のこと。マッチデータを変更せずにテストする必要があるなら、以下で説明する@code{looking-at-p}を使用すること。"

#. type: defun
#: original_texis/searching.texi:2003
msgid "In this example, point is located directly before the @samp{T}.  If it were anywhere else, the result would be @code{nil}."
msgstr "以下の例ではポイントは@samp{T}の直前にある。それ以外の場所にあれば結果は@code{nil}になるだろう。"

#. type: group
#: original_texis/searching.texi:2010 original_texis/searching.texi:2035
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"I read \"@point{}The cat in the hat\n"
"comes back\" twice.\n"
"---------- Buffer: foo ----------\n"
"\n"
msgstr ""
"---------- Buffer: foo ----------\n"
"I read \"@point{}The cat in the hat\n"
"comes back\" twice.\n"
"---------- Buffer: foo ----------\n"
"\n"

#. type: group
#: original_texis/searching.texi:2013
#, no-wrap
msgid ""
"(looking-at \"The cat in the hat$\")\n"
"     @result{} t\n"
msgstr ""
"(looking-at \"The cat in the hat$\")\n"
"     @result{} t\n"

#. type: defun
#: original_texis/searching.texi:2017
#, no-wrap
msgid "looking-back regexp limit &optional greedy"
msgstr "looking-back regexp limit &optional greedy"

#. type: defun
#: original_texis/searching.texi:2020
msgid "This function returns @code{t} if @var{regexp} matches the text immediately before point (i.e., ending at point), and @code{nil} otherwise."
msgstr "この関数はポイントの直前の(ポイントで終わる)テキストが@var{regexp}とマッチしたら@code{t}、それ以外は@code{nil}をリターンする。"

#. type: defun
#: original_texis/searching.texi:2028
msgid "Because regular expression matching works only going forward, this is implemented by searching backwards from point for a match that ends at point.  That can be quite slow if it has to search a long distance.  You can bound the time required by specifying a non-@code{nil} value for @var{limit}, which says not to search before @var{limit}.  In this case, the match that is found must begin at or after @var{limit}.  Here's an example:"
msgstr "正規表現マッチングは前方だけに機能するので、ポイントで終わるマッチをポイントから後方へ検索するように実装された。長い距離を検索する必要がある場合には、これは極めて低速になり得る。非@code{nil}値を@var{limit}を指定してその前を検索しないよう告げることにより、検索に要する時間を制限できる。この場合には、マッチデータは@var{limit}かその後で始まらなければならない。以下は例:"

#. type: group
#: original_texis/searching.texi:2040
#, no-wrap
msgid ""
"(looking-back \"read \\\"\" 3)\n"
"     @result{} t\n"
"(looking-back \"read \\\"\" 4)\n"
"     @result{} nil\n"
msgstr ""
"(looking-back \"read \\\"\" 3)\n"
"     @result{} t\n"
"(looking-back \"read \\\"\" 4)\n"
"     @result{} nil\n"

#. type: defun
#: original_texis/searching.texi:2048
msgid "If @var{greedy} is non-@code{nil}, this function extends the match backwards as far as possible, stopping when a single additional previous character cannot be part of a match for @var{regexp}.  When the match is extended, its starting position is allowed to occur before @var{limit}."
msgstr "@var{greedy}が非@code{nil}なら、この関数は可能な限り後方へマッチを拡張して、前方の1文字が@var{regexp}がマッチの一部とならなければ停止する。マッチが拡張されたときには、マッチ開始位置が@var{limit}の前にあっても許される。"

#. type: defun
#: original_texis/searching.texi:2053
msgid "As a general recommendation, try to avoid using @code{looking-back} wherever possible, since it is slow.  For this reason, there are no plans to add a @code{looking-back-p} function."
msgstr "一般的に@code{looking-back}は低速なので、可能な限り使用を避けることを推奨する。この理由により@code{looking-back-p}の追加は計画されていない。"

#. type: defun
#: original_texis/searching.texi:2055
#, no-wrap
msgid "looking-at-p regexp"
msgstr "looking-at-p regexp"

#. type: defun
#: original_texis/searching.texi:2058
msgid "This predicate function works like @code{looking-at}, but without updating the match data."
msgstr "この述語関数は@code{looking-at}と同様に機能するがマッチデータを更新しない。"

#. type: defvar
#: original_texis/searching.texi:2060
#, no-wrap
msgid "search-spaces-regexp"
msgstr "search-spaces-regexp"

#. type: defvar
#: original_texis/searching.texi:2067
msgid "If this variable is non-@code{nil}, it should be a regular expression that says how to search for whitespace.  In that case, any group of spaces in a regular expression being searched for stands for use of this regular expression.  However, spaces inside of constructs such as @samp{[@dots{}]} and @samp{*}, @samp{+}, @samp{?} are not affected by @code{search-spaces-regexp}."
msgstr "この変数が非@code{nil}なら、それは空白文字を検索する方法を告げる正規表現であること。この場合には検索される正規表現内のすべてのスペース属は、この正規表現を使用することを意味する。しかし@samp{[@dots{}]}、@samp{*}@samp{+}、@samp{?}のような構文要素内のスペースは@code{search-spaces-regexp}の影響を受けない。"

#. type: defvar
#: original_texis/searching.texi:2071
msgid "Since this variable affects all regular expression search and match constructs, you should bind it temporarily for as small as possible a part of the code."
msgstr "この変数はすべての正規表現検索とマッチ構文要素に影響するので、コードの可能な限り狭い範囲にたいして一時的にバインドすること。"

#. type: section
#: original_texis/searching.texi:2074
#, no-wrap
msgid "POSIX Regular Expression Searching"
msgstr "POSIX Regular Expression Searching"

#. type: cindex
#: original_texis/searching.texi:2076
#, no-wrap
msgid "backtracking and POSIX regular expressions"
msgstr "backtracking and POSIX regular expressions"

#. type: Plain text
#: original_texis/searching.texi:2081
msgid "The usual regular expression functions do backtracking when necessary to handle the @samp{\\|} and repetition constructs, but they continue this only until they find @emph{some} match.  Then they succeed and report the first match found."
msgstr "通常の正規表現関数は、@samp{\\|}や繰り返しの構文要素を処理するために必要なときだけバックトラッキングを行いますが、@emph{何らか}のマッチが見つかるまでの間だけこれを継続します。そして成功した後に見つかった最初のマッチを報告します。"

#. type: Plain text
#: original_texis/searching.texi:2088
msgid "This section describes alternative search functions which perform the full backtracking specified by the POSIX standard for regular expression matching.  They continue backtracking until they have tried all possibilities and found all matches, so they can report the longest match, as required by POSIX@.  This is much slower, so use these functions only when you really need the longest match."
msgstr "このセクションでは正規表現にたいしてPOSIX標準で指定された完全なバックトラッキングを処理する他の検索関数を説明します。これらはPOSIXが要求する最長マッチを報告できるようにすべての可能なマッチを試みて、すべてのマッチが見つかるまでバックトラッキングを継続します。これは非常に低速なので、本当に最長マッチが必要なときだけこれらの関数を使用してください。"

#. type: Plain text
#: original_texis/searching.texi:2093
msgid "The POSIX search and match functions do not properly support the non-greedy repetition operators (@pxref{Regexp Special, non-greedy}).  This is because POSIX backtracking conflicts with the semantics of non-greedy repetition."
msgstr "POSIXの検索とマッチ関数は、非欲張りな繰り返し演算子(@ref{Regexp Special, non-greedy}を参照)を正しくサポートしません。これはPOSIXのバックトラッキングが非欲張りな繰り返しのセマンチックと競合するからです。"

#. type: deffn
#: original_texis/searching.texi:2094
#, no-wrap
msgid "Command posix-search-forward regexp &optional limit noerror count"
msgstr "Command posix-search-forward regexp &optional limit noerror count"

#. type: deffn
#: original_texis/searching.texi:2098
msgid "This is like @code{re-search-forward} except that it performs the full backtracking specified by the POSIX standard for regular expression matching."
msgstr "これは@code{re-search-forward}と似ているが、正規表現マッチングにたいしてPOSIX標準が指定する完全なバックトラッキングを行う点が異なる。"

#. type: deffn
#: original_texis/searching.texi:2100
#, no-wrap
msgid "Command posix-search-backward regexp &optional limit noerror count"
msgstr "Command posix-search-backward regexp &optional limit noerror count"

#. type: deffn
#: original_texis/searching.texi:2104
msgid "This is like @code{re-search-backward} except that it performs the full backtracking specified by the POSIX standard for regular expression matching."
msgstr "これは@code{re-search-backward}と似ているが、正規表現マッチングにたいしてPOSIX標準が指定する完全なバックトラッキングを行う点が異なる。"

#. type: defun
#: original_texis/searching.texi:2106
#, no-wrap
msgid "posix-looking-at regexp"
msgstr "posix-looking-at regexp"

#. type: defun
#: original_texis/searching.texi:2110
msgid "This is like @code{looking-at} except that it performs the full backtracking specified by the POSIX standard for regular expression matching."
msgstr "これは@code{looking-at}と似ているが、正規表現マッチングにたいしてPOSIX標準が指定する完全なバックトラッキングを行う点が異なる。"

#. type: defun
#: original_texis/searching.texi:2112
#, no-wrap
msgid "posix-string-match regexp string &optional start"
msgstr "posix-string-match regexp string &optional start"

#. type: defun
#: original_texis/searching.texi:2116
msgid "This is like @code{string-match} except that it performs the full backtracking specified by the POSIX standard for regular expression matching."
msgstr "これは@code{string-match}と似ているが、正規表現にたいしてPOSIX標準が指定する完全なバックトラッキングを行う点が異なる。"

#. type: section
#: original_texis/searching.texi:2119
#, no-wrap
msgid "The Match Data"
msgstr "The Match Data"

#. type: cindex
#: original_texis/searching.texi:2120
#, no-wrap
msgid "match data"
msgstr "match data"

#. type: Plain text
#: original_texis/searching.texi:2127
msgid "Emacs keeps track of the start and end positions of the segments of text found during a search; this is called the @dfn{match data}.  Thanks to the match data, you can search for a complex pattern, such as a date in a mail message, and then extract parts of the match under control of the pattern."
msgstr "Emacsは検索の間に見つかったテキスト片の開始と終了の位置を追跡します。これは@dfn{マッチデータ(match data)}と呼ばれます。このマッチデータのおかげで、メールメッセージ内のデータのような複雑なパターンを検索した後に、そのパターンの制御下でマッチ部分を抽出できるのです。"

#. type: Plain text
#: original_texis/searching.texi:2133
msgid "Because the match data normally describe the most recent search only, you must be careful not to do another search inadvertently between the search you wish to refer back to and the use of the match data.  If you can't avoid another intervening search, you must save and restore the match data around it, to prevent it from being overwritten."
msgstr "マッチデータには通常はもっとも最近の検索だけが記述されるので、後で参照したい検索とそのマッチデータの使用の間に誤って別の検索を行わないように注意しなければなりません。誤って別の検索を避けるのが不可能な場合には、マッチデータの上書きを防ぐために前後でマッチデータの保存とリストアを行わなければなりません。"

#. type: Plain text
#: original_texis/searching.texi:2139
msgid "Notice that all functions are allowed to overwrite the match data unless they're explicitly documented not to do so.  A consequence is that functions that are run implicitly in the background (@pxref{Timers}, and @ref{Idle Timers}) should likely save and restore the match data explicitly."
msgstr "上書きを行わないと明記されていない限り、すべての関数は上書きを許されていることに注意してください。結果としてバックグラウンド(@ref{Timers}と@ref{Idle Timers}を参照)で暗黙に実行される関数は、おそらく明示的にマッチデータの保存とリストアを行うべきでしょう。"

#. type: node
#: original_texis/searching.texi:2146 original_texis/searching.texi:2148
#, no-wrap
msgid "Replacing Match"
msgstr "Replacing Match"

#. type: menuentry
#: original_texis/searching.texi:2146
msgid "Replacing a substring that was matched."
msgstr "マッチされた部分文字列の置換。"

#. type: node
#: original_texis/searching.texi:2146 original_texis/searching.texi:2232
#, no-wrap
msgid "Simple Match Data"
msgstr "Simple Match Data"

#. type: menuentry
#: original_texis/searching.texi:2146
msgid "Accessing single items of match data, such as where a particular subexpression started."
msgstr "特定の部分式開始箇所のようなマッチデータの単一アイテムへのアクセス。"

#. type: node
#: original_texis/searching.texi:2146 original_texis/searching.texi:2378
#, no-wrap
msgid "Entire Match Data"
msgstr "Entire Match Data"

#. type: menuentry
#: original_texis/searching.texi:2146
msgid "Accessing the entire match data at once, as a list."
msgstr "リストとしてマッチデータ全体に一度にアクセスする。"

#. type: node
#: original_texis/searching.texi:2146 original_texis/searching.texi:2460
#, no-wrap
msgid "Saving Match Data"
msgstr "Saving Match Data"

#. type: menuentry
#: original_texis/searching.texi:2146
msgid "Saving and restoring the match data."
msgstr "マッチデータの保存とリストア。"

#. type: subsection
#: original_texis/searching.texi:2149
#, no-wrap
msgid "Replacing the Text that Matched"
msgstr "Replacing the Text that Matched"

#. type: cindex
#: original_texis/searching.texi:2150
#, no-wrap
msgid "replace matched text"
msgstr "replace matched text"

#. type: Plain text
#: original_texis/searching.texi:2154
msgid "This function replaces all or part of the text matched by the last search.  It works by means of the match data."
msgstr "以下の関数は、最後の検索でマッチされたテキストのすべて、または一部を置換します。これはマッチデータにより機能します。"

#. type: cindex
#: original_texis/searching.texi:2155
#, no-wrap
msgid "case in replacements"
msgstr "case in replacements"

#. type: defun
#: original_texis/searching.texi:2156
#, no-wrap
msgid "replace-match replacement &optional fixedcase literal string subexp"
msgstr "replace-match replacement &optional fixedcase literal string subexp"

#. type: defun
#: original_texis/searching.texi:2158
msgid "This function performs a replacement operation on a buffer or string."
msgstr "この関数はバッファーや文字列にたいして置換処理を行う。"

#. type: defun
#: original_texis/searching.texi:2165
msgid "If you did the last search in a buffer, you should omit the @var{string} argument or specify @code{nil} for it, and make sure that the current buffer is the one in which you performed the last search.  Then this function edits the buffer, replacing the matched text with @var{replacement}.  It leaves point at the end of the replacement text."
msgstr "あるバッファーで最後の検索を行った場合には、@var{string}引数を省略または@code{nil}を指定すること。また最後に検索を行ったバッファーがカレントバッファーであることを確認すること。その場合には、この関数はマッチしたテキストを@var{replacement}で置換することにより、そのバッファーを編集する。これは置換したテキスト終端にポイントを残す。"

#. type: defun
#: original_texis/searching.texi:2169
msgid "If you performed the last search on a string, pass the same string as @var{string}.  Then this function returns a new string, in which the matched text is replaced by @var{replacement}."
msgstr "文字列にたいして最後の検索を行った場合には、同じ文字列が@var{string}に渡される。その場合には、この関数はマッチしたテキストが@var{replacement}に置き換えられた新たなテキストをリターンする。"

#. type: defun
#: original_texis/searching.texi:2179
msgid "If @var{fixedcase} is non-@code{nil}, then @code{replace-match} uses the replacement text without case conversion; otherwise, it converts the replacement text depending upon the capitalization of the text to be replaced.  If the original text is all upper case, this converts the replacement text to upper case.  If all words of the original text are capitalized, this capitalizes all the words of the replacement text.  If all the words are one-letter and they are all upper case, they are treated as capitalized words rather than all-upper-case words."
msgstr "@var{fixedcase}が非@code{nil}なら@code{replace-match}は大文字小文字を変更せずに置換テキストを使用して、それ以外は置換されるテキストがcapitalize(先頭が大文字)されているかどうかに応じて、置換テキストを変換する。元のテキストがすべて大文字なら置換テキストを大文字に変換する。元のテキストの単語すべてがcapitalizeされていたら置換テキストのすべての単語をcapitalizeする。すべての単語が1文字かつ大文字なら、それらはすべて大文字の単語ではなくcapitalizeされた単語として扱われる。"

#. type: defun
#: original_texis/searching.texi:2185
msgid "If @var{literal} is non-@code{nil}, then @var{replacement} is inserted exactly as it is, the only alterations being case changes as needed.  If it is @code{nil} (the default), then the character @samp{\\} is treated specially.  If a @samp{\\} appears in @var{replacement}, then it must be part of one of the following sequences:"
msgstr "@var{literal}が非@code{nil}なら@var{replacement}はそのまま挿入されるが、必要に応じてcaseの変更だけが行われる。これが@code{nil}(デフォルト)なら文字@samp{\\}は特別に扱われる。@var{replacement}内に@samp{\\}が出現した場合には、それは以下のシーケンスのいずれかの一部でなければならない:"

#. type: samp{#1}
#: original_texis/searching.texi:2187
#, no-wrap
msgid "\\&"
msgstr "\\&"

#. type: cindex
#: original_texis/searching.texi:2188
#, no-wrap
msgid "@samp{&} in replacement"
msgstr "@samp{&} in replacement"

#. type: table
#: original_texis/searching.texi:2190
msgid "This stands for the entire text being replaced."
msgstr "これは置換されるテキスト全体を意味する。"

#. type: item
#: original_texis/searching.texi:2191
#, no-wrap
msgid "@samp{\\@var{n}}, where @var{n} is a digit"
msgstr "@samp{\\@var{n}} （@var{n}は数字)"

#. type: cindex
#: original_texis/searching.texi:2192
#, no-wrap
msgid "@samp{\\@var{n}} in replacement"
msgstr "@samp{\\@var{n}} in replacement"

#. type: table
#: original_texis/searching.texi:2197
msgid "This stands for the text that matched the @var{n}th subexpression in the original regexp.  Subexpressions are those expressions grouped inside @samp{\\(@dots{}\\)}.  If the @var{n}th subexpression never matched, an empty string is substituted."
msgstr "これは元のregexpの@var{n}番目の部分式にマッチするテキストを意味する。この部分式とは@samp{\\(@dots{}\\)}の内部にグループかされた式のこと。@var{n}番目のマッチがなければ空文字列が代用される。"

#. type: samp{#1}
#: original_texis/searching.texi:2198
#, no-wrap
msgid "\\\\"
msgstr "\\\\"

#. type: cindex
#: original_texis/searching.texi:2199
#, no-wrap
msgid "@samp{\\} in replacement"
msgstr "@samp{\\} in replacement"

#. type: table
#: original_texis/searching.texi:2201
msgid "This stands for a single @samp{\\} in the replacement text."
msgstr "これは置換テキスト内で単一の@samp{\\}を意味する。"

#. type: samp{#1}
#: original_texis/searching.texi:2202
#, no-wrap
msgid "\\?"
msgstr "\\?"

#. type: table
#: original_texis/searching.texi:2206
msgid "This stands for itself (for compatibility with @code{replace-regexp} and related commands; @pxref{Regexp Replace,,, emacs, The GNU Emacs Manual})."
msgstr "これはそれ自身を意味する(@code{replace-regexp}と関連するコマンドの互換用。@ref{Regexp Replace,,, emacs, The GNU Emacs Manual}を参照)。"

#. type: defun
#: original_texis/searching.texi:2210
msgid "Any other character following @samp{\\} signals an error."
msgstr "これら以外の@samp{\\}に続く文字はエラーをシグナルする。"

#. type: defun
#: original_texis/searching.texi:2214
msgid "The substitutions performed by @samp{\\&} and @samp{\\@var{n}} occur after case conversion, if any.  Therefore, the strings they substitute are never case-converted."
msgstr "@samp{\\&}や@samp{\\@var{n}}により行われる代替えは、もしあればcase変換の後に発生する。したがって代替えする文字列は決してcase変換されない。"

#. type: defun
#: original_texis/searching.texi:2220
msgid "If @var{subexp} is non-@code{nil}, that says to replace just subexpression number @var{subexp} of the regexp that was matched, not the entire match.  For example, after matching @samp{foo \\(ba*r\\)}, calling @code{replace-match} with 1 as @var{subexp} means to replace just the text that matched @samp{\\(ba*r\\)}."
msgstr "@var{subexp}が非@code{nil}なら、それは全体のマッチではなくマッチされたregexpの部分式番号@var{subexp}だけを置換することを指定する。たとえば@samp{foo \\(ba*r\\)}のマッチング後に@code{replace-match}を呼び出すと、@var{subexp}が1なら@samp{\\(ba*r\\)}にマッチしたテキストだけを置換することを意味する。"

#. type: defun
#: original_texis/searching.texi:2222
#, no-wrap
msgid "match-substitute-replacement replacement &optional fixedcase literal string subexp"
msgstr "match-substitute-replacement replacement &optional fixedcase literal string subexp"

#. type: defun
#: original_texis/searching.texi:2230
msgid "This function returns the text that would be inserted into the buffer by @code{replace-match}, but without modifying the buffer.  It is useful if you want to present the user with actual replacement result, with constructs like @samp{\\@var{n}} or @samp{\\&} substituted with matched groups.  Arguments @var{replacement} and optional @var{fixedcase}, @var{literal}, @var{string} and @var{subexp} have the same meaning as for @code{replace-match}."
msgstr "この関数は@code{replace-match}によりバッファーに挿入されるであろうテキストをリターンするがバッファーを変更しない。これは@samp{\\@var{n}}や@samp{\\&}のような構文要素をマッチしたグループで置き換えた実際の結果をユーザーに示したいとき有用。引数@var{replacement}、およびオプションの@var{fixedcase}、@var{literal}、@var{string}、@var{subexp}は@code{replace-match}のときと同じ意味をもつ。"

#. type: subsection
#: original_texis/searching.texi:2233
#, no-wrap
msgid "Simple Match Data Access"
msgstr "Simple Match Data Access"

#. type: Plain text
#: original_texis/searching.texi:2237
msgid "This section explains how to use the match data to find out what was matched by the last search or match operation, if it succeeded."
msgstr "このセクションでは最後の検索やマッチング操作で、それが成功した場合に何がマッチされたのかを調べるために、マッチデータを使用する方法について説明します。"

#. type: Plain text
#: original_texis/searching.texi:2243
msgid "You can ask about the entire matching text, or about a particular parenthetical subexpression of a regular expression.  The @var{count} argument in the functions below specifies which.  If @var{count} is zero, you are asking about the entire match.  If @var{count} is positive, it specifies which subexpression you want."
msgstr "マッチしたテキスト全体または正規表現のカッコで括られた特定の部分式にたいして問い合わせることができます。以下の関数では、@var{count}によりどの部分式かを指定できます。@var{count}が0ならマッチ全体、@var{count}が正なら望む部分式を指定します。"

#. type: Plain text
#: original_texis/searching.texi:2251
msgid "Recall that the subexpressions of a regular expression are those expressions grouped with escaped parentheses, @samp{\\(@dots{}\\)}.  The @var{count}th subexpression is found by counting occurrences of @samp{\\(} from the beginning of the whole regular expression.  The first subexpression is numbered 1, the second 2, and so on.  Only regular expressions can have subexpressions---after a simple string search, the only information available is about the entire match."
msgstr "正規表現での部分式とは、エスケープされたカッコ@samp{\\(@dots{}\\)}でグループ化された表現だったことを思い出してください。@var{count}番目の部分式は正規表現全体の先頭から@samp{\\(}を数えることで見つけられます。最初の部分式が1、2つ目が2、...となります。正規表現だけが部分式をもつことができ、単純な文字列検索の後で利用できるのはマッチ全体の情報だけです。"

#. type: Plain text
#: original_texis/searching.texi:2259
msgid "Every successful search sets the match data.  Therefore, you should query the match data immediately after searching, before calling any other function that might perform another search.  Alternatively, you may save and restore the match data (@pxref{Saving Match Data}) around the call to functions that could perform another search.  Or use the functions that explicitly do not modify the match data; e.g., @code{string-match-p}."
msgstr "成功したすべての検索はマッチデータをセットします。したがって検索後は別の検索を行うかもしれない関数を呼び出す前に、検索の直後にマッチデータを問い合わせるべきです。別の検索を呼び出すかもしれない関数の前後で、かわりにマッチデータの保存とリストアすることもできます(@ref{Saving Match Data}を参照)。または@code{string-match-p}のようなマッチデータを変更しないと明示されている関数を使用してください。"

#. type: Plain text
#: original_texis/searching.texi:2266
msgid "A search which fails may or may not alter the match data.  In the current implementation, it does not, but we may change it in the future.  Don't try to rely on the value of the match data after a failing search."
msgstr "検索が成功しようと失敗しようとマッチデータは変更されます。現在はこのように実装されていますが、これは将来変更されるかもしれません。失敗した後のマッチデータを信用しないでください。"

#. type: defun
#: original_texis/searching.texi:2267
#, no-wrap
msgid "match-string count &optional in-string"
msgstr "match-string count &optional in-string"

#. type: defun
#: original_texis/searching.texi:2272
msgid "This function returns, as a string, the text matched in the last search or match operation.  It returns the entire text if @var{count} is zero, or just the portion corresponding to the @var{count}th parenthetical subexpression, if @var{count} is positive."
msgstr "この関数は最後の検索やマッチ処理でマッチしたテキストを文字列としてリターンする。これは@var{count}が0ならテキスト全体、@var{count}が正なら@var{count}番目のカッコで括られた部分式に対応する部分だけをリターンする。"

#. type: defun
#: original_texis/searching.texi:2280
msgid "If the last such operation was done against a string with @code{string-match}, then you should pass the same string as the argument @var{in-string}.  After a buffer search or match, you should omit @var{in-string} or pass @code{nil} for it; but you should make sure that the current buffer when you call @code{match-string} is the one in which you did the searching or matching.  Failure to follow this advice will lead to incorrect results."
msgstr "そのような最後の処理が文字列にたいする@code{string-match}呼び出しなら、引数@var{in-string}には同じ文字列を渡すこと。バッファーの検索やマッチの後は、@var{in-string}を省略するか@code{nil}を渡すこと。しかし最後に検索やマッチを行ったバッファーが、@code{match-string}呼び出し時にカレントバッファーであることを確認すること。このアドバイスにしたがわなければ誤った結果となるだろう。"

#. type: defun
#: original_texis/searching.texi:2284
msgid "The value is @code{nil} if @var{count} is out of range, or for a subexpression inside a @samp{\\|} alternative that wasn't used or a repetition that repeated zero times."
msgstr "@var{count}が範囲外、@samp{\\|}選択肢内部の部分式が使用されない、または0回の繰り返しなら値は@code{nil}。"

#. type: defun
#: original_texis/searching.texi:2286
#, no-wrap
msgid "match-string-no-properties count &optional in-string"
msgstr "match-string-no-properties count &optional in-string"

#. type: defun
#: original_texis/searching.texi:2289
msgid "This function is like @code{match-string} except that the result has no text properties."
msgstr "この関数は@code{match-string}と似ているが結果がテキストプロパティをもたない点が異なる。"

#. type: defun
#: original_texis/searching.texi:2291
#, no-wrap
msgid "match-beginning count"
msgstr "match-beginning count"

#. type: defun
#: original_texis/searching.texi:2295
msgid "If the last regular expression search found a match, this function returns the position of the start of the matching text or of a subexpression of it."
msgstr "最後の正規表現検索がマッチを見つけたら、この関数はマッチしたテキストか部分式の開始位置をリターンする。"

#. type: defun
#: original_texis/searching.texi:2300
msgid "If @var{count} is zero, then the value is the position of the start of the entire match.  Otherwise, @var{count} specifies a subexpression in the regular expression, and the value of the function is the starting position of the match for that subexpression."
msgstr "@var{count}が0なら値はマッチ全体の開始位置。それ以外なら@var{count}は正規表現内の部分式を指定するので、この関数の値はその部分式にたいするマッチの開始位置。"

#. type: defun
#: original_texis/searching.texi:2303
msgid "The value is @code{nil} for a subexpression inside a @samp{\\|} alternative that wasn't used or a repetition that repeated zero times."
msgstr "使用されない、あるいは0回の繰り返しであるような@samp{\\|}選択肢内部の部分式にたいしての値は@code{nil}。"

#. type: defun
#: original_texis/searching.texi:2305
#, no-wrap
msgid "match-end count"
msgstr "match-end count"

#. type: defun
#: original_texis/searching.texi:2309
msgid "This function is like @code{match-beginning} except that it returns the position of the end of the match, rather than the position of the beginning."
msgstr "この関数は@code{match-beginning}と似ているがマッチの開始ではなく終了位置である点が異なる。"

#. type: Plain text
#: original_texis/searching.texi:2313
msgid "Here is an example of using the match data, with a comment showing the positions within the text:"
msgstr "以下はマッチデータを使用する例です。コメントの数字はテキスト内での位置を示しています:"

#. type: group
#: original_texis/searching.texi:2320
#, no-wrap
msgid ""
"(string-match \"\\\\(qu\\\\)\\\\(ick\\\\)\"\n"
"              \"The quick fox jumped quickly.\")\n"
"              ;0123456789\n"
"     @result{} 4\n"
msgstr ""
"(string-match \"\\\\(qu\\\\)\\\\(ick\\\\)\"\n"
"              \"The quick fox jumped quickly.\")\n"
"              ;0123456789\n"
"     @result{} 4\n"

#. type: group
#: original_texis/searching.texi:2329
#, no-wrap
msgid ""
"(match-string 0 \"The quick fox jumped quickly.\")\n"
"     @result{} \"quick\"\n"
"(match-string 1 \"The quick fox jumped quickly.\")\n"
"     @result{} \"qu\"\n"
"(match-string 2 \"The quick fox jumped quickly.\")\n"
"     @result{} \"ick\"\n"
msgstr ""
"(match-string 0 \"The quick fox jumped quickly.\")\n"
"     @result{} \"quick\"\n"
"(match-string 1 \"The quick fox jumped quickly.\")\n"
"     @result{} \"qu\"\n"
"(match-string 2 \"The quick fox jumped quickly.\")\n"
"     @result{} \"ick\"\n"

#. type: group
#: original_texis/searching.texi:2334
#, no-wrap
msgid ""
"(match-beginning 1)       ; @r{The beginning of the match}\n"
"     @result{} 4                 ;   @r{with @samp{qu} is at index 4.}\n"
msgstr ""
"(match-beginning 1)       ; @r{@samp{qu}にたいするマッチ先頭の}\n"
"     @result{} 4                 ;   @r{インデックスは4}\n"

#. type: group
#: original_texis/searching.texi:2339
#, no-wrap
msgid ""
"(match-beginning 2)       ; @r{The beginning of the match}\n"
"     @result{} 6                 ;   @r{with @samp{ick} is at index 6.}\n"
msgstr ""
"(match-beginning 2)       ; @r{@samp{ick}にたいするマッチ先頭の}\n"
"     @result{} 6                 ;   @r{インデックスは6}\n"

#. type: group
#: original_texis/searching.texi:2344
#, no-wrap
msgid ""
"(match-end 1)             ; @r{The end of the match}\n"
"     @result{} 6                 ;   @r{with @samp{qu} is at index 6.}\n"
"\n"
msgstr ""
"(match-end 1)             ; @r{@samp{qu}にたいするマッチ終端の}\n"
"     @result{} 6                 ;   @r{インデックスは6}\n"
"\n"

#. type: group
#: original_texis/searching.texi:2347
#, no-wrap
msgid ""
"(match-end 2)             ; @r{The end of the match}\n"
"     @result{} 9                 ;   @r{with @samp{ick} is at index 9.}\n"
msgstr ""
"(match-end 2)             ; @r{@samp{ick}にたいするマッチ終端の}\n"
"     @result{} 9                 ;   @r{インデックスは9}\n"

#. type: Plain text
#: original_texis/searching.texi:2355
msgid "Here is another example.  Point is initially located at the beginning of the line.  Searching moves point to between the space and the word @samp{in}.  The beginning of the entire match is at the 9th character of the buffer (@samp{T}), and the beginning of the match for the first subexpression is at the 13th character (@samp{c})."
msgstr "別の例を以下に示します。ポイントは最初は行の先頭にあります。検索の後はポイントはスペースと単語@samp{in}の間にあります。マッチ全体の先頭はバッファーの9つ目の文字@samp{T}、1つ目の部分式にたいするマッチの先頭は13番目の文字@samp{c}です。"

#. type: group
#: original_texis/searching.texi:2363
#, no-wrap
msgid ""
"(list\n"
"  (re-search-forward \"The \\\\(cat \\\\)\")\n"
"  (match-beginning 0)\n"
"  (match-beginning 1))\n"
"    @result{} (17 9 13)\n"
msgstr ""
"(list\n"
"  (re-search-forward \"The \\\\(cat \\\\)\")\n"
"  (match-beginning 0)\n"
"  (match-beginning 1))\n"
"    @result{} (17 9 13)\n"

#. type: group
#: original_texis/searching.texi:2371
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"I read \"The cat @point{}in the hat comes back\" twice.\n"
"        ^   ^\n"
"        9  13\n"
"---------- Buffer: foo ----------\n"
msgstr ""
"---------- Buffer: foo ----------\n"
"I read \"The cat @point{}in the hat comes back\" twice.\n"
"        ^   ^\n"
"        9  13\n"
"---------- Buffer: foo ----------\n"

#. type: Plain text
#: original_texis/searching.texi:2377
msgid "(In this case, the index returned is a buffer position; the first character of the buffer counts as 1.)"
msgstr "(この場合にはリターンされるインデックスはバッファー位置であり、バッファーの1つ目の文字を1と数える。)"

#. type: subsection
#: original_texis/searching.texi:2379
#, no-wrap
msgid "Accessing the Entire Match Data"
msgstr "Accessing the Entire Match Data"

#. type: Plain text
#: original_texis/searching.texi:2383
msgid "The functions @code{match-data} and @code{set-match-data} read or write the entire match data, all at once."
msgstr "関数@code{match-data}と@code{set-match-data}は、マッチデータ全体にたいして一度に読み取り、または書き込みを行います。"

#. type: defun
#: original_texis/searching.texi:2384
#, no-wrap
msgid "match-data &optional integers reuse reseat"
msgstr "match-data &optional integers reuse reseat"

#. type: defun
#: original_texis/searching.texi:2392
msgid "This function returns a list of positions (markers or integers) that record all the information on the text that the last search matched.  Element zero is the position of the beginning of the match for the whole expression; element one is the position of the end of the match for the expression.  The next two elements are the positions of the beginning and end of the match for the first subexpression, and so on.  In general, element"
msgstr "この関数は最後の検索によりマッチしたテキストのすべての情報を記録する位置(マーカーか整数)をリターンする。要素0は正規表現全体にたいするマッチの先頭の位置。要素1はその正規表現にたいするマッチの終端の位置。次の2つの要素は1つ目の部分式にたいするマッチの先頭と終了、...となる。一般的に要素番号"

#. type: ifnottex
#: original_texis/searching.texi:2394
msgid "number 2@var{n}"
msgstr "2@var{n}"

#. type: tex
#: original_texis/searching.texi:2397
#, no-wrap
msgid "number {\\mathsurround=0pt $2n$}\n"
msgstr "{\\mathsurround=0pt $2n$}\n"

#. type: defun
#: original_texis/searching.texi:2400
msgid "corresponds to @code{(match-beginning @var{n})}; and element"
msgstr "は@code{(match-beginning @var{n})}、要素番号"

#. type: ifnottex
#: original_texis/searching.texi:2402
msgid "number 2@var{n} + 1"
msgstr "2@var{n} + 1"

#. type: tex
#: original_texis/searching.texi:2405
#, no-wrap
msgid "number {\\mathsurround=0pt $2n+1$}\n"
msgstr "{\\mathsurround=0pt $2n+1$}\n"

#. type: defun
#: original_texis/searching.texi:2407
msgid "corresponds to @code{(match-end @var{n})}."
msgstr "は@code{(match-end @var{n})}に対応する。"

#. type: defun
#: original_texis/searching.texi:2415
msgid "Normally all the elements are markers or @code{nil}, but if @var{integers} is non-@code{nil}, that means to use integers instead of markers.  (In that case, the buffer itself is appended as an additional element at the end of the list, to facilitate complete restoration of the match data.)  If the last match was done on a string with @code{string-match}, then integers are always used, since markers can't point into a string."
msgstr "すべての要素は通常はマーカーか@code{nil}だが、もし@var{integers}が非@code{nil}ならマーカーのかわりに整数を使用することを意味する(この場合にはマッチデータの完全なリストアを容易にするために、リストの最後の要素としてバッファー自身が追加される)。最後の検索が@code{string-match}により文字列にたいして行われた場合には、マーカーは文字列の内部をポイントできないので常に整数が使用される。"

#. type: defun
#: original_texis/searching.texi:2424
msgid "If @var{reuse} is non-@code{nil}, it should be a list.  In that case, @code{match-data} stores the match data in @var{reuse}.  That is, @var{reuse} is destructively modified.  @var{reuse} does not need to have the right length.  If it is not long enough to contain the match data, it is extended.  If it is too long, the length of @var{reuse} stays the same, but the elements that were not used are set to @code{nil}.  The purpose of this feature is to reduce the need for garbage collection."
msgstr "@var{reuse}が非@code{nil}なら、それはリストであること。この場合には、@code{match-data}はマッチデータを@var{reuse}内に格納する。つまり@var{reuse}は破壊的に変更される。@var{reuse}が正しい長さである必要はない。特定のマッチデータにたいして長さが十分でなければリストは拡張される。@var{reuse}が長過ぎる場合には、長さはそのままで使用しない要素に@code{nil}がセットされる。この機能にはガベージコレクションの必要頻度を減らす目的がある。"

#. type: defun
#: original_texis/searching.texi:2427
msgid "If @var{reseat} is non-@code{nil}, all markers on the @var{reuse} list are reseated to point to nowhere."
msgstr "@var{reseat}が非@code{nil}なら、@var{reuse}リスト内のすべてのマーカーは存在しない場所を指すよう再設定される。"

#. type: defun
#: original_texis/searching.texi:2431
msgid "As always, there must be no possibility of intervening searches between the call to a search function and the call to @code{match-data} that is intended to access the match data for that search."
msgstr "他の場合と同じように検索関数とその検索のマッチデータへのアクセスを意図する@code{match-data}呼び出しの間に介入するような検索があってはならない。"

#. type: group
#: original_texis/searching.texi:2439
#, no-wrap
msgid ""
"(match-data)\n"
"     @result{}  (#<marker at 9 in foo>\n"
"          #<marker at 17 in foo>\n"
"          #<marker at 13 in foo>\n"
"          #<marker at 17 in foo>)\n"
msgstr ""
"(match-data)\n"
"     @result{}  (#<marker at 9 in foo>\n"
"          #<marker at 17 in foo>\n"
"          #<marker at 13 in foo>\n"
"          #<marker at 17 in foo>)\n"

#. type: defun
#: original_texis/searching.texi:2443
#, no-wrap
msgid "set-match-data match-list &optional reseat"
msgstr "set-match-data match-list &optional reseat"

#. type: defun
#: original_texis/searching.texi:2448
msgid "This function sets the match data from the elements of @var{match-list}, which should be a list that was the value of a previous call to @code{match-data}.  (More precisely, anything that has the same format will work.)"
msgstr "この関数は@var{match-list}の要素からマッチデータをセットする。@var{match-list}は前の@code{match-data}呼び出しの値であるようなリストであること(正確には同じフォーマットなら他のものでも機能するだろう)。"

#. type: defun
#: original_texis/searching.texi:2451
msgid "If @var{match-list} refers to a buffer that doesn't exist, you don't get an error; that sets the match data in a meaningless but harmless way."
msgstr "@var{match-list}が存在しないバッファーを参照する場合でもエラーとはならない。これは無意味だが害のない方法でマッチデータをセットする。"

#. type: defun
#: original_texis/searching.texi:2454
msgid "If @var{reseat} is non-@code{nil}, all markers on the @var{match-list} list are reseated to point to nowhere."
msgstr "@var{reseat}が非@code{nil}なら、リスト@var{match-list}内のすべてのマーカーは存在しない場所を指すよう再設定される。"

#. type: findex
#: original_texis/searching.texi:2456
#, no-wrap
msgid "store-match-data"
msgstr "store-match-data"

#. type: defun
#: original_texis/searching.texi:2458
msgid "@code{store-match-data} is a semi-obsolete alias for @code{set-match-data}."
msgstr "@code{store-match-data}は@code{set-match-data}の半ば時代遅れなエイリアス。"

#. type: subsection
#: original_texis/searching.texi:2461
#, no-wrap
msgid "Saving and Restoring the Match Data"
msgstr "Saving and Restoring the Match Data"

#. type: Plain text
#: original_texis/searching.texi:2467
msgid "When you call a function that may search, you may need to save and restore the match data around that call, if you want to preserve the match data from an earlier search for later use.  Here is an example that shows the problem that arises if you fail to save the match data:"
msgstr "以前に行った検索にたいするマッチデータを後で使用するために保護する必要があるなら、検索を行うかもしれない関数の呼び出し時に呼び出しの前後でマッチデータの保存とリストアを行う必要があるでしょう。以下はマッチデータ保存に失敗した場合に発生する問題を示す例です:"

#. type: group
#: original_texis/searching.texi:2475
#, no-wrap
msgid ""
"(re-search-forward \"The \\\\(cat \\\\)\")\n"
"     @result{} 48\n"
"(foo)                   ; @r{@code{foo} does more searching.}\n"
"(match-end 0)\n"
"     @result{} 61              ; @r{Unexpected result---not 48!}\n"
msgstr ""
"(re-search-forward \"The \\\\(cat \\\\)\")\n"
"     @result{} 48\n"
"(foo)                   ; @r{@code{foo}が他の検索を行うと}\n"
"(match-end 0)\n"
"     @result{} 61              ; @r{結果は期待する48と異なる!}\n"

#. type: Plain text
#: original_texis/searching.texi:2479
msgid "You can save and restore the match data with @code{save-match-data}:"
msgstr "@code{save-match-data}でマッチデータの保存とリストアができます:"

#. type: defmac
#: original_texis/searching.texi:2480
#, no-wrap
msgid "save-match-data body@dots{}"
msgstr "save-match-data body@dots{}"

#. type: defmac
#: original_texis/searching.texi:2484
msgid "This macro executes @var{body}, saving and restoring the match data around it.  The return value is the value of the last form in @var{body}."
msgstr "このマクロは@var{body}を実行して、その前後のマッチデータの保存とリストアを行う。リターン値は@var{body}内の最後のフォームの値。"

#. type: Plain text
#: original_texis/searching.texi:2489
msgid "You could use @code{set-match-data} together with @code{match-data} to imitate the effect of the special form @code{save-match-data}.  Here is how:"
msgstr "@code{set-match-data}と@code{match-data}を一緒に使用して、@code{save-match-data}の効果を模倣することができます。以下はその方法です:"

#. type: group
#: original_texis/searching.texi:2496
#, no-wrap
msgid ""
"(let ((data (match-data)))\n"
"  (unwind-protect\n"
"      @dots{}   ; @r{Ok to change the original match data.}\n"
"    (set-match-data data)))\n"
msgstr ""
"(let ((data (match-data)))\n"
"  (unwind-protect\n"
"      @dots{}   ; @r{元のマッチデータを変更してもOK}\n"
"    (set-match-data data)))\n"

#. type: Plain text
#: original_texis/searching.texi:2502
msgid "Emacs automatically saves and restores the match data when it runs process filter functions (@pxref{Filter Functions}) and process sentinels (@pxref{Sentinels})."
msgstr "プロセスフィルター関数(@ref{Filter Functions}を参照)、およびプロセスセンチネル(@ref{Sentinels}を参照)の実行時には、Emacsが自動的にマッチデータの保存とリストアを行います。"

#. type: group
#: original_texis/searching.texi:2515
#, no-wrap
msgid ""
"(defun restore-match-data (data)\n"
"  \"Restore the match data DATA unless the buffer is missing.\"\n"
"  (catch 'foo\n"
"    (let ((d data))\n"
msgstr ""
"(defun restore-match-data (data)\n"
"  \"Restore the match data DATA unless the buffer is missing.\"\n"
"  (catch 'foo\n"
"    (let ((d data))\n"

#. type: smallexample
#: original_texis/searching.texi:2519
#, no-wrap
msgid ""
"      (while d\n"
"        (and (car d)\n"
"             (null (marker-buffer (car d)))\n"
msgstr ""
"      (while d\n"
"        (and (car d)\n"
"             (null (marker-buffer (car d)))\n"

#. type: group
#: original_texis/searching.texi:2524
#, no-wrap
msgid ""
"             ;; @file{match-data} @r{buffer is deleted.}\n"
"             (throw 'foo nil))\n"
"        (setq d (cdr d)))\n"
"      (set-match-data data))))\n"
msgstr ""
"             ;; @file{match-data} @r{buffer is deleted.}\n"
"             (throw 'foo nil))\n"
"        (setq d (cdr d)))\n"
"      (set-match-data data))))\n"

#. type: cindex
#: original_texis/searching.texi:2530
#, no-wrap
msgid "replacement after search"
msgstr "replacement after search"

#. type: cindex
#: original_texis/searching.texi:2531
#, no-wrap
msgid "searching and replacing"
msgstr "searching and replacing"

#. type: Plain text
#: original_texis/searching.texi:2536
msgid "If you want to find all matches for a regexp in part of the buffer, and replace them, the best way is to write an explicit loop using @code{re-search-forward} and @code{replace-match}, like this:"
msgstr "バッファーのある部分でregexpにたいするすべてのマッチを見つけてそれらを置換したい場合には、以下のように@code{re-search-forward}と@code{replace-match}を使用して明示的なループを記述するのが最良の方法です:"

#. type: example
#: original_texis/searching.texi:2540
#, no-wrap
msgid ""
"(while (re-search-forward \"foo[ \\t]+bar\" nil t)\n"
"  (replace-match \"foobar\"))\n"
msgstr ""
"(while (re-search-forward \"foo[ \\t]+bar\" nil t)\n"
"  (replace-match \"foobar\"))\n"

#. type: Plain text
#: original_texis/searching.texi:2545
msgid "@xref{Replacing Match,, Replacing the Text that Matched}, for a description of @code{replace-match}."
msgstr "@code{replace-match}の説明は@ref{Replacing Match,, Replacing the Text that Matched}を参照してください。"

#. type: Plain text
#: original_texis/searching.texi:2549
msgid "However, replacing matches in a string is more complex, especially if you want to do it efficiently.  So Emacs provides a function to do this."
msgstr "しかし文字列内のマッチの置換、特に置換を効果的に行いたい場合には、より複雑になります。そのためにEmacsはこれを行うための関数を提供します。"

#. type: defun
#: original_texis/searching.texi:2550
#, no-wrap
msgid "replace-regexp-in-string regexp rep string &optional fixedcase literal subexp start"
msgstr "replace-regexp-in-string regexp rep string &optional fixedcase literal subexp start"

#. type: defun
#: original_texis/searching.texi:2558
#, fuzzy
#| msgid "This function copies @var{string} and searches it for matches for @var{regexp}, and replaces them with @var{rep}.  It returns the modified copy.  If @var{start} is non-@code{nil}, the search for matches starts at that index in @var{string}, so matches starting before that index are not changed."
msgid "This function copies @var{string} and searches it for matches for @var{regexp}, and replaces them with @var{rep}.  It returns the modified copy.  If @var{start} is non-@code{nil}, the search for matches starts at that index in @var{string}, and the returned value does not include the first @var{start} characters of @var{string}.  To get the whole transformed string, concatenate the first @var{start} characters of @var{string} with the return value."
msgstr "この関数は@var{string}をコピーして@var{regexp}にたいするマッチを検索、それらを@var{rep}に置き換える。これは変更されたコピーをリターンする。@var{start}が非@code{nil}ならマッチにたいする検索は@var{string}内のそのインデックスから開始されて、そのインデックスより前で始まるマッチは変更されない。"

#. type: defun
#: original_texis/searching.texi:2562
msgid "This function uses @code{replace-match} to do the replacement, and it passes the optional arguments @var{fixedcase}, @var{literal} and @var{subexp} along to @code{replace-match}."
msgstr "この関数は置換を行うためにオプション引数@var{fixedcase}、@var{literal}、@var{subexp}を渡して@code{replace-match}を使用する。"

#. type: defun
#: original_texis/searching.texi:2569
msgid "Instead of a string, @var{rep} can be a function.  In that case, @code{replace-regexp-in-string} calls @var{rep} for each match, passing the text of the match as its sole argument.  It collects the value @var{rep} returns and passes that to @code{replace-match} as the replacement string.  The match data at this point are the result of matching @var{regexp} against a substring of @var{string}."
msgstr "@var{rep}は文字列のかわりに関数でもよい。この場合には@code{replace-regexp-in-string}はそれぞれのマッチにたいして、そのテキストを単一の引数として@var{rep}を呼び出す。これは@var{rep}がリターンする値を収集して、それを置換文字列として@code{replace-match}に渡す。この時点でのマッチデータは@var{string}の部分文字列にたいする@var{regexp}のマッチ結果。"

#. type: Plain text
#: original_texis/searching.texi:2573
msgid "If you want to write a command along the lines of @code{query-replace}, you can use @code{perform-replace} to do the work."
msgstr "@code{query-replace}の行に関するコマンドを記述したい場合には、@code{perform-replace}を使用してこれを行うことができます。"

#. type: defun
#: original_texis/searching.texi:2574
#, no-wrap
msgid "perform-replace from-string replacements query-flag regexp-flag delimited-flag &optional repeat-count map start end backward region-noncontiguous-p"
msgstr "perform-replace from-string replacements query-flag regexp-flag delimited-flag &optional repeat-count map start end backward region-noncontiguous-p"

#. type: defun
#: original_texis/searching.texi:2582
msgid "This function is the guts of @code{query-replace} and related commands.  It searches for occurrences of @var{from-string} in the text between positions @var{start} and @var{end} and replaces some or all of them.  If @var{start} is @code{nil} (or omitted), point is used instead, and the end of the buffer's accessible portion is used for @var{end}.  (If the optional argument @var{backward} is non-@code{nil}, the search starts at @var{end} and goes backward.)"
msgstr "これは@code{query-replace}および関連するコマンドの根幹となる関数である。これは位置@var{start}と@var{end}の間にあるテキスト内に出現する@var{from-string}の一部またはすべてを置換する。@var{start}が@code{nil} (または省略)ならかわりにポイントを、@var{end}にはそのバッファーのアクセス可能範囲の終端が使用される(オピション引数@var{backward}が非@code{nil}なら検索は@var{end}から後方に開始される)。"

#. type: defun
#: original_texis/searching.texi:2585
msgid "If @var{query-flag} is @code{nil}, it replaces all occurrences; otherwise, it asks the user what to do about each one."
msgstr "@var{query-flag}が@code{nil}ならすべてのマッチを置換する。それ以外なら、それぞれにたいしてユーザーにたいして何をすべきか問い合わせる。"

#. type: defun
#: original_texis/searching.texi:2590
msgid "If @var{regexp-flag} is non-@code{nil}, then @var{from-string} is considered a regular expression; otherwise, it must match literally.  If @var{delimited-flag} is non-@code{nil}, then only replacements surrounded by word boundaries are considered."
msgstr "@var{regexp-flag}が非@code{nil}なら@var{from-string}は正規表現、それ以外はリテラルとしてマッチしなければならない。@var{delimited-flag}が非@code{nil}なら単語境界に囲まれた置換だけが考慮される。"

#. type: defun
#: original_texis/searching.texi:2594
msgid "The argument @var{replacements} specifies what to replace occurrences with.  If it is a string, that string is used.  It can also be a list of strings, to be used in cyclic order."
msgstr "引数@var{replacements}はマッチを何で置き換えるかを指定する。文字列ならその文字列を使用する。サイクル順に使用される文字列リストでもよい。"

#. type: defun
#: original_texis/searching.texi:2599
msgid "If @var{replacements} is a cons cell, @w{@code{(@var{function} . @var{data})}}, this means to call @var{function} after each match to get the replacement text.  This function is called with two arguments: @var{data}, and the number of replacements already made."
msgstr "@var{replacements}がコンスセル@w{@code{(@var{function} . @var{data})}}なら、置換テキストを取得するためにそれぞれのマッチ後に@var{function}を呼び出すことを意味する。この関数は@var{data}とすでに置換された個数という、2つの引数で呼び出される。"

#. type: defun
#: original_texis/searching.texi:2603
msgid "If @var{repeat-count} is non-@code{nil}, it should be an integer.  Then it specifies how many times to use each of the strings in the @var{replacements} list before advancing cyclically to the next one."
msgstr "@var{repeat-count}が非@code{nil}なら、それは整数であること。その場合にはサイクルを次に進める前に、@var{replacements}リスト内の各文字列を何度使用するかを指定する。"

#. type: defun
#: original_texis/searching.texi:2607
msgid "If @var{from-string} contains upper-case letters, then @code{perform-replace} binds @code{case-fold-search} to @code{nil}, and it uses the @var{replacements} without altering their case."
msgstr "@var{from-string}が大文字アルファベットを含む場合には、@code{perform-replace}は@code{case-fold-search}を@code{nil}にバインドして大文字小文字を変換せずに@var{replacements}を使用する。"

#. type: defun
#: original_texis/searching.texi:2612
msgid "Normally, the keymap @code{query-replace-map} defines the possible user responses for queries.  The argument @var{map}, if non-@code{nil}, specifies a keymap to use instead of @code{query-replace-map}."
msgstr "キーマップ@code{query-replace-map}は通常は問い合わせにたいして可能なユーザー応答を定義する。引数@var{map}が非@code{nil}なら、それは@code{query-replace-map}のかわりに使用するキーマップを指定する。"

#. type: defun
#: original_texis/searching.texi:2617
msgid "Non-@code{nil} @var{region-noncontiguous-p} means that the region between @var{start} and @var{end} is composed of noncontiguous pieces.  The most common example of this is a rectangular region, where the pieces are separated by newline characters."
msgstr "@var{region-noncontiguous-p}が非@code{nil}なら、@var{start}と@var{end}の間のリージョンは非連続部分から構成されることを意味する。これのもっとも一般的な例は部分が開業文字で区切られた矩形リージョンである。"

#. type: defun
#: original_texis/searching.texi:2624
msgid "This function uses one of two functions to search for the next occurrence of @var{from-string}.  These functions are specified by the values of two variables: @code{replace-re-search-function} and @code{replace-search-function}.  The former is called when the argument @var{regexp-flag} is non-@code{nil}, the latter when it is @code{nil}."
msgstr "この関数は@var{from-string}の次のマッチを検索するために2つの関数のうちいずれか1つを使用する。これらの関数は2つの変数@code{replace-re-search-function}と@code{replace-search-function}により指定される。引数@var{regexp-flag}が非@code{nil}なら前者、@code{nil}なら後者が呼び出される。"

#. type: defvar
#: original_texis/searching.texi:2626
#, no-wrap
msgid "query-replace-map"
msgstr "query-replace-map"

#. type: defvar
#: original_texis/searching.texi:2631
msgid "This variable holds a special keymap that defines the valid user responses for @code{perform-replace} and the commands that use it, as well as @code{y-or-n-p} and @code{map-y-or-n-p}.  This map is unusual in two ways:"
msgstr "この変数は@code{perform-replace}にたいする有効なユーザー応答を定義するスペシャルキーマップを保持して、コマンドは@code{y-or-n-p}や@code{map-y-or-n-p}と同様にそれを使用する。このマップは2つの点において普通のマップと異なる。"

#. type: itemize
#: original_texis/searching.texi:2636
msgid "The key bindings are not commands, just symbols that are meaningful to the functions that use this map."
msgstr "キーバインディングはコマンドではなく、このマップを使用する関数にとって意味のある単なるシンボルであること。"

#. type: itemize
#: original_texis/searching.texi:2642
msgid "Prefix keys are not supported; each key binding must be for a single-event key sequence.  This is because the functions don't use @code{read-key-sequence} to get the input; instead, they read a single event and look it up ``by hand''."
msgstr "プレフィクスキーはサポートされない。各キーバインディングは単一イベントキーシーケンスでなければならない。この関数は入力を取得するために単一イベントを読み取って、それを``手動''で照合するので@code{read-key-sequence}を使用しないからである。"

#. type: Plain text
#: original_texis/searching.texi:2648
msgid "Here are the meaningful bindings for @code{query-replace-map}.  Several of them are meaningful only for @code{query-replace} and friends."
msgstr "@code{query-replace-map}にたいして意味をもつバインディングがあります。それらのうちいくつかは@code{query-replace}とその同族にたいしてのみ意味をもちます。"

#. type: item
#: original_texis/searching.texi:2650
#, no-wrap
msgid "act"
msgstr "act"

#. type: table
#: original_texis/searching.texi:2652
msgid "Do take the action being considered---in other words, ``yes''."
msgstr "判断している対象にたいしてアクションを起こす(言い換えると``yes'')。"

#. type: item
#: original_texis/searching.texi:2653
#, no-wrap
msgid "skip"
msgstr "skip"

#. type: table
#: original_texis/searching.texi:2655
msgid "Do not take action for this question---in other words, ``no''."
msgstr "この問いにたいしてアクションを起こさない(言い換えると``no'')。"

#. type: item
#: original_texis/searching.texi:2656
#, no-wrap
msgid "exit"
msgstr "exit"

#. type: table
#: original_texis/searching.texi:2659
msgid "Answer this question ``no'', and give up on the entire series of questions, assuming that the answers will be ``no''."
msgstr "この問いにたいして``no''を答えて、さらに一連の問いすべてにたいして``no''が応答されたとみなして問い合わせをあきらめる。"

#. type: item
#: original_texis/searching.texi:2660
#, no-wrap
msgid "exit-prefix"
msgstr "exit-prefix"

#. type: table
#: original_texis/searching.texi:2663
msgid "Like @code{exit}, but add the key that was pressed to @code{unread-command-events} (@pxref{Event Input Misc})."
msgstr "@code{exit}と似ているが、@code{unread-command-events}にたいして押下されたキーを追加する(@ref{Event Input Misc}を参照)。"

#. type: item
#: original_texis/searching.texi:2664
#, no-wrap
msgid "act-and-exit"
msgstr "act-and-exit"

#. type: table
#: original_texis/searching.texi:2667
msgid "Answer this question ``yes'', and give up on the entire series of questions, assuming that subsequent answers will be ``no''."
msgstr "この問いにたいして``yes''を答えて、さらに一連の問いすべてにたいして後続の問いに``no''が応答されるとみなして問い合わせをあきらめる。"

#. type: item
#: original_texis/searching.texi:2668
#, no-wrap
msgid "act-and-show"
msgstr "act-and-show"

#. type: table
#: original_texis/searching.texi:2671
msgid "Answer this question ``yes'', but show the results---don't advance yet to the next question."
msgstr "この問いに``yes''を答えるが、結果を表示してまだ次の問いへ進まない。"

#. type: item
#: original_texis/searching.texi:2672
#, no-wrap
msgid "automatic"
msgstr "automatic"

#. type: table
#: original_texis/searching.texi:2675
msgid "Answer this question and all subsequent questions in the series with ``yes'', without further user interaction."
msgstr "これ以上のユーザーとの対話を行わず、この問いと後続の問いにたいして``yes''を答える。"

#. type: item
#: original_texis/searching.texi:2676
#, no-wrap
msgid "backup"
msgstr "backup"

#. type: table
#: original_texis/searching.texi:2678
msgid "Move back to the previous place that a question was asked about."
msgstr "前に問い合わせた以前の場所に戻る。"

#. type: item
#: original_texis/searching.texi:2679
#, no-wrap
msgid "undo"
msgstr "undo"

#. type: table
#: original_texis/searching.texi:2682
msgid "Undo last replacement and move back to the place where that replacement was performed."
msgstr "最後の置換をアンドゥして置換が行われた位置に戻る。"

#. type: item
#: original_texis/searching.texi:2683
#, no-wrap
msgid "undo-all"
msgstr "undo-all"

#. type: table
#: original_texis/searching.texi:2686
msgid "Undo all replacements and move back to the place where the first replacement was performed."
msgstr "すべての置換をアンドゥして最初に置換が行われた位置に戻る。"

#. type: item
#: original_texis/searching.texi:2687
#, no-wrap
msgid "edit"
msgstr "edit"

#. type: table
#: original_texis/searching.texi:2690
msgid "Enter a recursive edit to deal with this question---instead of any other action that would normally be taken."
msgstr "この問いに対処するために、通常とられるアクションのかわりに再帰編集にエンターする。"

#. type: item
#: original_texis/searching.texi:2691
#, no-wrap
msgid "edit-replacement"
msgstr "edit-replacement"

#. type: table
#: original_texis/searching.texi:2693
msgid "Edit the replacement for this question in the minibuffer."
msgstr "ミニバッファー内で、この問いにたいする置換を編集する。"

#. type: item
#: original_texis/searching.texi:2694
#, no-wrap
msgid "delete-and-edit"
msgstr "delete-and-edit"

#. type: table
#: original_texis/searching.texi:2697
msgid "Delete the text being considered, then enter a recursive edit to replace it."
msgstr "検討中のテキストを削除して、それを置換するために再帰編集にエンターする。"

#. type: item
#: original_texis/searching.texi:2698
#, no-wrap
msgid "recenter"
msgstr "recenter"

#. type: itemx
#: original_texis/searching.texi:2699
#, no-wrap
msgid "scroll-up"
msgstr "scroll-up"

#. type: itemx
#: original_texis/searching.texi:2700
#, no-wrap
msgid "scroll-down"
msgstr "scroll-down"

#. type: itemx
#: original_texis/searching.texi:2701
#, no-wrap
msgid "scroll-other-window"
msgstr "scroll-other-window"

#. type: itemx
#: original_texis/searching.texi:2702
#, no-wrap
msgid "scroll-other-window-down"
msgstr "scroll-other-window-down"

#. type: table
#: original_texis/searching.texi:2706
msgid "Perform the specified window scroll operation, then ask the same question again.  Only @code{y-or-n-p} and related functions use this answer."
msgstr "指定されたウィンドウスクロール操作を行って同じ問いを再度尋ねる。この問いには@code{y-or-n-p}と関連する関数だけが使用される。"

#. type: item
#: original_texis/searching.texi:2707
#, no-wrap
msgid "quit"
msgstr "quit"

#. type: table
#: original_texis/searching.texi:2710
msgid "Perform a quit right away.  Only @code{y-or-n-p} and related functions use this answer."
msgstr "即座にquitを行う。この問いには@code{y-or-n-p}と関連する関数だけが使用される。"

#. type: item
#: original_texis/searching.texi:2711
#, no-wrap
msgid "help"
msgstr "help"

#. type: table
#: original_texis/searching.texi:2713
msgid "Display some help, then ask again."
msgstr "ヘルプを表示して再度尋ねる。"

#. type: defvar
#: original_texis/searching.texi:2715
#, no-wrap
msgid "multi-query-replace-map"
msgstr "multi-query-replace-map"

#. type: defvar
#: original_texis/searching.texi:2719
msgid "This variable holds a keymap that extends @code{query-replace-map} by providing additional keybindings that are useful in multi-buffer replacements.  The additional bindings are:"
msgstr "この変数はマルチバッファー置換で有用な追加キーバインディングを提供することにより@code{query-replace-map}を拡張するキーマップを保持する。追加されるバインディングは以下のとおり:"

#. type: item
#: original_texis/searching.texi:2721
#, no-wrap
msgid "automatic-all"
msgstr "automatic-all"

#. type: table
#: original_texis/searching.texi:2724
msgid "Answer this question and all subsequent questions in the series with ``yes'', without further user interaction, for all remaining buffers."
msgstr "残りすべてのバッファーにたいして、それ以上の対話をせずその問いと後続のすべての問いに``yes''を答える。"

#. type: item
#: original_texis/searching.texi:2725
#, no-wrap
msgid "exit-current"
msgstr "exit-current"

#. type: table
#: original_texis/searching.texi:2729
msgid "Answer this question ``no'', and give up on the entire series of questions for the current buffer.  Continue to the next buffer in the sequence."
msgstr "この問いに``no''を答えてカレントバッファーにたいする一連の問いすべてをあきらめる。そしてシーケンス内の次のバッファーへ問いを継続する。"

#. type: defvar
#: original_texis/searching.texi:2732
#, no-wrap
msgid "replace-search-function"
msgstr "replace-search-function"

#. type: defvar
#: original_texis/searching.texi:2738
msgid "This variable specifies a function that @code{perform-replace} calls to search for the next string to replace.  Its default value is @code{search-forward}.  Any other value should name a function of 3 arguments: the first 3 arguments of @code{search-forward} (@pxref{String Search})."
msgstr "この変数は置換する次の文字列を検索するために@code{perform-replace}が呼び出す関数を指定する。デフォルト値は@code{search-forward}。それ以外の値の場合には@code{search-forward}の最初の3つの引数を引数とする関数を指定すること(@ref{String Search}を参照)。"

#. type: defvar
#: original_texis/searching.texi:2740
#, no-wrap
msgid "replace-re-search-function"
msgstr "replace-re-search-function"

#. type: defvar
#: original_texis/searching.texi:2746
msgid "This variable specifies a function that @code{perform-replace} calls to search for the next regexp to replace.  Its default value is @code{re-search-forward}.  Any other value should name a function of 3 arguments: the first 3 arguments of @code{re-search-forward} (@pxref{Regexp Search})."
msgstr "この変数は置換する次のregexpを検索するために@code{perform-replace}が呼び出す関数を指定する。デフォルト値は@code{re-search-forward}。それ以外の値の場合には@code{re-search-forward}の最初の3つの引数を引数とする関数を指定すること(@ref{Regexp Search}を参照)。"

#. type: section
#: original_texis/searching.texi:2749
#, no-wrap
msgid "Standard Regular Expressions Used in Editing"
msgstr "Standard Regular Expressions Used in Editing"

#. type: cindex
#: original_texis/searching.texi:2750
#, no-wrap
msgid "regexps used standardly in editing"
msgstr "regexps used standardly in editing"

#. type: cindex
#: original_texis/searching.texi:2751
#, no-wrap
msgid "standard regexps used in editing"
msgstr "standard regexps used in editing"

#. type: Plain text
#: original_texis/searching.texi:2755
msgid "This section describes some variables that hold regular expressions used for certain purposes in editing:"
msgstr "このセクションでは、編集において特定の目的のために使用される正規表現を保持するいくつかの変数を説明します。"

#. type: defopt
#: original_texis/searching.texi:2756
#, no-wrap
msgid "page-delimiter"
msgstr "page-delimiter"

#. type: defopt
#: original_texis/searching.texi:2761
msgid "This is the regular expression describing line-beginnings that separate pages.  The default value is @code{\"^\\014\"} (i.e., @code{\"^^L\"} or @code{\"^\\C-l\"}); this matches a line that starts with a formfeed character."
msgstr "これはページを分割する行開始を記述する正規表現。デフォルト値は@code{\"^\\014\"} (@code{\"^^L\"}または@code{\"^\\C-l\"})。これはフォームフィード文字(改頁文字)で始まる行とマッチする。"

#. type: Plain text
#: original_texis/searching.texi:2771
msgid "The following two regular expressions should @emph{not} assume the match always starts at the beginning of a line; they should not use @samp{^} to anchor the match.  Most often, the paragraph commands do check for a match only at the beginning of a line, which means that @samp{^} would be superfluous.  When there is a nonzero left margin, they accept matches that start after the left margin.  In that case, a @samp{^} would be incorrect.  However, a @samp{^} is harmless in modes where a left margin is never used."
msgstr "以下の2つの正規表現が、常に行頭からマッチが始まる正規表現とみなすべきでは@emph{ありません}。これらを@samp{^}にマッチするアンカーとして使用するべきではありません。ほとんどの場合では、パラグラフコマンドは行頭にたいしてのみマッチのチェックを行うので、これは@samp{^}が不要であることを意味します。非0の左マージンが存在する場合には、これらは左マージンの後から始まるマッチに適用されます。その場合には、@samp{^}は不適切でしょう。しかし左マージンを決して使用しないモードでは@samp{^}は無害でしょう。"

#. type: defopt
#: original_texis/searching.texi:2772
#, no-wrap
msgid "paragraph-separate"
msgstr "paragraph-separate"

#. type: defopt
#: original_texis/searching.texi:2778
msgid "This is the regular expression for recognizing the beginning of a line that separates paragraphs.  (If you change this, you may have to change @code{paragraph-start} also.)  The default value is @w{@code{\"[@ \\t\\f]*$\"}}, which matches a line that consists entirely of spaces, tabs, and form feeds (after its left margin)."
msgstr "これはパラグラフを分割する行の開始を認識する正規表現(これを変更する場合は@code{paragraph-start}も変更する必要があるかもしれない)。デフォルト値は@w{@code{\"[@ \\t\\f]*$\"}}であり、これは(左マージン以降)すべてがスペース、タブ、フォームフィードで構成される行とマッチする。"

#. type: defopt
#: original_texis/searching.texi:2780
#, no-wrap
msgid "paragraph-start"
msgstr "paragraph-start"

#. type: defopt
#: original_texis/searching.texi:2785
msgid "This is the regular expression for recognizing the beginning of a line that starts @emph{or} separates paragraphs.  The default value is @w{@code{\"\\f\\\\|[ \\t]*$\"}}, which matches a line containing only whitespace or starting with a form feed (after its left margin)."
msgstr "これはパラグラフを開始@emph{または}分割する行の開始を認識する正規表現。デフォルト値は@w{@code{\"\\f\\\\|[ \\t]*$\"}}であり、これは(左マージン以降)すべてが空白文字で構成される行やフォームフィードで始まる行とマッチする。"

#. type: defun
#: original_texis/searching.texi:2787 original_texis/searching.texi:2798
#, no-wrap
msgid "sentence-end"
msgstr "sentence-end"

#. type: defopt
#: original_texis/searching.texi:2791
msgid "If non-@code{nil}, the value should be a regular expression describing the end of a sentence, including the whitespace following the sentence.  (All paragraph boundaries also end sentences, regardless.)"
msgstr "非@code{nil}なら、以降に続く空白文字を含めてセンテンスの終わりを記述する正規表現であること(これとは無関係にパラグラフ境界もセンテンスを終了させる)。"

#. type: defopt
#: original_texis/searching.texi:2796
msgid "If the value is @code{nil}, as it is by default, then the function @code{sentence-end} constructs the regexp.  That is why you should always call the function @code{sentence-end} to obtain the regexp to be used to recognize the end of a sentence."
msgstr "値が@code{nil} (デフォルト)なら、関数@code{sentence-end}がregexpを構築する。センテンス終端の認識に使用するregexpを得るために常に関数@code{sentence-end}を使用するべきなのはこれが理由。"

#. type: defun
#: original_texis/searching.texi:2805
msgid "This function returns the value of the variable @code{sentence-end}, if non-@code{nil}.  Otherwise it returns a default value based on the values of the variables @code{sentence-end-double-space} (@pxref{Definition of sentence-end-double-space}), @code{sentence-end-without-period}, and @code{sentence-end-without-space}."
msgstr "この関数は変数@code{sentence-end}が非@code{nil}ならその値をリターンする。それ以外なら変数@code{sentence-end-double-space} (@ref{Definition of sentence-end-double-space}を参照)、@code{sentence-end-without-period}、@code{sentence-end-without-space}にもとづくデフォルト値をリターンする。"
