# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2024-10-06 07:16+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: original_texis/strings.texi:6 original_texis/strings.texi:7
#, no-wrap
msgid "Strings and Characters"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:8
#, no-wrap
msgid "strings"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:9
#, no-wrap
msgid "character arrays"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:10
#, no-wrap
msgid "characters"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:11
#, no-wrap
msgid "bytes"
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:19
msgid ""
"A string in Emacs Lisp is an array that contains an ordered sequence of "
"characters.  Strings are used as names of symbols, buffers, and files; to "
"send messages to users; to hold text being copied between buffers; and for "
"many other purposes.  Because strings are so important, Emacs Lisp has many "
"functions expressly for manipulating them.  Emacs Lisp programs use strings "
"more often than individual characters."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:22
msgid ""
"@xref{Strings of Events}, for special considerations for strings of keyboard "
"character events."
msgstr ""

#. type: menuentry
#: original_texis/strings.texi:34
msgid "Basics: String Basics"
msgstr ""

#. type: menuentry
#: original_texis/strings.texi:34
msgid "Basic properties of strings and characters."
msgstr ""

#. type: section
#: original_texis/strings.texi:34 original_texis/strings.texi:94 original_texis/strings.texi:95
#, no-wrap
msgid "Predicates for Strings"
msgstr ""

#. type: menuentry
#: original_texis/strings.texi:34
msgid "Testing whether an object is a string or char."
msgstr ""

#. type: section
#: original_texis/strings.texi:34 original_texis/strings.texi:117 original_texis/strings.texi:118
#, no-wrap
msgid "Creating Strings"
msgstr ""

#. type: menuentry
#: original_texis/strings.texi:34
msgid "Functions to allocate new strings."
msgstr ""

#. type: section
#: original_texis/strings.texi:34 original_texis/strings.texi:459 original_texis/strings.texi:460
#, no-wrap
msgid "Modifying Strings"
msgstr ""

#. type: menuentry
#: original_texis/strings.texi:34
msgid "Altering the contents of an existing string."
msgstr ""

#. type: node
#: original_texis/strings.texi:34 original_texis/strings.texi:486
#, no-wrap
msgid "Text Comparison"
msgstr ""

#. type: menuentry
#: original_texis/strings.texi:34
msgid "Comparing characters or strings."
msgstr ""

#. type: node
#: original_texis/strings.texi:34 original_texis/strings.texi:830
#, no-wrap
msgid "String Conversion"
msgstr ""

#. type: menuentry
#: original_texis/strings.texi:34
msgid "Converting to and from characters and strings."
msgstr ""

#. type: section
#: original_texis/strings.texi:34 original_texis/strings.texi:937 original_texis/strings.texi:938
#, no-wrap
msgid "Formatting Strings"
msgstr ""

#. type: menuentry
#: original_texis/strings.texi:34
msgid "@code{format}: Emacs's analogue of @code{printf}."
msgstr ""

#. type: section
#: original_texis/strings.texi:34 original_texis/strings.texi:1236 original_texis/strings.texi:1237
#, no-wrap
msgid "Custom Format Strings"
msgstr ""

#. type: menuentry
#: original_texis/strings.texi:34
msgid "Formatting custom @code{format} specifications."
msgstr ""

#. type: node
#: original_texis/strings.texi:34 original_texis/strings.texi:1438
#, no-wrap
msgid "Case Conversion"
msgstr ""

#. type: menuentry
#: original_texis/strings.texi:34
msgid "Case conversion functions."
msgstr ""

#. type: node
#: original_texis/strings.texi:34 original_texis/strings.texi:1601
#, no-wrap
msgid "Case Tables"
msgstr ""

#. type: menuentry
#: original_texis/strings.texi:34
msgid "Customizing case conversion."
msgstr ""

#. type: node
#: original_texis/strings.texi:36
#, no-wrap
msgid "String Basics"
msgstr ""

#. type: section
#: original_texis/strings.texi:37
#, no-wrap
msgid "String and Character Basics"
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:44
msgid ""
"A character is a Lisp object which represents a single character of text.  "
"In Emacs Lisp, characters are simply integers; whether an integer is a "
"character or not is determined only by how it is used.  @xref{Character "
"Codes}, for details about character representation in Emacs."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:50
msgid ""
"A string is a fixed sequence of characters.  It is a type of sequence called "
"an @dfn{array}, meaning that its length is fixed and cannot be altered once "
"it is created (@pxref{Sequences Arrays Vectors}).  Unlike in C, Emacs Lisp "
"strings are @emph{not} terminated by a distinguished character code."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:56
msgid ""
"Since strings are arrays, and therefore sequences as well, you can operate "
"on them with the general array and sequence functions documented in "
"@ref{Sequences Arrays Vectors}.  For example, you can access individual "
"characters in a string using the function @code{aref} (@pxref{Array "
"Functions})."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:61
msgid ""
"There are two text representations for non-@acronym{ASCII} characters in "
"Emacs strings (and in buffers): unibyte and multibyte.  For most Lisp "
"programming, you don't need to be concerned with these two representations.  "
"@xref{Text Representations}, for details."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:72
msgid ""
"Sometimes key sequences are represented as unibyte strings.  When a unibyte "
"string is a key sequence, string elements in the range 128 to 255 represent "
"meta characters (which are large integers) rather than character codes in "
"the range 128 to 255.  Strings cannot hold characters that have the hyper, "
"super or alt modifiers; they can hold @acronym{ASCII} control characters, "
"but no other control characters.  They do not distinguish case in "
"@acronym{ASCII} control characters.  If you want to store such characters in "
"a sequence, such as a key sequence, you must use a vector instead of a "
"string.  @xref{Character Type}, for more information about keyboard input "
"characters."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:79
msgid ""
"Strings are useful for holding regular expressions.  You can also match "
"regular expressions against strings with @code{string-match} (@pxref{Regexp "
"Search}).  The functions @code{match-string} (@pxref{Simple Match Data}) and "
"@code{replace-match} (@pxref{Replacing Match}) are useful for decomposing "
"and modifying strings after matching regular expressions against them."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:84
msgid ""
"Like a buffer, a string can contain text properties for the characters in "
"it, as well as the characters themselves.  @xref{Text Properties}.  All the "
"Lisp primitives that copy text from strings to buffers or other strings also "
"copy the properties of the characters being copied."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:93
msgid ""
"@xref{Text}, for information about functions that display strings or copy "
"them into buffers.  @xref{Character Type}, and @ref{String Type}, for "
"information about the syntax of characters and strings.  @xref{Non-ASCII "
"Characters}, for functions to convert between text representations and to "
"encode and decode character codes.  Also, note that @code{length} should "
"@emph{not} be used for computing the width of a string on display; use "
"@code{string-width} (@pxref{Size of Displayed Text}) instead."
msgstr ""

#. type: cindex
#: original_texis/strings.texi:96
#, no-wrap
msgid "predicates for strings"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:97
#, no-wrap
msgid "string predicates"
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:101
msgid ""
"For more information about general sequence and array predicates, see "
"@ref{Sequences Arrays Vectors}, and @ref{Arrays}."
msgstr ""

#. type: defun
#: original_texis/strings.texi:102
#, no-wrap
msgid "stringp object"
msgstr ""

#. type: defun
#: original_texis/strings.texi:105
msgid ""
"This function returns @code{t} if @var{object} is a string, @code{nil} "
"otherwise."
msgstr ""

#. type: defun
#: original_texis/strings.texi:107
#, no-wrap
msgid "string-or-null-p object"
msgstr ""

#. type: defun
#: original_texis/strings.texi:110
msgid ""
"This function returns @code{t} if @var{object} is a string or @code{nil}.  "
"It returns @code{nil} otherwise."
msgstr ""

#. type: defun
#: original_texis/strings.texi:112
#, no-wrap
msgid "char-or-string-p object"
msgstr ""

#. type: defun
#: original_texis/strings.texi:115
msgid ""
"This function returns @code{t} if @var{object} is a string or a character "
"(i.e., an integer), @code{nil} otherwise."
msgstr ""

#. type: cindex
#: original_texis/strings.texi:119
#, no-wrap
msgid "creating strings"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:120
#, no-wrap
msgid "string creation"
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:127
msgid ""
"The following functions create strings, either from scratch, or by putting "
"strings together, or by taking them apart.  (For functions that create "
"strings based on the modified contents of other strings, like "
"@code{string-replace} and @code{replace-regexp-in-string}, see @ref{Search "
"and Replace}.)"
msgstr ""

#. type: defun
#: original_texis/strings.texi:128
#, no-wrap
msgid "make-string count character &optional multibyte"
msgstr ""

#. type: defun
#: original_texis/strings.texi:131
msgid ""
"This function returns a string made up of @var{count} repetitions of "
"@var{character}.  If @var{count} is negative, an error is signaled."
msgstr ""

#. type: example
#: original_texis/strings.texi:137
#, no-wrap
msgid ""
"(make-string 5 ?x)\n"
"     @result{} \"xxxxx\"\n"
"(make-string 0 ?x)\n"
"     @result{} \"\"\n"
msgstr ""

#. type: defun
#: original_texis/strings.texi:145
msgid ""
"Normally, if @var{character} is an @acronym{ASCII} character, the result is "
"a unibyte string.  But if the optional argument @var{multibyte} is "
"non-@code{nil}, the function will produce a multibyte string instead.  This "
"is useful when you later need to concatenate the result with "
"non-@acronym{ASCII} strings or replace some of its characters with "
"non-@acronym{ASCII} characters."
msgstr ""

#. type: defun
#: original_texis/strings.texi:148
msgid ""
"Other functions to compare with this one include @code{make-vector} "
"(@pxref{Vectors}) and @code{make-list} (@pxref{Building Lists})."
msgstr ""

#. type: defun
#: original_texis/strings.texi:150
#, no-wrap
msgid "string &rest characters"
msgstr ""

#. type: defun
#: original_texis/strings.texi:152
msgid "This returns a string containing the characters @var{characters}."
msgstr ""

#. type: example
#: original_texis/strings.texi:156
#, no-wrap
msgid ""
"(string ?a ?b ?c)\n"
"     @result{} \"abc\"\n"
msgstr ""

#. type: defun
#: original_texis/strings.texi:159
#, no-wrap
msgid "substring string &optional start end"
msgstr ""

#. type: defun
#: original_texis/strings.texi:165
msgid ""
"This function returns a new string which consists of those characters from "
"@var{string} in the range from (and including) the character at the index "
"@var{start} up to (but excluding) the character at the index @var{end}.  The "
"first character is at index zero.  With one argument, this function just "
"copies @var{string}."
msgstr ""

#. type: group
#: original_texis/strings.texi:170
#, no-wrap
msgid ""
"(substring \"abcdefg\" 0 3)\n"
"     @result{} \"abc\"\n"
msgstr ""

#. type: defun
#: original_texis/strings.texi:179
msgid ""
"In the above example, the index for @samp{a} is 0, the index for @samp{b} is "
"1, and the index for @samp{c} is 2.  The index 3---which is the fourth "
"character in the string---marks the character position up to which the "
"substring is copied.  Thus, @samp{abc} is copied from the string "
"@code{\"abcdefg\"}."
msgstr ""

#. type: defun
#: original_texis/strings.texi:182
msgid ""
"A negative number counts from the end of the string, so that @minus{}1 "
"signifies the index of the last character of the string.  For example:"
msgstr ""

#. type: group
#: original_texis/strings.texi:187
#, no-wrap
msgid ""
"(substring \"abcdefg\" -3 -1)\n"
"     @result{} \"ef\"\n"
msgstr ""

#. type: defun
#: original_texis/strings.texi:194
msgid ""
"In this example, the index for @samp{e} is @minus{}3, the index for @samp{f} "
"is @minus{}2, and the index for @samp{g} is @minus{}1.  Therefore, @samp{e} "
"and @samp{f} are included, and @samp{g} is excluded."
msgstr ""

#. type: defun
#: original_texis/strings.texi:197
msgid ""
"When @code{nil} is used for @var{end}, it stands for the length of the "
"string.  Thus,"
msgstr ""

#. type: group
#: original_texis/strings.texi:202
#, no-wrap
msgid ""
"(substring \"abcdefg\" -3 nil)\n"
"     @result{} \"efg\"\n"
msgstr ""

#. type: defun
#: original_texis/strings.texi:208
msgid ""
"Omitting the argument @var{end} is equivalent to specifying @code{nil}.  It "
"follows that @code{(substring @var{string} 0)} returns a copy of all of "
"@var{string}."
msgstr ""

#. type: group
#: original_texis/strings.texi:213
#, no-wrap
msgid ""
"(substring \"abcdefg\" 0)\n"
"     @result{} \"abcdefg\"\n"
msgstr ""

#. type: defun
#: original_texis/strings.texi:219
msgid ""
"But we recommend @code{copy-sequence} for this purpose (@pxref{Sequence "
"Functions})."
msgstr ""

#. type: defun
#: original_texis/strings.texi:222
msgid ""
"If the characters copied from @var{string} have text properties, the "
"properties are copied into the new string also.  @xref{Text Properties}."
msgstr ""

#. type: defun
#: original_texis/strings.texi:225
msgid "@code{substring} also accepts a vector for the first argument.  For example:"
msgstr ""

#. type: example
#: original_texis/strings.texi:229
#, no-wrap
msgid ""
"(substring [a b (c) \"d\"] 1 3)\n"
"     @result{} [b (c)]\n"
msgstr ""

#. type: defun
#: original_texis/strings.texi:236
msgid ""
"A @code{wrong-type-argument} error is signaled if @var{start} is not an "
"integer or if @var{end} is neither an integer nor @code{nil}.  An "
"@code{args-out-of-range} error is signaled if @var{start} indicates a "
"character following @var{end}, or if either integer is out of range for "
"@var{string}."
msgstr ""

#. type: defun
#: original_texis/strings.texi:241
msgid ""
"Contrast this function with @code{buffer-substring} (@pxref{Buffer "
"Contents}), which returns a string containing a portion of the text in the "
"current buffer.  The beginning of a string is at index 0, but the beginning "
"of a buffer is at index 1."
msgstr ""

#. type: defun
#: original_texis/strings.texi:243
#, no-wrap
msgid "substring-no-properties string &optional start end"
msgstr ""

#. type: defun
#: original_texis/strings.texi:249
msgid ""
"This works like @code{substring} but discards all text properties from the "
"value.  Also, @var{start} may be omitted or @code{nil}, which is equivalent "
"to 0.  Thus, @w{@code{(substring-no-properties @var{string})}} returns a "
"copy of @var{string}, with all text properties removed."
msgstr ""

#. type: defun
#: original_texis/strings.texi:251
#, no-wrap
msgid "concat &rest sequences"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:252
#, no-wrap
msgid "copying strings"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:253
#, no-wrap
msgid "concatenating strings"
msgstr ""

#. type: defun
#: original_texis/strings.texi:259
msgid ""
"This function returns a string consisting of the characters in the arguments "
"passed to it (along with their text properties, if any).  The arguments may "
"be strings, lists of numbers, or vectors of numbers; they are not themselves "
"changed.  If @code{concat} receives no arguments, it returns an empty "
"string."
msgstr ""

#. type: example
#: original_texis/strings.texi:272
#, no-wrap
msgid ""
"(concat \"abc\" \"-def\")\n"
"     @result{} \"abc-def\"\n"
"(concat \"abc\" (list 120 121) [122])\n"
"     @result{} \"abcxyz\"\n"
";; @r{@code{nil} is an empty sequence.}\n"
"(concat \"abc\" nil \"-def\")\n"
"     @result{} \"abc-def\"\n"
"(concat \"The \" \"quick brown \" \"fox.\")\n"
"     @result{} \"The quick brown fox.\"\n"
"(concat)\n"
"     @result{} \"\"\n"
msgstr ""

#. type: defun
#: original_texis/strings.texi:278
msgid ""
"This function does not always allocate a new string.  Callers are advised "
"not rely on the result being a new string nor on it being @code{eq} to an "
"existing string."
msgstr ""

#. type: defun
#: original_texis/strings.texi:283
msgid ""
"In particular, mutating the returned value may inadvertently change another "
"string, alter a constant string in the program, or even raise an error.  To "
"obtain a string that you can safely mutate, use @code{copy-sequence} on the "
"result."
msgstr ""

#. type: defun
#: original_texis/strings.texi:290
msgid ""
"For information about other concatenation functions, see the description of "
"@code{mapconcat} in @ref{Mapping Functions}, @code{vconcat} in @ref{Vector "
"Functions}, and @code{append} in @ref{Building Lists}.  For concatenating "
"individual command-line arguments into a string to be used as a shell "
"command, see @ref{Shell Arguments, combine-and-quote-strings}."
msgstr ""

#. type: defun
#: original_texis/strings.texi:292
#, no-wrap
msgid "split-string string &optional separators omit-nulls trim"
msgstr ""

#. type: defun
#: original_texis/strings.texi:297
msgid ""
"This function splits @var{string} into substrings based on the regular "
"expression @var{separators} (@pxref{Regular Expressions}).  Each match for "
"@var{separators} defines a splitting point; the substrings between splitting "
"points are made into a list, which is returned."
msgstr ""

#. type: defun
#: original_texis/strings.texi:301
msgid ""
"If @var{separators} is @code{nil} (or omitted), the default is the value of "
"@code{split-string-default-separators} and the function behaves as if "
"@var{omit-nulls} were @code{t}."
msgstr ""

#. type: defun
#: original_texis/strings.texi:307
msgid ""
"If @var{omit-nulls} is @code{nil} (or omitted), the result contains null "
"strings whenever there are two consecutive matches for @var{separators}, or "
"a match is adjacent to the beginning or end of @var{string}.  If "
"@var{omit-nulls} is @code{t}, these null strings are omitted from the "
"result."
msgstr ""

#. type: defun
#: original_texis/strings.texi:312
msgid ""
"If the optional argument @var{trim} is non-@code{nil}, it should be a "
"regular expression to match text to trim from the beginning and end of each "
"substring.  If trimming makes the substring empty, it is treated as null."
msgstr ""

#. type: defun
#: original_texis/strings.texi:316
msgid ""
"If you need to split a string into a list of individual command-line "
"arguments suitable for @code{call-process} or @code{start-process}, see "
"@ref{Shell Arguments, split-string-and-unquote}."
msgstr ""

#. type: defun
#: original_texis/strings.texi:318
msgid "Examples:"
msgstr ""

#. type: example
#: original_texis/strings.texi:322
#, no-wrap
msgid ""
"(split-string \"  two words \")\n"
"     @result{} (\"two\" \"words\")\n"
msgstr ""

#. type: defun
#: original_texis/strings.texi:327
msgid ""
"The result is not @code{(\"\" \"two\" \"words\" \"\")}, which would rarely "
"be useful.  If you need such a result, use an explicit value for "
"@var{separators}:"
msgstr ""

#. type: example
#: original_texis/strings.texi:332
#, no-wrap
msgid ""
"(split-string \"  two words \"\n"
"              split-string-default-separators)\n"
"     @result{} (\"\" \"two\" \"words\" \"\")\n"
msgstr ""

#. type: example
#: original_texis/strings.texi:341
#, no-wrap
msgid ""
"(split-string \"Soup is good food\" \"o\")\n"
"     @result{} (\"S\" \"up is g\" \"\" \"d f\" \"\" \"d\")\n"
"(split-string \"Soup is good food\" \"o\" t)\n"
"     @result{} (\"S\" \"up is g\" \"d f\" \"d\")\n"
"(split-string \"Soup is good food\" \"o+\")\n"
"     @result{} (\"S\" \"up is g\" \"d f\" \"d\")\n"
msgstr ""

#. type: defun
#: original_texis/strings.texi:346
msgid ""
"Empty matches do count, except that @code{split-string} will not look for a "
"final empty match when it already reached the end of the string using a "
"non-empty match or when @var{string} is empty:"
msgstr ""

#. type: example
#: original_texis/strings.texi:354
#, no-wrap
msgid ""
"(split-string \"aooob\" \"o*\")\n"
"     @result{} (\"\" \"a\" \"\" \"b\" \"\")\n"
"(split-string \"ooaboo\" \"o*\")\n"
"     @result{} (\"\" \"\" \"a\" \"b\" \"\")\n"
"(split-string \"\" \"\")\n"
"     @result{} (\"\")\n"
msgstr ""

#. type: defun
#: original_texis/strings.texi:359
msgid ""
"However, when @var{separators} can match the empty string, @var{omit-nulls} "
"is usually @code{t}, so that the subtleties in the three previous examples "
"are rarely relevant:"
msgstr ""

#. type: example
#: original_texis/strings.texi:367
#, no-wrap
msgid ""
"(split-string \"Soup is good food\" \"o*\" t)\n"
"     @result{} (\"S\" \"u\" \"p\" \" \" \"i\" \"s\" \" \" \"g\" \"d\" \" \" "
"\"f\" \"d\")\n"
"(split-string \"Nice doggy!\" \"\" t)\n"
"     @result{} (\"N\" \"i\" \"c\" \"e\" \" \" \"d\" \"o\" \"g\" \"g\" \"y\" "
"\"!\")\n"
"(split-string \"\" \"\" t)\n"
"     @result{} nil\n"
msgstr ""

#. type: defun
#: original_texis/strings.texi:373
msgid ""
"Somewhat odd, but predictable, behavior can occur for certain ``non-greedy'' "
"values of @var{separators} that can prefer empty matches over non-empty "
"matches.  Again, such values rarely occur in practice:"
msgstr ""

#. type: example
#: original_texis/strings.texi:379
#, no-wrap
msgid ""
"(split-string \"ooo\" \"o*\" t)\n"
"     @result{} nil\n"
"(split-string \"ooo\" \"\\\\|o+\" t)\n"
"     @result{} (\"o\" \"o\" \"o\")\n"
msgstr ""

#. type: defvar
#: original_texis/strings.texi:382
#, no-wrap
msgid "split-string-default-separators"
msgstr ""

#. type: defvar
#: original_texis/strings.texi:385
msgid ""
"The default value of @var{separators} for @code{split-string}.  Its usual "
"value is @w{@code{\"[ \\f\\t\\n\\r\\v]+\"}}."
msgstr ""

#. type: defun
#: original_texis/strings.texi:387
#, no-wrap
msgid "string-clean-whitespace string"
msgstr ""

#. type: defun
#: original_texis/strings.texi:391
msgid ""
"Clean up the whitespace in @var{string} by collapsing stretches of "
"whitespace to a single space character, as well as removing all whitespace "
"from the start and the end of @var{string}."
msgstr ""

#. type: defun
#: original_texis/strings.texi:393
#, no-wrap
msgid "string-trim-left string &optional regexp"
msgstr ""

#. type: defun
#: original_texis/strings.texi:396
msgid ""
"Remove the leading text that matches @var{regexp} from @var{string}.  "
"@var{regexp} defaults to @samp{[ \\t\\n\\r]+}."
msgstr ""

#. type: defun
#: original_texis/strings.texi:398
#, no-wrap
msgid "string-trim-right string &optional regexp"
msgstr ""

#. type: defun
#: original_texis/strings.texi:401
msgid ""
"Remove the trailing text that matches @var{regexp} from @var{string}.  "
"@var{regexp} defaults to @samp{[ \\t\\n\\r]+}."
msgstr ""

#. type: defun
#: original_texis/strings.texi:403
#, no-wrap
msgid "string-trim string &optional trim-left trim-right"
msgstr ""

#. type: defun
#: original_texis/strings.texi:407
msgid ""
"Remove the leading text that matches @var{trim-left} and trailing text that "
"matches @var{trim-right} from @var{string}.  Both regexps default to @samp{[ "
"\\t\\n\\r]+}."
msgstr ""

#. type: defun
#: original_texis/strings.texi:409
#, no-wrap
msgid "string-fill string width"
msgstr ""

#. type: defun
#: original_texis/strings.texi:415
msgid ""
"Attempt to Word-wrap @var{string} so that it displays with lines no wider "
"than @var{width}.  Filling is done on whitespace boundaries only.  If there "
"are individual words that are longer than @var{width}, these will not be "
"shortened, and therefore @var{string} might be shown with lines wider than "
"@var{width} in that case."
msgstr ""

#. type: defun
#: original_texis/strings.texi:417
#, no-wrap
msgid "string-limit string length &optional end coding-system"
msgstr ""

#. type: defun
#: original_texis/strings.texi:423
msgid ""
"If @var{string} is shorter than @var{length} characters, @var{string} is "
"returned as is.  Otherwise, return a substring of @var{string} consisting of "
"the first @var{length} characters.  If the optional @var{end} parameter is "
"given, return a string of the @var{length} last characters instead."
msgstr ""

#. type: defun
#: original_texis/strings.texi:430
msgid ""
"If @var{coding-system} is non-@code{nil}, @var{string} will be encoded "
"before limiting, and the result will be a unibyte string that's shorter than "
"@code{length} bytes.  If @var{string} contains characters that are encoded "
"into several bytes (for instance, when using @code{utf-8}), the resulting "
"unibyte string is never truncated in the middle of a character "
"representation."
msgstr ""

#. type: defun
#: original_texis/strings.texi:436
msgid ""
"This function measures the string length in characters or bytes, and thus is "
"generally inappropriate if you need to shorten strings for display purposes; "
"use @code{truncate-string-to-width} or @code{window-text-pixel-size} or "
"@code{string-glyph-split} instead (@pxref{Size of Displayed Text})."
msgstr ""

#. type: defun
#: original_texis/strings.texi:438
#, no-wrap
msgid "string-lines string &optional omit-nulls keep-newlines"
msgstr ""

#. type: defun
#: original_texis/strings.texi:444
msgid ""
"Split @var{string} into a list of strings on newline boundaries.  If the "
"optional argument @var{omit-nulls} is non-@code{nil}, remove empty lines "
"from the results.  If the optional argument @var{keep-newlines} is "
"non-@code{nil}, don't remove the trailing newlines from the result strings."
msgstr ""

#. type: defun
#: original_texis/strings.texi:446
#, no-wrap
msgid "string-pad string length &optional padding start"
msgstr ""

#. type: defun
#: original_texis/strings.texi:453
msgid ""
"Pad @var{string} to be of the given @var{length} using @var{padding} as the "
"padding character.  @var{padding} defaults to the space character.  If "
"@var{string} is longer than @var{length}, no padding is done.  If "
"@var{start} is @code{nil} or omitted, the padding is appended to the "
"characters of @var{string}, and if it's non-@code{nil}, the padding is "
"prepended to @var{string}'s characters."
msgstr ""

#. type: defun
#: original_texis/strings.texi:455
#, no-wrap
msgid "string-chop-newline string"
msgstr ""

#. type: defun
#: original_texis/strings.texi:457
msgid "Remove the final newline, if any, from @var{string}."
msgstr ""

#. type: cindex
#: original_texis/strings.texi:461
#, no-wrap
msgid "modifying strings"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:462
#, no-wrap
msgid "string modification"
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:466
msgid ""
"You can alter the contents of a mutable string via operations described in "
"this section.  @xref{Mutability}."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:476
msgid ""
"The most basic way to alter the contents of an existing string is with "
"@code{aset} (@pxref{Array Functions}).  @w{@code{(aset @var{string} "
"@var{idx} @var{char})}} stores @var{char} into @var{string} at character "
"index @var{idx}.  It will automatically convert a pure-@acronym{ASCII} "
"@var{string} to a multibyte string (@pxref{Text Representations}) if needed, "
"but we recommend to always make sure @var{string} is multibyte (e.g., by "
"using @code{string-to-multibyte}, @pxref{Converting Representations}), if "
"@var{char} is a non-@acronym{ASCII} character, not a raw byte."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:479
msgid "To clear out a string that contained a password, use @code{clear-string}:"
msgstr ""

#. type: defun
#: original_texis/strings.texi:480
#, no-wrap
msgid "clear-string string"
msgstr ""

#. type: defun
#: original_texis/strings.texi:483
msgid ""
"This makes @var{string} a unibyte string and clears its contents to null "
"characters.  It may also change @var{string}'s length."
msgstr ""

#. type: section
#: original_texis/strings.texi:487
#, no-wrap
msgid "Comparison of Characters and Strings"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:488
#, no-wrap
msgid "string equality"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:489
#, no-wrap
msgid "text comparison"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:490
#, no-wrap
msgid "string comparison"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:492
#, no-wrap
msgid "compare characters"
msgstr ""

#. type: defun
#: original_texis/strings.texi:493
#, no-wrap
msgid "char-equal character1 character2"
msgstr ""

#. type: defun
#: original_texis/strings.texi:497
msgid ""
"This function returns @code{t} if the arguments represent the same "
"character, @code{nil} otherwise.  This function ignores differences in case "
"if @code{case-fold-search} is non-@code{nil}."
msgstr ""

#. type: example
#: original_texis/strings.texi:504
#, no-wrap
msgid ""
"(char-equal ?x ?x)\n"
"     @result{} t\n"
"(let ((case-fold-search nil))\n"
"  (char-equal ?x ?X))\n"
"     @result{} nil\n"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:507
#, no-wrap
msgid "compare strings"
msgstr ""

#. type: defun
#: original_texis/strings.texi:508
#, no-wrap
msgid "string-equal string1 string2"
msgstr ""

#. type: defun
#: original_texis/strings.texi:513
msgid ""
"This function returns @code{t} if the characters of the two strings match "
"exactly.  Symbols are also allowed as arguments, in which case the symbol "
"names are used.  Case is always significant, regardless of "
"@code{case-fold-search}."
msgstr ""

#. type: defun
#: original_texis/strings.texi:520
msgid ""
"This function is equivalent to @code{equal} for comparing two strings "
"(@pxref{Equality Predicates}).  In particular, the text properties of the "
"two strings are ignored; use @code{equal-including-properties} if you need "
"to distinguish between strings that differ only in their text properties.  "
"However, unlike @code{equal}, if either argument is not a string or symbol, "
"@code{string-equal} signals an error."
msgstr ""

#. type: example
#: original_texis/strings.texi:528
#, no-wrap
msgid ""
"(string-equal \"abc\" \"abc\")\n"
"     @result{} t\n"
"(string-equal \"abc\" \"ABC\")\n"
"     @result{} nil\n"
"(string-equal \"ab\" \"ABC\")\n"
"     @result{} nil\n"
msgstr ""

#. type: defun
#: original_texis/strings.texi:534
msgid ""
"A unibyte and a multibyte string are equal in the sense of "
"@code{string-equal} if and only if they contain the same sequence of "
"character codes all being in the range 0--127 (@acronym{ASCII}).  @xref{Text "
"Representations}."
msgstr ""

#. type: defun
#: original_texis/strings.texi:536
#, no-wrap
msgid "string= string1 string2"
msgstr ""

#. type: defun
#: original_texis/strings.texi:538
msgid "@code{string=} is another name for @code{string-equal}."
msgstr ""

#. type: cindex
#: original_texis/strings.texi:540
#, no-wrap
msgid "case-insensitive string comparison"
msgstr ""

#. type: defun
#: original_texis/strings.texi:541
#, no-wrap
msgid "string-equal-ignore-case string1 string2"
msgstr ""

#. type: defun
#: original_texis/strings.texi:545
msgid ""
"@code{string-equal-ignore-case} compares strings ignoring case differences, "
"like @code{char-equal} when @code{case-fold-search} is @code{t}."
msgstr ""

#. type: cindex
#: original_texis/strings.texi:547
#, no-wrap
msgid "locale-dependent string equivalence"
msgstr ""

#. type: defun
#: original_texis/strings.texi:548
#, no-wrap
msgid "string-collate-equalp string1 string2 &optional locale ignore-case"
msgstr ""

#. type: defun
#: original_texis/strings.texi:565
msgid ""
"This function returns @code{t} if @var{string1} and @var{string2} are equal "
"with respect to the collation rules of the specified @var{locale}, which "
"defaults to your current system locale.  A collation rule is not only "
"determined by the lexicographic order of the characters contained in "
"@var{string1} and @var{string2}, but also by further rules about relations "
"between these characters.  Usually, it is defined by the locale environment "
"with which Emacs is running and by the Standard C library against which "
"Emacs was linked@footnote{ For more information about collation rules and "
"their locale dependencies, see @uref{https://unicode.org/reports/tr10/, The "
"Unicode Collation Algorithm}.  Some Standard C libraries, such as the "
"@acronym{GNU} C Library (a.k.a.@: @dfn{glibc}) implement large portions of "
"the Unicode Collation Algorithm and use the associated locale data, Common "
"Locale Data Repository, or @acronym{CLDR}.  }."
msgstr ""

#. type: defun
#: original_texis/strings.texi:569
msgid ""
"For example, characters with different code points but the same meaning, "
"like different grave accent Unicode characters, might, in some locales, be "
"considered as equal:"
msgstr ""

#. type: group
#: original_texis/strings.texi:574
#, no-wrap
msgid ""
"(string-collate-equalp (string ?\\uFF40) (string ?\\u1FEF))\n"
"     @result{} t\n"
msgstr ""

#. type: defun
#: original_texis/strings.texi:582
msgid ""
"The optional argument @var{locale}, a string, overrides the setting of your "
"current locale identifier for collation.  The value is system dependent; a "
"@var{locale} @code{\"en_US.UTF-8\"} is applicable on POSIX systems, while it "
"would be, e.g., @code{\"enu_USA.1252\"} on MS-Windows systems."
msgstr ""

#. type: defun
#: original_texis/strings.texi:589
msgid ""
"If @var{ignore-case} is non-@code{nil}, characters are compared "
"case-insensitively, by converting them to lower-case.  However, if the "
"underlying system library doesn't provide locale-specific collation rules, "
"this function falls back to @code{string-equal}, in which case the "
"@var{ignore-case} argument is ignored, and the comparison will always be "
"case-sensitive."
msgstr ""

#. type: vindex
#: original_texis/strings.texi:590
#, no-wrap
msgid "w32-collate-ignore-punctuation"
msgstr ""

#. type: defun
#: original_texis/strings.texi:594 original_texis/strings.texi:722
msgid ""
"To emulate Unicode-compliant collation on MS-Windows systems, bind "
"@code{w32-collate-ignore-punctuation} to a non-@code{nil} value, since the "
"codeset part of the locale cannot be @code{\"UTF-8\"} on MS-Windows."
msgstr ""

#. type: defun
#: original_texis/strings.texi:597
msgid ""
"If your system does not support a locale environment, this function behaves "
"like @code{string-equal}."
msgstr ""

#. type: defun
#: original_texis/strings.texi:601
msgid ""
"Do @emph{not} use this function to compare file names for equality, as "
"filesystems generally don't honor linguistic equivalence of strings that "
"collation implements."
msgstr ""

#. type: cindex
#: original_texis/strings.texi:603
#, no-wrap
msgid "lexical comparison of strings"
msgstr ""

#. type: anchor{#1}
#: original_texis/strings.texi:605
msgid "definition of string-lessp"
msgstr ""

#. type: defun
#: original_texis/strings.texi:605
#, no-wrap
msgid "string-lessp string1 string2"
msgstr ""

#. type: defun
#: original_texis/strings.texi:613
msgid ""
"This function compares two strings a character at a time.  It scans both the "
"strings at the same time to find the first pair of corresponding characters "
"that do not match.  If the lesser character of these two is the character "
"from @var{string1}, then @var{string1} is less, and this function returns "
"@code{t}.  If the lesser character is the one from @var{string2}, then "
"@var{string1} is greater, and this function returns @code{nil}.  If the two "
"strings match entirely, the value is @code{nil}."
msgstr ""

#. type: defun
#: original_texis/strings.texi:621
msgid ""
"Pairs of characters are compared according to their character codes.  Keep "
"in mind that lower case letters have higher numeric values in the "
"@acronym{ASCII} character set than their upper case counterparts; digits and "
"many punctuation characters have a lower numeric value than upper case "
"letters.  An @acronym{ASCII} character is less than any non-@acronym{ASCII} "
"character; a unibyte non-@acronym{ASCII} character is always less than any "
"multibyte non-@acronym{ASCII} character (@pxref{Text Representations})."
msgstr ""

#. type: group
#: original_texis/strings.texi:630
#, no-wrap
msgid ""
"(string-lessp \"abc\" \"abd\")\n"
"     @result{} t\n"
"(string-lessp \"abd\" \"abc\")\n"
"     @result{} nil\n"
"(string-lessp \"123\" \"abc\")\n"
"     @result{} t\n"
msgstr ""

#. type: defun
#: original_texis/strings.texi:637
msgid ""
"When the strings have different lengths, and they match up to the length of "
"@var{string1}, then the result is @code{t}.  If they match up to the length "
"of @var{string2}, the result is @code{nil}.  A string of no characters is "
"less than any other string."
msgstr ""

#. type: group
#: original_texis/strings.texi:650
#, no-wrap
msgid ""
"(string-lessp \"\" \"abc\")\n"
"     @result{} t\n"
"(string-lessp \"ab\" \"abc\")\n"
"     @result{} t\n"
"(string-lessp \"abc\" \"\")\n"
"     @result{} nil\n"
"(string-lessp \"abc\" \"ab\")\n"
"     @result{} nil\n"
"(string-lessp \"\" \"\")\n"
"     @result{} nil\n"
msgstr ""

#. type: defun
#: original_texis/strings.texi:655
msgid ""
"Symbols are also allowed as arguments, in which case their print names are "
"compared."
msgstr ""

#. type: defun
#: original_texis/strings.texi:657
#, no-wrap
msgid "string< string1 string2"
msgstr ""

#. type: defun
#: original_texis/strings.texi:659
msgid "@code{string<} is another name for @code{string-lessp}."
msgstr ""

#. type: defun
#: original_texis/strings.texi:661
#, no-wrap
msgid "string-greaterp string1 string2"
msgstr ""

#. type: defun
#: original_texis/strings.texi:665
msgid ""
"This function returns the result of comparing @var{string1} and "
"@var{string2} in the opposite order, i.e., it is equivalent to calling "
"@code{(string-lessp @var{string2} @var{string1})}."
msgstr ""

#. type: defun
#: original_texis/strings.texi:667
#, no-wrap
msgid "string> string1 string2"
msgstr ""

#. type: defun
#: original_texis/strings.texi:669
msgid "@code{string>} is another name for @code{string-greaterp}."
msgstr ""

#. type: cindex
#: original_texis/strings.texi:671
#, no-wrap
msgid "locale-dependent string comparison"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:672
#, no-wrap
msgid "string collation"
msgstr ""

#. type: defun
#: original_texis/strings.texi:673
#, no-wrap
msgid "string-collate-lessp string1 string2 &optional locale ignore-case"
msgstr ""

#. type: defun
#: original_texis/strings.texi:682
msgid ""
"This function returns @code{t} if @var{string1} is less than @var{string2} "
"in collation order of the specified @var{locale}, which defaults to your "
"current system locale.  A collation order is not only determined by the "
"lexicographic order of the characters contained in @var{string1} and "
"@var{string2}, but also by further rules about relations between these "
"characters.  Usually, it is defined by the locale environment with which "
"Emacs is running, and by the Standard C library against which Emacs was "
"linked."
msgstr ""

#. type: defun
#: original_texis/strings.texi:685
msgid ""
"For example, punctuation and whitespace characters might be ignored for "
"sorting (@pxref{Sequence Functions}):"
msgstr ""

#. type: group
#: original_texis/strings.texi:691
#, no-wrap
msgid ""
"(sort '(\"11\" \"12\" \"1 1\" \"1 2\" \"1.1\" \"1.2\")\n"
"       :lessp #'string-collate-lessp)\n"
"     @result{} (\"11\" \"1 1\" \"1.1\" \"12\" \"1 2\" \"1.2\")\n"
msgstr ""

#. type: defun
#: original_texis/strings.texi:696
msgid ""
"This behavior is system-dependent; e.g., punctuation and whitespace are "
"never ignored on Cygwin, regardless of locale."
msgstr ""

#. type: defun
#: original_texis/strings.texi:703
msgid ""
"The optional argument @var{locale}, a string, overrides the setting of your "
"current locale identifier for collation.  The value is system dependent; a "
"@var{locale} @code{\"en_US.UTF-8\"} is applicable on POSIX systems, while it "
"would be, e.g., @code{\"enu_USA.1252\"} on MS-Windows systems.  The "
"@var{locale} value of @code{\"POSIX\"} or @code{\"C\"} lets "
"@code{string-collate-lessp} behave like @code{string-lessp}:"
msgstr ""

#. type: group
#: original_texis/strings.texi:709
#, no-wrap
msgid ""
"(sort '(\"11\" \"12\" \"1 1\" \"1 2\" \"1.1\" \"1.2\")\n"
"      :lessp (lambda (s1 s2) (string-collate-lessp s1 s2 \"POSIX\")))\n"
"     @result{} (\"1 1\" \"1 2\" \"1.1\" \"1.2\" \"11\" \"12\")\n"
msgstr ""

#. type: defun
#: original_texis/strings.texi:718
msgid ""
"If @var{ignore-case} is non-@code{nil}, characters are compared "
"case-insensitively, by converting them to lower-case.  However, if the "
"underlying system library doesn't provide locale-specific collation rules, "
"this function falls back to @code{string-lessp}, in which case the "
"@var{ignore-case} argument is ignored, and the comparison will always be "
"case-sensitive."
msgstr ""

#. type: defun
#: original_texis/strings.texi:725
msgid ""
"If your system does not support a locale environment, this function behaves "
"like @code{string-lessp}."
msgstr ""

#. type: cindex
#: original_texis/strings.texi:727
#, no-wrap
msgid "version comparison"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:728
#, no-wrap
msgid "comparing version strings"
msgstr ""

#. type: defun
#: original_texis/strings.texi:729
#, no-wrap
msgid "string-version-lessp string1 string2"
msgstr ""

#. type: defun
#: original_texis/strings.texi:735
msgid ""
"This function compares strings lexicographically, except it treats sequences "
"of numerical characters as if they comprised a base-ten number, and then "
"compares the numbers.  So @samp{foo2.png} is ``smaller'' than "
"@samp{foo12.png} according to this predicate, even if @samp{12} is "
"lexicographically ``smaller'' than @samp{2}."
msgstr ""

#. type: cindex
#: original_texis/strings.texi:737
#, no-wrap
msgid "string starts with prefix"
msgstr ""

#. type: defun
#: original_texis/strings.texi:738
#, no-wrap
msgid "string-prefix-p string1 string2 &optional ignore-case"
msgstr ""

#. type: defun
#: original_texis/strings.texi:743
msgid ""
"This function returns non-@code{nil} if @var{string1} is a prefix of "
"@var{string2}; i.e., if @var{string2} starts with @var{string1}.  If the "
"optional argument @var{ignore-case} is non-@code{nil}, the comparison "
"ignores case differences."
msgstr ""

#. type: cindex
#: original_texis/strings.texi:745
#, no-wrap
msgid "string ends with suffix"
msgstr ""

#. type: defun
#: original_texis/strings.texi:746
#, no-wrap
msgid "string-suffix-p suffix string &optional ignore-case"
msgstr ""

#. type: defun
#: original_texis/strings.texi:751
msgid ""
"This function returns non-@code{nil} if @var{suffix} is a suffix of "
"@var{string}; i.e., if @var{string} ends with @var{suffix}.  If the optional "
"argument @var{ignore-case} is non-@code{nil}, the comparison ignores case "
"differences."
msgstr ""

#. type: defun
#: original_texis/strings.texi:753
#, no-wrap
msgid "string-search needle haystack &optional start-pos"
msgstr ""

#. type: defun
#: original_texis/strings.texi:761
msgid ""
"Return the position of the first instance of @var{needle} in @var{haystack}, "
"both of which are strings.  If @var{start-pos} is non-@code{nil}, start "
"searching from that position in @var{haystack}.  Return @code{nil} if no "
"match was found.  This function only considers the characters in the strings "
"when doing the comparison; text properties are ignored.  Matching is always "
"case-sensitive."
msgstr ""

#. type: defun
#: original_texis/strings.texi:763
#, no-wrap
msgid ""
"compare-strings string1 start1 end1 string2 start2 end2 &optional "
"ignore-case"
msgstr ""

#. type: defun
#: original_texis/strings.texi:771
msgid ""
"This function compares a specified part of @var{string1} with a specified "
"part of @var{string2}.  The specified part of @var{string1} runs from index "
"@var{start1} (inclusive) up to index @var{end1} (exclusive); @code{nil} for "
"@var{start1} means the start of the string, while @code{nil} for @var{end1} "
"means the length of the string.  Likewise, the specified part of "
"@var{string2} runs from index @var{start2} up to index @var{end2}."
msgstr ""

#. type: defun
#: original_texis/strings.texi:781
msgid ""
"The strings are compared by the numeric values of their characters.  For "
"instance, @var{str1} is considered less than @var{str2} if its first "
"differing character has a smaller numeric value.  If @var{ignore-case} is "
"non-@code{nil}, characters are converted to upper-case, using the current "
"buffer's case-table (@pxref{Case Tables}), before comparing them.  Unibyte "
"strings are converted to multibyte for comparison (@pxref{Text "
"Representations}), so that a unibyte string and its conversion to multibyte "
"are always regarded as equal."
msgstr ""

#. type: defun
#: original_texis/strings.texi:788
msgid ""
"If the specified portions of the two strings match, the value is @code{t}.  "
"Otherwise, the value is an integer which indicates how many leading "
"characters agree, and which string is less.  Its absolute value is one plus "
"the number of characters that agree at the beginning of the two strings.  "
"The sign is negative if @var{string1} (or its specified portion) is less."
msgstr ""

#. type: cindex
#: original_texis/strings.texi:790
#, no-wrap
msgid "Levenshtein distance"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:791
#, no-wrap
msgid "distance between strings"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:792
#, no-wrap
msgid "edit distance between strings"
msgstr ""

#. type: defun
#: original_texis/strings.texi:793
#, no-wrap
msgid "string-distance string1 string2 &optional bytecompare"
msgstr ""

#. type: defun
#: original_texis/strings.texi:800
msgid ""
"This function returns the @dfn{Levenshtein distance} between the source "
"string @var{string1} and the target string @var{string2}.  The Levenshtein "
"distance is the number of single-character changes---deletions, insertions, "
"or replacements---required to transform the source string into the target "
"string; it is one possible definition of the @dfn{edit distance} between "
"strings."
msgstr ""

#. type: defun
#: original_texis/strings.texi:810
msgid ""
"Letter-case of the strings is significant for the computed distance, but "
"their text properties are ignored.  If the optional argument "
"@var{bytecompare} is non-@code{nil}, the function calculates the distance in "
"terms of bytes instead of characters.  The byte-wise comparison uses the "
"internal Emacs representation of characters, so it will produce inaccurate "
"results for multibyte strings that include raw bytes (@pxref{Text "
"Representations}); make the strings unibyte by encoding them "
"(@pxref{Explicit Encoding}) if you need accurate results with raw bytes."
msgstr ""

#. type: defun
#: original_texis/strings.texi:812
#, no-wrap
msgid "assoc-string key alist &optional case-fold"
msgstr ""

#. type: defun
#: original_texis/strings.texi:822
msgid ""
"This function works like @code{assoc}, except that @var{key} must be a "
"string or symbol, and comparison is done using @code{compare-strings}.  "
"Symbols are converted to strings before testing.  If @var{case-fold} is "
"non-@code{nil}, @var{key} and the elements of @var{alist} are converted to "
"upper-case before comparison.  Unlike @code{assoc}, this function can also "
"match elements of the alist that are strings or symbols rather than conses.  "
"In particular, @var{alist} can be a list of strings or symbols rather than "
"an actual alist.  @xref{Association Lists}."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:829
msgid ""
"See also the function @code{compare-buffer-substrings} in @ref{Comparing "
"Text}, for a way to compare text in buffers.  The function "
"@code{string-match}, which matches a regular expression against a string, "
"can be used for a kind of string comparison; see @ref{Regexp Search}."
msgstr ""

#. type: section
#: original_texis/strings.texi:831
#, no-wrap
msgid "Conversion of Characters and Strings"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:832
#, no-wrap
msgid "conversion of strings"
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:842
msgid ""
"This section describes functions for converting between characters, strings "
"and integers.  @code{format} (@pxref{Formatting Strings}) and "
"@code{prin1-to-string} (@pxref{Output Functions}) can also convert Lisp "
"objects into strings.  @code{read-from-string} (@pxref{Input Functions}) can "
"convert a string representation of a Lisp object into an object.  The "
"functions @code{string-to-multibyte} and @code{string-to-unibyte} convert "
"the text representation of a string (@pxref{Converting Representations})."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:847
msgid ""
"@xref{Documentation}, for functions that produce textual descriptions of "
"text characters and general input events (@code{single-key-description} and "
"@code{text-char-description}).  These are used primarily for making help "
"messages."
msgstr ""

#. type: defun
#: original_texis/strings.texi:848
#, no-wrap
msgid "number-to-string number"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:849
#, no-wrap
msgid "integer to string"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:850
#, no-wrap
msgid "integer to decimal"
msgstr ""

#. type: defun
#: original_texis/strings.texi:854
msgid ""
"This function returns a string consisting of the printed base-ten "
"representation of @var{number}.  The returned value starts with a minus sign "
"if the argument is negative."
msgstr ""

#. type: example
#: original_texis/strings.texi:858
#, no-wrap
msgid ""
"(number-to-string 256)\n"
"     @result{} \"256\"\n"
msgstr ""

#. type: group
#: original_texis/strings.texi:861
#, no-wrap
msgid ""
"(number-to-string -23)\n"
"     @result{} \"-23\"\n"
msgstr ""

#. type: example
#: original_texis/strings.texi:864
#, no-wrap
msgid ""
"(number-to-string -23.5)\n"
"     @result{} \"-23.5\"\n"
msgstr ""

#. type: code{#1}
#: original_texis/strings.texi:866
#, no-wrap
msgid "int-to-string"
msgstr ""

#. type: defun
#: original_texis/strings.texi:868
msgid "@code{int-to-string} is a semi-obsolete alias for this function."
msgstr ""

#. type: defun
#: original_texis/strings.texi:870
msgid "See also the function @code{format} in @ref{Formatting Strings}."
msgstr ""

#. type: defun
#: original_texis/strings.texi:872
#, no-wrap
msgid "string-to-number string &optional base"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:873
#, no-wrap
msgid "string to number"
msgstr ""

#. type: defun
#: original_texis/strings.texi:881
msgid ""
"This function returns the numeric value of the characters in @var{string}.  "
"If @var{base} is non-@code{nil}, it must be an integer between 2 and 16 "
"(inclusive), and integers are converted in that base.  If @var{base} is "
"@code{nil}, then base ten is used.  Floating-point conversion only works in "
"base ten; we have not implemented other radices for floating-point numbers, "
"because that would be much more work and does not seem useful."
msgstr ""

#. type: defun
#: original_texis/strings.texi:887
msgid ""
"The parsing skips spaces and tabs at the beginning of @var{string}, then "
"reads as much of @var{string} as it can interpret as a number in the given "
"base.  (On some systems it ignores other whitespace at the beginning, not "
"just spaces and tabs.)  If @var{string} cannot be interpreted as a number, "
"this function returns 0."
msgstr ""

#. type: example
#: original_texis/strings.texi:899
#, no-wrap
msgid ""
"(string-to-number \"256\")\n"
"     @result{} 256\n"
"(string-to-number \"25 is a perfect square.\")\n"
"     @result{} 25\n"
"(string-to-number \"X256\")\n"
"     @result{} 0\n"
"(string-to-number \"-4.5\")\n"
"     @result{} -4.5\n"
"(string-to-number \"1e5\")\n"
"     @result{} 100000.0\n"
msgstr ""

#. type: defun
#: original_texis/strings.texi:902
#, no-wrap
msgid "char-to-string character"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:903
#, no-wrap
msgid "character to string"
msgstr ""

#. type: defun
#: original_texis/strings.texi:907
msgid ""
"This function returns a new string containing one character, "
"@var{character}.  This function is semi-obsolete because the function "
"@code{string} is more general.  @xref{Creating Strings}."
msgstr ""

#. type: defun
#: original_texis/strings.texi:909
#, no-wrap
msgid "string-to-char string"
msgstr ""

#. type: defun
#: original_texis/strings.texi:916
msgid ""
"This function returns the first character in @var{string}.  This is mostly "
"identical to @w{@code{(aref string 0)}}, except that it returns 0 if the "
"string is empty.  (The value is also 0 when the first character of "
"@var{string} is the null character, @acronym{ASCII} code 0.)  This function "
"may be eliminated in the future if it does not seem useful enough to retain."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:919
msgid "Here are some other functions that can convert to or from a string:"
msgstr ""

#. type: item
#: original_texis/strings.texi:921
#, no-wrap
msgid "concat"
msgstr ""

#. type: table
#: original_texis/strings.texi:924
msgid ""
"This function converts a vector or a list into a string.  @xref{Creating "
"Strings}."
msgstr ""

#. type: item
#: original_texis/strings.texi:925
#, no-wrap
msgid "vconcat"
msgstr ""

#. type: table
#: original_texis/strings.texi:928
msgid "This function converts a string into a vector.  @xref{Vector Functions}."
msgstr ""

#. type: item
#: original_texis/strings.texi:929
#, no-wrap
msgid "append"
msgstr ""

#. type: table
#: original_texis/strings.texi:931
msgid "This function converts a string into a list.  @xref{Building Lists}."
msgstr ""

#. type: item
#: original_texis/strings.texi:932
#, no-wrap
msgid "byte-to-string"
msgstr ""

#. type: table
#: original_texis/strings.texi:935
msgid ""
"This function converts a byte of character data into a unibyte string.  "
"@xref{Converting Representations}."
msgstr ""

#. type: cindex
#: original_texis/strings.texi:939
#, no-wrap
msgid "formatting strings"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:940
#, no-wrap
msgid "strings, formatting them"
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:946
msgid ""
"@dfn{Formatting} means constructing a string by substituting computed values "
"at various places in a constant string.  This constant string controls how "
"the other values are printed, as well as where they appear; it is called a "
"@dfn{format string}."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:951
msgid ""
"Formatting is often useful for computing messages to be displayed.  In fact, "
"the functions @code{message} and @code{error} provide the same formatting "
"feature described here; they differ from @code{format-message} only in how "
"they use the result of formatting."
msgstr ""

#. type: defun
#: original_texis/strings.texi:952
#, no-wrap
msgid "format string &rest objects"
msgstr ""

#. type: defun
#: original_texis/strings.texi:956
msgid ""
"This function returns a string equal to @var{string}, replacing any format "
"specifications with encodings of the corresponding @var{objects}.  The "
"arguments @var{objects} are the computed values to be formatted."
msgstr ""

#. type: defun
#: original_texis/strings.texi:961
msgid ""
"The characters in @var{string}, other than the format specifications, are "
"copied directly into the output, including their text properties, if any.  "
"Any text properties of the format specifications are copied to the produced "
"string representations of the argument @var{objects}."
msgstr ""

#. type: defun
#: original_texis/strings.texi:966
msgid ""
"The output string need not be newly-allocated.  For example, if @code{x} is "
"the string @code{\"foo\"}, the expressions @code{(eq x (format x))} and "
"@code{(eq x (format \"%s\" x))} might both yield @code{t}."
msgstr ""

#. type: defun
#: original_texis/strings.texi:968
#, no-wrap
msgid "format-message string &rest objects"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:969
#, no-wrap
msgid "curved quotes, in formatted messages"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:970
#, no-wrap
msgid "curly quotes, in formatted messages"
msgstr ""

#. type: defun
#: original_texis/strings.texi:974
msgid ""
"This function acts like @code{format}, except it also converts any grave "
"accents (@t{`}) and apostrophes (@t{'}) in @var{string} as per the value of "
"@code{text-quoting-style}."
msgstr ""

#. type: defun
#: original_texis/strings.texi:979
msgid ""
"Typically grave accent and apostrophe in the format translate to matching "
"curved quotes, e.g., @t{\"Missing `%s'\"} might result in @t{\"Missing "
"foo\"}.  @xref{Text Quoting Style}, for how to influence or inhibit this "
"translation."
msgstr ""

#. type: cindex
#: original_texis/strings.texi:981
#, no-wrap
msgid "@samp{%} in format"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:982
#, no-wrap
msgid "format specification"
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:988
msgid ""
"A format specification is a sequence of characters beginning with a "
"@samp{%}.  Thus, if there is a @samp{%d} in @var{string}, the @code{format} "
"function replaces it with the printed representation of one of the values to "
"be formatted (one of the arguments @var{objects}).  For example:"
msgstr ""

#. type: group
#: original_texis/strings.texi:993
#, no-wrap
msgid ""
"(format \"The value of fill-column is %d.\" fill-column)\n"
"     @result{} \"The value of fill-column is 72.\"\n"
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1002
msgid ""
"Since @code{format} interprets @samp{%} characters as format specifications, "
"you should @emph{never} pass an arbitrary string as the first argument.  "
"This is particularly true when the string is generated by some Lisp code.  "
"Unless the string is @emph{known} to never include any @samp{%} characters, "
"pass @code{\"%s\"}, described below, as the first argument, and the string "
"as the second, like this:"
msgstr ""

#. type: example
#: original_texis/strings.texi:1005
#, no-wrap
msgid "  (format \"%s\" @var{arbitrary-string})\n"
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1010
msgid ""
"Certain format specifications require values of particular types.  If you "
"supply a value that doesn't fit the requirements, an error is signaled."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1012
msgid "Here is a table of valid format specifications:"
msgstr ""

#. type: item
#: original_texis/strings.texi:1014
#, no-wrap
msgid "%s"
msgstr ""

#. type: table
#: original_texis/strings.texi:1020
msgid ""
"Replace the specification with the printed representation of the object, "
"made without quoting (that is, using @code{princ}, not "
"@code{prin1}---@pxref{Output Functions}).  Thus, strings are represented by "
"their contents alone, with no @samp{\"} characters, and symbols appear "
"without @samp{\\} characters."
msgstr ""

#. type: table
#: original_texis/strings.texi:1024
msgid ""
"If the object is a string, its text properties are copied into the output.  "
"The text properties of the @samp{%s} itself are also copied, but those of "
"the object take priority."
msgstr ""

#. type: item
#: original_texis/strings.texi:1025
#, no-wrap
msgid "%S"
msgstr ""

#. type: table
#: original_texis/strings.texi:1030
msgid ""
"Replace the specification with the printed representation of the object, "
"made with quoting (that is, using @code{prin1}---@pxref{Output Functions}).  "
"Thus, strings are enclosed in @samp{\"} characters, and @samp{\\} characters "
"appear where necessary before special characters."
msgstr ""

#. type: item
#: original_texis/strings.texi:1031
#, no-wrap
msgid "%o"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:1032
#, no-wrap
msgid "integer to octal"
msgstr ""

#. type: table
#: original_texis/strings.texi:1037
msgid ""
"Replace the specification with the base-eight representation of an integer.  "
"Negative integers are formatted in a platform-dependent way.  The object can "
"also be a floating-point number that is formatted as an integer, dropping "
"any fraction."
msgstr ""

#. type: item
#: original_texis/strings.texi:1038
#, no-wrap
msgid "%d"
msgstr ""

#. type: table
#: original_texis/strings.texi:1042
msgid ""
"Replace the specification with the base-ten representation of a signed "
"integer.  The object can also be a floating-point number that is formatted "
"as an integer, dropping any fraction."
msgstr ""

#. type: item
#: original_texis/strings.texi:1043
#, no-wrap
msgid "%x"
msgstr ""

#. type: itemx
#: original_texis/strings.texi:1044
#, no-wrap
msgid "%X"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:1045
#, no-wrap
msgid "integer to hexadecimal"
msgstr ""

#. type: table
#: original_texis/strings.texi:1051
msgid ""
"Replace the specification with the base-sixteen representation of an "
"integer.  Negative integers are formatted in a platform-dependent way.  "
"@samp{%x} uses lower case and @samp{%X} uses upper case.  The object can "
"also be a floating-point number that is formatted as an integer, dropping "
"any fraction."
msgstr ""

#. type: item
#: original_texis/strings.texi:1052
#, no-wrap
msgid "%c"
msgstr ""

#. type: table
#: original_texis/strings.texi:1054
msgid "Replace the specification with the character which is the value given."
msgstr ""

#. type: item
#: original_texis/strings.texi:1055
#, no-wrap
msgid "%e"
msgstr ""

#. type: table
#: original_texis/strings.texi:1058
msgid ""
"Replace the specification with the exponential notation for a floating-point "
"number."
msgstr ""

#. type: item
#: original_texis/strings.texi:1059
#, no-wrap
msgid "%f"
msgstr ""

#. type: table
#: original_texis/strings.texi:1062
msgid ""
"Replace the specification with the decimal-point notation for a "
"floating-point number."
msgstr ""

#. type: item
#: original_texis/strings.texi:1063
#, no-wrap
msgid "%g"
msgstr ""

#. type: table
#: original_texis/strings.texi:1071
msgid ""
"Replace the specification with notation for a floating-point number, using "
"either exponential notation or decimal-point notation.  The exponential "
"notation is used if the exponent would be less than @minus{}4 or greater "
"than or equal to the precision (default: 6).  By default, trailing zeros are "
"removed from the fractional portion of the result and a decimal-point "
"character appears only if it is followed by a digit."
msgstr ""

#. type: item
#: original_texis/strings.texi:1072
#, no-wrap
msgid "%%"
msgstr ""

#. type: table
#: original_texis/strings.texi:1077
msgid ""
"Replace the specification with a single @samp{%}.  This format specification "
"is unusual in that its only form is plain @samp{%%} and that it does not use "
"a value.  For example, @code{(format \"%% %d\" 30)} returns @code{\"% 30\"}."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1081
msgid ""
"Any other format character results in an @samp{Invalid format operation} "
"error."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1084
msgid ""
"Here are several examples, which assume the typical "
"@code{text-quoting-style} settings:"
msgstr ""

#. type: group
#: original_texis/strings.texi:1091
#, no-wrap
msgid ""
"(format \"The octal value of %d is %o,\n"
"         and the hex value is %x.\" 18 18 18)\n"
"     @result{} \"The octal value of 18 is 22,\n"
"         and the hex value is 12.\"\n"
"\n"
msgstr ""

#. type: group
#: original_texis/strings.texi:1095
#, no-wrap
msgid ""
"(format-message\n"
" \"The name of this buffer is %s.\" (buffer-name))\n"
"     @result{} \"The name of this buffer is strings.texi.\"\n"
"\n"
msgstr ""

#. type: group
#: original_texis/strings.texi:1099
#, no-wrap
msgid ""
"(format-message\n"
" \"The buffer object prints as `%s'.\" (current-buffer))\n"
"     @result{} \"The buffer object prints as strings.texi.\"\n"
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1108
msgid ""
"By default, format specifications correspond to successive values from "
"@var{objects}.  Thus, the first format specification in @var{string} uses "
"the first such value, the second format specification uses the second such "
"value, and so on.  Any extra format specifications (those for which there "
"are no corresponding values) cause an error.  Any extra values to be "
"formatted are ignored."
msgstr ""

#. type: cindex
#: original_texis/strings.texi:1109
#, no-wrap
msgid "field numbers in format spec"
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1117
msgid ""
"A format specification can have a @dfn{field number}, which is a decimal "
"number immediately after the initial @samp{%}, followed by a literal dollar "
"sign @samp{$}.  It causes the format specification to convert the argument "
"with the given number instead of the next argument.  Field numbers start at "
"1.  A format can contain either numbered or unnumbered format specifications "
"but not both, except that @samp{%%} can be mixed with numbered "
"specifications."
msgstr ""

#. type: example
#: original_texis/strings.texi:1121
#, no-wrap
msgid ""
"(format \"%2$s, %3$s, %%, %1$s\" \"x\" \"y\" \"z\")\n"
"     @result{} \"y, z, %, x\"\n"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:1123
#, no-wrap
msgid "flags in format specifications"
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1126
msgid ""
"After the @samp{%} and any field number, you can put certain @dfn{flag "
"characters}."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1134
msgid ""
"The flag @samp{+} inserts a plus sign before a nonnegative number, so that "
"it always has a sign.  A space character as flag inserts a space before a "
"nonnegative number.  (Otherwise, nonnegative numbers start with the first "
"digit.)  These flags are useful for ensuring that nonnegative and negative "
"numbers use the same number of columns.  They are ignored except for "
"@samp{%d}, @samp{%e}, @samp{%f}, @samp{%g}, and if both flags are used, "
"@samp{+} takes precedence."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1143
msgid ""
"The flag @samp{#} specifies an alternate form which depends on the format in "
"use.  For @samp{%o}, it ensures that the result begins with a @samp{0}.  For "
"@samp{%x} and @samp{%X}, it prefixes nonzero results with @samp{0x} or "
"@samp{0X}.  For @samp{%e} and @samp{%f}, the @samp{#} flag means include a "
"decimal point even if the precision is zero.  For @samp{%g}, it always "
"includes a decimal point, and also forces any trailing zeros after the "
"decimal point to be left in place where they would otherwise be removed."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1149
msgid ""
"The flag @samp{0} ensures that the padding consists of @samp{0} characters "
"instead of spaces.  This flag is ignored for non-numerical specification "
"characters like @samp{%s}, @samp{%S} and @samp{%c}.  These specification "
"characters accept the @samp{0} flag, but still pad with @emph{spaces}."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1154
msgid ""
"The flag @samp{-} causes any padding inserted by the width, if specified, to "
"be inserted on the right rather than the left.  If both @samp{-} and "
"@samp{0} are present, the @samp{0} flag is ignored."
msgstr ""

#. type: group
#: original_texis/strings.texi:1159
#, no-wrap
msgid ""
"(format \"%06d is padded on the left with zeros\" 123)\n"
"     @result{} \"000123 is padded on the left with zeros\"\n"
"\n"
msgstr ""

#. type: group
#: original_texis/strings.texi:1162
#, no-wrap
msgid ""
"(format \"'%-6d' is padded on the right\" 123)\n"
"     @result{} \"'123   ' is padded on the right\"\n"
"\n"
msgstr ""

#. type: group
#: original_texis/strings.texi:1166
#, no-wrap
msgid ""
"(format \"The word '%-7s' actually has %d letters in it.\"\n"
"        \"foo\" (length \"foo\"))\n"
"     @result{} \"The word 'foo    ' actually has 3 letters in it.\"\n"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:1169
#, no-wrap
msgid "field width"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:1170
#, no-wrap
msgid "padding"
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1176
msgid ""
"A specification can have a @dfn{width}, which is a decimal number that "
"appears after any field number and flags.  If the printed representation of "
"the object contains fewer characters than this width, @code{format} extends "
"it with padding.  Any padding introduced by the width normally consists of "
"spaces inserted on the left:"
msgstr ""

#. type: example
#: original_texis/strings.texi:1180
#, no-wrap
msgid ""
"(format \"%5d is padded on the left with spaces\" 123)\n"
"     @result{} \"  123 is padded on the left with spaces\"\n"
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1191
msgid ""
"If the width is too small, @code{format} does not truncate the object's "
"printed representation.  Thus, you can use a width to specify a minimum "
"spacing between columns with no risk of losing information.  In the "
"following two examples, @samp{%7s} specifies a minimum width of 7.  In the "
"first case, the string inserted in place of @samp{%7s} has only 3 letters, "
"and needs 4 blank spaces as padding.  In the second case, the string "
"@code{\"specification\"} is 13 letters wide but is not truncated."
msgstr ""

#. type: group
#: original_texis/strings.texi:1200
#, no-wrap
msgid ""
"(format \"The word '%7s' has %d letters in it.\"\n"
"        \"foo\" (length \"foo\"))\n"
"     @result{} \"The word '    foo' has 3 letters in it.\"\n"
"(format \"The word '%7s' has %d letters in it.\"\n"
"        \"specification\" (length \"specification\"))\n"
"     @result{} \"The word 'specification' has 13 letters in it.\"\n"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:1203
#, no-wrap
msgid "precision in format specifications"
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1219
msgid ""
"All the specification characters allow an optional @dfn{precision} after the "
"field number, flags and width, if present.  The precision is a decimal-point "
"@samp{.} followed by a digit-string.  For the floating-point specifications "
"(@samp{%e} and @samp{%f}), the precision specifies how many digits following "
"the decimal point to show; if zero, the decimal-point itself is also "
"omitted.  For @samp{%g}, the precision specifies how many significant digits "
"to show (significant digits are the first digit before the decimal point and "
"all the digits after it).  If the precision of %g is zero or unspecified, it "
"is treated as 1.  For @samp{%s} and @samp{%S}, the precision truncates the "
"string to the given width, so @samp{%.3s} shows only the first three "
"characters of the representation for @var{object}.  For other specification "
"characters, the effect of precision is what the local library functions of "
"the @code{printf} family produce."
msgstr ""

#. type: cindex
#: original_texis/strings.texi:1220
#, no-wrap
msgid "formatting numbers for rereading later"
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1230
msgid ""
"If you plan to use @code{read} later on the formatted string to retrieve a "
"copy of the formatted value, use a specification that lets @code{read} "
"reconstruct the value.  To format numbers in this reversible way you can use "
"@samp{%s} and @samp{%S}, to format just integers you can also use @samp{%d}, "
"and to format just nonnegative integers you can also use @samp{#x%x} and "
"@samp{#o%o}.  Other formats may be problematic; for example, @samp{%d} and "
"@samp{%g} can mishandle NaNs and can lose precision and type, and "
"@samp{#x%x} and @samp{#o%o} can mishandle negative integers.  @xref{Input "
"Functions}."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1235
msgid ""
"The functions described in this section accept a fixed set of specification "
"characters.  The next section describes a function @code{format-spec} which "
"can accept custom specification characters, such as @samp{%a} or @samp{%z}."
msgstr ""

#. type: cindex
#: original_texis/strings.texi:1238
#, no-wrap
msgid "custom format string"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:1239
#, no-wrap
msgid "custom @samp{%}-sequence in format"
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1249
msgid ""
"Sometimes it is useful to allow users and Lisp programs alike to control how "
"certain text is generated via custom format control strings.  For example, a "
"format string could control how to display someone's forename, surname, and "
"email address.  Using the function @code{format} described in the previous "
"section, the format string could be something like @w{@code{\"%s %s "
"<%s>\"}}.  This approach quickly becomes impractical, however, as it can be "
"unclear which specification character corresponds to which piece of "
"information."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1255
msgid ""
"A more convenient format string for such cases would be something like "
"@w{@code{\"%f %l <%e>\"}}, where each specification character carries more "
"semantic information and can easily be rearranged relative to other "
"specification characters, making such format strings more easily "
"customizable by the user."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1259
msgid ""
"The function @code{format-spec} described in this section performs a similar "
"function to @code{format}, except it operates on format control strings that "
"use arbitrary specification characters."
msgstr ""

#. type: defun
#: original_texis/strings.texi:1260
#, no-wrap
msgid "format-spec template spec-alist &optional ignore-missing split"
msgstr ""

#. type: defun
#: original_texis/strings.texi:1267
msgid ""
"This function returns a string produced from the format string "
"@var{template} according to conversions specified in @var{spec-alist}, which "
"is an alist (@pxref{Association Lists}) of the form @w{@code{(@var{letter} "
". @var{replacement})}}.  Each specification @code{%@var{letter}} in "
"@var{template} will be replaced by @var{replacement} when formatting the "
"resulting string."
msgstr ""

#. type: defun
#: original_texis/strings.texi:1272
msgid ""
"The characters in @var{template}, other than the format specifications, are "
"copied directly into the output, including their text properties, if any.  "
"Any text properties of the format specifications are copied to their "
"replacements."
msgstr ""

#. type: defun
#: original_texis/strings.texi:1275
msgid "Using an alist to specify conversions gives rise to some useful properties:"
msgstr ""

#. type: itemize
#: original_texis/strings.texi:1281
msgid ""
"If @var{spec-alist} contains more unique @var{letter} keys than there are "
"unique specification characters in @var{template}, the unused keys are "
"simply ignored."
msgstr ""

#. type: itemize
#: original_texis/strings.texi:1284
msgid ""
"If @var{spec-alist} contains more than one association with the same "
"@var{letter}, the closest one to the start of the list is used."
msgstr ""

#. type: itemize
#: original_texis/strings.texi:1288
msgid ""
"If @var{template} contains the same specification character more than once, "
"then the same @var{replacement} found in @var{spec-alist} is used as a basis "
"for all of that character's substitutions."
msgstr ""

#. type: itemize
#: original_texis/strings.texi:1291
msgid ""
"The order of specifications in @var{template} need not correspond to the "
"order of associations in @var{spec-alist}."
msgstr ""

#. type: defun
#: original_texis/strings.texi:1297
msgid ""
"REPLACEMENT can also be a function taking no arguments, and returning a "
"string to be used for the replacement.  It will only be called when the "
"corresponding LETTER is used in the TEMPLATE.  This is useful, for example, "
"to avoid prompting for input unless it is needed."
msgstr ""

#. type: defun
#: original_texis/strings.texi:1307
msgid ""
"The optional argument @var{ignore-missing} indicates how to handle "
"specification characters in @var{template} that are not found in "
"@var{spec-alist}.  If it is @code{nil} or omitted, the function signals an "
"error; if it is @code{ignore}, those format specifications are left verbatim "
"in the output, including their text properties, if any; if it is "
"@code{delete}, those format specifications are removed from the output; any "
"other non-@code{nil} value is handled like @code{ignore}, but any "
"occurrences of @samp{%%} are also left verbatim in the output."
msgstr ""

#. type: defun
#: original_texis/strings.texi:1312
msgid ""
"If the optional argument @var{split} is non-@code{nil}, instead of returning "
"a single string, @code{format-spec} will split the result into a list of "
"strings, based on where the substitutions were performed.  For instance:"
msgstr ""

#. type: example
#: original_texis/strings.texi:1316
#, no-wrap
msgid ""
"(format-spec \"foo %b bar\" '((?b . \"zot\")) nil t)\n"
"     @result{} (\"foo \" \"zot\" \" bar\")\n"
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1324
msgid ""
"The syntax of format specifications accepted by @code{format-spec} is "
"similar, but not identical, to that accepted by @code{format}.  In both "
"cases, a format specification is a sequence of characters beginning with "
"@samp{%} and ending with an alphabetic letter such as @samp{s}."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1328
msgid ""
"Unlike @code{format}, which assigns specific meanings to a fixed set of "
"specification characters, @code{format-spec} accepts arbitrary specification "
"characters and treats them all equally.  For example:"
msgstr ""

#. type: group
#: original_texis/strings.texi:1340
#, no-wrap
msgid ""
"(setq my-site-info\n"
"      (list (cons ?s system-name)\n"
"            (cons ?t (symbol-name system-type))\n"
"            (cons ?c system-configuration)\n"
"            (cons ?v emacs-version)\n"
"            (cons ?e invocation-name)\n"
"            (cons ?p (number-to-string (emacs-pid)))\n"
"            (cons ?a user-mail-address)\n"
"            (cons ?n user-full-name)))\n"
"\n"
msgstr ""

#. type: group
#: original_texis/strings.texi:1343
#, no-wrap
msgid ""
"(format-spec \"%e %v (%c)\" my-site-info)\n"
"     @result{} \"emacs 27.1 (x86_64-pc-linux-gnu)\"\n"
"\n"
msgstr ""

#. type: group
#: original_texis/strings.texi:1346
#, no-wrap
msgid ""
"(format-spec \"%n <%a>\" my-site-info)\n"
"     @result{} \"Emacs Developers <emacs-devel@@gnu.org>\"\n"
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1352
msgid ""
"A format specification can include any number of the following flag "
"characters immediately after the @samp{%} to modify aspects of the "
"substitution."
msgstr ""

#. type: item
#: original_texis/strings.texi:1354
#, no-wrap
msgid "0"
msgstr ""

#. type: table
#: original_texis/strings.texi:1357
msgid ""
"This flag causes any padding specified by the width to consist of @samp{0} "
"characters instead of spaces."
msgstr ""

#. type: item
#: original_texis/strings.texi:1358
#, no-wrap
msgid "-"
msgstr ""

#. type: table
#: original_texis/strings.texi:1361
msgid ""
"This flag causes any padding specified by the width to be inserted on the "
"right rather than the left."
msgstr ""

#. type: item
#: original_texis/strings.texi:1362
#, no-wrap
msgid "<"
msgstr ""

#. type: table
#: original_texis/strings.texi:1365
msgid ""
"This flag causes the substitution to be truncated on the left to the given "
"width and precision, if specified."
msgstr ""

#. type: item
#: original_texis/strings.texi:1366
#, no-wrap
msgid ">"
msgstr ""

#. type: table
#: original_texis/strings.texi:1369
msgid ""
"This flag causes the substitution to be truncated on the right to the given "
"width and precision, if specified."
msgstr ""

#. type: item
#: original_texis/strings.texi:1370
#, no-wrap
msgid "^"
msgstr ""

#. type: table
#: original_texis/strings.texi:1373
msgid ""
"This flag converts the substituted text to upper case (@pxref{Case "
"Conversion})."
msgstr ""

#. type: item
#: original_texis/strings.texi:1374
#, no-wrap
msgid "_@r{ (underscore)}"
msgstr ""

#. type: table
#: original_texis/strings.texi:1377
msgid ""
"This flag converts the substituted text to lower case (@pxref{Case "
"Conversion})."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1381
msgid ""
"The result of using contradictory flags (for instance, both upper and lower "
"case) is undefined."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1386
msgid ""
"As is the case with @code{format}, a format specification can include a "
"width, which is a decimal number that appears after any flags, and a "
"precision, which is a decimal-point @samp{.} followed by a decimal number "
"that appears after any flags and width."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1389
msgid ""
"If a substitution contains fewer characters than its specified width, it is "
"padded on the left:"
msgstr ""

#. type: group
#: original_texis/strings.texi:1395
#, no-wrap
msgid ""
"(format-spec \"%8a is padded on the left with spaces\"\n"
"             '((?a . \"alpha\")))\n"
"     @result{} \"   alpha is padded on the left with spaces\"\n"
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1400
msgid ""
"If a substitution contains more characters than its specified precision, it "
"is truncated on the right:"
msgstr ""

#. type: group
#: original_texis/strings.texi:1406
#, no-wrap
msgid ""
"(format-spec \"%.2a is truncated on the right\"\n"
"             '((?a . \"alpha\")))\n"
"     @result{} \"al is truncated on the right\"\n"
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1411
msgid ""
"Here is a more complicated example that combines several aforementioned "
"features:"
msgstr ""

#. type: group
#: original_texis/strings.texi:1420
#, no-wrap
msgid ""
"(setq my-battery-info\n"
"      (list (cons ?p \"73\")      ; Percentage\n"
"            (cons ?L \"Battery\") ; Status\n"
"            (cons ?t \"2:23\")    ; Remaining time\n"
"            (cons ?c \"24330\")   ; Capacity\n"
"            (cons ?r \"10.6\")))  ; Rate of discharge\n"
"\n"
msgstr ""

#. type: group
#: original_texis/strings.texi:1423
#, no-wrap
msgid ""
"(format-spec \"%>^-3L : %3p%% (%05t left)\" my-battery-info)\n"
"     @result{} \"BAT :  73% (02:23 left)\"\n"
"\n"
msgstr ""

#. type: group
#: original_texis/strings.texi:1428
#, no-wrap
msgid ""
"(format-spec \"%>^-3L : %3p%% (%05t left)\"\n"
"             (cons (cons ?L \"AC\")\n"
"                   my-battery-info))\n"
"     @result{} \"AC  :  73% (02:23 left)\"\n"
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1437
msgid ""
"As the examples in this section illustrate, @code{format-spec} is often used "
"for selectively formatting an assortment of different pieces of "
"information.  This is useful in programs that provide user-customizable "
"format strings, as the user can choose to format with a regular syntax and "
"in any desired order only a subset of the information that the program makes "
"available."
msgstr ""

#. type: section
#: original_texis/strings.texi:1439
#, no-wrap
msgid "Case Conversion in Lisp"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:1440
#, no-wrap
msgid "upper case"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:1441
#, no-wrap
msgid "lower case"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:1442
#, no-wrap
msgid "character case"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:1443
#, no-wrap
msgid "case conversion in Lisp"
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1451
msgid ""
"The character case functions change the case of single characters or of the "
"contents of strings.  The functions normally convert only alphabetic "
"characters (the letters @samp{A} through @samp{Z} and @samp{a} through "
"@samp{z}, as well as non-@acronym{ASCII} letters); other characters are not "
"altered.  You can specify a different case conversion mapping by specifying "
"a case table (@pxref{Case Tables})."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1454
msgid ""
"These functions do not modify the strings that are passed to them as "
"arguments."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1457
msgid ""
"The examples below use the characters @samp{X} and @samp{x} which have "
"@acronym{ASCII} codes 88 and 120 respectively."
msgstr ""

#. type: defun
#: original_texis/strings.texi:1458
#, no-wrap
msgid "downcase string-or-char"
msgstr ""

#. type: defun
#: original_texis/strings.texi:1461
msgid ""
"This function converts @var{string-or-char}, which should be either a "
"character or a string, to lower case."
msgstr ""

#. type: defun
#: original_texis/strings.texi:1468
msgid ""
"When @var{string-or-char} is a string, this function returns a new string in "
"which each letter in the argument that is upper case is converted to lower "
"case.  When @var{string-or-char} is a character, this function returns the "
"corresponding lower case character (an integer); if the original character "
"is lower case, or is not a letter, the return value is equal to the original "
"character."
msgstr ""

#. type: example
#: original_texis/strings.texi:1472
#, no-wrap
msgid ""
"(downcase \"The cat in the hat\")\n"
"     @result{} \"the cat in the hat\"\n"
"\n"
msgstr ""

#. type: example
#: original_texis/strings.texi:1475
#, no-wrap
msgid ""
"(downcase ?X)\n"
"     @result{} 120\n"
msgstr ""

#. type: defun
#: original_texis/strings.texi:1478
#, no-wrap
msgid "upcase string-or-char"
msgstr ""

#. type: defun
#: original_texis/strings.texi:1481
msgid ""
"This function converts @var{string-or-char}, which should be either a "
"character or a string, to upper case."
msgstr ""

#. type: defun
#: original_texis/strings.texi:1488
msgid ""
"When @var{string-or-char} is a string, this function returns a new string in "
"which each letter in the argument that is lower case is converted to upper "
"case.  When @var{string-or-char} is a character, this function returns the "
"corresponding upper case character (an integer); if the original character "
"is upper case, or is not a letter, the return value is equal to the original "
"character."
msgstr ""

#. type: example
#: original_texis/strings.texi:1492
#, no-wrap
msgid ""
"(upcase \"The cat in the hat\")\n"
"     @result{} \"THE CAT IN THE HAT\"\n"
"\n"
msgstr ""

#. type: example
#: original_texis/strings.texi:1495
#, no-wrap
msgid ""
"(upcase ?x)\n"
"     @result{} 88\n"
msgstr ""

#. type: defun
#: original_texis/strings.texi:1498
#, no-wrap
msgid "capitalize string-or-char"
msgstr ""

#. type: cindex
#: original_texis/strings.texi:1499
#, no-wrap
msgid "capitalization"
msgstr ""

#. type: defun
#: original_texis/strings.texi:1506
msgid ""
"This function capitalizes strings or characters.  If @var{string-or-char} is "
"a string, the function returns a new string whose contents are a copy of "
"@var{string-or-char} in which each word has been capitalized.  This means "
"that the first character of each word is converted to upper case, and the "
"rest are converted to lower case."
msgstr ""

#. type: vindex
#: original_texis/strings.texi:1507
#, no-wrap
msgid "case-symbols-as-words"
msgstr ""

#. type: defun
#: original_texis/strings.texi:1513
msgid ""
"The definition of a word is any sequence of consecutive characters that are "
"assigned to the word constituent syntax class in the current syntax table "
"(@pxref{Syntax Class Table}); if @code{case-symbols-as-words} is "
"non-@code{nil}, characters assigned to the symbol constituent syntax class "
"are also considered as word constituent."
msgstr ""

#. type: defun
#: original_texis/strings.texi:1516
msgid ""
"When @var{string-or-char} is a character, this function does the same thing "
"as @code{upcase}."
msgstr ""

#. type: group
#: original_texis/strings.texi:1521
#, no-wrap
msgid ""
"(capitalize \"The cat in the hat\")\n"
"     @result{} \"The Cat In The Hat\"\n"
msgstr ""

#. type: group
#: original_texis/strings.texi:1526
#, no-wrap
msgid ""
"(capitalize \"THE 77TH-HATTED CAT\")\n"
"     @result{} \"The 77th-Hatted Cat\"\n"
msgstr ""

#. type: group
#: original_texis/strings.texi:1531
#, no-wrap
msgid ""
"(capitalize ?x)\n"
"     @result{} 88\n"
msgstr ""

#. type: defun
#: original_texis/strings.texi:1535
#, no-wrap
msgid "upcase-initials string-or-char"
msgstr ""

#. type: defun
#: original_texis/strings.texi:1541
msgid ""
"If @var{string-or-char} is a string, this function capitalizes the initials "
"of the words in @var{string-or-char}, without altering any letters other "
"than the initials.  It returns a new string whose contents are a copy of "
"@var{string-or-char}, in which each word has had its initial letter "
"converted to upper case."
msgstr ""

#. type: defun
#: original_texis/strings.texi:1545
msgid ""
"The definition of a word for this function is the same as described for "
"@code{capitalize} above, and @code{case-symbols-as-words} has the same "
"effect on word constituent characters."
msgstr ""

#. type: defun
#: original_texis/strings.texi:1548
msgid ""
"When the argument to @code{upcase-initials} is a character, "
"@code{upcase-initials} has the same result as @code{upcase}."
msgstr ""

#. type: group
#: original_texis/strings.texi:1553
#, no-wrap
msgid ""
"(upcase-initials \"The CAT in the hAt\")\n"
"     @result{} \"The CAT In The HAt\"\n"
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1563
msgid ""
"Note that case conversion is not a one-to-one mapping of codepoints and "
"length of the result may differ from length of the argument.  Furthermore, "
"because passing a character forces return type to be a character, functions "
"are unable to perform proper substitution and result may differ compared to "
"treating a one-character string.  For example:"
msgstr ""

#. type: group
#: original_texis/strings.texi:1569
#, no-wrap
msgid ""
"(upcase \"\")  ; note: single character, ligature \"fi\"\n"
"     @result{} \"FI\"\n"
msgstr ""

#. type: group
#: original_texis/strings.texi:1573
#, no-wrap
msgid ""
"(upcase ?)\n"
"     @result{} 64257  ; i.e. ?\n"
msgstr ""

#. type: group
#: original_texis/strings.texi:1581
#, no-wrap
msgid ""
"(upcase \"@r{fi}\")  ; note: single character, ligature \"fi\"\n"
"     @result{} \"FI\"\n"
msgstr ""

#. type: group
#: original_texis/strings.texi:1585
#, no-wrap
msgid ""
"(upcase ?@r{fi})\n"
"     @result{} 64257  ; i.e. ?@r{fi}\n"
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1593
msgid ""
"To avoid this, a character must first be converted into a string, using "
"@code{string} function, before being passed to one of the casing functions.  "
"Of course, no assumptions on the length of the result may be made."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1597
msgid ""
"Mapping for such special cases are taken from @code{special-uppercase}, "
"@code{special-lowercase} and @code{special-titlecase} @xref{Character "
"Properties}."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1600
msgid ""
"@xref{Text Comparison}, for functions that compare strings; some of them "
"ignore case differences, or can optionally ignore case differences."
msgstr ""

#. type: section
#: original_texis/strings.texi:1602
#, no-wrap
msgid "The Case Table"
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1611
msgid ""
"You can customize case conversion by installing a special @dfn{case table}.  "
"A case table specifies the mapping between upper case and lower case "
"letters.  It affects both the case conversion functions for Lisp objects "
"(see the previous section) and those that apply to text in the buffer "
"(@pxref{Case Changes}).  Each buffer has a case table; there is also a "
"standard case table which is used to initialize the case table of new "
"buffers."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1616
msgid ""
"A case table is a char-table (@pxref{Char-Tables}) whose subtype is "
"@code{case-table}.  This char-table maps each character into the "
"corresponding lower case character.  It has three extra slots, which hold "
"related tables:"
msgstr ""

#. type: item
#: original_texis/strings.texi:1618
#, no-wrap
msgid "upcase"
msgstr ""

#. type: table
#: original_texis/strings.texi:1621
msgid ""
"The upcase table maps each character into the corresponding upper case "
"character."
msgstr ""

#. type: item
#: original_texis/strings.texi:1621
#, no-wrap
msgid "canonicalize"
msgstr ""

#. type: table
#: original_texis/strings.texi:1624
msgid ""
"The canonicalize table maps all of a set of case-related characters into a "
"particular member of that set."
msgstr ""

#. type: item
#: original_texis/strings.texi:1624
#, no-wrap
msgid "equivalences"
msgstr ""

#. type: table
#: original_texis/strings.texi:1627
msgid ""
"The equivalences table maps each one of a set of case-related characters "
"into the next character in that set."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1631
msgid ""
"In simple cases, all you need to specify is the mapping to lower-case; the "
"three related tables will be calculated automatically from that one."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1636
msgid ""
"For some languages, upper and lower case letters are not in one-to-one "
"correspondence.  There may be two different lower case letters with the same "
"upper case equivalent.  In these cases, you need to specify the maps for "
"both lower case and upper case."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1643
msgid ""
"The extra table @var{canonicalize} maps each character to a canonical "
"equivalent; any two characters that are related by case-conversion have the "
"same canonical equivalent character.  For example, since @samp{a} and "
"@samp{A} are related by case-conversion, they should have the same canonical "
"equivalent character (which should be either @samp{a} for both of them, or "
"@samp{A} for both of them)."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1649
msgid ""
"The extra table @var{equivalences} is a map that cyclically permutes each "
"equivalence class (of characters with the same canonical equivalent).  (For "
"ordinary @acronym{ASCII}, this would map @samp{a} into @samp{A} and @samp{A} "
"into @samp{a}, and likewise for each set of equivalent characters.)"
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1657
msgid ""
"When constructing a case table, you can provide @code{nil} for "
"@var{canonicalize}; then Emacs fills in this slot from the lower case and "
"upper case mappings.  You can also provide @code{nil} for "
"@var{equivalences}; then Emacs fills in this slot from @var{canonicalize}.  "
"In a case table that is actually in use, those components are "
"non-@code{nil}.  Do not try to specify @var{equivalences} without also "
"specifying @var{canonicalize}."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1659
msgid "Here are the functions for working with case tables:"
msgstr ""

#. type: defun
#: original_texis/strings.texi:1660
#, no-wrap
msgid "case-table-p object"
msgstr ""

#. type: defun
#: original_texis/strings.texi:1663
msgid "This predicate returns non-@code{nil} if @var{object} is a valid case table."
msgstr ""

#. type: defun
#: original_texis/strings.texi:1665
#, no-wrap
msgid "set-standard-case-table table"
msgstr ""

#. type: defun
#: original_texis/strings.texi:1668
msgid ""
"This function makes @var{table} the standard case table, so that it will be "
"used in any buffers created subsequently."
msgstr ""

#. type: defun
#: original_texis/strings.texi:1670
#, no-wrap
msgid "standard-case-table"
msgstr ""

#. type: defun
#: original_texis/strings.texi:1672
msgid "This returns the standard case table."
msgstr ""

#. type: defun
#: original_texis/strings.texi:1674
#, no-wrap
msgid "current-case-table"
msgstr ""

#. type: defun
#: original_texis/strings.texi:1676
msgid "This function returns the current buffer's case table."
msgstr ""

#. type: defun
#: original_texis/strings.texi:1678
#, no-wrap
msgid "set-case-table table"
msgstr ""

#. type: defun
#: original_texis/strings.texi:1680
msgid "This sets the current buffer's case table to @var{table}."
msgstr ""

#. type: defmac
#: original_texis/strings.texi:1682
#, no-wrap
msgid "with-case-table table body@dots{}"
msgstr ""

#. type: defmac
#: original_texis/strings.texi:1689
msgid ""
"The @code{with-case-table} macro saves the current case table, makes "
"@var{table} the current case table, evaluates the @var{body} forms, and "
"finally restores the case table.  The return value is the value of the last "
"form in @var{body}.  The case table is restored even in case of an abnormal "
"exit via @code{throw} or error (@pxref{Nonlocal Exits})."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1700
msgid ""
"Some language environments modify the case conversions of @acronym{ASCII} "
"characters; for example, in the Turkish language environment, the "
"@acronym{ASCII} capital I is downcased into a Turkish dotless i (@samp{}).  "
"This can interfere with code that requires ordinary @acronym{ASCII} case "
"conversion, such as implementations of @acronym{ASCII}-based network "
"protocols.  In that case, use the @code{with-case-table} macro with the "
"variable @var{ascii-case-table}, which stores the unmodified case table for "
"the @acronym{ASCII} character set."
msgstr ""

#. type: defvar
#: original_texis/strings.texi:1701
#, no-wrap
msgid "ascii-case-table"
msgstr ""

#. type: defvar
#: original_texis/strings.texi:1704
msgid ""
"The case table for the @acronym{ASCII} character set.  This should not be "
"modified by any language environment settings."
msgstr ""

#. type: Plain text
#: original_texis/strings.texi:1711
msgid ""
"The following three functions are convenient subroutines for packages that "
"define non-@acronym{ASCII} character sets.  They modify the specified case "
"table @var{case-table}; they also modify the standard syntax table.  "
"@xref{Syntax Tables}.  Normally you would use these functions to change the "
"standard case table."
msgstr ""

#. type: defun
#: original_texis/strings.texi:1712
#, no-wrap
msgid "set-case-syntax-pair uc lc case-table"
msgstr ""

#. type: defun
#: original_texis/strings.texi:1715
msgid ""
"This function specifies a pair of corresponding letters, one upper case and "
"one lower case."
msgstr ""

#. type: defun
#: original_texis/strings.texi:1717
#, no-wrap
msgid "set-case-syntax-delims l r case-table"
msgstr ""

#. type: defun
#: original_texis/strings.texi:1720
msgid ""
"This function makes characters @var{l} and @var{r} a matching pair of "
"case-invariant delimiters."
msgstr ""

#. type: defun
#: original_texis/strings.texi:1722
#, no-wrap
msgid "set-case-syntax char syntax case-table"
msgstr ""

#. type: defun
#: original_texis/strings.texi:1725
msgid "This function makes @var{char} case-invariant, with syntax @var{syntax}."
msgstr ""

#. type: deffn
#: original_texis/strings.texi:1727
#, no-wrap
msgid "Command describe-buffer-case-table"
msgstr ""

#. type: deffn
#: original_texis/strings.texi:1730
msgid ""
"This command displays a description of the contents of the current buffer's "
"case table."
msgstr ""
