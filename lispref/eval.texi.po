# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Emacs 26.1\n"
"POT-Creation-Date: 2020-08-02 05:42+0900\n"
"PO-Revision-Date: 2020-07-13 21:49+0900\n"
"Last-Translator: Takeshi Ayanokoji <takeshi.ayanokoji@gmail.com>\n"
"Language-Team: Japanese <takeshi.ayanokoji@gmail.com>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: original_texis/eval.texi:6 original_texis/eval.texi:7
#, no-wrap
msgid "Evaluation"
msgstr "Evaluation"

#. type: cindex
#: original_texis/eval.texi:8
#, no-wrap
msgid "evaluation"
msgstr "evaluation"

#. type: cindex
#: original_texis/eval.texi:9 original_texis/eval.texi:10
#, no-wrap
msgid "interpreter"
msgstr "interpreter"

#. type: cindex
#: original_texis/eval.texi:11
#, no-wrap
msgid "value of expression"
msgstr "value of expression"

#. type: Plain text
#: original_texis/eval.texi:20
msgid "The @dfn{evaluation} of expressions in Emacs Lisp is performed by the @dfn{Lisp interpreter}---a program that receives a Lisp object as input and computes its @dfn{value as an expression}.  How it does this depends on the data type of the object, according to rules described in this chapter.  The interpreter runs automatically to evaluate portions of your program, but can also be called explicitly via the Lisp primitive function @code{eval}."
msgstr "Emacs Lispでの式の@dfn{評価(evaluation)}は、@dfn{Lispインタープリター} --- 入力としてLispオブジェクトを受け取り、それの@dfn{式としての値(value as an expression)}を計算する --- により処理されます。評価を行なう方法はそのオブジェクトのデータ型に依存していて、それはこのチャプターで説明するルールにより行なわれます。インタープリターはプログラムの一部を評価するために自動的に実行されますが、Lispプリミティブ関数の@code{eval}を通じて明示的に呼び出すこともできます。"

#. type: node
#: original_texis/eval.texi:29 original_texis/eval.texi:31
#, no-wrap
msgid "Intro Eval"
msgstr "Intro Eval"

#. type: menuentry
#: original_texis/eval.texi:29
msgid "Evaluation in the scheme of things."
msgstr "事の在り方における評価。"

#. type: node
#: original_texis/eval.texi:29 original_texis/eval.texi:103
#, no-wrap
msgid "Forms"
msgstr "Forms"

#. type: menuentry
#: original_texis/eval.texi:29
msgid "How various sorts of objects are evaluated."
msgstr "さまざまなオブジェクト類が評価される方法。"

#. type: section
#: original_texis/eval.texi:29 original_texis/eval.texi:508
#: original_texis/eval.texi:555 original_texis/eval.texi:556
#, no-wrap
msgid "Quoting"
msgstr "Quoting"

#. type: menuentry
#: original_texis/eval.texi:29
msgid "Avoiding evaluation (to put constants in the program)."
msgstr "(プログラム内に定数を配すことによる)評価の回避。"

#. type: section
#: original_texis/eval.texi:29 original_texis/eval.texi:620
#: original_texis/eval.texi:621
#, no-wrap
msgid "Backquote"
msgstr "Backquote"

#. type: menuentry
#: original_texis/eval.texi:29
msgid "Easier construction of list structure."
msgstr "リスト構文より簡単な構築。"

#. type: section
#: original_texis/eval.texi:29 original_texis/eval.texi:717
#: original_texis/eval.texi:718
#, no-wrap
msgid "Eval"
msgstr "Eval"

#. type: menuentry
#: original_texis/eval.texi:29
msgid "How to invoke the Lisp interpreter explicitly."
msgstr "Lispインタープリターを明示的に呼び出す方法。"

#. type: node
#: original_texis/eval.texi:29 original_texis/eval.texi:909
#, no-wrap
msgid "Deferred Eval"
msgstr ""

#. type: menuentry
#: original_texis/eval.texi:29
msgid "Deferred and lazy evaluation of forms."
msgstr ""

#. type: section
#: original_texis/eval.texi:32
#, no-wrap
msgid "Introduction to Evaluation"
msgstr "Introduction to Evaluation"

#. type: ifnottex
#: original_texis/eval.texi:40
msgid "The Lisp interpreter, or evaluator, is the part of Emacs that computes the value of an expression that is given to it.  When a function written in Lisp is called, the evaluator computes the value of the function by evaluating the expressions in the function body.  Thus, running any Lisp program really means running the Lisp interpreter."
msgstr "Lispインタープリター(またはLispエバリュエーター)はEmacsの一部であり、与えられた式の値を計算します。Lispで記述された関数が呼び出されると、エバリュエーターはその関数のbody(本文)の中の式を評価してその関数の値を計算します。したがってLispプログラムを実行するとは、実際にはLispインタープリターを実行することを意味します。"

#. type: cindex
#: original_texis/eval.texi:42
#, no-wrap
msgid "form"
msgstr "form"

#. type: cindex
#: original_texis/eval.texi:43
#, no-wrap
msgid "expression"
msgstr "expression"

#. type: cindex
#: original_texis/eval.texi:44
#, no-wrap
msgid "S-expression"
msgstr "S-expression"

#. type: cindex
#: original_texis/eval.texi:45
#, no-wrap
msgid "sexp"
msgstr "sexp"

#. type: Plain text
#: original_texis/eval.texi:54
msgid "A Lisp object that is intended for evaluation is called a @dfn{form} or @dfn{expression}@footnote{It is sometimes also referred to as an @dfn{S-expression} or @dfn{sexp}, but we generally do not use this terminology in this manual.}.  The fact that forms are data objects and not merely text is one of the fundamental differences between Lisp-like languages and typical programming languages.  Any object can be evaluated, but in practice only numbers, symbols, lists and strings are evaluated very often."
msgstr "評価を意図したLispオブジェクトは@dfn{フォーム(form)}、または@dfn{式(expression)}と呼ばれます@footnote{@dfn{S式(S-expression)}、短くは@dfn{sexp}という言葉でも呼ばれることがありますが、わたしたちはこのマニュアル内では通常はこの用語は使用しません。}。フォームはデータオブジェクトであって単なるテキストではないという事実は、Lisp風の言語と通常のプログラミング言語との間にある基本的な相違点の1つです。任意のオブジェクトを評価できますが、実際に評価される事が非常に多いのは数字、シンボル、リスト、文字列です。"

#. type: Plain text
#: original_texis/eval.texi:57
msgid "In subsequent sections, we will describe the details of what evaluation means for each kind of form."
msgstr "以降のセクションでは、各種フォームにたいしてそれを評価することが何を意味するかの詳細を説明します。"

#. type: Plain text
#: original_texis/eval.texi:65
msgid "It is very common to read a Lisp form and then evaluate the form, but reading and evaluation are separate activities, and either can be performed alone.  Reading per se does not evaluate anything; it converts the printed representation of a Lisp object to the object itself.  It is up to the caller of @code{read} to specify whether this object is a form to be evaluated, or serves some entirely different purpose.  @xref{Input Functions}."
msgstr "Lispフォームを読み取ってそのフォームを評価するのは、非常に一般的なアクティビティーですが、読み取りと評価は別のアクティビティーであって、どちらか一方を単独で処理することができます。読み取っただけでは何も評価されません。読み取りはLispオブジェクトのプリント表現をそのオブジェクト自体に変換します。そのオブジェクトが評価されるべきフォームなのか、そのれともまったく違う目的をもつかを指定するのは、@code{read}の呼び出し元の役目です。@ref{Input Functions}を参照してください。"

#. type: cindex
#: original_texis/eval.texi:66
#, no-wrap
msgid "recursive evaluation"
msgstr "recursive evaluation"

#. type: Plain text
#: original_texis/eval.texi:77
msgid "Evaluation is a recursive process, and evaluating a form often involves evaluating parts within that form.  For instance, when you evaluate a @dfn{function call} form such as @code{(car x)}, Emacs first evaluates the argument (the subform @code{x}).  After evaluating the argument, Emacs @dfn{executes} the function (@code{car}), and if the function is written in Lisp, execution works by evaluating the @dfn{body} of the function (in this example, however, @code{car} is not a Lisp function; it is a primitive function implemented in C).  @xref{Functions}, for more information about functions and function calls."
msgstr "評価とは再帰的な処理であり、あるフォームを評価するとそのフォームの一部が評価されるといったことがよくあります。たとえば@code{(car x)}のような@dfn{関数呼び出し(function call)}のフォームを評価する場合、Emacsは最初にその引数(サブフォーム@code{x})を評価します。引数を評価した後、Emacsはその関数(@code{car})を@dfn{実行(executes)}します。その関数がLispで記述されていれば、関数の@dfn{body(本文)}を評価することによって実行が行なわれます(しかしこの例で使用している@code{car}はLisp関数ではなくCで実装されたプリミティブ関数である)。関数と関数呼び出しについての情報は@ref{Functions}を参照してください。"

#. type: cindex
#: original_texis/eval.texi:78
#, no-wrap
msgid "environment"
msgstr "environment"

#. type: Plain text
#: original_texis/eval.texi:88
msgid "Evaluation takes place in a context called the @dfn{environment}, which consists of the current values and bindings of all Lisp variables (@pxref{Variables}).@footnote{This definition of ``environment'' is specifically not intended to include all the data that can affect the result of a program.} Whenever a form refers to a variable without creating a new binding for it, the variable evaluates to the value given by the current environment.  Evaluating a form may also temporarily alter the environment by binding variables (@pxref{Local Variables})."
msgstr "評価は@dfn{環境(environment)}と呼ばれるコンテキストの内部で行なわれます。環境はすべてのLisp変数(@ref{Variables}を参照)のカレント値とバインディングにより構成されます。@footnote{``環境''にたいするこの定義は、プログラムの結果に影響し得るすべてのデータを特に意図したものではありません。}フォームが新たなバインディングを作成せずに変数を参照する際、その変数はカレントの環境から与えられる値へと評価されます。フォームの評価は、変数のバインディングによって一時的にその環境を変更することもあります(@ref{Local Variables}を参照)。"

#. type: cindex
#: original_texis/eval.texi:89
#, no-wrap
msgid "side effect"
msgstr "side effect"

#. type: anchor{#1}
#: original_texis/eval.texi:94
msgid "Definition of side effect"
msgstr "Definition of side effect"

#. type: Plain text
#: original_texis/eval.texi:94
msgid "Evaluating a form may also make changes that persist; these changes are called @dfn{side effects}.  An example of a form that produces a side effect is @code{(setq foo 1)}."
msgstr "フォームの評価が永続する変更を行なうこともあります。これらの変更は@dfn{副作用(side effects)}と呼ばれます。副作用を生成するフォームの例は@code{(setq foo 1)}です。"

#. type: Plain text
#: original_texis/eval.texi:102
msgid "Do not confuse evaluation with command key interpretation.  The editor command loop translates keyboard input into a command (an interactively callable function) using the active keymaps, and then uses @code{call-interactively} to execute that command.  Executing the command usually involves evaluation, if the command is written in Lisp; however, this step is not considered a part of command key interpretation.  @xref{Command Loop}."
msgstr "コマンドキー解釈での評価と混同しないでください。エディターのコマンドループはアクティブなキーマップを使用して、キーボード入力をコマンド(インタラクティブに呼び出すことができる関数)に変換してからそのコマンドを実行するために、@code{call-interactively}を使用します。そのコマンドがLispで記述されていれば、そのコマンドの実行には通常は評価を伴います。しかしこのステップはコマンドキー解釈の一部とは考えません。@ref{Command Loop}を参照してください。"

#. type: section
#: original_texis/eval.texi:104
#, no-wrap
msgid "Kinds of Forms"
msgstr "Kinds of Forms"

#. type: Plain text
#: original_texis/eval.texi:112
msgid "A Lisp object that is intended to be evaluated is called a @dfn{form} (or an @dfn{expression}).  How Emacs evaluates a form depends on its data type.  Emacs has three different kinds of form that are evaluated differently: symbols, lists, and all other types.  This section describes all three kinds, one by one, starting with the other types, which are self-evaluating forms."
msgstr "評価される事を意図したLispオブジェクトは@dfn{フォーム(form)}、または@dfn{式(expression)})と呼ばれます。Emacsがフォームを評価する方法はフォームのデータ型に依存します。Emacsは3種の異なるフォーム --- シンボル、リスト、およびその他すべての型 --- をもち、それらが評価される方法は異なります。このセクションではまず最初に自己評価フォームのその他の型から開始して、3つの種類をすべて1つずつ説明します。"

#. type: subsection
#: original_texis/eval.texi:125 original_texis/eval.texi:127
#: original_texis/eval.texi:128
#, no-wrap
msgid "Self-Evaluating Forms"
msgstr "Self-Evaluating Forms"

#. type: menuentry
#: original_texis/eval.texi:125
msgid "Forms that evaluate to themselves."
msgstr "自分自身を評価するフォーム。"

#. type: subsection
#: original_texis/eval.texi:125 original_texis/eval.texi:188
#: original_texis/eval.texi:189
#, no-wrap
msgid "Symbol Forms"
msgstr "Symbol Forms"

#. type: menuentry
#: original_texis/eval.texi:125
msgid "Symbols evaluate as variables."
msgstr "変数として評価されるシンボル。"

#. type: node
#: original_texis/eval.texi:125 original_texis/eval.texi:226
#, no-wrap
msgid "Classifying Lists"
msgstr "Classifying Lists"

#. type: menuentry
#: original_texis/eval.texi:125
msgid "How to distinguish various sorts of list forms."
msgstr "さまざまな種類のリストフォームを区別する方法。"

#. type: node
#: original_texis/eval.texi:125 original_texis/eval.texi:243
#, no-wrap
msgid "Function Indirection"
msgstr "Function Indirection"

#. type: menuentry
#: original_texis/eval.texi:125
msgid "When a symbol appears as the car of a list, we find the real function via the symbol."
msgstr "シンボルがリストのcarにあればそのシンボルを通じて実際の関数を見つける。"

#. type: node
#: original_texis/eval.texi:125 original_texis/eval.texi:360
#, no-wrap
msgid "Function Forms"
msgstr "Function Forms"

#. type: menuentry
#: original_texis/eval.texi:125
msgid "Forms that call functions."
msgstr "関数を呼び出すフォーム。"

#. type: node
#: original_texis/eval.texi:125 original_texis/eval.texi:385
#, no-wrap
msgid "Macro Forms"
msgstr "Macro Forms"

#. type: menuentry
#: original_texis/eval.texi:125
msgid "Forms that call macros."
msgstr "マクロを呼び出すフォーム。"

#. type: subsection
#: original_texis/eval.texi:125 original_texis/eval.texi:432
#: original_texis/eval.texi:433
#, no-wrap
msgid "Special Forms"
msgstr "Special Forms"

#. type: menuentry
#: original_texis/eval.texi:125
msgid "Special forms are idiosyncratic primitives, most of them extremely important."
msgstr "スペシャルフォームは特異なプリミティブであり、それらのほとんどがとても重要である。"

#. type: subsection
#: original_texis/eval.texi:125 original_texis/eval.texi:543
#: original_texis/eval.texi:544
#, no-wrap
msgid "Autoloading"
msgstr "Autoloading"

#. type: menuentry
#: original_texis/eval.texi:125
msgid "Functions set up to load files containing their real definitions."
msgstr "実際の定義を含むファイルのロードをセットアップする関数。"

#. type: cindex
#: original_texis/eval.texi:129
#, no-wrap
msgid "vector evaluation"
msgstr "vector evaluation"

#. type: cindex
#: original_texis/eval.texi:130
#, no-wrap
msgid "literal evaluation"
msgstr "literal evaluation"

#. type: cindex
#: original_texis/eval.texi:131
#, no-wrap
msgid "self-evaluating form"
msgstr "self-evaluating form"

#. type: cindex
#: original_texis/eval.texi:132
#, no-wrap
msgid "form, self-evaluating"
msgstr "form, self-evaluating"

#. type: Plain text
#: original_texis/eval.texi:141
msgid "A @dfn{self-evaluating form} is any form that is not a list or symbol.  Self-evaluating forms evaluate to themselves: the result of evaluation is the same object that was evaluated.  Thus, the number 25 evaluates to 25, and the string @code{\"foo\"} evaluates to the string @code{\"foo\"}.  Likewise, evaluating a vector does not cause evaluation of the elements of the vector---it returns the same vector with its contents unchanged."
msgstr "@dfn{自己評価フォーム(self-evaluating form)}はリストやシンボルではないすべてのフォームです。自己評価フォームはそのフォーム自身を評価します。評価の結果は評価されたオブジェクトと同じです。したがって数字の25は25、文字列@code{\"foo\"}は文字列@code{\"foo\"}に評価されます。同様にベクターの評価では、ベクターの要素の評価は発生しません --- 内容が変更されずに同じベクターがリターンされます。"

#. type: group
#: original_texis/eval.texi:146
#, no-wrap
msgid ""
"'123               ; @r{A number, shown without evaluation.}\n"
"     @result{} 123\n"
msgstr ""
"'123               ; @r{評価されずに表示される数字}\n"
"     @result{} 123\n"

#. type: group
#: original_texis/eval.texi:150
#, no-wrap
msgid ""
"123                ; @r{Evaluated as usual---result is the same.}\n"
"     @result{} 123\n"
msgstr ""
"123                ; @r{通常どおり評価され、同じものがreturnされる}\n"
"     @result{} 123\n"

#. type: group
#: original_texis/eval.texi:154
#, no-wrap
msgid ""
"(eval '123)        ; @r{Evaluated \"by hand\"---result is the same.}\n"
"     @result{} 123\n"
msgstr ""
"(eval '123)        ; @r{手動での評価 --- 同じものがreturnされる}\n"
"     @result{} 123\n"

#. type: group
#: original_texis/eval.texi:158
#, no-wrap
msgid ""
"(eval (eval '123)) ; @r{Evaluating twice changes nothing.}\n"
"     @result{} 123\n"
msgstr ""
"(eval (eval '123)) ; @r{2度評価しても何も変わらない。}\n"
"     @result{} 123\n"

#. type: Plain text
#: original_texis/eval.texi:166
msgid "A self-evaluating form yields a value that becomes part of the program, and you should not try to modify it via @code{setcar}, @code{aset} or similar operations.  The Lisp interpreter might unify the constants yielded by your program's self-evaluating forms, so that these constants might share structure.  @xref{Mutability}."
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:173
msgid "It is common to write numbers, characters, strings, and even vectors in Lisp code, taking advantage of the fact that they self-evaluate.  However, it is quite unusual to do this for types that lack a read syntax, because there's no way to write them textually.  It is possible to construct Lisp expressions containing these types by means of a Lisp program.  Here is an example:"
msgstr "自己評価されるという事実による利点から数字、文字、文字列、そしてベクターでさえLispコード内で記述されるのが一般的です。しかし入力構文がない型にたいしてこれを行なうのは極めて異例です。なぜなら、これらをテキスト的に記述する方法がないからです。Lispプログラムを使用してこれらの型を含むLisp式を構築することは可能です。以下は例です:"

#. type: group
#: original_texis/eval.texi:179
#, no-wrap
msgid ""
";; @r{Build an expression containing a buffer object.}\n"
"(setq print-exp (list 'print (current-buffer)))\n"
"     @result{} (print #<buffer eval.texi>)\n"
msgstr ""
";; @r{バッファーオブジェクトを含む式を構築する。}\n"
"(setq print-exp (list 'print (current-buffer)))\n"
"     @result{} (print #<buffer eval.texi>)\n"

#. type: group
#: original_texis/eval.texi:185
#, no-wrap
msgid ""
";; @r{Evaluate it.}\n"
"(eval print-exp)\n"
"     @print{} #<buffer eval.texi>\n"
"     @result{} #<buffer eval.texi>\n"
msgstr ""
";; @r{それを評価する。}\n"
"(eval print-exp)\n"
"     @print{} #<buffer eval.texi>\n"
"     @result{} #<buffer eval.texi>\n"

#. type: cindex
#: original_texis/eval.texi:190
#, no-wrap
msgid "symbol evaluation"
msgstr "symbol evaluation"

#. type: cindex
#: original_texis/eval.texi:191
#, no-wrap
msgid "symbol forms"
msgstr "symbol forms"

#. type: cindex
#: original_texis/eval.texi:192
#, no-wrap
msgid "forms, symbol"
msgstr "forms, symbol"

#. type: Plain text
#: original_texis/eval.texi:198
msgid "When a symbol is evaluated, it is treated as a variable.  The result is the variable's value, if it has one.  If the symbol has no value as a variable, the Lisp interpreter signals an error.  For more information on the use of variables, see @ref{Variables}."
msgstr "シンボルが評価されるときは変数として扱われます。それが値をもつなら結果はその変数の値になります。そのシンボルが変数としての値をもたなければ、Lispインタープリターはエラーをシグナルします。変数の使用法についての情報は@ref{Variables}を参照してください。"

#. type: Plain text
#: original_texis/eval.texi:202
msgid "In the following example, we set the value of a symbol with @code{setq}.  Then we evaluate the symbol, and get back the value that @code{setq} stored."
msgstr "以降の例では@code{setq}でシンボルに値をセットしています。その後シンボルを評価してからを@code{setq}に戻します。"

#. type: group
#: original_texis/eval.texi:207
#, no-wrap
msgid ""
"(setq a 123)\n"
"     @result{} 123\n"
msgstr ""
"(setq a 123)\n"
"     @result{} 123\n"

#. type: group
#: original_texis/eval.texi:211
#, no-wrap
msgid ""
"(eval 'a)\n"
"     @result{} 123\n"
msgstr ""
"(eval 'a)\n"
"     @result{} 123\n"

#. type: group
#: original_texis/eval.texi:215
#, no-wrap
msgid ""
"a\n"
"     @result{} 123\n"
msgstr ""
"a\n"
"     @result{} 123\n"

#. type: Plain text
#: original_texis/eval.texi:225
msgid "The symbols @code{nil} and @code{t} are treated specially, so that the value of @code{nil} is always @code{nil}, and the value of @code{t} is always @code{t}; you cannot set or bind them to any other values.  Thus, these two symbols act like self-evaluating forms, even though @code{eval} treats them like any other symbol.  A symbol whose name starts with @samp{:} also self-evaluates in the same way; likewise, its value ordinarily cannot be changed.  @xref{Constant Variables}."
msgstr "シンボル@code{nil}と@code{t}は特別に扱われるので、@code{nil}の値は常に@code{nil}、@code{t}の値は常に@code{t}になります。これらに他の値をセットしたり、他の値にバインドすることはできません。したがってこの2つのシンボルは、(たとえ@code{eval}がそれらを他の任意のシンボルと同様に扱うとはいえ)自己評価フォームと同じように振る舞います。名前が@samp{:}で始まるシンボルも同じ方法で自己評価されます。そして、(通常は)値を変更できない点も同じです。@ref{Constant Variables}を参照してください。"

#. type: subsection
#: original_texis/eval.texi:227
#, no-wrap
msgid "Classification of List Forms"
msgstr "Classification of List Forms"

#. type: cindex
#: original_texis/eval.texi:228
#, no-wrap
msgid "list form evaluation"
msgstr "list form evaluation"

#. type: cindex
#: original_texis/eval.texi:229
#, no-wrap
msgid "forms, list"
msgstr "forms, list"

#. type: Plain text
#: original_texis/eval.texi:236
msgid "A form that is a nonempty list is either a function call, a macro call, or a special form, according to its first element.  These three kinds of forms are evaluated in different ways, described below.  The remaining list elements constitute the @dfn{arguments} for the function, macro, or special form."
msgstr "空ではないリストフォームは関数呼び出し、マクロ呼び出し、スペシャルフォームのいずれかで、それは1番目の引数にしたがいます。これら3種のフォームは、以下で説明するように異なる方法で評価されます。残りの要素は関数、マクロ、またはスペシャルフォームにたいする@dfn{引数(arguments)}を構成します。"

#. type: Plain text
#: original_texis/eval.texi:242
msgid "The first step in evaluating a nonempty list is to examine its first element.  This element alone determines what kind of form the list is and how the rest of the list is to be processed.  The first element is @emph{not} evaluated, as it would be in some Lisp dialects such as Scheme."
msgstr "空ではないリストを評価する最初のステップは、1番目の要素の確認です。この要素は単独でそのリストがどの種類のフォームなのかと、残りの引数をどのように処理するがを決定します。SchemeのようなLisp方言とは異なり、1番目の要素は評価されません。"

#. type: subsection
#: original_texis/eval.texi:244
#, no-wrap
msgid "Symbol Function Indirection"
msgstr "Symbol Function Indirection"

#. type: cindex
#: original_texis/eval.texi:245
#, no-wrap
msgid "symbol function indirection"
msgstr "symbol function indirection"

#. type: cindex
#: original_texis/eval.texi:246
#, no-wrap
msgid "indirection for functions"
msgstr "indirection for functions"

#. type: cindex
#: original_texis/eval.texi:247
#, no-wrap
msgid "void function"
msgstr "void function"

#. type: Plain text
#: original_texis/eval.texi:255
msgid "If the first element of the list is a symbol then evaluation examines the symbol's function cell, and uses its contents instead of the original symbol.  If the contents are another symbol, this process, called @dfn{symbol function indirection}, is repeated until it obtains a non-symbol.  @xref{Function Names}, for more information about symbol function indirection."
msgstr "リストの最初の要素がシンボルなら、評価はそのシンボルの関数セルを調べて、元のシンボルの代わりに関数セルの内容を使用します。その内容が他のシンボルなら、シンボルではないものが得られるまでこのプロセスが繰り返されます。このプロセスのことを@dfn{シンボル関数インダイレクション(symbol function indirection: indirectionは間接の意)}と呼びます。シンボル関数インダイレクションについての情報は@ref{Function Names}を参照してください。"

#. type: Plain text
#: original_texis/eval.texi:260
msgid "One possible consequence of this process is an infinite loop, in the event that a symbol's function cell refers to the same symbol.  Otherwise, we eventually obtain a non-symbol, which ought to be a function or other suitable object."
msgstr "このプロセスの結果、シンボルの関数セルが同じシンボルを参照する場合には、無限ループを起こす可能性があります。それ以外なら最終的には非シンボルにたどりつき、それは関数か他の適切なオブジェクトである必要があります。"

#. type: kindex
#: original_texis/eval.texi:261
#, no-wrap
msgid "invalid-function"
msgstr "invalid-function"

#. type: Plain text
#: original_texis/eval.texi:267
msgid "More precisely, we should now have a Lisp function (a lambda expression), a byte-code function, a primitive function, a Lisp macro, a special form, or an autoload object.  Each of these types is a case described in one of the following sections.  If the object is not one of these types, Emacs signals an @code{invalid-function} error."
msgstr "適切なオブジェクトとは、より正確にはLisp関数(ラムダ式)、バイトコード関数、プリミティブ関数、Lispマクロ、スペシャルフォーム、またはオートロードオブジェクトです。これらそれぞれの型については以降のセクションで説明します。これらの型以外のオブジェクトならEmacsは@code{invalid-function}エラーをシグナルします。"

#. type: Plain text
#: original_texis/eval.texi:274
msgid "The following example illustrates the symbol indirection process.  We use @code{fset} to set the function cell of a symbol and @code{symbol-function} to get the function cell contents (@pxref{Function Cells}).  Specifically, we store the symbol @code{car} into the function cell of @code{first}, and the symbol @code{first} into the function cell of @code{erste}."
msgstr "以下の例はシンボルインダイレクションのプロセスを説明するものです。わたしたちはシンボルの関数セルへの関数のセットに@code{fset}、関数セルの内容(@ref{Function Cells}を参照)の取得に@code{symbol-function}を使用します。具体的には@code{first}の関数セルにシンボル@code{car}を格納して、シンボル@code{first}を@code{erste}の関数セルに格納します。"

#. type: group
#: original_texis/eval.texi:281
#, no-wrap
msgid ""
";; @r{Build this function cell linkage:}\n"
";;   -------------       -----        -------        -------\n"
";;  | #<subr car> | <-- | car |  <-- | first |  <-- | erste |\n"
";;   -------------       -----        -------        -------\n"
msgstr ""
";; @r{この関数セルのリンクを構築する:}\n"
";;   -------------       -----        -------        -------\n"
";;  | #<subr car> | <-- | car |  <-- | first |  <-- | erste |\n"
";;   -------------       -----        -------        -------\n"

#. type: group
#: original_texis/eval.texi:285
#, no-wrap
msgid ""
"(symbol-function 'car)\n"
"     @result{} #<subr car>\n"
msgstr ""
"(symbol-function 'car)\n"
"     @result{} #<subr car>\n"

#. type: group
#: original_texis/eval.texi:289
#, no-wrap
msgid ""
"(fset 'first 'car)\n"
"     @result{} car\n"
msgstr ""
"(fset 'first 'car)\n"
"     @result{} car\n"

#. type: group
#: original_texis/eval.texi:293
#, no-wrap
msgid ""
"(fset 'erste 'first)\n"
"     @result{} first\n"
msgstr ""
"(fset 'erste 'first)\n"
"     @result{} first\n"

#. type: group
#: original_texis/eval.texi:297
#, no-wrap
msgid ""
"(erste '(1 2 3))   ; @r{Call the function referenced by @code{erste}.}\n"
"     @result{} 1\n"
msgstr ""
"(erste '(1 2 3))   ; @r{@code{erste}により参照される関数を呼び出す}\n"
"     @result{} 1\n"

#. type: Plain text
#: original_texis/eval.texi:303
msgid "By contrast, the following example calls a function without any symbol function indirection, because the first element is an anonymous Lisp function, not a symbol."
msgstr "対照的に、以下の例ではシンボル関数インダイレクションを使用せずに関数を呼び出しています。なぜなら1番目の要素はシンボルではなく、無名Lisp関数(anonymous Lisp function)だからです。"

#. type: group
#: original_texis/eval.texi:309
#, no-wrap
msgid ""
"((lambda (arg) (erste arg))\n"
" '(1 2 3))\n"
"     @result{} 1\n"
msgstr ""
"((lambda (arg) (erste arg))\n"
" '(1 2 3))\n"
"     @result{} 1\n"

#. type: Plain text
#: original_texis/eval.texi:315
msgid "Executing the function itself evaluates its body; this does involve symbol function indirection when calling @code{erste}."
msgstr "関数自身を実行するとその関数のbodyを評価します。ここでは@code{erste}を呼び出すとき、シンボル関数インダイレクションが行なわれています。"

#. type: Plain text
#: original_texis/eval.texi:318
msgid "This form is rarely used and is now deprecated.  Instead, you should write it as:"
msgstr "このフォームが使用されるのは稀であり、現在では推奨されていません。かわりに以下のように記述するべきです:"

#. type: group
#: original_texis/eval.texi:323
#, no-wrap
msgid ""
"(funcall (lambda (arg) (erste arg))\n"
"         '(1 2 3))\n"
msgstr ""
"(funcall (lambda (arg) (erste arg))\n"
"         '(1 2 3))\n"

#. type: Plain text
#: original_texis/eval.texi:326
msgid "or just"
msgstr "または単に"

#. type: group
#: original_texis/eval.texi:329
#, no-wrap
msgid "(let ((arg '(1 2 3))) (erste arg))\n"
msgstr "(let ((arg '(1 2 3))) (erste arg))\n"

#. type: Plain text
#: original_texis/eval.texi:334
msgid "The built-in function @code{indirect-function} provides an easy way to perform symbol function indirection explicitly."
msgstr "ビルトイン関数の@code{indirect-function}は、明示的にシンボル関数インダイレクションを処理するための簡単な方法を提供します。"

#. type: defun
#: original_texis/eval.texi:336
#, no-wrap
msgid "indirect-function function &optional noerror"
msgstr "indirect-function function &optional noerror"

#. type: anchor{#1}
#: original_texis/eval.texi:342
msgid "Definition of indirect-function"
msgstr "Definition of indirect-function"

#. type: defun
#: original_texis/eval.texi:342
msgid "This function returns the meaning of @var{function} as a function.  If @var{function} is a symbol, then it finds @var{function}'s function definition and starts over with that value.  If @var{function} is not a symbol, then it returns @var{function} itself."
msgstr "この関数は@var{function}が意味するものを関数としてリターンする。@var{function}がシンボルなら@var{function}の関数定義を探して、その値で最初からやり直す。@var{function}がシンボルでなければ@var{function}自身をリターンする。"

#. type: defun
#: original_texis/eval.texi:346
msgid "This function returns @code{nil} if the final symbol is unbound.  It signals a @code{cyclic-function-indirection} error if there is a loop in the chain of symbols."
msgstr "この関数は最終的なシンボルがバインドされていなければ@code{nil}をリターンする。特定のシンボル内にループがれば、この関数は@code{cyclic-function-indirection}エラーをシグナルする。"

#. type: defun
#: original_texis/eval.texi:349
msgid "The optional argument @var{noerror} is obsolete, kept for backward compatibility, and has no effect."
msgstr "オペション引数@var{noerror}は廃れており、後方互換のためだけのもので効果はない。"

#. type: defun
#: original_texis/eval.texi:351
msgid "Here is how you could define @code{indirect-function} in Lisp:"
msgstr "以下はLispで@code{indirect-function}を定義する例である:"

#. type: example
#: original_texis/eval.texi:357
#, no-wrap
msgid ""
"(defun indirect-function (function)\n"
"  (if (symbolp function)\n"
"      (indirect-function (symbol-function function))\n"
"    function))\n"
msgstr ""
"(defun indirect-function (function)\n"
"  (if (symbolp function)\n"
"      (indirect-function (symbol-function function))\n"
"    function))\n"

#. type: subsection
#: original_texis/eval.texi:361
#, no-wrap
msgid "Evaluation of Function Forms"
msgstr "Evaluation of Function Forms"

#. type: cindex
#: original_texis/eval.texi:362
#, no-wrap
msgid "function form evaluation"
msgstr "function form evaluation"

#. type: cindex
#: original_texis/eval.texi:363
#, no-wrap
msgid "function call"
msgstr "function call"

#. type: cindex
#: original_texis/eval.texi:364
#, no-wrap
msgid "forms, function call"
msgstr "forms, function call"

#. type: Plain text
#: original_texis/eval.texi:370
msgid "If the first element of a list being evaluated is a Lisp function object, byte-code object or primitive function object, then that list is a @dfn{function call}.  For example, here is a call to the function @code{+}:"
msgstr "リストの1番目の要素がLispの関数オブジェクト、バイトコードオブジェクト、プリミティブ関数オブジェクトのいずれかと評価されると、そのリストは@dfn{関数呼び出し(function call)}になります。たとえば、以下は関数@code{+}を呼び出します:"

#. type: example
#: original_texis/eval.texi:373
#, no-wrap
msgid "(+ 1 x)\n"
msgstr "(+ 1 x)\n"

#. type: Plain text
#: original_texis/eval.texi:384
msgid "The first step in evaluating a function call is to evaluate the remaining elements of the list from left to right.  The results are the actual argument values, one value for each list element.  The next step is to call the function with this list of arguments, effectively using the function @code{apply} (@pxref{Calling Functions}).  If the function is written in Lisp, the arguments are used to bind the argument variables of the function (@pxref{Lambda Expressions}); then the forms in the function body are evaluated in order, and the value of the last body form becomes the value of the function call."
msgstr "関数呼び出しを評価する最初のステップでは、そのリストの残りの要素を左から右に評価します。結果は引数の実際の値で、リストの各要素にたいして1つの値となります。次のステップでは関数@code{apply}(@ref{Calling Functions}を参照)を使用して、引数のリストでその関数を呼び出します。関数がLispで記述されていたら引数はその関数の引数変数にバインドするために使用されます。その後に関数body内のフォームが順番に評価されて、リストのbodyフォームの値が関数呼び出しの値になります。"

#. type: subsection
#: original_texis/eval.texi:386
#, no-wrap
msgid "Lisp Macro Evaluation"
msgstr "Lisp Macro Evaluation"

#. type: cindex
#: original_texis/eval.texi:387
#, no-wrap
msgid "macro call evaluation"
msgstr "macro call evaluation"

#. type: cindex
#: original_texis/eval.texi:388
#, no-wrap
msgid "forms, macro call"
msgstr "forms, macro call"

#. type: Plain text
#: original_texis/eval.texi:399
msgid "If the first element of a list being evaluated is a macro object, then the list is a @dfn{macro call}.  When a macro call is evaluated, the elements of the rest of the list are @emph{not} initially evaluated.  Instead, these elements themselves are used as the arguments of the macro.  The macro definition computes a replacement form, called the @dfn{expansion} of the macro, to be evaluated in place of the original form.  The expansion may be any sort of form: a self-evaluating constant, a symbol, or a list.  If the expansion is itself a macro call, this process of expansion repeats until some other sort of form results."
msgstr "リストの最初の要素がマクロオブジェクトと評価されると、そのリストは@dfn{マクロ呼び出し(macro call)}になります。マクロ呼び出しが評価されるとき、リストの残りの要素は最初は@emph{評価されません}。そのかわりこれらの要素自体がマクロの引数に使用されます。そのマクロ定義は、元のフォームが評価される場所で置換フォームを計算します。これをマクロの@dfn{展開(expansion)}と言います。展開した結果は、任意の種類のフォーム --- 自己評価定数、シンボル、リストになります。展開した結果自体がマクロ呼び出しなら、結果が他の種類のフォームになるまで、繰り返し展開処理が行なわれます。"

#. type: Plain text
#: original_texis/eval.texi:404
msgid "Ordinary evaluation of a macro call finishes by evaluating the expansion.  However, the macro expansion is not necessarily evaluated right away, or at all, because other programs also expand macro calls, and they may or may not evaluate the expansions."
msgstr "通常のマクロ展開は、その展開結果を評価することにより終了します。しかし他のプログラムもマクロ呼び出しを展開し、それらが展開結果を評価するか、あるいは評価しないかもしれないので、そのマクロ展開が即時または最終的に評価される必要がない場合があります。"

#. type: Plain text
#: original_texis/eval.texi:408
msgid "Normally, the argument expressions are not evaluated as part of computing the macro expansion, but instead appear as part of the expansion, so they are computed when the expansion is evaluated."
msgstr "引数式は通常はマクロ展開の計算の一部としては評価されませんが、展開の部分として出現するので、展開結果が評価されるときに計算されます。"

#. type: Plain text
#: original_texis/eval.texi:410
msgid "For example, given a macro defined as follows:"
msgstr "たとえば以下のようなマクロ定義が与えられたとします:"

#. type: group
#: original_texis/eval.texi:415
#, no-wrap
msgid ""
"(defmacro cadr (x)\n"
"  (list 'car (list 'cdr x)))\n"
msgstr ""
"(defmacro cadr (x)\n"
"  (list 'car (list 'cdr x)))\n"

#. type: Plain text
#: original_texis/eval.texi:421
msgid "an expression such as @code{(cadr (assq 'handler list))} is a macro call, and its expansion is:"
msgstr "@code{(cadr (assq 'handler list))}のような式はマクロ呼び出しであり、展開結果は以下のようになります:"

#. type: example
#: original_texis/eval.texi:424
#, no-wrap
msgid "(car (cdr (assq 'handler list)))\n"
msgstr "(car (cdr (assq 'handler list)))\n"

#. type: Plain text
#: original_texis/eval.texi:429
msgid "Note that the argument @code{(assq 'handler list)} appears in the expansion."
msgstr "引数@code{(assq 'handler list)}が展開結果に含まれることに注意してください。"

#. type: Plain text
#: original_texis/eval.texi:431
msgid "@xref{Macros}, for a complete description of Emacs Lisp macros."
msgstr "Emacs Lispマクロの完全な説明は@ref{Macros}を参照してください。"

#. type: cindex
#: original_texis/eval.texi:434
#, no-wrap
msgid "special forms"
msgstr "special forms"

#. type: cindex
#: original_texis/eval.texi:435
#, no-wrap
msgid "forms, special"
msgstr "forms, special"

#. type: cindex
#: original_texis/eval.texi:436
#, no-wrap
msgid "evaluation of special forms"
msgstr "evaluation of special forms"

#. type: Plain text
#: original_texis/eval.texi:442
msgid "A @dfn{special form} is a primitive function specially marked so that its arguments are not all evaluated.  Most special forms define control structures or perform variable bindings---things which functions cannot do."
msgstr "@dfn{スペシャルフォーム(special form)}とは、特別だとマークされたプリミティブ関数であり、その引数のすべては評価されません。もっとも特別なフォームは制御構文の定義や変数バインディングの処理等、関数ではできないことを行ないます。"

#. type: Plain text
#: original_texis/eval.texi:446
msgid "Each special form has its own rules for which arguments are evaluated and which are used without evaluation.  Whether a particular argument is evaluated may depend on the results of evaluating other arguments."
msgstr "スペシャルフォームはそれぞれ、どの引数を評価して、どの引数を評価しないかについて独自のルールをもちます。特定の引数が評価されるかどうかは、他の引数を評価した結果に依存します。"

#. type: Plain text
#: original_texis/eval.texi:454
msgid "If an expression's first symbol is that of a special form, the expression should follow the rules of that special form; otherwise, Emacs's behavior is not well-defined (though it will not crash).  For example, @code{((lambda (x) x . 3) 4)} contains a subexpression that begins with @code{lambda} but is not a well-formed @code{lambda} expression, so Emacs may signal an error, or may return 3 or 4 or @code{nil}, or may behave in other ways."
msgstr "式の最初のシンボルがスペシャルフォームなら、式はそのスペシャルフォームのルールにしたがう必要があります。それ以外ならEmacsの挙動は(たとえクラッシュしなくいとしても)未定義です。たとえば@code{((lambda (x) x . 3) 4)}は@code{lambda}で始まるサブ式を含みますが、これは適正な@code{lambda}式ではないので、Emacsはエラーをシグナルするかもしれないし、3や4や@code{nil}をリターンしたり、もしかしたら他の挙動を示すかもしれません。"

#. type: defun
#: original_texis/eval.texi:455
#, no-wrap
msgid "special-form-p object"
msgstr "special-form-p object"

#. type: defun
#: original_texis/eval.texi:458
msgid "This predicate tests whether its argument is a special form, and returns @code{t} if so, @code{nil} otherwise."
msgstr "この述語は引数がスペシャルフォームかをテストして、スペシャルフォームなら@code{t}、それ以外なら@code{nil}をリターンする。"

#. type: Plain text
#: original_texis/eval.texi:462
msgid "Here is a list, in alphabetical order, of all of the special forms in Emacs Lisp with a reference to where each is described."
msgstr "以下にEmacs Lispのスペシャルフォームすべてと、それらがどこで説明されているかのリファレンスをアルファベット順でリストします。"

#. type: item
#: original_texis/eval.texi:464
#, no-wrap
msgid "and"
msgstr "and"

#. type: pxref{#1}
#: original_texis/eval.texi:466 original_texis/eval.texi:500
msgid "Combining Conditions"
msgstr "Combining Conditions"

#. type: item
#: original_texis/eval.texi:467
#, no-wrap
msgid "catch"
msgstr "catch"

#. type: pxref{#1}
#: original_texis/eval.texi:469
msgid "Catch and Throw"
msgstr "Catch and Throw"

#. type: item
#: original_texis/eval.texi:470
#, no-wrap
msgid "cond"
msgstr "cond"

#. type: pxref{#1}
#: original_texis/eval.texi:472 original_texis/eval.texi:487
msgid "Conditionals"
msgstr "Conditionals"

#. type: item
#: original_texis/eval.texi:473
#, no-wrap
msgid "condition-case"
msgstr "condition-case"

#. type: pxref{#1}
#: original_texis/eval.texi:475
msgid "Handling Errors"
msgstr "Handling Errors"

#. type: item
#: original_texis/eval.texi:476
#, no-wrap
msgid "defconst"
msgstr "defconst"

#. type: pxref{#1}
#: original_texis/eval.texi:478 original_texis/eval.texi:481
msgid "Defining Variables"
msgstr "Defining Variables"

#. type: item
#: original_texis/eval.texi:479
#, no-wrap
msgid "defvar"
msgstr "defvar"

#. type: item
#: original_texis/eval.texi:482
#, no-wrap
msgid "function"
msgstr "function"

#. type: pxref{#1}
#: original_texis/eval.texi:484
msgid "Anonymous Functions"
msgstr "Anonymous Functions"

#. type: item
#: original_texis/eval.texi:485
#, no-wrap
msgid "if"
msgstr "if"

#. type: item
#: original_texis/eval.texi:488
#, no-wrap
msgid "interactive"
msgstr "interactive"

#. type: pxref{#1}
#: original_texis/eval.texi:490
msgid "Interactive Call"
msgstr "Interactive Call"

#. type: item
#: original_texis/eval.texi:491
#, no-wrap
msgid "lambda"
msgstr "lambda"

#. type: pxref{#1}
#: original_texis/eval.texi:493
msgid "Lambda Expressions"
msgstr "Lambda Expressions"

#. type: item
#: original_texis/eval.texi:494
#, no-wrap
msgid "let"
msgstr "let"

#. type: itemx
#: original_texis/eval.texi:495
#, no-wrap
msgid "let*"
msgstr "let*"

#. type: pxref{#1}
#: original_texis/eval.texi:497
msgid "Local Variables"
msgstr "Local Variables"

#. type: item
#: original_texis/eval.texi:498
#, no-wrap
msgid "or"
msgstr "or"

#. type: item
#: original_texis/eval.texi:501
#, no-wrap
msgid "prog1"
msgstr "prog1"

#. type: itemx
#: original_texis/eval.texi:502
#, no-wrap
msgid "prog2"
msgstr "prog2"

#. type: itemx
#: original_texis/eval.texi:503
#, no-wrap
msgid "progn"
msgstr "progn"

#. type: pxref{#1}
#: original_texis/eval.texi:505
msgid "Sequencing"
msgstr "Sequencing"

#. type: item
#: original_texis/eval.texi:506
#, no-wrap
msgid "quote"
msgstr "quote"

#. type: item
#: original_texis/eval.texi:509
#, no-wrap
msgid "save-current-buffer"
msgstr "save-current-buffer"

#. type: pxref{#1}
#: original_texis/eval.texi:511
msgid "Current Buffer"
msgstr "Current Buffer"

#. type: item
#: original_texis/eval.texi:512
#, no-wrap
msgid "save-excursion"
msgstr "save-excursion"

#. type: pxref{#1}
#: original_texis/eval.texi:514
msgid "Excursions"
msgstr "Excursions"

#. type: item
#: original_texis/eval.texi:515
#, no-wrap
msgid "save-restriction"
msgstr "save-restriction"

#. type: pxref{#1}
#: original_texis/eval.texi:517
msgid "Narrowing"
msgstr "Narrowing"

#. type: item
#: original_texis/eval.texi:518
#, no-wrap
msgid "setq"
msgstr "setq"

#. type: pxref{#1}
#: original_texis/eval.texi:520
msgid "Setting Variables"
msgstr "Setting Variables"

#. type: item
#: original_texis/eval.texi:521
#, no-wrap
msgid "setq-default"
msgstr "setq-default"

#. type: pxref{#1}
#: original_texis/eval.texi:523
msgid "Creating Buffer-Local"
msgstr "Creating Buffer-Local"

#. type: item
#: original_texis/eval.texi:524
#, no-wrap
msgid "unwind-protect"
msgstr "unwind-protect"

#. type: pxref{#1}
#: original_texis/eval.texi:526
msgid "Nonlocal Exits"
msgstr "Nonlocal Exits"

#. type: item
#: original_texis/eval.texi:527
#, no-wrap
msgid "while"
msgstr "while"

#. type: pxref{#1}
#: original_texis/eval.texi:529
msgid "Iteration"
msgstr "Iteration"

#. type: cindex
#: original_texis/eval.texi:531
#, no-wrap
msgid "CL note---special forms compared"
msgstr "CL note---special forms compared"

#. type: quotation
#: original_texis/eval.texi:541
msgid "@b{Common Lisp note:} Here are some comparisons of special forms in GNU Emacs Lisp and Common Lisp.  @code{setq}, @code{if}, and @code{catch} are special forms in both Emacs Lisp and Common Lisp.  @code{save-excursion} is a special form in Emacs Lisp, but doesn't exist in Common Lisp.  @code{throw} is a special form in Common Lisp (because it must be able to throw multiple values), but it is a function in Emacs Lisp (which doesn't have multiple values)."
msgstr "@b{Common Lispに関する注意: }GNU EmacsとCommon Lispのスペシャルフォームを比較する。@code{setq}、@code{if}、@code{catch}はEmacs LispとCommon Lispの両方でスペシャルフォームである。@code{save-excursion}はEmacs Lispではスペシャルフォームだが、Common Lispには存在しない。@code{throw}はCommon Lispではスペシャルフォーム(なぜなら複数の値をthrowできなければならない)だが、Emacs Lispでは(複数の値をもたない)関数である。"

#. type: Plain text
#: original_texis/eval.texi:554
msgid "The @dfn{autoload} feature allows you to call a function or macro whose function definition has not yet been loaded into Emacs.  It specifies which file contains the definition.  When an autoload object appears as a symbol's function definition, calling that symbol as a function automatically loads the specified file; then it calls the real definition loaded from that file.  The way to arrange for an autoload object to appear as a symbol's function definition is described in @ref{Autoload}."
msgstr "@dfn{オートロード(autoload)}機能により、まだ関数定義がEmacsにロードされていない関数(またはマクロ)を呼び出すことができます。オートロードは定義がどのファイルに含まれるかを指定します。オートロードオブジェクトがシンボルの関数定義にある場合は、関数としてそのシンボルを呼び出すことにより、自動的に指定されたファイルがロードされます。その後にファイルからロードされた実際の定義を呼び出します。シンボル内の関数定義としてオートロードオブジェクトをアレンジする方法は@ref{Autoload}で説明します。"

#. type: cindex
#: original_texis/eval.texi:557
#, no-wrap
msgid "forms, quote"
msgstr "forms, quote"

#. type: Plain text
#: original_texis/eval.texi:564
msgid "The special form @code{quote} returns its single argument, as written, without evaluating it.  This provides a way to include constant symbols and lists, which are not self-evaluating objects, in a program.  (It is not necessary to quote self-evaluating objects such as numbers, strings, and vectors.)"
msgstr "スペシャルフォーム@code{quote}は、単一の引数を記述されたままに評価せずにリターンします。これはプログラムに自己評価オブジェクトではない、定数シンボルや定数リストを含める方法を提供します(数字、文字列、ベクターのような自己評価オブジェクトをクォートする必要はない)。"

#. type: defspec
#: original_texis/eval.texi:565
#, no-wrap
msgid "quote object"
msgstr "quote object"

#. type: defspec
#: original_texis/eval.texi:569
msgid "This special form returns @var{object}, without evaluating it.  The returned value might be shared and should not be modified.  @xref{Self-Evaluating Forms}."
msgstr ""

#. type: cindex
#: original_texis/eval.texi:571
#, no-wrap
msgid "@samp{'} for quoting"
msgstr "@samp{'} for quoting"

#. type: cindex
#: original_texis/eval.texi:572
#, no-wrap
msgid "quoting using apostrophe"
msgstr "quoting using apostrophe"

#. type: cindex
#: original_texis/eval.texi:573
#, no-wrap
msgid "apostrophe for quoting"
msgstr "apostrophe for quoting"

#. type: Plain text
#: original_texis/eval.texi:579
msgid "Because @code{quote} is used so often in programs, Lisp provides a convenient read syntax for it.  An apostrophe character (@samp{'})  followed by a Lisp object (in read syntax) expands to a list whose first element is @code{quote}, and whose second element is the object.  Thus, the read syntax @code{'x} is an abbreviation for @code{(quote x)}."
msgstr "@code{quote}はプログラム中で頻繁に使用されるので、Lispはそれにたいする便利な入力構文を提供します。アポストロフィー文字(@samp{'})に続けてLispオブジェクト(の入力構文)を記述すると、それは1番目の要素が@code{quote}、2番目の要素がそのオブジェクトであるようなリストに展開されます。つまり入力構文@code{'x}は@code{(quote x)}の略記になります。"

#. type: Plain text
#: original_texis/eval.texi:581
msgid "Here are some examples of expressions that use @code{quote}:"
msgstr "以下に@code{quote}を使用した式の例をいくつか示します:"

#. type: group
#: original_texis/eval.texi:586
#, no-wrap
msgid ""
"(quote (+ 1 2))\n"
"     @result{} (+ 1 2)\n"
msgstr ""
"(quote (+ 1 2))\n"
"     @result{} (+ 1 2)\n"

#. type: group
#: original_texis/eval.texi:590
#, no-wrap
msgid ""
"(quote foo)\n"
"     @result{} foo\n"
msgstr ""
"(quote foo)\n"
"     @result{} foo\n"

#. type: group
#: original_texis/eval.texi:594
#, no-wrap
msgid ""
"'foo\n"
"     @result{} foo\n"
msgstr ""
"'foo\n"
"     @result{} foo\n"

#. type: group
#: original_texis/eval.texi:598
#, fuzzy, no-wrap
#| msgid ""
#| "'foo\n"
#| "     @result{} foo\n"
msgid ""
"''foo\n"
"     @result{} 'foo\n"
msgstr ""
"'foo\n"
"     @result{} foo\n"

#. type: group
#: original_texis/eval.texi:602
#, fuzzy, no-wrap
#| msgid ""
#| "(quote foo)\n"
#| "     @result{} foo\n"
msgid ""
"'(quote foo)\n"
"     @result{} 'foo\n"
msgstr ""
"(quote foo)\n"
"     @result{} foo\n"

#. type: group
#: original_texis/eval.texi:606
#, fuzzy, no-wrap
#| msgid ""
#| "'foo\n"
#| "     @result{} foo\n"
msgid ""
"['foo]\n"
"     @result{} ['foo]\n"
msgstr ""
"'foo\n"
"     @result{} foo\n"

#. type: Plain text
#: original_texis/eval.texi:614
msgid "Although the expressions @code{(list '+ 1 2)} and @code{'(+ 1 2)} both yield lists equal to @code{(+ 1 2)}, the former yields a freshly-minted mutable list whereas the latter yields a list built from conses that might be shared and should not be modified.  @xref{Self-Evaluating Forms}."
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:619
msgid "Other quoting constructs include @code{function} (@pxref{Anonymous Functions}), which causes an anonymous lambda expression written in Lisp to be compiled, and @samp{`} (@pxref{Backquote}), which is used to quote only part of a list, while computing and substituting other parts."
msgstr "他のクォート構文としては、コンパイル用にLispで記述された無名のラムダ式の元となる@code{function} (@ref{Anonymous Functions}を参照)、リストを計算して置き換える際にリストの一部だけをクォートするために使用される@samp{`}(@ref{Backquote}を参照)があります。"

#. type: cindex
#: original_texis/eval.texi:622
#, no-wrap
msgid "backquote (list substitution)"
msgstr "backquote (list substitution)"

#. type: cindex
#: original_texis/eval.texi:623
#, no-wrap
msgid "` (list substitution)"
msgstr "` (list substitution)"

#. type: findex
#: original_texis/eval.texi:624
#, no-wrap
msgid "`"
msgstr "`"

#. type: cindex
#: original_texis/eval.texi:625
#, no-wrap
msgid "forms, backquote"
msgstr "forms, backquote"

#. type: Plain text
#: original_texis/eval.texi:630
#, fuzzy
#| msgid "@dfn{Backquote constructs} allow you to quote a list, but selectively evaluate elements of that list.  In the simplest case, it is identical to the special form @code{quote}"
msgid "@dfn{Backquote constructs} allow you to quote a list, but selectively evaluate elements of that list.  In the simplest case, it is identical to the special form"
msgstr "@dfn{バッククォート構文(backquote constructs)}を使用することにより、リストをクォートしてそのリストのある要素を選択的に評価することができます。もっとも簡単な使い方ではスペシャルフォーム@code{quote}と同じです"

#. type: iftex
#: original_texis/eval.texi:632
msgid "@code{quote}."
msgstr ""

#. type: ifnottex
#: original_texis/eval.texi:636
#, fuzzy
#| msgid "(described in the previous section; @pxref{Quoting})."
msgid "@code{quote} (described in the previous section; @pxref{Quoting})."
msgstr "(前のセクションで説明済み。@ref{Quoting}を参照)。"

#. type: Plain text
#: original_texis/eval.texi:638
msgid "For example, these two forms yield identical results:"
msgstr "たとえば以下の2つのフォームは同じ結果を生みます:"

#. type: group
#: original_texis/eval.texi:643
#, no-wrap
msgid ""
"`(a list of (+ 2 3) elements)\n"
"     @result{} (a list of (+ 2 3) elements)\n"
msgstr ""
"`(a list of (+ 2 3) elements)\n"
"     @result{} (a list of (+ 2 3) elements)\n"

#. type: group
#: original_texis/eval.texi:647
#, no-wrap
msgid ""
"'(a list of (+ 2 3) elements)\n"
"     @result{} (a list of (+ 2 3) elements)\n"
msgstr ""
"'(a list of (+ 2 3) elements)\n"
"     @result{} (a list of (+ 2 3) elements)\n"

#. type: findex
#: original_texis/eval.texi:650
#, no-wrap
msgid ", @r{(with backquote)}"
msgstr ", @r{(with backquote)}"

#. type: Plain text
#: original_texis/eval.texi:655
msgid "The special marker @samp{,} inside of the argument to backquote indicates a value that isn't constant.  The Emacs Lisp evaluator evaluates the argument of @samp{,}, and puts the value in the list structure:"
msgstr "バッククォートする引数の内側でスペシャルマーカー@samp{,}を使用すると、それは値が定数でないことを示します。Emacs Lispエバリュエーターは@samp{,}がついた引数を放置して、リスト構文内にその値を配置します:"

#. type: group
#: original_texis/eval.texi:660
#, no-wrap
msgid ""
"`(a list of ,(+ 2 3) elements)\n"
"     @result{} (a list of 5 elements)\n"
msgstr ""
"`(a list of ,(+ 2 3) elements)\n"
"     @result{} (a list of 5 elements)\n"

#. type: Plain text
#: original_texis/eval.texi:666
msgid "Substitution with @samp{,} is allowed at deeper levels of the list structure also.  For example:"
msgstr "@samp{,}による置き換えを、リスト構文のより深いレベルでも使用できます。たとえば:"

#. type: group
#: original_texis/eval.texi:671
#, no-wrap
msgid ""
"`(1 2 (3 ,(+ 4 5)))\n"
"     @result{} (1 2 (3 9))\n"
msgstr ""
"`(1 2 (3 ,(+ 4 5)))\n"
"     @result{} (1 2 (3 9))\n"

#. type: findex
#: original_texis/eval.texi:674
#, no-wrap
msgid ",@@ @r{(with backquote)}"
msgstr ",@@ @r{(with backquote)}"

#. type: cindex
#: original_texis/eval.texi:675
#, no-wrap
msgid "splicing (with backquote)"
msgstr "splicing (with backquote)"

#. type: Plain text
#: original_texis/eval.texi:681
msgid "You can also @dfn{splice} an evaluated value into the resulting list, using the special marker @samp{,@@}.  The elements of the spliced list become elements at the same level as the other elements of the resulting list.  The equivalent code without using @samp{`} is often unreadable.  Here are some examples:"
msgstr "スペシャルマーカー@samp{,@@}を使用すれば、評価された値を結果リストに@dfn{継ぎ足す(splice)}こともできます。継ぎ足されたリストの要素は、結果リスト内の他の要素と同じレベルになります。@samp{`}を使用しない等価なコードは読むのが困難なことがよくあります。以下にいくつかの例を示します:"

#. type: group
#: original_texis/eval.texi:686
#, no-wrap
msgid ""
"(setq some-list '(2 3))\n"
"     @result{} (2 3)\n"
msgstr ""
"(setq some-list '(2 3))\n"
"     @result{} (2 3)\n"

#. type: group
#: original_texis/eval.texi:690
#, no-wrap
msgid ""
"(cons 1 (append some-list '(4) some-list))\n"
"     @result{} (1 2 3 4 2 3)\n"
msgstr ""
"(cons 1 (append some-list '(4) some-list))\n"
"     @result{} (1 2 3 4 2 3)\n"

#. type: group
#: original_texis/eval.texi:694
#, no-wrap
msgid ""
"`(1 ,@@some-list 4 ,@@some-list)\n"
"     @result{} (1 2 3 4 2 3)\n"
msgstr ""
"`(1 ,@@some-list 4 ,@@some-list)\n"
"     @result{} (1 2 3 4 2 3)\n"

#. type: group
#: original_texis/eval.texi:699
#, no-wrap
msgid ""
"(setq list '(hack foo bar))\n"
"     @result{} (hack foo bar)\n"
msgstr ""
"(setq list '(hack foo bar))\n"
"     @result{} (hack foo bar)\n"

#. type: group
#: original_texis/eval.texi:705
#, no-wrap
msgid ""
"(cons 'use\n"
"  (cons 'the\n"
"    (cons 'words (append (cdr list) '(as elements)))))\n"
"     @result{} (use the words foo bar as elements)\n"
msgstr ""
"(cons 'use\n"
"  (cons 'the\n"
"    (cons 'words (append (cdr list) '(as elements)))))\n"
"     @result{} (use the words foo bar as elements)\n"

#. type: group
#: original_texis/eval.texi:709
#, no-wrap
msgid ""
"`(use the words ,@@(cdr list) as elements)\n"
"     @result{} (use the words foo bar as elements)\n"
msgstr ""
"`(use the words ,@@(cdr list) as elements)\n"
"     @result{} (use the words foo bar as elements)\n"

#. type: Plain text
#: original_texis/eval.texi:716
msgid "If a subexpression of a backquote construct has no substitutions or splices, it acts like @code{quote} in that it yields conses, vectors and strings that might be shared and should not be modified.  @xref{Self-Evaluating Forms}."
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:730
msgid "Most often, forms are evaluated automatically, by virtue of their occurrence in a program being run.  On rare occasions, you may need to write code that evaluates a form that is computed at run time, such as after reading a form from text being edited or getting one from a property list.  On these occasions, use the @code{eval} function.  Often @code{eval} is not needed and something else should be used instead.  For example, to get the value of a variable, while @code{eval} works, @code{symbol-value} is preferable; or rather than store expressions in a property list that then need to go through @code{eval}, it is better to store functions instead that are then passed to @code{funcall}."
msgstr "フォームはほとんどの場合、実行されるプログラム内に出現することにより自動的に評価されます。ごく稀に実行時 --- たとえば編集されているテキストやプロパティーリストから取得したフォームを読み取った後 --- に計算されるようにフォームを評価するコードを記述する必要があるかもしれません。このようなときは@code{eval}関数を使用します。@code{eval}が不必要だったり、かわりに他の何かを使用すべきときがよくあります。たとえば変数から値を取得するには@code{eval}も機能しますが、@code{symbol-value}のほうが適しています。@code{eval}で評価するためにプロパティーリストに式を格納するかわりに、@code{funcall}に渡すように関数を格納した方がよいでしょう。"

#. type: Plain text
#: original_texis/eval.texi:734
msgid "The functions and variables described in this section evaluate forms, specify limits to the evaluation process, or record recently returned values.  Loading a file also does evaluation (@pxref{Loading})."
msgstr "このセクションで説明する関数と変数はフォームの評価、評価処理の制限の指定、最後にリターンされた値の記録を行なうものです。ファイルのロードでも評価が行なわれます(@ref{Loading}を参照)。"

#. type: Plain text
#: original_texis/eval.texi:740
msgid "It is generally cleaner and more flexible to store a function in a data structure, and call it with @code{funcall} or @code{apply}, than to store an expression in the data structure and evaluate it.  Using functions provides the ability to pass information to them as arguments."
msgstr "データ構造に式を格納して評価するより、データ構造に関数を格納して@code{funcall}や@code{apply}で呼び出すほうが、より明解で柔軟です。関数を使用することにより、引数に情報を渡す能力が提供されます。"

#. type: defun
#: original_texis/eval.texi:741
#, no-wrap
msgid "eval form &optional lexical"
msgstr "eval form &optional lexical"

#. type: defun
#: original_texis/eval.texi:746
msgid "This is the basic function for evaluating an expression.  It evaluates @var{form} in the current environment, and returns the result.  The type of the @var{form} object determines how it is evaluated.  @xref{Forms}."
msgstr "これは式を評価する基本的な関数である。この関数はカレント環境内で@var{form}を評価して、その結果をリターンする。@var{form}オブジェクトの型はそれが評価される方法を決定します。@ref{Forms}を参照のこと。"

#. type: defun
#: original_texis/eval.texi:755
msgid "The argument @var{lexical} specifies the scoping rule for local variables (@pxref{Variable Scoping}).  If it is omitted or @code{nil}, that means to evaluate @var{form} using the default dynamic scoping rule.  If it is @code{t}, that means to use the lexical scoping rule.  The value of @var{lexical} can also be a non-empty alist specifying a particular @dfn{lexical environment} for lexical bindings; however, this feature is only useful for specialized purposes, such as in Emacs Lisp debuggers.  @xref{Lexical Binding}."
msgstr "引数@var{lexical}は、ローカル変数にたいするスコープ規則(@ref{Variable Scoping}を参照)を指定する。これが省略または@code{nil}ならデフォルトのダイナミックスコープ規則を使用して@var{form}を評価することを意味する。@code{t}ならレキシカルスコープ規則が使用されることを意味する。@var{lexical}の値にはレキシカルバインディングでの特定の@dfn{レキシカル環境(lexical environment)}を指定する空ではないalistも指定できる。しかしこの機能はEmacs Lispデバッガーのような、特別な用途にたいしてのみ有用。@ref{Lexical Binding}を参照のこと。"

#. type: defun
#: original_texis/eval.texi:760
msgid "Since @code{eval} is a function, the argument expression that appears in a call to @code{eval} is evaluated twice: once as preparation before @code{eval} is called, and again by the @code{eval} function itself.  Here is an example:"
msgstr "@code{eval}は関数なので@code{eval}呼び出しに現れる引数式は2回 --- @code{eval}が呼び出される前の準備で一度、@code{eval}関数自身によりもう一度 --- 評価される。以下に例を示す:"

#. type: group
#: original_texis/eval.texi:765
#, no-wrap
msgid ""
"(setq foo 'bar)\n"
"     @result{} bar\n"
msgstr ""
"(setq foo 'bar)\n"
"     @result{} bar\n"

#. type: group
#: original_texis/eval.texi:775
#, no-wrap
msgid ""
"(setq bar 'baz)\n"
"     @result{} baz\n"
";; @r{Here @code{eval} receives argument @code{foo}}\n"
"(eval 'foo)\n"
"     @result{} bar\n"
";; @r{Here @code{eval} receives argument @code{bar}, which is the value of @code{foo}}\n"
"(eval foo)\n"
"     @result{} baz\n"
msgstr ""
"(setq bar 'baz)\n"
"     @result{} baz\n"
";; @r{@code{eval}が引数@code{foo}を受け取る}\n"
"(eval 'foo)\n"
"     @result{} bar\n"
";; @r{@code{eval}が、@code{foo}の値である、引数@code{bar}を受け取る}\n"
"(eval foo)\n"
"     @result{} baz\n"

#. type: defun
#: original_texis/eval.texi:780
msgid "The number of currently active calls to @code{eval} is limited to @code{max-lisp-eval-depth} (see below)."
msgstr "@code{eval}で現在アクティブな呼び出しの数は@code{max-lisp-eval-depth}に制限される(以下参照)。"

#. type: deffn
#: original_texis/eval.texi:782
#, no-wrap
msgid "Command eval-region start end &optional stream read-function"
msgstr "Command eval-region start end &optional stream read-function"

#. type: anchor{#1}
#: original_texis/eval.texi:788
msgid "Definition of eval-region"
msgstr "Definition of eval-region"

#. type: deffn
#: original_texis/eval.texi:788
msgid "This function evaluates the forms in the current buffer in the region defined by the positions @var{start} and @var{end}.  It reads forms from the region and calls @code{eval} on them until the end of the region is reached, or until an error is signaled and not handled."
msgstr "この関数はカレントバッファー内の、位置@var{start}と@var{end}で定義されるリージョン内のフォームを評価する。この関数はリージョンからフォームを読み取って@code{eval}を呼び出す。これはリージョンの最後に達するか、処理されないエラーがシグナルされるまで行なわれる。"

#. type: deffn
#: original_texis/eval.texi:794
msgid "By default, @code{eval-region} does not produce any output.  However, if @var{stream} is non-@code{nil}, any output produced by output functions (@pxref{Output Functions}), as well as the values that result from evaluating the expressions in the region are printed using @var{stream}.  @xref{Output Streams}."
msgstr "デフォルトでは@code{eval-region}は出力を何も生成しない。しかし@var{stream}が非@code{nil}なら出力関数(@ref{Output Functions}を参照)で生成された任意の出力、同様にリージョン内の式を評価した結果の値が、@var{stream}を使用してプリントされる。@ref{Output Streams}を参照のこと。"

#. type: deffn
#: original_texis/eval.texi:802
msgid "If @var{read-function} is non-@code{nil}, it should be a function, which is used instead of @code{read} to read expressions one by one.  This function is called with one argument, the stream for reading input.  You can also use the variable @code{load-read-function} (@pxref{Definition of load-read-function,, How Programs Do Loading})  to specify this function, but it is more robust to use the @var{read-function} argument."
msgstr "@var{read-function}が非@code{nil}なら、@code{read}のかわりに1つずつ式を読み取るために使用する関数を指定すること。これは入力を読み取るストリームを指定する、1つの引数で呼び出される関数である。この関数を指定するために変数@code{load-read-function}(@ref{Definition of load-read-function,, How Programs Do Loading}を参照)も使用できるが、引数@var{read-function}を使用するほうが堅実である。"

#. type: deffn
#: original_texis/eval.texi:804
msgid "@code{eval-region} does not move point.  It always returns @code{nil}."
msgstr "@code{eval-region}はポイントを移動しない。常に@code{nil}をリターンする。"

#. type: cindex
#: original_texis/eval.texi:806
#, no-wrap
msgid "evaluation of buffer contents"
msgstr "evaluation of buffer contents"

#. type: deffn
#: original_texis/eval.texi:807
#, no-wrap
msgid "Command eval-buffer &optional buffer-or-name stream filename unibyte print"
msgstr "Command eval-buffer &optional buffer-or-name stream filename unibyte print"

#. type: deffn
#: original_texis/eval.texi:822
msgid "This is similar to @code{eval-region}, but the arguments provide different optional features.  @code{eval-buffer} operates on the entire accessible portion of buffer @var{buffer-or-name} (@pxref{Narrowing,,, emacs, The GNU Emacs Manual}).  @var{buffer-or-name} can be a buffer, a buffer name (a string), or @code{nil} (or omitted), which means to use the current buffer.  @var{stream} is used as in @code{eval-region}, unless @var{stream} is @code{nil} and @var{print} non-@code{nil}.  In that case, values that result from evaluating the expressions are still discarded, but the output of the output functions is printed in the echo area.  @var{filename} is the file name to use for @code{load-history} (@pxref{Unloading}), and defaults to @code{buffer-file-name} (@pxref{Buffer File Name}).  If @var{unibyte} is non-@code{nil}, @code{read} converts strings to unibyte whenever possible."
msgstr "この関数は@code{eval-region}と似ているが、引数は異なるオプション機能を提供する。@code{eval-buffer}はバッファー@var{buffer-or-name}のアクセス可能な部分(@ref{Narrowing,,, emacs, The GNU Emacs Manual}を参照)の全体を処理する。@var{buffer-or-name}にはバッファー名(文字列)を指定でき、@code{nil}(または省略)のときはカレントバッファーを意味する。@var{stream}が非@code{nil}、または@var{print}が@code{nil}なら、@code{eval-region}のように@var{stream}が使用される。この場合には式の評価結果の値は依然として破棄されるが、出力関数による出力はエコーエリアにプリントされる。@var{filename}は@code{load-history} (@ref{Unloading}を参照)に使用されるファイル名であり、デフォルトは@code{buffer-file-name} (@ref{Buffer File Name}を参照)。@var{unibyte}が非@code{nil}なら@code{read}可能な限りは文字列をユニコードに変換する。"

#. type: findex
#: original_texis/eval.texi:823
#, no-wrap
msgid "eval-current-buffer"
msgstr "eval-current-buffer"

#. type: deffn
#: original_texis/eval.texi:825
msgid "@code{eval-current-buffer} is an alias for this command."
msgstr "@code{eval-current-buffer}はこのコマンドのエイリアスである。"

#. type: defopt
#: original_texis/eval.texi:827
#, no-wrap
msgid "max-lisp-eval-depth"
msgstr "max-lisp-eval-depth"

#. type: anchor{#1}
#: original_texis/eval.texi:832
msgid "Definition of max-lisp-eval-depth"
msgstr "Definition of max-lisp-eval-depth"

#. type: defopt
#: original_texis/eval.texi:832
msgid "This variable defines the maximum depth allowed in calls to @code{eval}, @code{apply}, and @code{funcall} before an error is signaled (with error message @code{\"Lisp nesting exceeds max-lisp-eval-depth\"})."
msgstr "この変数はエラー(エラーメッセージは@code{\"Lisp nesting exceeds max-lisp-eval-depth\"})がシグナルされる前に@code{eval}、@code{apply}、@code{funcall}の呼び出しで許容される最大の深さを定義する。"

#. type: defopt
#: original_texis/eval.texi:841
msgid "This limit, with the associated error when it is exceeded, is one way Emacs Lisp avoids infinite recursion on an ill-defined function.  If you increase the value of @code{max-lisp-eval-depth} too much, such code can cause stack overflow instead.  On some systems, this overflow can be handled.  In that case, normal Lisp evaluation is interrupted and control is transferred back to the top level command loop (@code{top-level}).  Note that there is no way to enter Emacs Lisp debugger in this situation.  @xref{Error Debugging}."
msgstr "制限を超過時のエラーを付随するこの制限は、誤って定義された関数による無限再帰をEmacs Lispが回避する方法の1つである。@code{max-lisp-eval-depth}の値を過大に増加させると、そのようなコードはかわりにスタックオーバーフローを起こすだろう。オーバーフローを処理できるシステムがいくつかある。この場合には通常のLisp評価は割り込まれて、制御はトップレベルのコマンドループ(@code{top-level})に戻される。この状況ではEmacs Lispデバッガにエンターする手段は存在しないことに注意されたい。@ref{Error Debugging}を参照のこと。"

#. type: cindex
#: original_texis/eval.texi:842
#, no-wrap
msgid "Lisp nesting error"
msgstr "Lisp nesting error"

#. type: defopt
#: original_texis/eval.texi:848
msgid "The depth limit counts internal uses of @code{eval}, @code{apply}, and @code{funcall}, such as for calling the functions mentioned in Lisp expressions, and recursive evaluation of function call arguments and function body forms, as well as explicit calls in Lisp code."
msgstr "Lisp式に記述された関数の呼び出し、関数呼び出しの引数と関数bodyフォームにたいする再帰評価、Lispコード内での明示的な呼び出し等では内部的に@code{eval}、@code{apply}、@code{funcall}を使用して深さ制限を計数する。"

#. type: defopt
#: original_texis/eval.texi:854
msgid "The default value of this variable is 800.  If you set it to a value less than 100, Lisp will reset it to 100 if the given value is reached.  Entry to the Lisp debugger increases the value, if there is little room left, to make sure the debugger itself has room to execute."
msgstr "この変数のデフォルト値は800。この値を100未満にセットした場合には、値が与えられた値に達するとLispはそれを100にリセットする。空きが少なければデバッガー自身を実行するために空きが必要になるので、Lispデバッガーに入ったときは値が増加される。"

#. type: defopt
#: original_texis/eval.texi:857
msgid "@code{max-specpdl-size} provides another limit on nesting.  @xref{Definition of max-specpdl-size,, Local Variables}."
msgstr "@code{max-specpdl-size}はネストの他の制限を提供する。@ref{Definition of max-specpdl-size,, Local Variables}を参照のこと。"

#. type: defvar
#: original_texis/eval.texi:859
#, no-wrap
msgid "values"
msgstr "values"

#. type: defvar
#: original_texis/eval.texi:867
msgid "The value of this variable is a list of the values returned by all the expressions that were read, evaluated, and printed from buffers (including the minibuffer) by the standard Emacs commands which do this.  (Note that this does @emph{not} include evaluation in @file{*ielm*} buffers, nor evaluation using @kbd{C-j}, @kbd{C-x C-e}, and similar evaluation commands in @code{lisp-interaction-mode}.)  The elements are ordered most recent first."
msgstr "この変数の値は読み取り、評価、プリントを行なった標準的なEmacsコマンドにより、バッファー(ミニバッファーを含む)からリターンされる値のリストである(これには@file{*ielm*}バッファーでの評価や、@code{lisp-interaction-mode}での@kbd{C-j}や@kbd{C-x C-e}、類似の評価コマンドを使用した評価は@emph{含まれない}ことに注意)。要素の順番はもっとも最近のものが最初になる。"

#. type: group
#: original_texis/eval.texi:872
#, no-wrap
msgid ""
"(setq x 1)\n"
"     @result{} 1\n"
msgstr ""
"(setq x 1)\n"
"     @result{} 1\n"

#. type: group
#: original_texis/eval.texi:876
#, no-wrap
msgid ""
"(list 'A (1+ 2) auto-save-default)\n"
"     @result{} (A 3 t)\n"
msgstr ""
"(list 'A (1+ 2) auto-save-default)\n"
"     @result{} (A 3 t)\n"

#. type: group
#: original_texis/eval.texi:880
#, no-wrap
msgid ""
"values\n"
"     @result{} ((A 3 t) 1 @dots{})\n"
msgstr ""
"values\n"
"     @result{} ((A 3 t) 1 @dots{})\n"

#. type: defvar
#: original_texis/eval.texi:887
msgid "This variable is useful for referring back to values of forms recently evaluated.  It is generally a bad idea to print the value of @code{values} itself, since this may be very long.  Instead, examine particular elements, like this:"
msgstr "この変数は最近評価されたフォームの値を後で参照するのに有用。@code{values}自体の値のプリントは、値がおそらく非常に長くなるので通常は悪いアイデアである。かわりに以下のように特定の要素を調べること:"

#. type: group
#: original_texis/eval.texi:893
#, no-wrap
msgid ""
";; @r{Refer to the most recent evaluation result.}\n"
"(nth 0 values)\n"
"     @result{} (A 3 t)\n"
msgstr ""
";; @r{もっとも最近評価された結果を参照する}\n"
"(nth 0 values)\n"
"     @result{} (A 3 t)\n"

#. type: group
#: original_texis/eval.texi:899
#, no-wrap
msgid ""
";; @r{That put a new element on,}\n"
";;   @r{so all elements move back one.}\n"
"(nth 1 values)\n"
"     @result{} (A 3 t)\n"
msgstr ""
";; @r{これは新たな要素をputするので}\n"
";;   @r{すべての要素が1つ後に移動する}\n"
"(nth 1 values)\n"
"     @result{} (A 3 t)\n"

#. type: group
#: original_texis/eval.texi:905
#, no-wrap
msgid ""
";; @r{This gets the element that was next-to-most-recent}\n"
";;   @r{before this example.}\n"
"(nth 3 values)\n"
"     @result{} 1\n"
msgstr ""
";; @r{これは次に新しい、この例の前の次に新しい要素を取得する}\n"
"(nth 3 values)\n"
"     @result{} 1\n"

#. type: section
#: original_texis/eval.texi:910
#, no-wrap
msgid "Deferred and Lazy Evaluation"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:912
#, fuzzy, no-wrap
#| msgid "vector evaluation"
msgid "deferred evaluation"
msgstr "vector evaluation"

#. type: cindex
#: original_texis/eval.texi:913
#, fuzzy, no-wrap
#| msgid "literal evaluation"
msgid "lazy evaluation"
msgstr "literal evaluation"

#. type: Plain text
#: original_texis/eval.texi:921
msgid "Sometimes it is useful to delay the evaluation of an expression, for example if you want to avoid performing a time-consuming calculation if it turns out that the result is not needed in the future of the program.  The @file{thunk} library provides the following functions and macros to support such @dfn{deferred evaluation}:"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:922
#, no-wrap
msgid "thunk"
msgstr ""

#. type: defmac
#: original_texis/eval.texi:923
#, no-wrap
msgid "thunk-delay forms@dots{}"
msgstr ""

#. type: defmac
#: original_texis/eval.texi:928
msgid "Return a @dfn{thunk} for evaluating the @var{forms}.  A thunk is a closure (@pxref{Closures}) that inherits the lexical environment of the @code{thunk-delay} call.  Using this macro requires @code{lexical-binding}."
msgstr ""

#. type: defun
#: original_texis/eval.texi:930
#, no-wrap
msgid "thunk-force thunk"
msgstr ""

#. type: defun
#: original_texis/eval.texi:937
msgid "Force @var{thunk} to perform the evaluation of the forms specified in the @code{thunk-delay} that created the thunk.  The result of the evaluation of the last form is returned.  The @var{thunk} also ``remembers'' that it has been forced: Any further calls of @code{thunk-force} with the same @var{thunk} will just return the same result without evaluating the forms again."
msgstr ""

#. type: defmac
#: original_texis/eval.texi:939
#, no-wrap
msgid "thunk-let (bindings@dots{}) forms@dots{}"
msgstr ""

#. type: defmac
#: original_texis/eval.texi:947
msgid "This macro is analogous to @code{let} but creates ``lazy'' variable bindings.  Any binding has the form @w{@code{(@var{symbol} @var{value-form})}}.  Unlike @code{let}, the evaluation of any @var{value-form} is deferred until the binding of the according @var{symbol} is used for the first time when evaluating the @var{forms}.  Any @var{value-form} is evaluated at most once.  Using this macro requires @code{lexical-binding}."
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:950
msgid "Example:"
msgstr ""

#. type: group
#: original_texis/eval.texi:960
#, no-wrap
msgid ""
"(defun f (number)\n"
"  (thunk-let ((derived-number\n"
"              (progn (message \"Calculating 1 plus 2 times %d\" number)\n"
"                     (1+ (* 2 number)))))\n"
"    (if (> number 10)\n"
"        derived-number\n"
"      number)))\n"
msgstr ""

#. type: group
#: original_texis/eval.texi:965
#, fuzzy, no-wrap
#| msgid ""
#| "(eval 'a)\n"
#| "     @result{} 123\n"
msgid ""
"(f 5)\n"
"@result{} 5\n"
msgstr ""
"(eval 'a)\n"
"     @result{} 123\n"

#. type: group
#: original_texis/eval.texi:971
#, no-wrap
msgid ""
"(f 12)\n"
"@print{} Calculating 1 plus 2 times 12\n"
"@result{} 25\n"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:977
msgid "Because of the special nature of lazily bound variables, it is an error to set them (e.g.@: with @code{setq})."
msgstr ""

#. type: defmac
#: original_texis/eval.texi:979
#, no-wrap
msgid "thunk-let* (bindings@dots{}) forms@dots{}"
msgstr ""

#. type: defmac
#: original_texis/eval.texi:983
msgid "This is like @code{thunk-let} but any expression in @var{bindings} is allowed to refer to preceding bindings in this @code{thunk-let*} form.  Using this macro requires @code{lexical-binding}."
msgstr ""

#. type: group
#: original_texis/eval.texi:1000
#, no-wrap
msgid ""
"(thunk-let* ((x (prog2 (message \"Calculating x...\")\n"
"                    (+ 1 1)\n"
"                  (message \"Finished calculating x\")))\n"
"             (y (prog2 (message \"Calculating y...\")\n"
"                    (+ x 1)\n"
"                  (message \"Finished calculating y\")))\n"
"             (z (prog2 (message \"Calculating z...\")\n"
"                    (+ y 1)\n"
"                  (message \"Finished calculating z\")))\n"
"             (a (prog2 (message \"Calculating a...\")\n"
"                    (+ z 1)\n"
"                  (message \"Finished calculating a\"))))\n"
"  (* z x))\n"
"\n"
msgstr ""

#. type: group
#: original_texis/eval.texi:1008
#, no-wrap
msgid ""
"@print{} Calculating z...\n"
"@print{} Calculating y...\n"
"@print{} Calculating x...\n"
"@print{} Finished calculating x\n"
"@print{} Finished calculating y\n"
"@print{} Finished calculating z\n"
"@result{} 8\n"
"\n"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:1019
msgid "@code{thunk-let} and @code{thunk-let*} use thunks implicitly: their expansion creates helper symbols and binds them to thunks wrapping the binding expressions.  All references to the original variables in the body @var{forms} are then replaced by an expression that calls @code{thunk-force} with the according helper variable as the argument.  So, any code using @code{thunk-let} or @code{thunk-let*} could be rewritten to use thunks, but in many cases using these macros results in nicer code than using thunks explicitly."
msgstr ""
