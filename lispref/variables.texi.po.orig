# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Emacs 26.1-\n"
"POT-Creation-Date: 2023-10-20 10:51+0900\n"
"PO-Revision-Date: 2023-08-17 23:31+0900\n"
"Last-Translator: Takeshi Ayanokoji <takeshi.ayanokoji@gmail.com>\n"
"Language-Team: Japanese <takeshi.ayanokoji@gmail.com>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: original_texis/variables.texi:5 original_texis/variables.texi:6
#, no-wrap
msgid "Variables"
msgstr "Variables"

#. type: cindex
#: original_texis/variables.texi:7
#, no-wrap
msgid "variable"
msgstr "variable"

#. type: Plain text
#: original_texis/variables.texi:18
msgid "A @dfn{variable} is a name used in a program to stand for a value.  In Lisp, each variable is represented by a Lisp symbol (@pxref{Symbols}).  The variable name is simply the symbol's name, and the variable's value is stored in the symbol's value cell@footnote{To be precise, under the default @dfn{dynamic scoping} rule, the value cell always holds the variable's current value, but this is not the case under the @dfn{lexical scoping} rule.  @xref{Variable Scoping}, for details.}.  @xref{Symbol Components}.  In Emacs Lisp, the use of a symbol as a variable is independent of its use as a function name."
msgstr "@dfn{変数(variable)}とはプログラム内で値を表すために使用される名前です。Lispでは変数はそれぞれLispシンボルとして表されます(@ref{Symbols}を参照)。変数名は単にそのシンボルの名前であり、変数の値はそのシンボルの値セル(value cell)に格納されます@footnote{正確に言うとデフォルトの@dfn{ダイナミックスコープ(dynamic scoping)}のルールでは、値セルは常にその変数のカレント値を保持しますが、@dfn{レキシカルスコープ(lexical scoping)}では異なります。詳細は@ref{Variable Scoping}を参照してください。}。@ref{Symbol Components}を参照してください。Emacs Lispではシンボルを変数として使用することは、同じシンボルを関数名として使用することと関係ありません。"

#. type: Plain text
#: original_texis/variables.texi:25
msgid "As previously noted in this manual, a Lisp program is represented primarily by Lisp objects, and only secondarily as text.  The textual form of a Lisp program is given by the read syntax of the Lisp objects that constitute the program.  Hence, the textual form of a variable in a Lisp program is written using the read syntax for the symbol representing the variable."
msgstr "このマニュアルで前述したとおり、Lispプログラムはまず第1にLispオブジェクトとして表され、副次的にテキストとして表現されます。Lispプログラムのテキスト的な形式は、そのプログラムを構成するLispオブジェクトの入力構文により与えられます。したがってLispプログラム内の変数のテキスト的な形式は、その変数を表すシンボルの入力構文を使用して記述されます。"

#. type: section
#: original_texis/variables.texi:48 original_texis/variables.texi:50
#: original_texis/variables.texi:51
#, no-wrap
msgid "Global Variables"
msgstr "Global Variables"

#. type: menuentry
#: original_texis/variables.texi:48
msgid "Variable values that exist permanently, everywhere."
msgstr "どの場所でも永続的に存在する変数の値。"

#. type: node
#: original_texis/variables.texi:48 original_texis/variables.texi:102
#, no-wrap
msgid "Constant Variables"
msgstr "Constant Variables"

#. type: menuentry
#: original_texis/variables.texi:48
msgid "Variables that never change."
msgstr "Variables that never change."

#. type: section
#: original_texis/variables.texi:48 original_texis/variables.texi:150
#: original_texis/variables.texi:151
#, no-wrap
msgid "Local Variables"
msgstr "Local Variables"

#. type: menuentry
#: original_texis/variables.texi:48
msgid "Variable values that exist only temporarily."
msgstr "一時的にのみ存在する存在する変数の値。"

#. type: node
#: original_texis/variables.texi:48 original_texis/variables.texi:378
#, no-wrap
msgid "Void Variables"
msgstr "Void Variables"

#. type: menuentry
#: original_texis/variables.texi:48
msgid "Symbols that lack values."
msgstr "値を持たないシンボル。"

#. type: node
#: original_texis/variables.texi:48 original_texis/variables.texi:474
#, no-wrap
msgid "Defining Variables"
msgstr "Defining Variables"

#. type: menuentry
#: original_texis/variables.texi:48
msgid "A definition says a symbol is used as a variable."
msgstr "シンボルが変数として使用されていることを宣言する定義。"

#. type: node
#: original_texis/variables.texi:48 original_texis/variables.texi:622
#, no-wrap
msgid "Tips for Defining"
msgstr "Tips for Defining"

#. type: menuentry
#: original_texis/variables.texi:48
msgid "Things you should think about when you define a variable."
msgstr "変数を定義するときに考慮すべき事項。"

#. type: node
#: original_texis/variables.texi:48 original_texis/variables.texi:703
#, no-wrap
msgid "Accessing Variables"
msgstr "Accessing Variables"

#. type: menuentry
#: original_texis/variables.texi:48
msgid "Examining values of variables whose names are known only at run time."
msgstr "実行時に判明する名前をもつ変数の値を確認する。"

#. type: node
#: original_texis/variables.texi:48 original_texis/variables.texi:759
#, no-wrap
msgid "Setting Variables"
msgstr "Setting Variables"

#. type: menuentry
#: original_texis/variables.texi:48
msgid "Storing new values in variables."
msgstr "変数に新しい値を格納する。"

#. type: node
#: original_texis/variables.texi:48 original_texis/variables.texi:902
#, no-wrap
msgid "Watching Variables"
msgstr "Watching Variables"

#. type: section
#: original_texis/variables.texi:48 original_texis/variables.texi:903
#, no-wrap
msgid "Running a function when a variable is changed."
msgstr "変数が変更されたときに実行される関数。"

#. type: node
#: original_texis/variables.texi:48 original_texis/variables.texi:964
#, no-wrap
msgid "Variable Scoping"
msgstr "Variable Scoping"

#. type: menuentry
#: original_texis/variables.texi:48
msgid "How Lisp chooses among local and global values."
msgstr "Lispがローカル値とグローバル値を選択する方法。"

#. type: section
#: original_texis/variables.texi:48 original_texis/variables.texi:1409
#: original_texis/variables.texi:1410
#, no-wrap
msgid "Buffer-Local Variables"
msgstr "Buffer-Local Variables"

#. type: menuentry
#: original_texis/variables.texi:48
msgid "Variable values in effect only in one buffer."
msgstr "1つのバッファーないだけで効果をもつ変数の値。"

#. type: section
#: original_texis/variables.texi:48 original_texis/variables.texi:1928
#: original_texis/variables.texi:1929
#, no-wrap
msgid "File Local Variables"
msgstr "File Local Variables"

#. type: menuentry
#: original_texis/variables.texi:48
msgid "Handling local variable lists in files."
msgstr "ファイル内にリストされたローカル変数の処理。"

#. type: section
#: original_texis/variables.texi:48 original_texis/variables.texi:2159
#: original_texis/variables.texi:2160
#, no-wrap
msgid "Directory Local Variables"
msgstr "Directory Local Variables"

#. type: menuentry
#: original_texis/variables.texi:48
msgid "Local variables common to all files in a directory."
msgstr "ディレクトリー内のすべてのファイルで共通のローカル変数。"

#. type: section
#: original_texis/variables.texi:48 original_texis/variables.texi:2270
#: original_texis/variables.texi:2271
#, no-wrap
msgid "Connection Local Variables"
msgstr "Connection Local Variables"

#. type: menuentry
#: original_texis/variables.texi:48
msgid "Local variables common for remote connections."
msgstr "リモート接続で共通なローカル変数。"

#. type: section
#: original_texis/variables.texi:48 original_texis/variables.texi:2539
#: original_texis/variables.texi:2540
#, no-wrap
msgid "Variable Aliases"
msgstr "Variable Aliases"

#. type: menuentry
#: original_texis/variables.texi:48
msgid "Variables that are aliases for other variables."
msgstr "他の変数のエイリアスとなる変数。"

#. type: section
#: original_texis/variables.texi:48 original_texis/variables.texi:2640
#: original_texis/variables.texi:2641
#, no-wrap
msgid "Variables with Restricted Values"
msgstr "Variables with Restricted Values"

#. type: menuentry
#: original_texis/variables.texi:48
msgid "Non-constant variables whose value can @emph{not} be an arbitrary Lisp object."
msgstr "任意のLispオブジェクトを値とすることが@emph{できない}、定数ではない変数。"

#. type: section
#: original_texis/variables.texi:48 original_texis/variables.texi:2676
#: original_texis/variables.texi:2677
#, no-wrap
msgid "Generalized Variables"
msgstr "Generalized Variables"

#. type: menuentry
#: original_texis/variables.texi:48
msgid "Extending the concept of variables."
msgstr "変数の概念の拡張。"

#. type: section
#: original_texis/variables.texi:48 original_texis/variables.texi:2953
#: original_texis/variables.texi:2954
#, no-wrap
msgid "Multisession Variables"
msgstr "Multisession Variables"

#. type: menuentry
#: original_texis/variables.texi:48
msgid "Variables that survive restarting Emacs."
msgstr "Emacsを再起動しても存続する変数。"

#. type: cindex
#: original_texis/variables.texi:52
#, no-wrap
msgid "global variable"
msgstr "global variable"

#. type: Plain text
#: original_texis/variables.texi:59
msgid "The simplest way to use a variable is @dfn{globally}.  This means that the variable has just one value at a time, and this value is in effect (at least for the moment) throughout the Lisp system.  The value remains in effect until you specify a new one.  When a new value replaces the old one, no trace of the old value remains in the variable."
msgstr "変数を使用するための一番シンプルな方法は、@dfn{グローバル(globally)}を使用する方法です。これはある時点でその変数はただ1つの値をもち、その値が(少なくともその時点では)Lispシステム全体で効果をもつことを意味します。あらたな値を指定するまでその値が効果をもちます。新しい値で古い値を置き換えるとき、古い値を追跡する情報は変数内に残りません。"

#. type: Plain text
#: original_texis/variables.texi:61
msgid "You specify a value for a symbol with @code{setq}.  For example,"
msgstr "シンボルの値は@code{setq}で指定します。たとえば、"

#. type: example
#: original_texis/variables.texi:64
#, no-wrap
msgid "(setq x '(a b))\n"
msgstr "(setq x '(a b))\n"

#. type: Plain text
#: original_texis/variables.texi:71
msgid "gives the variable @code{x} the value @code{(a b)}.  Note that @code{setq} is a special form (@pxref{Special Forms}); it does not evaluate its first argument, the name of the variable, but it does evaluate the second argument, the new value."
msgstr "これは変数@code{x}に値@code{(a b)}を与えます。@code{setq}はスペシャルフォームであることに注意してください。これは1番目の引数(変数の名前)は評価しませんが、2番目の引数(新しい値)は評価します。"

#. type: Plain text
#: original_texis/variables.texi:74
msgid "Once the variable has a value, you can refer to it by using the symbol itself as an expression.  Thus,"
msgstr "変数が一度値をもつと、そのシンボル自身を式として使用することによって参照することができます。したがって、"

#. type: group
#: original_texis/variables.texi:78
#, no-wrap
msgid "x @result{} (a b)\n"
msgstr "x @result{} (a b)\n"

#. type: Plain text
#: original_texis/variables.texi:83
msgid "assuming the @code{setq} form shown above has already been executed."
msgstr "これは上記の@code{setq}フォームが実行された場合です。"

#. type: Plain text
#: original_texis/variables.texi:86
msgid "If you do set the same variable again, the new value replaces the old one:"
msgstr "同じ変数を再びセットすると、古い値は新しい値で置き換えられます:"

#. type: group
#: original_texis/variables.texi:91
#, no-wrap
msgid ""
"x\n"
"     @result{} (a b)\n"
msgstr ""
"x\n"
"     @result{} (a b)\n"

#. type: group
#: original_texis/variables.texi:95
#, no-wrap
msgid ""
"(setq x 4)\n"
"     @result{} 4\n"
msgstr ""
"(setq x 4)\n"
"     @result{} 4\n"

#. type: group
#: original_texis/variables.texi:99
#, no-wrap
msgid ""
"x\n"
"     @result{} 4\n"
msgstr ""
"x\n"
"     @result{} 4\n"

#. type: section
#: original_texis/variables.texi:103
#, no-wrap
msgid "Variables that Never Change"
msgstr "Variables that Never Change"

#. type: cindex
#: original_texis/variables.texi:104
#, no-wrap
msgid "@code{setting-constant} error"
msgstr "@code{setting-constant} error"

#. type: cindex
#: original_texis/variables.texi:105
#, no-wrap
msgid "keyword symbol"
msgstr "keyword symbol"

#. type: cindex
#: original_texis/variables.texi:106
#, no-wrap
msgid "variable with constant value"
msgstr "variable with constant value"

#. type: cindex
#: original_texis/variables.texi:107 original_texis/variables.texi:572
#, no-wrap
msgid "constant variables"
msgstr "constant variables"

#. type: cindex
#: original_texis/variables.texi:108
#, no-wrap
msgid "symbol that evaluates to itself"
msgstr "symbol that evaluates to itself"

#. type: cindex
#: original_texis/variables.texi:109
#, no-wrap
msgid "symbol with constant value"
msgstr "symbol with constant value"

#. type: Plain text
#: original_texis/variables.texi:119
msgid "In Emacs Lisp, certain symbols normally evaluate to themselves.  These include @code{nil} and @code{t}, as well as any symbol whose name starts with @samp{:} (these are called @dfn{keywords}).  These symbols cannot be rebound, nor can their values be changed.  Any attempt to set or bind @code{nil} or @code{t} signals a @code{setting-constant} error.  The same is true for a keyword (a symbol whose name starts with @samp{:}), if it is interned in the standard obarray, except that setting such a symbol to itself is not an error."
msgstr "Emacs Lispでは特定のシンボルは、通常は自分自身に評価されます。これらのシンボルには@code{nil}と@code{t}、同様に名前が@samp{:}で始まる任意のシンボル(これらは@dfn{キーワード}と呼ばれる)が含まれます。これらのシンボルはリバインドや、値の変更はできません。@code{nil}や@code{t}へのセットやリバインドは、@code{setting-constant}エラーをシグナルします。これはキーワード(名前が@samp{:}で始まるシンボル)についても当てはまります。ただしキーワードが標準のobarrayにinternされていれば、そのようなシンボルを自分自身にセットしてもエラーになりません。"

#. type: group
#: original_texis/variables.texi:124
#, no-wrap
msgid ""
"nil @equiv{} 'nil\n"
"     @result{} nil\n"
msgstr ""
"nil @equiv{} 'nil\n"
"     @result{} nil\n"

#. type: group
#: original_texis/variables.texi:128
#, no-wrap
msgid ""
"(setq nil 500)\n"
"@error{} Attempt to set constant symbol: nil\n"
msgstr ""
"(setq nil 500)\n"
"@error{} Attempt to set constant symbol: nil\n"

#. type: defun
#: original_texis/variables.texi:131
#, no-wrap
msgid "keywordp object"
msgstr "keywordp object"

#. type: defun
#: original_texis/variables.texi:135
msgid "function returns @code{t} if @var{object} is a symbol whose name starts with @samp{:}, interned in the standard obarray, and returns @code{nil} otherwise."
msgstr "この関数は@var{object}が@samp{:}で始まる名前のシンボルであり、標準のobarrayにinternされていれば@code{t}、それ以外は@code{nil}をリターンする。"

#. type: Plain text
#: original_texis/variables.texi:142
msgid "These constants are fundamentally different from the constants defined using the @code{defconst} special form (@pxref{Defining Variables}).  A @code{defconst} form serves to inform human readers that you do not intend to change the value of a variable, but Emacs does not raise an error if you actually change it."
msgstr "これらの定数はスペシャルフォーム@code{defconst}(@ref{Defining Variables}を参照)を使用して定義された定数(constant)とは根本的に異なります。@code{defconst}フォームは、人間の読み手に値の変更を意図しない変数であることを知らせる役目は果たしますが、実際にそれを変更してもEmacsはエラーを起こしません。"

#. type: cindex
#: original_texis/variables.texi:143
#, no-wrap
msgid "read-only variables"
msgstr "read-only variables"

#. type: Plain text
#: original_texis/variables.texi:149
msgid "A small number of additional symbols are made read-only for various practical reasons.  These include @code{enable-multibyte-characters}, @code{most-positive-fixnum}, @code{most-negative-fixnum}, and a few others.  Any attempt to set or bind these also signals a @code{setting-constant} error."
msgstr "現実的な種々の理由により、追加で少数のシンボルが読み取り専用になります。これらには@code{enable-multibyte-characters}、@code{most-positive-fixnum}、@code{most-negative-fixnum}の他にいくつかのシンボルが含まれます。これらにたいしてセットやバインドを試みると、すべて@code{setting-constant}エラーがシグナルされます。"

#. type: cindex
#: original_texis/variables.texi:152
#, no-wrap
msgid "binding local variables"
msgstr "binding local variables"

#. type: cindex
#: original_texis/variables.texi:153
#, no-wrap
msgid "local variables"
msgstr "local variables"

#. type: cindex
#: original_texis/variables.texi:154
#, no-wrap
msgid "local binding"
msgstr "local binding"

#. type: cindex
#: original_texis/variables.texi:155
#, no-wrap
msgid "global binding"
msgstr "global binding"

#. type: Plain text
#: original_texis/variables.texi:163
msgid "Global variables have values that last until explicitly superseded with new values.  Sometimes it is useful to give a variable a @dfn{local value}---a value that takes effect only within a certain part of a Lisp program.  When a variable has a local value, we say that it is @dfn{locally bound} to that value, and that it is a @dfn{local variable}."
msgstr "グローバル変数は新しい値で明示的に置き換えるまで値が持続します。変数に@dfn{ローカル値(local value)} --- Lispプログラム内の特定の部分で効果をもつ --- を与えると便利なときがあります。変数がローカル値をもつとき、わたしたちは変数がその値に@dfn{ローカルにバインド(locally bound)}されていると言い、その変数を@dfn{ローカル変数(local variable)}と呼びます。"

#. type: Plain text
#: original_texis/variables.texi:170
msgid "For example, when a function is called, its argument variables receive local values, which are the actual arguments supplied to the function call; these local bindings take effect within the body of the function.  To take another example, the @code{let} special form explicitly establishes local bindings for specific variables, which take effect only within the body of the @code{let} form."
msgstr "たとえば関数が呼び出されるとき、関数の引数となる変数はローカル値(その関数の呼び出しにおいて実際の引数に与えられた値)を受け取ります。これらのローカルバインディングは関数のbody内で効果をもちます。他にもたとえばスペシャルフォーム@code{let}は特定の変数にたいして明示的にローカルなバインディングを確立して、これは@code{let}フォームのbody内だけで効果を持ちます。"

#. type: Plain text
#: original_texis/variables.texi:173
msgid "We also speak of the @dfn{global binding}, which is where (conceptually) the global value is kept."
msgstr "これにたいして@dfn{グローバルなバインディング(global binding)}とは、(概念的には)グローバルな値が保持される場所です。"

#. type: cindex
#: original_texis/variables.texi:174
#, no-wrap
msgid "shadowing of variables"
msgstr "shadowing of variables"

#. type: Plain text
#: original_texis/variables.texi:182
msgid "Establishing a local binding saves away the variable's previous value (or lack of one).  We say that the previous value is @dfn{shadowed}.  Both global and local values may be shadowed.  If a local binding is in effect, using @code{setq} on the local variable stores the specified value in the local binding.  When that local binding is no longer in effect, the previously shadowed value (or lack of one) comes back."
msgstr "ローカルバインディングを確立すると、その変数の以前の値は他の場所に保存されます(または失われる)。わたしたちはこれを、以前の値が@dfn{シャドー(shadowed)}されたと言います。シャドーはグローバル変数とローカル変数の両方で発生し得ます。ローカルバインディングが効果を持つときには、ローカル変数に@code{setq}を使用することにより、指定した値をローカルバインディングに格納します。ローカルバインディングが効果を持たなくなったとき、以前にシャドーされた値が復元されます(または失われる)。"

#. type: cindex
#: original_texis/variables.texi:183
#, no-wrap
msgid "current binding"
msgstr "current binding"

#. type: Plain text
#: original_texis/variables.texi:189
msgid "A variable can have more than one local binding at a time (e.g., if there are nested @code{let} forms that bind the variable).  The @dfn{current binding} is the local binding that is actually in effect.  It determines the value returned by evaluating the variable symbol, and it is the binding acted on by @code{setq}."
msgstr "変数は同時に複数のローカルバインディングを持つことができます(たとえばその変数をバインドするネストされた@code{let})。@dfn{カレントバインディング(current binding)}とは、実際に効果を持つローカルバインディングのことです。カレントバインディングは、その変数の評価によりリターンされる値を決定し、@code{setq}により影響を受けるバインディングです。"

#. type: Plain text
#: original_texis/variables.texi:203
msgid "For most purposes, you can think of the current binding as the innermost local binding, or the global binding if there is no local binding.  To be more precise, a rule called the @dfn{scoping rule} determines where in a program a local binding takes effect.  The default scoping rule in Emacs Lisp is called @dfn{dynamic scoping}, which simply states that the current binding at any given point in the execution of a program is the most recently-created binding for that variable that still exists.  For details about dynamic scoping, and an alternative scoping rule called @dfn{lexical scoping}, @pxref{Variable Scoping}.  Lately Emacs is moving towards using lexical binding in more and more places, with the goal of eventually making lexical binding the default.  In particular, all Emacs Lisp source files and the @file{*scratch*} buffer use lexical scoping."
msgstr "ほとんどの用途において、最内(innermost)のローカルバインディングとローカルバインディングをもたないグローバルバインディングを、カレントバインディングと考えることができます。より正確に言うと、@dfn{スコープルール(scoping rule)}と呼ばれるルールは、プログラム内でローカルバインディングが効果を持つ任意の与えられた場所を決定します。Emacs Lispのスコープルールは@dfn{ダイナミックスコープ(dynamic scoping)}と呼ばれ、これは単に実行中のプログラム内の与えられた位置でのカレントバインディングを示しており、その変数がまだ存在すれば、その変数にたいしてもっとも最近作成されたバインディングです。ダイナミックスコープについての詳細、およびその代替である@dfn{レキシカルスコープ(lexical scoping)}と呼ばれるスコープルールについては、@ref{Variable Scoping}を参照してください。Emacsの最近の動向として、レキシカルバインディングをデフォルトにするという最終ゴールに向けて、レキシカルバインディングがますます多くの場所で使用される方向に進んでいます。特にEmacs Lispのソースファイルすべてと@file{*scratch*}バッファーではレキシカルなスコープが使用されています。"

#. type: Plain text
#: original_texis/variables.texi:206
msgid "The special forms @code{let} and @code{let*} exist to create local bindings:"
msgstr "スペシャルフォーム@code{let}と@code{let*}は、ローカルバインディングを作成するために存在します:"

#. type: defspec
#: original_texis/variables.texi:207
#, no-wrap
msgid "let (bindings@dots{}) forms@dots{}"
msgstr "let (bindings@dots{}) forms@dots{}"

#. type: defspec
#: original_texis/variables.texi:213
msgid "This special form sets up local bindings for a certain set of variables, as specified by @var{bindings}, and then evaluates all of the @var{forms} in textual order.  Its return value is the value of the last form in @var{forms}.  The local bindings set up by @code{let} will be in effect only within the body of @var{forms}."
msgstr "このスペシャルフォームは@var{bindings}により指定される特定の変数セットにたいするローカルバインディングをセットアップしてから、@var{forms}のすべてをテキスト順に評価する。これは@var{forms}内の最後のフォームの値をリターンする。@code{let}がセットアップしたローカルバインディングは@var{forms}のbody内でのみ効果をもつ。"

#. type: defspec
#: original_texis/variables.texi:219
msgid "Each of the @var{bindings} is either @w{(i) a} symbol, in which case that symbol is locally bound to @code{nil}; or @w{(ii) a} list of the form @code{(@var{symbol} @var{value-form})}, in which case @var{symbol} is locally bound to the result of evaluating @var{value-form}.  If @var{value-form} is omitted, @code{nil} is used."
msgstr "@var{bindings}の各バインディングは2つの形式のいずれかである。@w{(i)} シンボルなら、そのシンボルは@code{nil}にローカルにバインドされる。@w{(ii)} フォーム@code{(@var{symbol} @var{value-form})}のリストなら、@var{symbol}は@var{value-form}を評価した結果へローカルにバインドされる。@var{value-form}が省略されたら@code{nil}が使用される。"

#. type: defspec
#: original_texis/variables.texi:224
msgid "All of the @var{value-form}s in @var{bindings} are evaluated in the order they appear and @emph{before} binding any of the symbols to them.  Here is an example of this: @code{z} is bound to the old value of @code{y}, which is 2, not the new value of @code{y}, which is 1."
msgstr "@var{bindings}内のすべての@var{value-form}は、シンボルがそれらにバインドされる@emph{前}に、記述された順番に評価される。以下の例では@code{z}は@code{y}の新しい値(つまり1)にではなく、古い値(つまり2)にバインドされる。"

#. type: group
#: original_texis/variables.texi:229 original_texis/variables.texi:263
#, no-wrap
msgid ""
"(setq y 2)\n"
"     @result{} 2\n"
msgstr ""
"(setq y 2)\n"
"     @result{} 2\n"

#. type: group
#: original_texis/variables.texi:236
#, no-wrap
msgid ""
"(let ((y 1)\n"
"      (z y))\n"
"  (list y z))\n"
"     @result{} (1 2)\n"
msgstr ""
"(let ((y 1)\n"
"      (z y))\n"
"  (list y z))\n"
"     @result{} (1 2)\n"

#. type: defspec
#: original_texis/variables.texi:241
msgid "On the other hand, the order of @emph{bindings} is unspecified: in the following example, either 1 or 2 might be printed."
msgstr "その一方で@emph{bindings}の順序は指定されない。以下の例では1か2のどちらかがプリントされる。"

#. type: example
#: original_texis/variables.texi:246
#, no-wrap
msgid ""
"(let ((x 1)\n"
"      (x 2))\n"
"  (print x))\n"
msgstr ""
"(let ((x 1)\n"
"      (x 2))\n"
"  (print x))\n"

#. type: defspec
#: original_texis/variables.texi:250
msgid "Therefore, avoid binding a variable more than once in a single @code{let} form."
msgstr "したがって単一の@code{let}フォーム内で変数を複数回バインディングするのは避けること。"

#. type: defspec
#: original_texis/variables.texi:252
#, no-wrap
msgid "let* (bindings@dots{}) forms@dots{}"
msgstr "let* (bindings@dots{}) forms@dots{}"

#. type: defspec
#: original_texis/variables.texi:258
msgid "This special form is like @code{let}, but it binds each variable right after computing its local value, before computing the local value for the next variable.  Therefore, an expression in @var{bindings} can refer to the preceding symbols bound in this @code{let*} form.  Compare the following example with the example above for @code{let}."
msgstr "このスペシャルフォームは@code{let}と似ているが、次の変数値にたいするローカル値を計算する前に、ローカル値を計算してそれを変数にバインドする。したがて@var{bindings}内の式は、この@code{let*}フォーム内の前のシンボルのバインドを参照できる。以下の例を上記@code{let}の例と比較されたい。"

#. type: group
#: original_texis/variables.texi:270
#, no-wrap
msgid ""
"(let* ((y 1)\n"
"       (z y))    ; @r{Use the just-established value of @code{y}.}\n"
"  (list y z))\n"
"     @result{} (1 1)\n"
msgstr ""
"(let* ((y 1)\n"
"       (z y))    ; @r{@code{y}の値に今計算されたばかりの値を使用する}\n"
"  (list y z))\n"
"     @result{} (1 1)\n"

#. type: defspec
#: original_texis/variables.texi:276
msgid "Basically, the @code{let*} binding of @code{x} and @code{y} in the previous example is equivalent to using nested @code{let} bindings:"
msgstr "上記例における@code{x}と@code{y}の@code{let*}バインディングは、基本的には以下のようなネストされた@code{let}を使うのと同じ:"

#. type: example
#: original_texis/variables.texi:281
#, no-wrap
msgid ""
"(let ((y 1))\n"
"  (let ((z y))\n"
"    (list y z)))\n"
msgstr ""
"(let ((y 1))\n"
"  (let ((z y))\n"
"    (list y z)))\n"

#. type: defspec
#: original_texis/variables.texi:285
#, no-wrap
msgid "letrec (bindings@dots{}) forms@dots{}"
msgstr "letrec (bindings@dots{}) forms@dots{}"

#. type: defspec
#: original_texis/variables.texi:292
msgid "This special form is like @code{let*}, but all the variables are bound before any of the local values are computed.  The values are then assigned to the locally bound variables.  This is only useful when lexical binding is in effect, and you want to create closures that refer to bindings that would otherwise not yet be in effect when using @code{let*}."
msgstr "このスペシャルフォームは@code{let*}と同様だが、ローカル値を計算する前にすべての変数をバインドする。値はその後にバインドされた変数にローカルに割り当てられる。これはレキシカルバインディングが効力をもち、@code{let*}の使用しても有効にならないバインディングを参照するクロージャを作成したい場合のみ有用。"

#. type: defspec
#: original_texis/variables.texi:295
msgid "For instance, here's a closure that removes itself from a hook after being run once:"
msgstr "たとえば以下は一度実行後にフックから自身を削除するクロージャ:"

#. type: lisp
#: original_texis/variables.texi:301
#, no-wrap
msgid ""
"(letrec ((hookfun (lambda ()\n"
"                    (message \"Run once\")\n"
"                    (remove-hook 'post-command-hook hookfun))))\n"
"  (add-hook 'post-command-hook hookfun))\n"
msgstr ""
"(letrec ((hookfun (lambda ()\n"
"                    (message \"Run once\")\n"
"                    (remove-hook 'post-command-hook hookfun))))\n"
"  (add-hook 'post-command-hook hookfun))\n"

#. type: cindex
#: original_texis/variables.texi:304
#, no-wrap
msgid "dynamic binding, temporarily"
msgstr "dynamic binding, temporarily"

#. type: cindex
#: original_texis/variables.texi:305
#, no-wrap
msgid "dynamic let-binding"
msgstr "dynamic let-binding"

#. type: defspec
#: original_texis/variables.texi:306
#, no-wrap
msgid "dlet (bindings@dots{}) forms@dots{}"
msgstr "dlet (bindings@dots{}) forms@dots{}"

#. type: defspec
#: original_texis/variables.texi:312
msgid "This special form is like @code{let}, but it binds all variables dynamically.  This is rarely useful---you usually want to bind normal variables lexically, and special variables (i.e., variables that are defined with @code{defvar}) dynamically, and this is what @code{let} does."
msgstr "このスペシャルフォームは@code{let}と似ているが、すべての変数をダイナミックにバインドする。これが役に立つことは稀だろう --- 通常ならノーマル変数はレキシカルに、スペシャル変数(@code{defvar}で定義された変数)はダイナミックにバインドしたいと望むだろうし、これは正に@code{let}が行うことだからだ。"

#. type: defspec
#: original_texis/variables.texi:318
msgid "@code{dlet} can be useful when interfacing with old code that assumes that certain variables are dynamically bound (@pxref{Dynamic Binding}), but it's impractical to @code{defvar} these variables.  @code{dlet} will temporarily make the bound variables special, execute the forms, and then make the variables non-special again."
msgstr "特定の変数がダイナミックにバインド(@ref{Dynamic Binding}を参照)されていることを想定している古いコードとインターフェイスをとる際、それらの変数を@code{defvar}とするのは非現実的な場合に@code{dlet}は有用かもしれない。@code{dlet}はこれらの変数を一時的にスペシャルとしてバインドしてフォームを実行、それから再び変数を非スペシャルにする。"

#. type: defspec
#: original_texis/variables.texi:320
#, no-wrap
msgid "named-let name bindings &rest body"
msgstr "named-let name bindings &rest body"

#. type: defspec
#: original_texis/variables.texi:330
msgid "This special form is a looping construct inspired from the Scheme language.  It is similar to @code{let}: It binds the variables in @var{bindings}, and then evaluates @var{body}.  However, @code{named-let} also binds @var{name} to a local function whose formal arguments are the variables in @var{bindings} and whose body is @var{body}.  This allows @var{body} to call itself recursively by calling @var{name}, where the arguments passed to @var{name} are used as the new values of the bound variables in the recursive invocation."
msgstr "このスペシャルフォームはScheme言語からインスパイアされたロープ構文である。これは@code{let}のように@var{bindings}内の変数をバインドしてから@var{body}を評価する。ただし@code{named-let}は正規の引数が@var{bindings}内の変数で本体が@var{body}であるようなローカル関数にたいして@var{name}のバインドも行う。これにより@var{name}を呼び出して@var{body}が自身を再帰的に呼び出すことができる。再帰呼び出しにおいては、バインドされる変数の新たな値として@var{name}に渡された引数が使用される。"

#. type: defspec
#: original_texis/variables.texi:332
msgid "Example of a loop summing a list of numbers:"
msgstr "数値にリストを加算するループの例:"

#. type: lisp
#: original_texis/variables.texi:340
#, no-wrap
msgid ""
"(named-let sum ((numbers '(1 2 3 4))\n"
"                (running-sum 0))\n"
"  (if numbers\n"
"      (sum (cdr numbers) (+ running-sum (car numbers)))\n"
"    running-sum))\n"
"@result{} 10\n"
msgstr ""
"(named-let sum ((numbers '(1 2 3 4))\n"
"                (running-sum 0))\n"
"  (if numbers\n"
"      (sum (cdr numbers) (+ running-sum (car numbers)))\n"
"    running-sum))\n"
"@result{} 10\n"

#. type: anchor{#1}
#: original_texis/variables.texi:349
msgid "Tail recursion"
msgstr "Tail recursion"

#. type: defspec
#: original_texis/variables.texi:349
msgid "Recursive calls to @var{name} that occur in @emph{tail positions} in @var{body} are guaranteed to be optimized as @emph{tail calls}, which means that they will not consume any additional stack space no matter how deeply the recursion runs.  Such recursive calls will effectively jump to the top of the loop with new values for the variables."
msgstr "@var{body}の@emph{末尾位置(tail positions)}における@var{name}への再帰呼び出しは、@emph{末尾呼び出し(tail calls)}としての最適化が保証される。これは再帰の実行深さに関わらず追加のスタック空間を消費しないことを意味する。このような再帰呼び出しでは、変数にたいして新たな値でループ先頭に効果的にジャンプを行う。"

#. type: defspec
#: original_texis/variables.texi:353
msgid "A function call is in the tail position if it's the very last thing done so that the value returned by the call is the value of @var{body} itself, as is the case in the recursive call to @code{sum} above."
msgstr "一番最後に行うことが関数呼び出しならそれは末尾位置にあり、したがってその呼び出しのリターン値は上記@code{sum}にたいする再帰呼び出しと同じように@var{body}の値となる。"

#. type: defspec
#: original_texis/variables.texi:356
msgid "@strong{Warning:} @code{named-let} works as expected only when lexical-binding is enabled.  @xref{Lexical Binding}."
msgstr "@strong{警告:} @code{named-let}が期待通り動作するのはレキシカルバインディングｇ有効な場合のみ。@xref{Lexical Binding}を参照のこと。"

#. type: Plain text
#: original_texis/variables.texi:360
msgid "Here is a complete list of the other facilities that create local bindings:"
msgstr "以下はローカルバインディングを作成する他の機能のリストです:"

#. type: itemize
#: original_texis/variables.texi:364
msgid "Function calls (@pxref{Functions})."
msgstr "関数呼び出し(@ref{Functions}を参照)。"

#. type: itemize
#: original_texis/variables.texi:367
msgid "Macro calls (@pxref{Macros})."
msgstr "マクロ呼び出し(@ref{Macros}を参照)。"

#. type: itemize
#: original_texis/variables.texi:370
msgid "@code{condition-case} (@pxref{Errors})."
msgstr "@code{condition-case} (@ref{Errors}を参照)。"

#. type: Plain text
#: original_texis/variables.texi:377
msgid "Variables can also have buffer-local bindings (@pxref{Buffer-Local Variables}); a few variables have terminal-local bindings (@pxref{Multiple Terminals}).  These kinds of bindings work somewhat like ordinary local bindings, but they are localized depending on where you are in Emacs."
msgstr "変数はバッファーローカルなバインディングを持つこともできます(@ref{Buffer-Local Variables}を参照)。数は多くありませんが、端末ローカル(terminal-local)なバインディングをもつ変数もあります(@ref{Multiple Terminals}を参照)。この種のバインディングは、通常のローカルバインディングのように機能することもありますが、これらはEmacs内のどこにいるかに依存してローカルになります。"

#. type: section
#: original_texis/variables.texi:379
#, no-wrap
msgid "When a Variable is Void"
msgstr "When a Variable is Void"

#. type: cindex
#: original_texis/variables.texi:380
#, no-wrap
msgid "@code{void-variable} error"
msgstr "@code{void-variable} error"

#. type: cindex
#: original_texis/variables.texi:381
#, no-wrap
msgid "void variable"
msgstr "void variable"

#. type: Plain text
#: original_texis/variables.texi:385
msgid "We say that a variable is void if its symbol has an unassigned value cell (@pxref{Symbol Components})."
msgstr "シンボルの値セル(@ref{Symbol Components}を参照)に値が割り当てられていない場合、その変数はvoid(空)であると言います。"

#. type: Plain text
#: original_texis/variables.texi:394
msgid "Under Emacs Lisp's default dynamic scoping rule (@pxref{Variable Scoping}), the value cell stores the variable's current (local or global) value.  Note that an unassigned value cell is @emph{not} the same as having @code{nil} in the value cell.  The symbol @code{nil} is a Lisp object and can be the value of a variable, just as any other object can be; but it is still a value.  If a variable is void, trying to evaluate the variable signals a @code{void-variable} error, instead of returning a value."
msgstr "Emacs Lispのデフォルトであるダイナミックスコープルール(@ref{Variable Scoping}を参照)の下では、値セルはその変数のカレント値(ローカルまたはグローバル)を保持します。値が割り当てられていない値セルは、値セルに@code{nil}をもつのとは@emph{異なる}ことに注意してください。シンボル@code{nil}はLispオブジェクトであり、他のオブジェクトと同様に変数の値となることができます。@code{nil}は値なのです。変数がvoidの場合にその変数の評価を試みると、値をリターンするかわりに、@code{void-variable}エラーがシグナルされます。"

#. type: Plain text
#: original_texis/variables.texi:400
msgid "Under the optional lexical scoping rule, the value cell only holds the variable's global value---the value outside of any lexical binding construct.  When a variable is lexically bound, the local value is determined by the lexical environment; hence, variables can have local values even if their symbols' value cells are unassigned."
msgstr "オプションであるレキシカルスコープルール(lexical scoping rule)の下では、値セル保持できるのはその変数のグローバル値 --- 任意のレキシカルバインディング構造の外側の値だけです。変数がレキシカルにバインドされている場合、ローカル値はそのレキシカル環境により決定されます。したがってこれらのシンボルの値セルに値が割り当てられていなくても、変数はローカル値を持つことができます。"

#. type: defun
#: original_texis/variables.texi:401
#, no-wrap
msgid "makunbound symbol"
msgstr "makunbound symbol"

#. type: defun
#: original_texis/variables.texi:404
msgid "This function empties out the value cell of @var{symbol}, making the variable void.  It returns @var{symbol}."
msgstr "この関数は@var{symbol}の値セルを空にして、その変数をvoidにする。この関数は@var{symbol}をリターンする。"

#. type: defun
#: original_texis/variables.texi:410
msgid "If @var{symbol} has a dynamic local binding, @code{makunbound} voids the current binding, and this voidness lasts only as long as the local binding is in effect.  Afterwards, the previously shadowed local or global binding is reexposed; then the variable will no longer be void, unless the reexposed binding is void too."
msgstr "@var{symbol}がダイナミックなローカルバインディングをもつなら、@code{makunbound}はカレントのバインディングをvoidにして、そのローカルバインディングが効果を持つ限りvoidにする。その後で以前にシャドーされたローカル値(またはグローバル値)が再び有効になって、再び有効になった値がvoidでなければ、その変数はvoidではなくなる。"

#. type: defun
#: original_texis/variables.texi:412 original_texis/variables.texi:448
msgid "Here are some examples (assuming dynamic binding is in effect):"
msgstr "いくつか例を示す(ダイナミックバインディングが有効だとする):"

#. type: group
#: original_texis/variables.texi:421
#, no-wrap
msgid ""
"(setq x 1)               ; @r{Put a value in the global binding.}\n"
"     @result{} 1\n"
"(let ((x 2))             ; @r{Locally bind it.}\n"
"  (makunbound 'x)        ; @r{Void the local binding.}\n"
"  x)\n"
"@error{} Symbol's value as variable is void: x\n"
msgstr ""
"(setq x 1)               ; @r{グローバルバインディングに値をセットする}\n"
"     @result{} 1\n"
"(let ((x 2))             ; @r{それをローカルにバインドする}\n"
"  (makunbound 'x)        ; @r{ローカルバインディングをvoidにする}\n"
"  x)\n"
"@error{} Symbol's value as variable is void: x\n"

#. type: group
#: original_texis/variables.texi:425
#, no-wrap
msgid ""
"x                        ; @r{The global binding is unchanged.}\n"
"     @result{} 1\n"
"\n"
msgstr ""
"x                        ; @r{グローバルバインディングは変更されない}\n"
"     @result{} 1\n"
"\n"

#. type: group
#: original_texis/variables.texi:431
#, no-wrap
msgid ""
"(let ((x 2))             ; @r{Locally bind it.}\n"
"  (let ((x 3))           ; @r{And again.}\n"
"    (makunbound 'x)      ; @r{Void the innermost-local binding.}\n"
"    x))                  ; @r{And refer: it's void.}\n"
"@error{} Symbol's value as variable is void: x\n"
msgstr ""
"(let ((x 2))             ; @r{ローカルにバインドする}\n"
"  (let ((x 3))           ; @r{もう一度}\n"
"    (makunbound 'x)      ; @r{最内のローカルバインディングをvoidにする}\n"
"    x))                  ; @r{それを参照すると、void}\n"
"@error{} Symbol's value as variable is void: x\n"

#. type: group
#: original_texis/variables.texi:439
#, no-wrap
msgid ""
"(let ((x 2))\n"
"  (let ((x 3))\n"
"    (makunbound 'x))     ; @r{Void inner binding, then remove it.}\n"
"  x)                     ; @r{Now outer @code{let} binding is visible.}\n"
"     @result{} 2\n"
msgstr ""
"(let ((x 2))\n"
"  (let ((x 3))\n"
"    (makunbound 'x))     ; @r{内側のバインディングをvoidにしてから取り除く}\n"
"  x)                     ; @r{外側の@code{let}バインディングが有効になる}\n"
"     @result{} 2\n"

#. type: defun
#: original_texis/variables.texi:443
#, no-wrap
msgid "boundp variable"
msgstr "boundp variable"

#. type: defun
#: original_texis/variables.texi:446
msgid "This function returns @code{t} if @var{variable} (a symbol) is not void, and @code{nil} if it is void."
msgstr "この関数は@var{variable}(シンボル)がvoidでなければ@code{t}、voidなら@code{nil}をリターンする。"

#. type: group
#: original_texis/variables.texi:453
#, no-wrap
msgid ""
"(boundp 'abracadabra)          ; @r{Starts out void.}\n"
"     @result{} nil\n"
msgstr ""
"(boundp 'abracadabra)          ; @r{最初はvoid}\n"
"     @result{} nil\n"

#. type: group
#: original_texis/variables.texi:458
#, no-wrap
msgid ""
"(let ((abracadabra 5))         ; @r{Locally bind it.}\n"
"  (boundp 'abracadabra))\n"
"     @result{} t\n"
msgstr ""
"(let ((abracadabra 5))         ; @r{ローカルにバインドする}\n"
"  (boundp 'abracadabra))\n"
"     @result{} t\n"

#. type: group
#: original_texis/variables.texi:462
#, no-wrap
msgid ""
"(boundp 'abracadabra)          ; @r{Still globally void.}\n"
"     @result{} nil\n"
msgstr ""
"(boundp 'abracadabra)          ; @r{グローバルではまだvoid}\n"
"     @result{} nil\n"

#. type: group
#: original_texis/variables.texi:466
#, no-wrap
msgid ""
"(setq abracadabra 5)           ; @r{Make it globally nonvoid.}\n"
"     @result{} 5\n"
msgstr ""
"(setq abracadabra 5)           ; @r{グローバルで非voidにする}\n"
"     @result{} 5\n"

#. type: group
#: original_texis/variables.texi:470
#, no-wrap
msgid ""
"(boundp 'abracadabra)\n"
"     @result{} t\n"
msgstr ""
"(boundp 'abracadabra)\n"
"     @result{} t\n"

#. type: section
#: original_texis/variables.texi:475
#, no-wrap
msgid "Defining Global Variables"
msgstr "Defining Global Variables"

#. type: cindex
#: original_texis/variables.texi:476
#, no-wrap
msgid "variable definition"
msgstr "variable definition"

#. type: Plain text
#: original_texis/variables.texi:481
msgid "A @dfn{variable definition} is a construct that announces your intention to use a symbol as a global variable.  It uses the special forms @code{defvar} or @code{defconst}, which are documented below."
msgstr "@dfn{変数定義(variable definition)}とは、そのシンボルをグローバル変数として使用する意図を表明する構文です。これには以下で説明するスペシャルフォーム@code{defvar}や@code{defconst}が使用されます。"

#. type: Plain text
#: original_texis/variables.texi:488
msgid "A variable definition serves three purposes.  First, it informs people who read the code that the symbol is @emph{intended} to be used a certain way (as a variable).  Second, it informs the Lisp system of this, optionally supplying an initial value and a documentation string.  Third, it provides information to programming tools such as @command{etags}, allowing them to find where the variable was defined."
msgstr "変数宣言は3つの目的をもちます。1番目はコードを読む人にたいして、そのシンボルが特定の方法(変数として)使用されることを@emph{意図}したものだと知らせることです。2番目はLispシステムにたいしてオプションで初期値とドキュメント文字列を与えて、これを知らせることです。3番目は@command{etags}のようなプログラミングツールにたいして、その変数が定義されている場所を見つけられるように情報を提供することです。"

#. type: Plain text
#: original_texis/variables.texi:496
msgid "The difference between @code{defconst} and @code{defvar} is mainly a matter of intent, serving to inform human readers of whether the value should ever change.  Emacs Lisp does not actually prevent you from changing the value of a variable defined with @code{defconst}.  One notable difference between the two forms is that @code{defconst} unconditionally initializes the variable, whereas @code{defvar} initializes it only if it is originally void."
msgstr "@code{defconst}と@code{defvar}の主な違いは、人間の読み手に値が変更されるかどうかを知らせることにあります。Emacs Lispは実際に、@code{defconst}で定義された変数の値の変更を妨げません。この2つのフォームの特筆すべき違いは、@code{defconst}は無条件で変数を初期化して、@code{defvar}は変数が元々voidのときだけ初期化することです。"

#. type: Plain text
#: original_texis/variables.texi:500
msgid "To define a customizable variable, you should use @code{defcustom} (which calls @code{defvar} as a subroutine).  @xref{Variable Definitions}."
msgstr "カスタマイズ可能な変数を定義する場合は、@code{defcustom}を使用するべきです(これはサブルーチンとして@code{defvar}を呼び出す)。@ref{Variable Definitions}を参照してください。"

#. type: defspec
#: original_texis/variables.texi:501
#, no-wrap
msgid "defvar symbol [value [doc-string]]"
msgstr "defvar symbol [value [doc-string]]"

#. type: defspec
#: original_texis/variables.texi:507
msgid "This special form defines @var{symbol} as a variable.  Note that @var{symbol} is not evaluated; the symbol to be defined should appear explicitly in the @code{defvar} form.  The variable is marked as @dfn{special}, meaning that it should always be dynamically bound (@pxref{Variable Scoping})."
msgstr "このスペシャルフォームは変数として@var{symbol}を定義する。@var{symbol}が評価されないことに注意。シンボルは@code{defvar}フォーム内に明示的に表記して定義される必要がある。この変数は@dfn{特別}だとマークされて、これは常に変数がダイナミックにバインドされることを意味する(@ref{Variable Scoping}を参照)。"

#. type: defspec
#: original_texis/variables.texi:514
msgid "If @var{value} is specified, and @var{symbol} is void (i.e., it has no dynamically bound value; @pxref{Void Variables}), then @var{value} is evaluated and @var{symbol} is set to the result.  But if @var{symbol} is not void, @var{value} is not evaluated, and @var{symbol}'s value is left unchanged.  If @var{value} is omitted, the value of @var{symbol} is not changed in any case."
msgstr "@var{value}が指定されていて@var{symbol}がvoid(たとえばこのシンボルがダイナミックにバインドされた値を持たないとき。@ref{Void Variables}を参照)なら@var{value}が評価されて、その結果が@var{symbol}にセットされる。しかし@var{symbol}がvoidでなければ、@var{value}は評価されず@var{symbol}の値は変更されない。@var{value}が省略された場合は、いかなる場合も@var{symbol}の値は変更されない。"

#. type: defspec
#: original_texis/variables.texi:520
msgid "Note that specifying a value, even @code{nil}, marks the variable as special permanently.  Whereas if @var{value} is omitted then the variable is only marked special locally (i.e.@: within the current lexical scope, or file if at the top-level).  This can be useful for suppressing byte compilation warnings, see @ref{Compiler Errors}."
msgstr "たとえ@code{nil}であっても値を指定することにより、その変数は特別だと永続的にマークされることに注意。一方で@var{value}が省略されると変数はローカル(カレントのレキシカルスコープまたはトップレベルにあればファイル)でのみ特別だとマークされる。これはバイトコンパイルの警告を抑止するために有用。@ref{Compiler Errors}を参照のこと。"

#. type: defspec
#: original_texis/variables.texi:525
msgid "If @var{symbol} has a buffer-local binding in the current buffer, @code{defvar} acts on the default value, which is buffer-independent, rather than the buffer-local binding.  It sets the default value if the default value is void.  @xref{Buffer-Local Variables}."
msgstr "@var{symbol}がカレントバッファー内でバッファーローカルなバインディングをもつ場合、@code{defvar}はデフォルト値に作用する。デフォルト値はバッファーローカルなバインディングではなく、バッファーにたいして独立である。デフォルト値がvoidのときはデフォルト値をセットする。@ref{Buffer-Local Variables}を参照のこと。"

#. type: defspec
#: original_texis/variables.texi:531
msgid "If @var{symbol} is already let bound (e.g., if the @code{defvar} form occurs in a @code{let} form), then @code{defvar} sets the toplevel default value, like @code{set-default-toplevel-value}.  The let binding remains in effect until its binding construct exits.  @xref{Variable Scoping}."
msgstr "すでに@var{symbol}がletバインドされている(たとえば@code{let}フォーム内に@code{defvar}がある)場合には、@code{set-default-toplevel-value}と同じように@code{defvar}はトップレベルの値をセットする。letバインディングの構文を抜けるまでバインディングの効果は持続する。@ref{Variable Scoping}を参照のこと。"

#. type: cindex
#: original_texis/variables.texi:532
#, no-wrap
msgid "@code{eval-defun}, and @code{defvar} forms"
msgstr "control.texi.po"

#. type: cindex
#: original_texis/variables.texi:533
#, no-wrap
msgid "@code{eval-last-sexp}, and @code{defvar} forms"
msgstr "@code{eval-last-sexp}, and @code{defvar} forms"

#. type: defspec
#: original_texis/variables.texi:539
msgid "When you evaluate a top-level @code{defvar} form with @kbd{C-M-x} (@code{eval-defun}) or with @kbd{C-x C-e} (@code{eval-last-sexp}) in Emacs Lisp mode, a special feature of these two commands arranges to set the variable unconditionally, without testing whether its value is void."
msgstr "@kbd{C-M-x} (@code{eval-defun})、またはEmacs Lispモードで@kbd{C-x C-e} (@code{eval-last-sexp})によりトップレベルの@code{defvar}を評価する際には、これら2つのコマンドの特別な機能はその値がvoidであるかテストすることなく、その変数を無条件にセットする。"

#. type: defspec
#: original_texis/variables.texi:543
msgid "If the @var{doc-string} argument is supplied, it specifies the documentation string for the variable (stored in the symbol's @code{variable-documentation} property).  @xref{Documentation}."
msgstr "引数@var{doc-string}が与えられたら、それは変数にたいするドキュメント文字列を指定する(そのシンボルの@code{variable-documentation}プロパティに格納される)。@ref{Documentation}を参照のこと。"

#. type: defspec
#: original_texis/variables.texi:546
msgid "Here are some examples.  This form defines @code{foo} but does not initialize it:"
msgstr "以下にいくつか例を示す。これは@code{foo}を定義するが初期化は行わない:"

#. type: group
#: original_texis/variables.texi:551
#, no-wrap
msgid ""
"(defvar foo)\n"
"     @result{} foo\n"
msgstr ""
"(defvar foo)\n"
"     @result{} foo\n"

#. type: defspec
#: original_texis/variables.texi:556
msgid "This example initializes the value of @code{bar} to @code{23}, and gives it a documentation string:"
msgstr "以下の例は@code{bar}の値を@code{23}に初期化してドキュメント文字列を与える:"

#. type: group
#: original_texis/variables.texi:562
#, no-wrap
msgid ""
"(defvar bar 23\n"
"  \"The normal weight of a bar.\")\n"
"     @result{} bar\n"
msgstr ""
"(defvar bar 23\n"
"  \"The normal weight of a bar.\")\n"
"     @result{} bar\n"

#. type: defspec
#: original_texis/variables.texi:567
msgid "The @code{defvar} form returns @var{symbol}, but it is normally used at top level in a file where its value does not matter."
msgstr "@code{defvar}フォームは@var{symbol}をリターンするが、これは通常は値が問題にならないファイル内のトップレベルで使用される。"

#. type: defspec
#: original_texis/variables.texi:570
msgid "For a more elaborate example of using @code{defvar} without a value, see @ref{Local defvar example}."
msgstr "値をもたない@code{defvar}のより詳細な使用例は@ref{Local defvar example}を参照のこと。"

#. type: defspec
#: original_texis/variables.texi:573
#, no-wrap
msgid "defconst symbol value [doc-string]"
msgstr "defconst symbol value [doc-string]"

#. type: defspec
#: original_texis/variables.texi:579
msgid "This special form defines @var{symbol} as a value and initializes it.  It informs a person reading your code that @var{symbol} has a standard global value, established here, that should not be changed by the user or by other programs.  Note that @var{symbol} is not evaluated; the symbol to be defined must appear explicitly in the @code{defconst}."
msgstr "このスペシャルフォームはある値で@var{symbol}を定義して、それを初期化する。これはコードを読む人に、@var{symbol}がここで設定される標準的なグローバル値をもち、ユーザーや他のプログラムがそれを変更すべきではないことを知らせる。@var{symbol}が評価されないことに注意。定義されるシンボルは@code{defconst}内に明示的に記されなければならない。"

#. type: defspec
#: original_texis/variables.texi:584
msgid "The @code{defconst} form, like @code{defvar}, marks the variable as @dfn{special}, meaning that it should always be dynamically bound (@pxref{Variable Scoping}).  In addition, it marks the variable as risky (@pxref{File Local Variables})."
msgstr "@code{defvar}と同様、@code{defconst}は変数を@dfn{特別} --- この変数が常にダイナミックにバインドされているという意味 --- であるとマークする(@ref{Variable Scoping}を参照)。加えてこれはその変数を危険であるとマークする(@ref{File Local Variables}を参照)。"

#. type: defspec
#: original_texis/variables.texi:591
msgid "@code{defconst} always evaluates @var{value}, and sets the value of @var{symbol} to the result.  If @var{symbol} does have a buffer-local binding in the current buffer, @code{defconst} sets the default value, not the buffer-local value.  (But you should not be making buffer-local bindings for a symbol that is defined with @code{defconst}.)"
msgstr "@code{defconst}は常に@var{value}を評価して、その結果を@var{symbol}の値にセットする。カレントバッファー内で@var{symbol}がバッファーローカルなバインディングをもつなら、@code{defconst}はデフォルト値ではなくバッファーローカルな値をセットする(しかし@code{defconst}で定義されたシンボルにたいしてバッファーローカルなバインディングを作らないこと)。"

#. type: defspec
#: original_texis/variables.texi:597
msgid "An example of the use of @code{defconst} is Emacs's definition of @code{float-pi}---the mathematical constant @math{pi}, which ought not to be changed by anyone (attempts by the Indiana State Legislature notwithstanding).  As the second form illustrates, however, @code{defconst} is only advisory."
msgstr "@code{defconst}の使い方の例は、Emacsの@code{float-pi} --- (たとえインディアナ州議会が何を試みようと)何者かにより変更されるべきではない数学定数@math{pi}にたいする定義である。しかし2番目の@code{defconst}の例のように、これは単にアドバイス的なものである。"

#. type: group
#: original_texis/variables.texi:602
#, no-wrap
msgid ""
"(defconst float-pi 3.141592653589793 \"The value of Pi.\")\n"
"     @result{} float-pi\n"
msgstr ""
"(defconst float-pi 3.141592653589793 \"The value of Pi.\")\n"
"     @result{} float-pi\n"

#. type: group
#: original_texis/variables.texi:606
#, no-wrap
msgid ""
"(setq float-pi 3)\n"
"     @result{} float-pi\n"
msgstr ""
"(setq float-pi 3)\n"
"     @result{} float-pi\n"

#. type: group
#: original_texis/variables.texi:610
#, no-wrap
msgid ""
"float-pi\n"
"     @result{} 3\n"
msgstr ""
"float-pi\n"
"     @result{} 3\n"

#. type: Plain text
#: original_texis/variables.texi:621
msgid "@strong{Warning:} If you use a @code{defconst} or @code{defvar} special form while the variable has a local binding (made with @code{let}, or a function argument), it sets the local binding rather than the global binding.  This is not what you usually want.  To prevent this, use these special forms at top level in a file, where normally no local binding is in effect, and make sure to load the file before making a local binding for the variable."
msgstr "@strong{警告:} 変数がローカルバインディングをもつとき(@code{let}により作成された、または関数の引数の場合)に、スペシャルフォーム@code{defconst}または@code{defvar}を使用すると、これらのフォームはグローバルバインディングではなく、ローカルバインディングをセットします。これは通常は、あなたが望むことではないはずです。これを防ぐには、これらのスペシャルフォームをファイル内のトップレベルで使用します。この場所は通常、何のローカルバインディングも効果をもたないので、その変数にたいするローカルバインディングが作成される前にファイルがロードされることが確実だからです。"

#. type: section
#: original_texis/variables.texi:623
#, no-wrap
msgid "Tips for Defining Variables Robustly"
msgstr "Tips for Defining Variables Robustly"

#. type: Plain text
#: original_texis/variables.texi:628
msgid "When you define a variable whose value is a function, or a list of functions, use a name that ends in @samp{-function} or @samp{-functions}, respectively."
msgstr "値が関数(または関数のリスト)であるような変数を定義するときには、変数の名前の最後に@samp{-function}(または@samp{-functions})を使用します。"

#. type: Plain text
#: original_texis/variables.texi:631
msgid "There are several other variable name conventions; here is a complete list:"
msgstr "他にも変数名に関する慣習があります。以下はその完全なリストです:"

#. type: item
#: original_texis/variables.texi:633
#, no-wrap
msgid "@dots{}-hook"
msgstr "@dots{}-hook"

#. type: table
#: original_texis/variables.texi:635
msgid "The variable is a normal hook (@pxref{Hooks})."
msgstr "変数はノーマルフック(@ref{Hooks}を参照)。"

#. type: item
#: original_texis/variables.texi:636
#, no-wrap
msgid "@dots{}-function"
msgstr "@dots{}-function"

#. type: table
#: original_texis/variables.texi:638
msgid "The value is a function."
msgstr "値は関数。"

#. type: item
#: original_texis/variables.texi:639
#, no-wrap
msgid "@dots{}-functions"
msgstr "@dots{}-functions"

#. type: table
#: original_texis/variables.texi:641
msgid "The value is a list of functions."
msgstr "値は関数のリスト。"

#. type: item
#: original_texis/variables.texi:642
#, no-wrap
msgid "@dots{}-form"
msgstr "@dots{}-form"

#. type: table
#: original_texis/variables.texi:644
msgid "The value is a form (an expression)."
msgstr "値はフォーム(式)。"

#. type: item
#: original_texis/variables.texi:645
#, no-wrap
msgid "@dots{}-forms"
msgstr "@dots{}-forms"

#. type: table
#: original_texis/variables.texi:647
msgid "The value is a list of forms (expressions)."
msgstr "値はフォーム(式)のリスト。"

#. type: item
#: original_texis/variables.texi:648
#, no-wrap
msgid "@dots{}-predicate"
msgstr "@dots{}-predicate"

#. type: table
#: original_texis/variables.texi:651
msgid "The value is a predicate---a function of one argument that returns non-@code{nil} for success and @code{nil} for failure."
msgstr "値は述語(predicate) --- 1つの引数をとる関数 --- であり成功なら非@code{nil}、失敗なら@code{nil}をリターンする。"

#. type: item
#: original_texis/variables.texi:652
#, no-wrap
msgid "@dots{}-flag"
msgstr "@dots{}-flag"

#. type: table
#: original_texis/variables.texi:656
msgid "The value is significant only as to whether it is @code{nil} or not.  Since such variables often end up acquiring more values over time, this convention is not strongly recommended."
msgstr "@code{nil}か否かだけが意味をもつような値。結局そのような変数は、やがては多くの値をもつことが多いので、この慣習を強く推奨はしない。"

#. type: item
#: original_texis/variables.texi:657
#, no-wrap
msgid "@dots{}-program"
msgstr "@dots{}-program"

#. type: table
#: original_texis/variables.texi:659
msgid "The value is a program name."
msgstr "値はプログラム名。"

#. type: item
#: original_texis/variables.texi:660
#, no-wrap
msgid "@dots{}-command"
msgstr "@dots{}-command"

#. type: table
#: original_texis/variables.texi:662
msgid "The value is a whole shell command."
msgstr "値は完全なシェルコマンド。"

#. type: item
#: original_texis/variables.texi:663
#, no-wrap
msgid "@dots{}-switches"
msgstr "@dots{}-switches"

#. type: table
#: original_texis/variables.texi:665
msgid "The value specifies options for a command."
msgstr "値はコマンドにたいして指定するオプション。"

#. type: item
#: original_texis/variables.texi:666
#, no-wrap
msgid "@var{prefix}--@dots{}"
msgstr "@var{prefix}--@dots{}"

#. type: table
#: original_texis/variables.texi:670
msgid "The variable is intended for internal use and is defined in the file @file{@var{prefix}.el}.  (Emacs code contributed before 2018 may follow other conventions, which are being phased out.)"
msgstr "これは内部的な使用を意図した変数でありファイル@file{@var{prefix}.el}内で定義される(他の規約にしたがうかもしれない2018年以前に貢献されたEmacsコードは段階的に廃止される)。"

#. type: item
#: original_texis/variables.texi:671
#, no-wrap
msgid "@dots{}-internal"
msgstr "@dots{}-internal"

#. type: table
#: original_texis/variables.texi:675
msgid "The variable is intended for internal use and is defined in C code.  (Emacs code contributed before 2018 may follow other conventions, which are being phased out.)"
msgstr "これは内部的な使用を意図した変数でありファイルCコード内で定義される(他の規約にしたがうかもしれない2018年以前に貢献されたEmacsコードは段階的に廃止される)。"

#. type: Plain text
#: original_texis/variables.texi:679
msgid "When you define a variable, always consider whether you should mark it as safe or risky; see @ref{File Local Variables}."
msgstr "変数を定義するときは、その変数を安全(safe)とマークすべきか、それとも危険(risky)とマークすべきかを常に考慮してください。@ref{File Local Variables}を参照してください。"

#. type: Plain text
#: original_texis/variables.texi:683
#, fuzzy
#| msgid "When defining and initializing a variable that holds a complicated value (such as a keymap with bindings in it), it's best to put the entire computation of the value into the @code{defvar}, like this:"
msgid "When defining and initializing a variable that holds a complicated value (such as a syntax table for a major mode), it's best to put the entire computation of the value into the @code{defvar}, like this:"
msgstr "複雑な値を保持する変数(バインディングをもつkeymapなど)の定義や初期化を行う場合は、以下のように値の計算をすべて@code{defvar}の中に配置するのが最良です:"

#. type: example
#: original_texis/variables.texi:691
#, fuzzy, no-wrap
#| msgid ""
#| "(defvar my-mode-map\n"
#| "  (let ((map (make-sparse-keymap)))\n"
#| "    (keymap-set map \"C-c C-a\" 'my-command)\n"
#| "    @dots{}\n"
#| "    map)\n"
#| "  @var{docstring})\n"
msgid ""
"(defvar my-major-mode-syntax-table\n"
"  (let ((table (make-syntax-table)))\n"
"    (modify-syntax-entry ?# \"<\" table)\n"
"    @dots{}\n"
"    table)\n"
"  @var{docstring})\n"
msgstr ""
"(defvar my-mode-map\n"
"  (let ((map (make-sparse-keymap)))\n"
"    (keymap-set map \"C-c C-a\" 'my-command)\n"
"    @dots{}\n"
"    map)\n"
"  @var{docstring})\n"

#. type: Plain text
#: original_texis/variables.texi:702
#, fuzzy
#| msgid "This method has several benefits.  First, if the user quits while loading the file, the variable is either still uninitialized or initialized properly, never in-between.  If it is still uninitialized, reloading the file will initialize it properly.  Second, reloading the file once the variable is initialized will not alter it; that is important if the user has run hooks to alter part of the contents (such as, to rebind keys).  Third, evaluating the @code{defvar} form with @kbd{C-M-x} will reinitialize the map completely."
msgid "This method has several benefits.  First, if the user quits while loading the file, the variable is either still uninitialized or initialized properly, never in-between.  If it is still uninitialized, reloading the file will initialize it properly.  Second, reloading the file once the variable is initialized will not alter it; that is important if the user has changed its value.  Third, evaluating the @code{defvar} form with @kbd{C-M-x} will reinitialize the variable completely."
msgstr "この方法にはいくつかの利点があります。1つ目はファールをロード中にユーザーが中断した場合、変数はまだ初期化されていないか、初期化されているかのどちらかであり、その中間ということはありません。まだ初期化されていなければ、ファイルをリロードすれば正しく初期化されます。2つ目は一度初期化された変数は、ファイルをリロードしても変更されないことです。コンテンツの一部を変更(たとえばキーのリバインド)するフックをユーザーが実行した場合などに、これは重要です。3つ目は@kbd{C-M-x}で@code{defvar}を評価すると、そのマップは完全に再初期化されることです。"

#. type: section
#: original_texis/variables.texi:704
#, no-wrap
msgid "Accessing Variable Values"
msgstr "Accessing Variable Values"

#. type: Plain text
#: original_texis/variables.texi:708
msgid "The usual way to reference a variable is to write the symbol which names it.  @xref{Symbol Forms}."
msgstr "変数を参照する通常の方法は、それに名前をつけるシンボルを記述する方法です。@ref{Symbol Forms}を参照してください。"

#. type: Plain text
#: original_texis/variables.texi:713
msgid "Occasionally, you may want to reference a variable which is only determined at run time.  In that case, you cannot specify the variable name in the text of the program.  You can use the @code{symbol-value} function to extract the value."
msgstr "実行時にのみ決定される変数を参照したいときがあるかもしれません。そのような場合、プログラム中のテキストで変数名を指定することはできません。そのような値を抽出するために@code{symbol-value}を使うことができます。"

#. type: defun
#: original_texis/variables.texi:714
#, no-wrap
msgid "symbol-value symbol"
msgstr "symbol-value symbol"

#. type: defun
#: original_texis/variables.texi:719
msgid "This function returns the value stored in @var{symbol}'s value cell.  This is where the variable's current (dynamic) value is stored.  If the variable has no local binding, this is simply its global value.  If the variable is void, a @code{void-variable} error is signaled."
msgstr "この関数は@var{symbol}の値セルに格納された値をリターンする。これはその変数の(ダイナミックな)カレント値が格納された場所である。その変数がローカルバインディングをもたなければ単にその変数のグローバル値になる。変数がvoidなら@code{void-variable}はエラーをシグナルする。"

#. type: defun
#: original_texis/variables.texi:724
msgid "If the variable is lexically bound, the value reported by @code{symbol-value} is not necessarily the same as the variable's lexical value, which is determined by the lexical environment rather than the symbol's value cell.  @xref{Variable Scoping}."
msgstr "その変数がレキシカルにバインドされていれば、@code{symbol-value}が報告する値は、その変数のレキシカル値と同じである必要はない。レキシカル値はそのシンボルの値セルではなく、レキシカル環境により決定される。@ref{Variable Scoping}を参照のこと。"

#. type: group
#: original_texis/variables.texi:729
#, no-wrap
msgid ""
"(setq abracadabra 5)\n"
"     @result{} 5\n"
msgstr ""
"(setq abracadabra 5)\n"
"     @result{} 5\n"

#. type: group
#: original_texis/variables.texi:733
#, no-wrap
msgid ""
"(setq foo 9)\n"
"     @result{} 9\n"
msgstr ""
"(setq foo 9)\n"
"     @result{} 9\n"

#. type: group
#: original_texis/variables.texi:741
#, no-wrap
msgid ""
";; @r{Here the symbol @code{abracadabra}}\n"
";;   @r{is the symbol whose value is examined.}\n"
"(let ((abracadabra 'foo))\n"
"  (symbol-value 'abracadabra))\n"
"     @result{} foo\n"
msgstr ""
";; @r{ここでシンボル@code{abracadabra}}\n"
";;   @r{は値がテストされるシンボル}\n"
"(let ((abracadabra 'foo))\n"
"  (symbol-value 'abracadabra))\n"
"     @result{} foo\n"

#. type: group
#: original_texis/variables.texi:750
#, no-wrap
msgid ""
";; @r{Here, the value of @code{abracadabra},}\n"
";;   @r{which is @code{foo},}\n"
";;   @r{is the symbol whose value is examined.}\n"
"(let ((abracadabra 'foo))\n"
"  (symbol-value abracadabra))\n"
"     @result{} 9\n"
msgstr ""
";; @r{ここでは@code{abracadabra}の値、}\n"
";;   @r{つまり@code{foo}が値を}\n"
";;   @r{テストされるシンボル}\n"
"(let ((abracadabra 'foo))\n"
"  (symbol-value abracadabra))\n"
"     @result{} 9\n"

#. type: group
#: original_texis/variables.texi:755
#, no-wrap
msgid ""
"(symbol-value 'abracadabra)\n"
"     @result{} 5\n"
msgstr ""
"(symbol-value 'abracadabra)\n"
"     @result{} 5\n"

#. type: section
#: original_texis/variables.texi:760
#, no-wrap
msgid "Setting Variable Values"
msgstr "Setting Variable Values"

#. type: Plain text
#: original_texis/variables.texi:765
msgid "The usual way to change the value of a variable is with the special form @code{setq}.  When you need to compute the choice of variable at run time, use the function @code{set}."
msgstr "ある変数の値を変更する通常の方法は、スペシャルフォーム@code{setq}を使用する方法です。実行時に変数選択を計算する必要がある場合には関数@code{set}を使用します。"

#. type: defspec
#: original_texis/variables.texi:766
#, no-wrap
msgid "setq [symbol form]@dots{}"
msgstr "setq [symbol form]@dots{}"

#. type: defspec
#: original_texis/variables.texi:771
msgid "This special form is the most common method of changing a variable's value.  Each @var{symbol} is given a new value, which is the result of evaluating the corresponding @var{form}.  The current binding of the symbol is changed."
msgstr "このスペシャルフォームは、変数の値を変更するためのもっとも一般的な方法である。@var{symbol}にはそれぞれ、新しい値(対応する@var{form}が評価された結果)が与えられる。そのシンボルのカレントバインディングは変更される。"

#. type: defspec
#: original_texis/variables.texi:775
msgid "@code{setq} does not evaluate @var{symbol}; it sets the symbol that you write.  We say that this argument is @dfn{automatically quoted}.  The @samp{q} in @code{setq} stands for ``quoted''."
msgstr "@code{setq}は@var{symbol}を評価せずに、記述されたシンボルをセットする。この引数のことを@dfn{自動的にクォートされた(automatically quoted)}と呼ぶ。@code{setq}の@samp{q}は``quoted(クォートされた)''が由来。"

#. type: defspec
#: original_texis/variables.texi:777
msgid "The value of the @code{setq} form is the value of the last @var{form}."
msgstr "@code{setq}フォームの値は最後の@var{form}の値となる。"

#. type: group
#: original_texis/variables.texi:782
#, no-wrap
msgid ""
"(setq x (1+ 2))\n"
"     @result{} 3\n"
msgstr ""
"(setq x (1+ 2))\n"
"     @result{} 3\n"

#. type: example
#: original_texis/variables.texi:785
#, no-wrap
msgid ""
"x                   ; @r{@code{x} now has a global value.}\n"
"     @result{} 3\n"
msgstr ""
"x                   ; @r{ここで@code{x}はグローバル値をもつ}\n"
"     @result{} 3\n"

#. type: group
#: original_texis/variables.texi:790
#, no-wrap
msgid ""
"(let ((x 5))\n"
"  (setq x 6)        ; @r{The local binding of @code{x} is set.}\n"
"  x)\n"
"     @result{} 6\n"
msgstr ""
"(let ((x 5))\n"
"  (setq x 6)        ; @r{@code{x}のローカルバインディングをセット}\n"
"  x)\n"
"     @result{} 6\n"

#. type: example
#: original_texis/variables.texi:793
#, no-wrap
msgid ""
"x                   ; @r{The global value is unchanged.}\n"
"     @result{} 3\n"
msgstr ""
"x                   ; @r{グローバル値は変更されない}\n"
"     @result{} 3\n"

#. type: defspec
#: original_texis/variables.texi:798
msgid "Note that the first @var{form} is evaluated, then the first @var{symbol} is set, then the second @var{form} is evaluated, then the second @var{symbol} is set, and so on:"
msgstr "1番目の@var{form}が評価されてから1番目の@var{symbol}がセット、次に2番目の@var{form}が評価されてから@var{symbol}が評価されて、...となることに注意:"

#. type: group
#: original_texis/variables.texi:804
#, no-wrap
msgid ""
"(setq x 10          ; @r{Notice that @code{x} is set before}\n"
"      y (1+ x))     ;   @r{the value of @code{y} is computed.}\n"
"     @result{} 11\n"
msgstr ""
"(setq x 10          ; @r{ここで、@code{x}がセットされるのは}\n"
"      y (1+ x))     ;   @r{@code{y}の計算前であることに注目}\n"
"     @result{} 11\n"

#. type: defun
#: original_texis/variables.texi:808
#, no-wrap
msgid "set symbol value"
msgstr "set symbol value"

#. type: defun
#: original_texis/variables.texi:813
msgid "This function puts @var{value} in the value cell of @var{symbol}.  Since it is a function rather than a special form, the expression written for @var{symbol} is evaluated to obtain the symbol to set.  The return value is @var{value}."
msgstr "この関数は@var{symbol}の値セルに@var{value}を配置する。これはスペシャルフォームではなく関数なので、シンボルにセットするために@var{symbol}に記述された式は評価される。リターン値は@var{value}。"

#. type: defun
#: original_texis/variables.texi:820
msgid "When dynamic variable binding is in effect (the default), @code{set} has the same effect as @code{setq}, apart from the fact that @code{set} evaluates its @var{symbol} argument whereas @code{setq} does not.  But when a variable is lexically bound, @code{set} affects its @emph{dynamic} value, whereas @code{setq} affects its current (lexical) value.  @xref{Variable Scoping}."
msgstr "ダイナミックな変数バインドが有効(デフォルト)なら、@code{set}は自身の引数@var{symbol}を評価するが、@code{setq}は評価しないという点を除き、@code{set}は@code{setq}と同じ効果をもつ。しかし変数がレキシカルバインドなら、@code{set}は変数の@emph{ダイナミック}な値に、@code{setq}は変数のカレント値(レキシカル値)に影響する。@ref{Variable Scoping}を参照のこと。"

#. type: group
#: original_texis/variables.texi:825
#, no-wrap
msgid ""
"(set one 1)\n"
"@error{} Symbol's value as variable is void: one\n"
msgstr ""
"(set one 1)\n"
"@error{} Symbol's value as variable is void: one\n"

#. type: group
#: original_texis/variables.texi:829
#, no-wrap
msgid ""
"(set 'one 1)\n"
"     @result{} 1\n"
msgstr ""
"(set 'one 1)\n"
"     @result{} 1\n"

#. type: group
#: original_texis/variables.texi:833
#, no-wrap
msgid ""
"(set 'two 'one)\n"
"     @result{} one\n"
msgstr ""
"(set 'two 'one)\n"
"     @result{} one\n"

#. type: group
#: original_texis/variables.texi:837
#, no-wrap
msgid ""
"(set two 2)         ; @r{@code{two} evaluates to symbol @code{one}.}\n"
"     @result{} 2\n"
msgstr ""
"(set two 2)         ; @r{@code{two}はシンボル@code{one}に評価される}\n"
"     @result{} 2\n"

#. type: group
#: original_texis/variables.texi:845
#, no-wrap
msgid ""
"one                 ; @r{So it is @code{one} that was set.}\n"
"     @result{} 2\n"
"(let ((one 1))      ; @r{This binding of @code{one} is set,}\n"
"  (set 'one 3)      ;   @r{not the global value.}\n"
"  one)\n"
"     @result{} 3\n"
msgstr ""
"one                 ; @r{したがって@code{one}がセットされる}\n"
"     @result{} 2\n"
"(let ((one 1))      ; @r{@code{one}のこのバインディングがセットされる}\n"
"  (set 'one 3)      ;   @r{のであってグローバル値はセットされない}\n"
"  one)\n"
"     @result{} 3\n"

#. type: group
#: original_texis/variables.texi:849
#, no-wrap
msgid ""
"one\n"
"     @result{} 2\n"
msgstr ""
"one\n"
"     @result{} 2\n"

#. type: defun
#: original_texis/variables.texi:854
msgid "If @var{symbol} is not actually a symbol, a @code{wrong-type-argument} error is signaled."
msgstr "@var{symbol}が実際のシンボルでなければ@code{wrong-type-argument}エラーがシグナルされる。"

#. type: example
#: original_texis/variables.texi:858
#, no-wrap
msgid ""
"(set '(x y) 'z)\n"
"@error{} Wrong type argument: symbolp, (x y)\n"
msgstr ""
"(set '(x y) 'z)\n"
"@error{} Wrong type argument: symbolp, (x y)\n"

#. type: defmac
#: original_texis/variables.texi:861
#, no-wrap
msgid "setopt [symbol form]@dots{}"
msgstr "setopt [symbol form]@dots{}"

#. type: defmac
#: original_texis/variables.texi:867
msgid "This is like @code{setq} (see above), but meant for user options.  This macro uses the Customize machinery to set the variable(s)  (@pxref{Variable Definitions}).  In particular, @code{setopt} will run the setter function associated with the variable.  For instance, if you have:"
msgstr "これは@code{setq}(上記参照)と似ているがユーザーオプションを意図したマクロであり、変数(複数可)のセットにCustomizeの仕組みを使用している(@ref{Variable Definitions}を参照)。特に@code{setopt}はその変数に割り当てられたset用の関数を実行する。たとえば以下のような場合に:"

#. type: group
#: original_texis/variables.texi:876
#, no-wrap
msgid ""
"(defcustom my-var 1\n"
"  \"My var.\"\n"
"  :type 'number\n"
"  :set (lambda (var val)\n"
"         (set-default var val)\n"
"         (message \"We set %s to %s\" var val)))\n"
msgstr ""
"(defcustom my-var 1\n"
"  \"My var.\"\n"
"  :type 'number\n"
"  :set (lambda (var val)\n"
"         (set-default var val)\n"
"         (message \"We set %s to %s\" var val)))\n"

#. type: defmac
#: original_texis/variables.texi:882
msgid "then the following, in addition to setting @code{my-var} to @samp{2}, will also issue a message:"
msgstr "ここで次を実行すると@code{my-var}に@samp{2}がセットされるとともに、メッセージも発行されるだろう:"

#. type: example
#: original_texis/variables.texi:885
#, no-wrap
msgid "(setopt my-var 2)\n"
msgstr "(setopt my-var 2)\n"

#. type: defmac
#: original_texis/variables.texi:890
msgid "@code{setopt} also checks whether the value is valid for the user option.  For instance, using @code{setopt} to set a user option defined with a @code{number} type to a string will signal an error."
msgstr "ユーザーオプションにたいして@code{setopt}は値が妥当かどうかのチェックも行う。たとえば@code{setopt}で@code{number}タイプと定義されたユーザーオプションに文字列をセットするとエラーがシグナルされるだろう。"

#. type: defmac
#: original_texis/variables.texi:896
msgid "Unlike @code{defcustom} and related customization commands, such as @code{customize-variable}, @code{setopt} is meant for non-interactive use, in particular in the user init file.  For that reason, it doesn't record the standard, saved, and user-set values, and doesn't mark the variable as candidate for saving in the custom file."
msgstr "@code{defcustom}や@code{customize-variable}のようなCustomize関連コマンドとは異なり、@code{setopt}は非インタラクティブな使用、特にユーザーのinitファイルでの使用を意図している。この理由により値がstandard、saved、user-setのいずれなのかは記録せず、customファイルへの保存用に変数をマークすることも行わない。"

#. type: defmac
#: original_texis/variables.texi:900
msgid "The @code{setopt} macro can be used on regular, non-user option variables, but is much less efficient than @code{setq}.  The main use case for this macro is setting user options in the user's init file."
msgstr "@code{setopt}マクロはユーザーオプションではない通常の変数にも使用できるが、@code{setq}に比べると効率において遥かに劣る。このマクロのユースケースは、主にinitファイル内でのユーザーオプションのセットである。"

#. type: cindex
#: original_texis/variables.texi:904
#, no-wrap
msgid "variable watchpoints"
msgstr "variable watchpoints"

#. type: cindex
#: original_texis/variables.texi:905
#, no-wrap
msgid "watchpoints for Lisp variables"
msgstr "watchpoints for Lisp variables"

#. type: Plain text
#: original_texis/variables.texi:912
msgid "It is sometimes useful to take some action when a variable changes its value.  The @dfn{variable watchpoint} facility provides the means to do so.  Some possible uses for this feature include keeping display in sync with variable settings, and invoking the debugger to track down unexpected changes to variables (@pxref{Variable Debugging})."
msgstr "変数の値が変化したときに何らかのアクションを行えれば便利なときがあります。@dfn{変数watchpoint(variable watchpoint)}機能はそのための機能を提供します。この機能の有効な利用方法としては変数セッティングと表示の同期、変数への予期せぬ変更を追跡するためのデバッガの呼び出しが含まれます(@ref{Variable Debugging}を参照)。"

#. type: Plain text
#: original_texis/variables.texi:915
msgid "The following functions may be used to manipulate and query the watch functions for a variable."
msgstr "以下の関数は関数にたいするwatch関数の操作や問い合わせに使用できます。"

#. type: defun
#: original_texis/variables.texi:916
#, no-wrap
msgid "add-variable-watcher symbol watch-function"
msgstr "add-variable-watcher symbol watch-function"

#. type: defun
#: original_texis/variables.texi:920
msgid "This function arranges for @var{watch-function} to be called whenever @var{symbol} is modified.  Modifications through aliases (@pxref{Variable Aliases}) will have the same effect."
msgstr "この関数は@var{symbol}が変化したときは常に@var{watch-function}が呼び出されるようにアレンジする。エイリアスを介した変更にも同じ効果をもつ(@ref{Variable Aliases}を参照)。"

#. type: defun
#: original_texis/variables.texi:932
msgid "@var{watch-function} will be called, just before changing the value of @var{symbol}, with 4 arguments: @var{symbol}, @var{newval}, @var{operation}, and @var{where}.  @var{symbol} is the variable being changed.  @var{newval} is the value it will be changed to.  (The old value is available to @var{watch-function} as the value of @var{symbol}, since it was not yet changed to @var{newval}.)  @var{operation} is a symbol representing the kind of change, one of: @code{set}, @code{let}, @code{unlet}, @code{makunbound}, or @code{defvaralias}.  @var{where} is a buffer if the buffer-local value of the variable is being changed, @code{nil} otherwise."
msgstr "@var{watch-function}は@var{symbol}の値の変更直前に@var{symbol}、@var{newval}、@var{operation}、@var{where}という4つの引数で呼び出される。@var{symbol}は変更される変数、@var{newval}は変更後の値(@var{watch-function}では@var{newval}に変更される前なので古い値は@var{symbol}の値で利用可能)、@var{operation}は変更の種類を表すシンボルであり@code{set}、@code{let}、@code{unlet}、@code{makunbound}、@code{defvaralias}のいずれか。@var{where}は変数のバッファーローカルな値が変更される場合にはバッファー、それ以外は@code{nil}。"

#. type: defun
#: original_texis/variables.texi:934
#, no-wrap
msgid "remove-variable-watcher symbol watch-function"
msgstr "remove-variable-watcher symbol watch-function"

#. type: defun
#: original_texis/variables.texi:937
msgid "This function removes @var{watch-function} from @var{symbol}'s list of watchers."
msgstr "この関数は@var{symbol}のwatcherリストから@var{watch-function}を削除する。"

#. type: defun
#: original_texis/variables.texi:939
#, no-wrap
msgid "get-variable-watchers symbol"
msgstr "get-variable-watchers symbol"

#. type: defun
#: original_texis/variables.texi:942
msgid "This function returns the list of @var{symbol}'s active watcher functions."
msgstr "この関数は@var{symbol}のアクティブなwatcher関数のリストをリターンする。"

#. type: subsection
#: original_texis/variables.texi:944
#, no-wrap
msgid "Limitations"
msgstr "Limitations"

#. type: Plain text
#: original_texis/variables.texi:948
msgid "There are a couple of ways in which a variable could be modified (or at least appear to be modified) without triggering a watchpoint."
msgstr "watchpointをトリガーせずに変数が変更される(または少なくとも変更されたように見える)方法がいくつかあります。"

#. type: Plain text
#: original_texis/variables.texi:952
msgid "Since watchpoints are attached to symbols, modification to the objects contained within variables (e.g., by a list modification function @pxref{Modifying Lists}) is not caught by this mechanism."
msgstr "watchpointはシンボルにアタッチされるので変数内に含まれるオブジェクトの変更(リスト変更関数による変更。@ref{Modifying Lists}を参照のこと)はこのメカニズムにより検出されません。"

#. type: Plain text
#: original_texis/variables.texi:955
msgid "Additionally, C code can modify the value of variables directly, bypassing the watchpoint mechanism."
msgstr "さらにCのコードはwatchpointメカニズムをバイパスして変数の値を直接変更できます。"

#. type: Plain text
#: original_texis/variables.texi:962
msgid "A minor limitation of this feature, again because it targets symbols, is that only variables of dynamic scope may be watched.  This poses little difficulty, since modifications to lexical variables can be discovered easily by inspecting the code within the scope of the variable (unlike dynamic variables, which can be modified by any code at all, @pxref{Variable Scoping})."
msgstr "繰り返しになりますがこれはシンボルをターゲットとするので、この機能のマイナーな制限はダイナミックなスコープをもつ変数だけをウォッチできるということです。レキシカル変数への変更は変数スコープ内のコードを調べれば容易に発見できるので、これが問題をもたらすことは稀でしょう(結局のところいかなるコードからも変更され得るダイナミック変数とは異なる。@ref{Variable Scoping}を参照のこと)。"

#. type: section
#: original_texis/variables.texi:965
#, no-wrap
msgid "Scoping Rules for Variable Bindings"
msgstr "Scoping Rules for Variable Bindings"

#. type: cindex
#: original_texis/variables.texi:966
#, no-wrap
msgid "scoping rule"
msgstr "scoping rule"

#. type: Plain text
#: original_texis/variables.texi:971
msgid "When you create a local binding for a variable, that binding takes effect only within a limited portion of the program (@pxref{Local Variables}).  This section describes exactly what this means."
msgstr "ある変数にたいするローカルバインディングを作成するとき、そのバインディングはプログラムの限られた一部だけに効果をもちます(@ref{Local Variables}を参照)。このセクションでは、これが正確には何を意味するかについて説明します。"

#. type: cindex
#: original_texis/variables.texi:972
#, no-wrap
msgid "scope"
msgstr "scope"

#. type: cindex
#: original_texis/variables.texi:973
#, no-wrap
msgid "extent"
msgstr "extent"

#. type: Plain text
#: original_texis/variables.texi:978
msgid "Each local binding has a certain @dfn{scope} and @dfn{extent}.  @dfn{Scope} refers to @emph{where} in the textual source code the binding can be accessed.  @dfn{Extent} refers to @emph{when}, as the program is executing, the binding exists."
msgstr "ローカルバインディングはそれぞれ、個別に@dfn{スコープ(scope: 範囲という意味)}と@dfn{エクステント(extent: これも範囲を意味する)}をもちます。@dfn{スコープ}はそのバインディングにアクセスできるのが、テキストのソースコードの@emph{どこ(where)}であるかを示します。@dfn{エクステント}はプログラムの実行中に、そのバインディングが存在するのが@emph{いつ(when)}であるかを示します。"

#. type: cindex
#: original_texis/variables.texi:979
#, no-wrap
msgid "dynamic binding"
msgstr "dynamic binding"

#. type: cindex
#: original_texis/variables.texi:980
#, no-wrap
msgid "dynamic scope"
msgstr "dynamic scope"

#. type: cindex
#: original_texis/variables.texi:981
#, no-wrap
msgid "dynamic extent"
msgstr "dynamic extent"

#. type: Plain text
#: original_texis/variables.texi:988
msgid "By default, the local bindings that Emacs creates are @dfn{dynamic bindings}.  Such a binding has @dfn{dynamic scope}, meaning that any part of the program can potentially access the variable binding.  It also has @dfn{dynamic extent}, meaning that the binding lasts only while the binding construct (such as the body of a @code{let} form) is being executed."
msgstr "デフォルトではEmacsが作成したローカルバインディングは、@dfn{ダイナミックバインディング(dynamic binding)}です。このようなバインディングは@dfn{ダイナミックスコープ(dynamic scope)}をもち、それはプログラムの任意の範囲が、その変数バインディングにアクセスするかもしれないことを意味します。これは@dfn{ダイナミックエクステント(dynamic extent)}ももっています。これはそのバインディング構造(@code{let}フォームのbodyなど)が実行される間だけ、そのバインディングが存続することを意味します。"

#. type: cindex
#: original_texis/variables.texi:989
#, no-wrap
msgid "lexical binding"
msgstr "lexical binding"

#. type: cindex
#: original_texis/variables.texi:990
#, no-wrap
msgid "lexical scope"
msgstr "lexical scope"

#. type: cindex
#: original_texis/variables.texi:991
#, no-wrap
msgid "indefinite extent"
msgstr "indefinite extent"

#. type: Plain text
#: original_texis/variables.texi:1000
msgid "Emacs can optionally create @dfn{lexical bindings}.  A lexical binding has @dfn{lexical scope}, meaning that any reference to the variable must be located textually within the binding construct@footnote{With some exceptions; for instance, a lexical binding can also be accessed from the Lisp debugger.}.  It also has @dfn{indefinite extent}, meaning that under some circumstances the binding can live on even after the binding construct has finished executing, by means of special objects called @dfn{closures}."
msgstr "Emacsはオプションで@dfn{レキシカルバインディング(lexical binding)}を作成することができます。レキシカルバインディングは@dfn{レキシカルスコープ(lexical scope)}をもち、これはその変数にたいするすべての参照が、バインディング構文内にテキスト的に配置されなければならないことを意味します@footnote{これにはいくつか例外があります。たとえばレキシカルバインディングは、Lispデバッガーからもアクセスできます。}。レキシカルバインディングは@dfn{不定エクステント(indefinite extent)}ももっています。これはある状況下において、@dfn{クロージャ(closures)}と呼ばれるスペシャルオブジェクトにより、バインディング構造が実行を終えた後でさえも、存続し続けることを意味します。"

#. type: Plain text
#: original_texis/variables.texi:1005
msgid "The dynamic binding was (and still is) the default in Emacs for many years, but lately Emacs is moving towards using lexical binding in more and more places, with the goal of eventually making that the default."
msgstr "Emacsでは長年に渡り(そして現在でも)ダイナミックバインディングがデフォルトでしたが、最近の動向としてはレキシカルバインディングをデフォルトにするという最終ゴールに向けて、レキシカルバインディングがますます多くの場所で使用される方向に進んでいます。"

#. type: Plain text
#: original_texis/variables.texi:1009
msgid "The following subsections describe dynamic binding and lexical binding in greater detail, and how to enable lexical binding in Emacs Lisp programs."
msgstr "以降のサブセクションでは、ダイナミックバインディングとレキシカルバインディング、およびEmacs Lispプログラムでレキシカルバインディングを有効にする方法についてより詳細に説明します。"

#. type: subsection
#: original_texis/variables.texi:1016 original_texis/variables.texi:1018
#: original_texis/variables.texi:1019
#, no-wrap
msgid "Dynamic Binding"
msgstr "Dynamic Binding"

#. type: menuentry
#: original_texis/variables.texi:1016
msgid "The default for binding local variables in Emacs."
msgstr "Emacs内でのローカル変数にたいするデフォルトのバインディング。"

#. type: node
#: original_texis/variables.texi:1016 original_texis/variables.texi:1092
#, no-wrap
msgid "Dynamic Binding Tips"
msgstr "Dynamic Binding Tips"

#. type: menuentry
#: original_texis/variables.texi:1016
msgid "Avoiding problems with dynamic binding."
msgstr "ダイナミックバインディングによる問題を回避する。"

#. type: subsection
#: original_texis/variables.texi:1016 original_texis/variables.texi:1138
#: original_texis/variables.texi:1139
#, no-wrap
msgid "Lexical Binding"
msgstr "Lexical Binding"

#. type: menuentry
#: original_texis/variables.texi:1016
msgid "A different type of local variable binding."
msgstr "ローカル変数にたいする他の種類のバインディング。"

#. type: subsection
#: original_texis/variables.texi:1016 original_texis/variables.texi:1252
#: original_texis/variables.texi:1253
#, no-wrap
msgid "Using Lexical Binding"
msgstr "Using Lexical Binding"

#. type: menuentry
#: original_texis/variables.texi:1016
msgid "How to enable lexical binding."
msgstr "レキシカルバインディングを有効にする方法。"

#. type: subsection
#: original_texis/variables.texi:1016 original_texis/variables.texi:1332
#: original_texis/variables.texi:1333
#, no-wrap
msgid "Converting to Lexical Binding"
msgstr "Converting to Lexical Binding"

#. type: menuentry
#: original_texis/variables.texi:1016
msgid "Convert existing code to lexical binding."
msgstr "既存コードからレキシカルバインディングへの変換。"

#. type: Plain text
#: original_texis/variables.texi:1026
msgid "By default, the local variable bindings made by Emacs are dynamic bindings.  When a variable is dynamically bound, its current binding at any point in the execution of the Lisp program is simply the most recently-created dynamic local binding for that symbol, or the global binding if there is no such local binding."
msgstr "デフォルトでは、Emacsにより作成されるローカル変数のバインディングはダイナミックバインディングです。ある変数がダイナミックにバインドされていると、Lispプログラムの実行における任意のポイントでのカレントバインディングは、単にそのシンボルにたいしてもっとも最近作成されたダイナミックなローカルバインディング、またはそのようなローカルバインディングが存在しなければグローバルバインディングになります。"

#. type: Plain text
#: original_texis/variables.texi:1029
msgid "Dynamic bindings have dynamic scope and extent, as shown by the following example:"
msgstr "以下の例のように、ダイナミックバインディングはダイナミックスコープとダイナミックエクステントをもちます:"

#. type: group
#: original_texis/variables.texi:1033
#, no-wrap
msgid ""
"(defvar x -99)  ; @r{@code{x} receives an initial value of @minus{}99.}\n"
"\n"
msgstr ""
"(defvar x -99)  ; @r{@code{x}は初期値として@minus{}99を受け取る}\n"
"\n"

#. type: group
#: original_texis/variables.texi:1036 original_texis/variables.texi:1166
#, no-wrap
msgid ""
"(defun getx ()\n"
"  x)            ; @r{@code{x} is used free in this function.}\n"
"\n"
msgstr ""
"(defun getx ()\n"
"  x)            ; @r{この関数内では@code{x}は自由に使用される}\n"
"\n"

#. type: group
#: original_texis/variables.texi:1040
#, no-wrap
msgid ""
"(let ((x 1))    ; @r{@code{x} is dynamically bound.}\n"
"  (getx))\n"
"     @result{} 1\n"
"\n"
msgstr ""
"(let ((x 1))    ; @r{@code{x}はダイナミックにバインドされている}\n"
"  (getx))\n"
"     @result{} 1\n"
"\n"

#. type: group
#: original_texis/variables.texi:1043 original_texis/variables.texi:1075
#, no-wrap
msgid ""
";; @r{After the @code{let} form finishes, @code{x} reverts to its}\n"
";; @r{previous value, which is @minus{}99.}\n"
"\n"
msgstr ""
";; @r{@code{let}フォームが終了した後に}\n"
";; @r{@code{x}は前の値@minus{}99にリバートされる}\n"
"\n"

#. type: group
#: original_texis/variables.texi:1046
#, no-wrap
msgid ""
"(getx)\n"
"     @result{} -99\n"
msgstr ""
"(getx)\n"
"     @result{} -99\n"

#. type: Plain text
#: original_texis/variables.texi:1057
msgid "The function @code{getx} refers to @code{x}.  This is a @dfn{free} reference, in the sense that there is no binding for @code{x} within that @code{defun} construct itself.  When we call @code{getx} from within a @code{let} form in which @code{x} is (dynamically) bound, it retrieves the local value (i.e., 1).  But when we call @code{getx} outside the @code{let} form, it retrieves the global value (i.e., @minus{}99)."
msgstr "関数@code{getx}は@code{x}を参照します。@code{defun}構文自体の中に@code{x}にたいするバインディングが存在しないという意味において、これは@dfn{フリー}な参照です。@code{x}が(ダイナミックに)バインドされている@code{let}フォーム内から@code{getx}を呼び出すと、ローカル値(つまり1)が取得されます。しかしその後@code{let}フォームの外側から@code{getx}を呼び出すと、グローバル値(つまり@minus{}99)が取得されます。"

#. type: Plain text
#: original_texis/variables.texi:1060
msgid "Here is another example, which illustrates setting a dynamically bound variable using @code{setq}:"
msgstr "以下は@code{setq}を使用してダイナミックに変数をバインドする例です:"

#. type: group
#: original_texis/variables.texi:1064
#, no-wrap
msgid ""
"(defvar x -99)      ; @r{@code{x} receives an initial value of @minus{}99.}\n"
"\n"
msgstr ""
"(defvar x -99)      ; @r{@code{x}は初期値として@minus{}99を受け取る}\n"
"\n"

#. type: group
#: original_texis/variables.texi:1067
#, no-wrap
msgid ""
"(defun addx ()\n"
"  (setq x (1+ x)))  ; @r{Add 1 to @code{x} and return its new value.}\n"
"\n"
msgstr ""
"(defun addx ()\n"
"  (setq x (1+ x)))  ; @r{@code{x}に1加算して新しい値をリターンする}\n"
"\n"

#. type: group
#: original_texis/variables.texi:1072
#, no-wrap
msgid ""
"(let ((x 1))\n"
"  (addx)\n"
"  (addx))\n"
"     @result{} 3           ; @r{The two @code{addx} calls add to @code{x} twice.}\n"
"\n"
msgstr ""
"(let ((x 1))\n"
"  (addx)\n"
"  (addx))\n"
"     @result{} 3           ; @r{@code{addx}を2回呼び出すと@code{x}に2回加算される}\n"
"\n"

#. type: group
#: original_texis/variables.texi:1078
#, no-wrap
msgid ""
"(addx)\n"
"     @result{} -98\n"
msgstr ""
"(addx)\n"
"     @result{} -98\n"

#. type: Plain text
#: original_texis/variables.texi:1088
msgid "Dynamic binding is implemented in Emacs Lisp in a simple way.  Each symbol has a value cell, which specifies its current dynamic value (or absence of value).  @xref{Symbol Components}.  When a symbol is given a dynamic local binding, Emacs records the contents of the value cell (or absence thereof) in a stack, and stores the new local value in the value cell.  When the binding construct finishes executing, Emacs pops the old value off the stack, and puts it in the value cell."
msgstr "Emacs Lispでのダイナミックバインディングは、シンプルな方法で実装されています。シンボルはそれぞれ、シンボルのカレントのダイナミック値(または値の不在)を指定する値セルをもちます。@ref{Symbol Components}を参照してください。あるシンボルがダイナミックなローカル値を与えられたとき、Emacsは値セルの内容(または値の不在)をスタックに記録して、新しいローカル値を値セルに格納します。バインディング構文が実行を終えたとき、Emacsはスタックから古い値をpopして値セルにそれを配置します。"

#. type: Plain text
#: original_texis/variables.texi:1091
msgid "Note that when code using Dynamic Binding is native compiled the native compiler will not perform any Lisp specific optimization."
msgstr "ダイナミックバインディングを使用したコードのネイティブコンパイル時には、ネイティブコンパイラーはLisp固有の最適化を何も行わないことに注意してください。"

#. type: subsection
#: original_texis/variables.texi:1093
#, no-wrap
msgid "Proper Use of Dynamic Binding"
msgstr "Proper Use of Dynamic Binding"

#. type: Plain text
#: original_texis/variables.texi:1100
msgid "Dynamic binding is a powerful feature, as it allows programs to refer to variables that are not defined within their local textual scope.  However, if used without restraint, this can also make programs hard to understand.  There are two clean ways to use this technique:"
msgstr "ダイナミックバインディングは、プログラムにたいしてテキスト的なローカルスコープ内で定義されていない変数を参照することを許容する、強力な機能です。しかし無制限に使用した場合には、プログラムの理解を困難にしてしまうこともあります。このテクニックを使用するために2つの明解な方法があります:"

#. type: itemize
#: original_texis/variables.texi:1109
msgid "If a variable has no global definition, use it as a local variable only within a binding construct, such as the body of the @code{let} form where the variable was bound.  If this convention is followed consistently throughout a program, the value of the variable will not affect, nor be affected by, any uses of the same variable symbol elsewhere in the program."
msgstr "ある変数がグローバルな定義をもたなければ、ローカル変数としてバインディング構文内(その変数がバインドされる@code{let}フォームのbodyなどの場所)だけでそれを使用する。プログラムでこの慣習に一貫してしたがえば、プログラム内の他の場所で同じ変数シンボルを任意に使用しても、その変数の値に影響を与えたり、影響を受けることがなくなる。"

#. type: itemize
#: original_texis/variables.texi:1118
msgid "Otherwise, define the variable with @code{defvar}, @code{defconst} (@pxref{Defining Variables}), or @code{defcustom} (@pxref{Variable Definitions}).  Usually, the definition should be at top-level in an Emacs Lisp file.  As far as possible, it should include a documentation string which explains the meaning and purpose of the variable.  You should also choose the variable's name to avoid name conflicts (@pxref{Coding Conventions})."
msgstr "それ以外では@code{defvar}、@code{defconst} (@ref{Defining Variables}を参照)、@code{defcustom} (@ref{Variable Definitions}を参照)で変数を定義する。この定義は通常はEmacs Lispファイル内のトップレベルであること。この定義には可能な限り変数の意味と目的を説明するドキュメント文字列を含めること。また名前の衝突を避けるように変数を命名すること(@ref{Coding Conventions}を参照)。"

#. type: itemize
#: original_texis/variables.texi:1124
msgid "Then you can bind the variable anywhere in a program, knowing reliably what the effect will be.  Wherever you encounter the variable, it will be easy to refer back to the definition, e.g., via the @kbd{C-h v} command (provided the variable definition has been loaded into Emacs).  @xref{Name Help,,, emacs, The GNU Emacs Manual}."
msgstr "そうすればプログラム内のどこか別の場所で、それが何に影響するか確信をもって変数をバインドすることができます。その変数にどこで出会っても、(たとえば変数の定義がEmacsにロードされていれば@kbd{C-h v}コマンドを通じて)定義を参照するのが簡単になります。@ref{Name Help,,, emacs, The GNU Emacs Manual}を参照してください。"

#. type: itemize
#: original_texis/variables.texi:1127
msgid "For example, it is common to use local bindings for customizable variables like @code{case-fold-search}:"
msgstr "たとえば@code{case-fold-search}のようなカスタマイズ可能な変数にたいしてローカルバインディングを使用するのは一般的です:"

#. type: group
#: original_texis/variables.texi:1134
#, no-wrap
msgid ""
"(defun search-for-abc ()\n"
"  \"Search for the string \\\"abc\\\", ignoring case differences.\"\n"
"  (let ((case-fold-search t))\n"
"    (re-search-forward \"abc\")))\n"
msgstr ""
"(defun search-for-abc ()\n"
"  \"Search for the string \\\"abc\\\", ignoring case differences.\"\n"
"  (let ((case-fold-search t))\n"
"    (re-search-forward \"abc\")))\n"

#. type: Plain text
#: original_texis/variables.texi:1147
msgid "Lexical binding was introduced to Emacs, as an optional feature, in version 24.1.  We expect its importance to increase with time.  Lexical binding opens up many more opportunities for optimization, so programs using it are likely to run faster in future Emacs versions.  Lexical binding is also more compatible with concurrency, which was added to Emacs in version 26.1."
msgstr "Emacsのバージョン24.1からオプションの機能としてレキシカルバインディングが導入されました。わたしたちはこの機能の重要性が時とともに増加することを期待します。レキシカルバインディングは最適化の機会をより広げるので、この機能を使用するプログラムはおそらく将来のEmacsバージョンで高速に実行されるようになるでしょう。レキシカルバインディングは、バージョン26.1のEmacsで追加した並列性(concurrency)とも互換があります。"

#. type: Plain text
#: original_texis/variables.texi:1151
msgid "A lexically-bound variable has @dfn{lexical scope}, meaning that any reference to the variable must be located textually within the binding construct.  Here is an example"
msgstr "レキシカルにバインドされた変数は@dfn{レキシカルスコープ(lexical scope)}をもちます。これはその変数にたいする参照が、そのバインディング構文内にテキスト的に配置されなければならないことを意味しています。以下は例です"

#. type: iftex
#: original_texis/variables.texi:1153
msgid "(see the next subsection, for how to actually enable lexical binding):"
msgstr "(実際にレキシカルバインディングを有功にする方法は、次のサブセクションを参照のこと):"

#. type: ifnottex
#: original_texis/variables.texi:1156
msgid "(@pxref{Using Lexical Binding}, for how to actually enable lexical binding):"
msgstr "(実際にレキシカルバインディングを有功にする方法は、@ref{Using Lexical Binding}を参照のこと):"

#. type: group
#: original_texis/variables.texi:1163
#, no-wrap
msgid ""
"(let ((x 1))    ; @r{@code{x} is lexically bound.}\n"
"  (+ x 3))\n"
"     @result{} 4\n"
"\n"
msgstr ""
"(let ((x 1))    ; @r{@code{x}はレキシカルにバインドされる}\n"
"  (+ x 3))\n"
"     @result{} 4\n"
"\n"

#. type: group
#: original_texis/variables.texi:1170
#, no-wrap
msgid ""
"(let ((x 1))    ; @r{@code{x} is lexically bound.}\n"
"  (getx))\n"
"@error{} Symbol's value as variable is void: x\n"
msgstr ""
"(let ((x 1))    ; @r{@code{x}はレキシカルにバインドされる}\n"
"  (getx))\n"
"@error{} Symbol's value as variable is void: x\n"

#. type: Plain text
#: original_texis/variables.texi:1180
msgid "Here, the variable @code{x} has no global value.  When it is lexically bound within a @code{let} form, it can be used in the textual confines of that @code{let} form.  But it can @emph{not} be used from within a @code{getx} function called from the @code{let} form, since the function definition of @code{getx} occurs outside the @code{let} form itself."
msgstr "ここでは@code{x}はグローバル値をもちません。@code{let}フォーム内でレキシカルにバインドされたとき、この変数は@code{let}のテキスト境界内で使用できます。しかしこの@code{let}内から呼び出される@code{getx}関数からは、@code{getx}の関数定義が@code{let}フォームの外側なので使用することが@emph{できません}。"

#. type: cindex
#: original_texis/variables.texi:1181
#, no-wrap
msgid "lexical environment"
msgstr "lexical environment"

#. type: Plain text
#: original_texis/variables.texi:1188
msgid "Here is how lexical binding works.  Each binding construct defines a @dfn{lexical environment}, specifying the variables that are bound within the construct and their local values.  When the Lisp evaluator wants the current value of a variable, it looks first in the lexical environment; if the variable is not specified in there, it looks in the symbol's value cell, where the dynamic value is stored."
msgstr "レキシカルバインディングが機能する方法を説明します。バインディング構文はぞれぞれ、その構文内でローカル値にバインドする変数を指定する、@dfn{レキシカル環境(lexical environment)}を定義します。Lispの評価機能(Lisp evaluator)が、ある変数のカレント値を得たいときは、最初にレキシカル環境内を探します。そこで変数が指定されていなければ、ダイナミック値が格納されるシンボルの値セルを探します。"

#. type: Plain text
#: original_texis/variables.texi:1199
msgid "(Internally, the lexical environment is a list whose members are usually cons cells that are symbol-value pairs, but some of its members can be symbols rather than cons cells.  A symbol in the list means the lexical environment declared that symbol's variable as locally considered to be dynamically bound.  This list can be passed as the second argument to the @code{eval} function, in order to specify a lexical environment in which to evaluate a form.  @xref{Eval}.  Most Emacs Lisp programs, however, should not interact directly with lexical environments in this way; only specialized programs like debuggers.)"
msgstr "(レキシカル環境は内部的には、通常はシンボルと値のペアーによるコンスセルをメンバーとするリストだが、一部のメンバーはコンスセルではなくシンボルでもよい。このリストにおけるシンボルは、そのシンボルの変数はローカルではダイナミックにバインドされているとみなすよう宣言されたレキシカル環境を意味している。このリストはフォームを評価するためのレキシカル環境を指定するために、@code{eval}関数の2番目の引数として渡すことができる。@ref{Eval}を参照のこと。しかしほとんどのEmacs Lispプログラムは、この方法で直接レキシカル環境を使用するべきではない。デバッガーのような特化されたプログラムだけが使用すること。)"

#. type: cindex
#: original_texis/variables.texi:1200
#, no-wrap
msgid "closures, example of using"
msgstr "closures, example of using"

#. type: Plain text
#: original_texis/variables.texi:1206
msgid "Lexical bindings have indefinite extent.  Even after a binding construct has finished executing, its lexical environment can be ``kept around'' in Lisp objects called @dfn{closures}.  A closure is created when you define a named or anonymous function with lexical binding enabled.  @xref{Closures}, for details."
msgstr "レキシカルバインディングは不定エクステント(indefinite extent)をもちます。バインディング構造が終了した後でも、そのレキシカル環境は@dfn{クロージャ(closures)}と呼ばれるLispオブジェクト内に``保持''されるかもしれ、あせん。クロージャはレキシカルバインディングが有効な、名前つきまたは無名(anonymous)の関数が作成されたときに作成されます。詳細は@ref{Closures}を参照してください。"

#. type: Plain text
#: original_texis/variables.texi:1210
msgid "When a closure is called as a function, any lexical variable references within its definition use the retained lexical environment.  Here is an example:"
msgstr "クロージャが関数として呼び出されたとき、その関数の定義内のレキシカル変数にたいする任意の参照は、維持されたレキシカル環境を使用します。以下は例です:"

#. type: example
#: original_texis/variables.texi:1214
#, no-wrap
msgid ""
"(defvar my-ticker nil)   ; @r{We will use this dynamically bound}\n"
"                         ; @r{variable to store a closure.}\n"
"\n"
msgstr ""
"(defvar my-ticker nil)   ; @r{クロージャを格納するために}\n"
"                         ; @r{この変数を使用する}\n"
"\n"

#. type: example
#: original_texis/variables.texi:1220
#, no-wrap
msgid ""
"(let ((x 0))             ; @r{@code{x} is lexically bound.}\n"
"  (setq my-ticker (lambda ()\n"
"                    (setq x (1+ x)))))\n"
"    @result{} (closure ((x . 0)) ()\n"
"          (setq x (1+ x)))\n"
"\n"
msgstr ""
"(let ((x 0))             ; @r{@code{x}はレキシカルにバインドされる}\n"
"  (setq my-ticker (lambda ()\n"
"                    (setq x (1+ x)))))\n"
"    @result{} (closure ((x . 0)) ()\n"
"          (setq x (1+ x)))\n"
"\n"

#. type: example
#: original_texis/variables.texi:1223
#, no-wrap
msgid ""
"(funcall my-ticker)\n"
"    @result{} 1\n"
"\n"
msgstr ""
"(funcall my-ticker)\n"
"    @result{} 1\n"
"\n"

#. type: example
#: original_texis/variables.texi:1226
#, no-wrap
msgid ""
"(funcall my-ticker)\n"
"    @result{} 2\n"
"\n"
msgstr ""
"(funcall my-ticker)\n"
"    @result{} 2\n"
"\n"

#. type: example
#: original_texis/variables.texi:1229
#, no-wrap
msgid ""
"(funcall my-ticker)\n"
"    @result{} 3\n"
"\n"
msgstr ""
"(funcall my-ticker)\n"
"    @result{} 3\n"
"\n"

#. type: example
#: original_texis/variables.texi:1232
#, no-wrap
msgid ""
"x                        ; @r{Note that @code{x} has no global value.}\n"
"@error{} Symbol's value as variable is void: x\n"
msgstr ""
"x                        ; @r{@code{x}はグローバル値をもたないことに注意}\n"
"@error{} Symbol's value as variable is void: x\n"

#. type: Plain text
#: original_texis/variables.texi:1243
msgid "The @code{let} binding defines a lexical environment in which the variable @code{x} is locally bound to 0.  Within this binding construct, we define a lambda expression which increments @code{x} by one and returns the incremented value.  This lambda expression is automatically turned into a closure, in which the lexical environment lives on even after the @code{let} binding construct has exited.  Each time we evaluate the closure, it increments @code{x}, using the binding of @code{x} in that lexical environment."
msgstr "@code{let}バインディングは、内部に変数@code{x}をもつレキシカル環境を定義して、変数は0にローカルにバインドされます。このバインディング構文内で@code{x}を1増加して、増加された値をリターンするクロージャを定義しています。このラムダ式は自動的にクロージャとなり、たとえ@code{let}構文を抜けた後でも、その内部ではレキシカル環境が存続します。クロージャを評価するときは、毎回レキシカル環境内の@code{x}のバインディングが使用されて、@code{x}が加算されます。"

#. type: Plain text
#: original_texis/variables.texi:1251
msgid "Note that unlike dynamic variables which are tied to the symbol object itself, the relationship between lexical variables and symbols is only present in the interpreter (or compiler).  Therefore, functions which take a symbol argument (like @code{symbol-value}, @code{boundp}, and @code{set}) can only retrieve or modify a variable's dynamic binding (i.e., the contents of its symbol's value cell)."
msgstr "シンボルオブジェクト自体に束縛されるダイナミック変数と異なり、レキシカル変数とシンボルの関係はインタープリター(かコンパイラー)内にのみ存在します。したがって(@code{symbol-value}、@code{boundp}、@code{set}のような)シンボル引数を受け取る関数ができるのは、変数のダイナミックなバインディング(そのシンボルの値セルの内容)の取得と変更だけです。"

#. type: Plain text
#: original_texis/variables.texi:1258
msgid "When loading an Emacs Lisp file or evaluating a Lisp buffer, lexical binding is enabled if the buffer-local variable @code{lexical-binding} is non-@code{nil}:"
msgstr "Emacs LispファイルのロードやLispバッファーを評価するとき、バッファーローカルな変数@code{lexical-binding}が非@code{nil}なら、レキシカルバインディングが有効になります:"

#. type: defvar
#: original_texis/variables.texi:1259
#, no-wrap
msgid "lexical-binding"
msgstr "lexical-binding"

#. type: defvar
#: original_texis/variables.texi:1268
msgid "If this buffer-local variable is non-@code{nil}, Emacs Lisp files and buffers are evaluated using lexical binding instead of dynamic binding.  (However, special variables are still dynamically bound; see below.)  If @code{nil}, dynamic binding is used for all local variables.  This variable is typically set for a whole Emacs Lisp file, as a file local variable (@pxref{File Local Variables}).  Note that unlike other such variables, this one must be set in the first line of a file."
msgstr "このバッファーローカルな変数が非@code{nil}なら、Emacs Lispファイルとバッファーはダイナミックバインディングではなくレキシカルバインディングを使用して評価される(しかし特別な変数はダイナミックにバインドされたまま。以下を照)。@code{nil}ならすべてのローカル変数にたいしてダイナミックバインディングが使用される。この変数は、通常はファイルローカル変数として、Emacs Lispファイル全体にたいしてセットされる(@ref{File Local Variables}を参照)。他のファイルローカル変数などとは異なり、ファイルの最初の行でセットされなければならないことに注意。"

#. type: Plain text
#: original_texis/variables.texi:1274
msgid "When evaluating Emacs Lisp code directly using an @code{eval} call, lexical binding is enabled if the @var{lexical} argument to @code{eval} is non-@code{nil}.  @xref{Eval}."
msgstr "@code{eval}呼び出しを使用してEmacs Lispコードを直接評価するとき、@code{eval}の@var{lexical}引数が非@code{nil}なら、レキシカルバインディングが有効になります。@ref{Eval}を参照してください。"

#. type: findex
#: original_texis/variables.texi:1275
#, no-wrap
msgid "eval-expression@r{, and }lexical-binding"
msgstr "eval-expression@r{, and }lexical-binding"

#. type: Plain text
#: original_texis/variables.texi:1283
msgid "Lexical binding is also enabled in Lisp Interaction and IELM mode, used in the @file{*scratch*} and @file{*ielm*} buffers, and also when evaluating expressions via @kbd{M-:} (@code{eval-expression}) and when processing the @option{--eval} command-line options of Emacs (@pxref{Action Arguments,,, emacs, The GNU Emacs Manual}) and @command{emacsclient} (@pxref{emacsclient Options,,, emacs, The GNU Emacs Manual})."
msgstr "レキシカルバインディングは@file{*scratch*}バッファーで使用されるLisp Interactionモード、および@file{*ielm*}バッファーで使用されるIELMモードでも有効であり、@kbd{M-:} (@code{eval-expression})を通じた式の評価や、Emacsと@command{emacsclient} (@ref{emacsclient Options,,, emacs, The GNU Emacs Manual}を参照)の@option{--eval}コマンドラインオプション(@ref{Action Arguments,,, emacs, The GNU Emacs Manual}を参照)を処理する際にも有効です。"

#. type: cindex
#: original_texis/variables.texi:1284
#, no-wrap
msgid "special variables"
msgstr "special variables"

#. type: Plain text
#: original_texis/variables.texi:1291
msgid "Even when lexical binding is enabled, certain variables will continue to be dynamically bound.  These are called @dfn{special variables}.  Every variable that has been defined with @code{defvar}, @code{defcustom} or @code{defconst} is a special variable (@pxref{Defining Variables}).  All other variables are subject to lexical binding."
msgstr "レキシカルバインディングが有効な場合でも、特定の変数はダイナミックにバインドされたままです。これらは@dfn{スペシャル変数(special variable)}と呼ばれます。@code{defvar}、@code{defcustom}、@code{defconst}で定義されたすべての変数はスペシャル変数です(@ref{Defining Variables}を参照)。その他のすべての変数はレキシカルバインディングの対象になります。"

#. type: anchor{#1}
#: original_texis/variables.texi:1296
msgid "Local defvar example"
msgstr "Local defvar example"

#. type: Plain text
#: original_texis/variables.texi:1296
msgid "Using @code{defvar} without a value, it is possible to bind a variable dynamically just in one file, or in just one part of a file while still binding it lexically elsewhere.  For example:"
msgstr "値なしで@code{defvar}を使用することにより、他の場所ではレキシカルにバインドされている状態のまま、単一ファイルやファイルの一部だけで変数をダイナミックにバインドすることが可能になります。たとえば:"

#. type: group
#: original_texis/variables.texi:1304
#, no-wrap
msgid ""
"(let (_)\n"
"  (defvar x)      ; @r{Let-bindings of @code{x} will be dynamic within this let.}\n"
"  (let ((x -99))  ; @r{This is a dynamic binding of @code{x}.}\n"
"    (defun get-dynamic-x ()\n"
"      x)))\n"
"\n"
msgstr ""
"(let (_)\n"
"  (defvar x)      ; @r{@code{x}へのletバインドはこのlet内ではダイナミック}\n"
"  (let ((x -99))  ; @r{これは@code{x}のダイナミックバインド}\n"
"    (defun get-dynamic-x ()\n"
"      x)))\n"
"\n"

#. type: group
#: original_texis/variables.texi:1308
#, no-wrap
msgid ""
"(let ((x 'lexical)) ; @r{This is a lexical binding of @code{x}.}\n"
"  (defun get-lexical-x ()\n"
"    x))\n"
"\n"
msgstr ""
"(let ((x 'lexical)) ; @r{これは@code{x}のレキシカルバインド}\n"
"  (defun get-lexical-x ()\n"
"    x))\n"
"\n"

#. type: group
#: original_texis/variables.texi:1315
#, no-wrap
msgid ""
"(let (_)\n"
"  (defvar x)\n"
"  (let ((x 'dynamic))\n"
"    (list (get-lexical-x)\n"
"          (get-dynamic-x))))\n"
"    @result{} (lexical dynamic)\n"
msgstr ""
"(let (_)\n"
"  (defvar x)\n"
"  (let ((x 'dynamic))\n"
"    (list (get-lexical-x)\n"
"          (get-dynamic-x))))\n"
"    @result{} (lexical dynamic)\n"

#. type: defun
#: original_texis/variables.texi:1318
#, no-wrap
msgid "special-variable-p symbol"
msgstr "special-variable-p symbol"

#. type: defun
#: original_texis/variables.texi:1323
msgid "This function returns non-@code{nil} if @var{symbol} is a special variable (i.e., it has a @code{defvar}, @code{defcustom}, or @code{defconst} variable definition).  Otherwise, the return value is @code{nil}."
msgstr "この関数は@var{symbol}がスペシャル変数(つまり変数が@code{defvar}、@code{defcustom}、@code{defconst}による定義をもつ)なら非@code{nil}をリターンする。、それ以外ならリターン値は@code{nil}。"

#. type: defun
#: original_texis/variables.texi:1327
msgid "Note that since this is a function, it can only return non-@code{nil} for variables which are permanently special, but not for those that are only special in the current lexical scope."
msgstr "これは関数なので永続的にスペシャルな変数には非@code{nil}をリターンできるが、カレントレキシカルスコープでのみスペシャルな変数では異なることに注意。"

#. type: Plain text
#: original_texis/variables.texi:1331
msgid "The use of a special variable as a formal argument in a function is not supported."
msgstr "関数内の正式な引数としてのスペシャル変数の使用はサポートされていません。"

#. type: Plain text
#: original_texis/variables.texi:1341
msgid "Converting an Emacs Lisp program to lexical binding is easy.  First, add a file-local variable setting of @code{lexical-binding} to @code{t} in the header line of the Emacs Lisp source file (@pxref{File Local Variables}).  Second, check that every variable in the program which needs to be dynamically bound has a variable definition, so that it is not inadvertently bound lexically."
msgstr "Emacs Lispプログラムをレキシカルバインディングに変換するのは簡単です。最初にEmacs Lispソースファイルのヘッダー行で@code{lexical-binding}を@code{t}にして、ファイルローカル変数を追加します(@ref{File Local Variables}を参照)。次に意図せずレキシカルにバインドしてしまわないように、ダイナミックなバインドをもつ必要がある変数が変数定義をもつことを各変数ごとにチェックします。"

#. type: cindex
#: original_texis/variables.texi:1342
#, no-wrap
msgid "free variable"
msgstr "free variable"

#. type: cindex
#: original_texis/variables.texi:1343
#, no-wrap
msgid "unused lexical variable"
msgstr "unused lexical variable"

#. type: Plain text
#: original_texis/variables.texi:1352
msgid "A simple way to find out which variables need a variable definition is to byte-compile the source file.  @xref{Byte Compilation}.  If a non-special variable is used outside of a @code{let} form, the byte-compiler will warn about reference or assignment to a free variable.  If a non-special variable is bound but not used within a @code{let} form, the byte-compiler will warn about an unused lexical variable.  The byte-compiler will also issue a warning if you use a special variable as a function argument."
msgstr "どの変数が変数定義をもつ必要があるか見つけるシンプルな方法は、ソースファイルをバイトコンパイルすることです。@ref{Byte Compilation}を参照してください。@code{let}フォームの外側で非スペシャル変数が使用されていれば、バイトコンパイラーはフリーな変数にたいする参照や割り当てについて警告するでしょう。非スペシャル変数がバインドされているが@code{let}フォーム内で使用されていなければ、バイトコンパイラーは使用されないレキシカル変数に関して警告するでしょう。バイトコンパイラーは、スペシャル変数を関数の引数として使用している場合も問題を警告します。"

#. type: Plain text
#: original_texis/variables.texi:1357
msgid "A warning about a reference or an assignment to a free variable is usually a clear sign that that variable should be marked as dynamically scoped, so you need to add an appropriate @code{defvar} before the first use of that variable."
msgstr "フリー変換にたいする参照や割り当てに関する警告は、通常はその変数をダイナミックスコープにすべきだという明解なサインなので、その変数を最初に使用する前に適切な@code{defvar}を追加する必要があります。"

#. type: Plain text
#: original_texis/variables.texi:1369
msgid "A warning about an unused variable may be a good hint that the variable was intended to be dynamically scoped (because it is actually used, but in another function), but it may also be an indication that the variable is simply really not used and could simply be removed.  So you need to find out which case it is, and based on that, either add a @code{defvar} or remove the variable altogether.  If removal is not possible or not desirable (typically because it is a formal argument and that we cannot or don't want to change all the callers), you can also add a leading underscore to the variable's name to indicate to the compiler that this is a variable known not to be used.)"
msgstr "使用されない変数についての警告は、それが(実際には別の関数で使用されているので)ダイナミックスコープを意図した変数だという良いヒントかもしれませんが、その変数が実際に未使用であり、単に削除可能であることを示しているのかもしれません。そのために、あなたはこれがいずれのケースなのかを調べて、それにもとづいて@code{defvar}を追加するか、あるいはその変数を完全に削除する必要があります。削除が不可能、あるいは望ましくない場合(典型的にはそれが正規の引数であり、呼び出し側すべての変更が不可能だったり望ましくない場合)には、それが使用されないと判っている変数であることをコンパイラーに示すために、変数名の先頭にアンダースコアを追加することもできます。"

#. type: subsubheading
#: original_texis/variables.texi:1370
#, no-wrap
msgid "Cross-file variable checking"
msgstr "クロスファイル変数のチェック"

#. type: Plain text
#: original_texis/variables.texi:1374
msgid "@strong{Caution:} This is an experimental feature that may change or disappear without prior notice."
msgstr "@strong{警告:} これは事前通知なしに変更あるいは消滅するかもしれない実験的な機能です。"

#. type: Plain text
#: original_texis/variables.texi:1379
msgid "The byte-compiler can also warn about lexical variables that are special in other Emacs Lisp files, often indicating a missing @code{defvar} declaration.  This useful but somewhat specialized check requires three steps:"
msgstr "バイトコンパイラーは別のEmacs Lispファイル内ではスペシャルであるようなレキシカル変数についても警告するかもしれません。これはしばしば@code{defvar}宣言の欠落を示しています。これは便利ですが3つのステップを要する幾分特殊なチェックを行います:"

#. type: enumerate
#: original_texis/variables.texi:1388
msgid "Byte-compile all files whose special variable declarations may be of interest, with the environment variable @env{EMACS_GENERATE_DYNVARS} set to a nonempty string.  These are typically all the files in the same package or related packages or Emacs subsystems.  The process will generate a file whose name ends in @file{.dynvars} for each compiled Emacs Lisp file."
msgstr "環境変数@env{EMACS_GENERATE_DYNVARS}に非空の文字列をセットして、対象となりそうなスペシャル変数宣言をもつすべてのファイルをバイトコンパイルする。これは通常は同一パッケージ、関連するパッケージ、Emacsサブシステム内のすべてのファイルが該当する。この処理によりコンパイル済みEmacs Lispファイルそれぞれにたいして、名前が@file{.dynvars}で終わるファイルが生成される。"

#. type: enumerate
#: original_texis/variables.texi:1391
msgid "Concatenate the @file{.dynvars} files into a single file."
msgstr "@file{.dynvars}ファイルを単一のファイルに結合する。"

#. type: enumerate
#: original_texis/variables.texi:1396
msgid "Byte-compile the files that need to be checked, this time with the environment variable @env{EMACS_DYNVARS_FILE} set to the name of the aggregated file created in step 2."
msgstr "チェックを要するファイルをバイトコンパイルする。このときには環境変数@env{EMACS_DYNVARS_FILE}にはステップ2で作成した集約済みファイルがセットされる。"

#. type: Plain text
#: original_texis/variables.texi:1400
msgid "Here is an example illustrating how this could be done, assuming that a Unix shell and @command{make} are used for byte-compilation:"
msgstr "以下はUnixシェル上で@command{make}を使用してバイトコンパイルしたら何が行われるかを示した例です:"

#. type: example
#: original_texis/variables.texi:1407
#, no-wrap
msgid ""
"$ rm *.elc                                # force recompilation\n"
"$ EMACS_GENERATE_DYNVARS=1 make           # generate .dynvars\n"
"$ cat *.dynvars > ~/my-dynvars            # combine .dynvars\n"
"$ rm *.elc                                # force recompilation\n"
"$ EMACS_DYNVARS_FILE=~/my-dynvars make    # perform checks\n"
msgstr ""
"$ rm *.elc                                # 再コンパイルを強制\n"
"$ EMACS_GENERATE_DYNVARS=1 make           # .dynvarsを生成\n"
"$ cat *.dynvars > ~/my-dynvars            # .dynvarsを結合\n"
"$ rm *.elc                                # 再コンパイルを強制\n"
"$ EMACS_DYNVARS_FILE=~/my-dynvars make    # チェック実施\n"

#. type: cindex
#: original_texis/variables.texi:1411
#, no-wrap
msgid "variable, buffer-local"
msgstr "variable, buffer-local"

#. type: cindex
#: original_texis/variables.texi:1412
#, no-wrap
msgid "buffer-local variables"
msgstr "buffer-local variables"

#. type: Plain text
#: original_texis/variables.texi:1421
msgid "Global and local variable bindings are found in most programming languages in one form or another.  Emacs, however, also supports additional, unusual kinds of variable binding, such as @dfn{buffer-local} bindings, which apply only in one buffer.  Having different values for a variable in different buffers is an important customization method.  (Variables can also have bindings that are local to each terminal.  @xref{Multiple Terminals}.)"
msgstr "グローバルおよびローカルな変数バインディングは、いずれかの形式をほとんどのプログラミング言語で見つけることができます。しかしEmacsは1つのバッファーだけに適用される@dfn{バッファーローカル(buffer-local)}なバインディング用に、普通には存在しない類の変数バインディングもサポートしています。ある変数にたいして異なるバッファーごとに別の値をもつのは、カスタマイズでの重要な手法です(変数は端末ごとにローカルなバインディングをもつこともできる。@ref{Multiple Terminals}を参照)。"

#. type: node
#: original_texis/variables.texi:1427 original_texis/variables.texi:1429
#, no-wrap
msgid "Intro to Buffer-Local"
msgstr "Intro to Buffer-Local"

#. type: menuentry
#: original_texis/variables.texi:1427
msgid "Introduction and concepts."
msgstr "イントロダクションと概念。"

#. type: node
#: original_texis/variables.texi:1427 original_texis/variables.texi:1523
#, no-wrap
msgid "Creating Buffer-Local"
msgstr "Creating Buffer-Local"

#. type: menuentry
#: original_texis/variables.texi:1427
msgid "Creating and destroying buffer-local bindings."
msgstr "バッファーローカルなバインディングの作成と削除。"

#. type: node
#: original_texis/variables.texi:1427 original_texis/variables.texi:1772
#, no-wrap
msgid "Default Value"
msgstr "Default Value"

#. type: menuentry
#: original_texis/variables.texi:1427
msgid "The default value is seen in buffers that don't have their own buffer-local values."
msgstr "自身ではバッファーローカルな値をもたないバッファーで参照されるデフォルト値。"

#. type: subsection
#: original_texis/variables.texi:1430
#, no-wrap
msgid "Introduction to Buffer-Local Variables"
msgstr "Introduction to Buffer-Local Variables"

#. type: Plain text
#: original_texis/variables.texi:1438
msgid "A buffer-local variable has a buffer-local binding associated with a particular buffer.  The binding is in effect when that buffer is current; otherwise, it is not in effect.  If you set the variable while a buffer-local binding is in effect, the new value goes in that binding, so its other bindings are unchanged.  This means that the change is visible only in the buffer where you made it."
msgstr "バッファーローカル変数は特定のバッファーに関連づけられた、バッファーローカルなバインディングをもちます。このバインディングはそのバッファーがカレントのときに効果をもち、カレントでないときには効果がありません。バッファーローカルなバインディングが効力をもつときにその変数をセットすると、そのバインディングは新しい値をもちますが他のバインディングは変更されません。これはバッファーローカルなバインディングを作成したバッファーだけで変更が見えることを意味します。"

#. type: Plain text
#: original_texis/variables.texi:1442
msgid "The variable's ordinary binding, which is not associated with any specific buffer, is called the @dfn{default binding}.  In most cases, this is the global binding."
msgstr "その変数にたいする特定のバッファーに関連しない通常のバインディングは、@dfn{デフォルトバインディング(default binding)}と呼ばれます。これはほとんどの場合はグローバルバインディングです。"

#. type: Plain text
#: original_texis/variables.texi:1450
msgid "A variable can have buffer-local bindings in some buffers but not in other buffers.  The default binding is shared by all the buffers that don't have their own bindings for the variable.  (This includes all newly-created buffers.)  If you set the variable in a buffer that does not have a buffer-local binding for it, this sets the default binding, so the new value is visible in all the buffers that see the default binding."
msgstr "変数はあるバッファーではバッファーローカルなバインディングをもつことができ、他のバッファーではもたないことができます。デフォルトバインディングは、その変数にたいして自身のバインディングをもたないすべてのバッファーで共有されます(これには新たに作成されたバッファーが含まれる)。ある変数にたいして、その変数のバッファーローカルなバインディングをもたないバッファーでその変数をセットすると、それによりデフォルトバインディングがセットされるので、デフォルトバインディングを参照するすべてのバッファーで新しい値を見ることになります。"

#. type: Plain text
#: original_texis/variables.texi:1457
msgid "The most common use of buffer-local bindings is for major modes to change variables that control the behavior of commands.  For example, C mode and Lisp mode both set the variable @code{paragraph-start} to specify that only blank lines separate paragraphs.  They do this by making the variable buffer-local in the buffer that is being put into C mode or Lisp mode, and then setting it to the new value for that mode.  @xref{Major Modes}."
msgstr "バッファーローカルなバインディングのもっとも一般的な使用は、メジャーモードがコマンドの動作を制御するために変数を変更する場合です。たとえばCモードやLispモードは、空行だけがパラグラフの区切りになるように変数@code{paragraph-start}をセットします。これらのモードは、CモードやLispモードになるようなバッファー内でこの変数をバッファーローカルにすることでこれを行って、その後そのモードにたいする新しい値をセットします。@ref{Major Modes}を参照してください。"

#. type: Plain text
#: original_texis/variables.texi:1463
msgid "The usual way to make a buffer-local binding is with @code{make-local-variable}, which is what major mode commands typically use.  This affects just the current buffer; all other buffers (including those yet to be created) will continue to share the default value unless they are explicitly given their own buffer-local bindings."
msgstr "バッファーローカルなバインディングを作成する通常の方法は、@code{make-local-variable}による方法で、これは通常はメジャーモードが使用します。これはカレントバッファーだけに効果があります。その他すべてのバッファー(まだ作成されていないバッファーを含む)は、それらのバッファー自身が明示的にバッファーローカルなバインディングを与えるまでデフォルト値を共有し続けます。"

#. type: cindex
#: original_texis/variables.texi:1464
#, no-wrap
msgid "automatically buffer-local"
msgstr "automatically buffer-local"

#. type: Plain text
#: original_texis/variables.texi:1477
msgid "A more powerful operation is to mark the variable as @dfn{automatically buffer-local} by calling @code{make-variable-buffer-local}.  You can think of this as making the variable local in all buffers, even those yet to be created.  More precisely, the effect is that setting the variable automatically makes the variable local to the current buffer if it is not already so.  All buffers start out by sharing the default value of the variable as usual, but setting the variable creates a buffer-local binding for the current buffer.  The new value is stored in the buffer-local binding, leaving the default binding untouched.  This means that the default value cannot be changed with @code{setq} in any buffer; the only way to change it is with @code{setq-default}."
msgstr "変数を@dfn{自動的にバッファーローカルになる}ようにマークする、より強力な操作は@code{make-variable-buffer-local}を呼び出すことにより行われます。これはたとえその変数がまだ作成されていなくても、変数をすべてのバッファーにたいしてローカルにすると考えることができます。より正確には変数を自動的にセットすることにより、その変数がカレントバッファーにたいしてローカルでなくても、変数をローカルにする効果があります。すべてのバッファーは最初は通常のようにデフォルト値を共有しますが、変数をセットすることでカレントバッファーにたいしてバッファーローカルなバインディングを作成します。新たな値はバッファーローカルなバインディングに格納され、デフォルトバインディングは変更されずに残ります。これは任意のバッファーで@code{setq}によりデフォルト値を変更できないことを意味します。変更する唯一の方法は@code{setq-default}だけです。"

#. type: Plain text
#: original_texis/variables.texi:1489
msgid "@strong{Warning:} When a variable has buffer-local bindings in one or more buffers, @code{let} rebinds the binding that's currently in effect.  For instance, if the current buffer has a buffer-local value, @code{let} temporarily rebinds that.  If no buffer-local bindings are in effect, @code{let} rebinds the default value.  If inside the @code{let} you then change to a different current buffer in which a different binding is in effect, you won't see the @code{let} binding any more.  And if you exit the @code{let} while still in the other buffer, you won't see the unbinding occur (though it will occur properly).  Here is an example to illustrate:"
msgstr "@strong{警告:} ある変数が1つ以上のバッファーでバッファーローカルなバインディングをもつ際に、@code{let}はそのとき効力がある変数のバインディングをリバインドします。たとえばカレントバッファーがバッファーローカルな値をもつなら、@code{let}は一時的にそれをリバインドします。効力があるバッファーローカルなバインディングが存在しなければ@code{let}はデフォルト値をリバインドします。@code{let}の内部で、別のバインディングが効力をもつ別のバッファーをカレントバッファーにすると、それ以上@code{let}バインディングを参照できなくなります。他のバッファーにいる間に@code{let}を抜けると、(たとえそれが正しくても)バインディングの解消を見ることはできません。以下にこれを示します:"

#. type: group
#: original_texis/variables.texi:1495
#, no-wrap
msgid ""
"(setq foo 'g)\n"
"(set-buffer \"a\")\n"
"(make-local-variable 'foo)\n"
msgstr ""
"(setq foo 'g)\n"
"(set-buffer \"a\")\n"
"(make-local-variable 'foo)\n"

#. type: example
#: original_texis/variables.texi:1502
#, no-wrap
msgid ""
"(setq foo 'a)\n"
"(let ((foo 'temp))\n"
"  ;; foo @result{} 'temp  ; @r{let binding in buffer @samp{a}}\n"
"  (set-buffer \"b\")\n"
"  ;; foo @result{} 'g     ; @r{the global value since foo is not local in @samp{b}}\n"
"  @var{body}@dots{})\n"
msgstr ""
"(setq foo 'a)\n"
"(let ((foo 'temp))\n"
"  ;; foo @result{} 'temp  ; @r{バッファー@samp{a}内でのletバインディング}\n"
"  (set-buffer \"b\")\n"
"  ;; foo @result{} 'g     ; @r{fooは@samp{b}にたいしてローカルではないためグローバル値}\n"
"  @var{body}@dots{})\n"

#. type: group
#: original_texis/variables.texi:1505
#, no-wrap
msgid ""
"foo @result{} 'g        ; @r{exiting restored the local value in buffer @samp{a},}\n"
"                 ; @r{but we don't see that in buffer @samp{b}}\n"
msgstr ""
"foo @result{} 'g        ; @r{exitによりバッファー@samp{a}のローカル値が復元されるが}\n"
"                 ; @r{バッファー@samp{b}では見ることができない}\n"

#. type: group
#: original_texis/variables.texi:1509
#, no-wrap
msgid ""
"(set-buffer \"a\") ; @r{verify the local value was restored}\n"
"foo @result{} 'a\n"
msgstr ""
"(set-buffer \"a\") ; @r{ローカル値が復元されたことを確認}\n"
"foo @result{} 'a\n"

#. type: Plain text
#: original_texis/variables.texi:1515
msgid "Note that references to @code{foo} in @var{body} access the buffer-local binding of buffer @samp{b}."
msgstr "@var{body}内の@code{foo}にたいする参照は、バッファー@samp{b}のバッファーローカルなバインディングにアクセスすることに注意してください。"

#. type: Plain text
#: original_texis/variables.texi:1519
msgid "When a file specifies local variable values, these become buffer-local values when you visit the file.  @xref{File Variables,,, emacs, The GNU Emacs Manual}."
msgstr "あるファイルがローカル変数の値をセットする場合、これらの変数はファイルをvisitするときバッファーローカルな値になります。@ref{File Variables,,, emacs, The GNU Emacs Manual}を参照してください。"

#. type: Plain text
#: original_texis/variables.texi:1522
msgid "A buffer-local variable cannot be made terminal-local (@pxref{Multiple Terminals})."
msgstr "バッファーローカル変数を端末ローカル(terminal-local)にすることはできません(@ref{Multiple Terminals}を参照)。"

#. type: subsection
#: original_texis/variables.texi:1524
#, no-wrap
msgid "Creating and Deleting Buffer-Local Bindings"
msgstr "Creating and Deleting Buffer-Local Bindings"

#. type: deffn
#: original_texis/variables.texi:1526
#, no-wrap
msgid "Command make-local-variable variable"
msgstr "Command make-local-variable variable"

#. type: deffn
#: original_texis/variables.texi:1530
msgid "This function creates a buffer-local binding in the current buffer for @var{variable} (a symbol).  Other buffers are not affected.  The value returned is @var{variable}."
msgstr "この関数はカレントバッファー内で、@var{variable}(シンボル)にたいするバッファーローカルなバインディングを作成する。他のバッファーは影響を受けない。リターンされる値は@var{variable}。"

#. type: deffn
#: original_texis/variables.texi:1534
msgid "The buffer-local value of @var{variable} starts out as the same value @var{variable} previously had.  If @var{variable} was void, it remains void."
msgstr "@var{variable}のバッファーローカルな値は、最初は以前に@var{variable}がもっていた値と同じ値をもつ。@var{variable}がvoidのときはvoidのまま。"

#. type: group
#: original_texis/variables.texi:1540
#, no-wrap
msgid ""
";; @r{In buffer @samp{b1}:}\n"
"(setq foo 5)                ; @r{Affects all buffers.}\n"
"     @result{} 5\n"
msgstr ""
";; @r{バッファー@samp{b1}で行う:}\n"
"(setq foo 5)                ; @r{すべてのバッファーに影響する。}\n"
"     @result{} 5\n"

#. type: group
#: original_texis/variables.texi:1544
#, no-wrap
msgid ""
"(make-local-variable 'foo)  ; @r{Now it is local in @samp{b1}.}\n"
"     @result{} foo\n"
msgstr ""
"(make-local-variable 'foo)  ; @r{@samp{b1}内でローカルになった}\n"
"     @result{} foo\n"

#. type: group
#: original_texis/variables.texi:1548
#, no-wrap
msgid ""
"foo                         ; @r{That did not change}\n"
"     @result{} 5                   ;   @r{the value.}\n"
msgstr ""
"foo                         ; @r{値は変更されない}\n"
"     @result{} 5\n"

#. type: group
#: original_texis/variables.texi:1552
#, no-wrap
msgid ""
"(setq foo 6)                ; @r{Change the value}\n"
"     @result{} 6                   ;   @r{in @samp{b1}.}\n"
msgstr ""
"(setq foo 6)                ; @r{@samp{b1}内で値を変更}\n"
"     @result{} 6\n"

#. type: group
#: original_texis/variables.texi:1556
#, no-wrap
msgid ""
"foo\n"
"     @result{} 6\n"
msgstr ""
"foo\n"
"     @result{} 6\n"

#. type: group
#: original_texis/variables.texi:1563
#, no-wrap
msgid ""
";; @r{In buffer @samp{b2}, the value hasn't changed.}\n"
"(with-current-buffer \"b2\"\n"
"  foo)\n"
"     @result{} 5\n"
msgstr ""
";; @r{バッファー@samp{b2}では、値は変更されていない}\n"
"(with-current-buffer \"b2\"\n"
"  foo)\n"
"     @result{} 5\n"

#. type: deffn
#: original_texis/variables.texi:1571
msgid "Making a variable buffer-local within a @code{let}-binding for that variable does not work reliably, unless the buffer in which you do this is not current either on entry to or exit from the @code{let}.  This is because @code{let} does not distinguish between different kinds of bindings; it knows only which variable the binding was made for."
msgstr "変数を@code{let}バインディングでバッファーローカルにしても、@code{let}への出入り時の両方でこれを行うバッファーがカレントでなければ信頼性はない。これは@code{let}がバインディングの種類を区別しないからである。@code{let}に解るのはバインディングが作成される変数だけである。"

#. type: deffn
#: original_texis/variables.texi:1574 original_texis/variables.texi:1622
msgid "It is an error to make a constant or a read-only variable buffer-local.  @xref{Constant Variables}."
msgstr "定数や読み取り専用の変数をバッファーローカルにするとエラーになる。@ref{Constant Variables}を参照のこと。"

#. type: deffn
#: original_texis/variables.texi:1578
msgid "If the variable is terminal-local (@pxref{Multiple Terminals}), this function signals an error.  Such variables cannot have buffer-local bindings as well."
msgstr "変数が端末ローカル(@ref{Multiple Terminals}を参照)なら、この関数はエラーをシグナルする。そのような変数はバッファーローカルなバインディングをもつことができない。"

#. type: deffn
#: original_texis/variables.texi:1583
msgid "@strong{Warning:} do not use @code{make-local-variable} for a hook variable.  The hook variables are automatically made buffer-local as needed if you use the @var{local} argument to @code{add-hook} or @code{remove-hook}."
msgstr "@strong{警告:} フック変数にたいして@code{make-local-variable}を使用しないこと。フック変数は@code{add-hook}か@code{remove-hook}の@var{local}引数を使用すると、必要に応じて自動でバッファーローカルになる。"

#. type: defmac
#: original_texis/variables.texi:1585
#, no-wrap
msgid "setq-local &rest pairs"
msgstr "setq-local &rest pairs"

#. type: defmac
#: original_texis/variables.texi:1591
msgid "@var{pairs} is a list of variable and value pairs.  This macro creates a buffer-local binding in the current buffer for each of the variables, and gives them a buffer-local value.  It is equivalent to calling @code{make-local-variable} followed by @code{setq} for each of the variables.  The variables should be unquoted symbols."
msgstr "@var{pairs}は変数と値のペアからなるリスト。このマクロはカレントバッファー内で変数それぞれにたいしてバッファーローカルなバインディングを作成して、それにバッファーローカルな値を与える。このマクロは各変数にたいして@code{make-local-variable}の後に@code{setq}を呼び出すのと等価。変数はクォートされていないシンボルであること。"

#. type: lisp
#: original_texis/variables.texi:1595
#, no-wrap
msgid ""
"(setq-local var1 \"value1\"\n"
"            var2 \"value2\")\n"
msgstr ""
"(setq-local var1 \"value1\"\n"
"            var2 \"value2\")\n"

#. type: deffn
#: original_texis/variables.texi:1598
#, no-wrap
msgid "Command make-variable-buffer-local variable"
msgstr "Command make-variable-buffer-local variable"

#. type: deffn
#: original_texis/variables.texi:1605
msgid "This function marks @var{variable} (a symbol) automatically buffer-local, so that any subsequent attempt to set it will make it local to the current buffer at the time.  Unlike @code{make-local-variable}, with which it is often confused, this cannot be undone, and affects the behavior of the variable in all buffers."
msgstr "このコマンドは@var{variable}(シンボル)が自動的にバッファーローカルになるようにマークするので、それ以降にその変数へのセットを試みると、その時点でカレントのバッファーにローカルになる。しばしば混乱を招く@code{make-local-variable}とは異なり、これが取り消されることはなく、すべてのバッファー内での変数の挙動に影響する。"

#. type: deffn
#: original_texis/variables.texi:1611
msgid "A peculiar wrinkle of this feature is that binding the variable (with @code{let} or other binding constructs) does not create a buffer-local binding for it.  Only setting the variable (with @code{set} or @code{setq}), while the variable does not have a @code{let}-style binding that was made in the current buffer, does so."
msgstr "この機能特有の欠点は、(@code{let}やその他のバインディング構文による)変数のバインディングが、その変数にたいするバッファーローカルなバインディングを作成しないことである。(@code{set}や@code{setq}による)変数のセットだけは、その変数がカレントバッファーで作成された@code{let}スタイルのバインディングをもたないので、ローカルなバインディングを作成する。"

#. type: deffn
#: original_texis/variables.texi:1617
msgid "If @var{variable} does not have a default value, then calling this command will give it a default value of @code{nil}.  If @var{variable} already has a default value, that value remains unchanged.  Subsequently calling @code{makunbound} on @var{variable} will result in a void buffer-local value and leave the default value unaffected."
msgstr "@var{variable}がデフォルト値をもたない場合、このコマンドの呼び出しは@code{nil}のデフォルト値を与える。@var{variable}がすでにデフォルト値をもつなら、その値は変更されずに残る。それ以降に@var{variable}にたいして@code{makunbound}を呼び出すと、バッファーローカル値をvoidにして、デフォルト値は影響を受けずに残る。"

#. type: deffn
#: original_texis/variables.texi:1619
msgid "The value returned is @var{variable}."
msgstr "▼リターン値は@var{variable}。"

#. type: deffn
#: original_texis/variables.texi:1628
msgid "@strong{Warning:} Don't assume that you should use @code{make-variable-buffer-local} for user-option variables, simply because users @emph{might} want to customize them differently in different buffers.  Users can make any variable local, when they wish to.  It is better to leave the choice to them."
msgstr "@strong{警告:} ユーザーオプション変数では、ユーザーは異なるバッファーにたいして異なるカスタマイズを望む@emph{かもしれない}ので、@code{make-variable-buffer-local}を使うべきだと決め込むべきではない。ユーザーは望むなら任意の変数をローカルにできる。その選択の余地を残すほうがよい。"

#. type: deffn
#: original_texis/variables.texi:1634
msgid "The time to use @code{make-variable-buffer-local} is when it is crucial that no two buffers ever share the same binding.  For example, when a variable is used for internal purposes in a Lisp program which depends on having separate values in separate buffers, then using @code{make-variable-buffer-local} can be the best solution."
msgstr "@code{make-variable-buffer-local}を使用すべきなのは、複数のバッファーが同じバインディングを共有しないことが自明な場合である。たとえばバッファーごとに個別な値をもつことに依存するLispプログラム内の内部プロセスにたいして変数が使用されるときは、@code{make-variable-buffer-local}の使用が最善の解決策になるかもしれない。"

#. type: defmac
#: original_texis/variables.texi:1636
#, no-wrap
msgid "defvar-local variable value &optional docstring"
msgstr "defvar-local variable value &optional docstring"

#. type: defmac
#: original_texis/variables.texi:1642
msgid "This macro defines @var{variable} as a variable with initial value @var{value} and @var{docstring}, and marks it as automatically buffer-local.  It is equivalent to calling @code{defvar} followed by @code{make-variable-buffer-local}.  @var{variable} should be an unquoted symbol."
msgstr "このマクロは@var{variable}を初期値@var{value}と@var{docstring}の変数として定義して、それを自動的にバッファーローカルとマークする。これは@code{defvar}の後につづけて@code{make-variable-buffer-local}を呼び出すのと同じ。@var{variable}はクォートされていないシンボル。"

#. type: defun
#: original_texis/variables.texi:1644
#, no-wrap
msgid "local-variable-p variable &optional buffer"
msgstr "local-variable-p variable &optional buffer"

#. type: defun
#: original_texis/variables.texi:1648
msgid "This returns @code{t} if @var{variable} is buffer-local in buffer @var{buffer} (which defaults to the current buffer); otherwise, @code{nil}."
msgstr "これは@var{variable}がバッファー@var{buffer}(デフォルトはカレントバッファー)内でバッファーローカルなら@code{t}、それ以外は@code{nil}をリターンする。"

#. type: defun
#: original_texis/variables.texi:1650
#, no-wrap
msgid "local-variable-if-set-p variable &optional buffer"
msgstr "local-variable-if-set-p variable &optional buffer"

#. type: defun
#: original_texis/variables.texi:1655
msgid "This returns @code{t} if @var{variable} either has a buffer-local value in buffer @var{buffer}, or is automatically buffer-local.  Otherwise, it returns @code{nil}.  If omitted or @code{nil}, @var{buffer} defaults to the current buffer."
msgstr "これは@var{variable}がバッファー@var{buffer}内でバッファーローカル値をもつ、または自動的にバッファーローカルになるなら@code{t}、それ以外は@code{nil}をリターンする。@var{buffer}が省略または@code{nil}の場合のデフォルトはカレントバッファー。"

#. type: defun
#: original_texis/variables.texi:1657
#, no-wrap
msgid "buffer-local-value variable buffer"
msgstr "buffer-local-value variable buffer"

#. type: defun
#: original_texis/variables.texi:1662
msgid "This function returns the buffer-local binding of @var{variable} (a symbol) in buffer @var{buffer}.  If @var{variable} does not have a buffer-local binding in buffer @var{buffer}, it returns the default value (@pxref{Default Value}) of @var{variable} instead."
msgstr "この関数はバッファー@var{buffer}内の、@var{variable}(シンボル)のバッファーローカルなバインディングをリターンする。@var{variable}がバッファー@var{buffer}内でバッファーローカルなバインディングをもたなければ、かわりに@var{variable}のデフォルト値(@ref{Default Value}を参照)をリターンする。"

#. type: defun
#: original_texis/variables.texi:1664
#, no-wrap
msgid "buffer-local-boundp variable buffer"
msgstr "buffer-local-boundp variable buffer"

#. type: defun
#: original_texis/variables.texi:1668
msgid "This returns non-@code{nil} if there's either a buffer-local binding of @var{variable} (a symbol) in buffer @var{buffer}, or @var{variable} has a global binding."
msgstr "これは@var{variable}がバッファー@var{buffer}でバッファーローカルにバインドされているか、あるいはグローバルにバインドされていれば非@code{nil}をリターンする。"

#. type: defun
#: original_texis/variables.texi:1670
#, no-wrap
msgid "buffer-local-variables &optional buffer"
msgstr "buffer-local-variables &optional buffer"

#. type: defun
#: original_texis/variables.texi:1678
msgid "This function returns a list describing the buffer-local variables in buffer @var{buffer}.  (If @var{buffer} is omitted, the current buffer is used.)  Normally, each list element has the form @w{@code{(@var{sym} . @var{val})}}, where @var{sym} is a buffer-local variable (a symbol) and @var{val} is its buffer-local value.  But when a variable's buffer-local binding in @var{buffer} is void, its list element is just @var{sym}."
msgstr "この関数はバッファー@var{buffer}内のバッファーローカル変数を表すリストをリターンする(@var{buffer}が省略された場合はカレントバッファーが使用される)。リストの各要素は通常は@w{@code{(@var{sym} . @var{val})}}という形式をもつ。ここで@var{sym}はバッファーローカル変数(シンボル)、@var{val}はバッファーローカル値。しかし@var{buffer}内のある変数のバッファーローカルなバインディングがvoidなら、その変数に対応するリスト要素は単に@var{sym}となる。"

#. type: group
#: original_texis/variables.texi:1685
#, no-wrap
msgid ""
"(make-local-variable 'foobar)\n"
"(makunbound 'foobar)\n"
"(make-local-variable 'bind-me)\n"
"(setq bind-me 69)\n"
msgstr ""
"(make-local-variable 'foobar)\n"
"(makunbound 'foobar)\n"
"(make-local-variable 'bind-me)\n"
"(setq bind-me 69)\n"

#. type: example
#: original_texis/variables.texi:1692
#, no-wrap
msgid ""
"(setq lcl (buffer-local-variables))\n"
"    ;; @r{First, built-in variables local in all buffers:}\n"
"@result{} ((mark-active . nil)\n"
"    (buffer-undo-list . nil)\n"
"    (mode-name . \"Fundamental\")\n"
"    @dots{}\n"
msgstr ""
"(setq lcl (buffer-local-variables))\n"
"    ;; @r{最初はすべてのバッファー内でローカルなビルトイン変数:}\n"
"@result{} ((mark-active . nil)\n"
"    (buffer-undo-list . nil)\n"
"    (mode-name . \"Fundamental\")\n"
"    @dots{}\n"

#. type: group
#: original_texis/variables.texi:1698
#, no-wrap
msgid ""
"    ;; @r{Next, non-built-in buffer-local variables.}\n"
"    ;; @r{This one is buffer-local and void:}\n"
"    foobar\n"
"    ;; @r{This one is buffer-local and nonvoid:}\n"
"    (bind-me . 69))\n"
msgstr ""
"    ;; @r{次にビルトインでないバッファーローカル変数}\n"
"    ;; @r{This one is buffer-local and void:}\n"
"    foobar\n"
"    ;; @r{これはバッファーローカルでvoidではない:}\n"
"    (bind-me . 69))\n"

#. type: defun
#: original_texis/variables.texi:1703
msgid "Note that storing new values into the @sc{cdr}s of cons cells in this list does @emph{not} change the buffer-local values of the variables."
msgstr "このリスト内のコンスセルの@sc{cdr}に新たな値を格納しても、その変数のバッファーローカル値は@emph{変化しない}ことに注意。"

#. type: deffn
#: original_texis/variables.texi:1705
#, no-wrap
msgid "Command kill-local-variable variable"
msgstr "Command kill-local-variable variable"

#. type: deffn
#: original_texis/variables.texi:1712
msgid "This function deletes the buffer-local binding (if any) for @var{variable} (a symbol) in the current buffer.  As a result, the default binding of @var{variable} becomes visible in this buffer.  This typically results in a change in the value of @var{variable}, since the default value is usually different from the buffer-local value just eliminated."
msgstr "この関数はカレントバッファー内の@var{variable}(シンボル)にたいするバッファーローカルなバインディング(もしあれば)を削除する。その結果として、このバッファー内で@var{variable}のデフォルトバインディングが可視になる。これは通常は@var{variable}の値を変更する。デフォルト値は削除されたバッファーローカル値とは異なるのが普通だからである。"

#. type: deffn
#: original_texis/variables.texi:1717
msgid "If you kill the buffer-local binding of a variable that automatically becomes buffer-local when set, this makes the default value visible in the current buffer.  However, if you set the variable again, that will once again create a buffer-local binding for it."
msgstr "セットしたとき自動的にバッファーローカルになる変数のバッファーローカルなバインディングをkillすると、これによりカレントバッファー内でデフォルト値が可視になる。しかし変数を再度セットすると、その変数にたいするバッファーローカルなバインディングが再作成される。"

#. type: deffn
#: original_texis/variables.texi:1719
msgid "@code{kill-local-variable} returns @var{variable}."
msgstr "@code{kill-local-variable}は@var{variable}をreturnします。"

#. type: deffn
#: original_texis/variables.texi:1723
msgid "This function is a command because it is sometimes useful to kill one buffer-local variable interactively, just as it is useful to create buffer-local variables interactively."
msgstr "この関数はコマンドである。なぜならバッファーローカル変数のインタラクティブな作成が有用な場合があるように、あるバッファーローカル変数のインタラクティブなkillが有用な場合があるからである。"

#. type: cindex
#: original_texis/variables.texi:1725
#, no-wrap
msgid "local variables, killed by major mode"
msgstr "local variables, killed by major mode"

#. type: defun
#: original_texis/variables.texi:1726
#, no-wrap
msgid "kill-all-local-variables &optional kill-permanent"
msgstr "kill-all-local-variables &optional kill-permanent"

#. type: defun
#: original_texis/variables.texi:1734
msgid "This function eliminates all the buffer-local variable bindings of the current buffer.  As a result, the buffer will see the default values of most variables.  By default, for variables marked as permanent and local hook functions that have a non-@code{nil} @code{permanent-local-hook} property (@pxref{Setting Hooks}) won't be killed, but if the optional @var{kill-permanent} argument is non-@code{nil}, even these variables will be killed."
msgstr "この関数はカレントバッファーにおいてバッファーローカル変数のすべてのバインディングを解消する。結果としてそのバッファーではほとんどの変数にたいしてデフォルト値を参照することになる。デフォルトではpermanent(永続的)とマークされた変数、および非@code{nil}の@code{permanent-local-hook}プロパティをもつローカルフック関数(@ref{Setting Hooks}を参照)は除外されるが、オプションの@var{kill-permanent}引数が非@code{nil}ならこれらの変数をもkillされる。"

#. type: defun
#: original_texis/variables.texi:1740
msgid "This function also resets certain other information pertaining to the buffer: it sets the local keymap to @code{nil}, the syntax table to the value of @code{(standard-syntax-table)}, the case table to @code{(standard-case-table)}, and the abbrev table to the value of @code{fundamental-mode-abbrev-table}."
msgstr "この関数はそのバッファーに関連する他の特定の情報もリセットする。これはローカルキーマップを@code{nil}、構文テーブルを@code{(standard-syntax-table)}の値、caseテーブルを@code{(standard-case-table)}、abbrevテーブルを@code{fundamental-mode-abbrev-table}の値にセットする。"

#. type: defun
#: original_texis/variables.texi:1743
msgid "The very first thing this function does is run the normal hook @code{change-major-mode-hook} (see below)."
msgstr "この関数が一番最初に行うのはノーマルフック@code{change-major-mode-hook}(以下参照)の実行である。"

#. type: defun
#: original_texis/variables.texi:1748
msgid "Every major mode command begins by calling this function, which has the effect of switching to Fundamental mode and erasing most of the effects of the previous major mode.  To ensure that this does its job, the variables that major modes set should not be marked permanent."
msgstr "すべてのメジャーモードコマンドはこの関数を呼び出すことによって開始され、これによりFundamentalモードにスイッチし、以前のメジャーモードの影響のほとんどを消去する効果があります。この関数が処理を行うのを確実にするために、メジャーモードがセットする変数はpermanentとマークすべきではない。"

#. type: defun
#: original_texis/variables.texi:1750
msgid "@code{kill-all-local-variables} returns @code{nil}."
msgstr "@code{kill-all-local-variables}は@code{nil}をreturnします。"

#. type: defvar
#: original_texis/variables.texi:1752
#, no-wrap
msgid "change-major-mode-hook"
msgstr "change-major-mode-hook"

#. type: defvar
#: original_texis/variables.texi:1758
msgid "The function @code{kill-all-local-variables} runs this normal hook before it does anything else.  This gives major modes a way to arrange for something special to be done if the user switches to a different major mode.  It is also useful for buffer-specific minor modes that should be forgotten if the user changes the major mode."
msgstr "関数@code{kill-all-local-variables}は、何か他のことを行う前にまずこのノーマルフックを実行する。この関数はメジャーモードにたいして、ユーザーが他のメジャーモードにスイッチした場合に行われる何か特別なことを準備する方法を与える。この関数はユーザーがメジャーモードを変更した場合に忘れられるべき、バッファー固有のマイナーモードにたいしても有用。"

#. type: defvar
#: original_texis/variables.texi:1762
msgid "For best results, make this variable buffer-local, so that it will disappear after doing its job and will not interfere with the subsequent major mode.  @xref{Hooks}."
msgstr "最善の結果を得るために、この変数をバッファーローカルにすれば、処理が終了したときに消えるので、以降のメジャーモードに干渉しなくなる。@ref{Hooks}を参照のこと。"

#. type: cindex
#: original_texis/variables.texi:1764
#, no-wrap
msgid "permanent local variable"
msgstr "permanent local variable"

#. type: Plain text
#: original_texis/variables.texi:1771
msgid "A buffer-local variable is @dfn{permanent} if the variable name (a symbol) has a @code{permanent-local} property that is non-@code{nil}.  Such variables are unaffected by @code{kill-all-local-variables}, and their local bindings are therefore not cleared by changing major modes.  Permanent locals are appropriate for data pertaining to where the file came from or how to save it, rather than with how to edit the contents."
msgstr "変数名(シンボル)が非@code{nil}の@code{permanent-local}プロパティをもつなら、そのバッファーローカル変数は@dfn{permanent(永続的)}です。そのような変数は@code{kill-all-local-variables}の影響を受けず、したがってメジャーモードの変更によりそれらのローカルバインディングは作成されません。permanentなローカル変数はファイルの内容を編集する方法ではなく、どこから読み込んだファイルか、あるいはどのように保存するかといったことに関連するデータに適しています。"

#. type: subsection
#: original_texis/variables.texi:1773
#, no-wrap
msgid "The Default Value of a Buffer-Local Variable"
msgstr "The Default Value of a Buffer-Local Variable"

#. type: cindex
#: original_texis/variables.texi:1774
#, no-wrap
msgid "default value"
msgstr "default value"

#. type: Plain text
#: original_texis/variables.texi:1780
msgid "The global value of a variable with buffer-local bindings is also called the @dfn{default} value, because it is the value that is in effect whenever neither the current buffer nor the selected frame has its own binding for the variable."
msgstr "バッファーローカルなバインディングをもつ変数のグローバル値も@dfn{デフォルト値(default)}値と呼ばれます。なぜならその変数にたいしてカレントバッファーや選択されたフレームもバインディングをもたなければ、その値が常に効果をもつからです。"

#. type: Plain text
#: original_texis/variables.texi:1788
msgid "The functions @code{default-value} and @code{setq-default} access and change a variable's default value regardless of whether the current buffer has a buffer-local binding.  For example, you could use @code{setq-default} to change the default setting of @code{paragraph-start} for most buffers; and this would work even when you are in a C or Lisp mode buffer that has a buffer-local value for this variable."
msgstr "関数@code{default-value}と@code{setq-default}は、カレントバッファーがバッファーローカルなバインディングをもつかどうかに関わらず、その変数のデフォルト値にアクセスまたは変更します。たとえばほとんどのバッファーにたいして、@code{paragraph-start}のデフォルトのセッティングを変更するために、@code{setq-default}を使用できます。そしてこの変数にたいするバッファーローカルな値をもつCモードやLispモードにいるときでさえ、これは機能します。"

#. type: Plain text
#: original_texis/variables.texi:1792
msgid "The special forms @code{defvar} and @code{defconst} also set the default value (if they set the variable at all), rather than any buffer-local value."
msgstr "スペシャルフォーム@code{defvar}と@code{defconst}もバッファーローカルな値ではなく、(もし変数にセットする場合は)デフォルト値をセットします。"

#. type: defun
#: original_texis/variables.texi:1793
#, no-wrap
msgid "default-value symbol"
msgstr "default-value symbol"

#. type: defun
#: original_texis/variables.texi:1798
msgid "This function returns @var{symbol}'s default value.  This is the value that is seen in buffers and frames that do not have their own values for this variable.  If @var{symbol} is not buffer-local, this is equivalent to @code{symbol-value} (@pxref{Accessing Variables})."
msgstr "この関数は@var{symbol}のデフォルト値をリターンする。これはこの変数にたいして独自の値をもたないバッファーやフレームから参照される値である。@var{symbol}がバッファーローカルでなければ、これは@code{symbol-value}(@ref{Accessing Variables}を参照)と同じ。"

#. type: defun
#: original_texis/variables.texi:1800
#, no-wrap
msgid "default-boundp symbol"
msgstr "default-boundp symbol"

#. type: defun
#: original_texis/variables.texi:1804
msgid "The function @code{default-boundp} tells you whether @var{symbol}'s default value is nonvoid.  If @code{(default-boundp 'foo)} returns @code{nil}, then @code{(default-value 'foo)} would get an error."
msgstr "関数@code{default-boundp}は@var{symbol}のデフォルト値がvoidでないか報告する。@code{(default-boundp 'foo)}が@code{nil}をリターンした場合には@code{(default-value 'foo)}はエラーになる。"

#. type: defun
#: original_texis/variables.texi:1807
msgid "@code{default-boundp} is to @code{default-value} as @code{boundp} is to @code{symbol-value}."
msgstr "@code{default-boundp}は、@code{boundp}が@code{symbol-value}に対応するように、@code{default-value}に対応する。"

#. type: defspec
#: original_texis/variables.texi:1809
#, no-wrap
msgid "setq-default [symbol form]@dots{}"
msgstr "setq-default [symbol form]@dots{}"

#. type: defspec
#: original_texis/variables.texi:1814
msgid "This special form gives each @var{symbol} a new default value, which is the result of evaluating the corresponding @var{form}.  It does not evaluate @var{symbol}, but does evaluate @var{form}.  The value of the @code{setq-default} form is the value of the last @var{form}."
msgstr "このスペシャルフォームは各@var{symbol}に新たなデフォルト値として、対応する@var{form}を評価した結果を与える。これは@var{symbol}を評価しないが@var{form}は評価する。@code{setq-default}フォームの値は最後の@var{form}の値。"

#. type: defspec
#: original_texis/variables.texi:1821
msgid "If a @var{symbol} is not buffer-local for the current buffer, and is not marked automatically buffer-local, @code{setq-default} has the same effect as @code{setq}.  If @var{symbol} is buffer-local for the current buffer, then this changes the value that other buffers will see (as long as they don't have a buffer-local value), but not the value that the current buffer sees."
msgstr "カレントバッファーにたいして@var{symbol}がバッファーローカルでなく、自動的にバッファーローカルにマークされていなければ、@code{setq-default}は@code{setq}と同じ効果をもつ。カレントバッファーにたいして@var{symbol}がバッファーローカルなら、(バッファーローカルな値をもたない)他のバッファーから参照できる値を変更するが、それはカレントバッファーが参照する値ではない。"

#. type: group
#: original_texis/variables.texi:1827
#, no-wrap
msgid ""
";; @r{In buffer @samp{foo}:}\n"
"(make-local-variable 'buffer-local)\n"
"     @result{} buffer-local\n"
msgstr ""
";; @r{バッファー@samp{foo}で行う:}\n"
"(make-local-variable 'buffer-local)\n"
"     @result{} buffer-local\n"

#. type: group
#: original_texis/variables.texi:1831
#, no-wrap
msgid ""
"(setq buffer-local 'value-in-foo)\n"
"     @result{} value-in-foo\n"
msgstr ""
"(setq buffer-local 'value-in-foo)\n"
"     @result{} value-in-foo\n"

#. type: group
#: original_texis/variables.texi:1835
#, no-wrap
msgid ""
"(setq-default buffer-local 'new-default)\n"
"     @result{} new-default\n"
msgstr ""
"(setq-default buffer-local 'new-default)\n"
"     @result{} new-default\n"

#. type: group
#: original_texis/variables.texi:1839
#, no-wrap
msgid ""
"buffer-local\n"
"     @result{} value-in-foo\n"
msgstr ""
"buffer-local\n"
"     @result{} value-in-foo\n"

#. type: group
#: original_texis/variables.texi:1843 original_texis/variables.texi:1853
#, no-wrap
msgid ""
"(default-value 'buffer-local)\n"
"     @result{} new-default\n"
msgstr ""
"(default-value 'buffer-local)\n"
"     @result{} new-default\n"

#. type: group
#: original_texis/variables.texi:1849
#, no-wrap
msgid ""
";; @r{In (the new) buffer @samp{bar}:}\n"
"buffer-local\n"
"     @result{} new-default\n"
msgstr ""
";; @r{(新しい)バッファー@samp{bar}で行う:}\n"
"buffer-local\n"
"     @result{} new-default\n"

#. type: group
#: original_texis/variables.texi:1857
#, no-wrap
msgid ""
"(setq buffer-local 'another-default)\n"
"     @result{} another-default\n"
msgstr ""
"(setq buffer-local 'another-default)\n"
"     @result{} another-default\n"

#. type: group
#: original_texis/variables.texi:1861
#, no-wrap
msgid ""
"(default-value 'buffer-local)\n"
"     @result{} another-default\n"
msgstr ""
"(default-value 'buffer-local)\n"
"     @result{} another-default\n"

#. type: group
#: original_texis/variables.texi:1869
#, no-wrap
msgid ""
";; @r{Back in buffer @samp{foo}:}\n"
"buffer-local\n"
"     @result{} value-in-foo\n"
"(default-value 'buffer-local)\n"
"     @result{} another-default\n"
msgstr ""
";; @r{バッファー@samp{foo}に戻って行う:}\n"
"buffer-local\n"
"     @result{} value-in-foo\n"
"(default-value 'buffer-local)\n"
"     @result{} another-default\n"

#. type: defun
#: original_texis/variables.texi:1873
#, no-wrap
msgid "set-default symbol value"
msgstr "set-default symbol value"

#. type: defun
#: original_texis/variables.texi:1876
msgid "This function is like @code{setq-default}, except that @var{symbol} is an ordinary evaluated argument."
msgstr "この関数は@code{setq-default}と似ているが、@var{symbol}は通常の引数として評価される。"

#. type: group
#: original_texis/variables.texi:1881
#, no-wrap
msgid ""
"(set-default (car '(a b c)) 23)\n"
"     @result{} 23\n"
msgstr ""
"(set-default (car '(a b c)) 23)\n"
"     @result{} 23\n"

#. type: group
#: original_texis/variables.texi:1885
#, no-wrap
msgid ""
"(default-value 'a)\n"
"     @result{} 23\n"
msgstr ""
"(default-value 'a)\n"
"     @result{} 23\n"

#. type: Plain text
#: original_texis/variables.texi:1896
msgid "A variable can be let-bound (@pxref{Local Variables}) to a value.  This makes its global value shadowed by the binding; @code{default-value} will then return the value from that binding, not the global value, and @code{set-default} will be prevented from setting the global value (it will change the let-bound value instead).  The following two functions allow to reference the global value even if it's shadowed by a let-binding."
msgstr "ある変数に値をletバインドできます(@ref{Local Variables}を参照)。このバインディングにより変数のグローバル値はシャドーされます。@code{default-value}はグローバル値ではなくそのバインディングの値をリターンして、@code{set-default}によるグローバル値のセットは防がれます(かわりにletバインドされた値が変更される)。以下の2つの関数によりletバインドでグローバル値がシャドーされていてもグローバル値を参照できます。"

#. type: cindex
#: original_texis/variables.texi:1897
#, no-wrap
msgid "top-level default value"
msgstr "top-level default value"

#. type: defun
#: original_texis/variables.texi:1898
#, no-wrap
msgid "default-toplevel-value symbol"
msgstr "default-toplevel-value symbol"

#. type: defun
#: original_texis/variables.texi:1901
msgid "This function returns the @dfn{top-level} default value of @var{symbol}, which is its value outside of any let-binding."
msgstr "この関数は@var{symbol}にたいするすべてのletバインディングの外部の値として@dfn{トップレベル}のデフォルト値をリターンする。"

#. type: group
#: original_texis/variables.texi:1907
#, no-wrap
msgid ""
"(defvar variable 'global-value)\n"
"    @result{} variable\n"
msgstr ""
"(defvar variable 'global-value)\n"
"    @result{} variable\n"

#. type: group
#: original_texis/variables.texi:1912
#, no-wrap
msgid ""
"(let ((variable 'let-binding))\n"
"  (default-value 'variable))\n"
"    @result{} let-binding\n"
msgstr ""
"(let ((variable 'let-binding))\n"
"  (default-value 'variable))\n"
"    @result{} let-binding\n"

#. type: group
#: original_texis/variables.texi:1917
#, no-wrap
msgid ""
"(let ((variable 'let-binding))\n"
"  (default-toplevel-value 'variable))\n"
"    @result{} global-value\n"
msgstr ""
"(let ((variable 'let-binding))\n"
"  (default-toplevel-value 'variable))\n"
"    @result{} global-value\n"

#. type: defun
#: original_texis/variables.texi:1920
#, no-wrap
msgid "set-default-toplevel-value symbol value"
msgstr "set-default-toplevel-value symbol value"

#. type: defun
#: original_texis/variables.texi:1925
msgid "This function sets the top-level default value of @var{symbol} to the specified @var{value}.  This comes in handy when you want to set the global value of @var{symbol} regardless of whether your code runs in the context of @var{symbol}'s let-binding."
msgstr "この関数は@var{symbol}のトップレベルのデフォルト値に指定された@var{value}をセットする。これはコードが@var{symbol}のletバインディングのコンテキスト下で実行中かどうかとは無関係に@var{symbol}のグローバル値をセットしたいときに便利。"

#. type: cindex
#: original_texis/variables.texi:1930
#, no-wrap
msgid "file local variables"
msgstr "file local variables"

#. type: Plain text
#: original_texis/variables.texi:1938
msgid "A file can specify local variable values; Emacs uses these to create buffer-local bindings for those variables in the buffer visiting that file.  @xref{File Variables, , Local Variables in Files, emacs, The GNU Emacs Manual}, for basic information about file-local variables.  This section describes the functions and variables that affect how file-local variables are processed."
msgstr "ファイルにローカル変数の値を指定できます。そのファイルをvisitしているバッファー内で、これらの変数にたいしてバッファーローカルなバインディングを作成するために、Emacsはこれらを使用します。ファイルローカル変数の基本的な情報については、@ref{File Variables, , Local Variables in Files, emacs, The GNU Emacs Manual}を参照してください。このセクションではファイルローカル変数が処理される方法に影響する関数と変数を説明します。"

#. type: Plain text
#: original_texis/variables.texi:1944
msgid "If a file-local variable could specify an arbitrary function or Lisp expression that would be called later, visiting a file could take over your Emacs.  Emacs protects against this by automatically setting only those file-local variables whose specified values are known to be safe.  Other file-local variables are set only if the user agrees."
msgstr "ファイルローカル変数が勝手に関数や、後で呼び出されるLisp式を指定できたら、ファイルのvisitによってEmacsが乗っ取られてしまうかもしれません。Emacsは既知のファイルローカル変数だけにたいして、指定された値が安全だと自動的にセットすることにより、この危険から保護します。これ以外のファイルローカル変数は、ユーザーが同意した場合のみセットされます。"

#. type: Plain text
#: original_texis/variables.texi:1949
msgid "For additional safety, @code{read-circle} is temporarily bound to @code{nil} when Emacs reads file-local variables (@pxref{Input Functions}).  This prevents the Lisp reader from recognizing circular and shared Lisp structures (@pxref{Circular Objects})."
msgstr "追加の安全策としてEmacsがファイルローカル変数を読み込むとき、一時的に@code{read-circle}を@code{nil}にバインドします(@ref{Input Functions}を参照)。これは循環認識と共有されたLisp構造からLispリーダーを保護します(@ref{Circular Objects}を参照)。"

#. type: defopt
#: original_texis/variables.texi:1950
#, no-wrap
msgid "enable-local-variables"
msgstr "enable-local-variables"

#. type: defopt
#: original_texis/variables.texi:1953
msgid "This variable controls whether to process file-local variables.  The possible values are:"
msgstr "この変数はファイルローカル変数を処理するかどうかを制御する。以下の値が利用できる:"

#. type: item
#: original_texis/variables.texi:1955
#, no-wrap
msgid "@code{t} (the default)"
msgstr "@code{t}(デフォルト)"

#. type: table
#: original_texis/variables.texi:1957
msgid "Set the safe variables, and query (once) about any unsafe variables."
msgstr "安全な変数をセット、安全でない変数は問い合わせる(1回)。"

#. type: code{#1}
#: original_texis/variables.texi:1957
#, no-wrap
msgid ":safe"
msgstr ":safe"

#. type: table
#: original_texis/variables.texi:1959
msgid "Set only the safe variables and do not query."
msgstr "安全な変数だけをセット、問い合わせはしない。"

#. type: code{#1}
#: original_texis/variables.texi:1959
#, no-wrap
msgid ":all"
msgstr ":all"

#. type: table
#: original_texis/variables.texi:1961
msgid "Set all the variables and do not query."
msgstr "問い合わせをせずに、すべての変数をセット。"

#. type: code{#1}
#: original_texis/variables.texi:1961
#, no-wrap
msgid "nil"
msgstr "nil"

#. type: table
#: original_texis/variables.texi:1963
msgid "Don't set any variables."
msgstr "変数をセットしない。"

#. type: item
#: original_texis/variables.texi:1963
#, no-wrap
msgid "anything else"
msgstr "その他"

#. type: table
#: original_texis/variables.texi:1965
msgid "Query (once) about all the variables."
msgstr "すべての変数にたいして問い合わせる(1回)。"

#. type: defvar
#: original_texis/variables.texi:1968
#, no-wrap
msgid "inhibit-local-variables-regexps"
msgstr "inhibit-local-variables-regexps"

#. type: defvar
#: original_texis/variables.texi:1973
msgid "This is a list of regular expressions.  If a file has a name matching an element of this list, then it is not scanned for any form of file-local variable.  For examples of why you might want to use this, @pxref{Auto Major Mode}."
msgstr "これは正規表現のリストである。ファイルがこのリストの要素にマッチする名前をもつなら、すべてのファイルローカル変数のフォームはスキャンされない。どんなときにこれを使いたいかの例は、@ref{Auto Major Mode}を参照のこと。"

#. type: defvar
#: original_texis/variables.texi:1975
#, no-wrap
msgid "permanently-enabled-local-variables"
msgstr "permanently-enabled-local-variables"

#. type: defvar
#: original_texis/variables.texi:1981
msgid "Some local variable settings will, by default, be heeded even if @code{enable-local-variables} is @code{nil}.  By default, this is only the case for the @code{lexical-binding} local variable setting, but this can be controlled by using this variable, which is a list of symbols."
msgstr "たとえ@code{enable-local-variables}が@code{nil}であっても、いくつかのローカル変数セッティングは、デフォルトでは注意する必要があるだろう。これはデフォルトにおいてローカル変数@code{lexical-binding}のセッティングの場合だけだが、この変数(シンボルのリスト)を使用して制御できる。"

#. type: defun
#: original_texis/variables.texi:1983
#, no-wrap
msgid "hack-local-variables &optional handle-mode"
msgstr "hack-local-variables &optional handle-mode"

#. type: defun
#: original_texis/variables.texi:1990
msgid "This function parses, and binds or evaluates as appropriate, any local variables specified by the contents of the current buffer.  The variable @code{enable-local-variables} has its effect here.  However, this function does not look for the @samp{mode:} local variable in the @w{@samp{-*-}} line.  @code{set-auto-mode} does that, also taking @code{enable-local-variables} into account (@pxref{Auto Major Mode})."
msgstr "この関数はカレントバッファーの内容により指定された任意のローカル変数にたいしてパースを行い、適切にバインドと評価を行う。変数@code{enable-local-variables}はここでも効果をもつ。しかしこの関数は@w{@samp{-*-}}行の、@samp{mode:}ローカル変数を探さない。@code{set-auto-mode}はこれを行って@code{enable-local-variables}も考慮する(@ref{Auto Major Mode}を参照)。"

#. type: defun
#: original_texis/variables.texi:1999
msgid "This function works by walking the alist stored in @code{file-local-variables-alist} and applying each local variable in turn.  It calls @code{before-hack-local-variables-hook} and @code{hack-local-variables-hook} before and after applying the variables, respectively.  It only calls the before-hook if the alist is non-@code{nil}; it always calls the other hook.  This function ignores a @samp{mode} element if it specifies the same major mode as the buffer already has."
msgstr "この関数は@code{file-local-variables-alist}内に格納されたalistを調べて、各ローカル変数を順に適用することにより機能する。この関数は変数に適用する前(か後)に、@code{before-hack-local-variables-hook}(か@code{hack-local-variables-hook})を呼び出す。alistが非@code{nil}の場合のみ、事前のフック(before-hook)を呼び出し、その他のフックは常に呼び出す。この関数はそのバッファーがすでにもつメジャーモードと同じメジャーモードが指定された場合は@samp{mode}要素を無視する。"

#. type: defun
#: original_texis/variables.texi:2009
msgid "If the optional argument @var{handle-mode} is @code{t}, then all this function does is return a symbol specifying the major mode, if the @w{@samp{-*-}} line or the local variables list specifies one, and @code{nil} otherwise.  It does not set the mode or any other file-local variable.  If @var{handle-mode} has any value other than @code{nil} or @code{t}, any settings of @samp{mode} in the @w{@samp{-*-}} line or the local variables list are ignored, and the other settings are applied.  If @var{handle-mode} is @code{nil}, all the file local variables are set."
msgstr "オプションの引数@var{handle-mode}が@code{t}なら、この関数が行うのはメジャーモードを指定するシンボルをリターンすることだけであり、@w{@samp{-*-}}行やローカル変数リストがメジャーモードを指定していればそのモード、それ以外は@code{nil}をリターンする。この関数はモードや他のファイルローカル変数をセットしない。@var{handle-mode}の値が@code{nil}と@code{t}のいずれでもなければ@w{@samp{-*-}}行の@samp{mode}に関するすべてのセッティングとローカル変数リストは無視されて、別のセッティングが適用される。@var{handle-mode}が@code{nil}ならすべてのファイルローカル変数がセットされる。"

#. type: defvar
#: original_texis/variables.texi:2011
#, no-wrap
msgid "file-local-variables-alist"
msgstr "file-local-variables-alist"

#. type: defvar
#: original_texis/variables.texi:2019
msgid "This buffer-local variable holds the alist of file-local variable settings.  Each element of the alist is of the form @w{@code{(@var{var} . @var{value})}}, where @var{var} is a symbol of the local variable and @var{value} is its value.  When Emacs visits a file, it first collects all the file-local variables into this alist, and then the @code{hack-local-variables} function applies them one by one."
msgstr "このバッファーローカルな変数は、ファイルローカル変数のセッティングのalistを保持する。alistの各要素は@w{@code{(@var{var} . @var{value})}}という形式で、@var{var}はローカル変数のシンボル、@var{value}はその値である。Emacsがファイルをvisitするとき、最初にすべてのファイルローカル変数をこのalistに収集して、その後で変数に1つずつ関数@code{hack-local-variables}を適用する。"

#. type: defvar
#: original_texis/variables.texi:2021
#, no-wrap
msgid "before-hack-local-variables-hook"
msgstr "before-hack-local-variables-hook"

#. type: defvar
#: original_texis/variables.texi:2024
msgid "Emacs calls this hook immediately before applying file-local variables stored in @code{file-local-variables-alist}."
msgstr "Emacsは@code{file-local-variables-alist}に格納されたファイルローカル変数を適用する直前にこのフックを呼び出す。"

#. type: defvar
#: original_texis/variables.texi:2026
#, no-wrap
msgid "hack-local-variables-hook"
msgstr "hack-local-variables-hook"

#. type: defvar
#: original_texis/variables.texi:2029
msgid "Emacs calls this hook immediately after it finishes applying file-local variables stored in @code{file-local-variables-alist}."
msgstr "Emacsは@code{file-local-variables-alist}に格納されたファイルローカル変数を適用し終えた直後にこのフックを呼び出す。"

#. type: cindex
#: original_texis/variables.texi:2031
#, no-wrap
msgid "safe local variable"
msgstr "safe local variable"

#. type: cindex
#: original_texis/variables.texi:2032
#, no-wrap
msgid "@code{safe-local-variable}, property of variable"
msgstr "@code{safe-local-variable}, property of variable"

#. type: Plain text
#: original_texis/variables.texi:2041
msgid "You can specify safe values for a variable with a @code{safe-local-variable} property.  The property has to be a function of one argument; any value is safe if the function returns non-@code{nil} given that value.  Many commonly-encountered file variables have @code{safe-local-variable} properties; these include @code{fill-column}, @code{fill-prefix}, and @code{indent-tabs-mode}.  For boolean-valued variables that are safe, use @code{booleanp} as the property value."
msgstr "ある変数にたいして@code{safe-local-variable}プロパティによって安全な値を指定できます。このプロパティは引数を1つとる関数です。与えられた値にたいして、その関数が非@code{nil}をリターンしたらその値は安全です。一般的に目にするファイル変数の多くは、@code{safe-local-variable}プロパティをもちます。これらのファイル変数には@code{fill-column}、@code{fill-prefix}、@code{indent-tabs-mode}が含まれます。ブーリーン値の変数にたいしては、プロパティの値に@code{booleanp}を使用します。"

#. type: Plain text
#: original_texis/variables.texi:2046
msgid "If you want to define @code{safe-local-variable} properties for variables defined in C source code, add the names and the properties of those variables to the list in the ``Safe local variables'' section of @file{files.el}."
msgstr "Cソースコード内で定義された変数に@code{safe-local-variable}プロパティを定義したければ、それらの変数の名前とプロパティを@file{files.el}のセクション``Safe local variables''のリストに追加してください。"

#. type: cindex
#: original_texis/variables.texi:2047
#, no-wrap
msgid "autoload cookie, and safe values of variable"
msgstr "autoload cookie, and safe values of variable"

#. type: Plain text
#: original_texis/variables.texi:2056
msgid "When defining a user option using @code{defcustom}, you can set its @code{safe-local-variable} property by adding the arguments @code{:safe @var{function}} to @code{defcustom} (@pxref{Variable Definitions}).  However, a safety predicate defined using @code{:safe} will only be known once the package that contains the @code{defcustom} is loaded, which is often too late.  As an alternative, you can use the autoload cookie (@pxref{Autoload}) to assign the option its safety predicate, like this:"
msgstr "@code{defcustom}を使用してユーザーオプションを定義する際には、@code{defcustom}に引数@code{:safe @var{function}}を追加して@code{safe-local-variable}プロパティをセットできます(@ref{Variable Definitions}を参照)。しかし@code{:safe}を使用して定義された安全性の述語は、その@code{defcustom}を含むパッケージのロード時の一度だけ認識されるものであり、それでは遅すぎることがしばしばあります。代替策としては、以下のようにオプションに安全性の述語を割り当てるためにautoloadクッキー(@ref{Autoload}を参照)を使用できます:"

#. type: lisp
#: original_texis/variables.texi:2059
#, no-wrap
msgid ";;;###autoload (put '@var{var} 'safe-local-variable '@var{pred})\n"
msgstr ";;;###autoload (put '@var{var} 'safe-local-variable '@var{pred})\n"

#. type: Plain text
#: original_texis/variables.texi:2066
msgid "The safe value definitions specified with @code{autoload} are copied into the package's autoloads file (@file{loaddefs.el} for most packages bundled with Emacs), and are known to Emacs since the beginning of a session."
msgstr "@code{autoload}で指定された安全な値の定義は、そのパッケージのautoloadファイル(Emacsに同梱されたパッケージのほとんどでは@file{loaddefs.el})にコピーされて、セッションの開始からEmacsにより認識されます。"

#. type: defopt
#: original_texis/variables.texi:2067
#, no-wrap
msgid "safe-local-variable-values"
msgstr "safe-local-variable-values"

#. type: defopt
#: original_texis/variables.texi:2072
msgid "This variable provides another way to mark some variable values as safe.  It is a list of cons cells @code{(@var{var} . @var{val})}, where @var{var} is a variable name and @var{val} is a value which is safe for that variable."
msgstr "この変数はある変数の値が安全であることをマークする、別の方法を提供する。これはコンスセル@code{(@var{var} . @var{val})}のリストであり@var{var}は変数名、@var{val}はその変数にたいして安全な値である。"

#. type: defopt
#: original_texis/variables.texi:2078
msgid "When Emacs asks the user whether or not to obey a set of file-local variable specifications, the user can choose to mark them as safe.  Doing so adds those variable/value pairs to @code{safe-local-variable-values}, and saves it to the user's custom file."
msgstr "Emacsが一連のファイルローカル変数にしたがうかどうかユーザーに尋ねるとき、ユーザーはそれらの変数が安全だとマークすることができる。安全とマークすると@code{safe-local-variable-values}にこれらのvariable/valueペアーが追加されて、ユーザーのカスタムファイルに保存する。"

#. type: defopt
#: original_texis/variables.texi:2080
#, no-wrap
msgid "ignored-local-variable-values"
msgstr "ignored-local-variable-values"

#. type: defopt
#: original_texis/variables.texi:2092
msgid "If there are some values of particular local variables that you always want to ignore completely, you can use this variable.  Its value has the same form as @code{safe-local-variable-values}; a file-local variable setting to the value that appears in the list will always be ignored when processing the local variables specified by the file.  As with that variable, when Emacs queries the user about whether to obey file-local variables, the user can choose to ignore their particular values permanently, and that will alter this variable and save it to the user's custom file.  Variable-value pairs that appear in this variable take precedence over the same pairs in @code{safe-local-variable-values}."
msgstr "特定のローカル変数にたいして常に完全に無視したい値がいくつかある場合には、この変数を使用できる。値は@code{safe-local-variable-values}と同じ形式であり、ファイルが指定するローカル変数の処理時にこのリストに現れる値にセットされるファイルローカル変数は常に無視される。@code{safe-local-variable-values}の場合のように、ファイルローカル変数にしたがうべきかEmacsがユーザーに尋ねる際に、ユーザーは特定の値を恒久的に無視することを選択でき、この選択によってこの変数は変更されてユーザーのcustomファイルに保存される。この変数にある変数/値ペアーは、@code{safe-local-variable-values}内にある同一ペアーより優先される。"

#. type: defun
#: original_texis/variables.texi:2094
#, no-wrap
msgid "safe-local-variable-p sym val"
msgstr "safe-local-variable-p sym val"

#. type: defun
#: original_texis/variables.texi:2097
msgid "This function returns non-@code{nil} if it is safe to give @var{sym} the value @var{val}, based on the above criteria."
msgstr "この関数は上記の条件に基づき、@var{sym}に値@var{val}を与えても安全ななら非@code{nil}をリターンする。"

#. type: Plain text
#: original_texis/variables.texi:2105
msgid "Some variables are considered @dfn{risky}.  If a variable is risky, it is never entered automatically into @code{safe-local-variable-values}; Emacs always queries before setting a risky variable, unless the user explicitly allows a value by customizing @code{safe-local-variable-values} directly."
msgstr "いくつかの変数は@dfn{危険(risky)}だと判断されます。ある変数が危険なら、その変数が@code{safe-local-variable-values}に自動的に追加されることはありません。ユーザーが@code{safe-local-variable-values}を直接カスタマイズすることで明示的に値を許さない限り、危険な変数をセットする前にEmacsは常に確認を求めます。"

#. type: Plain text
#: original_texis/variables.texi:2119
msgid "Any variable whose name has a non-@code{nil} @code{risky-local-variable} property is considered risky.  When you define a user option using @code{defcustom}, you can set its @code{risky-local-variable} property by adding the arguments @code{:risky @var{value}} to @code{defcustom} (@pxref{Variable Definitions}).  In addition, any variable whose name ends in any of @samp{-command}, @samp{-frame-alist}, @samp{-function}, @samp{-functions}, @samp{-hook}, @samp{-hooks}, @samp{-form}, @samp{-forms}, @samp{-map}, @samp{-map-alist}, @samp{-mode-alist}, @samp{-program}, or @samp{-predicate} is automatically considered risky.  The variables @samp{font-lock-keywords}, @samp{font-lock-keywords} followed by a digit, and @samp{font-lock-syntactic-keywords} are also considered risky."
msgstr "名前が非@code{nil}の@code{risky-local-variable}プロパティをもつすべての変数は危険だと判断されます。@code{defcustom}を使用してユーザーオプションを定義するとき、@code{defcustom}に引数@code{:risky @var{value}}を追加することにより、ユーザーオプションに@code{risky-local-variable}プロパティをセットできます。それに加えて名前が@samp{-command}、@samp{-frame-alist}、@samp{-function}、@samp{-functions}、@samp{-hook}、@samp{-hooks}、@samp{-form}、@samp{-forms}、@samp{-map}、@samp{-map-alist}、@samp{-mode-alist}、@samp{-program}、@samp{-predicate}で終わるすべての変数は自動的に危険だと判断されます。後に数字をともなう変数@samp{font-lock-keywords}と@samp{font-lock-keywords}、さらには@samp{font-lock-syntactic-keywords}も危険だと判断されます。"

#. type: defun
#: original_texis/variables.texi:2120
#, no-wrap
msgid "risky-local-variable-p sym"
msgstr "risky-local-variable-p sym"

#. type: defun
#: original_texis/variables.texi:2123
msgid "This function returns non-@code{nil} if @var{sym} is a risky variable, based on the above criteria."
msgstr "この関数は@var{sym}が上記の条件にもとづき危険な変数なら非@code{nil}をリターンする。"

#. type: defvar
#: original_texis/variables.texi:2125
#, no-wrap
msgid "ignored-local-variables"
msgstr "ignored-local-variables"

#. type: defvar
#: original_texis/variables.texi:2129
msgid "This variable holds a list of variables that should not be given local values by files.  Any value specified for one of these variables is completely ignored."
msgstr "この変数はファイルによりローカル値を与えらるべきではない変数のリストを保持する。これらの変数に指定された任意の値は、完全に無視される。"

#. type: Plain text
#: original_texis/variables.texi:2133
msgid "The @samp{Eval:} ``variable'' is also a potential loophole, so Emacs normally asks for confirmation before handling it."
msgstr "``変数''@samp{Eval:}も抜け道になる可能性があるので、Emacsは通常はそれを処理する前に確認を求めます。"

#. type: defopt
#: original_texis/variables.texi:2134
#, no-wrap
msgid "enable-local-eval"
msgstr "enable-local-eval"

#. type: defopt
#: original_texis/variables.texi:2140
msgid "This variable controls processing of @samp{Eval:} in @samp{-*-} lines or local variables lists in files being visited.  A value of @code{t} means process them unconditionally; @code{nil} means ignore them; anything else means ask the user what to do for each file.  The default value is @code{maybe}."
msgstr "この変数は@samp{-*-}の行中、またはvisitされるファイル内のローカル変数リストにたいする、@samp{Eval:}の処理を制御する。値@code{t}は無条件に実行し、@code{nil}はそれらを無視することを意味します。それ以外なら各ファイルにたいして何を行うか、ユーザーに確認を求めることを意味する。デフォルト値は@code{maybe}。"

#. type: defopt
#: original_texis/variables.texi:2142
#, no-wrap
msgid "safe-local-eval-forms"
msgstr "safe-local-eval-forms"

#. type: defopt
#: original_texis/variables.texi:2146
msgid "This variable holds a list of expressions that are safe to evaluate when found in the @samp{Eval:} ``variable'' in a file local variables list."
msgstr "この変数はファイルローカル変数リスト内で@samp{Eval:}``変数''が見つかった際に評価しても安全な式のリストを保持する。"

#. type: Plain text
#: original_texis/variables.texi:2154
msgid "If the expression is a function call and the function has a @code{safe-local-eval-function} property, the property value determines whether the expression is safe to evaluate.  The property value can be a predicate to call to test the expression, a list of such predicates (it's safe if any predicate succeeds), or @code{t} (always safe provided the arguments are constant)."
msgstr "式が関数呼び出しであり、その関数が@code{safe-local-eval-function}プロパティをもつなら、その式の評価が安全かどうかはそのプロパティ値が決定します。プロパティ値はその式をテストするための述語(predicate)、そのような述語のリスト(成功した述語があれば安全)、または@code{t}(引数が定数である限り常に安全)を指定できます。"

#. type: Plain text
#: original_texis/variables.texi:2158
msgid "Text properties are also potential loopholes, since their values could include functions to call.  So Emacs discards all text properties from string values specified for file-local variables."
msgstr "テキストプロパティには、それらの値に関数呼び出しを含めることができるので抜け道になる可能性があります。したがってEmacsはファイルローカル変数にたいして指定された文字列値から、テキストプロパティを取り除きます。"

#. type: cindex
#: original_texis/variables.texi:2161
#, no-wrap
msgid "directory local variables"
msgstr "directory local variables"

#. type: Plain text
#: original_texis/variables.texi:2168
msgid "A directory can specify local variable values common to all files in that directory; Emacs uses these to create buffer-local bindings for those variables in buffers visiting any file in that directory.  This is useful when the files in the directory belong to some @dfn{project} and therefore share the same local variables."
msgstr "ディレクトリーは、そのディレクトリー内のすべてのファイルに共通なローカル変数値を指定することができます。Emacsはそのディレクトリー内の任意のファイルをvisitしているバッファー内で、それらの変数にたいするバッファーローカルなバインディングを作成するためにこれを使用します。これはそのディレクトリー内のファイルが何らかの@dfn{プロジェクト}に属していて、同じローカル変数を共有するときなどに有用です。"

#. type: Plain text
#: original_texis/variables.texi:2172
msgid "There are two different methods for specifying directory local variables: by putting them in a special file, or by defining a @dfn{project class} for that directory."
msgstr "ディレクトリーローカル変数を指定するために2つの異なる方法があります: 1つは特別なファイルにそれを記述する方法、もう1つはそのディレクトリーに@dfn{プロジェクトクラス(project class)}を定義する方法です。"

#. type: defvr
#: original_texis/variables.texi:2173
#, no-wrap
msgid "Constant dir-locals-file"
msgstr "Constant dir-locals-file"

#. type: defvr
#: original_texis/variables.texi:2193
msgid "This constant is the name of the file where Emacs expects to find the directory-local variables.  The name of the file is @file{.dir-locals.el}@footnote{ The MS-DOS version of Emacs uses @file{_dir-locals.el} instead, due to limitations of the DOS filesystems.  }.  A file by that name in a directory causes Emacs to apply its settings to any file in that directory or any of its subdirectories (optionally, you can exclude subdirectories; see below).  If some of the subdirectories have their own @file{.dir-locals.el} files, Emacs uses the settings from the deepest file it finds starting from the file's directory and moving up the directory tree.  This constant is also used to derive the name of a second dir-locals file @file{.dir-locals-2.el}.  If this second dir-locals file is present, then that is loaded in addition to @file{.dir-locals.el}.  This is useful when @file{.dir-locals.el} is under version control in a shared repository and cannot be used for personal customizations.  The file specifies local variables as a specially formatted list; see @ref{Directory Variables, , Per-directory Local Variables, emacs, The GNU Emacs Manual}, for more details."
msgstr "この定数はEmacsがディレクトリーローカル変数を見つけることができると期待するファイルの名前。ファイル名は@file{.dir-locals.el}@footnote{MS-DOS版のEmacsはDOSファイルシステムの制限により、かわりに@file{_dir-locals.el}という名前を使用します。}。ディレクトリー内でその名前をもつファイルによりEmacsはディレクトリー内の任意のファイル、または任意のサブディレクトリー(オプションでサブディレクトリーを除外できる。以下参照し)にセッティングを適用する。独自に@file{.dir-locals.el}をもつサブディレクトリーがある場合には、Emacsはサブディレクトリーで見つかったもっとも深いファイルのディレクトリーからディレクトリーツリーを上方に移動しながら、もっとも深いファイルのセッティングを使用する。この定数は2番目のdir-localsファイル@file{.dir-locals-2.el}の名前を導出するためにも使用される。この2番目のdir-localsファイルが与えられた場合には、そのファイルが@file{.dir-locals.el}に加えてロードされる。これは@file{.dir-locals.el}がバージョンコントロールの共有レポジトリの配下にあって個人のカスタマイズ用に使用できないときに有用。このファイルはローカル変数をフォーマットされたリストとして指定する。詳細は@ref{Directory Variables, , Per-directory Local Variables, emacs, The GNU Emacs Manual}を参照のこと。"

#. type: defun
#: original_texis/variables.texi:2195
#, no-wrap
msgid "hack-dir-local-variables"
msgstr "hack-dir-local-variables"

#. type: defun
#: original_texis/variables.texi:2204
msgid "This function reads the @code{.dir-locals.el} file and stores the directory-local variables in @code{file-local-variables-alist} that is local to the buffer visiting any file in the directory, without applying them.  It also stores the directory-local settings in @code{dir-locals-class-alist}, where it defines a special class for the directory in which @file{.dir-locals.el} file was found.  This function works by calling @code{dir-locals-set-class-variables} and @code{dir-locals-set-directory-class}, described below."
msgstr "この関数は@code{.dir-locals.el}ファイルを読み込み、そのディレクトリー内の任意のファイルをvisitしているバッファーにローカルな@code{file-local-variables-alist}内に、それらを適用することなくディレクトリーローカル変数を格納する。この関数はディレクトリーローカルなセッティングも@code{dir-locals-class-alist}(@file{.dir-locals.el}ファイルが見つかったディレクトリーにたいする特別なクラスを定義する)内に格納する。この関数は以下で説明するように、@code{dir-locals-set-class-variables}と@code{dir-locals-set-directory-class}を呼び出すことにより機能する。"

#. type: defun
#: original_texis/variables.texi:2206
#, no-wrap
msgid "hack-dir-local-variables-non-file-buffer"
msgstr "hack-dir-local-variables-non-file-buffer"

#. type: defun
#: original_texis/variables.texi:2213
msgid "This function looks for directory-local variables, and immediately applies them in the current buffer.  It is intended to be called in the mode commands for non-file buffers, such as Dired buffers, to let them obey directory-local variable settings.  For non-file buffers, Emacs looks for directory-local variables in @code{default-directory} and its parent directories."
msgstr "この関数はディレクトリーローカル変数を探して、即座にそれらをカレントバッファーに適用する。これはDiredバッファーのような、非ファイルバッファーをディレクトリーローカル変数のセッティングにしたがわせるために、モードコマンド呼び出しの中から呼び出されることを意図したものである。非ファイルバッファーにたいしては、Emacsは@code{default-directory}とその親ディレクトリーの中から、ディレクトリーローカル変数を探す。"

#. type: defun
#: original_texis/variables.texi:2215
#, no-wrap
msgid "dir-locals-set-class-variables class variables"
msgstr "dir-locals-set-class-variables class variables"

#. type: defun
#: original_texis/variables.texi:2230
msgid "This function defines a set of variable settings for the named @var{class}, which is a symbol.  You can later assign the class to one or more directories, and Emacs will apply those variable settings to all files in those directories.  The list in @var{variables} can be of one of the two forms: @code{(@var{major-mode} . @var{alist})} or @code{(@var{directory} . @var{list})}.  With the first form, if the file's buffer turns on a mode that is derived from @var{major-mode}, then all the variables in the associated @var{alist} are applied; @var{alist} should be of the form @code{(@var{name} . @var{value})}.  A special value @code{nil} for @var{major-mode} means the settings are applicable to any mode.  In @var{alist}, you can use a special @var{name}: @code{subdirs}.  If the associated value is @code{nil}, the alist is only applied to files in the relevant directory, not to those in any subdirectories."
msgstr "この関数は@var{class}という名前がつけられたシンボルにたいして一連の変数セッティングを定義する。その後はこのクラスを1つ以上のディレクトリーに割り当てることができるので、Emacsはこれらの変数セッティングをディレクトリー内のすべてのファイルに適用する。@var{variables}内のリストは2つの形式 --- @code{(@var{major-mode} . @var{alist})}、または@code{(@var{directory} . @var{list})} --- のうちのいずれかをもつことができる。1番目の形式ではそのファイルのバッファーが@var{major-mode}を継承するモードに切り替わるときに、連想リスト@var{alist}内のすべての変数が適用される。@var{alist}は@code{(@var{name} . @var{value})}という形式。@var{major-mode}にたいする特別な値@code{nil}は、そのセッティングが任意のモードに適用できることを意味する。@var{alist}内では特別な@var{name}として@code{subdirs}を使用することができる。連想値が@code{nil}ならalistは関連するディレクトリー内のファイルだけに適用されて、それらのサブディレクトリーには適用されない。"

#. type: defun
#: original_texis/variables.texi:2235
msgid "With the second form of @var{variables}, if @var{directory} is the initial substring of the file's directory, then @var{list} is applied recursively by following the above rules; @var{list} should be of one of the two forms accepted by this function in @var{variables}."
msgstr "@var{variables}の2番目の形式では、@var{directory}がそのファイルのディレクトリーの最初のサブディレクトリーなら、上記のルールにしたがい@var{list}が再帰的に適用される。@var{list}はこの関数の@var{variables}で指定できる2つの形式のうち1つを指定する。"

#. type: defun
#: original_texis/variables.texi:2237
#, no-wrap
msgid "dir-locals-set-directory-class directory class &optional mtime"
msgstr "dir-locals-set-directory-class directory class &optional mtime"

#. type: defun
#: original_texis/variables.texi:2243
msgid "This function assigns @var{class} to all the files in @code{directory} and its subdirectories.  Thereafter, all the variable settings specified for @var{class} will be applied to any visited file in @var{directory} and its children.  @var{class} must have been already defined by @code{dir-locals-set-class-variables}."
msgstr "この関数は@code{directory}とサブディレクトリー内のすべてのファイルに@var{class}を割り当てる。その後、@var{class}にたいして指定されたすべての変数セッティングは、@var{directory}とその子ディレクトリー内でvisitされたすべてのファイルに適用される。@var{class}は事前に@code{dir-locals-set-class-variables}で定義されていなければならない。"

#. type: defun
#: original_texis/variables.texi:2250
msgid "Emacs uses this function internally when it loads directory variables from a @code{.dir-locals.el} file.  In that case, the optional argument @var{mtime} holds the file modification time (as returned by @code{file-attributes}).  Emacs uses this time to check stored local variables are still valid.  If you are assigning a class directly, not via a file, this argument should be @code{nil}."
msgstr "Emacsが@code{.dir-locals.el}ファイルからディレクトリー変数をロードする際、内部的にこの関数を使用する。その場合、オプションの引数@var{mtime}はファイルの修正日時(modification time。@code{file-attributes}によりリターンされる)を保持する。Emacsは記憶されたローカル変数がまだ有効化チェックするために、この日時を使用する。ファイルを介さず直接クラスを割り当てる場合、この引数は@code{nil}になる。"

#. type: defvar
#: original_texis/variables.texi:2252
#, no-wrap
msgid "dir-locals-class-alist"
msgstr "dir-locals-class-alist"

#. type: defvar
#: original_texis/variables.texi:2255
msgid "This alist holds the class symbols and the associated variable settings.  It is updated by @code{dir-locals-set-class-variables}."
msgstr "このalistはクラスシンボル(class symbol)とそれに関連づけられる変数のセッティングを保持する。これは@code{dir-locals-set-class-variables}により更新される。"

#. type: defvar
#: original_texis/variables.texi:2257
#, no-wrap
msgid "dir-locals-directory-cache"
msgstr "dir-locals-directory-cache"

#. type: defvar
#: original_texis/variables.texi:2262
msgid "This alist holds directory names, their assigned class names, and modification times of the associated directory local variables file (if there is one).  The function @code{dir-locals-set-directory-class} updates this list."
msgstr "このalistはディレクトリー名、それらに割り当てられたクラス名、およびこのエントリーに関連するディレクトリーローカル変数ファイルの修正日時を保持する。関数@code{dir-locals-set-directory-class}はこのlistを更新する。"

#. type: defvar
#: original_texis/variables.texi:2264
#, no-wrap
msgid "enable-dir-local-variables"
msgstr "enable-dir-local-variables"

#. type: defvar
#: original_texis/variables.texi:2268
msgid "If @code{nil}, directory-local variables are ignored.  This variable may be useful for modes that want to ignore directory-locals while still respecting file-local variables (@pxref{File Local Variables})."
msgstr "@code{nil}ならディレクトリーローカル変数は無視される。この変数はファイルローカル変数(@ref{File Local Variables}を参照)にはしたがうが、ディレクトリーローカル変数は無視したいモードにたいして有用かもしれない。"

#. type: cindex
#: original_texis/variables.texi:2272
#, no-wrap
msgid "connection local variables"
msgstr "connection local variables"

#. type: Plain text
#: original_texis/variables.texi:2278
msgid "Connection-local variables provide a general mechanism for different variable settings in buffers with a remote connection (@pxref{Remote Files,, Remote Files, emacs, The GNU Emacs Manual}).  They are bound and set depending on the remote connection a buffer is dedicated to."
msgstr "接続ローカル変数(connection-local variable)はリモート接続をもつバッファーにおいて、異なる変数セッティングにたいする汎用のメカニズムを提供します(@ref{Remote Files,, Remote Files, emacs, The GNU Emacs Manual}を参照)。これはそのリモート接続に専用のバッファーに応じてバインドおよびセットされる変数です。"

#. type: subsection
#: original_texis/variables.texi:2284 original_texis/variables.texi:2286
#: original_texis/variables.texi:2287
#, no-wrap
msgid "Connection Local Profiles"
msgstr "Connection Local Profiles"

#. type: menuentry
#: original_texis/variables.texi:2284
msgid "Storing variable settings to apply to connections."
msgstr "接続に適用する変数セッティングの保存。"

#. type: subsection
#: original_texis/variables.texi:2284 original_texis/variables.texi:2409
#: original_texis/variables.texi:2410
#, no-wrap
msgid "Applying Connection Local Variables"
msgstr "Applying Connection Local Variables"

#. type: menuentry
#: original_texis/variables.texi:2284
msgid "Using connection-local values in your code."
msgstr "コード内での接続ローカル変数の使用。"

#. type: cindex
#: original_texis/variables.texi:2288
#, no-wrap
msgid "connection local profiles"
msgstr "connection local profiles"

#. type: Plain text
#: original_texis/variables.texi:2294
msgid "Emacs uses connection-local profiles to store the variable settings to apply to particular connections.  You can then associate these with remote connections by defining the criteria when they should apply, using @code{connection-local-set-profiles}."
msgstr "接続ローカルプロファイルとは、特定の接続にたいして適用する変数のセッティングを保存するためにEmacsが使用するプロファイルのことです。@code{connection-local-set-profiles}を使用してプロファイルを適用すべき条件を定義することで、プロファイルとリモート接続を関連付けることができます。"

#. type: defun
#: original_texis/variables.texi:2295
#, no-wrap
msgid "connection-local-set-profile-variables profile variables"
msgstr "connection-local-set-profile-variables profile variables"

#. type: defun
#: original_texis/variables.texi:2302
msgid "This function defines a set of variable settings for the connection @var{profile}, which is a symbol.  You can later assign the connection profile to one or more remote connections, and Emacs will apply those variable settings to all process buffers for those connections.  The list in @var{variables} is an alist of the form @code{(@var{name}@tie{}.@tie{}@var{value})}.  Example:"
msgstr "この関数は接続@var{profile} (シンボル)にたいする一連の変数セッティングを定義する。この接続プロファイルに後から1つ以上のリモート接続を割り当てることができ、Emacsはそれらの接続にたいするすべてのプロセスバッファーにそれらの変数セッティングを適用するだろう。@var{variables}内のリストは@code{(@var{name}@tie{}.@tie{}@var{value})}という形式のalist。たとえば:"

#. type: group
#: original_texis/variables.texi:2311
#, no-wrap
msgid ""
"(connection-local-set-profile-variables\n"
"  'remote-bash\n"
"  '((shell-file-name . \"/bin/bash\")\n"
"    (shell-command-switch . \"-c\")\n"
"    (shell-interactive-switch . \"-i\")\n"
"    (shell-login-switch . \"-l\")))\n"
msgstr ""
"(connection-local-set-profile-variables\n"
"  'remote-bash\n"
"  '((shell-file-name . \"/bin/bash\")\n"
"    (shell-command-switch . \"-c\")\n"
"    (shell-interactive-switch . \"-i\")\n"
"    (shell-login-switch . \"-l\")))\n"

#. type: group
#: original_texis/variables.texi:2320
#, no-wrap
msgid ""
"(connection-local-set-profile-variables\n"
"  'remote-ksh\n"
"  '((shell-file-name . \"/bin/ksh\")\n"
"    (shell-command-switch . \"-c\")\n"
"    (shell-interactive-switch . \"-i\")\n"
"    (shell-login-switch . \"-l\")))\n"
msgstr ""
"(connection-local-set-profile-variables\n"
"  'remote-ksh\n"
"  '((shell-file-name . \"/bin/ksh\")\n"
"    (shell-command-switch . \"-c\")\n"
"    (shell-interactive-switch . \"-i\")\n"
"    (shell-login-switch . \"-l\")))\n"

#. type: group
#: original_texis/variables.texi:2326
#, no-wrap
msgid ""
"(connection-local-set-profile-variables\n"
"  'remote-null-device\n"
"  '((null-device . \"/dev/null\")))\n"
msgstr ""
"(connection-local-set-profile-variables\n"
"  'remote-null-device\n"
"  '((null-device . \"/dev/null\")))\n"

#. type: findex
#: original_texis/variables.texi:2329
#, no-wrap
msgid "connection-local-get-profile-variables"
msgstr "connection-local-get-profile-variables"

#. type: defun
#: original_texis/variables.texi:2333
msgid "If you want to append variable settings to an existing profile, you could use the function @code{connection-local-get-profile-variables} in order to retrieve the existing settings, like"
msgstr "既存のプロファイルにたいして変数セッティングを追加したい場合には、以下のように関数@code{connection-local-get-profile-variables}を使って既存のセッティングを取得できる"

#. type: group
#: original_texis/variables.texi:2341
#, no-wrap
msgid ""
"(connection-local-set-profile-variables\n"
"  'remote-bash\n"
"  (append\n"
"   (connection-local-get-profile-variables 'remote-bash)\n"
"   '((shell-command-dont-erase-buffer . t))))\n"
msgstr ""
"(connection-local-set-profile-variables\n"
"  'remote-bash\n"
"  (append\n"
"   (connection-local-get-profile-variables 'remote-bash)\n"
"   '((shell-command-dont-erase-buffer . t))))\n"

#. type: deffn
#: original_texis/variables.texi:2345
#, no-wrap
msgid "{User Option} connection-local-profile-alist"
msgstr "{User Option} connection-local-profile-alist"

#. type: deffn
#: original_texis/variables.texi:2349
msgid "This alist holds the connection profile symbols and the associated variable settings.  It is updated by @code{connection-local-set-profile-variables}."
msgstr "このalistは接続プロファイルシンボルと連想変数セッティングを保持する。これは@code{connection-local-set-profile-variables}により更新される。"

#. type: defun
#: original_texis/variables.texi:2351
#, no-wrap
msgid "connection-local-set-profiles criteria &rest profiles"
msgstr "connection-local-set-profiles criteria &rest profiles"

#. type: defun
#: original_texis/variables.texi:2360
msgid "This function assigns @var{profiles}, which are symbols, to all remote connections identified by @var{criteria}.  @var{criteria} is a plist identifying a connection and the application using this connection.  Property names might be @code{:application}, @code{:protocol}, @code{:user} and @code{:machine}.  The property value of @code{:application} is a symbol, all other property values are strings.  All properties are optional; if @var{criteria} is @code{nil}, it always applies.  Example:"
msgstr "この関数は@var{criteria}で識別されるすべてのリモート接続に@var{profiles} (シンボル)を割り当てる。@var{criteria}は接続を識別するplistであり、アプリケーションはその接続を使用する。プロパティ名は@code{:application}、@code{:protocol}、@code{:user}、@code{:machine}のいずれか。@code{:application}のプロパティ値はシンボル、それ以外のプロパティ値は文字列。プロパティはすべてオプション。@var{criteria}が@code{nil}なら常に適用される。たとえば:"

#. type: group
#: original_texis/variables.texi:2366
#, no-wrap
msgid ""
"(connection-local-set-profiles\n"
"  '(:application tramp :protocol \"ssh\" :machine \"localhost\")\n"
"  'remote-bash 'remote-null-device)\n"
msgstr ""
"(connection-local-set-profiles\n"
"  '(:application tramp :protocol \"ssh\" :machine \"localhost\")\n"
"  'remote-bash 'remote-null-device)\n"

#. type: group
#: original_texis/variables.texi:2373
#, no-wrap
msgid ""
"(connection-local-set-profiles\n"
"  '(:application tramp :protocol \"sudo\"\n"
"    :user \"root\" :machine \"localhost\")\n"
"  'remote-ksh 'remote-null-device)\n"
msgstr ""
"(connection-local-set-profiles\n"
"  '(:application tramp :protocol \"sudo\"\n"
"    :user \"root\" :machine \"localhost\")\n"
"  'remote-ksh 'remote-null-device)\n"

#. type: defun
#: original_texis/variables.texi:2378
msgid "If @var{criteria} is @code{nil}, it applies for all remote connections.  Therefore, the example above would be equivalent to"
msgstr "@var{criteria}が@code{nil}ならすべてのリモート接続に適用される。したがって上記の例は以下と等価"

#. type: group
#: original_texis/variables.texi:2384
#, no-wrap
msgid ""
"(connection-local-set-profiles\n"
"  '(:application tramp :protocol \"ssh\" :machine \"localhost\")\n"
"  'remote-bash)\n"
msgstr ""
"(connection-local-set-profiles\n"
"  '(:application tramp :protocol \"ssh\" :machine \"localhost\")\n"
"  'remote-bash)\n"

#. type: group
#: original_texis/variables.texi:2391
#, no-wrap
msgid ""
"(connection-local-set-profiles\n"
"  '(:application tramp :protocol \"sudo\"\n"
"    :user \"root\" :machine \"localhost\")\n"
"  'remote-ksh)\n"
msgstr ""
"(connection-local-set-profiles\n"
"  '(:application tramp :protocol \"sudo\"\n"
"    :user \"root\" :machine \"localhost\")\n"
"  'remote-ksh)\n"

#. type: group
#: original_texis/variables.texi:2396
#, no-wrap
msgid ""
"(connection-local-set-profiles\n"
"  nil 'remote-null-device)\n"
msgstr ""
"(connection-local-set-profiles\n"
"  nil 'remote-null-device)\n"

#. type: defun
#: original_texis/variables.texi:2401
msgid "Any connection profile of @var{profiles} must have been already defined by @code{connection-local-set-profile-variables}."
msgstr "@var{profiles}のすべてのプロファイルは@code{connection-local-set-profile-variables}で定義済みでなければならない。"

#. type: deffn
#: original_texis/variables.texi:2403
#, no-wrap
msgid "{User Option} connection-local-criteria-alist"
msgstr "{User Option} connection-local-criteria-alist"

#. type: deffn
#: original_texis/variables.texi:2407
msgid "This alist contains connection criteria and their assigned profile names.  The function @code{connection-local-set-profiles} updates this list."
msgstr "このalistは接続のcriteria(判断基準)それに割り当てられたとprofileの名前を含む。関数@code{connection-local-set-profiles}はこのリストを更新する。"

#. type: cindex
#: original_texis/variables.texi:2411
#, no-wrap
msgid "connection local variables, applying"
msgstr "connection local variables, applying"

#. type: Plain text
#: original_texis/variables.texi:2416
msgid "When writing connection-aware code, you'll need to collect, and possibly apply, any connection-local variables.  There are several ways to do this, as described below."
msgstr "接続を認識するコードの記述時には接続ローカル変数を収集して、もしかしたらそれらを適用する必要があるでしょう。これを行うには以下のようにいくつかの方法があります。"

#. type: defun
#: original_texis/variables.texi:2417
#, no-wrap
msgid "hack-connection-local-variables criteria"
msgstr "hack-connection-local-variables criteria"

#. type: defun
#: original_texis/variables.texi:2422
msgid "This function collects applicable connection-local variables associated with @var{criteria} in @code{connection-local-variables-alist}, without applying them.  Example:"
msgstr "この関数は@code{connection-local-variables-alist}内の@var{criteria}に関連する適用可能な接続ローカル変数を適用することなく収集する。たとえば:"

#. type: group
#: original_texis/variables.texi:2427
#, no-wrap
msgid ""
"(hack-connection-local-variables\n"
"  '(:application tramp :protocol \"ssh\" :machine \"localhost\"))\n"
msgstr ""
"(hack-connection-local-variables\n"
"  '(:application tramp :protocol \"ssh\" :machine \"localhost\"))\n"

#. type: group
#: original_texis/variables.texi:2436
#, no-wrap
msgid ""
"connection-local-variables-alist\n"
"     @result{} ((null-device . \"/dev/null\")\n"
"        (shell-login-switch . \"-l\")\n"
"        (shell-interactive-switch . \"-i\")\n"
"        (shell-command-switch . \"-c\")\n"
"        (shell-file-name . \"/bin/bash\"))\n"
msgstr ""
"connection-local-variables-alist\n"
"     @result{} ((null-device . \"/dev/null\")\n"
"        (shell-login-switch . \"-l\")\n"
"        (shell-interactive-switch . \"-i\")\n"
"        (shell-command-switch . \"-c\")\n"
"        (shell-file-name . \"/bin/bash\"))\n"

#. type: defun
#: original_texis/variables.texi:2440
#, no-wrap
msgid "hack-connection-local-variables-apply criteria"
msgstr "hack-connection-local-variables-apply criteria"

#. type: defun
#: original_texis/variables.texi:2443
msgid "This function looks for connection-local variables according to @var{criteria}, and immediately applies them in the current buffer."
msgstr "この関数は@var{criteria}に対応する接続ローカル変数を探してカレントバッファーに即座に適用する。"

#. type: defmac
#: original_texis/variables.texi:2445
#, no-wrap
msgid "with-connection-local-application-variables application &rest body"
msgstr "with-connection-local-application-variables application &rest body"

#. type: defmac
#: original_texis/variables.texi:2448
msgid "Apply all connection-local variables for @code{application}, which are specified by @code{default-directory}."
msgstr "@code{default-directory}によって指定されるすべての接続ローカル変数を@code{application}に適用する。"

#. type: defmac
#: original_texis/variables.texi:2451
msgid "After that, @var{body} is executed, and the connection-local variables are unwound.  Example:"
msgstr "その後に@var{body}を実行して接続ローカル変数を非バインド化する。たとえば:"

#. type: group
#: original_texis/variables.texi:2458
#, no-wrap
msgid ""
"(connection-local-set-profile-variables\n"
"  'my-remote-perl\n"
"  '((perl-command-name . \"/usr/local/bin/perl5\")\n"
"    (perl-command-switch . \"-e %s\")))\n"
msgstr ""
"(connection-local-set-profile-variables\n"
"  'my-remote-perl\n"
"  '((perl-command-name . \"/usr/local/bin/perl5\")\n"
"    (perl-command-switch . \"-e %s\")))\n"

#. type: group
#: original_texis/variables.texi:2464
#, no-wrap
msgid ""
"(connection-local-set-profiles\n"
"  '(:application my-app :protocol \"ssh\" :machine \"remotehost\")\n"
"  'my-remote-perl)\n"
msgstr ""
"(connection-local-set-profiles\n"
"  '(:application my-app :protocol \"ssh\" :machine \"remotehost\")\n"
"  'my-remote-perl)\n"

#. type: group
#: original_texis/variables.texi:2470
#, no-wrap
msgid ""
"(let ((default-directory \"/ssh:remotehost:/working/dir/\"))\n"
"  (with-connection-local-application-variables 'my-app\n"
"    do something useful))\n"
msgstr ""
"(let ((default-directory \"/ssh:remotehost:/working/dir/\"))\n"
"  (with-connection-local-application-variables 'my-app\n"
"    do something useful))\n"

#. type: defvar
#: original_texis/variables.texi:2474
#, no-wrap
msgid "connection-local-default-application"
msgstr "connection-local-default-application"

#. type: defvar
#: original_texis/variables.texi:2479
msgid "The default application, a symbol, to be applied in @code{with-connection-local-variables}.  It defaults to @code{tramp}, but you can let-bind it to change the application temporarily (@pxref{Local Variables})."
msgstr "@code{with-connection-local-variables}が適用されるデフォルトのアプリケーション(シンボル)。デフォルトは@code{tramp}だが、letバインドによって一時的にアプリケーションを変更できる(@ref{Local Variables}を参照)。"

#. type: defvar
#: original_texis/variables.texi:2481 original_texis/variables.texi:2532
msgid "This variable must not be changed globally."
msgstr "この変数をグローバルに変更してはならない。"

#. type: defmac
#: original_texis/variables.texi:2483
#, no-wrap
msgid "with-connection-local-variables &rest body"
msgstr "with-connection-local-variables &rest body"

#. type: defmac
#: original_texis/variables.texi:2487
msgid "This is equivalent to @code{with-connection-local-application-variables}, but uses @code{connection-local-default-application} for the application."
msgstr "これは@code{with-connection-local-application-variables}と同じだが、そのアプリケーションにたいして@code{connection-local-default-application}を使用する。"

#. type: defmac
#: original_texis/variables.texi:2489
#, no-wrap
msgid "setq-connection-local [symbol form]@dots{}"
msgstr "setq-connection-local [symbol form]@dots{}"

#. type: defmac
#: original_texis/variables.texi:2495
msgid "This macro sets each @var{symbol} connection-locally to the result of evaluating the corresponding @var{form}, using the connection-local profile specified in @code{connection-local-profile-name-for-setq}; if the profile name is @code{nil}, this macro will just set the variables normally, as with @code{setq} (@pxref{Setting Variables})."
msgstr "このマクロは@code{connection-local-profile-name-for-setq}で指定された接続ローカルプロファイルを用いて、それぞれの@var{symbol}を対応する@var{form}を評価した結果に接続ローカルでバインドする。接続ローカルプロファイルの名前が@code{nil}の場合には、このマクロは@code{setq}が行うような通常の方法によって変数をセットする(@ref{Setting Variables}を参照)。"

#. type: defmac
#: original_texis/variables.texi:2500
msgid "For example, you can use this macro in combination with @code{with-connection-local-variables} or @code{with-connection-local-application-variables} to lazily initialize connection-local settings:"
msgstr "たとえば接続ローカルなセッティングの初期化を遅延させるには、このマクロを以下のように@code{with-connection-local-variables}や@code{with-connection-local-application-variables}と組み合わせて使用する:"

#. type: group
#: original_texis/variables.texi:2504
#, no-wrap
msgid ""
"(defvar my-app-variable nil)\n"
"\n"
msgstr ""
"(defvar my-app-variable nil)\n"
"\n"

#. type: group
#: original_texis/variables.texi:2508
#, no-wrap
msgid ""
"(connection-local-set-profile-variables\n"
" 'my-app-connection-default-profile\n"
" '((my-app-variable . nil)))\n"
"\n"
msgstr ""
"(connection-local-set-profile-variables\n"
" 'my-app-connection-default-profile\n"
" '((my-app-variable . nil)))\n"
"\n"

#. type: group
#: original_texis/variables.texi:2512
#, no-wrap
msgid ""
"(connection-local-set-profiles\n"
" '(:application my-app)\n"
" 'my-app-connection-default-profile)\n"
msgstr ""
"(connection-local-set-profiles\n"
" '(:application my-app)\n"
" 'my-app-connection-default-profile)\n"

#. type: group
#: original_texis/variables.texi:2520
#, no-wrap
msgid ""
"(defun my-app-get-variable ()\n"
"  (with-connection-local-application-variables 'my-app\n"
"    (or my-app-variable\n"
"        (setq-connection-local my-app-variable\n"
"                               do something useful))))\n"
msgstr ""
"(defun my-app-get-variable ()\n"
"  (with-connection-local-application-variables 'my-app\n"
"    (or my-app-variable\n"
"        (setq-connection-local my-app-variable\n"
"                               do something useful))))\n"

#. type: defvar
#: original_texis/variables.texi:2524
#, no-wrap
msgid "connection-local-profile-name-for-setq"
msgstr "connection-local-profile-name-for-setq"

#. type: defvar
#: original_texis/variables.texi:2530
msgid "The connection-local profile name, a symbol, to use when setting variables via @code{setq-connection-local}.  This is let-bound in the body of @code{with-connection-local-variables}, but you can also let-bind it yourself if you'd like to set variables on a different profile."
msgstr "@code{setq-connection-local}を通じて変数をセットする際に使用する接続ローカルプロファイル名(シンボル)。これは@code{with-connection-local-variables}のbody内でletバインドされているが、別のプロファイルで変数をセットしたければ自分でletバインドすることもできる。"

#. type: defvar
#: original_texis/variables.texi:2534
#, no-wrap
msgid "enable-connection-local-variables"
msgstr "enable-connection-local-variables"

#. type: defvar
#: original_texis/variables.texi:2537
msgid "If @code{nil}, connection-local variables are ignored.  This variable shall be changed temporarily only in special modes."
msgstr "@code{nil}なら接続ローカル変数を無視する。この変数は特殊なモード内でのみ一時的に変更されるべきである。"

#. type: cindex
#: original_texis/variables.texi:2541
#, no-wrap
msgid "variable aliases"
msgstr "variable aliases"

#. type: cindex
#: original_texis/variables.texi:2542
#, no-wrap
msgid "alias, for variables"
msgstr "alias, for variables"

#. type: Plain text
#: original_texis/variables.texi:2551
msgid "It is sometimes useful to make two variables synonyms, so that both variables always have the same value, and changing either one also changes the other.  Whenever you change the name of a variable---either because you realize its old name was not well chosen, or because its meaning has partly changed---it can be useful to keep the old name as an @emph{alias} of the new one for compatibility.  You can do this with @code{defvaralias}."
msgstr "2つの変数をシノニム(同義語)にすれば、2つの変数は常に同じ値をもち、どちらか一方を変更するともう一方も変更されるようになり、便利なときがあります。変数の名前を変更  --- 古い名前はよく考慮して選択されたものではなかったとか、変数の意味が部分的に変更された等の理由で --- するとき、互換性のために新しい名前の@emph{エイリアス(alias)}として古い名前を維持できれば便利なときがあるかもしれません。@code{defvaralias}によってこれを行うことができます。"

#. type: defun
#: original_texis/variables.texi:2552
#, no-wrap
msgid "defvaralias new-alias base-variable &optional docstring"
msgstr "defvaralias new-alias base-variable &optional docstring"

#. type: defun
#: original_texis/variables.texi:2559
msgid "This function defines the symbol @var{new-alias} as a variable alias for symbol @var{base-variable}. This means that retrieving the value of @var{new-alias} returns the value of @var{base-variable}, and changing the value of @var{new-alias} changes the value of @var{base-variable}.  The two aliased variable names always share the same value and the same bindings."
msgstr "この関数はシンボル@var{base-variable}のエイリアスとして、シンボル@var{new-alias}を定義する。これは@var{new-alias}から値を取得すると@var{base-variable}の値がリターンされ、@var{new-alias}の値を変更すると@var{base-variable}の値が変更されることを意味する。エイリアスされた2つの変数名は、常に同じ値と同じバインディングを共有する。"

#. type: defun
#: original_texis/variables.texi:2565
msgid "If the @var{docstring} argument is non-@code{nil}, it specifies the documentation for @var{new-alias}; otherwise, the alias gets the same documentation as @var{base-variable} has, if any, unless @var{base-variable} is itself an alias, in which case @var{new-alias} gets the documentation of the variable at the end of the chain of aliases."
msgstr "@var{docstring}引数が非@code{nil}なら、それは@var{new-alias}のドキュメント文字列を指定する。それ以外なら、エイリアスは(もしあれば)@var{base-variable}と同じドキュメント文字列となる。ただしそれは@var{base-variable}自体がエイリアスではない場合で、エイリアスなら@var{new-alias}はエイリアスチェーンの最後の変数のドキュメント文字列になる。"

#. type: defun
#: original_texis/variables.texi:2567
msgid "This function returns @var{base-variable}."
msgstr "この関数は@var{base-variable}をリターンする。"

#. type: Plain text
#: original_texis/variables.texi:2573
msgid "Variable aliases are convenient for replacing an old name for a variable with a new name.  @code{make-obsolete-variable} declares that the old name is obsolete and therefore that it may be removed at some stage in the future."
msgstr "変数のエイリアスは、変数にたいする古い名前を新しい名前に置き換える便利な方法です。@code{make-obsolete-variable}は古い名前を陳腐化(obsolete)していると宣言して。それが将来のある時点で削除されるかもしれないことを宣言します。"

#. type: defun
#: original_texis/variables.texi:2574
#, no-wrap
msgid "make-obsolete-variable obsolete-name current-name when &optional access-type"
msgstr "make-obsolete-variable obsolete-name current-name when &optional access-type"

#. type: defun
#: original_texis/variables.texi:2583
msgid "This function makes the byte compiler warn that the variable @var{obsolete-name} is obsolete.  If @var{current-name} is a symbol, it is the variable's new name; then the warning message says to use @var{current-name} instead of @var{obsolete-name}.  If @var{current-name} is a string, this is the message and there is no replacement variable.  @var{when} should be a string indicating when the variable was first made obsolete (usually a version number string)."
msgstr "この関数はバイトコンパイラーに変数@var{obsolete-name}が陳腐化していると警告させる。@var{current-name}がシンボルなら、それはこの変数の新たな名前である。警告メッセージはその後、@var{obsolete-name}のかわりに@var{current-name}を使用するよう告げるようになる。@var{current-name}が文字列なら、それはメッセージであり、置き換えられる変数はない。@var{when}はその変数が最初に陳腐化するのがいつかを示す文字列(通常はバージョン番号文字列)。"

#. type: defun
#: original_texis/variables.texi:2587
msgid "The optional argument @var{access-type}, if non-@code{nil}, should specify the kind of access that will trigger obsolescence warnings; it can be either @code{get} or @code{set}."
msgstr "オプションの引数@var{access-type}が非@code{nil}なら、それは陳腐化の警告を引き起こすアクセスの種類を指定すること。@code{get}か@code{set}を指定できる。"

#. type: Plain text
#: original_texis/variables.texi:2591
msgid "You can make two variables synonyms and declare one obsolete at the same time using the macro @code{define-obsolete-variable-alias}."
msgstr "2つの変数シノニムを作成してマクロ@code{define-obsolete-variable-alias}を使用することにより、1つが陳腐化していると同時に宣言できます。"

#. type: defmac
#: original_texis/variables.texi:2592
#, no-wrap
msgid "define-obsolete-variable-alias obsolete-name current-name when &optional docstring"
msgstr "define-obsolete-variable-alias obsolete-name current-name when &optional docstring"

#. type: defmac
#: original_texis/variables.texi:2596
msgid "This macro marks the variable @var{obsolete-name} as obsolete and also makes it an alias for the variable @var{current-name}.  It is equivalent to the following:"
msgstr "このマクロは変数@var{obsolete-name}が陳腐化しているとマークして、それを変数@var{current-name}にたいするエイリアスにする。これは以下と等価である:"

#. type: example
#: original_texis/variables.texi:2600
#, no-wrap
msgid ""
"(defvaralias @var{obsolete-name} @var{current-name} @var{docstring})\n"
"(make-obsolete-variable @var{obsolete-name} @var{current-name} @var{when})\n"
msgstr ""
"(defvaralias @var{obsolete-name} @var{current-name} @var{docstring})\n"
"(make-obsolete-variable @var{obsolete-name} @var{current-name} @var{when})\n"

#. type: defmac
#: original_texis/variables.texi:2605
msgid "This macro evaluates all its parameters, and both @var{obsolete-name} and @var{current-name} should be symbols, so a typical usage would look like:"
msgstr "このマクロはすべてのパラメーターを評価する。@var{obsolete-name}と@var{current-name}はいずれもシンボルのはずなので、通常は以下のような使用方法になる:"

#. type: lisp
#: original_texis/variables.texi:2608
#, no-wrap
msgid "(define-obsolete-variable-alias 'foo-thing 'bar-thing \"27.1\")\n"
msgstr "(define-obsolete-variable-alias 'foo-thing 'bar-thing \"27.1\")\n"

#. type: defun
#: original_texis/variables.texi:2611
#, no-wrap
msgid "indirect-variable variable"
msgstr "indirect-variable variable"

#. type: defun
#: original_texis/variables.texi:2615
msgid "This function returns the variable at the end of the chain of aliases of @var{variable}.  If @var{variable} is not a symbol, or if @var{variable} is not defined as an alias, the function returns @var{variable}."
msgstr "この関数は@var{variable}のエイリアスチェーンの最後の変数をリターンする。@var{variable}がシンボルでない、または@var{variable}がエイリアスとして定義されていなければ、この関数は@var{variable}をリターンする。"

#. type: defun
#: original_texis/variables.texi:2618
msgid "This function signals a @code{cyclic-variable-indirection} error if there is a loop in the chain of symbols."
msgstr "この関数はシンボルのチェーンがループしていたら、@code{cyclic-variable-indirection}エラーをシグナルする。"

#. type: example
#: original_texis/variables.texi:2629
#, no-wrap
msgid ""
"(defvaralias 'foo 'bar)\n"
"(indirect-variable 'foo)\n"
"     @result{} bar\n"
"(indirect-variable 'bar)\n"
"     @result{} bar\n"
"(setq bar 2)\n"
"bar\n"
"     @result{} 2\n"
msgstr ""
"(defvaralias 'foo 'bar)\n"
"(indirect-variable 'foo)\n"
"     @result{} bar\n"
"(indirect-variable 'bar)\n"
"     @result{} bar\n"
"(setq bar 2)\n"
"bar\n"
"     @result{} 2\n"

#. type: group
#: original_texis/variables.texi:2632
#, no-wrap
msgid ""
"foo\n"
"     @result{} 2\n"
msgstr ""
"foo\n"
"     @result{} 2\n"

#. type: example
#: original_texis/variables.texi:2638
#, no-wrap
msgid ""
"(setq foo 0)\n"
"bar\n"
"     @result{} 0\n"
"foo\n"
"     @result{} 0\n"
msgstr ""
"(setq foo 0)\n"
"bar\n"
"     @result{} 0\n"
"foo\n"
"     @result{} 0\n"

#. type: cindex
#: original_texis/variables.texi:2642
#, no-wrap
msgid "lisp variables defined in C, restrictions"
msgstr "lisp variables defined in C, restrictions"

#. type: Plain text
#: original_texis/variables.texi:2653
msgid "Ordinary Lisp variables can be assigned any value that is a valid Lisp object.  However, certain Lisp variables are not defined in Lisp, but in C@.  Most of these variables are defined in the C code using @code{DEFVAR_LISP}.  Like variables defined in Lisp, these can take on any value.  However, some variables are defined using @code{DEFVAR_INT} or @code{DEFVAR_BOOL}.  @xref{Defining Lisp variables in C,, Writing Emacs Primitives}, in particular the description of functions of the type @code{syms_of_@var{filename}}, for a brief discussion of the C implementation."
msgstr "通常のLisp変数には、有効なLispオブジェクトである任意の値を割り当てることができます。しかしLispではなくCで定義されたLisp変数もあります。これらの変数のほとんどは、@code{DEFVAR_LISP}を使用してCコードで定義されています。Lispで定義された変数と同様、これらは任意の値をとることができます。しかしいくつかの変数は@code{DEFVAR_INT}や@code{DEFVAR_BOOL}を使用して定義されています。C実装の概要的な議論は、@ref{Defining Lisp variables in C,, Writing Emacs Primitives}、特に@code{syms_of_@var{filename}}型の関数の説明を参照してください。"

#. type: Plain text
#: original_texis/variables.texi:2657
msgid "Variables of type @code{DEFVAR_BOOL} can only take on the values @code{nil} or @code{t}.  Attempting to assign them any other value will set them to @code{t}:"
msgstr "@code{DEFVAR_BOOL}型の変数は、値に@code{nil}か@code{t}しかとることができません。他の値の割り当てを試みると@code{t}がセットされます:"

#. type: example
#: original_texis/variables.texi:2662
#, no-wrap
msgid ""
"(let ((display-hourglass 5))\n"
"  display-hourglass)\n"
"     @result{} t\n"
msgstr ""
"(let ((display-hourglass 5))\n"
"  display-hourglass)\n"
"     @result{} t\n"

#. type: defvar
#: original_texis/variables.texi:2664
#, no-wrap
msgid "byte-boolean-vars"
msgstr "byte-boolean-vars"

#. type: defvar
#: original_texis/variables.texi:2666
msgid "This variable holds a list of all variables of type @code{DEFVAR_BOOL}."
msgstr "この変数は@code{DEFVAR_BOOL}型のすべての変数のリストを保持する。"

#. type: Plain text
#: original_texis/variables.texi:2670
msgid "Variables of type @code{DEFVAR_INT} can take on only integer values.  Attempting to assign them any other value will result in an error:"
msgstr "@code{DEFVAR_INT}型の変数は、整数値だけをとることができます。他の値の割り当てを試みると結果はエラーになります:"

#. type: example
#: original_texis/variables.texi:2674
#, no-wrap
msgid ""
"(setq undo-limit 1000.0)\n"
"@error{} Wrong type argument: integerp, 1000.0\n"
msgstr ""
"(setq undo-limit 1000.0)\n"
"@error{} Wrong type argument: integerp, 1000.0\n"

#. type: cindex
#: original_texis/variables.texi:2679
#, no-wrap
msgid "generalized variable"
msgstr "generalized variable"

#. type: cindex
#: original_texis/variables.texi:2680
#, no-wrap
msgid "place form"
msgstr "place form"

#. type: Plain text
#: original_texis/variables.texi:2687
msgid "A @dfn{generalized variable} or @dfn{place form} is one of the many places in Lisp memory where values can be stored using the @code{setf} macro (@pxref{Setting Generalized Variables}).  The simplest place form is a regular Lisp variable.  But the @sc{car}s and @sc{cdr}s of lists, elements of arrays, properties of symbols, and many other locations are also places where Lisp values get stored."
msgstr "@dfn{ジェネリック変数(generalized variable： 汎変数)}または@dfn{place form}は@code{setf}マクロ(@ref{Setting Generalized Variables}を参照)を使用して値が格納される、Lispメモリー内の多くの場所のうちの1つです。一番シンプルなplace formは通常のLisp変数です。しかしリストの@sc{car}と@sc{cdr}、配列の要素、シンボルのプロパティ、その他多くのロケーション(location)もLisp値が格納される場所です。"

#. type: Plain text
#: original_texis/variables.texi:2693
msgid "Generalized variables are analogous to lvalues in the C language, where @samp{x = a[i]} gets an element from an array and @samp{a[i] = x} stores an element using the same notation.  Just as certain forms like @code{a[i]} can be lvalues in C, there is a set of forms that can be generalized variables in Lisp."
msgstr "ジェネリック変数は、C言語のlvalues(左辺値)と類似しています。C言語のlvalueでは@samp{x = a[i]}で配列から要素を取得し、同じ表記を使用して@samp{a[i] = x}で要素を格納します。Cでは@code{a[i]}のような特定のフォームがlvalueになれるように、Lispでジェネリック変数になることができる一連のフォームが存在します。"

#. type: node
#: original_texis/variables.texi:2697 original_texis/variables.texi:2699
#, no-wrap
msgid "Setting Generalized Variables"
msgstr "Setting Generalized Variables"

#. type: menuentry
#: original_texis/variables.texi:2697
msgid "The @code{setf} macro."
msgstr "@code{setf}マクロ。"

#. type: node
#: original_texis/variables.texi:2697 original_texis/variables.texi:2830
#, no-wrap
msgid "Adding Generalized Variables"
msgstr "Adding Generalized Variables"

#. type: menuentry
#: original_texis/variables.texi:2697
msgid "Defining new @code{setf} forms."
msgstr "新たな@code{setf}フォームの定義。"

#. type: subsection
#: original_texis/variables.texi:2700
#, no-wrap
msgid "The @code{setf} Macro"
msgstr "The @code{setf} Macro"

#. type: Plain text
#: original_texis/variables.texi:2709
msgid "The @code{setf} macro is the most basic way to operate on generalized variables.  The @code{setf} form is like @code{setq}, except that it accepts arbitrary place forms in the first (left) argument of each pair rather than just symbols.  For example, @code{(setf (car a) b)} sets the car of @code{a} to @code{b}, doing the same operation as @code{(setcar a b)}, but without you having to use two separate functions for setting and accessing this type of place."
msgstr "@code{setf}マクロはジェネリック変数を操作するもっとも基本的な方法です。@code{setf}フォームは@code{setq}と似ていますが、シンボルだけでなくそれぞれのペアーの1つ目(左)の任意のplace formを受け入れます。たとえば@code{(setf (car a) b)}は@code{a}のcarを@code{b}にセットして@code{(setcar a b)}と同じ操作を行いますが、このタイプのplaceにセットやアクセスするために2つの関数を個別に覚える必要はありません。"

#. type: defmac
#: original_texis/variables.texi:2710
#, no-wrap
msgid "setf [place form]@dots{}"
msgstr "setf [place form]@dots{}"

#. type: defmac
#: original_texis/variables.texi:2716
msgid "This macro evaluates @var{form} and stores its value in @var{place}, which must be a valid generalized variable form.  If there are several @var{place} and @var{form} pairs, the assignments are done sequentially just as with @code{setq}.  @code{setf} returns the value of the last @var{form}."
msgstr "このマクロは@var{form}を評価して、その値を@var{place}に格納する。@var{place}は有効なジェネリック変数フォームでなければならない。複数の@var{place}/@var{form}ペアーがある場合の割り当てについては@code{setq}の場合と同様。@code{setf}は最後の@var{form}の値をリターンする。"

#. type: Plain text
#: original_texis/variables.texi:2721
msgid "The following Lisp forms are the forms in Emacs that will work as generalized variables, and so may appear in the @var{place} argument of @code{setf}:"
msgstr "以下のLispフォームはEmacsではジェネリック変数として機能するフォームなので、@code{setf}の@var{place}引数にすることができます:"

#. type: itemize
#: original_texis/variables.texi:2731
msgid "A symbol.  In other words, @code{(setf x y)} is exactly equivalent to @code{(setq x y)}, and @code{setq} itself is strictly speaking redundant given that @code{setf} exists.  Most programmers will continue to prefer @code{setq} for setting simple variables, though, for stylistic and historical reasons.  The macro @code{(setf x y)} actually expands to @code{(setq x y)}, so there is no performance penalty for using it in compiled code."
msgstr "シンボル。言い換えると、@code{(setf x y)}は完全に@code{(setq x y)}と正に等しく、厳密に言うと@code{setq}自体は@code{setf}が存在するので冗長です。これは純粋にスタイルと歴史的な理由によりますが、ほとんどのプログラマーは依然として単純な変数へのセットには@code{setq}の方を好みます。マクロ@code{(setf x y)}は実際には@code{(setq x y)}に展開されるので、コンパイルされたコードでこれを使用することにパフォーマンス的な不利はありません。"

#. type: itemize
#: original_texis/variables.texi:2734
msgid "A call to any of the following standard Lisp functions:"
msgstr "以下の標準的なLisp関数の呼び出し:"

#. type: smallexample
#: original_texis/variables.texi:2742
#, no-wrap
msgid ""
"aref      cddr      symbol-function\n"
"car       elt       symbol-plist\n"
"caar      get       symbol-value\n"
"cadr      gethash\n"
"cdr       nth\n"
"cdar      nthcdr\n"
msgstr ""
"aref      cddr      symbol-function\n"
"car       elt       symbol-plist\n"
"caar      get       symbol-value\n"
"cadr      gethash\n"
"cdr       nth\n"
"cdar      nthcdr\n"

#. type: itemize
#: original_texis/variables.texi:2746
msgid "A call to any of the following Emacs-specific functions:"
msgstr "以下のEmacs特有な関数の呼び出し:"

#. type: smallexample
#: original_texis/variables.texi:2763
#, no-wrap
msgid ""
"alist-get                     overlay-start\n"
"default-value                 overlay-get\n"
"face-background               process-buffer\n"
"face-font                     process-filter\n"
"face-foreground               process-get\n"
"face-stipple                  process-sentinel\n"
"face-underline-p              terminal-parameter\n"
"file-modes                    window-buffer\n"
"frame-parameter               window-dedicated-p\n"
"frame-parameters              window-display-table\n"
"get-register                  window-hscroll\n"
"getenv                        window-parameter\n"
"keymap-parent                 window-point\n"
"match-data                    window-start\n"
"overlay-end\n"
msgstr ""
"alist-get                     overlay-start\n"
"default-value                 overlay-get\n"
"face-background               process-buffer\n"
"face-font                     process-filter\n"
"face-foreground               process-get\n"
"face-stipple                  process-sentinel\n"
"face-underline-p              terminal-parameter\n"
"file-modes                    window-buffer\n"
"frame-parameter               window-dedicated-p\n"
"frame-parameters              window-display-table\n"
"get-register                  window-hscroll\n"
"getenv                        window-parameter\n"
"keymap-parent                 window-point\n"
"match-data                    window-start\n"
"overlay-end\n"

#. type: itemize
#: original_texis/variables.texi:2771
msgid "A call of the form @code{(substring @var{subplace} @var{n} [@var{m}])}, where @var{subplace} is itself a valid generalized variable whose current value is a string, and where the value stored is also a string.  The new string is spliced into the specified part of the destination string.  For example:"
msgstr "@code{(substring @var{subplace} @var{n} [@var{m}])}という形式の呼び出し。ここで@var{subplace}はそれ自体がカレント値として文字列をもち、それに格納される値も文字列であるような有効なジェネリック変数。新たな文字列は目的となる文字列の指定した箇所につなぎ合わされる。たとえば:"

#. type: example
#: original_texis/variables.texi:2785
#, no-wrap
msgid ""
"(setq a (list \"hello\" \"world\"))\n"
"     @result{} (\"hello\" \"world\")\n"
"(cadr a)\n"
"     @result{} \"world\"\n"
"(substring (cadr a) 2 4)\n"
"     @result{} \"rl\"\n"
"(setf (substring (cadr a) 2 4) \"o\")\n"
"     @result{} \"o\"\n"
"(cadr a)\n"
"     @result{} \"wood\"\n"
"a\n"
"     @result{} (\"hello\" \"wood\")\n"
msgstr ""
"(setq a (list \"hello\" \"world\"))\n"
"     @result{} (\"hello\" \"world\")\n"
"(cadr a)\n"
"     @result{} \"world\"\n"
"(substring (cadr a) 2 4)\n"
"     @result{} \"rl\"\n"
"(setf (substring (cadr a) 2 4) \"o\")\n"
"     @result{} \"o\"\n"
"(cadr a)\n"
"     @result{} \"wood\"\n"
"a\n"
"     @result{} (\"hello\" \"wood\")\n"

#. type: itemize
#: original_texis/variables.texi:2791
msgid "The @code{if} and @code{cond} conditionals will work as generalized variables.  For instance, this will set either the @code{foo} or the @code{bar} variable to @code{zot}:"
msgstr "ジェネリック変数では@code{if}や@code{cond}というコンディションも機能する。たとえば以下は@code{foo}か@code{bar}いずれかの変数を@code{zot}にセットする例:"

#. type: example
#: original_texis/variables.texi:2797
#, no-wrap
msgid ""
"(setf (if (zerop (random 2))\n"
"\t  foo\n"
"\tbar)\n"
"      'zot)\n"
msgstr ""
"(setf (if (zerop (random 2))\n"
"\t  foo\n"
"\tbar)\n"
"      'zot)\n"

#. type: Plain text
#: original_texis/variables.texi:2803
msgid "@code{setf} signals an error if you pass a @var{place} form that it does not know how to handle."
msgstr "どのように処理すれば良いか未知な@var{place}フォームを渡すと、@code{setf}はエラーをシグナルします。"

#. type: Plain text
#: original_texis/variables.texi:2810
msgid "Note that for @code{nthcdr}, the list argument of the function must itself be a valid @var{place} form.  For example, @code{(setf (nthcdr 0 foo) 7)} will set @code{foo} itself to 7."
msgstr "@code{nthcdr}の場合、関数のリスト引数はそれ自体が有効な@var{place}フォームでなければならないことに注意してください。たとえば@code{(setf (nthcdr 0 foo) 7)}は、@code{foo}自体に7をセットするでしょう。"

#. type: Plain text
#: original_texis/variables.texi:2824
msgid "The macros @code{push} (@pxref{List Variables}) and @code{pop} (@pxref{List Elements}) can manipulate generalized variables, not just lists.  @code{(pop @var{place})} removes and returns the first element of the list stored in @var{place}.  It is analogous to @code{(prog1 (car @var{place}) (setf @var{place} (cdr @var{place})))}, except that it takes care to evaluate all subforms only once.  @code{(push @var{x} @var{place})} inserts @var{x} at the front of the list stored in @var{place}.  It is analogous to @code{(setf @var{place} (cons @var{x} @var{place}))}, except for evaluation of the subforms.  Note that @code{push} and @code{pop} on an @code{nthcdr} place can be used to insert or delete at any position in a list."
msgstr "マクロ@code{push}(@ref{List Variables}を参照)と@code{pop}(@ref{List Elements}を参照)は、リストだけでなくジェネリック変数を操作できます。@code{(pop @var{place})}は@var{place}内に格納されたリストの最初の要素を削除してリターンします。これは@code{(prog1 (car @var{place}) (setf @var{place} (cdr @var{place})))}と似ていますが、すべてのサブフォームを一度だけ評価します。@code{(push @var{x} @var{place})}は@var{place}内に格納されたリストの一番前に@var{x}を挿入します。これは@code{(setf @var{place} (cons @var{x} @var{place}))}と似ていますが、サブフォームの評価が異なります。@code{nthcdr} placeへの@code{push}と@code{pop}は、リスト内の任意の位置での挿入ち削除に使用できることに注意してください。"

#. type: Plain text
#: original_texis/variables.texi:2828
msgid "The @file{cl-lib} library defines various extensions for generalized variables, including additional @code{setf} places.  @xref{Generalized Variables,,, cl, Common Lisp Extensions}."
msgstr "@file{cl-lib}ライブラリーでは追加の@code{setf} placeを含む、ジェネリック変数にたいするさまざまな拡張が定義されています。@ref{Generalized Variables,,, cl, Common Lisp Extensions}を参照してください。"

#. type: subsection
#: original_texis/variables.texi:2831
#, no-wrap
msgid "Defining new @code{setf} forms"
msgstr "Defining new @code{setf} forms"

#. type: Plain text
#: original_texis/variables.texi:2835
msgid "This section describes how to define new forms that @code{setf} can operate on."
msgstr "このセクションでは、@code{setf}が操作できる新たなフォームの定義方法を説明します。"

#. type: defmac
#: original_texis/variables.texi:2836
#, no-wrap
msgid "gv-define-simple-setter name setter &optional fix-return"
msgstr "gv-define-simple-setter name setter &optional fix-return"

#. type: defmac
#: original_texis/variables.texi:2842
msgid "This macro enables you to easily define @code{setf} methods for simple cases.  @var{name} is the name of a function, macro, or special form.  You can use this macro whenever @var{name} has a directly corresponding @var{setter} function that updates it, e.g., @code{(gv-define-simple-setter car setcar)}."
msgstr "このマクロは単純なケースで@code{setf}メソッドを簡単に定義することを可能にする。@var{name}は関数、マクロ、スペシャルフォームの名前。@var{name}がそれを更新するための対応する@var{setter}関数をもつなら、このマクロを使用できる(たとえば@code{(gv-define-simple-setter car setcar)})。"

#. type: defmac
#: original_texis/variables.texi:2844
msgid "This macro translates a call of the form"
msgstr "このマクロは以下のフォームの呼び出しを"

#. type: example
#: original_texis/variables.texi:2847
#, no-wrap
msgid "(setf (@var{name} @var{args}@dots{}) @var{value})\n"
msgstr "(setf (@var{name} @var{args}@dots{}) @var{value})\n"

#. type: defmac
#: original_texis/variables.texi:2850
msgid "into"
msgstr "以下のように変換する。"

#. type: example
#: original_texis/variables.texi:2852
#, no-wrap
msgid "(@var{setter} @var{args}@dots{} @var{value})\n"
msgstr "(@var{setter} @var{args}@dots{} @var{value})\n"

#. type: defmac
#: original_texis/variables.texi:2861
msgid "Such a @code{setf} call is documented to return @var{value}.  This is no problem with, e.g., @code{car} and @code{setcar}, because @code{setcar} returns the value that it set.  If your @var{setter} function does not return @var{value}, use a non-@code{nil} value for the @var{fix-return} argument of @code{gv-define-simple-setter}.  This expands into something equivalent to"
msgstr "このような@code{setf}の呼び出しは@var{value}をリターンするとドキュメントされている。これは@code{car}と@code{setcar}では問題はない。@code{setcar}はそれがセットする値をリターンするからである。@var{setter}関数が@var{value}をリターンしない場合には、@code{gv-define-simple-setter}の@var{fix-return}引数に、非@code{nil}値を使用すること。これは以下のようなものに展開される"

#. type: example
#: original_texis/variables.texi:2865
#, no-wrap
msgid ""
"(let ((temp @var{value}))\n"
"  (@var{setter} @var{args}@dots{} temp)\n"
"  temp)\n"
msgstr ""
"(let ((temp @var{value}))\n"
"  (@var{setter} @var{args}@dots{} temp)\n"
"  temp)\n"

#. type: defmac
#: original_texis/variables.texi:2867
msgid "so ensuring that it returns the correct result."
msgstr "これで正しい結果がリターンされることが保証される。"

#. type: defmac
#: original_texis/variables.texi:2870
#, no-wrap
msgid "gv-define-setter name arglist &rest body"
msgstr "gv-define-setter name arglist &rest body"

#. type: defmac
#: original_texis/variables.texi:2875
msgid "This macro allows for more complex @code{setf} expansions than the previous form.  You may need to use this form, for example, if there is no simple setter function to call, or if there is one but it requires different arguments to the place form."
msgstr "このマクロは上述のフォームより複雑な@code{setf}展開を可能にする。たとえば呼び出すべきシンプルなsetter関数が存在しないときや、もしそれが存在してもplaceフォームとは異なる引数を要求するなら、このフォームを使う必要があるかもしれない。"

#. type: defmac
#: original_texis/variables.texi:2883
msgid "This macro expands the form @code{(setf (@var{name} @var{args}@dots{}) @var{value})} by first binding the @code{setf} argument forms @code{(@var{value} @var{args}@dots{})} according to @var{arglist}, and then executing @var{body}.  @var{body} should return a Lisp form that does the assignment, and finally returns the value that was set.  An example of using this macro is:"
msgstr "このマクロは最初に@code{setf}引数フォーム@code{(@var{value} @var{args}@dots{})}を@var{arglist}にバインドして、その後@var{body}を実行することによって、フォーム@code{(setf (@var{name} @var{args}@dots{}) @var{value})}を展開する。@var{body}は割り当てを行うLispフォームをリターンして、最終的にはセットされた値をリターンすること。以下はこのマクロの使用例:"

#. type: example
#: original_texis/variables.texi:2886
#, no-wrap
msgid "(gv-define-setter caar (val x) `(setcar (car ,x) ,val))\n"
msgstr "(gv-define-setter caar (val x) `(setcar (car ,x) ,val))\n"

#. type: defmac
#: original_texis/variables.texi:2889
#, no-wrap
msgid "gv-define-expander name handler"
msgstr "gv-define-expander name handler"

#. type: defmac
#: original_texis/variables.texi:2893
msgid "For more control over the expansion, the @code{gv-define-expander} macro can be used.  For instance, a settable @code{substring} could be implemented this way:"
msgstr "展開をより詳細に制御するために@code{gv-define-expander}マクロが使用できる。たとえばセット可能な@code{substring}は以下の方法で実装できる:"

#. type: example
#: original_texis/variables.texi:2906
#, no-wrap
msgid ""
"(gv-define-expander substring\n"
"  (lambda (do place from &optional to)\n"
"    (gv-letplace (getter setter) place\n"
"      (macroexp-let2* (from to)\n"
"        (funcall do `(substring ,getter ,from ,to)\n"
"                 (lambda (v)\n"
"                   (macroexp-let2* (v)\n"
"                     `(progn\n"
"                        ,(funcall setter `(cl--set-substring\n"
"                                           ,getter ,from ,to ,v))\n"
"                        ,v))))))))\n"
msgstr ""
"(gv-define-expander substring\n"
"  (lambda (do place from &optional to)\n"
"    (gv-letplace (getter setter) place\n"
"      (macroexp-let2* (from to)\n"
"        (funcall do `(substring ,getter ,from ,to)\n"
"                 (lambda (v)\n"
"                   (macroexp-let2* (v)\n"
"                     `(progn\n"
"                        ,(funcall setter `(cl--set-substring\n"
"                                           ,getter ,from ,to ,v))\n"
"                        ,v))))))))\n"

#. type: defmac
#: original_texis/variables.texi:2909
#, no-wrap
msgid "gv-letplace (getter setter) place &rest body"
msgstr "gv-letplace (getter setter) place &rest body"

#. type: defmac
#: original_texis/variables.texi:2913
msgid "The macro @code{gv-letplace} can be useful in defining macros that perform similarly to @code{setf}; for example, the @code{incf} macro of Common Lisp could be implemented this way:"
msgstr "マクロ@code{gv-letplace}は@code{setf}のような処理を行うマクロを定義するのに有用。たとえばCommon Lispの@code{incf}マクロは以下の方法で実装できる:"

#. type: example
#: original_texis/variables.texi:2919
#, no-wrap
msgid ""
"(defmacro incf (place &optional n)\n"
"  (gv-letplace (getter setter) place\n"
"    (macroexp-let2* ((v (or n 1)))\n"
"      (funcall setter `(+ ,v ,getter)))))\n"
msgstr ""
"(defmacro incf (place &optional n)\n"
"  (gv-letplace (getter setter) place\n"
"    (macroexp-let2* ((v (or n 1)))\n"
"      (funcall setter `(+ ,v ,getter)))))\n"

#. type: defmac
#: original_texis/variables.texi:2926
msgid "@var{getter} will be bound to a copyable expression that returns the value of @var{place}.  @var{setter} will be bound to a function that takes an expression @var{v} and returns a new expression that sets @var{place} to @var{v}.  @var{body} should return a Emacs Lisp expression manipulating @var{place} via @var{getter} and @var{setter}."
msgstr "@var{getter}は@var{place}の値をリターンするコピー可能な式にバインドされる。@var{setter}は式@var{v}を受け取り、@var{place}に@var{v}をセットする新たな式をリターンする関数にセットされる。@var{body}は@var{getter}と@var{setter}を介して@var{place}を操作するEmacs Lisp式をリターンすること。"

#. type: Plain text
#: original_texis/variables.texi:2929
msgid "Consult the source file @file{gv.el} for more details."
msgstr "詳細は@file{gv.el}のソースファイルを参照。"

#. type: defun
#: original_texis/variables.texi:2930
#, no-wrap
msgid "make-obsolete-generalized-variable obsolete-name current-name when"
msgstr "make-obsolete-generalized-variable obsolete-name current-name when"

#. type: defun
#: original_texis/variables.texi:2938
msgid "This function makes the byte compiler warn that the generalized variable @var{obsolete-name} is obsolete.  If @var{current-name} is a symbol, then the warning message says to use @var{current-name} instead of @var{obsolete-name}.  If @var{current-name} is a string, this is the message.  @var{when} should be a string indicating when the variable was first made obsolete (usually a version number string)."
msgstr "この関数はバイトコンパイラーにジェネリック変数@var{obsolete-name}が陳腐化していると警告させる。@var{current-name}がシンボルなら、@var{obsolete-name}のかわりに@var{current-name}を使用するよう告げるメッセージにより警告が行われる。@var{current-name}が文字列なら、それはメッセージであること。@var{when}はその変数が最初に陳腐化するのがいつかを示す文字列(通常はバージョン番号文字列)。"

#. type: cindex
#: original_texis/variables.texi:2940
#, no-wrap
msgid "CL note---no @code{setf} functions"
msgstr "CL note---no @code{setf} functions"

#. type: quotation
#: original_texis/variables.texi:2951
msgid "@b{Common Lisp note:} Common Lisp defines another way to specify the @code{setf} behavior of a function, namely @code{setf} functions, whose names are lists @code{(setf @var{name})} rather than symbols.  For example, @code{(defun (setf foo) @dots{})} defines the function that is used when @code{setf} is applied to @code{foo}.  Emacs does not support this.  It is a compile-time error to use @code{setf} on a form that has not already had an appropriate expansion defined.  In Common Lisp, this is not an error since the function @code{(setf @var{func})} might be defined later."
msgstr "@b{Common Lispに関する注意:} Common Lispは関数としての@code{setf}、すなわち関数名がシンボルではなくリスト@code{(setf @var{name})}であるような@code{setf}関数の挙動を指定するために別の方法を定義する。たとえば@code{(defun (setf foo) @dots{})}は、@code{setf}が@code{foo}に適用されるときに使用される関数を定義する。Emacsはこれをサポートしない。適切な展開が定義されていないフォームに@code{setf}を使用するとコンパイル時エラーとなる。Common Lispでは後で関数@code{(setf @var{func})}が定義されるのでエラーにならない。"

#. type: cindex
#: original_texis/variables.texi:2956
#, no-wrap
msgid "multisession variable"
msgstr "multisession variable"

#. type: Plain text
#: original_texis/variables.texi:2964
msgid "When you set a variable to a value and then close Emacs and restart it, that value won't be automatically restored.  Users usually set normal variables in their startup files, or use Customize (@pxref{Customization}) to set user options permanently, and various packages have various files where they store the data (e.g., Gnus stores this in @file{.newsrc.eld} and the URL library stores cookies in @file{~/.emacs.d/url/cookies})."
msgstr "ある変数に値をセットしてからEmacsを終了すると、その後に再起動してもその値が自動的に復元されることはありません。ユーザーが値を永続的にセットする場合には、通常の変数であればスタートアップファイル、ユーザーオプションであればCustomize(@ref{Customization}を参照)を用いるのが普通です。更にデータを格納するためにさまざまなファイルをもつパッケージが沢山あります(例: Gnusはデータを@file{.newsrc.eld}、URLライブラリーはcookieを@file{~/.emacs.d/url/cookies}に格納する)。"

#. type: Plain text
#: original_texis/variables.texi:2971
msgid "For things in between these two extremes (i.e., configuration which goes in the startup file, and massive application state that goes into separate files), Emacs provides a facility to replicate data between sessions called @dfn{multisession variables}.  (This facility may not be available on all systems.)  To give you an idea of how these are meant to be used, here's a small example:"
msgstr "これらの2つの対極的な事項(スタートアップファイルに書き込まれる構成、あるいは大規模なアプリケーションが個別のファイルへ書き込む状態)にたいして、Emacsはセッションに跨がるデータを複製(replicate)するための@dfn{マルチセッション変数(multisession variables)}と呼ばれる機能を提供しています(この機能はすべてのシステムで利用できる訳ではない)。これらがどのような利用を意図しているかヒントを与えるために、以下に小さな例を示しましょう:"

#. type: group
#: original_texis/variables.texi:2980
#, no-wrap
msgid ""
"(define-multisession-variable foo-var 0)\n"
"(defun my-adder (num)\n"
"  (interactive \"nAdd number: \")\n"
"  (setf (multisession-value foo)\n"
"        (+ (multisession-value foo) num))\n"
"  (message \"The new number is: %s\" (multisession-value foo)))\n"
msgstr ""
"(define-multisession-variable foo-var 0)\n"
"(defun my-adder (num)\n"
"  (interactive \"nAdd number: \")\n"
"  (setf (multisession-value foo)\n"
"        (+ (multisession-value foo) num))\n"
"  (message \"The new number is: %s\" (multisession-value foo)))\n"

#. type: Plain text
#: original_texis/variables.texi:2989
msgid "This defines the variable @code{foo-var} and binds it to a special multisession object which is initialized with the value @samp{0} (if the variable doesn't already exist from a previous session).  The @code{my-adder} command queries the user for a number, adds this to the old (possibly saved value), and then saves the new value."
msgstr "これは変数@code{foo-var}を定義して、(この変数が以前のセッション以降に存在していなければ)値@samp{0}に初期化された特別なマルチセッションオブジェクトにバインドしています。@code{my-adder}コマンドはユーザーに数値の入力を求めて、それを(もしかしたら保存されていた)古い値に加算してから新しい値へと保存します。"

#. type: Plain text
#: original_texis/variables.texi:2992
msgid "This facility isn't meant to be used for huge data structures, but should be performant for most values."
msgstr "この機能は巨大なデータ構造にたいする使用を意図したものではありませんが、ほとんどの値にたいしてパフォーマンスは高いはずです。"

#. type: defmac
#: original_texis/variables.texi:2993
#, no-wrap
msgid "define-multisession-variable name initial-value &optional doc &rest args"
msgstr "define-multisession-variable name initial-value &optional doc &rest args"

#. type: defmac
#: original_texis/variables.texi:2998
msgid "This macro defines @var{name} as a multisession variable, and gives it the @var{initial-value} if this variable hasn't been assigned a value earlier.  @var{doc} is the doc string, and several keyword arguments can be used in @var{args}:"
msgstr "このマクロはマルチセッション変数として@var{name}を定義して、その変数に以前に値が割り当てられていなければ@var{initial-value}を与える。@var{doc}はdoc文字列、@var{args}にはいくつかのキーワード引数を使用できる:"

#. type: item
#: original_texis/variables.texi:3000
#, no-wrap
msgid ":package @var{package-symbol}"
msgstr ":package @var{package-symbol}"

#. type: table
#: original_texis/variables.texi:3009
msgid "This keyword says that a multisession variable belongs to the package specified by @var{package-symbol}.  The combination of @var{package-symbol} and @var{name} has to be unique.  If @var{package-symbol} isn't given, this will default to the first ``segment'' of the @var{name} symbol's name, which is the part of its name up to and excluding the first @samp{-}.  For instance, if @var{name} is @code{foo-var} and @var{package-symbol} isn't given, @var{package-symbol} will default to @code{foo}."
msgstr "マルチセッション変数が@var{package-symbol}で指定されたパッケージに属することを告げるキーワード。@var{package-symbol}と@var{name}は一意な組み合わせであること。@var{package-symbol}が与えられない場合には、@var{name}のシンボル名の1つ目の``セグメント''(シンボル名の最初の@samp{-}の手前までの部分)がデフォルトになる。たとえば@var{name}が@code{foo-var}で@var{package-symbol}を与えなければ、@var{package-symbol}のデフォルトは@code{foo}。"

#. type: cindex
#: original_texis/variables.texi:3010
#, no-wrap
msgid "synchronized multisession variables"
msgstr "synchronized multisession variables"

#. type: item
#: original_texis/variables.texi:3011
#, no-wrap
msgid ":synchronized @var{bool}"
msgstr ":synchronized @var{bool}"

#. type: table
#: original_texis/variables.texi:3019
msgid "Multisession variables can be @dfn{synchronized} if @var{bool} is non-@code{nil}.  This means that if there're two concurrent Emacs instances running, and the other Emacs changes the multisession variable @code{foo-var}, the current Emacs instance will retrieve that modified data when accessing the value.  If @var{synchronized} is @code{nil} or missing, this won't happen, and the values in all Emacs sessions using the variable will be independent of each other."
msgstr "@var{bool}が非@code{nil}であればマルチセッション変数を@dfn{同期(synchronized)}できる。同時に2つのEmacsインスタンスが実行中に、別のEmacsがマルチセッション変数@code{foo-var}を変更すると、カレントのEmacsインスタンスがその値にアクセスした際には変更済みのデータが取得されることを意味する。これは@var{synchronized}が@code{nil}あるいは未指定の場合には発生せず、この変数を使用するすべてのEmacsセッションそれぞれにたいして独立した値となる。"

#. type: item
#: original_texis/variables.texi:3020
#, no-wrap
msgid ":storage @var{storage}"
msgstr ":storage @var{storage}"

#. type: table
#: original_texis/variables.texi:3025
msgid "Use the specified @var{storage} method.  This can be either @code{sqlite} (in Emacs compiled with SQLite support) or @code{files}.  If not given, this defaults to the value of the @code{multisession-storage} variable, described below."
msgstr "@var{storage}で指定されたメソッドを使用する。@code{sqlite}(SQLiteサポートつきでコンパイルされたEmacsの場合)、あるいは@code{files}のいずれか。与えられない場合には、後述の@code{multisession-storage}変数の値がデフォルトになる。"

#. type: defun
#: original_texis/variables.texi:3028
#, no-wrap
msgid "multisession-value variable"
msgstr "multisession-value variable"

#. type: defun
#: original_texis/variables.texi:3035
msgid "This function returns the current value of @var{variable}.  If this variable hasn't been accessed before in this Emacs session, or if it's changed externally, it will be read in from external storage.  If not, the current value in this session is returned as is.  It is an error to call this function for a @var{variable} that is not a multisession variable."
msgstr "この関数は@var{variable}のカレント値をリターンする。そのEmacsセッションにおいて変数にこれまでアクセスしていない、あるいは変数が外部から変更されていた場合には外部ストレージから読み込まれる。それ以外の場合にはそのセッションでのカレント値がそのままリターンされる。マルチセッション変数ではない@var{variable}にたいしてこの関数を呼び出すとエラーとなる。"

#. type: defun
#: original_texis/variables.texi:3038
msgid "Values retrieved via @code{multisession-value} may or may not be @code{eq} to each other, but they will always be @code{equal}."
msgstr "@code{multisession-value}を通じて取得した値は互いに@code{eq}のときもあれば異なるときもあるが、常に@code{equal}である。"

#. type: defun
#: original_texis/variables.texi:3041
msgid "This is a generalized variable (@pxref{Generalized Variables}), so the way to update such a variable is to say, for instance:"
msgstr "これはジェネリック化された変数(@ref{Generalized Variables}を参照)なので、そのような変数はたとえば以下のような方法によって更新される:"

#. type: lisp
#: original_texis/variables.texi:3044
#, no-wrap
msgid "(setf (multisession-value foo-bar) 'zot)\n"
msgstr "(setf (multisession-value foo-bar) 'zot)\n"

#. type: defun
#: original_texis/variables.texi:3048
msgid "Only Emacs Lisp values that have a readable print syntax (@pxref{Printed Representation}) can be saved this way."
msgstr "この方法によって保存できるのは読み取り可能なプリント構文(@ref{Printed Representation}を参照)をもつEmacs Lisp値のみ。"

#. type: defun
#: original_texis/variables.texi:3051
msgid "If the multisession variable is synchronized, setting it may update the value first.  For instance:"
msgstr "そのマルチセッション変数が同期化されている場合にセットすると、最初に値が更新されるかもしれない。たとえば:"

#. type: lisp
#: original_texis/variables.texi:3054
#, no-wrap
msgid "(cl-incf (multisession-value foo-bar))\n"
msgstr "(cl-incf (multisession-value foo-bar))\n"

#. type: defun
#: original_texis/variables.texi:3061
msgid "This first checks whether the value has changed in a different Emacs instance, retrieves that value, and then adds 1 to that value and stores it.  But note that this is done without locking, so if many instances are updating the value at the same time, it's unpredictable which instance ``wins''."
msgstr "ここではまず別のEmacsセッションによって値が変更されているかどうかをチェックして、その後に値に1を加算して格納している。これはロックなしでおこなわれために、多くのセッションが同時に値を変更する場合にどのセッションが``勝利''するか予想できないことに注意。"

#. type: defun
#: original_texis/variables.texi:3063
#, no-wrap
msgid "multisession-delete object"
msgstr "multisession-delete object"

#. type: defun
#: original_texis/variables.texi:3066
msgid "This function deletes @var{object} and its value from its persistent storage."
msgstr "この関数は@var{object}とその値を永続化されたストレージから削除する。"

#. type: defun
#: original_texis/variables.texi:3069
#, no-wrap
msgid "make-multisession"
msgstr "make-multisession"

#. type: defun
#: original_texis/variables.texi:3072
msgid "You can also make persistent values that aren't tied to a specific variable, but are tied to an explicit package and key."
msgstr "特定の変数ではなく明示的なパッケージとキーに結びつけられらた永続的な値を作成することもできる。"

#. type: example
#: original_texis/variables.texi:3077
#, no-wrap
msgid ""
"(setq foo (make-multisession :package \"mail\"\n"
"                             :key \"friends\"))\n"
"(setf (multisession-value foo) 'everybody)\n"
msgstr ""
"(setq foo (make-multisession :package \"mail\"\n"
"                             :key \"friends\"))\n"
"(setf (multisession-value foo) 'everybody)\n"

#. type: defun
#: original_texis/variables.texi:3082
msgid "This supports the same keywords as @code{define-multisession-variable}, but also supports a @code{:initial-value} keyword, which specifies the default value."
msgstr "この関数は@code{define-multisession-variable}と同じキーワードに加えて、@code{:initial-value}キーワード(デフォルト値を指定する)もサポートする。"

#. type: defopt
#: original_texis/variables.texi:3084
#, no-wrap
msgid "multisession-storage"
msgstr "multisession-storage"

#. type: defopt
#: original_texis/variables.texi:3091
msgid "This variable controls how the multisession variables are stored.  It value defaults to @code{files}, which means that the values are stored in a one-file-per-variable structure inside the directory specified by @code{multisession-directory}.  If this value is @code{sqlite} instead, the values are stored in an SQLite database; this is only available if Emacs was built with SQLite support."
msgstr "この変数はマルチセッション変数をどのように格納するかを制御する。デフォルト値の@code{files}は@code{multisession-directory}で指定されたディレクトリー内に変数1つにたいしてファイル1つという構造で値が格納されることを意味する。これが@code{sqlite}なら値はSQLiteデータベースに格納される(SQLiteサポートつきでビルドされたEmacsでのみ利用可能)。"

#. type: defopt
#: original_texis/variables.texi:3093
#, no-wrap
msgid "multisession-directory"
msgstr "multisession-directory"

#. type: defopt
#: original_texis/variables.texi:3098
msgid "The multisession variables are stored under this directory, which defaults to @file{multisession/} subdirectory of the @code{user-emacs-directory}, which is typically @file{~/.emacs.d/multisession/}."
msgstr "このディレクトリー配下にマルチセッション変数は格納される。デフォルトは@code{user-emacs-directory}のサブディレクトリー@file{multisession/} (通常なら@file{~/.emacs.d/multisession/})。"

#. type: findex
#: original_texis/variables.texi:3100
#, no-wrap
msgid "multisession-edit-mode"
msgstr "multisession-edit-mode"

#. type: deffn
#: original_texis/variables.texi:3101
#, no-wrap
msgid "Command list-multisession-values"
msgstr "Command list-multisession-values"

#. type: deffn
#: original_texis/variables.texi:3105
msgid "This command pops up a buffer listing all the multisession variables, and enters a special mode @code{multisession-edit-mode} which allows you to delete them and edit their values."
msgstr "このコマンドはすべてのマルチセッション変数をリストするバッファーをポップアップして、それらの値の削除や編集が行える特別なモード@code{multisession-edit-mode}にエンターする。"
