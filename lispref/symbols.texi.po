# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Emacs 26.1\n"
"POT-Creation-Date: 2024-06-30 14:10+0000\n"
"PO-Revision-Date: 2024-01-24 07:13+0900\n"
"Last-Translator: Takeshi Ayanokoji <takeshi.ayanokoji@gmail.com>\n"
"Language-Team: Japanese <takeshi.ayanokoji@gmail.com>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: original_texis/symbols.texi:6 original_texis/symbols.texi:7
#, no-wrap
msgid "Symbols"
msgstr "Symbols"

#. type: cindex
#: original_texis/symbols.texi:8
#, no-wrap
msgid "symbol"
msgstr "symbol"

#. type: Plain text
#: original_texis/symbols.texi:16
msgid "A @dfn{symbol} is an object with a unique name.  This chapter describes symbols, their components, their property lists, and how they are created and interned.  Separate chapters describe the use of symbols as variables and as function names; see @ref{Variables}, and @ref{Functions}.  For the precise read syntax for symbols, see @ref{Symbol Type}."
msgstr "@dfn{シンボル(symbol)}は一意な名前をもつオブジェクトです。このチャプターではシンボル、シンボルの構成要素とプロパティリスト、およびシンボルの作成とインターンする方法を説明します。別のチャプターではシンボルを変数として使用したり、関数名として使用する方法が説明されています。@ref{Variables}と@ref{Functions}を参照してください。シンボルの正確な入力構文については、@ref{Symbol Type}を参照してください。"

#. type: Plain text
#: original_texis/symbols.texi:19
msgid "You can test whether an arbitrary Lisp object is a symbol with @code{symbolp}:"
msgstr "@code{symbolp}を使用して、任意のLispオブジェクトがシンボルかどうかをテストできます:"

#. type: defun
#: original_texis/symbols.texi:20
#, no-wrap
msgid "symbolp object"
msgstr "symbolp object"

#. type: defun
#: original_texis/symbols.texi:23
msgid "This function returns @code{t} if @var{object} is a symbol, @code{nil} otherwise."
msgstr "この関数は@var{object}がシンボルなら@code{t}、それ以外は@code{nil}をリターンする。"

#. type: section
#: original_texis/symbols.texi:35 original_texis/symbols.texi:37
#: original_texis/symbols.texi:38
#, no-wrap
msgid "Symbol Components"
msgstr "Symbol Components"

#. type: menuentry
#: original_texis/symbols.texi:35
msgid "Symbols have names, values, function definitions and property lists."
msgstr "シンボルは名前、値、関数定義、プロパティリストをもつ。"

#. type: node
#: original_texis/symbols.texi:35 original_texis/symbols.texi:122
#, no-wrap
msgid "Definitions"
msgstr "Definitions"

#. type: menuentry
#: original_texis/symbols.texi:35
msgid "A definition says how a symbol will be used."
msgstr "定義はシンボルが使用される方法を示す。"

#. type: node
#: original_texis/symbols.texi:35 original_texis/symbols.texi:171
#, no-wrap
msgid "Creating Symbols"
msgstr "Creating Symbols"

#. type: menuentry
#: original_texis/symbols.texi:35
msgid "How symbols are kept unique."
msgstr "シンボルが一意に保たれる方法。"

#. type: section
#: original_texis/symbols.texi:35 original_texis/symbols.texi:419
#: original_texis/symbols.texi:420
#, no-wrap
msgid "Symbol Properties"
msgstr "Symbol Properties"

#. type: menuentry
#: original_texis/symbols.texi:35
msgid "Each symbol has a property list for recording miscellaneous information."
msgstr "さまざまな情報を記録するために各シンボルはプロパティリストをもつ。"

#. type: section
#: original_texis/symbols.texi:35 original_texis/symbols.texi:657
#: original_texis/symbols.texi:658
#, no-wrap
msgid "Shorthands"
msgstr "Shorthands"

#. type: menuentry
#: original_texis/symbols.texi:35
msgid "Properly organize your symbol names but type less of them."
msgstr "シンボル名のタイプ量を少なくしつつ正しく組織化するには。"

#. type: section
#: original_texis/symbols.texi:35 original_texis/symbols.texi:774
#: original_texis/symbols.texi:775
#, no-wrap
msgid "Symbols with Position"
msgstr "Symbols with Position"

#. type: menuentry
#: original_texis/symbols.texi:35
msgid "Symbol variants containing integer positions"
msgstr "整数の位置を含んだシンボルの変種"

#. type: cindex
#: original_texis/symbols.texi:39
#, no-wrap
msgid "symbol components"
msgstr "symbol components"

#. type: Plain text
#: original_texis/symbols.texi:43
msgid "Each symbol has four components (or ``cells''), each of which references another object:"
msgstr "各シンボルは4つの構成要素(もしくは``セル'')をもち、構成要素はそれぞれ別のオブジェクトを参照します:"

#. type: item
#: original_texis/symbols.texi:45
#, no-wrap
msgid "Print name"
msgstr "プリント名(print name)"

#. type: cindex
#: original_texis/symbols.texi:46
#, no-wrap
msgid "print name cell"
msgstr "print name cell"

#. type: table
#: original_texis/symbols.texi:48
msgid "The symbol's name."
msgstr "そのシンボルの名前。"

#. type: item
#: original_texis/symbols.texi:49
#, no-wrap
msgid "Value"
msgstr "値(value)"

#. type: cindex
#: original_texis/symbols.texi:50
#, no-wrap
msgid "value cell"
msgstr "value cell"

#. type: table
#: original_texis/symbols.texi:52
msgid "The symbol's current value as a variable."
msgstr "変数としてのそのシンボルの現在値。"

#. type: item
#: original_texis/symbols.texi:53
#, no-wrap
msgid "Function"
msgstr "関数(function)"

#. type: cindex
#: original_texis/symbols.texi:54
#, no-wrap
msgid "function cell"
msgstr "function cell"

#. type: table
#: original_texis/symbols.texi:57
msgid "The symbol's function definition.  It can also hold a symbol, a keymap, or a keyboard macro."
msgstr "そのシンボルの関数定義。シンボル、キーマップ、キーボードマクロも保持できる。"

#. type: item
#: original_texis/symbols.texi:58
#, no-wrap
msgid "Property list"
msgstr "プロパティリスト(property list)"

#. type: cindex
#: original_texis/symbols.texi:59
#, no-wrap
msgid "property list cell"
msgstr "property list cell"

#. type: table
#: original_texis/symbols.texi:61
msgid "The symbol's property list."
msgstr "そのシンボルのプロパティリスト。"

#. type: Plain text
#: original_texis/symbols.texi:66
msgid "The print name cell always holds a string, and cannot be changed.  Each of the other three cells can be set to any Lisp object."
msgstr "プリント名のセルは常に文字列を保持し、それを変更することはできません。他の3つのセルには、任意のLispオブジェクトをセットすることができます。"

#. type: Plain text
#: original_texis/symbols.texi:77
msgid "The print name cell holds the string that is the name of a symbol.  Since symbols are represented textually by their names, it is important not to have two symbols with the same name.  The Lisp reader ensures this: every time it reads a symbol, it looks for an existing symbol with the specified name before it creates a new one.  To get a symbol's name, use the function @code{symbol-name} (@pxref{Creating Symbols}).  However, although each symbol has only one unique @emph{print name}, it is nevertheless possible to refer to that same symbol via different alias names called ``shorthands'' (@pxref{Shorthands})."
msgstr "プリント名のセルはシンボルの名前となる文字列を保持します。シンボルはシンボル名によりテキストとして表されるので、2つのシンボルが同じ名前をもたないことが重要です。Lispリーダーはシンボルを読み取るごとに、それを新規作成する前に、指定されたシンボルがすでに存在するかを調べます。シンボルの名前を得るには関数@code{symbol-name}(@ref{Creating Symbols}を参照)を使用します。しかしシンボルがそれぞれ一意な@emph{プリント名(print name)}を1つだけもつとしても、``ショートハンド(shorthand)''と呼ばれる違うエイリアス名を通じて同じシンボルを参照することは可能です(@ref{Shorthands}を参照)。"

#. type: Plain text
#: original_texis/symbols.texi:87
msgid "The value cell holds a symbol's value as a variable, which is what you get if the symbol itself is evaluated as a Lisp expression.  @xref{Variables}, for details about how values are set and retrieved, including complications such as @dfn{local bindings} and @dfn{scoping rules}.  Most symbols can have any Lisp object as a value, but certain special symbols have values that cannot be changed; these include @code{nil} and @code{t}, and any symbol whose name starts with @samp{:} (those are called @dfn{keywords}).  @xref{Constant Variables}."
msgstr "値セルは変数としてのシンボルの値(そのシンボル自身がLisp式として評価されたときに得る値)を保持します。@dfn{ローカルバインディング(local binding)}や@dfn{スコーピングルール(scoping rules)}等のような複雑なものを含めて、変数のセットや取得方法については@ref{Variables}を参照してください。ほとんどのシンボルは値として任意のLispオブジェクトをもつことができますが、一部の特別なシンボルは変更できない値をもちます。これらには@code{nil}、@code{t}、および名前が@samp{:}で始まるすべてのシンボル(@dfn{キーワード(keyword)}と呼ばれる)が含まれます。@ref{Constant Variables}を参照してください。"

#. type: Plain text
#: original_texis/symbols.texi:98
msgid "The function cell holds a symbol's function definition.  Often, we refer to ``the function @code{foo}'' when we really mean the function stored in the function cell of @code{foo}; we make the distinction explicit only when necessary.  Typically, the function cell is used to hold a function (@pxref{Functions}) or a macro (@pxref{Macros}).  However, it can also be used to hold a symbol (@pxref{Function Indirection}), keyboard macro (@pxref{Keyboard Macros}), keymap (@pxref{Keymaps}), or autoload object (@pxref{Autoloading}).  To get the contents of a symbol's function cell, use the function @code{symbol-function} (@pxref{Function Cells})."
msgstr "関数セルはシンボルの関数定義を保持します。実際はには@code{foo}の関数セルの中に保管されている関数を意味するときに、``関数@code{foo}''といってそれを参照することがよくあります。わたしたちは必要なときだけ、これを明確に区別することにします。関数セルは通常は関数(@ref{Functions}を参照)か、マクロ(@ref{Macros}を参照)を保持するために使用されます。しかし関数セルはシンボル(@ref{Function Indirection}を参照)、キーボードマクロ(@ref{Keyboard Macros}を参照)、キーマップ(@ref{Keymaps}を参照)、またはオートロードオブジェクト(@ref{Autoloading}を参照)を保持するためにも使用できます。シンボルの関数セルの内容を得るには、関数@code{symbol-function} (@ref{Function Cells}を参照)を使用します。"

#. type: Plain text
#: original_texis/symbols.texi:102
msgid "The property list cell normally should hold a correctly formatted property list.  To get a symbol's property list, use the function @code{symbol-plist}.  @xref{Symbol Properties}."
msgstr "プロパティリストのセルは、通常は正しくフォーマットされたプロパティリストを保持するべきです。シンボルのプロパティリストを得るには関数@code{symbol-plist}を使用します。@ref{Symbol Properties}を参照してください。"

#. type: Plain text
#: original_texis/symbols.texi:108
msgid "The function cell or the value cell may be @dfn{void}, which means that the cell does not reference any object.  (This is not the same thing as holding the symbol @code{void}, nor the same as holding the symbol @code{nil}.)  Examining a function or value cell that is void results in an error, such as @samp{Symbol's value as variable is void}."
msgstr "マクロセルと値セルが@dfn{void(空)}のときもあります。voidとはそのセルがどのオブジェクトも参照していないことを意味します(これはシンボル@code{void}を保持するのともシンボル@code{nil}を保持するのとも異なる)。voidの関数セルまたは値セルを調べようとすると結果は@samp{Symbol's value as variable is void}のようなエラーとなります。"

#. type: Plain text
#: original_texis/symbols.texi:114
msgid "Because each symbol has separate value and function cells, variables names and function names do not conflict.  For example, the symbol @code{buffer-file-name} has a value (the name of the file being visited in the current buffer) as well as a function definition (a primitive function that returns the name of the file):"
msgstr "各シンボルは値セルと関数セルを別個にもつので、変数名と関数名が衝突することはありません。たとえばシンボル@code{buffer-file-name}が値(カレントバッファーでvisitされているファイルの名前)をもつと同様に、関数定義(ファイルの名前をリターンするプリミティブ関数)をもつことができます:"

#. type: example
#: original_texis/symbols.texi:120
#, no-wrap
msgid ""
"buffer-file-name\n"
"     @result{} \"/gnu/elisp/symbols.texi\"\n"
"(symbol-function 'buffer-file-name)\n"
"     @result{} #<subr buffer-file-name>\n"
msgstr ""
"buffer-file-name\n"
"     @result{} \"/gnu/elisp/symbols.texi\"\n"
"(symbol-function 'buffer-file-name)\n"
"     @result{} #<subr buffer-file-name>\n"

#. type: section
#: original_texis/symbols.texi:123
#, no-wrap
msgid "Defining Symbols"
msgstr "Defining Symbols"

#. type: cindex
#: original_texis/symbols.texi:124
#, no-wrap
msgid "definitions of symbols"
msgstr "definitions of symbols"

#. type: Plain text
#: original_texis/symbols.texi:132
msgid "A @dfn{definition} is a special kind of Lisp expression that announces your intention to use a symbol in a particular way.  It typically specifies a value or meaning for the symbol for one kind of use, plus documentation for its meaning when used in this way.  Thus, when you define a symbol as a variable, you can supply an initial value for the variable, plus documentation for the variable."
msgstr "@dfn{定義(definition)}とは、特別な方法での使用の意図を宣言する特別な種類のLisp式です。定義とは通常はシンボルにたいする値を指定するか、シンボルにたいする1つの種類の使用についての意味とその方法で使用する際のシンボルの意味のドキュメントを指定します。したがってシンボルを変数として定義すると、その変数の初期値に加えてその変数のドキュメントを提供できます。"

#. type: Plain text
#: original_texis/symbols.texi:139
msgid "@code{defvar} and @code{defconst} are special forms that define a symbol as a @dfn{global variable}---a variable that can be accessed at any point in a Lisp program.  @xref{Variables}, for details about variables.  To define a customizable variable, use the @code{defcustom} macro, which also calls @code{defvar} as a subroutine (@pxref{Customization})."
msgstr "@code{defvar}と@code{defconst}は@dfn{グローバル変数(global variable)} --- Lispプログラムの任意の箇所からアクセスできる変数 --- として定義するためのスペシャルフォームです。変数についての詳細は@ref{Variables}を参照してください。カスタマイズ可能な変数を定義するには@code{defcustom} (サブルーチンとして@code{defvar}も呼び出す)を使用します(@ref{Customization}を参照)。"

#. type: Plain text
#: original_texis/symbols.texi:146
msgid "In principle, you can assign a variable value to any symbol with @code{setq}, whether or not it has first been defined as a variable.  However, you ought to write a variable definition for each global variable that you want to use; otherwise, your Lisp program may not act correctly if it is evaluated with lexical scoping enabled (@pxref{Variable Scoping})."
msgstr "最初にシンボルが変数として定義されているかどうかに関わらず、原則として@code{setq}で任意のシンボルに値を割り当てることができます。しかし使用したいグローバル変数それぞれにたいして変数定義を記述するべきです。さもないとレキシカルスコープ(@ref{Variable Scoping}を参照)が有効なときに変数が評価されると、Lispプログラムが正しく動作しないかもしれません。"

#. type: Plain text
#: original_texis/symbols.texi:154
msgid "@code{defun} defines a symbol as a function, creating a lambda expression and storing it in the function cell of the symbol.  This lambda expression thus becomes the function definition of the symbol.  (The term ``function definition'', meaning the contents of the function cell, is derived from the idea that @code{defun} gives the symbol its definition as a function.)  @code{defsubst} and @code{defalias} are two other ways of defining a function.  @xref{Functions}."
msgstr "@code{defun}はラムダ式(lambda expression)を生成して、そのシンボルの関数セルに格納することにより、そのシンボルを関数として定義します。したがってこのシンボルの関数定義は、そのラムダ式になります(関数セルの内容を意味する用語``関数定義(function definition)''は、@code{defun}がシンボルに関数としての定義を与えるというアイデアに由来する)。@ref{Functions}を参照してください。"

#. type: Plain text
#: original_texis/symbols.texi:161
msgid "@code{defmacro} defines a symbol as a macro.  It creates a macro object and stores it in the function cell of the symbol.  Note that a given symbol can be a macro or a function, but not both at once, because both macro and function definitions are kept in the function cell, and that cell can hold only one Lisp object at any given time.  @xref{Macros}."
msgstr "@code{defmacro}はシンボルをマクロとして定義します。これはマクロオブジェクトを作成してシンボルの関数セルにそれを格納します。シンボルにはマクロと関数を与えることができますが、マクロと関数定義はどちらも関数セルに保持されるのにたいし、関数セルに保持できるのは常にただ1つのLispオブジェクトなので、一度に両方を行なうことはできないことに注意してください。@ref{Macros}を参照してください。"

#. type: Plain text
#: original_texis/symbols.texi:165
msgid "As previously noted, Emacs Lisp allows the same symbol to be defined both as a variable (e.g., with @code{defvar}) and as a function or macro (e.g., with @code{defun}).  Such definitions do not conflict."
msgstr "前に注記したようにEmacs Lispではシンボルを(たとえば@code{defvar}で)変数として定義して、同じシンボルを(たとえば@code{defun}で)関数やマクロとして両方定義することができます。このような定義は衝突しません。"

#. type: Plain text
#: original_texis/symbols.texi:170
msgid "These definitions also act as guides for programming tools.  For example, the @kbd{C-h f} and @kbd{C-h v} commands create help buffers containing links to the relevant variable, function, or macro definitions.  @xref{Name Help,,, emacs, The GNU Emacs Manual}."
msgstr "これらの定義は、プログラミングツールのガイドを果たすこともできます。たとえば、@kbd{C-h f}および@kbd{C-h v}コマンドは、関係ある変数、関数、マクロ定義へのリンクを含むヘルプバッファーを作成します。@ref{Name Help,,, emacs, The GNU Emacs Manual}を参照してください。"

#. type: section
#: original_texis/symbols.texi:172
#, no-wrap
msgid "Creating and Interning Symbols"
msgstr "Creating and Interning Symbols"

#. type: cindex
#: original_texis/symbols.texi:173
#, no-wrap
msgid "reading symbols"
msgstr "reading symbols"

#. type: Plain text
#: original_texis/symbols.texi:179
msgid "To understand how symbols are created in GNU Emacs Lisp, you must know how Lisp reads them.  Lisp must ensure that it finds the same symbol every time it reads the same sequence of characters in the same context.  Failure to do so would cause complete confusion."
msgstr "GNU Emacs Lispでシンボルが作成される方法を理解するには、Lispがシンボルを読み取る方法を理解しなければなりません。Lispは同じコンテキストで同じ文字シーケンスを読み取ったら、毎回同じシンボルを見つけることを保証しなければなりません。これに失敗すると、完全な混乱を招くでしょう。"

#. type: cindex
#: original_texis/symbols.texi:180
#, no-wrap
msgid "symbol name hashing"
msgstr "symbol name hashing"

#. type: cindex
#: original_texis/symbols.texi:181
#, no-wrap
msgid "hashing"
msgstr "hashing"

#. type: defvar
#: original_texis/symbols.texi:182 original_texis/symbols.texi:377
#, no-wrap
msgid "obarray"
msgstr "obarray"

#. type: cindex
#: original_texis/symbols.texi:183
#, no-wrap
msgid "bucket (in obarray)"
msgstr "bucket (in obarray)"

#. type: Plain text
#: original_texis/symbols.texi:198
msgid "When the Lisp reader encounters a name that references a symbol in the source code, it reads all the characters of that name.  Then it looks up that name in a table called an @dfn{obarray} to find the symbol that the programmer meant.  The technique used in this lookup is called ``hashing'', an efficient method of looking something up by converting a sequence of characters to a number, known as a ``hash code''.  For example, instead of searching a telephone book cover to cover when looking up Jan Jones, you start with the J's and go from there.  That is a simple version of hashing.  Each element of the obarray is a @dfn{bucket} which holds all the symbols with a given hash code; to look for a given name, it is sufficient to look through all the symbols in the bucket for that name's hash code.  (The same idea is used for general Emacs hash tables, but they are a different data type; see @ref{Hash Tables}.)"
msgstr "ソースコード内でシンボルを参照する名前に出会うと、Lispリーダーはその名前の文字すべてを読み取ります。それからプログラマーが意図したシンボルを見つけるために、@dfn{obarray(オブジェクト配列)}と呼ばれるテーブルでその名前を照合します。この照合に使用されるテクニックは``ハッシュ化(hashing)''と呼ばれています。これは照合を行う際に文字シーケンスを``ハッシュコード(hash code)''として知られる数値に変換する効率的な手法です。たとえばJan Jonesを見つけるときは、電話帳を表紙から1頁ずつ探すのではなくJの頁から探し始めます。これはハッシュ化の簡単なバージョンです。obarrayの各要素は与えられたハッシュコードとともに、すべてのシンボルを保持する@dfn{バケット(bucket)}です。与えられた名前を探すためには、バケットの中からハッシュコードがその名前であるような、すべてのシンボルを探すのが効果的です(同じアイデアは一般的なEmacsのハッシュテーブルでも使用されていがこれらはデータ型が異なる。@ref{Hash Tables}を参照されたい)。"

#. type: Plain text
#: original_texis/symbols.texi:208
msgid "When looking up names, the Lisp reader also considers ``shorthands''.  If the programmer supplied them, this allows the reader to find a symbol even if its name isn't present in its full form in the source code.  Of course, the reader needs to be aware of some pre-established context about such shorthands, much as one needs context to be to able to refer uniquely to Jan Jones by just the name ``Jan'': it's probably fine when amongst the Joneses, or when Jan has been mentioned recently, but very ambiguous in any other situation.  @xref{Shorthands}."
msgstr "Lispリーダーは名前の照合時には``ショートハンド(shorthands 速記、簡略表記)''も考慮します。プログラマーがショートハンドを提供した場合には、たとえソースコード内でシンボル名が完全な形式で与えられなくても、リーダーはシンボルを見つけることができます。もちろんリーダーはそのようなショートハンドに関して事前に既定されたコンテキストを認識する必要があり、同様に``Jan''という名前だけでJan Jonesを一意に参照できるコンテキストが必要です。これはJonesの中にいるときや、Janが最近言及されていれば問題はないでしょうが、他の状況下では非常に曖昧です。@ref{Shorthands}を参照してください。"

#. type: cindex
#: original_texis/symbols.texi:209
#, no-wrap
msgid "interning"
msgstr "interning"

#. type: Plain text
#: original_texis/symbols.texi:215
msgid "If a symbol with the desired name is found, the reader uses that symbol.  If the obarray does not contain a symbol with that name, the reader makes a new symbol and adds it to the obarray.  Finding or adding a symbol with a certain name is called @dfn{interning} it, and the symbol is then called an @dfn{interned symbol}."
msgstr "探している名前のシンボルが見つかったら、リーダーはそのシンボルを使用します。obarrayにその名前のシンボルが含まれなければ、リーダーは新しいシンボルを作成してそれをobarrayに追加します。特定の名前のシンボルを探して追加することを@dfn{インターン(intern)}と言い、これが行なわれた後はそのシンボルは@dfn{インターンされたシンボル(interned symbol)}と呼ばれます。"

#. type: Plain text
#: original_texis/symbols.texi:220
msgid "Interning ensures that each obarray has just one symbol with any particular name.  Other like-named symbols may exist, but not in the same obarray.  Thus, the reader gets the same symbols for the same names, as long as you keep reading with the same obarray."
msgstr "インターンすることによりある特定の名前のシンボルは、各obarrayに1つだけであることが保証されます。同じ名前のシンボルが他に存在するかもしれませんが、同じobarrayには存在しません。したがってリーダーは、(同じobarrayを読みつづける限り)同じ名前にたいして同じシンボルを取得します。"

#. type: Plain text
#: original_texis/symbols.texi:229
msgid "Interning usually happens automatically in the reader, but sometimes other programs may want to do it.  For example, after the @kbd{M-x} command obtains the command name as a string using the minibuffer, it then interns the string, to get the interned symbol with that name.  As another example, a hypothetical telephone book program could intern the name of each looked up person's name as a symbol, even if the obarray did not contain it, so that it could attach information to that new symbol, such as the last time someone looked it up."
msgstr "インターンは通常はリーダー内で自動的に発生しますが、他のプログラムがこれを行ないたい場合もあるかもしれません。たとえば@kbd{M-x}コマンドはその後にミニバッファーを使用してコマンド名を文字列として取得して、その文字列をインターンしてからインターンされたその名前のシンボルを得ます。別の例として、照合する人名それぞれをシンボル名としてインターンする架空の電話帳プログラムは、たとえそれがobarrayに含まれていなくても、誰かが最後にそれを照合した際に情報をアタッチできるようにする場合などです。"

#. type: cindex
#: original_texis/symbols.texi:230
#, no-wrap
msgid "symbol equality"
msgstr "symbol equality"

#. type: cindex
#: original_texis/symbols.texi:231
#, no-wrap
msgid "uninterned symbol"
msgstr "uninterned symbol"

#. type: Plain text
#: original_texis/symbols.texi:238
msgid "No obarray contains all symbols; in fact, some symbols are not in any obarray.  They are called @dfn{uninterned symbols}.  An uninterned symbol has the same four cells as other symbols; however, the only way to gain access to it is by finding it in some other object or as the value of a variable.  Uninterned symbols are sometimes useful in generating Lisp code, see below."
msgstr "すべてのシンボルを含むobarrayはありません。実際にどのobarrayにも含まれないシンボルがいくつかあります。これらは@dfn{インターンされていないシンボル(uninterned symbols)}と呼ばれます。インターンされていないシンボルも、他のシンボルと同じく4つのセルをもちます。しかしインターンされていないシンボルへのアクセスを得る唯一の方法は、他の何らかのオブジェクトとして探すか、変数の値として探す方法だけです。インターンされていないシンボルはLispコード生成時に有用な場合があります。以下を参照してください。"

#. type: Plain text
#: original_texis/symbols.texi:246
msgid "In Emacs Lisp, an obarray is actually a vector.  Each element of the vector is a bucket; its value is either an interned symbol whose name hashes to that bucket, or 0 if the bucket is empty.  Each interned symbol has an internal link (invisible to the user) to the next symbol in the bucket.  Because these links are invisible, there is no way to find all the symbols in an obarray except using @code{mapatoms} (below).  The order of symbols in a bucket is not significant."
msgstr "Emacs Lispではobarrayはベクターです。ベクター内の各要素がバケットになります。要素の値は、名前がそのバケットにハッシュされるようなインターンされたシンボル、またはバケットが空のときは0です。インターンされたシンボルは、そのバケット内の次のシンボルへの内部リンク(ユーザーからは見えない)をもちます。これらのリンクは不可視なので、@code{mapatoms} (以下参照)を使用する方法をのぞき、obarray内のすべてのシンボルを探す方法はありません。バケット内のシンボルの順番に意味はありません。"

#. type: Plain text
#: original_texis/symbols.texi:252
msgid "In an empty obarray, every element is 0, so you can create an obarray with @code{(make-vector @var{length} 0)}.  @strong{This is the only valid way to create an obarray.} Prime numbers as lengths tend to result in good hashing; lengths one less than a power of two are also good."
msgstr "空のobarrayではすべての要素が0なので、@code{(make-vector @var{length} 0)}でobarrayを作成することができます。@strong{obarrayを作成する有効な方法はこれだけです。}長さに素数を指定するとよいハッシュ化がされる傾向があります。2の累乗から1減じた長さもよい結果を生む傾向があります。"

#. type: Plain text
#: original_texis/symbols.texi:255
msgid "@strong{Do not try to put symbols in an obarray yourself.} This does not work---only @code{intern} can enter a symbol in an obarray properly."
msgstr "@strong{自分でobarrayにシンボルを置かないでください。}これはうまくいきません --- obarrayに正しくシンボルを入力できるのは@code{intern}だけです。"

#. type: cindex
#: original_texis/symbols.texi:256
#, no-wrap
msgid "CL note---symbol in obarrays"
msgstr "CL note---symbol in obarrays"

#. type: quotation
#: original_texis/symbols.texi:263
msgid "@b{Common Lisp note:} Unlike Common Lisp, Emacs Lisp does not provide for interning the same name in several different ``packages'', thus creating multiple symbols with the same name but different packages.  Emacs Lisp provides a different namespacing system called ``shorthands'' (@pxref{Shorthands})."
msgstr "@b{Common Lispに関する注意:} Common Lispとは異なりEmacs Lispでは複数の異なる``パッケージ''における同一の名前のインターンは提供されていないので、異なるパッケージごとに同じ名前のシンボルが複数作成される。Emacs Lispは``ショートハンド''と呼ばれる別の名前空間システムを提供する(@ref{Shorthands}を参照)。"

#. type: Plain text
#: original_texis/symbols.texi:268
msgid "Most of the functions below take a name and sometimes an obarray as arguments.  A @code{wrong-type-argument} error is signaled if the name is not a string, or if the obarray is not a vector."
msgstr "以下の関数のほとんどは、引数に名前とobarrayをとります。名前が文字列以外、またはobarrayがベクター以外なら@code{wrong-type-argument}エラーがシグナルされます。"

#. type: defun
#: original_texis/symbols.texi:269
#, no-wrap
msgid "symbol-name symbol"
msgstr "symbol-name symbol"

#. type: defun
#: original_texis/symbols.texi:271
msgid "This function returns the string that is @var{symbol}'s name.  For example:"
msgstr "この関数は@var{symbol}の名前を文字列としてリターンする。たとえば:"

#. type: group
#: original_texis/symbols.texi:276
#, no-wrap
msgid ""
"(symbol-name 'foo)\n"
"     @result{} \"foo\"\n"
msgstr ""
"(symbol-name 'foo)\n"
"     @result{} \"foo\"\n"

#. type: defun
#: original_texis/symbols.texi:281
msgid "@strong{Warning:} Never alter the string returned by that function.  Doing that might make Emacs dysfunctional, and might even crash Emacs."
msgstr "@strong{警告:} この関数がリターンした文字列は絶対変更してはならない。これを行うことによってEmacsの機能が損なわれるかもしれず、Emacsのクラッシュすら招きかねない。"

#. type: cindex
#: original_texis/symbols.texi:283
#, no-wrap
msgid "uninterned symbol, and generating Lisp code"
msgstr "uninterned symbol, and generating Lisp code"

#. type: Plain text
#: original_texis/symbols.texi:287
msgid "Creating an uninterned symbol is useful in generating Lisp code, because an uninterned symbol used as a variable in the code you generate cannot clash with any variables used in other Lisp programs."
msgstr "インターンされていないシンボルの作成は、Lispコードを生成するとき有用です。なぜなら作成されたコード内で変数として使用されているインターンされていないシンボルは、他のLispプログラムで使用されている任意の変数と競合することはありえないからです。"

#. type: defun
#: original_texis/symbols.texi:288
#, no-wrap
msgid "make-symbol name"
msgstr "make-symbol name"

#. type: defun
#: original_texis/symbols.texi:294
msgid "This function returns a newly-allocated, uninterned symbol whose name is @var{name} (which must be a string).  Its value and function definition are void, and its property list is @code{nil}.  In the example below, the value of @code{sym} is not @code{eq} to @code{foo} because it is a distinct uninterned symbol whose name is also @samp{foo}."
msgstr "この関数は新たに割り当てられた、名前が@var{name}(文字列でなければならない)であるような、インターンされていないシンボルをリターンする。このシンボルの値と関数はvoidで、プロパティリストは@code{nil}。以下の例では@code{sym}の値は@code{foo}と@code{eq}ではない。なぜならこれは名前が@samp{foo}という、インターンされていないシンボルだからである。"

#. type: example
#: original_texis/symbols.texi:300
#, no-wrap
msgid ""
"(setq sym (make-symbol \"foo\"))\n"
"     @result{} foo\n"
"(eq sym 'foo)\n"
"     @result{} nil\n"
msgstr ""
"(setq sym (make-symbol \"foo\"))\n"
"     @result{} foo\n"
"(eq sym 'foo)\n"
"     @result{} nil\n"

#. type: defun
#: original_texis/symbols.texi:303
#, no-wrap
msgid "gensym &optional prefix"
msgstr "gensym &optional prefix"

#. type: defun
#: original_texis/symbols.texi:309
msgid "This function returns a symbol using @code{make-symbol}, whose name is made by appending @code{gensym-counter} to @var{prefix} and incrementing that counter, guaranteeing that no two calls to this function will generate a symbol with the same name.  The prefix defaults to @code{\"g\"}."
msgstr "この関数は@code{make-symbol}を使用して@var{prefix}に@code{gensym-counter}を付加した名前のシンボルをリターンする。更にこの関数を複数回呼び出しても同一名のシンボルが生成されないことを保証するためにカウンターを増加する。プレフィックスのデフォルトは@code{\"g\"}。"

#. type: Plain text
#: original_texis/symbols.texi:314
msgid "To avoid problems when accidentally interning printed representation of generated code (@pxref{Printed Representation}), it is recommended to use @code{gensym} instead of @code{make-symbol}."
msgstr "意図せず生成したコードのプリント表現をインターンした際の問題を避けるために、@code{make-symbol}ではなく@code{gensym}の使用をお勧めします。(@ref{Printed Representation}を参照)。"

#. type: defun
#: original_texis/symbols.texi:315
#, no-wrap
msgid "intern name &optional obarray"
msgstr "intern name &optional obarray"

#. type: defun
#: original_texis/symbols.texi:321
msgid "This function returns the interned symbol whose name is @var{name}.  If there is no such symbol in the obarray @var{obarray}, @code{intern} creates a new one, adds it to the obarray, and returns it.  If @var{obarray} is omitted, the value of the global variable @code{obarray} is used."
msgstr "この関数は名前が@var{name}であるような、インターンされたシンボルをリターンする。オブジェクト配列@var{obarray}の中にそのようなシンボルが存在しなければ、@code{intern}は新たにシンボルを作成してobarrayに追加してそれをリターンする。@var{obarray}が省略されると、グローバル変数@code{obarray}の値が使用される。"

#. type: example
#: original_texis/symbols.texi:327
#, no-wrap
msgid ""
"(setq sym (intern \"foo\"))\n"
"     @result{} foo\n"
"(eq sym 'foo)\n"
"     @result{} t\n"
"\n"
msgstr ""
"(setq sym (intern \"foo\"))\n"
"     @result{} foo\n"
"(eq sym 'foo)\n"
"     @result{} t\n"
"\n"

#. type: example
#: original_texis/symbols.texi:332
#, no-wrap
msgid ""
"(setq sym1 (intern \"foo\" other-obarray))\n"
"     @result{} foo\n"
"(eq sym1 'foo)\n"
"     @result{} nil\n"
msgstr ""
"(setq sym1 (intern \"foo\" other-obarray))\n"
"     @result{} foo\n"
"(eq sym1 'foo)\n"
"     @result{} nil\n"

#. type: cindex
#: original_texis/symbols.texi:335
#, no-wrap
msgid "CL note---interning existing symbol"
msgstr "CL note---interning existing symbol"

#. type: quotation
#: original_texis/symbols.texi:340
msgid "@b{Common Lisp note:} In Common Lisp, you can intern an existing symbol in an obarray.  In Emacs Lisp, you cannot do this, because the argument to @code{intern} must be a string, not a symbol."
msgstr "@b{Common Lispに関する注意: }Common Lispでは既存のシンボルをobarrayにインターンできる。Emacs Lispでは@code{intern}の引数はシンボルではなく文字列なのでこれを行なうことはできない。"

#. type: defun
#: original_texis/symbols.texi:342
#, no-wrap
msgid "intern-soft name &optional obarray"
msgstr "intern-soft name &optional obarray"

#. type: defun
#: original_texis/symbols.texi:348
msgid "This function returns the symbol in @var{obarray} whose name is @var{name}, or @code{nil} if @var{obarray} has no symbol with that name.  Therefore, you can use @code{intern-soft} to test whether a symbol with a given name is already interned.  If @var{obarray} is omitted, the value of the global variable @code{obarray} is used."
msgstr "この関数は@var{obarray}内の名前が@var{name}のシンボル、@var{obarray}にその名前のシンボルが存在しなければ@code{nil}をリターンする。したがって与えられた名前のシンボルがすでにインターンされているかテストするために、@code{intern-soft}を使用することができる。@var{obarray}が省略されるとグローバル変数@code{obarray}の値が使用される。"

#. type: defun
#: original_texis/symbols.texi:352
msgid "The argument @var{name} may also be a symbol; in that case, the function returns @var{name} if @var{name} is interned in the specified obarray, and otherwise @code{nil}."
msgstr "引数@var{name}にはシンボルも使用できる。この場合、指定されたobarrayに@var{name}がインターンされていれば@var{name}、それ以外なら@code{nil}をリターンする。"

#. type: example
#: original_texis/symbols.texi:358
#, no-wrap
msgid ""
"(intern-soft \"frazzle\")        ; @r{No such symbol exists.}\n"
"     @result{} nil\n"
"(make-symbol \"frazzle\")        ; @r{Create an uninterned one.}\n"
"     @result{} frazzle\n"
msgstr ""
"(intern-soft \"frazzle\")        ; @r{そのようなシンボルは存在しない}\n"
"     @result{} nil\n"
"(make-symbol \"frazzle\")        ; @r{インターンされていないシンボルを作成する}\n"
"     @result{} frazzle\n"

#. type: group
#: original_texis/symbols.texi:361
#, no-wrap
msgid ""
"(intern-soft \"frazzle\")        ; @r{That one cannot be found.}\n"
"     @result{} nil\n"
msgstr ""
"(intern-soft \"frazzle\")        ; @r{そのようなシンボルは見つからない}\n"
"     @result{} nil\n"

#. type: group
#: original_texis/symbols.texi:365
#, no-wrap
msgid ""
"(setq sym (intern \"frazzle\"))  ; @r{Create an interned one.}\n"
"     @result{} frazzle\n"
msgstr ""
"(setq sym (intern \"frazzle\"))  ; @r{インターンされたシンボルを作成する}\n"
"     @result{} frazzle\n"

#. type: group
#: original_texis/symbols.texi:369
#, no-wrap
msgid ""
"(intern-soft \"frazzle\")        ; @r{That one can be found!}\n"
"     @result{} frazzle\n"
msgstr ""
"(intern-soft \"frazzle\")        ; @r{シンボルが見つかった!}\n"
"     @result{} frazzle\n"

#. type: group
#: original_texis/symbols.texi:373
#, no-wrap
msgid ""
"(eq sym 'frazzle)              ; @r{And it is the same one.}\n"
"     @result{} t\n"
msgstr ""
"(eq sym 'frazzle)              ; @r{そしてそれは同じシンボル}\n"
"     @result{} t\n"

#. type: defvar
#: original_texis/symbols.texi:380
msgid "This variable is the standard obarray for use by @code{intern} and @code{read}."
msgstr "この変数は@code{intern}と@code{read}が使用する標準のobarrayである。"

#. type: defun
#: original_texis/symbols.texi:382
#, no-wrap
msgid "mapatoms function &optional obarray"
msgstr "mapatoms function &optional obarray"

#. type: anchor{#1}
#: original_texis/symbols.texi:388
msgid "Definition of mapatoms"
msgstr "Definition of mapatoms"

#. type: defun
#: original_texis/symbols.texi:388
msgid "This function calls @var{function} once with each symbol in the obarray @var{obarray}.  Then it returns @code{nil}.  If @var{obarray} is omitted, it defaults to the value of @code{obarray}, the standard obarray for ordinary symbols."
msgstr "この関数はオブジェクト配列@var{obarray}の中の各シンボルにたいして、@var{function}を一度呼び出しその後@code{nil}をリターンする。@var{obarray}が省略されると、通常のシンボルにたいする標準のオブジェクト配列@code{obarray}の値がデフォルトになる。"

#. type: example
#: original_texis/symbols.texi:399
#, no-wrap
msgid ""
"(setq count 0)\n"
"     @result{} 0\n"
"(defun count-syms (s)\n"
"  (setq count (1+ count)))\n"
"     @result{} count-syms\n"
"(mapatoms 'count-syms)\n"
"     @result{} nil\n"
"count\n"
"     @result{} 1871\n"
msgstr ""
"(setq count 0)\n"
"     @result{} 0\n"
"(defun count-syms (s)\n"
"  (setq count (1+ count)))\n"
"     @result{} count-syms\n"
"(mapatoms 'count-syms)\n"
"     @result{} nil\n"
"count\n"
"     @result{} 1871\n"

#. type: defun
#: original_texis/symbols.texi:403
msgid "See @code{documentation} in @ref{Accessing Documentation}, for another example using @code{mapatoms}."
msgstr "@code{mapatoms}を使用する他の例については、@ref{Accessing Documentation}の@code{documentation}を参照のこと。"

#. type: defun
#: original_texis/symbols.texi:405
#, no-wrap
msgid "unintern symbol obarray"
msgstr "unintern symbol obarray"

#. type: defun
#: original_texis/symbols.texi:409
msgid "This function deletes @var{symbol} from the obarray @var{obarray}.  If @code{symbol} is not actually in the obarray, @code{unintern} does nothing.  If @var{obarray} is @code{nil}, the current obarray is used."
msgstr "この関数はオブジェクト配列@var{obarray}から@var{symbol}を削除する。obarrayの中に@code{symbol}が存在しなければ、@code{unintern}は何も行なわない。@var{obarray}が@code{nil}なら現在のobarrayが使用される。"

#. type: defun
#: original_texis/symbols.texi:414
msgid "If you provide a string instead of a symbol as @var{symbol}, it stands for a symbol name.  Then @code{unintern} deletes the symbol (if any) in the obarray which has that name.  If there is no such symbol, @code{unintern} does nothing."
msgstr "@var{symbol}にシンボルではなく文字列を与えると、それはシンボルの名前を意味する。この場合、@code{unintern}は(もしあれば)obarrayからその名前のシンボルを削除する。そのようなシンボルが存在するなら@code{unintern}は何も行なわない。"

#. type: defun
#: original_texis/symbols.texi:417
msgid "If @code{unintern} does delete a symbol, it returns @code{t}.  Otherwise it returns @code{nil}."
msgstr "@code{unintern}がシンボルを削除したら@code{t}、それ以外は@code{nil}をリターンする。"

#. type: cindex
#: original_texis/symbols.texi:421
#, no-wrap
msgid "symbol property"
msgstr "symbol property"

#. type: Plain text
#: original_texis/symbols.texi:428
msgid "A symbol may possess any number of @dfn{symbol properties}, which can be used to record miscellaneous information about the symbol.  For example, when a symbol has a @code{risky-local-variable} property with a non-@code{nil} value, that means the variable which the symbol names is a risky file-local variable (@pxref{File Local Variables})."
msgstr "シンボルはそのシンボルについての様々な情報を記録するために使用される、任意の数の@dfn{シンボルプロパティ(symbol properties)}をもつことができます。たとえばシンボルの@code{risky-local-variable}プロパティが@code{nil}なら、その変数の名前が危険なファイルローカル変数(@ref{File Local Variables}を参照)であることを意味します。"

#. type: Plain text
#: original_texis/symbols.texi:432
msgid "Each symbol's properties and property values are stored in the symbol's property list cell (@pxref{Symbol Components}), in the form of a property list (@pxref{Property Lists})."
msgstr "シンボルのプロパティとプロパティ値はそれぞれ、シンボルのプロパティリストセル(@ref{Symbol Components}を参照)に、プロパティリスト形式(@ref{Property Lists}を参照)で格納されます。"

#. type: node
#: original_texis/symbols.texi:436 original_texis/symbols.texi:438
#, no-wrap
msgid "Symbol Plists"
msgstr "Symbol Plists"

#. type: menuentry
#: original_texis/symbols.texi:436
msgid "Accessing symbol properties."
msgstr "シンボルプロパティへのアクセス。"

#. type: node
#: original_texis/symbols.texi:436 original_texis/symbols.texi:522
#, no-wrap
msgid "Standard Properties"
msgstr "Standard Properties"

#. type: menuentry
#: original_texis/symbols.texi:436
msgid "Standard meanings of symbol properties."
msgstr "シンボルプロパティの標準的な意味。"

#. type: subsection
#: original_texis/symbols.texi:439
#, no-wrap
msgid "Accessing Symbol Properties"
msgstr "Accessing Symbol Properties"

#. type: Plain text
#: original_texis/symbols.texi:442
msgid "The following functions can be used to access symbol properties."
msgstr "以下の関数を使用してシンボルプロパティにアクセスできます。"

#. type: defun
#: original_texis/symbols.texi:443
#, no-wrap
msgid "get symbol property"
msgstr "get symbol property"

#. type: defun
#: original_texis/symbols.texi:448
msgid "This function returns the value of the property named @var{property} in @var{symbol}'s property list.  If there is no such property, it returns @code{nil}.  Thus, there is no distinction between a value of @code{nil} and the absence of the property."
msgstr "この関数は@var{symbol}のプロパティリスト内の、名前が@var{property}というプロパティの値をリターンする。そのようなプロパティが存在しなければ@code{nil}をリターンする。したがって値が@code{nil}のときとプロパティが存在しないときの違いはない。"

#. type: defun
#: original_texis/symbols.texi:451
msgid "The name @var{property} is compared with the existing property names using @code{eq}, so any object is a legitimate property."
msgstr "名前@var{property}は@code{eq}を使用して既存のプロパティと比較されるので、すべてのオブジェクトがプロパティとして適正である。"

#. type: defun
#: original_texis/symbols.texi:453
msgid "See @code{put} for an example."
msgstr "@code{put}の例を参照のこと。"

#. type: defun
#: original_texis/symbols.texi:455
#, no-wrap
msgid "put symbol property value"
msgstr "put symbol property value"

#. type: defun
#: original_texis/symbols.texi:459
msgid "This function puts @var{value} onto @var{symbol}'s property list under the property name @var{property}, replacing any previous property value.  The @code{put} function returns @var{value}."
msgstr "この関数は@var{symbol}のプロパティリストの、プロパティ名@var{property}に@var{value}をputして、前のプロパティ値を置き換える。@code{put}関数は@var{value}をリターンする。"

#. type: example
#: original_texis/symbols.texi:469
#, no-wrap
msgid ""
"(put 'fly 'verb 'transitive)\n"
"     @result{}'transitive\n"
"(put 'fly 'noun '(a buzzing little bug))\n"
"     @result{} (a buzzing little bug)\n"
"(get 'fly 'verb)\n"
"     @result{} transitive\n"
"(symbol-plist 'fly)\n"
"     @result{} (verb transitive noun (a buzzing little bug))\n"
msgstr ""
"(put 'fly 'verb 'transitive)\n"
"     @result{}'transitive\n"
"(put 'fly 'noun '(a buzzing little bug))\n"
"     @result{} (a buzzing little bug)\n"
"(get 'fly 'verb)\n"
"     @result{} transitive\n"
"(symbol-plist 'fly)\n"
"     @result{} (verb transitive noun (a buzzing little bug))\n"

#. type: defun
#: original_texis/symbols.texi:472
#, no-wrap
msgid "symbol-plist symbol"
msgstr "symbol-plist symbol"

#. type: defun
#: original_texis/symbols.texi:474
msgid "This function returns the property list of @var{symbol}."
msgstr "この関数は@var{symbol}のプロパティリストをリターンする。"

#. type: defun
#: original_texis/symbols.texi:476
#, no-wrap
msgid "setplist symbol plist"
msgstr "setplist symbol plist"

#. type: defun
#: original_texis/symbols.texi:480
msgid "This function sets @var{symbol}'s property list to @var{plist}.  Normally, @var{plist} should be a well-formed property list, but this is not enforced.  The return value is @var{plist}."
msgstr "この関数は@var{symbol}のプロパティリストを@var{plist}にセットする。@var{plist}は通常は適正なプロパティリストであるべきだが、これは強制ではない。リターン値は@var{plist}です。"

#. type: example
#: original_texis/symbols.texi:486
#, no-wrap
msgid ""
"(setplist 'foo '(a 1 b (2 3) c nil))\n"
"     @result{} (a 1 b (2 3) c nil)\n"
"(symbol-plist 'foo)\n"
"     @result{} (a 1 b (2 3) c nil)\n"
msgstr ""
"(setplist 'foo '(a 1 b (2 3) c nil))\n"
"     @result{} (a 1 b (2 3) c nil)\n"
"(symbol-plist 'foo)\n"
"     @result{} (a 1 b (2 3) c nil)\n"

#. type: defun
#: original_texis/symbols.texi:492
msgid "For symbols in special obarrays, which are not used for ordinary purposes, it may make sense to use the property list cell in a nonstandard fashion; in fact, the abbrev mechanism does so (@pxref{Abbrevs})."
msgstr "通常の用途には使用されない特別なobarray内のシンボルでは、非標準的な方法でプロパティリストセルを使用することに意味があるかもしれない。実際にabbrev(@ref{Abbrevs}を参照)のメカニズムでこれを行なっている。"

#. type: defun
#: original_texis/symbols.texi:495
msgid "You could define @code{put} in terms of @code{setplist} and @code{plist-put}, as follows:"
msgstr "以下のように@code{setplist}と@code{plist-put}で@code{put}を定義できる:"

#. type: example
#: original_texis/symbols.texi:500
#, no-wrap
msgid ""
"(defun put (symbol prop value)\n"
"  (setplist symbol\n"
"            (plist-put (symbol-plist symbol) prop value)))\n"
msgstr ""
"(defun put (symbol prop value)\n"
"  (setplist symbol\n"
"            (plist-put (symbol-plist symbol) prop value)))\n"

#. type: defun
#: original_texis/symbols.texi:503
#, no-wrap
msgid "function-get symbol property &optional autoload"
msgstr "function-get symbol property &optional autoload"

#. type: defun
#: original_texis/symbols.texi:512
msgid "This function is identical to @code{get}, except that if @var{symbol} is the name of a function alias, it looks in the property list of the symbol naming the actual function.  @xref{Defining Functions}.  If the optional argument @var{autoload} is non-@code{nil}, and @var{symbol} is auto-loaded, this function will try to autoload it, since autoloading might set @var{property} of @var{symbol}.  If @var{autoload} is the symbol @code{macro}, only try autoloading if @var{symbol} is an auto-loaded macro."
msgstr "この関数は@code{get}と等価だが@var{symbol}が関数のエイリアス名なら。実際の関数を命名するシンボルのプロパティリストを照合する点が異なる。@ref{Defining Functions}を参照のこと。オプション引数@var{autoload}が非@code{nil}で、@var{symbol}が自動ロードされていれば、その自動ロードにより@var{symbol}の@var{property}がセットされるかもしれないので、この関数はそれの自動ロードを試みるだろう。@var{autoload}がシンボル@code{macro}なら、@var{symbol}が自動ロードされたマクロのときだけ自動ロードを試みる。"

#. type: defun
#: original_texis/symbols.texi:514
#, no-wrap
msgid "function-put function property value"
msgstr "function-put function property value"

#. type: defun
#: original_texis/symbols.texi:520
msgid "This function sets @var{property} of @var{function} to @var{value}.  @var{function} should be a symbol.  This function is preferred to calling @code{put} for setting properties of a function, because it will allow us some day to implement remapping of old properties to new ones."
msgstr "この関数は@var{function}の@var{property}に@var{value}をセットする。@var{function}はシンボルであること。関数のプロパティのセットには、@code{put}よりこの関数を呼び出すほうがよい。この関数を使用すれば、いつか古いプロパティから新しいプロパティへのリマップを実装することができるからである。"

#. type: subsection
#: original_texis/symbols.texi:523
#, no-wrap
msgid "Standard Symbol Properties"
msgstr "Standard Symbol Properties"

#. type: Plain text
#: original_texis/symbols.texi:529
msgid "Here, we list the symbol properties which are used for special purposes in Emacs.  In the following table, whenever we say ``the named function'', that means the function whose name is the relevant symbol; similarly for ``the named variable'' etc."
msgstr "Emacsで特別な目的のために使用されるシンボルプロパティを以下に一覧します。以下のテーブルで、``命名される関数(the named function)''と言うときは、関数名がそのシンボルであるような関数を意味します。``命名される変数(the named variable)''等の場合も同様です。"

#. type: item
#: original_texis/symbols.texi:531
#, no-wrap
msgid ":advertised-binding"
msgstr ":advertised-binding"

#. type: table
#: original_texis/symbols.texi:534
msgid "This property value specifies the preferred key binding, when showing documentation, for the named function.  @xref{Keys in Documentation}."
msgstr "このプロパティリストは、命名される関数のドキュメントを表示する際に優先されるキーバインディングを指定する。@ref{Keys in Documentation}を参照のこと。"

#. type: item
#: original_texis/symbols.texi:535
#, no-wrap
msgid "char-table-extra-slots"
msgstr "char-table-extra-slots"

#. type: table
#: original_texis/symbols.texi:538
msgid "The value, if non-@code{nil}, specifies the number of extra slots in the named char-table type.  @xref{Char-Tables}."
msgstr "値が非@code{nil}なら、それは命名される文字テーブル型の追加スロットの数を指定する。@ref{Char-Tables}を参照のこと。"

#. type: item
#: original_texis/symbols.texi:539
#, no-wrap
msgid "customized-face"
msgstr "customized-face"

#. type: itemx
#: original_texis/symbols.texi:540
#, no-wrap
msgid "face-defface-spec"
msgstr "face-defface-spec"

#. type: itemx
#: original_texis/symbols.texi:541
#, no-wrap
msgid "saved-face"
msgstr "saved-face"

#. type: itemx
#: original_texis/symbols.texi:542
#, no-wrap
msgid "theme-face"
msgstr "theme-face"

#. type: table
#: original_texis/symbols.texi:547
msgid "These properties are used to record a face's standard, saved, customized, and themed face specs.  Do not set them directly; they are managed by @code{defface} and related functions.  @xref{Defining Faces}."
msgstr "これらのプロパティはフェイスの標準のフェイス仕様(face specs)と、フォント仕様のsaved-face、customized-face、themed-faceを記録するために使用される。これらのプロパティを直接セットしないこと。これらのプロパティは@code{defface}と関連する関数により管理される。@ref{Defining Faces}を参照のこと。"

#. type: item
#: original_texis/symbols.texi:548
#, no-wrap
msgid "customized-value"
msgstr "customized-value"

#. type: itemx
#: original_texis/symbols.texi:549
#, no-wrap
msgid "saved-value"
msgstr "saved-value"

#. type: itemx
#: original_texis/symbols.texi:550
#, no-wrap
msgid "standard-value"
msgstr "standard-value"

#. type: itemx
#: original_texis/symbols.texi:551
#, no-wrap
msgid "theme-value"
msgstr "theme-value"

#. type: table
#: original_texis/symbols.texi:556
msgid "These properties are used to record a customizable variable's standard value, saved value, customized-but-unsaved value, and themed values.  Do not set them directly; they are managed by @code{defcustom} and related functions.  @xref{Variable Definitions}."
msgstr "これらのプロパティは、カスタマイズ可能な変数のstandard-value、saved-value、customized-value(しかし保存はされない)、themed-valueを記録するために使用される。これらのプロパティを直接セットしないこと。これらは@code{defcustom}と関連する関数により管理される。@ref{Variable Definitions}を参照のこと。"

#. type: item
#: original_texis/symbols.texi:557
#, no-wrap
msgid "definition-name"
msgstr "definition-name"

#. type: table
#: original_texis/symbols.texi:573
msgid "This property is used to find the definition of a symbol in the source code, when it might be hard to find the definition by textual search of the source file.  For example, a @code{define-derived-mode} (@pxref{Derived Modes}) might define a mode-specific function or a variable implicitly; or your Lisp program might generate a run-time call to @code{defun} to define a function (@pxref{Defining Functions}).  In these and similar cases, the @code{definition-name} property of the symbol should be another symbol whose definition can be found by textual search and whose code defines the original symbol.  In the example with @code{define-derived-mode}, the value of this property of the functions and variables it defines should be the mode symbol.  The Emacs Help commands such as @kbd{C-h f} (@pxref{Help,,, emacs, The GNU Emacs Manual}) use this property to show the definition of a symbol via a button in the @file{*Help*} buffer where the symbol's documentation is shown."
msgstr "このプロパティはソースファイルのテキスト検索ではシンボルの定義を見つけるのが困難な際に、ソースコードから定義を見つけるために使用される。たとえば@code{define-derived-mode} (@ref{Derived Modes}を参照)によってモード固有の関数や変数が暗黙裡に定義されたのかもしれないし、Lispプログラム実行時に@code{defun}を呼び出して関数を定義したのかもしれない(@ref{Defining Functions}を参照)。このようなケースや類似したケースにおいては、そのシンボルの@code{definition-name}プロパティはテキスト検索によって検索可能な定義をもち、そのコードによって元のシンボルを定義するような別のシンボルであることが必要になる。@code{define-derived-mode}の例では、定義される関数および変数にたいするこのプロパティの値がモードシンボルであることが必要になる。@kbd{C-h f} (@ref{Help,,, emacs, The GNU Emacs Manual}を参照)のようなEmacsのヘルプコマンドでは、そのシンボルのドキュメントを表示する@file{*Help*}バッファーのボタンを通じてシンボルの定義を表示するためにこのプロパティが使用されている。"

#. type: item
#: original_texis/symbols.texi:574
#, no-wrap
msgid "disabled"
msgstr "disabled"

#. type: table
#: original_texis/symbols.texi:577
msgid "If the value is non-@code{nil}, the named function is disabled as a command.  @xref{Disabling Commands}."
msgstr "値が非@code{nil}なら命名される関数はコマンドとして無効になる。@ref{Disabling Commands}を参照のこと。"

#. type: item
#: original_texis/symbols.texi:578
#, no-wrap
msgid "face-documentation"
msgstr "face-documentation"

#. type: table
#: original_texis/symbols.texi:581
msgid "The value stores the documentation string of the named face.  This is set automatically by @code{defface}.  @xref{Defining Faces}."
msgstr "値には命名されるフェイスのドキュメント文字列が格納される。これは@code{defface}により自動的にセットされる。@ref{Defining Faces}を参照のこと。"

#. type: item
#: original_texis/symbols.texi:582
#, no-wrap
msgid "history-length"
msgstr "history-length"

#. type: table
#: original_texis/symbols.texi:586
msgid "The value, if non-@code{nil}, specifies the maximum minibuffer history length for the named history list variable.  @xref{Minibuffer History}."
msgstr "値が非@code{nil}なら、命名されるヒストリーリスト変数のミニバッファーヒストリーの最大長を指定する。@ref{Minibuffer History}を参照のこと。"

#. type: item
#: original_texis/symbols.texi:587
#, no-wrap
msgid "interactive-form"
msgstr "interactive-form"

#. type: table
#: original_texis/symbols.texi:591
msgid "The value is an interactive form for the named function.  Normally, you should not set this directly; use the @code{interactive} special form instead.  @xref{Interactive Call}."
msgstr "この値は命名される関数のインタラクティブ形式である。通常はこれを直接セットするべきではない。かわりにスペシャルフォーム@code{interactive}を使用すること。@ref{Interactive Call}を参照されたい。"

#. type: item
#: original_texis/symbols.texi:592
#, no-wrap
msgid "menu-enable"
msgstr "menu-enable"

#. type: table
#: original_texis/symbols.texi:595
msgid "The value is an expression for determining whether the named menu item should be enabled in menus.  @xref{Simple Menu Items}."
msgstr "この値は命名されるメニューアイテムが、メニュー内で有効であるべきか否かを決定するための式である。@ref{Simple Menu Items}を参照のこと。"

#. type: item
#: original_texis/symbols.texi:596
#, no-wrap
msgid "mode-class"
msgstr "mode-class"

#. type: table
#: original_texis/symbols.texi:599
msgid "If the value is @code{special}, the named major mode is special.  @xref{Major Mode Conventions}."
msgstr "値が@code{special}なら命名されるメジャーモードはspecial(特別)である。@ref{Major Mode Conventions}を参照のこと。"

#. type: item
#: original_texis/symbols.texi:600
#, no-wrap
msgid "permanent-local"
msgstr "permanent-local"

#. type: table
#: original_texis/symbols.texi:604
msgid "If the value is non-@code{nil}, the named variable is a buffer-local variable whose value should not be reset when changing major modes.  @xref{Creating Buffer-Local}."
msgstr "値が非@code{nil}なら命名される変数はバッファーローカル変数となり、メジャーモードの変更によって変数の値はリセットされない。@ref{Creating Buffer-Local}を参照のこと。"

#. type: item
#: original_texis/symbols.texi:605
#, no-wrap
msgid "permanent-local-hook"
msgstr "permanent-local-hook"

#. type: table
#: original_texis/symbols.texi:609
msgid "If the value is non-@code{nil}, the named function should not be deleted from the local value of a hook variable when changing major modes.  @xref{Setting Hooks}."
msgstr "値が非@code{nil}なら、命名される関数はメジャーモード変更時にフック変数のローカル値から削除されない。@ref{Setting Hooks}を参照のこと。"

#. type: item
#: original_texis/symbols.texi:610
#, no-wrap
msgid "pure"
msgstr "pure"

#. type: cindex
#: original_texis/symbols.texi:611
#, no-wrap
msgid "@code{pure} property"
msgstr "@code{pure} property"

#. type: table
#: original_texis/symbols.texi:617
msgid "If the value is non-@code{nil}, the named function is considered to be pure (@pxref{What Is a Function}).  Calls with constant arguments can be evaluated at compile time.  This may shift run time errors to compile time.  Not to be confused with pure storage (@pxref{Pure Storage})."
msgstr "値が非@code{nil}の場合には、名づけられた関数は純粋(pure)だとみなされる。定数の引数で呼び出された場合には、コンパイル時に評価することができる。これは実行時のエラーをコンパイル時へとシフトする。純粋ストレージ(pure storage)と混同しないこと(@ref{Pure Storage}を参照)。"

#. type: item
#: original_texis/symbols.texi:618
#, no-wrap
msgid "risky-local-variable"
msgstr "risky-local-variable"

#. type: table
#: original_texis/symbols.texi:621
msgid "If the value is non-@code{nil}, the named variable is considered risky as a file-local variable.  @xref{File Local Variables}."
msgstr "値が非@code{nil}なら、命名される変数はファイルローカル変数としては危険だとみなされる。@ref{File Local Variables}を参照のこと。"

#. type: item
#: original_texis/symbols.texi:622
#, no-wrap
msgid "safe-function"
msgstr "safe-function"

#. type: table
#: original_texis/symbols.texi:625
msgid "If the value is non-@code{nil}, the named function is considered generally safe for evaluation.  @xref{Function Safety}."
msgstr "値が非@code{nil}なら、命名される関数は評価において一般的に安全だとみなされます。@ref{Function Safety}を参照のこと。"

#. type: item
#: original_texis/symbols.texi:626
#, no-wrap
msgid "safe-local-eval-function"
msgstr "safe-local-eval-function"

#. type: table
#: original_texis/symbols.texi:629
msgid "If the value is non-@code{nil}, the named function is safe to call in file-local evaluation forms.  @xref{File Local Variables}."
msgstr "値が非@code{nil}なら、命名される関数はファイルローカルの評価フォーム内で安全に呼び出すことができる。@ref{File Local Variables}を参照のこと。"

#. type: item
#: original_texis/symbols.texi:630
#, no-wrap
msgid "safe-local-variable"
msgstr "safe-local-variable"

#. type: table
#: original_texis/symbols.texi:636
msgid "The value specifies a function for determining safe file-local values for the named variable.  @xref{File Local Variables}.  Since this value is consulted when loading files, the function should be efficient and should ideally not lead to loading any libraries to determine the safeness (e.g., it should not be an autoloaded function)."
msgstr "この値は命名される変数にたいして、ファイルローカル値が安全かを判断する関数を指定する。@ref{File Local Variables}を参照のこと。この値はファイルのロード時に参照されるので、指定する関数は効率的かつ安全性判断のために理想的にはライブラリーを何もロードしない(autoload関数にしない)ようにする必要がある。"

#. type: item
#: original_texis/symbols.texi:637
#, no-wrap
msgid "side-effect-free"
msgstr "side-effect-free"

#. type: cindex
#: original_texis/symbols.texi:638
#, no-wrap
msgid "@code{side-effect-free} property"
msgstr "@code{side-effect-free} property"

#. type: table
#: original_texis/symbols.texi:645
msgid "A non-@code{nil} value indicates that the named function is free of side effects (@pxref{What Is a Function}), so the byte compiler may ignore a call whose value is unused.  If the property's value is @code{error-free}, the byte compiler may even delete such unused calls.  In addition to byte compiler optimizations, this property is also used for determining function safety (@pxref{Function Safety})."
msgstr "非@code{nil}値は命名される関数が副作用(@ref{What Is a Function}を参照)をもたないことを示すので、バイトコンパイラーは値が使用されない呼び出しを無視する。このプロパティの値が@code{error-free}なら、バイトコンパイラーはそのような呼び出しの削除すら行うかもしれない。バイトコンパイラーの最適化に加えて、このプロパティは関数の安全性を判断するためにも使用される(@ref{Function Safety}を参照)。"

#. type: item
#: original_texis/symbols.texi:646
#, no-wrap
msgid "undo-inhibit-region"
msgstr "undo-inhibit-region"

#. type: table
#: original_texis/symbols.texi:650
msgid "If non-@code{nil}, the named function prevents the @code{undo} operation from being restricted to the active region, if @code{undo} is invoked immediately after the function.  @xref{Undo}."
msgstr "非@code{nil}の場合には、命名される関数の直後に@code{undo}が呼び出されると、@code{undo}操作をアクティブなリージョンに限定することを抑止する。@ref{Undo}を参照のこと。"

#. type: item
#: original_texis/symbols.texi:651
#, no-wrap
msgid "variable-documentation"
msgstr "variable-documentation"

#. type: table
#: original_texis/symbols.texi:655
msgid "If non-@code{nil}, this specifies the named variable's documentation string.  This is set automatically by @code{defvar} and related functions.  @xref{Defining Faces}."
msgstr "非@code{nil}なら、それは命名される変数のドキュメント文字列を指定する。ドキュメント文字列は@code{defvar}と関連する関数により自動的にセットされる。@ref{Defining Faces}を参照のこと。"

#. type: cindex
#: original_texis/symbols.texi:659
#, no-wrap
msgid "shorthands"
msgstr "shorthands"

#. type: cindex
#: original_texis/symbols.texi:660
#, no-wrap
msgid "symbolic shorthands"
msgstr "symbolic shorthands"

#. type: cindex
#: original_texis/symbols.texi:661
#, no-wrap
msgid "namespacing"
msgstr "namespacing"

#. type: cindex
#: original_texis/symbols.texi:662
#, no-wrap
msgid "namespaces"
msgstr "namespaces"

#. type: Plain text
#: original_texis/symbols.texi:669
msgid "The symbol @dfn{shorthands}, sometimes known as ``renamed symbols'', are symbolic forms found in Lisp source.  They're just like regular symbolic forms, except that when the Lisp reader encounters them, it produces symbols which have a different and usually longer @dfn{print name} (@pxref{Symbol Components})."
msgstr "``名前変更シンボル(renamed symbols)''と呼ばれることもあるシンボルの@dfn{ショートハンド(shorthands: 速記、簡略表記)}とは、Lispソースで目にする抽象形式です。これらは正規の抽象形式と類似していますが、Lispリーダーがそれらに遭遇した際に別の通常はもっと長い@dfn{プリント名(print name)}を生成する点が異なリます(@ref{Symbol Components}を参照)。"

#. type: Plain text
#: original_texis/symbols.texi:673
msgid "It is useful to think of shorthands as @emph{abbreviating} the full names of intended symbols.  Despite this, do not confuse shorthands with the Abbrev system (@pxref{Abbrevs})."
msgstr "ショートハンドを意図するシンボルの完全名にたいする@emph{略語(abbreviating)}と考えることは有益です。その点を除けばAbbrevシステム(@ref{Abbrevs}を参照)とショートハンドを混同しないでください。"

#. type: cindex
#: original_texis/symbols.texi:674
#, no-wrap
msgid "namespace etiquette"
msgstr "namespace etiquette"

#. type: Plain text
#: original_texis/symbols.texi:687
msgid "Shorthands make Emacs Lisp's @dfn{namespacing etiquette} easier to work with.  Since all symbols are stored in a single obarray (@pxref{Creating Symbols}), programmers commonly prefix each symbol name with the name of the library where it originates.  For example, the functions @code{text-property-search-forward} and @code{text-property-search-backward} both belong to the @file{text-property-search.el} library (@pxref{Loading}).  By properly prefixing symbol names, one effectively prevents clashes between similarly named symbols which belong to different libraries and thus do different things.  However, this practice commonly originates very long symbols names, which are inconvenient to type and read after a while.  Shorthands solve these issues in a clean way."
msgstr "ショートハンドによりEmacs Lispの@dfn{ネームスペース作法(namespacing etiquette)}にしたがうことが容易になります。すべてのシンボルは単一のobarray (@ref{Creating Symbols}を参照)に格納されるので、一般的にプログラマーはシンボル名それぞれにたいして出自ライブラリー名をプレフィクスとして付加します。たとえば関数@code{text-property-search-forward}と@code{text-property-search-backward}はどちらも@file{text-property-search.el}ライブラリーに属しています(@ref{Loading}を参照)。シンボル名に正しくプレフィクスを付加することによって、異なるライブラリーに属する別のことを行う同一名シンボル間でのクラッシュを効果的に回避できます。しかしこれを実践してしばらくすると、一般的にはタイプしにくく読み難い、非常に長いシンボル名となります。これらの問題をショートハンドは明快な方法により解決します。"

#. type: defvar
#: original_texis/symbols.texi:688
#, no-wrap
msgid "read-symbol-shorthands"
msgstr "read-symbol-shorthands"

#. type: defvar
#: original_texis/symbols.texi:694
msgid "This variable's value is an alist whose elements have the form @code{(@var{shorthand-prefix} . @var{longhand-prefix})}.  Each element instructs the Lisp reader to read every symbol form which starts with @var{shorthand-prefix} as if it started with @var{longhand-prefix} instead."
msgstr "この変数の値は要素が@code{(@var{shorthand-prefix} . @var{longhand-prefix})}という形式であるようなalist。それぞれの要素はLispリーダーにたいして、@var{shorthand-prefix}で始まるすべてのシンボルを、@var{longhand-prefix}で始まるシンボルとして読み取るよう指示する。"

#. type: defvar
#: original_texis/symbols.texi:697
msgid "This variable may only be set in file-local variables (@pxref{File Variables, , Local Variables in Files, emacs, The GNU Emacs Manual})."
msgstr "この変数はファイルローカル変数としてのみセットできる(@ref{File Variables, , Local Variables in Files, emacs, The GNU Emacs Manual}を参照)。"

#. type: Plain text
#: original_texis/symbols.texi:701
msgid "Here's an example of shorthands usage in a hypothetical string manipulating library @file{some-nice-string-utils.el}."
msgstr "以下は架空の文字列操作ライブラリー@file{some-nice-string-utils.el}でショートハンドを使用する例です。"

#. type: smalllisp
#: original_texis/symbols.texi:706
#, no-wrap
msgid ""
"(defun some-nice-string-utils-split (separator s &optional omit-nulls)\n"
"  \"A match-data saving variant of `split-string'.\"\n"
"  (save-match-data (split-string s separator omit-nulls)))\n"
"\n"
msgstr ""
"(defun some-nice-string-utils-split (separator s &optional omit-nulls)\n"
"  \"match-dataを保存する`split-string'の変種\"\n"
"  (save-match-data (split-string s separator omit-nulls)))\n"
"\n"

#. type: smalllisp
#: original_texis/symbols.texi:710
#, no-wrap
msgid ""
"(defun some-nice-string-utils-lines (s)\n"
"  \"Split string S at newline characters into a list of strings.\"\n"
"  (some-nice-string-utils-split \"\\\\(\\r\\n\\\\|[\\n\\r]\\\\)\" s))\n"
msgstr ""
"(defun some-nice-string-utils-lines (s)\n"
"  \"文字列Sを改行文字で分割して文字列リストにする\"\n"
"  (some-nice-string-utils-split \"\\\\(\\r\\n\\\\|[\\n\\r]\\\\)\" s))\n"

#. type: Plain text
#: original_texis/symbols.texi:715
msgid "As can be seen, it's quite tedious to read or develop this code since the symbol names to type are so long.  We can use shorthands to alleviate that."
msgstr "見ての通りタイプするシンボル名が非常に長いので、このコードを読んだり開発するのはとても退屈です。これの緩和にショートハンドが使用できます。"

#. type: lisp
#: original_texis/symbols.texi:720
#, no-wrap
msgid ""
"(defun snu-split (separator s &optional omit-nulls)\n"
"  \"A match-data saving variation on `split-string'.\"\n"
"  (save-match-data (split-string s separator omit-nulls)))\n"
"\n"
msgstr ""
"(defun snu-split (separator s &optional omit-nulls)\n"
"  \"match-dataを保存する`split-string'の変種\"\n"
"  (save-match-data (split-string s separator omit-nulls)))\n"
"\n"

#. type: lisp
#: original_texis/symbols.texi:724
#, no-wrap
msgid ""
"(defun snu-lines (s)\n"
"  \"Split string S into a list of strings on newline characters.\"\n"
"  (snu-split \"\\\\(\\r\\n\\\\|[\\n\\r]\\\\)\" s))\n"
"\n"
msgstr ""
"(defun snu-lines (s)\n"
"  \"文字列Sを改行文字で分割して文字列リストにする\"\n"
"  (snu-split \"\\\\(\\r\\n\\\\|[\\n\\r]\\\\)\" s))\n"
"\n"

#. type: lisp
#: original_texis/symbols.texi:728
#, no-wrap
msgid ""
";; Local Variables:\n"
";; read-symbol-shorthands: ((\"snu-\" . \"some-nice-string-utils-\"))\n"
";; End:\n"
msgstr ""
";; Local Variables:\n"
";; read-symbol-shorthands: ((\"snu-\" . \"some-nice-string-utils-\"))\n"
";; End:\n"

#. type: Plain text
#: original_texis/symbols.texi:740
msgid "Even though the two excerpts look different, they are quite identical after the Lisp reader processes them.  Both will lead to the very same symbols being interned (@pxref{Creating Symbols}).  Thus loading or byte-compiling any of the two files has equivalent results.  The shorthands @code{snu-split} and @code{snu-lines} used in the second version are @emph{not} interned in the obarray.  This is easily seen by moving point to the location where the shorthands are used and waiting for ElDoc (@pxref{Programming Language Doc, , Local Variables in Files, emacs, The GNU Emacs Manual}) to hint at the true full name of the symbol under point in the echo area."
msgstr "この2つの例が異なるように見えても、これらをLispリーダーが処理した後はまったく同じです。どちらもインターン(@ref{Creating Symbols}を参照)される同一のシンボルへと導かれます。したがって2つのファイルのどちらをバイトコンパイルしても、同じ結果が得られます。2つ目のバージョンのショートハンド@code{snu-split}と@code{snu-lines}はobarrayに@emph{インターンされません}。これはショートハンド使用箇所にポイントを移動して、ポイント位置のシンボルの真のシンボル名のヒントをElDoc (@ref{Programming Language Doc, , Local Variables in Files, emacs, The GNU Emacs Manual}を参照)がエコーエリアに表示するのを待つことで容易に確認できます。"

#. type: Plain text
#: original_texis/symbols.texi:748
msgid "Since @code{read-symbol-shorthands} is a file-local variable, it is possible that multiple libraries depending on @file{some-nice-string-utils-lines.el} refer to the same symbols under @emph{different} shorthands, or not using shorthands at all.  In the next example, the @file{my-tricks.el} library refers to the symbol @code{some-nice-string-utils-lines} using the @code{sns-} prefix instead of @code{snu-}."
msgstr "@code{read-symbol-shorthands}はファイルローカル変数なので、@file{some-nice-string-utils-lines.el}に依存する複数のライブラリーが同一のシンボルを@emph{異なる}ショートハンドで参照したり、あるいはショートハンドをまったく使用せずに参照することが可能になります。次の例では@file{my-tricks.el}ライブラリーが@code{snu-}ではなく、@code{sns-}というプレフィクスを使用してシンボル@code{some-nice-string-utils-lines}を参照しています。"

#. type: example
#: original_texis/symbols.texi:751
#, no-wrap
msgid ""
"(defun t-reverse-lines (s) (string-join (reverse (sns-lines s)) \"\\n\")\n"
"\n"
msgstr ""
"(defun t-reverse-lines (s) (string-join (reverse (sns-lines s)) \"\\n\")\n"
"\n"

#. type: example
#: original_texis/symbols.texi:756
#, no-wrap
msgid ""
";; Local Variables:\n"
";; read-symbol-shorthands: ((\"t-\" . \"my-tricks-\")\n"
";;                          (\"sns-\" . \"some-nice-string-utils-\"))\n"
";; End:\n"
msgstr ""
";; Local Variables:\n"
";; read-symbol-shorthands: ((\"t-\" . \"my-tricks-\")\n"
";;                          (\"sns-\" . \"some-nice-string-utils-\"))\n"
";; End:\n"

#. type: subsection
#: original_texis/symbols.texi:758
#, no-wrap
msgid "Exceptions"
msgstr "Exceptions"

#. type: Plain text
#: original_texis/symbols.texi:761
msgid "There are two exceptions to rules governing Shorthand transformations:"
msgstr "ショートハンド変換適用を管理するにあたって2つの例外があります:"

#. type: itemize
#: original_texis/symbols.texi:769
msgid "Symbol forms comprised entirely of characters in the Emacs Lisp symbol constituent class (@pxref{Syntax Class Table}) are not transformed.  For example, it's possible to use @code{-} or @code{/=} as shorthand prefixes, but that won't shadow the arithmetic @emph{functions} of those names."
msgstr "Emacs Lispシンボル構成クラス(@ref{Syntax Class Table}を参照)の文字だけでシンボルフォーム全体が形成される場合には変換されない。たとえば@code{-}や@code{/=}をショートハンドプレフィクスとして使用するのは可能だが、それらの名前は算術の@emph{関数}をシャドーしない。"

#. type: itemize
#: original_texis/symbols.texi:772
msgid "Symbol forms whose names start with @samp{#_} are not transformed."
msgstr "名前が@samp{#_}で始まるシンボルフォームは変換されない。"

#. type: cindex
#: original_texis/symbols.texi:776
#, no-wrap
msgid "symbol with position"
msgstr "symbol with position"

#. type: cindex
#: original_texis/symbols.texi:778
#, no-wrap
msgid "bare symbol"
msgstr "bare symbol"

#. type: Plain text
#: original_texis/symbols.texi:784
msgid "A @dfn{symbol with position} is a symbol, the @dfn{bare symbol}, together with an unsigned integer called the @dfn{position}.  These objects are intended for use by the byte compiler, which records in them the position of each symbol occurrence and uses those positions in warning and error messages."
msgstr "@dfn{位置つきシンボル(symbol with position)}とは@dfn{bareシンボル(bare symbol: 裸のシンボル)}と@dfn{位置(position)}と呼ばれる符号なし整数を合わせたシンボルのことです。これらのオブジェクトはバイトコンパイラーによって使用されます。バイトコンパイラーはシンボルそれぞれの出現位置を記録して、警告メッセージやエラーメッセージでそれらの位置を使用します。"

#. type: Plain text
#: original_texis/symbols.texi:792
msgid "The printed representation of a symbol with position uses the hash notation outlined in @ref{Printed Representation}.  It looks like @samp{#<symbol foo at 12345>}.  It has no read syntax.  You can cause just the bare symbol to be printed by binding the variable @code{print-symbols-bare} to non-@code{nil} around the print operation.  The byte compiler does this before writing its output to the compiled Lisp file."
msgstr "位置つきシンボルのプリント表現には、@ref{Printed Representation}で概説したハッシュ表記が使用されます。@samp{#<symbol foo at 12345>}のようなプリント表現であり、入力構文はありません。プリント操作の前後で変数@code{print-symbols-bare}を非@code{nil}にバインドすれば、bareシンボルだけをプリントさせることができます。バイトコンパイラーはコンパイル済みLispファイルへ書き込む前にこれを行っています。"

#. type: Plain text
#: original_texis/symbols.texi:800
msgid "For most purposes, when the flag variable @code{symbols-with-pos-enabled} is non-@code{nil}, symbols with positions behave just as bare symbols do.  For example, @samp{(eq #<symbol foo at 12345> foo)} has a value @code{t} when that variable is set (but @code{nil} when it isn't set).  Most of the time in Emacs this variable is @code{nil}, but the byte compiler binds it to @code{t} when it runs."
msgstr "フラグ変数@code{symbols-with-pos-enabled}が非@code{nil}であっても、ほとんどの用途にたいして位置つきシンボルはbareシンボルと同じように動作します。たとえばこの変数がセットされている場合には、@samp{(eq #<symbol foo at 12345> foo)}の値は@code{t}になります(ただしセットされていなければ@code{nil})。Emacsではほとんどの場合この変数は@code{nil}ですが、バイトコンパイラーの実行時には@code{t}にバインドされます。"

#. type: Plain text
#: original_texis/symbols.texi:805
msgid "Typically, symbols with position are created by the byte compiler calling the reader function @code{read-positioning-symbols} (@pxref{Input Functions}).  One can also be created with the function @code{position-symbol}."
msgstr "位置つきシンボルは通常はバイトコンパイラーがリーダー関数@code{read-positioning-symbols}を呼び出すことによって作成されます(@ref{Input Functions}を参照)が、関数@code{position-symbol}によって作成することもできます。"

#. type: defvar
#: original_texis/symbols.texi:806
#, no-wrap
msgid "symbols-with-pos-enabled"
msgstr "symbols-with-pos-enabled"

#. type: defvar
#: original_texis/symbols.texi:810
msgid "When this variable is non-@code{nil}, symbols with position behave like the contained bare symbol.  Emacs runs a little more slowly in this case."
msgstr "この変数が非@code{nil}の際には、位置つきシンボルはそれに内包されているbareシンボルと同様に振る舞う。この場合にはEmacsの実行が少しだけ遅くなる。"

#. type: defvar
#: original_texis/symbols.texi:812
#, no-wrap
msgid "print-symbols-bare"
msgstr "print-symbols-bare"

#. type: defvar
#: original_texis/symbols.texi:815
msgid "When bound to non-@code{nil}, the Lisp printer prints only the bare symbol of a symbol with position, ignoring the position."
msgstr "非@code{nil}にバインドされていると、Lispプリンターは位置つきシンボルの位置は無視してbareシンボルだけをプリントする。"

#. type: defun
#: original_texis/symbols.texi:817
#, no-wrap
msgid "symbol-with-pos-p symbol."
msgstr "symbol-with-pos-p symbol."

#. type: defun
#: original_texis/symbols.texi:820
msgid "This function returns @code{t} if @var{symbol} is a symbol with position, @code{nil} otherwise."
msgstr "この関数は@var{symbol}がシンボルなら@code{t}、それ以外は@code{nil}をリターンする。"

#. type: defun
#: original_texis/symbols.texi:822
#, no-wrap
msgid "bare-symbol symbol"
msgstr "bare-symbol symbol"

#. type: defun
#: original_texis/symbols.texi:826
msgid "This function returns the bare symbol contained in @var{symbol}, or @var{symbol} itself if it is already a bare symbol.  For any other type of object, it signals an error."
msgstr "この関数は@var{symbol}に含まれるbareシンボル、@var{symbol}がすでにbareシンボルなら@var{symbol}自体をリターンする。それ以外のタイプのオブジェクトの場合にはエラーをシグナルする。"

#. type: defun
#: original_texis/symbols.texi:828
#, no-wrap
msgid "symbol-with-pos-pos symbol"
msgstr "symbol-with-pos-pos symbol"

#. type: defun
#: original_texis/symbols.texi:831
msgid "This function returns the position, a number, from a symbol with position.  For any other type of object, it signals an error."
msgstr "この関数は位置つきシンボルの位置(数値)をリターンする。それ以外のタイプのオブジェクトの場合にはエラーをシグナルする。"

#. type: defun
#: original_texis/symbols.texi:833
#, no-wrap
msgid "position-symbol sym pos"
msgstr "position-symbol sym pos"

#. type: defun
#: original_texis/symbols.texi:839
msgid "Make a new symbol with position.  @var{sym} is either a bare symbol or a symbol with position, and supplies the symbol part of the new object.  @var{pos} is either an integer which becomes the number part of the new object, or a symbol with position whose position is used.  Emacs signals an error if either argument is invalid."
msgstr "位置つきシンボルを新たに作成する。@var{sym}はbareシンボルか位置つきシンボルで、これは新たなオブジェクトにたいしてシンボル部分を提供する。@var{pos}は整数(新オブジェクトの数値部分となる)、あるいは位置つきシンボル(このシンボルの位置を使用)のいずれか。引数のいずれかが無効であればEmacsはエラーをシグナルする。"
