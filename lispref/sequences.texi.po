# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2019-10-19 09:39+0900\n"
"PO-Revision-Date: 2019-10-19 02:00+0900\n"
"Last-Translator: Takeshi Ayanokoji <ayanokoji.takesi@gmail.com>\n"
"Language-Team: Japanese <h1r0p@outlook.jp>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: node
#: original_texis/sequences.texi:6
#, no-wrap
msgid "Sequences Arrays Vectors"
msgstr "Sequences Arrays Vectors"

#. type: chapter
#: original_texis/sequences.texi:7
#, no-wrap
msgid "Sequences, Arrays, and Vectors"
msgstr "Sequences, Arrays, and Vectors"

#. type: cindex
#: original_texis/sequences.texi:8
#, no-wrap
msgid "sequence"
msgstr "sequence"

#. type: Plain text
#: original_texis/sequences.texi:14
msgid "The @dfn{sequence} type is the union of two other Lisp types: lists and arrays.  In other words, any list is a sequence, and any array is a sequence.  The common property that all sequences have is that each is an ordered collection of elements."
msgstr "@dfn{シーケンス(sequence)}型は2つの異なるLisp型 --- リストと配列 --- を結合した型です。言い換えると任意のリストはシーケンスであり任意の配列はシーケンスです。すべてのシーケンスがもつ共通な属性は、それぞれが順序づけされた要素のコレクションであることです。"

#. type: Plain text
#: original_texis/sequences.texi:18
msgid "An @dfn{array} is a fixed-length object with a slot for each of its elements.  All the elements are accessible in constant time.  The four types of arrays are strings, vectors, char-tables and bool-vectors."
msgstr "@dfn{配列(array)}はスロットがその要素であるような、固定長のオブジェクトです。すべての要素に一定時間でアクセスできます。配列の4つの型として文字列、ベクター、文字テーブル、ブールベクターがあります。"

#. type: Plain text
#: original_texis/sequences.texi:24
msgid "A list is a sequence of elements, but it is not a single primitive object; it is made of cons cells, one cell per element.  Finding the @var{n}th element requires looking through @var{n} cons cells, so elements farther from the beginning of the list take longer to access.  But it is possible to add elements to the list, or remove elements."
msgstr "リストは要素のシーケンスですが、要素は単一の基本オブジェクトではありません。リストはコンスセルにより作られ、要素ごとに1つのセルをもちます。@var{n}番目の要素を探すには@var{n}個のコンスセルを走査する必要があるので、先頭から離れた要素ほどアクセスに時間を要します。しかしリストは要素の追加や削除が可能です。"

#. type: Plain text
#: original_texis/sequences.texi:26
msgid "The following diagram shows the relationship between these types:"
msgstr "以下の図はこれらの型の関連を表しています:"

#. type: group
#: original_texis/sequences.texi:45
#, no-wrap
msgid ""
"          _____________________________________________\n"
"         |                                             |\n"
"         |          Sequence                           |\n"
"         |  ______   ________________________________  |\n"
"         | |      | |                                | |\n"
"         | | List | |             Array              | |\n"
"         | |      | |    ________       ________     | |\n"
"         | |______| |   |        |     |        |    | |\n"
"         |          |   | Vector |     | String |    | |\n"
"         |          |   |________|     |________|    | |\n"
"         |          |  ____________   _____________  | |\n"
"         |          | |            | |             | | |\n"
"         |          | | Char-table | | Bool-vector | | |\n"
"         |          | |____________| |_____________| | |\n"
"         |          |________________________________| |\n"
"         |_____________________________________________|\n"
msgstr ""
"          _____________________________________________\n"
"         |                                             |\n"
"         |          Sequence                           |\n"
"         |  ______   ________________________________  |\n"
"         | |      | |                                | |\n"
"         | | List | |             Array              | |\n"
"         | |      | |    ________       ________     | |\n"
"         | |______| |   |        |     |        |    | |\n"
"         |          |   | Vector |     | String |    | |\n"
"         |          |   |________|     |________|    | |\n"
"         |          |  ____________   _____________  | |\n"
"         |          | |            | |             | | |\n"
"         |          | | Char-table | | Bool-vector | | |\n"
"         |          | |____________| |_____________| | |\n"
"         |          |________________________________| |\n"
"         |_____________________________________________|\n"

#. type: node
#: original_texis/sequences.texi:57 original_texis/sequences.texi:59
#, no-wrap
msgid "Sequence Functions"
msgstr "Sequence Functions"

#. type: menuentry
#: original_texis/sequences.texi:57
msgid "Functions that accept any kind of sequence."
msgstr "任意の種類のシーケンスを許す関数。"

#. type: section
#: original_texis/sequences.texi:57 original_texis/sequences.texi:220
#: original_texis/sequences.texi:221
#, no-wrap
msgid "Arrays"
msgstr "Arrays"

#. type: menuentry
#: original_texis/sequences.texi:57
msgid "Characteristics of arrays in Emacs Lisp."
msgstr "Emacs Lispの配列の特徴。"

#. type: node
#: original_texis/sequences.texi:57 original_texis/sequences.texi:288
#, no-wrap
msgid "Array Functions"
msgstr "Array Functions"

#. type: menuentry
#: original_texis/sequences.texi:57
msgid "Functions specifically for arrays."
msgstr "配列に特化した関数。"

#. type: section
#: original_texis/sequences.texi:57 original_texis/sequences.texi:388
#: original_texis/sequences.texi:389
#, no-wrap
msgid "Vectors"
msgstr "Vectors"

#. type: menuentry
#: original_texis/sequences.texi:57
msgid "Special characteristics of Emacs Lisp vectors."
msgstr "Emacs Lispベクターの特質。"

#. type: node
#: original_texis/sequences.texi:57 original_texis/sequences.texi:426
#, no-wrap
msgid "Vector Functions"
msgstr "Vector Functions"

#. type: menuentry
#: original_texis/sequences.texi:57
msgid "Functions specifically for vectors."
msgstr "ベクターのための特別な関数。"

#. type: section
#: original_texis/sequences.texi:57 original_texis/sequences.texi:516
#: original_texis/sequences.texi:517
#, no-wrap
msgid "Char-Tables"
msgstr "Char-Tables"

#. type: menuentry
#: original_texis/sequences.texi:57
msgid "How to work with char-tables."
msgstr "文字テーブルを扱う方法。"

#. type: node
#: original_texis/sequences.texi:57 original_texis/sequences.texi:691
#, no-wrap
msgid "Bool-Vectors"
msgstr "Bool-Vectors"

#. type: menuentry
#: original_texis/sequences.texi:57
msgid "How to work with bool-vectors."
msgstr "ブールベクターを扱う方法。"

#. type: node
#: original_texis/sequences.texi:57 original_texis/sequences.texi:783
#, no-wrap
msgid "Rings"
msgstr "Rings"

#. type: menuentry
#: original_texis/sequences.texi:57
msgid "Managing a fixed-size ring of objects."
msgstr "オブジェクトの固定サイズのリングを管理する。"

#. type: section
#: original_texis/sequences.texi:60
#, no-wrap
msgid "Sequences"
msgstr "Sequences"

#. type: Plain text
#: original_texis/sequences.texi:63
msgid "This section describes functions that accept any kind of sequence."
msgstr "このセクションでは任意の種類のシーケンスを許す関数を説明します。"

#. type: defun
#: original_texis/sequences.texi:64
#, no-wrap
msgid "sequencep object"
msgstr "sequencep object"

#. type: defun
#: original_texis/sequences.texi:67
msgid "This function returns @code{t} if @var{object} is a list, vector, string, bool-vector, or char-table, @code{nil} otherwise."
msgstr "この関数は@var{object}がリスト、ベクター、文字列、ブールベクター、文字テーブルなら@code{t}、それ以外は@code{nil}をリターンする。"

#. type: defun
#: original_texis/sequences.texi:69
#, no-wrap
msgid "length sequence"
msgstr "length sequence"

#. type: cindex
#: original_texis/sequences.texi:70
#, no-wrap
msgid "string length"
msgstr "string length"

#. type: cindex
#: original_texis/sequences.texi:71
#, no-wrap
msgid "list length"
msgstr "list length"

#. type: cindex
#: original_texis/sequences.texi:72
#, no-wrap
msgid "vector length"
msgstr "vector length"

#. type: cindex
#: original_texis/sequences.texi:73
#, no-wrap
msgid "sequence length"
msgstr "sequence length"

#. type: cindex
#: original_texis/sequences.texi:74
#, no-wrap
msgid "char-table length"
msgstr "char-table length"

#. type: defun
#: original_texis/sequences.texi:80
msgid "This function returns the number of elements in @var{sequence}.  If @var{sequence} is a dotted list, a @code{wrong-type-argument} error is signaled.  Circular lists may cause an infinite loop.  For a char-table, the value returned is always one more than the maximum Emacs character code."
msgstr "この関数は@var{sequence}内の要素の数をリターンする。@var{sequence}がドットリストなら@code{wrong-type-argument}エラーがシグナルされる。循環リストは無限ループを引き起こす。文字テーブルではEmacsの最大文字コードより1大きい値が常にリターンされる。"

#. type: defun
#: original_texis/sequences.texi:82
msgid "@xref{Definition of safe-length}, for the related function @code{safe-length}."
msgstr "関連する関数@code{safe-length}については@ref{Definition of safe-length}を参照のこと。"

#. type: group
#: original_texis/sequences.texi:87
#, no-wrap
msgid ""
"(length '(1 2 3))\n"
"    @result{} 3\n"
msgstr ""
"(length '(1 2 3))\n"
"    @result{} 3\n"

#. type: group
#: original_texis/sequences.texi:91
#, no-wrap
msgid ""
"(length ())\n"
"    @result{} 0\n"
msgstr ""
"(length ())\n"
"    @result{} 0\n"

#. type: group
#: original_texis/sequences.texi:95
#, no-wrap
msgid ""
"(length \"foobar\")\n"
"    @result{} 6\n"
msgstr ""
"(length \"foobar\")\n"
"    @result{} 6\n"

#. type: group
#: original_texis/sequences.texi:99
#, no-wrap
msgid ""
"(length [1 2 3])\n"
"    @result{} 3\n"
msgstr ""
"(length [1 2 3])\n"
"    @result{} 3\n"

#. type: group
#: original_texis/sequences.texi:103
#, no-wrap
msgid ""
"(length (make-bool-vector 5 nil))\n"
"    @result{} 5\n"
msgstr ""
"(length (make-bool-vector 5 nil))\n"
"    @result{} 5\n"

#. type: Plain text
#: original_texis/sequences.texi:109
msgid "See also @code{string-bytes}, in @ref{Text Representations}."
msgstr "@ref{Text Representations}の@code{string-bytes}も参照されたい。"

#. type: Plain text
#: original_texis/sequences.texi:114
msgid "If you need to compute the width of a string on display, you should use @code{string-width} (@pxref{Size of Displayed Text}), not @code{length}, since @code{length} only counts the number of characters, but does not account for the display width of each character."
msgstr "ディスプレー上での文字列の幅を計算する必要があるなら、文字数だけを数えて各文字のディスプレー幅を計算しない@code{length}ではなく、@code{string-width} (@ref{Size of Displayed Text}を参照)を使用すること。"

#. type: defun
#: original_texis/sequences.texi:115
#, no-wrap
msgid "elt sequence index"
msgstr "elt sequence index"

#. type: cindex
#: original_texis/sequences.texi:116
#, no-wrap
msgid "elements of sequences"
msgstr "elements of sequences"

#. type: defun
#: original_texis/sequences.texi:123
msgid "This function returns the element of @var{sequence} indexed by @var{index}.  Legitimate values of @var{index} are integers ranging from 0 up to one less than the length of @var{sequence}.  If @var{sequence} is a list, out-of-range values behave as for @code{nth}.  @xref{Definition of nth}.  Otherwise, out-of-range values trigger an @code{args-out-of-range} error."
msgstr "この関数は@var{index}によりインデックスづけされた、@var{sequence}の要素をリターンする。@var{index}の値として妥当なのは、0から@var{sequence}の長さより1小さい数までの範囲の整数。@var{sequence}がリストなら範囲外の値は@code{nth}と同じように振る舞う。@ref{Definition of nth}を参照のこと。それ以外なら範囲外の値は@code{args-out-of-range}エラーを引き起こす。"

#. type: group
#: original_texis/sequences.texi:128
#, no-wrap
msgid ""
"(elt [1 2 3 4] 2)\n"
"     @result{} 3\n"
msgstr ""
"(elt [1 2 3 4] 2)\n"
"     @result{} 3\n"

#. type: group
#: original_texis/sequences.texi:132
#, no-wrap
msgid ""
"(elt '(1 2 3 4) 2)\n"
"     @result{} 3\n"
msgstr ""
"(elt '(1 2 3 4) 2)\n"
"     @result{} 3\n"

#. type: group
#: original_texis/sequences.texi:137
#, no-wrap
msgid ""
";; @r{We use @code{string} to show clearly which character @code{elt} returns.}\n"
"(string (elt \"1234\" 2))\n"
"     @result{} \"3\"\n"
msgstr ""
";; @r{@code{elt}がどの文字をreturnするか明確にするために@code{string}を使用}\n"
"(string (elt \"1234\" 2))\n"
"     @result{} \"3\"\n"

#. type: group
#: original_texis/sequences.texi:141
#, no-wrap
msgid ""
"(elt [1 2 3 4] 4)\n"
"     @error{} Args out of range: [1 2 3 4], 4\n"
msgstr ""
"(elt [1 2 3 4] 4)\n"
"     @error{} Args out of range: [1 2 3 4], 4\n"

#. type: group
#: original_texis/sequences.texi:145
#, no-wrap
msgid ""
"(elt [1 2 3 4] -1)\n"
"     @error{} Args out of range: [1 2 3 4], -1\n"
msgstr ""
"(elt [1 2 3 4] -1)\n"
"     @error{} Args out of range: [1 2 3 4], -1\n"

#. type: defun
#: original_texis/sequences.texi:150
msgid "This function generalizes @code{aref} (@pxref{Array Functions}) and @code{nth} (@pxref{Definition of nth})."
msgstr "この関数は@code{aref} (@ref{Array Functions}を参照)と@code{nth} (@ref{Definition of nth}を参照)を一般化したものである。"

#. type: defun
#: original_texis/sequences.texi:152
#, no-wrap
msgid "copy-sequence sequence"
msgstr "copy-sequence sequence"

#. type: cindex
#: original_texis/sequences.texi:153
#, no-wrap
msgid "copying sequences"
msgstr "copying sequences"

#. type: defun
#: original_texis/sequences.texi:157
msgid "This function returns a copy of @var{sequence}.  The copy is the same type of object as the original sequence, and it has the same elements in the same order."
msgstr "この関数は@var{sequence}のコピーをリターンする。コピーは元のシーケンスと同じ型、同じ要素、同じ順番となる。"

#. type: defun
#: original_texis/sequences.texi:164
msgid "Storing a new element into the copy does not affect the original @var{sequence}, and vice versa.  However, the elements of the new sequence are not copies; they are identical (@code{eq}) to the elements of the original.  Therefore, changes made within these elements, as found via the copied sequence, are also visible in the original sequence."
msgstr "コピーに新しい要素を格納するのは、元の@var{sequence}に影響を与えずその逆も真である。しかし新しいシーケンス内の要素がコピーされたものでなければ、元のシーケンスの要素と同一(@code{eq})になる。したがって、コピーされたシーケンスを介して見つかった要素を変更すると、この変更は元のシーケンスでも見ることができる。"

#. type: defun
#: original_texis/sequences.texi:169
msgid "If the sequence is a string with text properties, the property list in the copy is itself a copy, not shared with the original's property list.  However, the actual values of the properties are shared.  @xref{Text Properties}."
msgstr "シーケンスがテキストプロパティーをもつ文字列なら、コピー内のプロパティーリスト自身もコピーとなり、元のシーケンスのプロパティーリストと共有はされない。しかしプロパティーリストの実際の値は共有される。@ref{Text Properties}を参照のこと。"

#. type: defun
#: original_texis/sequences.texi:172
msgid "This function does not work for dotted lists.  Trying to copy a circular list may cause an infinite loop."
msgstr "この関数はドットリストでは機能しない。循環リストのコピーは無限ループを起こすだろう。"

#. type: defun
#: original_texis/sequences.texi:176
msgid "See also @code{append} in @ref{Building Lists}, @code{concat} in @ref{Creating Strings}, and @code{vconcat} in @ref{Vector Functions}, for other ways to copy sequences."
msgstr "シーケンスをコピーする別の方法については@ref{Building Lists}の@code{append}、@ref{Creating Strings}の@code{concat}、@ref{Vector Functions}の@code{vconcat}も参照されたい。"

#. type: group
#: original_texis/sequences.texi:181
#, no-wrap
msgid ""
"(setq bar '(1 2))\n"
"     @result{} (1 2)\n"
msgstr ""
"(setq bar '(1 2))\n"
"     @result{} (1 2)\n"

#. type: group
#: original_texis/sequences.texi:185
#, no-wrap
msgid ""
"(setq x (vector 'foo bar))\n"
"     @result{} [foo (1 2)]\n"
msgstr ""
"(setq x (vector 'foo bar))\n"
"     @result{} [foo (1 2)]\n"

#. type: group
#: original_texis/sequences.texi:189
#, no-wrap
msgid ""
"(setq y (copy-sequence x))\n"
"     @result{} [foo (1 2)]\n"
msgstr ""
"(setq y (copy-sequence x))\n"
"     @result{} [foo (1 2)]\n"

#. type: group
#: original_texis/sequences.texi:194
#, no-wrap
msgid ""
"(eq x y)\n"
"     @result{} nil\n"
msgstr ""
"(eq x y)\n"
"     @result{} nil\n"

#. type: group
#: original_texis/sequences.texi:198
#, no-wrap
msgid ""
"(equal x y)\n"
"     @result{} t\n"
msgstr ""
"(equal x y)\n"
"     @result{} t\n"

#. type: group
#: original_texis/sequences.texi:202
#, no-wrap
msgid ""
"(eq (elt x 1) (elt y 1))\n"
"     @result{} t\n"
msgstr ""
"(eq (elt x 1) (elt y 1))\n"
"     @result{} t\n"

#. type: group
#: original_texis/sequences.texi:209
#, no-wrap
msgid ""
";; @r{Replacing an element of one sequence.}\n"
"(aset x 0 'quux)\n"
"x @result{} [quux (1 2)]\n"
"y @result{} [foo (1 2)]\n"
msgstr ""
";; @r{一方のシーケンスの要素を置き換え}\n"
"(aset x 0 'quux)\n"
"x @result{} [quux (1 2)]\n"
"y @result{} [foo (1 2)]\n"

#. type: group
#: original_texis/sequences.texi:216
#, no-wrap
msgid ""
";; @r{Modifying the inside of a shared element.}\n"
"(setcar (aref x 1) 69)\n"
"x @result{} [quux (69 2)]\n"
"y @result{} [foo (69 2)]\n"
msgstr ""
";; @r{共有された要素の内部を変更}\n"
"(setcar (aref x 1) 69)\n"
"x @result{} [quux (69 2)]\n"
"y @result{} [foo (69 2)]\n"

#. type: cindex
#: original_texis/sequences.texi:222
#, no-wrap
msgid "array"
msgstr "array"

#. type: Plain text
#: original_texis/sequences.texi:229
msgid "An @dfn{array} object has slots that hold a number of other Lisp objects, called the elements of the array.  Any element of an array may be accessed in constant time.  In contrast, the time to access an element of a list is proportional to the position of that element in the list."
msgstr "@dfn{配列(array)}オブジェクトは、いくつかのLispオブジェクトを保持するスロットをもち、これらのオブジェクトは配列の要素と呼ばれます。配列内の任意の要素は一定時間でアクセスされます。対照的にリスト内の要素のアクセスに要する時間は、その要素がリスト内のどの位置にあるかに比例します。"

#. type: Plain text
#: original_texis/sequences.texi:236
msgid "Emacs defines four types of array, all one-dimensional: @dfn{strings} (@pxref{String Type}), @dfn{vectors} (@pxref{Vector Type}), @dfn{bool-vectors} (@pxref{Bool-Vector Type}), and @dfn{char-tables} (@pxref{Char-Table Type}).  Vectors and char-tables can hold elements of any type, but strings can only hold characters, and bool-vectors can only hold @code{t} and @code{nil}."
msgstr "Emacsは4つの配列型 ---@dfn{文字列(strings、@ref{String Type}を参照)}、@dfn{ベクター(vectors、@ref{Vector Type}を参照)}、@dfn{ブールベクター(bool-vectors、@ref{Bool-Vector Type}を参照)}、@dfn{文字テーブル(char-tables、@ref{Char-Table Type}を参照)} --- を定義しており、これらはすべて1次元です。ベクターと文字テーブルは任意の型の要素を保持できますが、文字列は文字だけ、ブールベクターは@code{t}か@code{nil}しか保持できません。"

#. type: Plain text
#: original_texis/sequences.texi:238
msgid "All four kinds of array share these characteristics:"
msgstr "4種のすべての配列はこれらの特性を共有します:"

#. type: itemize
#: original_texis/sequences.texi:244
msgid "The first element of an array has index zero, the second element has index 1, and so on.  This is called @dfn{zero-origin} indexing.  For example, an array of four elements has indices 0, 1, 2, @w{and 3}."
msgstr "配列の1番目の要素はインデックス0、2番目はインデックス1、...となる。これは@dfn{0基準(zero-origin)}のインデックスづけと呼ばれる。たとえば4要素の配列のインデックスは0、1、2、3。"

#. type: itemize
#: original_texis/sequences.texi:248
msgid "The length of the array is fixed once you create it; you cannot change the length of an existing array."
msgstr "配列の長さは一度配列が作成されたら固定されるので、既存の配列の長さは変更できない。"

#. type: itemize
#: original_texis/sequences.texi:252
msgid "For purposes of evaluation, the array is a constant---i.e., it evaluates to itself."
msgstr "評価において配列は定数 --- つまりそれ自身へと評価される。"

#. type: itemize
#: original_texis/sequences.texi:256
msgid "The elements of an array may be referenced or changed with the functions @code{aref} and @code{aset}, respectively (@pxref{Array Functions})."
msgstr "配列の要素は関数@code{aref}で参照したり、関数@code{aset}で変更できる(@ref{Array Functions}を参照)。"

#. type: Plain text
#: original_texis/sequences.texi:261
msgid "When you create an array, other than a char-table, you must specify its length.  You cannot specify the length of a char-table, because that is determined by the range of character codes."
msgstr "配列を作成したとき、文字テーブル以外では長さを指定しなければなりません。文字テーブルの長さは文字コードの範囲により決定されるので長さを指定できません。"

#. type: Plain text
#: original_texis/sequences.texi:265
msgid "In principle, if you want an array of text characters, you could use either a string or a vector.  In practice, we always choose strings for such applications, for four reasons:"
msgstr "原則として、テキスト文字の配列が欲しい場合は、文字列とベクターのどちらかを使用できます。実際のところ4つの理由により,そのような用途にたいしては、わたしたちは常に文字列を選択します:"

#. type: itemize
#: original_texis/sequences.texi:269
msgid "They occupy one-fourth the space of a vector of the same elements."
msgstr "文字列は同じ要素をもつベクターと比較して占めるスペースが1/4である。"

#. type: itemize
#: original_texis/sequences.texi:273
msgid "Strings are printed in a way that shows the contents more clearly as text."
msgstr "文字列の内容はテキストとして、より明解な方法によりプリントされる。"

#. type: itemize
#: original_texis/sequences.texi:276
msgid "Strings can hold text properties.  @xref{Text Properties}."
msgstr "文字列はテキストプロパティーを保持できる。@ref{Text Properties}を参照のこと。"

#. type: itemize
#: original_texis/sequences.texi:281
msgid "Many of the specialized editing and I/O facilities of Emacs accept only strings.  For example, you cannot insert a vector of characters into a buffer the way you can insert a string.  @xref{Strings and Characters}."
msgstr "Emacsの特化した編集機能とI/O機能の多くが文字列だけに適用される。たとえば文字列をバッファーに挿入する方法では、文字のベクターをバッファーに挿入できない。@ref{Strings and Characters}を参照のこと"

#. type: Plain text
#: original_texis/sequences.texi:287
msgid "By contrast, for an array of keyboard input characters (such as a key sequence), a vector may be necessary, because many keyboard input characters are outside the range that will fit in a string.  @xref{Key Sequence Input}."
msgstr "対照的に、(キーシーケンスのような)キーボード入力文字の配列では、多くのキーボード入力文字は文字列に収まる範囲の外にあるので、ベクターが必要になるでしょう。@ref{Key Sequence Input}を参照してください。"

#. type: section
#: original_texis/sequences.texi:289
#, no-wrap
msgid "Functions that Operate on Arrays"
msgstr "Functions that Operate on Arrays"

#. type: Plain text
#: original_texis/sequences.texi:293
msgid "In this section, we describe the functions that accept all types of arrays."
msgstr "このセクションではすべての型の配列に適用される関数を説明します。"

#. type: defun
#: original_texis/sequences.texi:294
#, no-wrap
msgid "arrayp object"
msgstr "arrayp object"

#. type: defun
#: original_texis/sequences.texi:297
msgid "This function returns @code{t} if @var{object} is an array (i.e., a vector, a string, a bool-vector or a char-table)."
msgstr "この関数は@var{object}が配列(ベクター、文字列、ブールベクター、文字テーブル)なら@code{t}をリターンする。"

#. type: group
#: original_texis/sequences.texi:306
#, no-wrap
msgid ""
"(arrayp [a])\n"
"     @result{} t\n"
"(arrayp \"asdf\")\n"
"     @result{} t\n"
"(arrayp (syntax-table))    ;; @r{A char-table.}\n"
"     @result{} t\n"
msgstr ""
"(arrayp [a])\n"
"     @result{} t\n"
"(arrayp \"asdf\")\n"
"     @result{} t\n"
"(arrayp (syntax-table))    ;; @r{文字テーブル}\n"
"     @result{} t\n"

#. type: defun
#: original_texis/sequences.texi:310
#, no-wrap
msgid "aref array index"
msgstr "aref array index"

#. type: cindex
#: original_texis/sequences.texi:311
#, no-wrap
msgid "array elements"
msgstr "array elements"

#. type: defun
#: original_texis/sequences.texi:314
msgid "This function returns the @var{index}th element of @var{array}.  The first element is at index zero."
msgstr "この関数は @var{array}の@var{index}番目の要素をリターンする。1番目の要素のインデクスは0。"

#. type: group
#: original_texis/sequences.texi:321
#, no-wrap
msgid ""
"(setq primes [2 3 5 7 11 13])\n"
"     @result{} [2 3 5 7 11 13]\n"
"(aref primes 4)\n"
"     @result{} 11\n"
msgstr ""
"(setq primes [2 3 5 7 11 13])\n"
"     @result{} [2 3 5 7 11 13]\n"
"(aref primes 4)\n"
"     @result{} 11\n"

#. type: group
#: original_texis/sequences.texi:325
#, no-wrap
msgid ""
"(aref \"abcdefg\" 1)\n"
"     @result{} 98           ; @r{@samp{b} is @acronym{ASCII} code 98.}\n"
msgstr ""
"(aref \"abcdefg\" 1)\n"
"     @result{} 98           ; @r{@samp{b}の@acronym{ASCII}コードは98}\n"

#. type: defun
#: original_texis/sequences.texi:329
msgid "See also the function @code{elt}, in @ref{Sequence Functions}."
msgstr "@ref{Sequence Functions}の関数@code{elt}も参照されたい。"

#. type: defun
#: original_texis/sequences.texi:331
#, no-wrap
msgid "aset array index object"
msgstr "aset array index object"

#. type: defun
#: original_texis/sequences.texi:334
msgid "This function sets the @var{index}th element of @var{array} to be @var{object}.  It returns @var{object}."
msgstr "この関数は@var{array}の@var{index}番目の要素を@var{object}にセットする。この関数は@var{object}をリターンする。"

#. type: group
#: original_texis/sequences.texi:343
#, no-wrap
msgid ""
"(setq w [foo bar baz])\n"
"     @result{} [foo bar baz]\n"
"(aset w 0 'fu)\n"
"     @result{} fu\n"
"w\n"
"     @result{} [fu bar baz]\n"
msgstr ""
"(setq w [foo bar baz])\n"
"     @result{} [foo bar baz]\n"
"(aset w 0 'fu)\n"
"     @result{} fu\n"
"w\n"
"     @result{} [fu bar baz]\n"

#. type: group
#: original_texis/sequences.texi:352
#, no-wrap
msgid ""
"(setq x \"asdfasfd\")\n"
"     @result{} \"asdfasfd\"\n"
"(aset x 3 ?Z)\n"
"     @result{} 90\n"
"x\n"
"     @result{} \"asdZasfd\"\n"
msgstr ""
"(setq x \"asdfasfd\")\n"
"     @result{} \"asdfasfd\"\n"
"(aset x 3 ?Z)\n"
"     @result{} 90\n"
"x\n"
"     @result{} \"asdZasfd\"\n"

#. type: defun
#: original_texis/sequences.texi:358
msgid "If @var{array} is a string and @var{object} is not a character, a @code{wrong-type-argument} error results.  The function converts a unibyte string to multibyte if necessary to insert a character."
msgstr "@var{array}が文字列で@var{object}が文字でなければ、結果は@code{wrong-type-argument}エラーとなる。この関数は文字列の挿入で必要なら、ユニバイト文字列をマルチバイト文字列に変換する。"

#. type: defun
#: original_texis/sequences.texi:360
#, no-wrap
msgid "fillarray array object"
msgstr "fillarray array object"

#. type: defun
#: original_texis/sequences.texi:363
msgid "This function fills the array @var{array} with @var{object}, so that each element of @var{array} is @var{object}.  It returns @var{array}."
msgstr "この関数は配列@var{array}を@var{object}で充填するので、@var{array}のすべての要素は@var{object}になる。この関数は@var{array}をリターンする。"

#. type: group
#: original_texis/sequences.texi:372
#, no-wrap
msgid ""
"(setq a [a b c d e f g])\n"
"     @result{} [a b c d e f g]\n"
"(fillarray a 0)\n"
"     @result{} [0 0 0 0 0 0 0]\n"
"a\n"
"     @result{} [0 0 0 0 0 0 0]\n"
msgstr ""
"(setq a [a b c d e f g])\n"
"     @result{} [a b c d e f g]\n"
"(fillarray a 0)\n"
"     @result{} [0 0 0 0 0 0 0]\n"
"a\n"
"     @result{} [0 0 0 0 0 0 0]\n"

#. type: group
#: original_texis/sequences.texi:378
#, no-wrap
msgid ""
"(setq s \"When in the course\")\n"
"     @result{} \"When in the course\"\n"
"(fillarray s ?-)\n"
"     @result{} \"------------------\"\n"
msgstr ""
"(setq s \"When in the course\")\n"
"     @result{} \"When in the course\"\n"
"(fillarray s ?-)\n"
"     @result{} \"------------------\"\n"

#. type: defun
#: original_texis/sequences.texi:383
msgid "If @var{array} is a string and @var{object} is not a character, a @code{wrong-type-argument} error results."
msgstr "@var{array}が文字列で@var{object}が文字でなければ、結果は@code{wrong-type-argument}エラーとなる。"

#. type: Plain text
#: original_texis/sequences.texi:387
msgid "The general sequence functions @code{copy-sequence} and @code{length} are often useful for objects known to be arrays.  @xref{Sequence Functions}."
msgstr "配列と判っているオブジェクトにたいしては、一般的なシーケンス関数@code{copy-sequence}と@code{length}が有用なときがよくあります。@ref{Sequence Functions}を参照してください。"

#. type: cindex
#: original_texis/sequences.texi:390
#, no-wrap
msgid "vector (type)"
msgstr "vector (type)"

#. type: Plain text
#: original_texis/sequences.texi:399
msgid "A @dfn{vector} is a general-purpose array whose elements can be any Lisp objects.  (By contrast, the elements of a string can only be characters.  @xref{Strings and Characters}.)  Vectors are used in Emacs for many purposes: as key sequences (@pxref{Key Sequences}), as symbol-lookup tables (@pxref{Creating Symbols}), as part of the representation of a byte-compiled function (@pxref{Byte Compilation}), and more."
msgstr "@dfn{ベクター(vector)}とは任意のLispオブジェクトを要素にもつことができる、一般用途のための配列です(対照的に文字列の要素は文字のみ。@ref{Strings and Characters}を参照)。Emacsではベクターはキーシーケンス(@ref{Key Sequences}を参照)、シンボル検索用のテーブル(@ref{Creating Symbols}を参照)、バイトコンパイルされた関数表現の一部(@ref{Byte Compilation}を参照)などの多くの目的で使用されます。"

#. type: Plain text
#: original_texis/sequences.texi:402
msgid "Like other arrays, vectors use zero-origin indexing: the first element has index 0."
msgstr "他の配列と同様、ベクターは0基準のインデックスづけを使用し、1番目の要素はインデックス0になります。"

#. type: Plain text
#: original_texis/sequences.texi:407
msgid "Vectors are printed with square brackets surrounding the elements.  Thus, a vector whose elements are the symbols @code{a}, @code{b} and @code{a} is printed as @code{[a b a]}.  You can write vectors in the same way in Lisp input."
msgstr "ベクターは角カッコ(square brackets)で囲まれた要素としてプリントされます。したがってシンボル@code{a}、@code{b}、@code{a}を要素にもつベクターは、@code{[a b a]}とプリントされます。Lisp入力として同じ方法でベクターを記述できます。"

#. type: Plain text
#: original_texis/sequences.texi:412
msgid "A vector, like a string or a number, is considered a constant for evaluation: the result of evaluating it is the same vector.  This does not evaluate or even examine the elements of the vector.  @xref{Self-Evaluating Forms}."
msgstr "文字列や数値と同様にベクターは定数として評価され、評価された結果は同じベクターになります。ベクターの要素は評価も確認もされません。@ref{Self-Evaluating Forms}を参照してください。"

#. type: Plain text
#: original_texis/sequences.texi:414
msgid "Here are examples illustrating these principles:"
msgstr "以下はこれらの原理を表す例です:"

#. type: group
#: original_texis/sequences.texi:423
#, no-wrap
msgid ""
"(setq avector [1 two '(three) \"four\" [five]])\n"
"     @result{} [1 two (quote (three)) \"four\" [five]]\n"
"(eval avector)\n"
"     @result{} [1 two (quote (three)) \"four\" [five]]\n"
"(eq avector (eval avector))\n"
"     @result{} t\n"
msgstr ""
"(setq avector [1 two '(three) \"four\" [five]])\n"
"     @result{} [1 two (quote (three)) \"four\" [five]]\n"
"(eval avector)\n"
"     @result{} [1 two (quote (three)) \"four\" [five]]\n"
"(eq avector (eval avector))\n"
"     @result{} t\n"

#. type: section
#: original_texis/sequences.texi:427
#, no-wrap
msgid "Functions for Vectors"
msgstr "Functions for Vectors"

#. type: Plain text
#: original_texis/sequences.texi:430
msgid "Here are some functions that relate to vectors:"
msgstr "ベクターに関連した関数をいくつか示します:"

#. type: defun
#: original_texis/sequences.texi:431
#, no-wrap
msgid "vectorp object"
msgstr "vectorp object"

#. type: defun
#: original_texis/sequences.texi:433
msgid "This function returns @code{t} if @var{object} is a vector."
msgstr "この関数は@var{object}がベクターなら@code{t}をリターンする。"

#. type: group
#: original_texis/sequences.texi:440
#, no-wrap
msgid ""
"(vectorp [a])\n"
"     @result{} t\n"
"(vectorp \"asdf\")\n"
"     @result{} nil\n"
msgstr ""
"(vectorp [a])\n"
"     @result{} t\n"
"(vectorp \"asdf\")\n"
"     @result{} nil\n"

#. type: defun
#: original_texis/sequences.texi:444
#, no-wrap
msgid "vector &rest objects"
msgstr "vector &rest objects"

#. type: defun
#: original_texis/sequences.texi:447
msgid "This function creates and returns a vector whose elements are the arguments, @var{objects}."
msgstr "この関数は引数@var{objects}を要素にもつベクターを作成してリターンする。"

#. type: group
#: original_texis/sequences.texi:454
#, no-wrap
msgid ""
"(vector 'foo 23 [bar baz] \"rats\")\n"
"     @result{} [foo 23 [bar baz] \"rats\"]\n"
"(vector)\n"
"     @result{} []\n"
msgstr ""
"(vector 'foo 23 [bar baz] \"rats\")\n"
"     @result{} [foo 23 [bar baz] \"rats\"]\n"
"(vector)\n"
"     @result{} []\n"

#. type: defun
#: original_texis/sequences.texi:458
#, no-wrap
msgid "make-vector length object"
msgstr "make-vector length object"

#. type: defun
#: original_texis/sequences.texi:461
msgid "This function returns a new vector consisting of @var{length} elements, each initialized to @var{object}."
msgstr "この関数は各要素が@var{object}に初期化された、@var{length}個の要素からなる新しいベクターをリターンする。"

#. type: group
#: original_texis/sequences.texi:466
#, no-wrap
msgid ""
"(setq sleepy (make-vector 9 'Z))\n"
"     @result{} [Z Z Z Z Z Z Z Z Z]\n"
msgstr ""
"(setq sleepy (make-vector 9 'Z))\n"
"     @result{} [Z Z Z Z Z Z Z Z Z]\n"

#. type: defun
#: original_texis/sequences.texi:470
#, no-wrap
msgid "vconcat &rest sequences"
msgstr "vconcat &rest sequences"

#. type: cindex
#: original_texis/sequences.texi:471
#, no-wrap
msgid "copying vectors"
msgstr "copying vectors"

#. type: defun
#: original_texis/sequences.texi:476
msgid "This function returns a new vector containing all the elements of @var{sequences}.  The arguments @var{sequences} may be true lists, vectors, strings or bool-vectors.  If no @var{sequences} are given, the empty vector is returned."
msgstr "この関数は@var{sequences}のすべての要素を含む新しいベクターをリターンする。引数@var{sequences}は真リスト、ベクター、文字列、ブールベクター。@var{sequences}が与えられければ空のベクターがリターンされる。"

#. type: defun
#: original_texis/sequences.texi:479
msgid "The value is either the empty vector, or is a newly constructed nonempty vector that is not @code{eq} to any existing vector."
msgstr "値は空のベクター、またはすべての既存ベクターと@code{eq}ではないような空ではない新しいベクターのいずれか。"

#. type: group
#: original_texis/sequences.texi:486
#, no-wrap
msgid ""
"(setq a (vconcat '(A B C) '(D E F)))\n"
"     @result{} [A B C D E F]\n"
"(eq a (vconcat a))\n"
"     @result{} nil\n"
msgstr ""
"(setq a (vconcat '(A B C) '(D E F)))\n"
"     @result{} [A B C D E F]\n"
"(eq a (vconcat a))\n"
"     @result{} nil\n"

#. type: group
#: original_texis/sequences.texi:492
#, no-wrap
msgid ""
"(vconcat)\n"
"     @result{} []\n"
"(vconcat [A B C] \"aa\" '(foo (6 7)))\n"
"     @result{} [A B C 97 97 foo (6 7)]\n"
msgstr ""
"(vconcat)\n"
"     @result{} []\n"
"(vconcat [A B C] \"aa\" '(foo (6 7)))\n"
"     @result{} [A B C 97 97 foo (6 7)]\n"

#. type: defun
#: original_texis/sequences.texi:498
msgid "The @code{vconcat} function also allows byte-code function objects as arguments.  This is a special feature to make it easy to access the entire contents of a byte-code function object.  @xref{Byte-Code Objects}."
msgstr "@code{vconcat}関数は、引数としてバイトコード関数オブジェクトも受け取ることができる。これはバイトコード関数オブジェクトの内容全体にアクセスするのを容易にするための特別な機能である。@ref{Byte-Code Objects}を参照のこと。"

#. type: defun
#: original_texis/sequences.texi:502
msgid "For other concatenation functions, see @code{mapconcat} in @ref{Mapping Functions}, @code{concat} in @ref{Creating Strings}, and @code{append} in @ref{Building Lists}."
msgstr "結合を行なう他の関数については@ref{Mapping Functions}の@code{mapconcat}、@ref{Creating Strings}の@code{concat}、@ref{Building Lists}の@code{append}を参照されたい。"

#. type: Plain text
#: original_texis/sequences.texi:506
msgid "The @code{append} function also provides a way to convert a vector into a list with the same elements:"
msgstr "@code{append}関数はベクターを同じ要素をもつリストに変換する方法も提供します:"

#. type: group
#: original_texis/sequences.texi:513
#, no-wrap
msgid ""
"(setq avector [1 two (quote (three)) \"four\" [five]])\n"
"     @result{} [1 two (quote (three)) \"four\" [five]]\n"
"(append avector nil)\n"
"     @result{} (1 two (quote (three)) \"four\" [five])\n"
msgstr ""
"(setq avector [1 two (quote (three)) \"four\" [five]])\n"
"     @result{} [1 two (quote (three)) \"four\" [five]]\n"
"(append avector nil)\n"
"     @result{} (1 two (quote (three)) \"four\" [five])\n"

#. type: cindex
#: original_texis/sequences.texi:518
#, no-wrap
msgid "char-tables"
msgstr "char-tables"

#. type: cindex
#: original_texis/sequences.texi:519
#, no-wrap
msgid "extra slots of char-table"
msgstr "extra slots of char-table"

#. type: Plain text
#: original_texis/sequences.texi:529
msgid "A char-table is much like a vector, except that it is indexed by character codes.  Any valid character code, without modifiers, can be used as an index in a char-table.  You can access a char-table's elements with @code{aref} and @code{aset}, as with any array.  In addition, a char-table can have @dfn{extra slots} to hold additional data not associated with particular character codes.  Like vectors, char-tables are constants when evaluated, and can hold elements of any type."
msgstr "文字テーブル(char-table)はベクターとよく似ていますが、文字テーブルは文字コードによりインデックスづけされます。文字テーブルのインデックスには、修飾キーをともなわない任意の有効な文字コードを使用できます。他の配列と同様に、@code{aref}と@code{aset}で文字テーブルの要素にアクセスできます。加えて、文字テーブルは追加のデータを保持するために、特定の文字コードに関連づけられていない@dfn{エキストラスロット(extra slots)}をもつことができます。ベクターと同様、文字テーブルは定数として評価され、任意の型の要素を保持できます。"

#. type: cindex
#: original_texis/sequences.texi:530
#, no-wrap
msgid "subtype of char-table"
msgstr "subtype of char-table"

#. type: Plain text
#: original_texis/sequences.texi:533
msgid "Each char-table has a @dfn{subtype}, a symbol, which serves two purposes:"
msgstr "文字テーブルはそれぞれ@dfn{サブタイプ(subtype)}をもち、これは2つの目的をもつシンボルです:"

#. type: itemize
#: original_texis/sequences.texi:541
msgid "The subtype provides an easy way to tell what the char-table is for.  For instance, display tables are char-tables with @code{display-table} as the subtype, and syntax tables are char-tables with @code{syntax-table} as the subtype.  The subtype can be queried using the function @code{char-table-subtype}, described below."
msgstr "サブタイプはそれがなんのための文字テーブルなのかを簡単に表す方法を提供する。たとえばディスプレーテーブル(display tables)はサブタイプが@code{display-table}の文字テーブルであり、構文テーブル(syntax tables)はサブタイプが@code{syntax-table}の文字テーブル。以下で説明するように関数@code{char-table-subtype}を使用してサブタイプの問い合わせが可能。"

#. type: itemize
#: original_texis/sequences.texi:549
msgid "The subtype controls the number of @dfn{extra slots} in the char-table.  This number is specified by the subtype's @code{char-table-extra-slots} symbol property (@pxref{Symbol Properties}), whose value should be an integer between 0 and 10.  If the subtype has no such symbol property, the char-table has no extra slots."
msgstr "サブタイプは文字テーブル内のいくつかの@dfn{エキストラスロット(extra slots)}を制御する。エキストラスロットの数は、そのサブタイプの@code{char-table-extra-slots}シンボルプロパティー(@ref{Symbol Properties}を参照)により指定され、値は0から10の整数。サブタイプにそのようなシンボルプロパティーがなければ、その文字テーブルはエキストラスロットをもたない。"

#. type: cindex
#: original_texis/sequences.texi:551
#, no-wrap
msgid "parent of char-table"
msgstr "parent of char-table"

#. type: Plain text
#: original_texis/sequences.texi:558
msgid "A char-table can have a @dfn{parent}, which is another char-table.  If it does, then whenever the char-table specifies @code{nil} for a particular character @var{c}, it inherits the value specified in the parent.  In other words, @code{(aref @var{char-table} @var{c})} returns the value from the parent of @var{char-table} if @var{char-table} itself specifies @code{nil}."
msgstr "文字テーブルは@dfn{親(parent)}をもつことができ、これは他の文字テーブルです。文字テーブルが親をもつ場合、その文字テーブルで特定の文字@var{c}にたいして@code{nil}が指定されていたら、親と指定された文字テーブルで指定された値を継承します。言い方を変えると、文字テーブル@var{char-table}で@var{c}に@code{nil}が指定されていたら、@code{(aref @var{char-table} @var{c})}は@var{char-table}の親の値をリターンします。"

#. type: cindex
#: original_texis/sequences.texi:559
#, no-wrap
msgid "default value of char-table"
msgstr "default value of char-table"

#. type: Plain text
#: original_texis/sequences.texi:563
msgid "A char-table can also have a @dfn{default value}.  If so, then @code{(aref @var{char-table} @var{c})} returns the default value whenever the char-table does not specify any other non-@code{nil} value."
msgstr "文字テーブルは@dfn{デフォルト値(default value)}をもつこともできます。デフォルト値をもつとき、文字テーブル@var{char-table}が@var{c}にたいして@code{nil}値を指定すると、@code{(aref @var{char-table} @var{c})}はデフォルト値をリターンします。"

#. type: defun
#: original_texis/sequences.texi:564
#, no-wrap
msgid "make-char-table subtype &optional init"
msgstr "make-char-table subtype &optional init"

#. type: defun
#: original_texis/sequences.texi:569
msgid "Return a newly-created char-table, with subtype @var{subtype} (a symbol).  Each element is initialized to @var{init}, which defaults to @code{nil}.  You cannot alter the subtype of a char-table after the char-table is created."
msgstr "サブタイプ@var{subtype}(シンボル)をもつ、新たに作成された文字テーブルをリターンする。各要素は@var{init}に初期化され、デフォルトは@code{nil}。文字テーブルが作成された後で、文字テーブルのサブタイプを変更することはできない。"

#. type: defun
#: original_texis/sequences.texi:572
msgid "There is no argument to specify the length of the char-table, because all char-tables have room for any valid character code as an index."
msgstr "すべての文字テーブルは、インデックスとなる任意の有効な文字テーブルのための空間をもつので、文字テーブルの長さを指定する引数はない。"

#. type: defun
#: original_texis/sequences.texi:579
msgid "If @var{subtype} has the @code{char-table-extra-slots} symbol property, that specifies the number of extra slots in the char-table.  This should be an integer between 0 and 10; otherwise, @code{make-char-table} raises an error.  If @var{subtype} has no @code{char-table-extra-slots} symbol property (@pxref{Property Lists}), the char-table has no extra slots."
msgstr "@var{subtype}がシンボルプロパティー@code{char-table-extra-slots}をもつなら、それはその文字列テーブル内のエキストラスロットの数を指定する。値には0から10の整数を指定し、これ以外なら@code{make-char-table}はエラーとなる。@var{subtype}がシンボルプロパティー@code{char-table-extra-slots}(@ref{Property Lists}を参照)をもたなければ、その文字テーブルはエキストラスロットをもたない。"

#. type: defun
#: original_texis/sequences.texi:581
#, no-wrap
msgid "char-table-p object"
msgstr "char-table-p object"

#. type: defun
#: original_texis/sequences.texi:584
msgid "This function returns @code{t} if @var{object} is a char-table, and @code{nil} otherwise."
msgstr "この関数は@var{object}が文字テーブルなら@code{t}、それ以外は@code{nil}をリターンする。"

#. type: defun
#: original_texis/sequences.texi:586
#, no-wrap
msgid "char-table-subtype char-table"
msgstr "char-table-subtype char-table"

#. type: defun
#: original_texis/sequences.texi:588
msgid "This function returns the subtype symbol of @var{char-table}."
msgstr "この関数は@var{char-table}のサブタイプのシンボルをリターンする。"

#. type: Plain text
#: original_texis/sequences.texi:592
msgid "There is no special function to access default values in a char-table.  To do that, use @code{char-table-range} (see below)."
msgstr "文字テーブルのデフォルト値にアクセスするための特別な関数は存在しません。これを行なうには@code{char-table-range}を使用します(以下参照)。"

#. type: defun
#: original_texis/sequences.texi:593
#, no-wrap
msgid "char-table-parent char-table"
msgstr "char-table-parent char-table"

#. type: defun
#: original_texis/sequences.texi:596
msgid "This function returns the parent of @var{char-table}.  The parent is always either @code{nil} or another char-table."
msgstr "この関数は@var{char-table}の親をリターンする。親は常に@code{nil}か他の文字テーブルである。"

#. type: defun
#: original_texis/sequences.texi:598
#, no-wrap
msgid "set-char-table-parent char-table new-parent"
msgstr "set-char-table-parent char-table new-parent"

#. type: defun
#: original_texis/sequences.texi:600
msgid "This function sets the parent of @var{char-table} to @var{new-parent}."
msgstr "この関数は@var{char-table}の親を@var{new-parent}にセットする。"

#. type: defun
#: original_texis/sequences.texi:602
#, no-wrap
msgid "char-table-extra-slot char-table n"
msgstr "char-table-extra-slot char-table n"

#. type: defun
#: original_texis/sequences.texi:606
msgid "This function returns the contents of extra slot @var{n} of @var{char-table}.  The number of extra slots in a char-table is determined by its subtype."
msgstr "このガン数は、@var{char-table}のエキストラスロット@var{n}の内容をreturnします。文字テーブルのエキストラスロットの数は、文字テーブルのサブタイプにより決定されます。"

#. type: defun
#: original_texis/sequences.texi:608
#, no-wrap
msgid "set-char-table-extra-slot char-table n value"
msgstr "set-char-table-extra-slot char-table n value"

#. type: defun
#: original_texis/sequences.texi:611
msgid "This function stores @var{value} in extra slot @var{n} of @var{char-table}."
msgstr "この関数は、@var{char-table}のエキストラスロット@var{n}に、@var{value}を格納します。"

#. type: Plain text
#: original_texis/sequences.texi:615
msgid "A char-table can specify an element value for a single character code; it can also specify a value for an entire character set."
msgstr "文字テーブルは1つの文字コードにたいして1つの要素値(element value)を指定できます。文字テーブルは文字セット全体にたいして値を指定することもできます。"

#. type: defun
#: original_texis/sequences.texi:616
#, no-wrap
msgid "char-table-range char-table range"
msgstr "char-table-range char-table range"

#. type: defun
#: original_texis/sequences.texi:619
msgid "This returns the value specified in @var{char-table} for a range of characters @var{range}.  Here are the possibilities for @var{range}:"
msgstr "この関数は文字範囲@var{range}にたいして@var{char-table}で指定された値をリターンする。可能な@var{range}は以下のとおり:"

#. type: code{#1}
#: original_texis/sequences.texi:621 original_texis/sequences.texi:639
#, no-wrap
msgid "nil"
msgstr "nil"

#. type: table
#: original_texis/sequences.texi:623 original_texis/sequences.texi:641
msgid "Refers to the default value."
msgstr "デフォルト値への参照。"

#. type: var{#1}
#: original_texis/sequences.texi:624 original_texis/sequences.texi:645
#, no-wrap
msgid "char"
msgstr "char"

#. type: table
#: original_texis/sequences.texi:627 original_texis/sequences.texi:648
msgid "Refers to the element for character @var{char} (supposing @var{char} is a valid character code)."
msgstr "文字@var{char}にたいする要素への参照(@var{char}は有効な文字コードであると仮定)。"

#. type: code{#1}
#: original_texis/sequences.texi:628 original_texis/sequences.texi:649
#, no-wrap
msgid "(@var{from} . @var{to})"
msgstr "(@var{from} . @var{to})"

#. type: table
#: original_texis/sequences.texi:631 original_texis/sequences.texi:652
msgid "A cons cell refers to all the characters in the inclusive range @samp{[@var{from}..@var{to}]}."
msgstr "包括的な範囲@samp{[@var{from}..@var{to}]}内のすべての文字を参照するコンスセル。"

#. type: defun
#: original_texis/sequences.texi:634
#, no-wrap
msgid "set-char-table-range char-table range value"
msgstr "set-char-table-range char-table range value"

#. type: defun
#: original_texis/sequences.texi:637
msgid "This function sets the value in @var{char-table} for a range of characters @var{range}.  Here are the possibilities for @var{range}:"
msgstr "この関数は@var{char-table}内の文字範囲@var{range}にたいして値をセットする。可能な@var{range}は以下のとおり:"

#. type: code{#1}
#: original_texis/sequences.texi:642
#, no-wrap
msgid "t"
msgstr "t"

#. type: table
#: original_texis/sequences.texi:644
msgid "Refers to the whole range of character codes."
msgstr "文字コード範囲の全体を参照。"

#. type: defun
#: original_texis/sequences.texi:655
#, no-wrap
msgid "map-char-table function char-table"
msgstr "map-char-table function char-table"

#. type: defun
#: original_texis/sequences.texi:663
msgid "This function calls its argument @var{function} for each element of @var{char-table} that has a non-@code{nil} value.  The call to @var{function} is with two arguments, a key and a value.  The key is a possible @var{range} argument for @code{char-table-range}---either a valid character or a cons cell @code{(@var{from} . @var{to})}, specifying a range of characters that share the same value.  The value is what @code{(char-table-range @var{char-table} @var{key})} returns."
msgstr "この関数は@var{char-table}の非@code{nil}値ではない各要素にたいして引数@var{function}を呼び出す。@var{function}の呼び出しでは2つの引数(keyとvalue)が指定される。keyは@code{char-table-range}にたいする可能な@var{range} (有効な文字か、同じ値を共有する文字範囲を指定するコンスセル@code{(@var{from} . @var{to})})。valueは@code{(char-table-range @var{char-table} @var{key})}がリターンする値。"

#. type: defun
#: original_texis/sequences.texi:666
msgid "Overall, the key-value pairs passed to @var{function} describe all the values stored in @var{char-table}."
msgstr "全体として、@var{function}に渡されるkey-valueのペアは@var{char-table}に格納されたすべての値を表す。"

#. type: defun
#: original_texis/sequences.texi:670
msgid "The return value is always @code{nil}; to make calls to @code{map-char-table} useful, @var{function} should have side effects.  For example, here is how to examine the elements of the syntax table:"
msgstr "リターン値は常に@code{nil}である。@code{map-char-table}呼び出しを有用にするために@var{function}は副作用をもつこと。たとえば以下は構文テーブルを調べる方法:"

#. type: example
#: original_texis/sequences.texi:688
#, no-wrap
msgid ""
"(let (accumulator)\n"
"   (map-char-table\n"
"    #'(lambda (key value)\n"
"        (setq accumulator\n"
"              (cons (list\n"
"                     (if (consp key)\n"
"                         (list (car key) (cdr key))\n"
"                       key)\n"
"                     value)\n"
"                    accumulator)))\n"
"    (syntax-table))\n"
"   accumulator)\n"
"@result{}\n"
"(((2597602 4194303) (2)) ((2597523 2597601) (3))\n"
" ... (65379 (5 . 65378)) (65378 (4 . 65379)) (65377 (1))\n"
" ... (12 (0)) (11 (3)) (10 (12)) (9 (0)) ((0 8) (3)))\n"
msgstr ""
"(let (accumulator)\n"
"   (map-char-table\n"
"    #'(lambda (key value)\n"
"        (setq accumulator\n"
"              (cons (list\n"
"                     (if (consp key)\n"
"                         (list (car key) (cdr key))\n"
"                       key)\n"
"                     value)\n"
"                    accumulator)))\n"
"    (syntax-table))\n"
"   accumulator)\n"
"@result{}\n"
"(((2597602 4194303) (2)) ((2597523 2597601) (3))\n"
" ... (65379 (5 . 65378)) (65378 (4 . 65379)) (65377 (1))\n"
" ... (12 (0)) (11 (3)) (10 (12)) (9 (0)) ((0 8) (3)))\n"

#. type: cindex
#: original_texis/sequences.texi:692 original_texis/sequences.texi:693
#, no-wrap
msgid "Bool-vectors"
msgstr "Bool-vectors"

#. type: Plain text
#: original_texis/sequences.texi:701
msgid "A bool-vector is much like a vector, except that it stores only the values @code{t} and @code{nil}.  If you try to store any non-@code{nil} value into an element of the bool-vector, the effect is to store @code{t} there.  As with all arrays, bool-vector indices start from 0, and the length cannot be changed once the bool-vector is created.  Bool-vectors are constants when evaluated."
msgstr "ブールベクター(bool-vector)はベクターとよく似ていますが、値に@code{t}と@code{nil}しか格納できません。ブールベクターの要素に非@code{nil}値の格納を試みたると、そこには@code{t}が格納されます。すべての配列と同様、ブールベクターのインデックスは0から開始され、一度ブールベクターが作成されたら長さを変更することはできません。ブールベクターは定数として評価されます。"

#. type: Plain text
#: original_texis/sequences.texi:705
msgid "There are two special functions for working with bool-vectors; aside from that, you manipulate them with same functions used for other kinds of arrays."
msgstr "ブールベクターを処理する、特別な関数が2つあります。その関数意外にも、他の種類の配列に使用されるのと同じ関数で、ブールベクターを操作できます。"

#. type: defun
#: original_texis/sequences.texi:706
#, no-wrap
msgid "make-bool-vector length initial"
msgstr "make-bool-vector length initial"

#. type: defun
#: original_texis/sequences.texi:709
msgid "Return a new bool-vector of @var{length} elements, each one initialized to @var{initial}."
msgstr "@var{initial}に初期化された@var{length}要素の新しいブールベクターをリターンする。"

#. type: defun
#: original_texis/sequences.texi:711
#, no-wrap
msgid "bool-vector-p object"
msgstr "bool-vector-p object"

#. type: defun
#: original_texis/sequences.texi:714
msgid "This returns @code{t} if @var{object} is a bool-vector, and @code{nil} otherwise."
msgstr "この関数は@var{object}がブールベクターであれば@code{t}、それ以外は@code{nil}をリターンする。"

#. type: Plain text
#: original_texis/sequences.texi:717
msgid "There are also some bool-vector set operation functions, described below:"
msgstr "以下で説明するように、ブールベクターのセット処理を行なう関数がいくつかあります:"

#. type: defun
#: original_texis/sequences.texi:718
#, no-wrap
msgid "bool-vector-exclusive-or a b &optional c"
msgstr "bool-vector-exclusive-or a b &optional c"

#. type: defun
#: original_texis/sequences.texi:722
msgid "Return @dfn{bitwise exclusive or} of bool vectors @var{a} and @var{b}.  If optional argument @var{c} is given, the result of this operation is stored into @var{c}.  All arguments should be bool vectors of the same length."
msgstr "ブールベクター@var{a}と@var{b}の@dfn{ビットごとの排他的論理和(bitwise exclusive or)}をリターンする。オプション引数@var{c}が与えられたら、この処理の結果は@var{c}に格納される。引数にはすべて同じ長さのブールベクターを指定すること。"

#. type: defun
#: original_texis/sequences.texi:724
#, no-wrap
msgid "bool-vector-union a b &optional c"
msgstr "bool-vector-union a b &optional c"

#. type: defun
#: original_texis/sequences.texi:728
msgid "Return @dfn{bitwise or} of bool vectors @var{a} and @var{b}.  If optional argument @var{c} is given, the result of this operation is stored into @var{c}.  All arguments should be bool vectors of the same length."
msgstr "ブールベクター@var{a}と@var{b}の@dfn{ビットごとの論理和(bitwise or)}をリターンする。オプション引数@var{c}が与えられたら、この処理の結果は@var{c}に格納される。引数にはすべて同じ長さのブールベクターを指定すること。"

#. type: defun
#: original_texis/sequences.texi:730
#, no-wrap
msgid "bool-vector-intersection a b &optional c"
msgstr "bool-vector-intersection a b &optional c"

#. type: defun
#: original_texis/sequences.texi:734
msgid "Return @dfn{bitwise and} of bool vectors @var{a} and @var{b}.  If optional argument @var{c} is given, the result of this operation is stored into @var{c}.  All arguments should be bool vectors of the same length."
msgstr "ブールベクター@var{a}と@var{b}の@dfn{ビットごとの論理積(bitwise and)}をリターンする。オプション引数@var{c}が与えられたら、この処理の結果は@var{c}に格納される。引数にはすべて同じ長さのブールベクターを指定すること。"

#. type: defun
#: original_texis/sequences.texi:736
#, no-wrap
msgid "bool-vector-set-difference a b &optional c"
msgstr "bool-vector-set-difference a b &optional c"

#. type: defun
#: original_texis/sequences.texi:740
msgid "Return @dfn{set difference} of bool vectors @var{a} and @var{b}.  If optional argument @var{c} is given, the result of this operation is stored into @var{c}.  All arguments should be bool vectors of the same length."
msgstr "ブールベクター@var{a}と@var{b}の@dfn{差集合(set difference)}をリターンする。オプション引数@var{c}が与えられたら、この処理の結果は@var{c}に格納される。引数にはすべて同じ長さのブールベクターを指定すること。"

#. type: defun
#: original_texis/sequences.texi:742
#, no-wrap
msgid "bool-vector-not a &optional b"
msgstr "bool-vector-not a &optional b"

#. type: defun
#: original_texis/sequences.texi:746
msgid "Return @dfn{set complement} of bool vector @var{a}.  If optional argument @var{b} is given, the result of this operation is stored into @var{b}.  All arguments should be bool vectors of the same length."
msgstr "ブールベクター@var{a}の@dfn{補集合(set complement)}をリターンする。オプション引数@var{b}が与えられたら、この処理の結果は@var{b}に格納される。引数にはすべて同じ長さのブールベクターを指定すること。"

#. type: defun
#: original_texis/sequences.texi:748
#, no-wrap
msgid "bool-vector-subsetp a b"
msgstr "bool-vector-subsetp a b"

#. type: defun
#: original_texis/sequences.texi:752
msgid "Return @code{t} if every @code{t} value in @var{a} is also t in @var{b}, @code{nil} otherwise.  All arguments should be bool vectors of the same length."
msgstr "@var{a}内のすべての@code{t}値が、@var{b}でも@code{t}値なら@code{t}、それ以外は@code{nil}をリターンする。引数にはすべて同じ長さのブールベクターを指定すること。"

#. type: defun
#: original_texis/sequences.texi:754
#, no-wrap
msgid "bool-vector-count-consecutive a b i"
msgstr "bool-vector-count-consecutive a b i"

#. type: defun
#: original_texis/sequences.texi:758
msgid "Return the number of consecutive elements in @var{a} equal @var{b} starting at @var{i}.  @code{a} is a bool vector, @var{b} is @code{t} or @code{nil}, and @var{i} is an index into @code{a}."
msgstr "@var{i}から始まる@var{a}の、@var{b}と等しい連続する要素の数をリターンする。@code{a}はブールベクターで、@var{b}は@code{t}か@code{nil}、@var{i}は@code{a}のインデックス。"

#. type: defun
#: original_texis/sequences.texi:760
#, no-wrap
msgid "bool-vector-count-population a"
msgstr "bool-vector-count-population a"

#. type: defun
#: original_texis/sequences.texi:762
msgid "Return the number of elements that are @code{t} in bool vector @var{a}."
msgstr "ブールベクター@var{a}から@code{t}であるような要素の数をリターンする。"

#. type: Plain text
#: original_texis/sequences.texi:767
msgid "Here is an example of creating, examining, and updating a bool-vector.  Note that the printed form represents up to 8 boolean values as a single character."
msgstr "以下はブールベクターを作成、確認、更新する例です。長さ8以下のブール値のプリント表記は、1つの文字で表されることに注意してください。"

#. type: example
#: original_texis/sequences.texi:777
#, no-wrap
msgid ""
"(setq bv (make-bool-vector 5 t))\n"
"     @result{} #&5\"^_\"\n"
"(aref bv 1)\n"
"     @result{} t\n"
"(aset bv 3 nil)\n"
"     @result{} nil\n"
"bv\n"
"     @result{} #&5\"^W\"\n"
msgstr ""
"(setq bv (make-bool-vector 5 t))\n"
"     @result{} #&5\"^_\"\n"
"(aref bv 1)\n"
"     @result{} t\n"
"(aset bv 3 nil)\n"
"     @result{} nil\n"
"bv\n"
"     @result{} #&5\"^W\"\n"

#. type: Plain text
#: original_texis/sequences.texi:782
msgid "These results make sense because the binary codes for control-_ and control-W are 11111 and 10111, respectively."
msgstr "control-_の2進コードは11111、control-Wは10111なので、この結果は理にかなっています。"

#. type: section
#: original_texis/sequences.texi:784
#, no-wrap
msgid "Managing a Fixed-Size Ring of Objects"
msgstr "Managing a Fixed-Size Ring of Objects"

#. type: cindex
#: original_texis/sequences.texi:786
#, no-wrap
msgid "ring data structure"
msgstr "ring data structure"

#. type: Plain text
#: original_texis/sequences.texi:791
msgid "A @dfn{ring} is a fixed-size data structure that supports insertion, deletion, rotation, and modulo-indexed reference and traversal.  An efficient ring data structure is implemented by the @code{ring} package.  It provides the functions listed in this section."
msgstr "@dfn{リング(ring)}は挿入、削除、ローテーション、剰余(modulo)でインデックスづけされた、参照と走査(traversal)をサポートする固定長のデータ構造です。@code{ring}パッケージにより効率的なリングデータ構造が実装されています。このパッケージは、このセクションにリストした関数を提供します。"

#. type: Plain text
#: original_texis/sequences.texi:796
msgid "Note that several ``rings'' in Emacs, like the kill ring and the mark ring, are actually implemented as simple lists, @emph{not} using the @code{ring} package; thus the following functions won't work on them."
msgstr "killリングやマークリングのような、Emacsにあるいくつかの``リング''は、実際には単なるリストとして実装されていることに注意してください。したがって、これらのリングにたいしては、以下の関数は機能しないでしょう。"

#. type: defun
#: original_texis/sequences.texi:797
#, no-wrap
msgid "make-ring size"
msgstr "make-ring size"

#. type: defun
#: original_texis/sequences.texi:800
msgid "This returns a new ring capable of holding @var{size} objects.  @var{size} should be an integer."
msgstr "この関数は@var{size}オブジェクトを保持できる、新しいリングをリターンする。@var{size}は整数。"

#. type: defun
#: original_texis/sequences.texi:802
#, no-wrap
msgid "ring-p object"
msgstr "ring-p object"

#. type: defun
#: original_texis/sequences.texi:804
msgid "This returns @code{t} if @var{object} is a ring, @code{nil} otherwise."
msgstr "この関数は@var{object}がリングなら@code{t}、それ以外は@code{nil}をリターンする。"

#. type: defun
#: original_texis/sequences.texi:806
#, no-wrap
msgid "ring-size ring"
msgstr "ring-size ring"

#. type: defun
#: original_texis/sequences.texi:808
msgid "This returns the maximum capacity of the @var{ring}."
msgstr "この関数は@var{ring}の最大の要素数をリターンする。"

#. type: defun
#: original_texis/sequences.texi:810
#, no-wrap
msgid "ring-length ring"
msgstr "ring-length ring"

#. type: defun
#: original_texis/sequences.texi:813
msgid "This returns the number of objects that @var{ring} currently contains.  The value will never exceed that returned by @code{ring-size}."
msgstr "この関数は@var{ring}に現在含まれるオブジェクトの数をリターンする。値が@code{ring-size}のリターンする値を超えることはない。"

#. type: defun
#: original_texis/sequences.texi:815
#, no-wrap
msgid "ring-elements ring"
msgstr "ring-elements ring"

#. type: defun
#: original_texis/sequences.texi:817
msgid "This returns a list of the objects in @var{ring}, in order, newest first."
msgstr "この関数は@var{ring}内のオブジェクトのリストをリターンする。リストの順序は新しいオブジェクトが先頭になる。"

#. type: defun
#: original_texis/sequences.texi:819
#, no-wrap
msgid "ring-copy ring"
msgstr "ring-copy ring"

#. type: defun
#: original_texis/sequences.texi:822
msgid "This returns a new ring which is a copy of @var{ring}.  The new ring contains the same (@code{eq}) objects as @var{ring}."
msgstr "この関数は新しいリングとして@var{ring}のコピーをリターンする。新しいリングは@var{ring}と同じ(@code{eq}な)オブジェクトを含む。"

#. type: defun
#: original_texis/sequences.texi:824
#, no-wrap
msgid "ring-empty-p ring"
msgstr "ring-empty-p ring"

#. type: defun
#: original_texis/sequences.texi:826
msgid "This returns @code{t} if @var{ring} is empty, @code{nil} otherwise."
msgstr "この関数は@var{ring}が空なら@code{t}、それ以外は@code{nil}をリターンする。"

#. type: Plain text
#: original_texis/sequences.texi:832
msgid "The newest element in the ring always has index 0.  Higher indices correspond to older elements.  Indices are computed modulo the ring length.  Index @minus{}1 corresponds to the oldest element, @minus{}2 to the next-oldest, and so forth."
msgstr "リング内の1番新しい要素は常にインデックス0をもちます。より大きいインデックスは、より古い要素に対応します。インデックスはリング長のmoduloにより計算されます。インデックス@minus{}1は1番古い要素、@minus{}2は次に古い要素、...となります。"

#. type: defun
#: original_texis/sequences.texi:833
#, no-wrap
msgid "ring-ref ring index"
msgstr "ring-ref ring index"

#. type: defun
#: original_texis/sequences.texi:837
msgid "This returns the object in @var{ring} found at index @var{index}.  @var{index} may be negative or greater than the ring length.  If @var{ring} is empty, @code{ring-ref} signals an error."
msgstr "この関数はインデックス@var{index}にある@var{ring}内のオブジェクトをリターンする。@var{index}には負やリング長より大きい数を指定できる。@var{ring}が空なら@code{ring-ref}はエラーをシグナルする。"

#. type: defun
#: original_texis/sequences.texi:839
#, no-wrap
msgid "ring-insert ring object"
msgstr "ring-insert ring object"

#. type: defun
#: original_texis/sequences.texi:842
msgid "This inserts @var{object} into @var{ring}, making it the newest element, and returns @var{object}."
msgstr "この関数は1番新しい要素として@var{object}を@var{ring}に挿入して@var{object}をリターンする。"

#. type: defun
#: original_texis/sequences.texi:845
msgid "If the ring is full, insertion removes the oldest element to make room for the new element."
msgstr "リングが満杯なら新しい要素用の空きを作るために、挿入により1番古い要素が削除される。"

#. type: defun
#: original_texis/sequences.texi:847
#, no-wrap
msgid "ring-remove ring &optional index"
msgstr "ring-remove ring &optional index"

#. type: defun
#: original_texis/sequences.texi:852
msgid "Remove an object from @var{ring}, and return that object.  The argument @var{index} specifies which item to remove; if it is @code{nil}, that means to remove the oldest item.  If @var{ring} is empty, @code{ring-remove} signals an error."
msgstr "@var{ring}からオブジェクトを削除してそのオブジェクトをリターンする。引数@var{index}はどのアイテムを削除するかを指定する。これが@code{nil}なら、それは1番古いアイテムを削除することを意味する。@var{ring}が空なら@code{ring-remove}はエラーをシグナルする。"

#. type: defun
#: original_texis/sequences.texi:854
#, no-wrap
msgid "ring-insert-at-beginning ring object"
msgstr "ring-insert-at-beginning ring object"

#. type: defun
#: original_texis/sequences.texi:857
msgid "This inserts @var{object} into @var{ring}, treating it as the oldest element.  The return value is not significant."
msgstr "この関数は1番古い要素として@var{object}を@var{ring}に挿入する。リターン値に意味はない。"

#. type: defun
#: original_texis/sequences.texi:860
msgid "If the ring is full, this function removes the newest element to make room for the inserted element."
msgstr "リングが満杯なら、この関数は挿入される要素のための空きを作るために1番新しい要素を削除する。"

#. type: cindex
#: original_texis/sequences.texi:862
#, no-wrap
msgid "fifo data structure"
msgstr "fifo data structure"

#. type: Plain text
#: original_texis/sequences.texi:865
msgid "If you are careful not to exceed the ring size, you can use the ring as a first-in-first-out queue.  For example:"
msgstr "リングサイズを超過しないよう注意すれば、そのリングをFIFO(first-in-first-out: 先入れ先出し)のキューとして使用することができます。たとえば:"

#. type: lisp
#: original_texis/sequences.texi:874
#, no-wrap
msgid ""
"(let ((fifo (make-ring 5)))\n"
"  (mapc (lambda (obj) (ring-insert fifo obj))\n"
"        '(0 one \"two\"))\n"
"  (list (ring-remove fifo) t\n"
"        (ring-remove fifo) t\n"
"        (ring-remove fifo)))\n"
"     @result{} (0 t one t \"two\")\n"
msgstr ""
"(let ((fifo (make-ring 5)))\n"
"  (mapc (lambda (obj) (ring-insert fifo obj))\n"
"        '(0 one \"two\"))\n"
"  (list (ring-remove fifo) t\n"
"        (ring-remove fifo) t\n"
"        (ring-remove fifo)))\n"
"     @result{} (0 t one t \"two\")\n"
