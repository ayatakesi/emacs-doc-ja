# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Emacs 26.1\n"
"POT-Creation-Date: 2020-08-02 05:43+0900\n"
"PO-Revision-Date: 2020-06-15 14:11+0900\n"
"Last-Translator: Takeshi Ayanokoji <takeshi.ayanokoji@gmail.com>\n"
"Language-Team: Japanese <takeshi.ayanokoji@gmail.com>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: original_texis/lists.texi:6 original_texis/lists.texi:7
#, no-wrap
msgid "Lists"
msgstr "Lists"

#. type: cindex
#: original_texis/lists.texi:8
#, no-wrap
msgid "lists"
msgstr "lists"

#. type: cindex
#: original_texis/lists.texi:9
#, no-wrap
msgid "element (of list)"
msgstr "element (of list)"

#. type: Plain text
#: original_texis/lists.texi:16
msgid "A @dfn{list} represents a sequence of zero or more elements (which may be any Lisp objects).  The important difference between lists and vectors is that two or more lists can share part of their structure; in addition, you can insert or delete elements in a list without copying the whole list."
msgstr "@dfn{リスト(list)}は0個以上の要素(任意のLispオブジェクト)のシーケンスを表します。リストとベクターの重要な違いは、2つ以上のリストが構造の一部を共有できることです。加えて、リスト全体をコピーすることなく要素の挿入と削除ができます。"

#. type: node
#: original_texis/lists.texi:27 original_texis/lists.texi:29
#, no-wrap
msgid "Cons Cells"
msgstr "Cons Cells"

#. type: menuentry
#: original_texis/lists.texi:27
msgid "How lists are made out of cons cells."
msgstr "コンスセルからリストが作られる方法。"

#. type: node
#: original_texis/lists.texi:27 original_texis/lists.texi:88
#, no-wrap
msgid "List-related Predicates"
msgstr "List-related Predicates"

#. type: menuentry
#: original_texis/lists.texi:27
msgid "Is this object a list? Comparing two lists."
msgstr "このオブジェクトはリストか? 2つのリストを比較する。"

#. type: node
#: original_texis/lists.texi:27 original_texis/lists.texi:176
#, no-wrap
msgid "List Elements"
msgstr "List Elements"

#. type: menuentry
#: original_texis/lists.texi:27
msgid "Extracting the pieces of a list."
msgstr "リストの一部を抽出する。"

#. type: node
#: original_texis/lists.texi:27 original_texis/lists.texi:431
#, no-wrap
msgid "Building Lists"
msgstr "Building Lists"

#. type: menuentry
#: original_texis/lists.texi:27
msgid "Creating list structure."
msgstr "リスト構造の作成。"

#. type: node
#: original_texis/lists.texi:27 original_texis/lists.texi:729
#, no-wrap
msgid "List Variables"
msgstr "List Variables"

#. type: menuentry
#: original_texis/lists.texi:27
msgid "Modifying lists stored in variables."
msgstr "変数に保存されたリストにたいする変更。"

#. type: node
#: original_texis/lists.texi:27 original_texis/lists.texi:866
#, no-wrap
msgid "Modifying Lists"
msgstr "Modifying Lists"

#. type: menuentry
#: original_texis/lists.texi:27
msgid "Storing new pieces into an existing list."
msgstr "既存のリストに新しい要素を保存する。"

#. type: node
#: original_texis/lists.texi:27 original_texis/lists.texi:1210
#, no-wrap
msgid "Sets And Lists"
msgstr "Sets And Lists"

#. type: menuentry
#: original_texis/lists.texi:27
msgid "A list can represent a finite mathematical set."
msgstr "リストは有限な数学集合を表現できる。"

#. type: section
#: original_texis/lists.texi:27 original_texis/lists.texi:1484
#: original_texis/lists.texi:1485
#, no-wrap
msgid "Association Lists"
msgstr "Association Lists"

#. type: menuentry
#: original_texis/lists.texi:27
msgid "A list can represent a finite relation or mapping."
msgstr "リストは有限な関係またはマッピングを表現できる。"

#. type: section
#: original_texis/lists.texi:27 original_texis/lists.texi:1830
#: original_texis/lists.texi:1831
#, no-wrap
msgid "Property Lists"
msgstr "Property Lists"

#. type: menuentry
#: original_texis/lists.texi:27
msgid "A list of paired elements."
msgstr "要素ペアのリスト。"

#. type: section
#: original_texis/lists.texi:30
#, no-wrap
msgid "Lists and Cons Cells"
msgstr "Lists and Cons Cells"

#. type: cindex
#: original_texis/lists.texi:31
#, no-wrap
msgid "lists and cons cells"
msgstr "lists and cons cells"

#. type: Plain text
#: original_texis/lists.texi:40
msgid "Lists in Lisp are not a primitive data type; they are built up from @dfn{cons cells} (@pxref{Cons Cell Type}).  A cons cell is a data object that represents an ordered pair.  That is, it has two slots, and each slot @dfn{holds}, or @dfn{refers to}, some Lisp object.  One slot is known as the @sc{car}, and the other is known as the @sc{cdr}.  (These names are traditional; see @ref{Cons Cell Type}.)  @sc{cdr} is pronounced ``could-er''."
msgstr "Lispでのリストは基本データ型ではありません。リストは@dfn{コンスセル(cons cells)}から構築されます(@ref{Cons Cell Type}を参照)。コンスセルは順序つきペアを表現するデータオブジェクトです。つまりコンスセルは2つのスロットをもち、それぞれのスロットはLispオブジェクトを@dfn{保持(holds)}または@dfn{参照(refers to)}します。1つのスロットは@sc{car}、もう1つは@sc{cdr}です(これらの名前は歴史的なものである。@ref{Cons Cell Type}を参照されたい)。@sc{cdr}は``could-er(クダー)''と発音します。"

#. type: Plain text
#: original_texis/lists.texi:43
msgid "We say that ``the @sc{car} of this cons cell is'' whatever object its @sc{car} slot currently holds, and likewise for the @sc{cdr}."
msgstr "わたしたちは、コンスセルの@sc{car}スロットに現在保持されているオブジェクトが何であれ、``このコンスセルの@sc{car}は、...''のような言い方をします。これは@sc{cdr}の場合でも同様です。"

#. type: Plain text
#: original_texis/lists.texi:52
msgid "A list is a series of cons cells chained together, so that each cell refers to the next one.  There is one cons cell for each element of the list.  By convention, the @sc{car}s of the cons cells hold the elements of the list, and the @sc{cdr}s are used to chain the list (this asymmetry between @sc{car} and @sc{cdr} is entirely a matter of convention; at the level of cons cells, the @sc{car} and @sc{cdr} slots have similar properties).  Hence, the @sc{cdr} slot of each cons cell in a list refers to the following cons cell."
msgstr "リストとは互いに連なる(chained together)一連のコンスセルであり、各セルは次のセルを参照します。リストの各要素にたいして1つのコンスセルがあります。慣例によりコンスセルの@sc{car}はリストの要素を保持し、@sc{cdr}はリストをチェーンするのに使用されます(@sc{car}と@sc{cdr}の間の非対称性は完全に慣例的なものである。コンスセルのレベルでは@sc{car}スロットと@sc{cdr}スロットは同じようなプロパティーをもつ)。したがって、リスト内の各コンスセルの@sc{cdr}スロットは次のコンスセルを参照します。"

#. type: cindex
#: original_texis/lists.texi:53
#, no-wrap
msgid "proper list"
msgstr "proper list"

#. type: cindex
#: original_texis/lists.texi:54
#, no-wrap
msgid "true list"
msgstr "true list"

#. type: Plain text
#: original_texis/lists.texi:63
msgid "Also by convention, the @sc{cdr} of the last cons cell in a list is @code{nil}.  We call such a @code{nil}-terminated structure a @dfn{proper list}@footnote{It is sometimes also referred to as a @dfn{true list}, but we generally do not use this terminology in this manual.}.  In Emacs Lisp, the symbol @code{nil} is both a symbol and a list with no elements.  For convenience, the symbol @code{nil} is considered to have @code{nil} as its @sc{cdr} (and also as its @sc{car})."
msgstr "これも慣例的なものですがリスト内の最後のコンスセルの@sc{cdr}は@code{nil}です。わたしたちはこのような@code{nil}で終端された構造を@dfn{正リスト(proper list)}と呼びます@footnote{これは@dfn{真リスト(true list)}と呼ばれることもありますが、このマニュアルでは一般的にこの用語を使用しません。}。Emacs Lispではシンボル@code{nil}はシンボルであり、かつ要素なしのリストでもあります。便宜上、シンボル@code{nil}はその@sc{cdr}(と@sc{car})に@code{nil}をもつと考えます。"

#. type: Plain text
#: original_texis/lists.texi:67
msgid "Hence, the @sc{cdr} of a proper list is always a proper list.  The @sc{cdr} of a nonempty proper list is a proper list containing all the elements except the first."
msgstr "したがって正リストの@sc{cdr}は常に正リストです。空でない正リストの@sc{cdr}は1番目の要素以外を含む正リストです。"

#. type: cindex
#: original_texis/lists.texi:68
#, no-wrap
msgid "dotted list"
msgstr "dotted list"

#. type: cindex
#: original_texis/lists.texi:69
#, no-wrap
msgid "circular list"
msgstr "circular list"

#. type: Plain text
#: original_texis/lists.texi:76
msgid "If the @sc{cdr} of a list's last cons cell is some value other than @code{nil}, we call the structure a @dfn{dotted list}, since its printed representation would use dotted pair notation (@pxref{Dotted Pair Notation}).  There is one other possibility: some cons cell's @sc{cdr} could point to one of the previous cons cells in the list.  We call that structure a @dfn{circular list}."
msgstr "リストの最後のコンスセルの@sc{cdr}が@code{nil}以外の何らかの値の場合、このリストのプリント表現はドットペア表記(dotted pair notation。@ref{Dotted Pair Notation}を参照のこと)を使用するので、わたしたちはこの構造を@dfn{ドットリスト(dotted list)}と呼びます。他の可能性もあります。あるコンスセルの@sc{cdr}が、そのリストのそれより前にある要素を指すかもしれません。わたしたちは、この構造を@dfn{循環リスト(circular list)}と呼びます。"

#. type: Plain text
#: original_texis/lists.texi:83
msgid "For some purposes, it does not matter whether a list is proper, circular or dotted.  If a program doesn't look far enough down the list to see the @sc{cdr} of the final cons cell, it won't care.  However, some functions that operate on lists demand proper lists and signal errors if given a dotted list.  Most functions that try to find the end of a list enter infinite loops if given a circular list."
msgstr "ある目的においてはそのリストが正リストか循環リストなのか、あるいはドットリストなのかが問題にならない場合もあります。そのプログラムがリストを充分に辿って最後のコンスセルの@sc{cdr}を確認しようとしないなら、これは問題になりません。しかしリストを処理する関数のいくつかは正リストを要求し、ドットリストの場合はエラーをシグナルします。リストの最後を探そうと試みる関数のほとんどは循環リストを与えると無限ループに突入します。"

#. type: cindex
#: original_texis/lists.texi:84
#, no-wrap
msgid "list structure"
msgstr "list structure"

#. type: Plain text
#: original_texis/lists.texi:87
msgid "Because most cons cells are used as part of lists, we refer to any structure made out of cons cells as a @dfn{list structure}."
msgstr "ほとんどのコンスセルはリストの一部として使用されるので、わたしたちはコンスセルで構成される任意の構造を@dfn{リスト構造(list structure)}と呼びます。"

#. type: section
#: original_texis/lists.texi:89
#, no-wrap
msgid "Predicates on Lists"
msgstr "Predicates on Lists"

#. type: cindex
#: original_texis/lists.texi:90
#, no-wrap
msgid "predicates for lists"
msgstr "predicates for lists"

#. type: cindex
#: original_texis/lists.texi:91
#, no-wrap
msgid "list predicates"
msgstr "list predicates"

#. type: Plain text
#: original_texis/lists.texi:98
msgid "The following predicates test whether a Lisp object is an atom, whether it is a cons cell or is a list, or whether it is the distinguished object @code{nil}.  (Many of these predicates can be defined in terms of the others, but they are used so often that it is worth having them.)"
msgstr "以下の述語はあるLispオブジェクトがアトムか、コンスセルか、リストなのか、またはオブジェクトが@code{nil}かどうかテストします(これらの述語の多くは他の述語で定義することもできるが、多用されるので個別に定義する価値がある)。"

#. type: defun
#: original_texis/lists.texi:99
#, no-wrap
msgid "consp object"
msgstr "consp object"

#. type: defun
#: original_texis/lists.texi:102
msgid "This function returns @code{t} if @var{object} is a cons cell, @code{nil} otherwise.  @code{nil} is not a cons cell, although it @emph{is} a list."
msgstr "この関数は@var{object}がコンスセルなら@code{t}、それ以外は@code{nil}をリターンする。たとえ@code{nil}が@emph{リスト}であっても、コンスセルではない。"

#. type: defun
#: original_texis/lists.texi:104
#, no-wrap
msgid "atom object"
msgstr "atom object"

#. type: defun
#: original_texis/lists.texi:109
msgid "This function returns @code{t} if @var{object} is an atom, @code{nil} otherwise.  All objects except cons cells are atoms.  The symbol @code{nil} is an atom and is also a list; it is the only Lisp object that is both."
msgstr "この関数は@var{object}がアトムなら@code{t}、それ以外は@code{nil}をリターンする。シンボル@code{nil}はアトムであり、かつリストでもある。そのようなLispオブジェクトは@code{nil}だけである。"

#. type: example
#: original_texis/lists.texi:112
#, no-wrap
msgid "(atom @var{object}) @equiv{} (not (consp @var{object}))\n"
msgstr "(atom @var{object}) @equiv{} (not (consp @var{object}))\n"

#. type: defun
#: original_texis/lists.texi:115
#, no-wrap
msgid "listp object"
msgstr "listp object"

#. type: defun
#: original_texis/lists.texi:118
msgid "This function returns @code{t} if @var{object} is a cons cell or @code{nil}.  Otherwise, it returns @code{nil}."
msgstr "この関数は@var{object}がコンスセルか@code{nil}なら@code{t}、それ以外は@code{nil}をリターンする。"

#. type: group
#: original_texis/lists.texi:123
#, no-wrap
msgid ""
"(listp '(1))\n"
"     @result{} t\n"
msgstr ""
"(listp '(1))\n"
"     @result{} t\n"

#. type: group
#: original_texis/lists.texi:127
#, no-wrap
msgid ""
"(listp '())\n"
"     @result{} t\n"
msgstr ""
"(listp '())\n"
"     @result{} t\n"

#. type: defun
#: original_texis/lists.texi:131
#, no-wrap
msgid "nlistp object"
msgstr "nlistp object"

#. type: defun
#: original_texis/lists.texi:134
msgid "This function is the opposite of @code{listp}: it returns @code{t} if @var{object} is not a list.  Otherwise, it returns @code{nil}."
msgstr "この関数は@code{listp}の反対である。@var{object}がリストでなければ@code{t}、それ以外は@code{nil}をリターンする。"

#. type: example
#: original_texis/lists.texi:137
#, no-wrap
msgid "(listp @var{object}) @equiv{} (not (nlistp @var{object}))\n"
msgstr "(listp @var{object}) @equiv{} (not (nlistp @var{object}))\n"

#. type: defun
#: original_texis/lists.texi:140
#, no-wrap
msgid "null object"
msgstr "null object"

#. type: defun
#: original_texis/lists.texi:146
msgid "This function returns @code{t} if @var{object} is @code{nil}, and returns @code{nil} otherwise.  This function is identical to @code{not}, but as a matter of clarity we use @code{null} when @var{object} is considered a list and @code{not} when it is considered a truth value (see @code{not} in @ref{Combining Conditions})."
msgstr "この関数は@var{object}が@code{nil}なら@code{t}、それ以外は@code{nil}をリターンする。この関数は@code{not}と等価だが、明解にするために@var{object}をリストだと考えるときは@code{null}、真偽値だと考えるときは@code{not}を使用すること(@ref{Combining Conditions}の@code{not}を参照)。"

#. type: group
#: original_texis/lists.texi:151
#, no-wrap
msgid ""
"(null '(1))\n"
"     @result{} nil\n"
msgstr ""
"(null '(1))\n"
"     @result{} nil\n"

#. type: group
#: original_texis/lists.texi:155
#, no-wrap
msgid ""
"(null '())\n"
"     @result{} t\n"
msgstr ""
"(null '())\n"
"     @result{} t\n"

#. type: defun
#: original_texis/lists.texi:159
#, fuzzy, no-wrap
#| msgid "listp object"
msgid "proper-list-p object"
msgstr "listp object"

#. type: defun
#: original_texis/lists.texi:163
msgid "This function returns the length of @var{object} if it is a proper list, @code{nil} otherwise (@pxref{Cons Cells}).  In addition to satisfying @code{listp}, a proper list is neither circular nor dotted."
msgstr ""

#. type: group
#: original_texis/lists.texi:168
#, fuzzy, no-wrap
#| msgid ""
#| "(listp '())\n"
#| "     @result{} t\n"
msgid ""
"(proper-list-p '(a b c))\n"
"    @result{} 3\n"
msgstr ""
"(listp '())\n"
"     @result{} t\n"

#. type: group
#: original_texis/lists.texi:172
#, fuzzy, no-wrap
#| msgid ""
#| "(car '(a b c))\n"
#| "     @result{} a\n"
msgid ""
"(proper-list-p '(a b . c))\n"
"    @result{} nil\n"
msgstr ""
"(car '(a b c))\n"
"     @result{} a\n"

#. type: section
#: original_texis/lists.texi:177
#, no-wrap
msgid "Accessing Elements of Lists"
msgstr "Accessing Elements of Lists"

#. type: cindex
#: original_texis/lists.texi:178
#, no-wrap
msgid "list elements"
msgstr "list elements"

#. type: defun
#: original_texis/lists.texi:180
#, no-wrap
msgid "car cons-cell"
msgstr "car cons-cell"

#. type: defun
#: original_texis/lists.texi:184
msgid "This function returns the value referred to by the first slot of the cons cell @var{cons-cell}.  In other words, it returns the @sc{car} of @var{cons-cell}."
msgstr "この関数はコンスセル@var{cons-cell}の1番目のスロットが参照する値をリターンする。言い換えるとこの関数は@var{cons-cell}の@sc{car}をリターンする。"

#. type: defun
#: original_texis/lists.texi:188
msgid "As a special case, if @var{cons-cell} is @code{nil}, this function returns @code{nil}.  Therefore, any list is a valid argument.  An error is signaled if the argument is not a cons cell or @code{nil}."
msgstr "特別なケースとして@var{cons-cell}が@code{nil}の場合、この関数は@code{nil}をリターンする。したがってリストはすべて引数として有効である。引数がコンスセルでも@code{nil}でもなければエラーがシグナルされる。"

#. type: group
#: original_texis/lists.texi:193
#, no-wrap
msgid ""
"(car '(a b c))\n"
"     @result{} a\n"
msgstr ""
"(car '(a b c))\n"
"     @result{} a\n"

#. type: group
#: original_texis/lists.texi:197
#, no-wrap
msgid ""
"(car '())\n"
"     @result{} nil\n"
msgstr ""
"(car '())\n"
"     @result{} nil\n"

#. type: defun
#: original_texis/lists.texi:201
#, no-wrap
msgid "cdr cons-cell"
msgstr "cdr cons-cell"

#. type: defun
#: original_texis/lists.texi:205
msgid "This function returns the value referred to by the second slot of the cons cell @var{cons-cell}.  In other words, it returns the @sc{cdr} of @var{cons-cell}."
msgstr "この関数はコンスセル@var{cons-cell}の2番目のスロットにより参照される値をリターンする。言い換えるとこの関数は@var{cons-cell}の@sc{cdr}をリターンする。"

#. type: defun
#: original_texis/lists.texi:209
msgid "As a special case, if @var{cons-cell} is @code{nil}, this function returns @code{nil}; therefore, any list is a valid argument.  An error is signaled if the argument is not a cons cell or @code{nil}."
msgstr "特別なケースとして@var{cons-cell}が@code{nil}の場合、この関数は@code{nil}をリターンする。したがってリストはすべて引数として有効である。引数がコンスセルでも@code{nil}でもければエラーがシグナルされる。"

#. type: group
#: original_texis/lists.texi:214
#, no-wrap
msgid ""
"(cdr '(a b c))\n"
"     @result{} (b c)\n"
msgstr ""
"(cdr '(a b c))\n"
"     @result{} (b c)\n"

#. type: group
#: original_texis/lists.texi:218
#, no-wrap
msgid ""
"(cdr '())\n"
"     @result{} nil\n"
msgstr ""
"(cdr '())\n"
"     @result{} nil\n"

#. type: defun
#: original_texis/lists.texi:222
#, no-wrap
msgid "car-safe object"
msgstr "car-safe object"

#. type: defun
#: original_texis/lists.texi:227
msgid "This function lets you take the @sc{car} of a cons cell while avoiding errors for other data types.  It returns the @sc{car} of @var{object} if @var{object} is a cons cell, @code{nil} otherwise.  This is in contrast to @code{car}, which signals an error if @var{object} is not a list."
msgstr "この関数により他のデータ型によるエラーを起こさずに、コンスセルの@sc{car}を取得できり。この関数は@var{object}がコンスセルなら@var{object}の@sc{car}、それ以外は@code{nil}をリターンする。この関数は、@var{object}がリストでなければエラーをシグナルする@code{car}とは対象的である。"

#. type: group
#: original_texis/lists.texi:236
#, no-wrap
msgid ""
"(car-safe @var{object})\n"
"@equiv{}\n"
"(let ((x @var{object}))\n"
"  (if (consp x)\n"
"      (car x)\n"
"    nil))\n"
msgstr ""
"(car-safe @var{object})\n"
"@equiv{}\n"
"(let ((x @var{object}))\n"
"  (if (consp x)\n"
"      (car x)\n"
"    nil))\n"

#. type: defun
#: original_texis/lists.texi:240
#, no-wrap
msgid "cdr-safe object"
msgstr "cdr-safe object"

#. type: defun
#: original_texis/lists.texi:246
msgid "This function lets you take the @sc{cdr} of a cons cell while avoiding errors for other data types.  It returns the @sc{cdr} of @var{object} if @var{object} is a cons cell, @code{nil} otherwise.  This is in contrast to @code{cdr}, which signals an error if @var{object} is not a list."
msgstr "この関数により他のデータ型によるエラーを起こさずに、コンスセルの@sc{cdr}を取得できる。この関数は@var{object}がコンスセルなら@var{object}の@sc{cdr}、それ以外は@code{nil}をリターンする。この関数は、@var{object}がリストでないときはエラーをシグナルする@code{cdr}とは対象的である。"

#. type: group
#: original_texis/lists.texi:255
#, no-wrap
msgid ""
"(cdr-safe @var{object})\n"
"@equiv{}\n"
"(let ((x @var{object}))\n"
"  (if (consp x)\n"
"      (cdr x)\n"
"    nil))\n"
msgstr ""
"(cdr-safe @var{object})\n"
"@equiv{}\n"
"(let ((x @var{object}))\n"
"  (if (consp x)\n"
"      (cdr x)\n"
"    nil))\n"

#. type: defmac
#: original_texis/lists.texi:259
#, no-wrap
msgid "pop listname"
msgstr "pop listname"

#. type: defmac
#: original_texis/lists.texi:265
msgid "This macro provides a convenient way to examine the @sc{car} of a list, and take it off the list, all at once.  It operates on the list stored in @var{listname}.  It removes the first element from the list, saves the @sc{cdr} into @var{listname}, then returns the removed element."
msgstr "このマクロはリストの@sc{car}を調べて、それをリストから取り去るのを一度に行なう便利な方法を提供する。この関数は@var{listname}に格納されたリストにたいして処理を行なう。この関数はリストから1番目の要素を削除して、@sc{cdr}を@var{listname}に保存し、その後で削除した要素をリターンする。"

#. type: defmac
#: original_texis/lists.texi:269
msgid "In the simplest case, @var{listname} is an unquoted symbol naming a list; in that case, this macro is equivalent to @w{@code{(prog1 (car listname) (setq listname (cdr listname)))}}."
msgstr "もっとも単純なケースは、リストに名前をつけるためのクォートされていないシンボルの場合である。この場合、このマクロは@w{@code{(prog1 (car listname) (setq listname (cdr listname)))}}と等価である。"

#. type: example
#: original_texis/lists.texi:277
#, no-wrap
msgid ""
"x\n"
"     @result{} (a b c)\n"
"(pop x)\n"
"     @result{} a\n"
"x\n"
"     @result{} (b c)\n"
msgstr ""
"x\n"
"     @result{} (a b c)\n"
"(pop x)\n"
"     @result{} a\n"
"x\n"
"     @result{} (b c)\n"

#. type: defmac
#: original_texis/lists.texi:282
msgid "More generally, @var{listname} can be a generalized variable.  In that case, this macro saves into @var{listname} using @code{setf}.  @xref{Generalized Variables}."
msgstr "より一般的なのは@var{listname}が汎変数(generalized variable)の場合である。この場合、このマクロは@code{setf}を使用して@var{listname}に保存する。@ref{Generalized Variables}を参照のこと。"

#. type: defmac
#: original_texis/lists.texi:285
msgid "For the @code{push} macro, which adds an element to a list, @xref{List Variables}."
msgstr "リストに要素を追加する@code{push}マクロについては@ref{List Variables}を参照のこと。"

#. type: defun
#: original_texis/lists.texi:287
#, no-wrap
msgid "nth n list"
msgstr "nth n list"

#. type: anchor{#1}
#: original_texis/lists.texi:293
msgid "Definition of nth"
msgstr "Definition of nth"

#. type: defun
#: original_texis/lists.texi:293
msgid "This function returns the @var{n}th element of @var{list}.  Elements are numbered starting with zero, so the @sc{car} of @var{list} is element number zero.  If the length of @var{list} is @var{n} or less, the value is @code{nil}."
msgstr "この関数は@var{list}の@var{n}番目の要素をリターンする。要素は0から数えられるので@var{list}の@sc{car}は要素0になる。@var{list}の長さが@var{n}以下なら値は@code{nil}。"

#. type: group
#: original_texis/lists.texi:303
#, no-wrap
msgid ""
"(nth 2 '(1 2 3 4))\n"
"     @result{} 3\n"
msgstr ""
"(nth 2 '(1 2 3 4))\n"
"     @result{} 3\n"

#. type: group
#: original_texis/lists.texi:307
#, no-wrap
msgid ""
"(nth 10 '(1 2 3 4))\n"
"     @result{} nil\n"
"\n"
msgstr ""
"(nth 10 '(1 2 3 4))\n"
"     @result{} nil\n"
"\n"

#. type: group
#: original_texis/lists.texi:309
#, no-wrap
msgid "(nth n x) @equiv{} (car (nthcdr n x))\n"
msgstr "(nth n x) @equiv{} (car (nthcdr n x))\n"

#. type: defun
#: original_texis/lists.texi:315
msgid "The function @code{elt} is similar, but applies to any kind of sequence.  For historical reasons, it takes its arguments in the opposite order.  @xref{Sequence Functions}."
msgstr "これは関数@code{elt}も類似しているが、任意の種類のシーケンスに適用される。歴史的な理由によりこの関数は逆の順序で引数を受け取る。@ref{Sequence Functions}を参照のこと。"

#. type: defun
#: original_texis/lists.texi:317
#, no-wrap
msgid "nthcdr n list"
msgstr "nthcdr n list"

#. type: defun
#: original_texis/lists.texi:321
msgid "This function returns the @var{n}th @sc{cdr} of @var{list}.  In other words, it skips past the first @var{n} links of @var{list} and returns what follows."
msgstr "この関数は@var{list}の@var{n}番目の@sc{cdr}をリターンする。言い換えると、この関数は@var{list}の最初の@var{n}個のリンクをスキップしてから、それ以降をリターンする。"

#. type: defun
#: original_texis/lists.texi:326
msgid "If @var{n} is zero, @code{nthcdr} returns all of @var{list}.  If the length of @var{list} is @var{n} or less, @code{nthcdr} returns @code{nil}."
msgstr "@var{n}が0なら@code{nthcdr}は@var{list}全体をリターンする。@var{list}の長さが@var{n}以下なら@code{nthcdr}は@code{nil}をリターンする。"

#. type: group
#: original_texis/lists.texi:331
#, no-wrap
msgid ""
"(nthcdr 1 '(1 2 3 4))\n"
"     @result{} (2 3 4)\n"
msgstr ""
"(nthcdr 1 '(1 2 3 4))\n"
"     @result{} (2 3 4)\n"

#. type: group
#: original_texis/lists.texi:335
#, no-wrap
msgid ""
"(nthcdr 10 '(1 2 3 4))\n"
"     @result{} nil\n"
msgstr ""
"(nthcdr 10 '(1 2 3 4))\n"
"     @result{} nil\n"

#. type: group
#: original_texis/lists.texi:339
#, no-wrap
msgid ""
"(nthcdr 0 '(1 2 3 4))\n"
"     @result{} (1 2 3 4)\n"
msgstr ""
"(nthcdr 0 '(1 2 3 4))\n"
"     @result{} (1 2 3 4)\n"

#. type: defun
#: original_texis/lists.texi:343
#, no-wrap
msgid "last list &optional n"
msgstr "last list &optional n"

#. type: defun
#: original_texis/lists.texi:349
msgid "This function returns the last link of @var{list}.  The @code{car} of this link is the list's last element.  If @var{list} is null, @code{nil} is returned.  If @var{n} is non-@code{nil}, the @var{n}th-to-last link is returned instead, or the whole of @var{list} if @var{n} is bigger than @var{list}'s length."
msgstr "この関数は@var{list}の最後のリンクをリターンする。このリンクの@code{car}はこのリストの最後の要素。@var{list}がnullなら@code{nil}がリターンされる。@var{n}が非@code{nil}なら@var{n}番目から最後までのリンクがリターンされる。@var{n}が@var{list}の長さより大きければ@var{list}全体がリターンされる。"

#. type: defun
#: original_texis/lists.texi:351
#, no-wrap
msgid "safe-length list"
msgstr "safe-length list"

#. type: anchor{#1}
#: original_texis/lists.texi:357
msgid "Definition of safe-length"
msgstr "Definition of safe-length"

#. type: defun
#: original_texis/lists.texi:357
msgid "This function returns the length of @var{list}, with no risk of either an error or an infinite loop.  It generally returns the number of distinct cons cells in the list.  However, for circular lists, the value is just an upper bound; it is often too large."
msgstr "この関数はエラーや無限ループの危険なしで、@var{list}の長さをリターンする。この関数は一般的に、リスト内のコンスセルの個数をリターンする。しかし循環リストでは単に上限値が値となるため、非常に大きくなる場合があります。"

#. type: defun
#: original_texis/lists.texi:360
msgid "If @var{list} is not @code{nil} or a cons cell, @code{safe-length} returns 0."
msgstr "@var{list}が@code{nil}]とコンスセルのいずれでもなければ@code{safe-length}は0をリターンする。"

#. type: Plain text
#: original_texis/lists.texi:365
msgid "The most common way to compute the length of a list, when you are not worried that it may be circular, is with @code{length}.  @xref{Sequence Functions}."
msgstr "循環リストを考慮しなくてもよい場合にリストの長さを計算するもっとも一般的な方法は、@code{length}を使う方法です。@ref{Sequence Functions}を参照してください。"

#. type: defun
#: original_texis/lists.texi:366
#, no-wrap
msgid "caar cons-cell"
msgstr "caar cons-cell"

#. type: defun
#: original_texis/lists.texi:368
msgid "This is the same as @code{(car (car @var{cons-cell}))}."
msgstr "これは@code{(car (car @var{cons-cell}))}と同じ。"

#. type: defun
#: original_texis/lists.texi:370
#, no-wrap
msgid "cadr cons-cell"
msgstr "cadr cons-cell"

#. type: defun
#: original_texis/lists.texi:373
msgid "This is the same as @code{(car (cdr @var{cons-cell}))} or @code{(nth 1 @var{cons-cell})}."
msgstr "これは@code{(car (cdr @var{cons-cell}))}か@code{(nth 1 @var{cons-cell})}と同じ。"

#. type: defun
#: original_texis/lists.texi:375
#, no-wrap
msgid "cdar cons-cell"
msgstr "cdar cons-cell"

#. type: defun
#: original_texis/lists.texi:377
msgid "This is the same as @code{(cdr (car @var{cons-cell}))}."
msgstr "これは@code{(cdr (car @var{cons-cell}))}と同じ。"

#. type: defun
#: original_texis/lists.texi:379
#, no-wrap
msgid "cddr cons-cell"
msgstr "cddr cons-cell"

#. type: defun
#: original_texis/lists.texi:382
msgid "This is the same as @code{(cdr (cdr @var{cons-cell}))} or @code{(nthcdr 2 @var{cons-cell})}."
msgstr "これは@code{(cdr (cdr @var{cons-cell}))}か@code{(nthcdr 2 @var{cons-cell})}と同じ。"

#. type: findex
#: original_texis/lists.texi:384
#, no-wrap
msgid "caaar"
msgstr "caaar"

#. type: findex
#: original_texis/lists.texi:385
#, no-wrap
msgid "caadr"
msgstr "caadr"

#. type: findex
#: original_texis/lists.texi:386
#, no-wrap
msgid "cadar"
msgstr "cadar"

#. type: findex
#: original_texis/lists.texi:387
#, no-wrap
msgid "caddr"
msgstr "caddr"

#. type: findex
#: original_texis/lists.texi:388
#, no-wrap
msgid "cdaar"
msgstr "cdaar"

#. type: findex
#: original_texis/lists.texi:389
#, no-wrap
msgid "cdadr"
msgstr "cdadr"

#. type: findex
#: original_texis/lists.texi:390
#, no-wrap
msgid "cddar"
msgstr "cddar"

#. type: findex
#: original_texis/lists.texi:391
#, no-wrap
msgid "cdddr"
msgstr "cdddr"

#. type: findex
#: original_texis/lists.texi:392
#, no-wrap
msgid "caaaar"
msgstr "caaaar"

#. type: findex
#: original_texis/lists.texi:393
#, no-wrap
msgid "caaadr"
msgstr "caaadr"

#. type: findex
#: original_texis/lists.texi:394
#, no-wrap
msgid "caadar"
msgstr "caadar"

#. type: findex
#: original_texis/lists.texi:395
#, no-wrap
msgid "caaddr"
msgstr "caaddr"

#. type: findex
#: original_texis/lists.texi:396
#, no-wrap
msgid "cadaar"
msgstr "cadaar"

#. type: findex
#: original_texis/lists.texi:397
#, no-wrap
msgid "cadadr"
msgstr "cadadr"

#. type: findex
#: original_texis/lists.texi:398
#, no-wrap
msgid "caddar"
msgstr "caddar"

#. type: findex
#: original_texis/lists.texi:399
#, no-wrap
msgid "cadddr"
msgstr "cadddr"

#. type: findex
#: original_texis/lists.texi:400
#, no-wrap
msgid "cdaaar"
msgstr "cdaaar"

#. type: findex
#: original_texis/lists.texi:401
#, no-wrap
msgid "cdaadr"
msgstr "cdaadr"

#. type: findex
#: original_texis/lists.texi:402
#, no-wrap
msgid "cdadar"
msgstr "cdadar"

#. type: findex
#: original_texis/lists.texi:403
#, no-wrap
msgid "cdaddr"
msgstr "cdaddr"

#. type: findex
#: original_texis/lists.texi:404
#, no-wrap
msgid "cddaar"
msgstr "cddaar"

#. type: findex
#: original_texis/lists.texi:405
#, no-wrap
msgid "cddadr"
msgstr "cddadr"

#. type: findex
#: original_texis/lists.texi:406
#, no-wrap
msgid "cdddar"
msgstr "cdddar"

#. type: findex
#: original_texis/lists.texi:407
#, no-wrap
msgid "cddddr"
msgstr "cddddr"

#. type: Plain text
#: original_texis/lists.texi:416
msgid "In addition to the above, 24 additional compositions of @code{car} and @code{cdr} are defined as @code{c@var{xxx}r} and @code{c@var{xxxx}r}, where each @code{@var{x}} is either @code{a} or @code{d}.  @code{cadr}, @code{caddr}, and @code{cadddr} pick out the second, third or fourth elements of a list, respectively.  @file{cl-lib} provides the same under the names @code{cl-second}, @code{cl-third}, and @code{cl-fourth}.  @xref{List Functions,,, cl, Common Lisp Extensions}."
msgstr "上記に加えて@code{c@var{xxx}r}や@code{c@var{xxxx}r}のような@code{car}と@code{cdr}で構成される24の関数が定義されています。ここで@code{@var{x}}は@code{a}か@code{d}のいずれかです。@code{cadr}と@code{caddr}と@code{cadddr}はそれぞれリストの2つ目、3つ目、4つ目の要素です。@file{cl-lib}は同じものを@code{cl-second}、@code{cl-third}、@code{cl-fourth}という名前で提供しています。@ref{List Functions,,, cl, Common Lisp Extensions}を参照してください。"

#. type: defun
#: original_texis/lists.texi:417
#, no-wrap
msgid "butlast x &optional n"
msgstr "butlast x &optional n"

#. type: defun
#: original_texis/lists.texi:423
msgid "This function returns the list @var{x} with the last element, or the last @var{n} elements, removed.  If @var{n} is greater than zero it makes a copy of the list so as not to damage the original list.  In general, @code{(append (butlast @var{x} @var{n})  (last @var{x} @var{n}))} will return a list equal to @var{x}."
msgstr "この関数はリスト@var{x}から、最後の要素か最後の@var{n}個の要素を削除してリターンする。@var{n}が0より大きければこの関数はリストのコピーを作成するので、元のリストに影響はない。一般的に@code{(append (butlast @var{x} @var{n})  (last @var{x} @var{n}))}は、@var{x}と等しいリストをリターンする。"

#. type: defun
#: original_texis/lists.texi:425
#, no-wrap
msgid "nbutlast x &optional n"
msgstr "nbutlast x &optional n"

#. type: defun
#: original_texis/lists.texi:429
msgid "This is a version of @code{butlast} that works by destructively modifying the @code{cdr} of the appropriate element, rather than making a copy of the list."
msgstr "この関数はリストのコピーを作成するのではなく、@code{cdr}を適切な要素に変更することにより破壊的に機能するバージョンの@code{butlast}である。"

#. type: section
#: original_texis/lists.texi:432
#, no-wrap
msgid "Building Cons Cells and Lists"
msgstr "Building Cons Cells and Lists"

#. type: cindex
#: original_texis/lists.texi:433
#, no-wrap
msgid "cons cells"
msgstr "cons cells"

#. type: cindex
#: original_texis/lists.texi:434
#, no-wrap
msgid "building lists"
msgstr "building lists"

#. type: Plain text
#: original_texis/lists.texi:440
msgid "Many functions build lists, as lists reside at the very heart of Lisp.  @code{cons} is the fundamental list-building function; however, it is interesting to note that @code{list} is used more times in the source code for Emacs than @code{cons}."
msgstr "リストはLispの中核にあたる機能なので、リストを構築するために多くの関数があります。@code{cons}はリストを構築する基本的な関数です。しかしEmacsのソースコードでは、@code{cons}より@code{list}のほうが多く使用されているのは興味深いことです。"

#. type: defun
#: original_texis/lists.texi:441
#, no-wrap
msgid "cons object1 object2"
msgstr "cons object1 object2"

#. type: defun
#: original_texis/lists.texi:447
msgid "This function is the most basic function for building new list structure.  It creates a new cons cell, making @var{object1} the @sc{car}, and @var{object2} the @sc{cdr}.  It then returns the new cons cell.  The arguments @var{object1} and @var{object2} may be any Lisp objects, but most often @var{object2} is a list."
msgstr "この関数は新しいリスト構造を構築するための、もっとも基本的な関数である。この関数は@var{object1}を@sc{car}、@var{object2}を@sc{cdr}とする新しいコンスセルを作成して、それから新しいコンスセルをリターンする。引数@var{object1}と@var{object2}には任意のLispオブジェクトを指定できるが、ほとんどの場合@var{object2}はリストである。"

#. type: group
#: original_texis/lists.texi:452
#, no-wrap
msgid ""
"(cons 1 '(2))\n"
"     @result{} (1 2)\n"
msgstr ""
"(cons 1 '(2))\n"
"     @result{} (1 2)\n"

#. type: group
#: original_texis/lists.texi:456
#, no-wrap
msgid ""
"(cons 1 '())\n"
"     @result{} (1)\n"
msgstr ""
"(cons 1 '())\n"
"     @result{} (1)\n"

#. type: group
#: original_texis/lists.texi:460
#, no-wrap
msgid ""
"(cons 1 2)\n"
"     @result{} (1 . 2)\n"
msgstr ""
"(cons 1 2)\n"
"     @result{} (1 . 2)\n"

#. type: cindex
#: original_texis/lists.texi:463
#, no-wrap
msgid "consing"
msgstr "consing"

#. type: defun
#: original_texis/lists.texi:475
msgid "@code{cons} is often used to add a single element to the front of a list.  This is called @dfn{consing the element onto the list}.  @footnote{There is no strictly equivalent way to add an element to the end of a list.  You can use @code{(append @var{listname} (list @var{newelt}))}, which creates a whole new list by copying @var{listname} and adding @var{newelt} to its end.  Or you can use @code{(nconc @var{listname} (list @var{newelt}))}, which modifies @var{listname} by following all the @sc{cdr}s and then replacing the terminating @code{nil}.  Compare this to adding an element to the beginning of a list with @code{cons}, which neither copies nor modifies the list.} For example:"
msgstr "リストの先頭に1つの要素を追加するために、@code{cons}がよく使用される。これを@dfn{リストに要素をコンスする}と言います。@footnote{リストの最後に要素を追加するための、これと完全に同等な方法はありません。@var{listname}をコピーすることにより新しいリストを作成してから、@var{newelt}をそのリストの最後に追加する@code{(append @var{listname} (list @var{newelt}))}を使用することができます。すべての@sc{cdr}を辿って終端の@code{nil}を置き換える、@code{(nconc @var{listname} (list @var{newelt}))}を使用することもできます。コピーも変更も行なわずにリストの先頭に要素を追加する@code{cons}と比較してみてください。}たとえば:"

#. type: example
#: original_texis/lists.texi:478
#, no-wrap
msgid "(setq list (cons newelt list))\n"
msgstr "(setq list (cons newelt list))\n"

#. type: defun
#: original_texis/lists.texi:483
msgid "Note that there is no conflict between the variable named @code{list} used in this example and the function named @code{list} described below; any symbol can serve both purposes."
msgstr "この例で使用されている@code{list}という名前の変数と、以下で説明する@code{list}という名前の関数は競合しないことに注意されたい。すべてのシンボルが、変数ト関数の両方の役割を果たすことができる。"

#. type: defun
#: original_texis/lists.texi:485
#, no-wrap
msgid "list &rest objects"
msgstr "list &rest objects"

#. type: defun
#: original_texis/lists.texi:489
msgid "This function creates a list with @var{objects} as its elements.  The resulting list is always @code{nil}-terminated.  If no @var{objects} are given, the empty list is returned."
msgstr "この関数は@var{objects}を要素とするリストを作成する。結果となるリストは常に@code{nil}終端される。@var{objects}を指定しないと空リストがリターンされる。"

#. type: group
#: original_texis/lists.texi:494
#, no-wrap
msgid ""
"(list 1 2 3 4 5)\n"
"     @result{} (1 2 3 4 5)\n"
msgstr ""
"(list 1 2 3 4 5)\n"
"     @result{} (1 2 3 4 5)\n"

#. type: group
#: original_texis/lists.texi:498
#, no-wrap
msgid ""
"(list 1 2 '(3 4 5) 'foo)\n"
"     @result{} (1 2 (3 4 5) foo)\n"
msgstr ""
"(list 1 2 '(3 4 5) 'foo)\n"
"     @result{} (1 2 (3 4 5) foo)\n"

#. type: group
#: original_texis/lists.texi:502
#, no-wrap
msgid ""
"(list)\n"
"     @result{} nil\n"
msgstr ""
"(list)\n"
"     @result{} nil\n"

#. type: defun
#: original_texis/lists.texi:506
#, no-wrap
msgid "make-list length object"
msgstr "make-list length object"

#. type: defun
#: original_texis/lists.texi:510
msgid "This function creates a list of @var{length} elements, in which each element is @var{object}.  Compare @code{make-list} with @code{make-string} (@pxref{Creating Strings})."
msgstr "この関数は各要素が@var{object}であるような、@var{length}個の要素からなるリストを作成する。@code{make-list}と@code{make-string}(@ref{Creating Strings}を参照)を比較してみよ。"

#. type: group
#: original_texis/lists.texi:515
#, no-wrap
msgid ""
"(make-list 3 'pigs)\n"
"     @result{} (pigs pigs pigs)\n"
msgstr ""
"(make-list 3 'pigs)\n"
"     @result{} (pigs pigs pigs)\n"

#. type: group
#: original_texis/lists.texi:519
#, no-wrap
msgid ""
"(make-list 0 'pigs)\n"
"     @result{} nil\n"
msgstr ""
"(make-list 0 'pigs)\n"
"     @result{} nil\n"

#. type: group
#: original_texis/lists.texi:525
#, no-wrap
msgid ""
"(setq l (make-list 3 '(a b)))\n"
"     @result{} ((a b) (a b) (a b))\n"
"(eq (car l) (cadr l))\n"
"     @result{} t\n"
msgstr ""
"(setq l (make-list 3 '(a b)))\n"
"     @result{} ((a b) (a b) (a b))\n"
"(eq (car l) (cadr l))\n"
"     @result{} t\n"

#. type: defun
#: original_texis/lists.texi:529
#, no-wrap
msgid "append &rest sequences"
msgstr "append &rest sequences"

#. type: cindex
#: original_texis/lists.texi:530
#, no-wrap
msgid "copying lists"
msgstr "copying lists"

#. type: defun
#: original_texis/lists.texi:537
msgid "This function returns a list containing all the elements of @var{sequences}.  The @var{sequences} may be lists, vectors, bool-vectors, or strings, but the last one should usually be a list.  All arguments except the last one are copied, so none of the arguments is altered.  (See @code{nconc} in @ref{Rearrangement}, for a way to join lists with no copying.)"
msgstr "この関数は@var{sequences}のすべての要素を含むリストをreturnします。@var{sequences}にはリスト、ベクター、ブールベクター、文字列も指定できるが、通常は最後にリストを指定すること。最後の引数を除くすべての引数はコピーされるので、変更される引数はない(コピーを行なわずにリストを結合する方法については@ref{Rearrangement}の@code{nconc}を参照のこと)。"

#. type: defun
#: original_texis/lists.texi:545
msgid "More generally, the final argument to @code{append} may be any Lisp object.  The final argument is not copied or converted; it becomes the @sc{cdr} of the last cons cell in the new list.  If the final argument is itself a list, then its elements become in effect elements of the result list.  If the final element is not a list, the result is a dotted list since its final @sc{cdr} is not @code{nil} as required in a proper list (@pxref{Cons Cells})."
msgstr "より一般的には@code{append}にたいする最後の引数は任意のLispオブジェクトを指定できる。最後の引数のコピーや変換は行わない。最後の引数は新しいリストの最後のコンスセルの@sc{cdr}となる。最後の引数もリストならば、このリストの要素は実質的には結果リストの要素になる。最後の要素がリストでなければ、最後の@sc{cdr}が(正リストで要求される)@code{nil}ではないので結果はドットリストになる(@ref{Cons Cells}を参照)。"

#. type: Plain text
#: original_texis/lists.texi:548
msgid "Here is an example of using @code{append}:"
msgstr "以下は@code{append}を使用した例です:"

#. type: group
#: original_texis/lists.texi:555
#, no-wrap
msgid ""
"(setq trees '(pine oak))\n"
"     @result{} (pine oak)\n"
"(setq more-trees (append '(maple birch) trees))\n"
"     @result{} (maple birch pine oak)\n"
msgstr ""
"(setq trees '(pine oak))\n"
"     @result{} (pine oak)\n"
"(setq more-trees (append '(maple birch) trees))\n"
"     @result{} (maple birch pine oak)\n"

#. type: group
#: original_texis/lists.texi:562
#, no-wrap
msgid ""
"trees\n"
"     @result{} (pine oak)\n"
"more-trees\n"
"     @result{} (maple birch pine oak)\n"
msgstr ""
"trees\n"
"     @result{} (pine oak)\n"
"more-trees\n"
"     @result{} (maple birch pine oak)\n"

#. type: group
#: original_texis/lists.texi:566
#, no-wrap
msgid ""
"(eq trees (cdr (cdr more-trees)))\n"
"     @result{} t\n"
msgstr ""
"(eq trees (cdr (cdr more-trees)))\n"
"     @result{} t\n"

#. type: Plain text
#: original_texis/lists.texi:574
msgid "You can see how @code{append} works by looking at a box diagram.  The variable @code{trees} is set to the list @code{(pine oak)} and then the variable @code{more-trees} is set to the list @code{(maple birch pine oak)}.  However, the variable @code{trees} continues to refer to the original list:"
msgstr "@code{append}がどのように機能するか、ボックスダイアグラムで確認できます。変数@code{trees}はリスト@code{(pine oak)}にセットされ、それから変数@code{more-trees}にリスト@code{(maple birch pine oak)}がセットされます。しかし変数@code{trees}は継続して元のリストを参照します:"

#. type: group
#: original_texis/lists.texi:585
#, no-wrap
msgid ""
"more-trees                trees\n"
"|                           |\n"
"|     --- ---      --- ---   -> --- ---      --- ---\n"
" --> |   |   |--> |   |   |--> |   |   |--> |   |   |--> nil\n"
"      --- ---      --- ---      --- ---      --- ---\n"
"       |            |            |            |\n"
"       |            |            |            |\n"
"        --> maple    -->birch     --> pine     --> oak\n"
msgstr ""
"more-trees                trees\n"
"|                           |\n"
"|     --- ---      --- ---   -> --- ---      --- ---\n"
" --> |   |   |--> |   |   |--> |   |   |--> |   |   |--> nil\n"
"      --- ---      --- ---      --- ---      --- ---\n"
"       |            |            |            |\n"
"       |            |            |            |\n"
"        --> maple    -->birch     --> pine     --> oak\n"

#. type: Plain text
#: original_texis/lists.texi:591
msgid "An empty sequence contributes nothing to the value returned by @code{append}.  As a consequence of this, a final @code{nil} argument forces a copy of the previous argument:"
msgstr "空のシーケンスは@code{append}によりリターンされる値に寄与しません。この結果、最後の引数に@code{nil}を指定すると、それより前の引数のコピーを強制することになります。"

#. type: group
#: original_texis/lists.texi:596
#, no-wrap
msgid ""
"trees\n"
"     @result{} (pine oak)\n"
msgstr ""
"trees\n"
"     @result{} (pine oak)\n"

#. type: group
#: original_texis/lists.texi:600
#, no-wrap
msgid ""
"(setq wood (append trees nil))\n"
"     @result{} (pine oak)\n"
msgstr ""
"(setq wood (append trees nil))\n"
"     @result{} (pine oak)\n"

#. type: group
#: original_texis/lists.texi:604
#, no-wrap
msgid ""
"wood\n"
"     @result{} (pine oak)\n"
msgstr ""
"wood\n"
"     @result{} (pine oak)\n"

#. type: group
#: original_texis/lists.texi:608
#, no-wrap
msgid ""
"(eq wood trees)\n"
"     @result{} nil\n"
msgstr ""
"(eq wood trees)\n"
"     @result{} nil\n"

#. type: Plain text
#: original_texis/lists.texi:614
msgid "This once was the usual way to copy a list, before the function @code{copy-sequence} was invented.  @xref{Sequences Arrays Vectors}."
msgstr "関数@code{copy-sequence}が導入される以前は,これがリストをコピーする通常の方法でした。@ref{Sequences Arrays Vectors}を参照してください。"

#. type: Plain text
#: original_texis/lists.texi:616
msgid "Here we show the use of vectors and strings as arguments to @code{append}:"
msgstr "以下は@code{append}の引数としてベクターと文字列を使用する例です:"

#. type: group
#: original_texis/lists.texi:621
#, no-wrap
msgid ""
"(append [a b] \"cd\" nil)\n"
"     @result{} (a b 99 100)\n"
msgstr ""
"(append [a b] \"cd\" nil)\n"
"     @result{} (a b 99 100)\n"

#. type: Plain text
#: original_texis/lists.texi:626
msgid "With the help of @code{apply} (@pxref{Calling Functions}), we can append all the lists in a list of lists:"
msgstr "@code{apply} (@ref{Calling Functions}を参照)の助けを借りることにより、リストのリストの中のすべてのリストをappendできます。"

#. type: group
#: original_texis/lists.texi:631
#, no-wrap
msgid ""
"(apply 'append '((a b c) nil (x y z) nil))\n"
"     @result{} (a b c x y z)\n"
msgstr ""
"(apply 'append '((a b c) nil (x y z) nil))\n"
"     @result{} (a b c x y z)\n"

#. type: Plain text
#: original_texis/lists.texi:635
msgid "If no @var{sequences} are given, @code{nil} is returned:"
msgstr "@var{sequences}が与えられなければ@code{nil}がリターンされます:"

#. type: group
#: original_texis/lists.texi:640
#, no-wrap
msgid ""
"(append)\n"
"     @result{} nil\n"
msgstr ""
"(append)\n"
"     @result{} nil\n"

#. type: Plain text
#: original_texis/lists.texi:644
msgid "Here are some examples where the final argument is not a list:"
msgstr "以下は最後の引数がリストでない場合の例です:"

#. type: example
#: original_texis/lists.texi:650
#, no-wrap
msgid ""
"(append '(x y) 'z)\n"
"     @result{} (x y . z)\n"
"(append '(x y) [z])\n"
"     @result{} (x y . [z])\n"
msgstr ""
"(append '(x y) 'z)\n"
"     @result{} (x y . z)\n"
"(append '(x y) [z])\n"
"     @result{} (x y . [z])\n"

#. type: Plain text
#: original_texis/lists.texi:657
msgid "The second example shows that when the final argument is a sequence but not a list, the sequence's elements do not become elements of the resulting list.  Instead, the sequence becomes the final @sc{cdr}, like any other non-list final argument."
msgstr "2番目の例は最後の引数はリストではないシーケンスの場合で、このシーケンスの要素は、結果リストの要素にはなりません。かわりに最後の引数がリストでないときと同様、シーケンスが最後の@sc{cdr}になります。"

#. type: defun
#: original_texis/lists.texi:658
#, no-wrap
msgid "copy-tree tree &optional vecp"
msgstr "copy-tree tree &optional vecp"

#. type: defun
#: original_texis/lists.texi:663
msgid "This function returns a copy of the tree @var{tree}.  If @var{tree} is a cons cell, this makes a new cons cell with the same @sc{car} and @sc{cdr}, then recursively copies the @sc{car} and @sc{cdr} in the same way."
msgstr "この関数はツリー@var{tree}のコピーをリターンする。@var{tree}がコンスセルなら同じ@sc{car}と@sc{cdr}をもつ新しいコンスセルを作成してから、同じ方法によって@sc{car}と@sc{cdr}を再帰的にコピーする。"

#. type: defun
#: original_texis/lists.texi:668
msgid "Normally, when @var{tree} is anything other than a cons cell, @code{copy-tree} simply returns @var{tree}.  However, if @var{vecp} is non-@code{nil}, it copies vectors too (and operates recursively on their elements)."
msgstr "@var{tree}がコンスセル以外の場合、通常は@code{copy-tree}は単に@var{tree}をリターンする。しかし@var{vecp}が非@code{nil}なら、この関数はベクターでもコピーします(そしてベクターの要素を再帰的に処理する)。"

#. type: defun
#: original_texis/lists.texi:670
#, no-wrap
msgid "flatten-tree tree"
msgstr ""

#. type: defun
#: original_texis/lists.texi:675
msgid "This function returns a ``flattened'' copy of @var{tree}, that is, a list containing all the non-@code{nil} terminal nodes, or leaves, of the tree of cons cells rooted at @var{tree}.  Leaves in the returned list are in the same order as in @var{tree}."
msgstr ""

#. type: example
#: original_texis/lists.texi:680
#, fuzzy, no-wrap
#| msgid ""
#| "(list 1 2 3 4 5)\n"
#| "     @result{} (1 2 3 4 5)\n"
msgid ""
"(flatten-tree '(1 (2 . 3) nil (4 5 (6)) 7))\n"
"    @result{}(1 2 3 4 5 6 7)\n"
msgstr ""
"(list 1 2 3 4 5)\n"
"     @result{} (1 2 3 4 5)\n"

#. type: defun
#: original_texis/lists.texi:682
#, no-wrap
msgid "number-sequence from &optional to separation"
msgstr "number-sequence from &optional to separation"

#. type: defun
#: original_texis/lists.texi:691
#, fuzzy
#| msgid "This returns a list of numbers starting with @var{from} and incrementing by @var{separation}, and ending at or just before @var{to}.  @var{separation} can be positive or negative and defaults to 1.  If @var{to} is @code{nil} or numerically equal to @var{from}, the value is the one-element list @code{(@var{from})}.  If @var{to} is less than @var{from} with a positive @var{separation}, or greater than @var{from} with a negative @var{separation}, the value is @code{nil} because those arguments specify an empty sequence."
msgid "This function returns a list of numbers starting with @var{from} and incrementing by @var{separation}, and ending at or just before @var{to}.  @var{separation} can be positive or negative and defaults to 1.  If @var{to} is @code{nil} or numerically equal to @var{from}, the value is the one-element list @code{(@var{from})}.  If @var{to} is less than @var{from} with a positive @var{separation}, or greater than @var{from} with a negative @var{separation}, the value is @code{nil} because those arguments specify an empty sequence."
msgstr "これは@var{from}から@var{separation}づつインクリメントして、@var{to}の直前で終わる、数字のリストをリターンする。@var{separation}には正か負の数を指定でき、デフォルトは1。@var{to}が@code{nil}、または数値的に@var{from}と等しければ、値は1要素のリスト@code{(@var{from})}になる。@var{separation}が正で@var{to}が@var{from}より小さい、または@var{separation}が負で@var{to}が@var{from}より大きければ、これらの引数は空のシーケンスを指示することになるので、値は@code{nil}になります。"

#. type: defun
#: original_texis/lists.texi:695
msgid "If @var{separation} is 0 and @var{to} is neither @code{nil} nor numerically equal to @var{from}, @code{number-sequence} signals an error, since those arguments specify an infinite sequence."
msgstr "@var{separation}が0で、@var{to}が@code{nil}でもなく、数値的に@var{from}とも等しくまければ、これらの引数は無限シーケンスを指示することになるので、エラーがシグナルされる。"

#. type: defun
#: original_texis/lists.texi:708
msgid "All arguments are numbers.  Floating-point arguments can be tricky, because floating-point arithmetic is inexact.  For instance, depending on the machine, it may quite well happen that @code{(number-sequence 0.4 0.6 0.2)} returns the one element list @code{(0.4)}, whereas @code{(number-sequence 0.4 0.8 0.2)} returns a list with three elements.  The @var{n}th element of the list is computed by the exact formula @code{(+ @var{from} (* @var{n} @var{separation}))}.  Thus, if one wants to make sure that @var{to} is included in the list, one can pass an expression of this exact type for @var{to}.  Alternatively, one can replace @var{to} with a slightly larger value (or a slightly more negative value if @var{separation} is negative)."
msgstr "引数はすべて数字である。浮動少数点数の計算は正確ではないので、浮動少数点数の引数には注意する必要がある。たとえばマシンへの依存により、@code{(number-sequence 0.4 0.8 0.2)}が3要素のリストをリターンして、@code{(number-sequence 0.4 0.6 0.2)}が1要素のリスト@code{(0.4)}をリターンnすることがよく起こる。リストの@var{n}番目の要素は、厳密に@code{(+ @var{from} (* @var{n} @var{separation}))}という式により計算される。リストに確実に@var{to}が含まれるようにするために、この式に適切な型の@var{to}を渡すことができる。別の方法として@var{to}を少しだけ大きな値(@var{separation}が負なら少しだけ小さな値)に置き換えることもできる。"

#. type: defun
#: original_texis/lists.texi:710
msgid "Some examples:"
msgstr "例をいくつか示す:"

#. type: example
#: original_texis/lists.texi:726
#, no-wrap
msgid ""
"(number-sequence 4 9)\n"
"     @result{} (4 5 6 7 8 9)\n"
"(number-sequence 9 4 -1)\n"
"     @result{} (9 8 7 6 5 4)\n"
"(number-sequence 9 4 -2)\n"
"     @result{} (9 7 5)\n"
"(number-sequence 8)\n"
"     @result{} (8)\n"
"(number-sequence 8 5)\n"
"     @result{} nil\n"
"(number-sequence 5 8 -1)\n"
"     @result{} nil\n"
"(number-sequence 1.5 6 2)\n"
"     @result{} (1.5 3.5 5.5)\n"
msgstr ""
"(number-sequence 4 9)\n"
"     @result{} (4 5 6 7 8 9)\n"
"(number-sequence 9 4 -1)\n"
"     @result{} (9 8 7 6 5 4)\n"
"(number-sequence 9 4 -2)\n"
"     @result{} (9 7 5)\n"
"(number-sequence 8)\n"
"     @result{} (8)\n"
"(number-sequence 8 5)\n"
"     @result{} nil\n"
"(number-sequence 5 8 -1)\n"
"     @result{} nil\n"
"(number-sequence 1.5 6 2)\n"
"     @result{} (1.5 3.5 5.5)\n"

#. type: section
#: original_texis/lists.texi:730
#, no-wrap
msgid "Modifying List Variables"
msgstr "Modifying List Variables"

#. type: cindex
#: original_texis/lists.texi:731
#, no-wrap
msgid "modify a list"
msgstr "modify a list"

#. type: cindex
#: original_texis/lists.texi:732
#, no-wrap
msgid "list modification"
msgstr "list modification"

#. type: Plain text
#: original_texis/lists.texi:736
msgid "These functions, and one macro, provide convenient ways to modify a list which is stored in a variable."
msgstr "以下の関数と1つのマクロは、変数に格納されたリストを変更する便利な方法を提供します。"

#. type: defmac
#: original_texis/lists.texi:737
#, no-wrap
msgid "push element listname"
msgstr "push element listname"

#. type: defmac
#: original_texis/lists.texi:743
msgid "This macro creates a new list whose @sc{car} is @var{element} and whose @sc{cdr} is the list specified by @var{listname}, and saves that list in @var{listname}.  In the simplest case, @var{listname} is an unquoted symbol naming a list, and this macro is equivalent to @w{@code{(setq @var{listname} (cons @var{element} @var{listname}))}}."
msgstr "このマクロは@sc{car}が@var{element}で、@sc{cdr}が@var{listname}のリストであるような新しいリストを作成して、そのリストを@var{listname}に保存する。@var{listname}がリストに名前をつけるクォートされていないシンボルのときは単純で、この場合マクロは@w{@code{(setq @var{listname} (cons @var{element} @var{listname}))}}と等価になる。"

#. type: example
#: original_texis/lists.texi:751
#, no-wrap
msgid ""
"(setq l '(a b))\n"
"     @result{} (a b)\n"
"(push 'c l)\n"
"     @result{} (c a b)\n"
"l\n"
"     @result{} (c a b)\n"
msgstr ""
"(setq l '(a b))\n"
"     @result{} (a b)\n"
"(push 'c l)\n"
"     @result{} (c a b)\n"
"l\n"
"     @result{} (c a b)\n"

#. type: defmac
#: original_texis/lists.texi:757
msgid "More generally, @code{listname} can be a generalized variable.  In that case, this macro does the equivalent of @w{@code{(setf @var{listname} (cons @var{element} @var{listname}))}}.  @xref{Generalized Variables}."
msgstr "より一般的なのは@code{listname}が汎変数の場合である。この場合、このマクロは@w{@code{(setf @var{listname} (cons @var{element} @var{listname}))}}と等価になる。@ref{Generalized Variables}を参照のこと。"

#. type: defmac
#: original_texis/lists.texi:760
msgid "For the @code{pop} macro, which removes the first element from a list, @xref{List Elements}."
msgstr "リストから1番目の要素を取り出す@code{pop}マクロについては、@ref{List Elements}を参照されたい。"

#. type: Plain text
#: original_texis/lists.texi:763
msgid "Two functions modify lists that are the values of variables."
msgstr "以下の2つの関数は、変数の値であるリストを変更します。"

#. type: defun
#: original_texis/lists.texi:764
#, no-wrap
msgid "add-to-list symbol element &optional append compare-fn"
msgstr "add-to-list symbol element &optional append compare-fn"

#. type: defun
#: original_texis/lists.texi:772
msgid "This function sets the variable @var{symbol} by consing @var{element} onto the old value, if @var{element} is not already a member of that value.  It returns the resulting list, whether updated or not.  The value of @var{symbol} had better be a list already before the call.  @code{add-to-list} uses @var{compare-fn} to compare @var{element} against existing list members; if @var{compare-fn} is @code{nil}, it uses @code{equal}."
msgstr "この関数は@var{element}が@var{symbol}の値のメンバーでなければ、@var{symbol}に@var{element}をコンスすることにより、変数@var{symbol}をセットする。この関数はリストが更新されているか否かに関わらず、結果のリストをリターンする。@var{symbol}の値は呼び出し前にすでにリストであることが望ましい。@var{element}がリストの既存メンバーか比較するために、@code{add-to-list}は@var{compare-fn}を使用する。@var{compare-fn}が@code{nil}なら@code{equal}を使用する。"

#. type: defun
#: original_texis/lists.texi:776
msgid "Normally, if @var{element} is added, it is added to the front of @var{symbol}, but if the optional argument @var{append} is non-@code{nil}, it is added at the end."
msgstr "@var{element}が追加される場合は、通常は@var{symbol}の前に追加されるが、オプションの引数@var{append}が非@code{nil}なら最後に追加される。"

#. type: defun
#: original_texis/lists.texi:780
msgid "The argument @var{symbol} is not implicitly quoted; @code{add-to-list} is an ordinary function, like @code{set} and unlike @code{setq}.  Quote the argument yourself if that is what you want."
msgstr "引数@var{symbol}は暗黙にクォートされない。@code{setq}とは異なり@code{add-to-list}は@code{set}のような通常の関数である。クォートしたい場合には自分で引数をクォートすること。"

#. type: defun
#: original_texis/lists.texi:783
msgid "Do not use this function when @var{symbol} refers to a lexical variable."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:786
msgid "Here's a scenario showing how to use @code{add-to-list}:"
msgstr "以下に@code{add-to-list}を使用する方法をシナリオで示します:"

#. type: example
#: original_texis/lists.texi:790
#, no-wrap
msgid ""
"(setq foo '(a b))\n"
"     @result{} (a b)\n"
"\n"
msgstr ""
"(setq foo '(a b))\n"
"     @result{} (a b)\n"
"\n"

#. type: example
#: original_texis/lists.texi:793
#, no-wrap
msgid ""
"(add-to-list 'foo 'c)     ;; @r{Add @code{c}.}\n"
"     @result{} (c a b)\n"
"\n"
msgstr ""
"(add-to-list 'foo 'c)     ;; @r{@code{c}を追加}\n"
"     @result{} (c a b)\n"
"\n"

#. type: example
#: original_texis/lists.texi:796
#, no-wrap
msgid ""
"(add-to-list 'foo 'b)     ;; @r{No effect.}\n"
"     @result{} (c a b)\n"
"\n"
msgstr ""
"(add-to-list 'foo 'b)     ;; @r{効果なし}\n"
"     @result{} (c a b)\n"
"\n"

#. type: example
#: original_texis/lists.texi:799
#, no-wrap
msgid ""
"foo                       ;; @r{@code{foo} was changed.}\n"
"     @result{} (c a b)\n"
msgstr ""
"foo                       ;; @r{@code{foo}が変更された}\n"
"     @result{} (c a b)\n"

#. type: Plain text
#: original_texis/lists.texi:803
msgid "An equivalent expression for @code{(add-to-list '@var{var} @var{value})} is this:"
msgstr "以下は@code{(add-to-list '@var{var} @var{value})}と等価な式です:"

#. type: example
#: original_texis/lists.texi:808
#, fuzzy, no-wrap
#| msgid ""
#| "(or (member @var{value} @var{var})\n"
#| "    (setq @var{var} (cons @var{value} @var{var})))\n"
msgid ""
"(if (member @var{value} @var{var})\n"
"    @var{var}\n"
"  (setq @var{var} (cons @var{value} @var{var})))\n"
msgstr ""
"(or (member @var{value} @var{var})\n"
"    (setq @var{var} (cons @var{value} @var{var})))\n"

#. type: defun
#: original_texis/lists.texi:810
#, no-wrap
msgid "add-to-ordered-list symbol element &optional order"
msgstr "add-to-ordered-list symbol element &optional order"

#. type: defun
#: original_texis/lists.texi:817
msgid "This function sets the variable @var{symbol} by inserting @var{element} into the old value, which must be a list, at the position specified by @var{order}.  If @var{element} is already a member of the list, its position in the list is adjusted according to @var{order}.  Membership is tested using @code{eq}.  This function returns the resulting list, whether updated or not."
msgstr "この関数は古い値の@var{order} (リストであること)で指定された位置に、@var{element}を挿入して変数@var{symbol}をセットする。@var{element}がすでにこのリストのメンバなら、リスト内の要素の位置は@var{order}にしたがって調整される。メンバーか否かは@code{eq}を使用してテストされる。この関数は更新されているかどうかに関わらず、結果のリストをリターンする。"

#. type: defun
#: original_texis/lists.texi:820
msgid "The @var{order} is typically a number (integer or float), and the elements of the list are sorted in non-decreasing numerical order."
msgstr "@var{order}は通常は数字(整数か浮動小数点数)で、リストの要素はその数字の昇順で並べられる。"

#. type: defun
#: original_texis/lists.texi:825
msgid "@var{order} may also be omitted or @code{nil}.  Then the numeric order of @var{element} stays unchanged if it already has one; otherwise, @var{element} has no numeric order.  Elements without a numeric list order are placed at the end of the list, in no particular order."
msgstr "@var{order}は省略または@code{nil}を指定できる。これによりリストに@var{element}がすでに存在するなら、@var{element}の数字順序は変更されない。それ以外なら@var{element}は数字順序をもたない。リストの数字順序をもたない要素はリストの最後に配置され、特別な順序はつかない。"

#. type: defun
#: original_texis/lists.texi:828
msgid "Any other value for @var{order} removes the numeric order of @var{element} if it already has one; otherwise, it is equivalent to @code{nil}."
msgstr "@var{order}に他の値を指定すると、@var{element}がすでに数字順序をもつときは数字順序が削除される。それ以外はなら@code{nil}と同じ。"

#. type: defun
#: original_texis/lists.texi:832
msgid "The argument @var{symbol} is not implicitly quoted; @code{add-to-ordered-list} is an ordinary function, like @code{set} and unlike @code{setq}.  Quote the argument yourself if necessary."
msgstr "引数@var{symbol}は暗黙にクォートされない。@code{add-to-ordered-list}は@code{setq}などとは異なり、@code{set}のような通常の関数である。必要なら引数を自分でクォートすること。"

#. type: defun
#: original_texis/lists.texi:836
#, fuzzy
#| msgid "The ordering information is stored in a hash table on @var{symbol}'s @code{list-order} property."
msgid "The ordering information is stored in a hash table on @var{symbol}'s @code{list-order} property.  @var{symbol} cannot refer to a lexical variable."
msgstr "順序の情報は@var{symbol}の@code{list-order}プロパティーにハッシュテーブルで保存される。"

#. type: Plain text
#: original_texis/lists.texi:839
msgid "Here's a scenario showing how to use @code{add-to-ordered-list}:"
msgstr "以下に@code{add-to-ordered-list}を使用する方法をシナリオで示します:"

#. type: example
#: original_texis/lists.texi:843
#, no-wrap
msgid ""
"(setq foo '())\n"
"     @result{} nil\n"
"\n"
msgstr ""
"(setq foo '())\n"
"     @result{} nil\n"
"\n"

#. type: example
#: original_texis/lists.texi:846
#, no-wrap
msgid ""
"(add-to-ordered-list 'foo 'a 1)     ;; @r{Add @code{a}.}\n"
"     @result{} (a)\n"
"\n"
msgstr ""
"(add-to-ordered-list 'foo 'a 1)     ;; @r{@code{a}を追加}\n"
"     @result{} (a)\n"
"\n"

#. type: example
#: original_texis/lists.texi:849
#, no-wrap
msgid ""
"(add-to-ordered-list 'foo 'c 3)     ;; @r{Add @code{c}.}\n"
"     @result{} (a c)\n"
"\n"
msgstr ""
"(add-to-ordered-list 'foo 'c 3)     ;; @r{@code{c}を追加}\n"
"     @result{} (a c)\n"
"\n"

#. type: example
#: original_texis/lists.texi:852
#, no-wrap
msgid ""
"(add-to-ordered-list 'foo 'b 2)     ;; @r{Add @code{b}.}\n"
"     @result{} (a b c)\n"
"\n"
msgstr ""
"(add-to-ordered-list 'foo 'b 2)     ;; @r{@code{b}を追加}\n"
"     @result{} (a b c)\n"
"\n"

#. type: example
#: original_texis/lists.texi:855
#, no-wrap
msgid ""
"(add-to-ordered-list 'foo 'b 4)     ;; @r{Move @code{b}.}\n"
"     @result{} (a c b)\n"
"\n"
msgstr ""
"(add-to-ordered-list 'foo 'b 4)     ;; @r{@code{b}を移動}\n"
"     @result{} (a c b)\n"
"\n"

#. type: example
#: original_texis/lists.texi:858
#, no-wrap
msgid ""
"(add-to-ordered-list 'foo 'd)       ;; @r{Append @code{d}.}\n"
"     @result{} (a c b d)\n"
"\n"
msgstr ""
"(add-to-ordered-list 'foo 'd)       ;; @r{@code{d}を後に追加}\n"
"     @result{} (a c b d)\n"
"\n"

#. type: example
#: original_texis/lists.texi:861
#, no-wrap
msgid ""
"(add-to-ordered-list 'foo 'e)       ;; @r{Add @code{e}}.\n"
"     @result{} (a c b e d)\n"
"\n"
msgstr ""
"(add-to-ordered-list 'foo 'e)       ;; @r{@code{e}を追加}\n"
"     @result{} (a c b e d)\n"
"\n"

#. type: example
#: original_texis/lists.texi:864
#, no-wrap
msgid ""
"foo                       ;; @r{@code{foo} was changed.}\n"
"     @result{} (a c b e d)\n"
msgstr ""
"foo                       ;; @r{@code{foo}が変更された}\n"
"     @result{} (a c b e d)\n"

#. type: section
#: original_texis/lists.texi:867
#, no-wrap
msgid "Modifying Existing List Structure"
msgstr "Modifying Existing List Structure"

#. type: cindex
#: original_texis/lists.texi:868
#, no-wrap
msgid "destructive list operations"
msgstr "destructive list operations"

#. type: cindex
#: original_texis/lists.texi:869
#, no-wrap
msgid "mutable lists"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:878
msgid "You can modify the @sc{car} and @sc{cdr} contents of a cons cell with the primitives @code{setcar} and @code{setcdr}.  These are destructive operations because they change existing list structure.  Destructive operations should be applied only to mutable lists, that is, lists constructed via @code{cons}, @code{list} or similar operations.  Lists created by quoting are part of the program and should not be changed by destructive operations.  @xref{Mutability}."
msgstr ""

#. type: cindex
#: original_texis/lists.texi:879
#, no-wrap
msgid "CL note---@code{rplaca} vs @code{setcar}"
msgstr "CL note---@code{rplaca} vs @code{setcar}"

#. type: findex
#: original_texis/lists.texi:881
#, no-wrap
msgid "rplaca"
msgstr "rplaca"

#. type: findex
#: original_texis/lists.texi:882
#, no-wrap
msgid "rplacd"
msgstr "rplacd"

#. type: quotation
#: original_texis/lists.texi:888
msgid "@b{Common Lisp note:} Common Lisp uses functions @code{rplaca} and @code{rplacd} to alter list structure; they change structure the same way as @code{setcar} and @code{setcdr}, but the Common Lisp functions return the cons cell while @code{setcar} and @code{setcdr} return the new @sc{car} or @sc{cdr}."
msgstr "@b{Common Lispに関する注意: }Common Lispはリスト構造の変更に@code{rplaca}と@code{rplacd}を使用する。これらは@code{setcar}や@code{setcdr}と同じ方法でリスト構造を変更するが、@code{setcar}と@code{setcdr}は新しい@sc{car}や@sc{cdr}をリターンするのにたいして、Common Lispの関数はコンスセルをリターンする。"

#. type: node
#: original_texis/lists.texi:895 original_texis/lists.texi:897
#, no-wrap
msgid "Setcar"
msgstr "Setcar"

#. type: menuentry
#: original_texis/lists.texi:895
msgid "Replacing an element in a list."
msgstr "リスト内の要素の置き換え。"

#. type: node
#: original_texis/lists.texi:895 original_texis/lists.texi:1004
#, no-wrap
msgid "Setcdr"
msgstr "Setcdr"

#. type: menuentry
#: original_texis/lists.texi:895
msgid "Replacing part of the list backbone.  This can be used to remove or add elements."
msgstr "リストの根幹部分の置き換え。これは要素の追加や削除に使用される。"

#. type: node
#: original_texis/lists.texi:895 original_texis/lists.texi:1106
#, no-wrap
msgid "Rearrangement"
msgstr "Rearrangement"

#. type: menuentry
#: original_texis/lists.texi:895
msgid "Reordering the elements in a list; combining lists."
msgstr "リスト内の要素の再配置、リストの合成。"

#. type: subsection
#: original_texis/lists.texi:898
#, no-wrap
msgid "Altering List Elements with @code{setcar}"
msgstr "Altering List Elements with @code{setcar}"

#. type: cindex
#: original_texis/lists.texi:899
#, no-wrap
msgid "replace list element"
msgstr "replace list element"

#. type: cindex
#: original_texis/lists.texi:900
#, no-wrap
msgid "list, replace element"
msgstr "list, replace element"

#. type: Plain text
#: original_texis/lists.texi:905
msgid "Changing the @sc{car} of a cons cell is done with @code{setcar}.  When used on a list, @code{setcar} replaces one element of a list with a different element."
msgstr "コンスセルの@sc{car}の変更は@code{setcar}で行ないます。リストにたいして使用すると@code{setcar}はリストの1つの要素を別の要素に置き換えます。"

#. type: defun
#: original_texis/lists.texi:906
#, no-wrap
msgid "setcar cons object"
msgstr "setcar cons object"

#. type: defun
#: original_texis/lists.texi:911
msgid "This function stores @var{object} as the new @sc{car} of @var{cons}, replacing its previous @sc{car}.  In other words, it changes the @sc{car} slot of @var{cons} to refer to @var{object}.  It returns the value @var{object}.  For example:"
msgstr "この関数は以前の@sc{car}を置き換えて、@var{cons}の新しい@sc{car}に@var{object}を格納する。言い換えると、この関数は@var{cons}の@sc{car}スロットを@var{object}を参照するように変更する。この関数は値@var{object}をリターンする。たとえば:"

#. type: group
#: original_texis/lists.texi:916
#, fuzzy, no-wrap
#| msgid ""
#| "(setq x '(1 2))\n"
#| "     @result{} (1 2)\n"
msgid ""
"(setq x (list 1 2))\n"
"     @result{} (1 2)\n"
msgstr ""
"(setq x '(1 2))\n"
"     @result{} (1 2)\n"

#. type: group
#: original_texis/lists.texi:920
#, no-wrap
msgid ""
"(setcar x 4)\n"
"     @result{} 4\n"
msgstr ""
"(setcar x 4)\n"
"     @result{} 4\n"

#. type: group
#: original_texis/lists.texi:924
#, no-wrap
msgid ""
"x\n"
"     @result{} (4 2)\n"
msgstr ""
"x\n"
"     @result{} (4 2)\n"

#. type: Plain text
#: original_texis/lists.texi:931
msgid "When a cons cell is part of the shared structure of several lists, storing a new @sc{car} into the cons changes one element of each of these lists.  Here is an example:"
msgstr "コンスセルが複数のリストを共有する構造の一部なら、コンスに新しい@sc{car}を格納することにより、これら共有されたリストの各1つの要素を変更します。以下は例です:"

#. type: group
#: original_texis/lists.texi:939
#, fuzzy, no-wrap
#| msgid ""
#| ";; @r{Create two lists that are partly shared.}\n"
#| "(setq x1 '(a b c))\n"
#| "     @result{} (a b c)\n"
#| "(setq x2 (cons 'z (cdr x1)))\n"
#| "     @result{} (z b c)\n"
msgid ""
";; @r{Create two lists that are partly shared.}\n"
"(setq x1 (list 'a 'b 'c))\n"
"     @result{} (a b c)\n"
"(setq x2 (cons 'z (cdr x1)))\n"
"     @result{} (z b c)\n"
msgstr ""
";; @r{部分的に共有された2つのリストを作成}\n"
"(setq x1 '(a b c))\n"
"     @result{} (a b c)\n"
"(setq x2 (cons 'z (cdr x1)))\n"
"     @result{} (z b c)\n"

#. type: group
#: original_texis/lists.texi:949
#, no-wrap
msgid ""
";; @r{Replace the @sc{car} of a shared link.}\n"
"(setcar (cdr x1) 'foo)\n"
"     @result{} foo\n"
"x1                           ; @r{Both lists are changed.}\n"
"     @result{} (a foo c)\n"
"x2\n"
"     @result{} (z foo c)\n"
msgstr ""
";; @r{共有されたリンクの@sc{car}を置き換え}\n"
"(setcar (cdr x1) 'foo)\n"
"     @result{} foo\n"
"x1                           ; @r{両方のリストが変更された}\n"
"     @result{} (a foo c)\n"
"x2\n"
"     @result{} (z foo c)\n"

#. type: group
#: original_texis/lists.texi:959
#, no-wrap
msgid ""
";; @r{Replace the @sc{car} of a link that is not shared.}\n"
"(setcar x1 'baz)\n"
"     @result{} baz\n"
"x1                           ; @r{Only one list is changed.}\n"
"     @result{} (baz foo c)\n"
"x2\n"
"     @result{} (z foo c)\n"
msgstr ""
";; @r{共有されていないリンクの@sc{car}を置き換え}\n"
"(setcar x1 'baz)\n"
"     @result{} baz\n"
"x1                           ; @r{1つのリストだけが変更された}\n"
"     @result{} (baz foo c)\n"
"x2\n"
"     @result{} (z foo c)\n"

#. type: Plain text
#: original_texis/lists.texi:965
msgid "Here is a graphical depiction of the shared structure of the two lists in the variables @code{x1} and @code{x2}, showing why replacing @code{b} changes them both:"
msgstr "なぜ@code{b}を置き換えると両方が変更されるのかを説明するために、変数@code{x1}と@code{x2}の2つのリストによる共有構造を視覚化してみましょう:"

#. type: group
#: original_texis/lists.texi:981
#, no-wrap
msgid ""
"        --- ---        --- ---      --- ---\n"
"x1---> |   |   |----> |   |   |--> |   |   |--> nil\n"
"        --- ---        --- ---      --- ---\n"
"         |        -->   |            |\n"
"         |       |      |            |\n"
"          --> a  |       --> b        --> c\n"
"                 |\n"
"       --- ---   |\n"
"x2--> |   |   |--\n"
"       --- ---\n"
"        |\n"
"        |\n"
"         --> z\n"
msgstr ""
"        --- ---        --- ---      --- ---\n"
"x1---> |   |   |----> |   |   |--> |   |   |--> nil\n"
"        --- ---        --- ---      --- ---\n"
"         |        -->   |            |\n"
"         |       |      |            |\n"
"          --> a  |       --> b        --> c\n"
"                 |\n"
"       --- ---   |\n"
"x2--> |   |   |--\n"
"       --- ---\n"
"        |\n"
"        |\n"
"         --> z\n"

#. type: Plain text
#: original_texis/lists.texi:985
msgid "Here is an alternative form of box diagram, showing the same relationship:"
msgstr "同じ関係を別のボックス図で示すと、以下のようになります:"

#. type: group
#: original_texis/lists.texi:1001
#, no-wrap
msgid ""
"x1:\n"
" --------------       --------------       --------------\n"
"| car   | cdr  |     | car   | cdr  |     | car   | cdr  |\n"
"|   a   |   o------->|   b   |   o------->|   c   |  nil |\n"
"|       |      |  -->|       |      |     |       |      |\n"
" --------------  |    --------------       --------------\n"
"                 |\n"
"x2:              |\n"
" --------------  |\n"
"| car   | cdr  | |\n"
"|   z   |   o----\n"
"|       |      |\n"
" --------------\n"
msgstr ""
"x1:\n"
" --------------       --------------       --------------\n"
"| car   | cdr  |     | car   | cdr  |     | car   | cdr  |\n"
"|   a   |   o------->|   b   |   o------->|   c   |  nil |\n"
"|       |      |  -->|       |      |     |       |      |\n"
" --------------  |    --------------       --------------\n"
"                 |\n"
"x2:              |\n"
" --------------  |\n"
"| car   | cdr  | |\n"
"|   z   |   o----\n"
"|       |      |\n"
" --------------\n"

#. type: subsection
#: original_texis/lists.texi:1005
#, no-wrap
msgid "Altering the CDR of a List"
msgstr "Altering the CDR of a List"

#. type: cindex
#: original_texis/lists.texi:1006
#, no-wrap
msgid "replace part of list"
msgstr "replace part of list"

#. type: Plain text
#: original_texis/lists.texi:1009
msgid "The lowest-level primitive for modifying a @sc{cdr} is @code{setcdr}:"
msgstr "@sc{cdr}を変更するもっとも低レベルのプリミティブ関数は@code{setcdr}です:"

#. type: defun
#: original_texis/lists.texi:1010
#, no-wrap
msgid "setcdr cons object"
msgstr "setcdr cons object"

#. type: defun
#: original_texis/lists.texi:1015
msgid "This function stores @var{object} as the new @sc{cdr} of @var{cons}, replacing its previous @sc{cdr}.  In other words, it changes the @sc{cdr} slot of @var{cons} to refer to @var{object}.  It returns the value @var{object}."
msgstr "この関数は前の@sc{cdr}を置き換えて、@var{cons}の新しい@sc{cdr}に@var{object}を格納する。言い換えると、この関数は@var{cons}の@sc{cdr}が@var{object}を参照するように変更する。この関数は値@var{object}をリターンする。"

#. type: Plain text
#: original_texis/lists.texi:1022
msgid "Here is an example of replacing the @sc{cdr} of a list with a different list.  All but the first element of the list are removed in favor of a different sequence of elements.  The first element is unchanged, because it resides in the @sc{car} of the list, and is not reached via the @sc{cdr}."
msgstr "以下はリストの@sc{cdr}を、他のリストに置き換える例です。1番目の要素以外のすべての要素は、別のシーケンスまたは要素のために取り除かれます。1番目の要素はリストの@sc{car}なので変更されず、@sc{cdr}を通じて到達することもできないからです。"

#. type: group
#: original_texis/lists.texi:1027 original_texis/lists.texi:1140
#: original_texis/lists.texi:1160
#, fuzzy, no-wrap
#| msgid ""
#| "(setq x '(1 2 3))\n"
#| "     @result{} (1 2 3)\n"
msgid ""
"(setq x (list 1 2 3))\n"
"     @result{} (1 2 3)\n"
msgstr ""
"(setq x '(1 2 3))\n"
"     @result{} (1 2 3)\n"

#. type: group
#: original_texis/lists.texi:1031
#, no-wrap
msgid ""
"(setcdr x '(4))\n"
"     @result{} (4)\n"
msgstr ""
"(setcdr x '(4))\n"
"     @result{} (4)\n"

#. type: group
#: original_texis/lists.texi:1035
#, no-wrap
msgid ""
"x\n"
"     @result{} (1 4)\n"
msgstr ""
"x\n"
"     @result{} (1 4)\n"

#. type: Plain text
#: original_texis/lists.texi:1042
msgid "You can delete elements from the middle of a list by altering the @sc{cdr}s of the cons cells in the list.  For example, here we delete the second element, @code{b}, from the list @code{(a b c)}, by changing the @sc{cdr} of the first cons cell:"
msgstr "リスト内のコンスセルの@sc{cdr}を変更することにより、リストの途中から要素を削除できます。たとえば以下では、1番目のコンスセルの@sc{cdr}を変更することにより、2番目の要素@code{b}をリスト@code{(a b c)}から削除します。"

#. type: group
#: original_texis/lists.texi:1051
#, fuzzy, no-wrap
#| msgid ""
#| "(setq x1 '(a b c))\n"
#| "     @result{} (a b c)\n"
#| "(setcdr x1 (cdr (cdr x1)))\n"
#| "     @result{} (c)\n"
#| "x1\n"
#| "     @result{} (a c)\n"
msgid ""
"(setq x1 (list 'a 'b 'c))\n"
"     @result{} (a b c)\n"
"(setcdr x1 (cdr (cdr x1)))\n"
"     @result{} (c)\n"
"x1\n"
"     @result{} (a c)\n"
msgstr ""
"(setq x1 '(a b c))\n"
"     @result{} (a b c)\n"
"(setcdr x1 (cdr (cdr x1)))\n"
"     @result{} (c)\n"
"x1\n"
"     @result{} (a c)\n"

#. type: Plain text
#: original_texis/lists.texi:1055
msgid "Here is the result in box notation:"
msgstr "以下に結果をボックス表記で示します:"

#. type: group
#: original_texis/lists.texi:1065
#, no-wrap
msgid ""
"                   --------------------\n"
"                  |                    |\n"
" --------------   |   --------------   |    --------------\n"
"| car   | cdr  |  |  | car   | cdr  |   -->| car   | cdr  |\n"
"|   a   |   o-----   |   b   |   o-------->|   c   |  nil |\n"
"|       |      |     |       |      |      |       |      |\n"
" --------------       --------------        --------------\n"
msgstr ""
"                   --------------------\n"
"                  |                    |\n"
" --------------   |   --------------   |    --------------\n"
"| car   | cdr  |  |  | car   | cdr  |   -->| car   | cdr  |\n"
"|   a   |   o-----   |   b   |   o-------->|   c   |  nil |\n"
"|       |      |     |       |      |      |       |      |\n"
" --------------       --------------        --------------\n"

#. type: Plain text
#: original_texis/lists.texi:1072
msgid "The second cons cell, which previously held the element @code{b}, still exists and its @sc{car} is still @code{b}, but it no longer forms part of this list."
msgstr "以前は要素@code{b}を保持していた2番目のコンスセルは依然として存在し、その@sc{car}も@code{b}のままですが、すでにこのリストの一部を形成していません。"

#. type: Plain text
#: original_texis/lists.texi:1074
msgid "It is equally easy to insert a new element by changing @sc{cdr}s:"
msgstr "@sc{cdr}を変更して新しい要素を挿入するのも同じくらい簡単です:"

#. type: group
#: original_texis/lists.texi:1083
#, fuzzy, no-wrap
#| msgid ""
#| "(setq x1 '(a b c))\n"
#| "     @result{} (a b c)\n"
#| "(setcdr x1 (cons 'd (cdr x1)))\n"
#| "     @result{} (d b c)\n"
#| "x1\n"
#| "     @result{} (a d b c)\n"
msgid ""
"(setq x1 (list 'a 'b 'c))\n"
"     @result{} (a b c)\n"
"(setcdr x1 (cons 'd (cdr x1)))\n"
"     @result{} (d b c)\n"
"x1\n"
"     @result{} (a d b c)\n"
msgstr ""
"(setq x1 '(a b c))\n"
"     @result{} (a b c)\n"
"(setcdr x1 (cons 'd (cdr x1)))\n"
"     @result{} (d b c)\n"
"x1\n"
"     @result{} (a d b c)\n"

#. type: Plain text
#: original_texis/lists.texi:1087
msgid "Here is this result in box notation:"
msgstr "以下に結果をボックス表記で示します:"

#. type: group
#: original_texis/lists.texi:1103
#, no-wrap
msgid ""
" --------------        -------------       -------------\n"
"| car  | cdr   |      | car  | cdr  |     | car  | cdr  |\n"
"|   a  |   o   |   -->|   b  |   o------->|   c  |  nil |\n"
"|      |   |   |  |   |      |      |     |      |      |\n"
" --------- | --   |    -------------       -------------\n"
"           |      |\n"
"     -----         --------\n"
"    |                      |\n"
"    |    ---------------   |\n"
"    |   | car   | cdr   |  |\n"
"     -->|   d   |   o------\n"
"        |       |       |\n"
"         ---------------\n"
msgstr ""
" --------------        -------------       -------------\n"
"| car  | cdr   |      | car  | cdr  |     | car  | cdr  |\n"
"|   a  |   o   |   -->|   b  |   o------->|   c  |  nil |\n"
"|      |   |   |  |   |      |      |     |      |      |\n"
" --------- | --   |    -------------       -------------\n"
"           |      |\n"
"     -----         --------\n"
"    |                      |\n"
"    |    ---------------   |\n"
"    |   | car   | cdr   |  |\n"
"     -->|   d   |   o------\n"
"        |       |       |\n"
"         ---------------\n"

#. type: subsection
#: original_texis/lists.texi:1107
#, no-wrap
msgid "Functions that Rearrange Lists"
msgstr "Functions that Rearrange Lists"

#. type: cindex
#: original_texis/lists.texi:1108
#, no-wrap
msgid "rearrangement of lists"
msgstr "rearrangement of lists"

#. type: cindex
#: original_texis/lists.texi:1109
#, no-wrap
msgid "reordering, of elements in lists"
msgstr "reordering, of elements in lists"

#. type: cindex
#: original_texis/lists.texi:1110
#, no-wrap
msgid "modification of lists"
msgstr "modification of lists"

#. type: Plain text
#: original_texis/lists.texi:1117
msgid "Here are some functions that rearrange lists destructively by modifying the @sc{cdr}s of their component cons cells.  These functions are destructive because they chew up the original lists passed to them as arguments, relinking their cons cells to form a new list that is the returned value."
msgstr "以下ではリストの構成要素であるコンスセルの@sc{cdr}を変更することにより、リストを破壊的に再配置する関数をいくつか示します。これらの関数が破壊的だという理由は、これらの関数が引数として渡された元のリストを処理してリターン値となる新しいリストを形成するために、リストのコンスセルを再リンクするからです。"

#. type: ifnottex
#: original_texis/lists.texi:1121
msgid "See @code{delq}, in @ref{Sets And Lists}, for another function that modifies cons cells."
msgstr "コンスセルを変更する他の関数については、@ref{Sets And Lists}の@code{delq}を参照してください。"

#. type: iftex
#: original_texis/lists.texi:1125
msgid "The function @code{delq} in the following section is another example of destructive list manipulation."
msgstr "以降のセクションで説明する関数@code{delq}は、破壊的にリストを操作する別の例です。"

#. type: defun
#: original_texis/lists.texi:1127
#, no-wrap
msgid "nconc &rest lists"
msgstr "nconc &rest lists"

#. type: cindex
#: original_texis/lists.texi:1128
#, no-wrap
msgid "concatenating lists"
msgstr "concatenating lists"

#. type: cindex
#: original_texis/lists.texi:1129
#, no-wrap
msgid "joining lists"
msgstr "joining lists"

#. type: defun
#: original_texis/lists.texi:1135
msgid "This function returns a list containing all the elements of @var{lists}.  Unlike @code{append} (@pxref{Building Lists}), the @var{lists} are @emph{not} copied.  Instead, the last @sc{cdr} of each of the @var{lists} is changed to refer to the following list.  The last of the @var{lists} is not altered.  For example:"
msgstr "この関数は@var{lists}の要素すべてを含むリストをリターンする。@code{append} (@ref{Building Lists}を参照)とは異なり、@var{lists}は@emph{コピーされない}。かわりに@var{lists}の各リストの最後の@sc{cdr}が次のリストを参照するように変更される。@var{lists}の最後のリストは変更されない。たとえば:"

#. type: group
#: original_texis/lists.texi:1144
#, no-wrap
msgid ""
"(nconc x '(4 5))\n"
"     @result{} (1 2 3 4 5)\n"
msgstr ""
"(nconc x '(4 5))\n"
"     @result{} (1 2 3 4 5)\n"

#. type: group
#: original_texis/lists.texi:1148
#, no-wrap
msgid ""
"x\n"
"     @result{} (1 2 3 4 5)\n"
msgstr ""
"x\n"
"     @result{} (1 2 3 4 5)\n"

#. type: defun
#: original_texis/lists.texi:1155
msgid "Since the last argument of @code{nconc} is not itself modified, it is reasonable to use a constant list, such as @code{'(4 5)}, as in the above example.  For the same reason, the last argument need not be a list:"
msgstr "@code{nconc}の最後の引数は変更されないので、上記の例のように@code{'(4 5)}のような定数リストを使用するのが合理的である。また同じ理由により最後の引数がリストである必要はない。"

#. type: group
#: original_texis/lists.texi:1164
#, no-wrap
msgid ""
"(nconc x 'z)\n"
"     @result{} (1 2 3 . z)\n"
msgstr ""
"(nconc x 'z)\n"
"     @result{} (1 2 3 . z)\n"

#. type: group
#: original_texis/lists.texi:1168
#, no-wrap
msgid ""
"x\n"
"     @result{} (1 2 3 . z)\n"
msgstr ""
"x\n"
"     @result{} (1 2 3 . z)\n"

#. type: defun
#: original_texis/lists.texi:1172
#, fuzzy
#| msgid "However, the other arguments (all but the last) must be lists."
msgid "However, the other arguments (all but the last) should be mutable lists."
msgstr "しかし他の(最後を除くすべての)引数はリストでなければなければならない。"

#. type: defun
#: original_texis/lists.texi:1178
#, fuzzy
#| msgid "A common pitfall is to use a quoted constant list as a non-last argument to @code{nconc}.  If you do this, your program will change each time you run it! Here is what happens:"
msgid "A common pitfall is to use a constant list as a non-last argument to @code{nconc}.  If you do this, the resulting behavior is undefined.  It is possible that your program will change each time you run it! Here is what might happen (though this is not guaranteed to happen):"
msgstr "一般的な落とし穴としては、@code{nconc}にたいしてクォートされたリスト定数を最後以外の引数として使用した場合である。これを行なうと、実行するごとにプログラムはリスト定数を変更するだろう! 何が起こるのかを以下に示す:"

#. type: group
#: original_texis/lists.texi:1183
#, no-wrap
msgid ""
"(defun add-foo (x)            ; @r{We want this function to add}\n"
"  (nconc '(foo) x))           ;   @r{@code{foo} to the front of its arg.}\n"
msgstr ""
"(defun add-foo (x)            ; @r{この関数では@code{foo}}\n"
"  (nconc '(foo) x))           ;   @r{を引数の前に追加したい}\n"

#. type: group
#: original_texis/lists.texi:1188
#, fuzzy, no-wrap
#| msgid ""
#| "(symbol-function 'add-foo)\n"
#| "     @result{} (lambda (x) (nconc (quote (foo)) x))\n"
msgid ""
"(symbol-function 'add-foo)\n"
"     @result{} (lambda (x) (nconc '(foo) x))\n"
msgstr ""
"(symbol-function 'add-foo)\n"
"     @result{} (lambda (x) (nconc (quote (foo)) x))\n"

#. type: group
#: original_texis/lists.texi:1193
#, no-wrap
msgid ""
"(setq xx (add-foo '(1 2)))    ; @r{It seems to work.}\n"
"     @result{} (foo 1 2)\n"
msgstr ""
"(setq xx (add-foo '(1 2)))    ; @r{動いているように見える}\n"
"     @result{} (foo 1 2)\n"

#. type: group
#: original_texis/lists.texi:1197
#, no-wrap
msgid ""
"(setq xy (add-foo '(3 4)))    ; @r{What happened?}\n"
"     @result{} (foo 1 2 3 4)\n"
msgstr ""
"(setq xy (add-foo '(3 4)))    ; @r{何が起きているのか?}\n"
"     @result{} (foo 1 2 3 4)\n"

#. type: group
#: original_texis/lists.texi:1201
#, no-wrap
msgid ""
"(eq xx xy)\n"
"     @result{} t\n"
msgstr ""
"(eq xx xy)\n"
"     @result{} t\n"

#. type: group
#: original_texis/lists.texi:1206
#, fuzzy, no-wrap
#| msgid ""
#| "(symbol-function 'add-foo)\n"
#| "     @result{} (lambda (x) (nconc (quote (foo 1 2 3 4) x)))\n"
msgid ""
"(symbol-function 'add-foo)\n"
"     @result{} (lambda (x) (nconc '(foo 1 2 3 4) x))\n"
msgstr ""
"(symbol-function 'add-foo)\n"
"     @result{} (lambda (x) (nconc (quote (foo 1 2 3 4) x)))\n"

#. type: section
#: original_texis/lists.texi:1211
#, no-wrap
msgid "Using Lists as Sets"
msgstr "Using Lists as Sets"

#. type: cindex
#: original_texis/lists.texi:1212
#, no-wrap
msgid "lists as sets"
msgstr "lists as sets"

#. type: cindex
#: original_texis/lists.texi:1213
#, no-wrap
msgid "sets"
msgstr "sets"

#. type: Plain text
#: original_texis/lists.texi:1222
msgid "A list can represent an unordered mathematical set---simply consider a value an element of a set if it appears in the list, and ignore the order of the list.  To form the union of two sets, use @code{append} (as long as you don't mind having duplicate elements).  You can remove @code{equal} duplicates using @code{delete-dups}.  Other useful functions for sets include @code{memq} and @code{delq}, and their @code{equal} versions, @code{member} and @code{delete}."
msgstr "リストは順序なしの数学的集合 --- リスト内に要素があれば集合の要素の値としてリスト内の順序は無視される --- を表すことができます。2つの集合を結合(union)するには、(重複する要素を気にしなければ)@code{append}を使用します。@code{equal}である重複を取り除くには@code{delete-dups}を使用します。集合にたいする他の有用な関数には@code{memq}や@code{delq}や、それらの@code{equal}バージョンである@code{member}と@code{delete}が含まれます。"

#. type: cindex
#: original_texis/lists.texi:1223
#, no-wrap
msgid "CL note---lack @code{union}, @code{intersection}"
msgstr "CL note---lack @code{union}, @code{intersection}"

#. type: quotation
#: original_texis/lists.texi:1229
#, fuzzy
#| msgid "@b{Common Lisp note:} Common Lisp has functions @code{union} (which avoids duplicate elements) and @code{intersection} for set operations.  Although standard GNU Emacs Lisp does not have them, the @file{cl-lib} library provides versions.  @xref{Lists as Sets,,, cl, Common Lisp Extensions}."
msgid "@b{Common Lisp note:} Common Lisp has functions @code{union} (which avoids duplicate elements) and @code{intersection} for set operations.  In Emacs Lisp, variants of these facilities are provided by the @file{cl-lib} library.  @xref{Lists as Sets,,,cl,Common Lisp Extensions}."
msgstr "@b{Common Lispに関する注意:} 集合を処理するためにCommon Lispには(要素の重複がない)関数@code{union}がある。これらの関数は標準のGNU Emacs Lispには存在しないが、@file{cl-lib}がこれらを提供する。@ref{Lists as Sets,,, cl, Common Lisp Extensions}を参照されたい。"

#. type: defun
#: original_texis/lists.texi:1231
#, no-wrap
msgid "memq object list"
msgstr "memq object list"

#. type: cindex
#: original_texis/lists.texi:1232
#, no-wrap
msgid "membership in a list"
msgstr "membership in a list"

#. type: defun
#: original_texis/lists.texi:1238
msgid "This function tests to see whether @var{object} is a member of @var{list}.  If it is, @code{memq} returns a list starting with the first occurrence of @var{object}.  Otherwise, it returns @code{nil}.  The letter @samp{q} in @code{memq} says that it uses @code{eq} to compare @var{object} against the elements of the list.  For example:"
msgstr "この関数は@var{object}が@var{list}のメンバーかどうかをテストする。メンバーなら@code{memq}は、@var{object}で最初に見つかった要素から開始されるリストをリターンする。メンバーでなければ@code{nil}をリターンする。@code{memq}の文字@samp{q}は、この関数が@var{object}とリスト内の要素の比較に@code{eq}を使用することを示す。たとえば:"

#. type: group
#: original_texis/lists.texi:1243
#, no-wrap
msgid ""
"(memq 'b '(a b c b a))\n"
"     @result{} (b c b a)\n"
msgstr ""
"(memq 'b '(a b c b a))\n"
"     @result{} (b c b a)\n"

#. type: group
#: original_texis/lists.texi:1247
#, fuzzy, no-wrap
#| msgid ""
#| "(memq '(2) '((1) (2)))    ; @r{@code{(2)} and @code{(2)} are not @code{eq}.}\n"
#| "     @result{} nil\n"
msgid ""
"(memq '(2) '((1) (2)))    ; @r{The two @code{(2)}s need not be @code{eq}.}\n"
"     @result{} @r{Unspecified; might be @code{nil} or @code{((2))}.}\n"
msgstr ""
"(memq '(2) '((1) (2)))    ; @r{@code{(2)}と@code{(2)}は@code{eq}ではない。}\n"
"     @result{} nil\n"

#. type: defun
#: original_texis/lists.texi:1251
#, no-wrap
msgid "delq object list"
msgstr "delq object list"

#. type: cindex
#: original_texis/lists.texi:1252
#, no-wrap
msgid "deleting list elements"
msgstr "deleting list elements"

#. type: defun
#: original_texis/lists.texi:1258
msgid "This function destructively removes all elements @code{eq} to @var{object} from @var{list}, and returns the resulting list.  The letter @samp{q} in @code{delq} says that it uses @code{eq} to compare @var{object} against the elements of the list, like @code{memq} and @code{remq}."
msgstr "この関数は@var{list}から@var{object}と@code{eq}であるような、すべての要素を破壊的に取り除いて結果のリストをリターンする。@code{delq}の文字@samp{q}は、この関数が@var{object}とリスト内の要素の比較に@code{eq}を使用することを示す(@code{memq}や@code{remq}と同様)。"

#. type: defun
#: original_texis/lists.texi:1262
msgid "Typically, when you invoke @code{delq}, you should use the return value by assigning it to the variable which held the original list.  The reason for this is explained below."
msgstr "@code{delq}を呼び出すときは、通常は元のリストを保持していた変数にリターン値を割り当てて使用する必要がある(理由は以下参照)。"

#. type: Plain text
#: original_texis/lists.texi:1267
msgid "The @code{delq} function deletes elements from the front of the list by simply advancing down the list, and returning a sublist that starts after those elements.  For example:"
msgstr "@code{delq}関数がリストの先頭にある要素を削除する場合は、単にリストを読み進めてこの要素の後から開始される部分リストをリターンします。つまり:"

#. type: group
#: original_texis/lists.texi:1271
#, no-wrap
msgid "(delq 'a '(a b c)) @equiv{} (cdr '(a b c))\n"
msgstr "(delq 'a '(a b c)) @equiv{} (cdr '(a b c))\n"

#. type: Plain text
#: original_texis/lists.texi:1277
msgid "When an element to be deleted appears in the middle of the list, removing it involves changing the @sc{cdr}s (@pxref{Setcdr})."
msgstr "リストの途中にある要素を削除するときは、必要な@sc{cdr} (@ref{Setcdr}を参照)を変更することで削除を行います。"

#. type: group
#: original_texis/lists.texi:1282
#, fuzzy, no-wrap
#| msgid ""
#| "(setq sample-list '(a b c (4)))\n"
#| "     @result{} (a b c (4))\n"
msgid ""
"(setq sample-list (list 'a 'b 'c '(4)))\n"
"     @result{} (a b c (4))\n"
msgstr ""
"(setq sample-list '(a b c (4)))\n"
"     @result{} (a b c (4))\n"

#. type: group
#: original_texis/lists.texi:1286
#, no-wrap
msgid ""
"(delq 'a sample-list)\n"
"     @result{} (b c (4))\n"
msgstr ""
"(delq 'a sample-list)\n"
"     @result{} (b c (4))\n"

#. type: group
#: original_texis/lists.texi:1290
#, no-wrap
msgid ""
"sample-list\n"
"     @result{} (a b c (4))\n"
msgstr ""
"sample-list\n"
"     @result{} (a b c (4))\n"

#. type: group
#: original_texis/lists.texi:1294
#, no-wrap
msgid ""
"(delq 'c sample-list)\n"
"     @result{} (a b (4))\n"
msgstr ""
"(delq 'c sample-list)\n"
"     @result{} (a b (4))\n"

#. type: group
#: original_texis/lists.texi:1298
#, no-wrap
msgid ""
"sample-list\n"
"     @result{} (a b (4))\n"
msgstr ""
"sample-list\n"
"     @result{} (a b (4))\n"

#. type: Plain text
#: original_texis/lists.texi:1308
msgid "Note that @code{(delq 'c sample-list)} modifies @code{sample-list} to splice out the third element, but @code{(delq 'a sample-list)} does not splice anything---it just returns a shorter list.  Don't assume that a variable which formerly held the argument @var{list} now has fewer elements, or that it still holds the original list! Instead, save the result of @code{delq} and use that.  Most often we store the result back into the variable that held the original list:"
msgstr "@code{(delq 'a sample-list)}は何も取り除きませんが(単に短いリストをリターンする)、@code{(delq 'c sample-list)}は3番目の要素を取り除いて@code{sample-list}を変更することに注意してください。引数@var{list}を保持するように形成された変数が、実行後にもっと少ない要素になるとか、元のリストを保持すると仮定しないでください! かわりに@code{delq}の結果を保存して、それを使用してください。元のリストを保持していた変数に結果を書き戻すことはよく行なわれます。"

#. type: example
#: original_texis/lists.texi:1311
#, no-wrap
msgid "(setq flowers (delq 'rose flowers))\n"
msgstr "(setq flowers (delq 'rose flowers))\n"

#. type: Plain text
#: original_texis/lists.texi:1315
#, fuzzy
#| msgid "In the following example, the @code{(4)} that @code{delq} attempts to match and the @code{(4)} in the @code{sample-list} are not @code{eq}:"
msgid "In the following example, the @code{(list 4)} that @code{delq} attempts to match and the @code{(4)} in the @code{sample-list} are @code{equal} but not @code{eq}:"
msgstr "以下の例では、@code{delq}が比較しようとしている@code{(4)}と、@code{sample-list}内の@code{(4)}は@code{eq}ではありません:"

#. type: group
#: original_texis/lists.texi:1320
#, fuzzy, no-wrap
#| msgid ""
#| "(delq '(4) sample-list)\n"
#| "     @result{} (a c (4))\n"
msgid ""
"(delq (list 4) sample-list)\n"
"     @result{} (a c (4))\n"
msgstr ""
"(delq '(4) sample-list)\n"
"     @result{} (a c (4))\n"

#. type: Plain text
#: original_texis/lists.texi:1325
msgid "If you want to delete elements that are @code{equal} to a given value, use @code{delete} (see below)."
msgstr "与えられた値と@code{equal}な要素を削除したい場合には、@code{delete} (以下参照)を使用してください。"

#. type: defun
#: original_texis/lists.texi:1326
#, no-wrap
msgid "remq object list"
msgstr "remq object list"

#. type: defun
#: original_texis/lists.texi:1331
msgid "This function returns a copy of @var{list}, with all elements removed which are @code{eq} to @var{object}.  The letter @samp{q} in @code{remq} says that it uses @code{eq} to compare @var{object} against the elements of @code{list}."
msgstr "この関数は@var{object}と@code{eq}なすべての要素が除かれた、@var{list}のコピーをリターンする。@code{remq}の文字@samp{q}は、この関数が@var{object}とリスト内の要素の比較に@code{eq}を使用することを示す。"

#. type: group
#: original_texis/lists.texi:1336
#, fuzzy, no-wrap
#| msgid ""
#| "(setq sample-list '(a b c a b c))\n"
#| "     @result{} (a b c a b c)\n"
msgid ""
"(setq sample-list (list 'a 'b 'c 'a 'b 'c))\n"
"     @result{} (a b c a b c)\n"
msgstr ""
"(setq sample-list '(a b c a b c))\n"
"     @result{} (a b c a b c)\n"

#. type: group
#: original_texis/lists.texi:1340
#, no-wrap
msgid ""
"(remq 'a sample-list)\n"
"     @result{} (b c b c)\n"
msgstr ""
"(remq 'a sample-list)\n"
"     @result{} (b c b c)\n"

#. type: group
#: original_texis/lists.texi:1344
#, no-wrap
msgid ""
"sample-list\n"
"     @result{} (a b c a b c)\n"
msgstr ""
"sample-list\n"
"     @result{} (a b c a b c)\n"

#. type: defun
#: original_texis/lists.texi:1348
#, no-wrap
msgid "memql object list"
msgstr "memql object list"

#. type: defun
#: original_texis/lists.texi:1354
msgid "The function @code{memql} tests to see whether @var{object} is a member of @var{list}, comparing members with @var{object} using @code{eql}, so floating-point elements are compared by value.  If @var{object} is a member, @code{memql} returns a list starting with its first occurrence in @var{list}.  Otherwise, it returns @code{nil}."
msgstr "関数@code{memql}は@code{eql}(浮動少数点数の要素は値で比較される)を使用してメンバーと@code{eql}を比較することにより、@var{object}が@var{list}のメンバーかどうかをテストする。@var{object}がメンバーなら、@code{memql}は@var{list}内で最初に見つかった要素から始まるリスト、それ以外なら@code{nil}をリターンする。"

#. type: defun
#: original_texis/lists.texi:1356 original_texis/lists.texi:1380
msgid "Compare this with @code{memq}:"
msgstr "@code{memq}と比較してみよう:"

#. type: group
#: original_texis/lists.texi:1361
#, no-wrap
msgid ""
"(memql 1.2 '(1.1 1.2 1.3))  ; @r{@code{1.2} and @code{1.2} are @code{eql}.}\n"
"     @result{} (1.2 1.3)\n"
msgstr ""
"(memql 1.2 '(1.1 1.2 1.3))  ; @r{@code{1.2}と@code{1.2}は@code{eql}。}\n"
"     @result{} (1.2 1.3)\n"

#. type: group
#: original_texis/lists.texi:1365
#, fuzzy, no-wrap
#| msgid ""
#| "(memql 1.2 '(1.1 1.2 1.3))  ; @r{@code{1.2} and @code{1.2} are @code{eql}.}\n"
#| "     @result{} (1.2 1.3)\n"
msgid ""
"(memq 1.2 '(1.1 1.2 1.3))  ; @r{The two @code{1.2}s need not be @code{eq}.}\n"
"     @result{} @r{Unspecified; might be @code{nil} or @code{(1.2 1.3)}.}\n"
msgstr ""
"(memql 1.2 '(1.1 1.2 1.3))  ; @r{@code{1.2}と@code{1.2}は@code{eql}。}\n"
"     @result{} (1.2 1.3)\n"

#. type: Plain text
#: original_texis/lists.texi:1372
msgid "The following three functions are like @code{memq}, @code{delq} and @code{remq}, but use @code{equal} rather than @code{eq} to compare elements.  @xref{Equality Predicates}."
msgstr "以下の3つの関数は@code{memq}、@code{delq}、@code{remq}と似ていますが、要素の比較に@code{eq}ではなく@code{equal}を使用します。@ref{Equality Predicates}を参照してください。"

#. type: defun
#: original_texis/lists.texi:1373
#, no-wrap
msgid "member object list"
msgstr "member object list"

#. type: defun
#: original_texis/lists.texi:1378
msgid "The function @code{member} tests to see whether @var{object} is a member of @var{list}, comparing members with @var{object} using @code{equal}.  If @var{object} is a member, @code{member} returns a list starting with its first occurrence in @var{list}.  Otherwise, it returns @code{nil}."
msgstr "関数@code{member}は、メンバーと@var{object}を@code{equal}を使用して比較して、@var{object}が@var{list}のメンバーかどうかをテストする。@var{object}がメンバーなら、@code{member}は@var{list}で最初に見つかったところから開始されるリスト、それ以外なら@code{nil}をリターンする。"

#. type: group
#: original_texis/lists.texi:1385
#, no-wrap
msgid ""
"(member '(2) '((1) (2)))  ; @r{@code{(2)} and @code{(2)} are @code{equal}.}\n"
"     @result{} ((2))\n"
msgstr ""
"(member '(2) '((1) (2)))  ; @r{@code{(2)} and @code{(2)} are @code{equal}.}\n"
"     @result{} ((2))\n"

#. type: group
#: original_texis/lists.texi:1389
#, fuzzy, no-wrap
#| msgid ""
#| "(memq '(2) '((1) (2)))    ; @r{@code{(2)} and @code{(2)} are not @code{eq}.}\n"
#| "     @result{} nil\n"
msgid ""
"(memq '(2) '((1) (2)))    ; @r{The two @code{(2)}s need not be @code{eq}.}\n"
"     @result{} @r{Unspecified; might be @code{nil} or @code{(2)}.}\n"
msgstr ""
"(memq '(2) '((1) (2)))    ; @r{@code{(2)}と@code{(2)}は@code{eq}ではない。}\n"
"     @result{} nil\n"

#. type: group
#: original_texis/lists.texi:1394
#, no-wrap
msgid ""
";; @r{Two strings with the same contents are @code{equal}.}\n"
"(member \"foo\" '(\"foo\" \"bar\"))\n"
"     @result{} (\"foo\" \"bar\")\n"
msgstr ""
";; @r{同じ内容の2つの文字列は@code{equal}}\n"
"(member \"foo\" '(\"foo\" \"bar\"))\n"
"     @result{} (\"foo\" \"bar\")\n"

#. type: defun
#: original_texis/lists.texi:1398
#, no-wrap
msgid "delete object sequence"
msgstr "delete object sequence"

#. type: defun
#: original_texis/lists.texi:1401
msgid "This function removes all elements @code{equal} to @var{object} from @var{sequence}, and returns the resulting sequence."
msgstr "この関数は@var{sequence}から@var{object}と@code{equal}な要素を取り除いて、結果のシーケンスをリターンする。"

#. type: defun
#: original_texis/lists.texi:1408
msgid "If @var{sequence} is a list, @code{delete} is to @code{delq} as @code{member} is to @code{memq}: it uses @code{equal} to compare elements with @var{object}, like @code{member}; when it finds an element that matches, it cuts the element out just as @code{delq} would.  As with @code{delq}, you should typically use the return value by assigning it to the variable which held the original list."
msgstr "@var{sequence}がリストなら、@code{delete}が@code{delq}に対応するように、@code{member}は@code{memq}に対応する。つまりこの関数は@code{member}と同様、要素と@var{object}の比較に@code{equal}を使用する。マッチする要素が見つかったら、@code{delq}が行なうようにその要素を取り除く。@code{delq}と同様、通常は元のリストを保持していた変数にリターン値を割り当てて使用する。"

#. type: defun
#: original_texis/lists.texi:1412
msgid "If @code{sequence} is a vector or string, @code{delete} returns a copy of @code{sequence} with all elements @code{equal} to @code{object} removed."
msgstr "@code{sequence}がベクターか文字列なら、@code{delete}は@code{object}と@code{equal}なすべての要素を取り除いた@code{sequence}のコピーをリターンする。"

#. type: defun
#: original_texis/lists.texi:1414 original_texis/lists.texi:1661
msgid "For example:"
msgstr "たとえば:"

#. type: group
#: original_texis/lists.texi:1424
#, fuzzy, no-wrap
#| msgid ""
#| "(setq l '((2) (1) (2)))\n"
#| "(delete '(2) l)\n"
#| "     @result{} ((1))\n"
#| "l\n"
#| "     @result{} ((2) (1))\n"
#| ";; @r{If you want to change @code{l} reliably,}\n"
#| ";; @r{write @code{(setq l (delete '(2) l))}.}\n"
msgid ""
"(setq l (list '(2) '(1) '(2)))\n"
"(delete '(2) l)\n"
"     @result{} ((1))\n"
"l\n"
"     @result{} ((2) (1))\n"
";; @r{If you want to change @code{l} reliably,}\n"
";; @r{write @code{(setq l (delete '(2) l))}.}\n"
msgstr ""
"(setq l '((2) (1) (2)))\n"
"(delete '(2) l)\n"
"     @result{} ((1))\n"
"l\n"
"     @result{} ((2) (1))\n"
";; @r{@code{l}の変更に信頼性を要するときは}\n"
";; @r{@code{(setq l (delete '(2) l))}と記述する。}\n"

#. type: group
#: original_texis/lists.texi:1433
#, fuzzy, no-wrap
#| msgid ""
#| "(setq l '((2) (1) (2)))\n"
#| "(delete '(1) l)\n"
#| "     @result{} ((2) (2))\n"
#| "l\n"
#| "     @result{} ((2) (2))\n"
#| ";; @r{In this case, it makes no difference whether you set @code{l},}\n"
#| ";; @r{but you should do so for the sake of the other case.}\n"
msgid ""
"(setq l (list '(2) '(1) '(2)))\n"
"(delete '(1) l)\n"
"     @result{} ((2) (2))\n"
"l\n"
"     @result{} ((2) (2))\n"
";; @r{In this case, it makes no difference whether you set @code{l},}\n"
";; @r{but you should do so for the sake of the other case.}\n"
msgstr ""
"(setq l '((2) (1) (2)))\n"
"(delete '(1) l)\n"
"     @result{} ((2) (2))\n"
"l\n"
"     @result{} ((2) (2))\n"
";; @r{このケースでは@code{l}のセットの有無に違い}\n"
";; @r{はないが他のケースに倣ってセットするべき}\n"

#. type: group
#: original_texis/lists.texi:1437
#, no-wrap
msgid ""
"(delete '(2) [(2) (1) (2)])\n"
"     @result{} [(1)]\n"
msgstr ""
"(delete '(2) [(2) (1) (2)])\n"
"     @result{} [(1)]\n"

#. type: defun
#: original_texis/lists.texi:1441
#, no-wrap
msgid "remove object sequence"
msgstr "remove object sequence"

#. type: defun
#: original_texis/lists.texi:1445
msgid "This function is the non-destructive counterpart of @code{delete}.  It returns a copy of @code{sequence}, a list, vector, or string, with elements @code{equal} to @code{object} removed.  For example:"
msgstr "この関数は@code{delete}に対応する非破壊的な関数である。この関数は@code{object}と@code{equal}な要素を取り除いた、@code{sequence}(リスト、ベクター、文字列)のコピーをリターンする。たとえば:"

#. type: group
#: original_texis/lists.texi:1450
#, no-wrap
msgid ""
"(remove '(2) '((2) (1) (2)))\n"
"     @result{} ((1))\n"
msgstr ""
"(remove '(2) '((2) (1) (2)))\n"
"     @result{} ((1))\n"

#. type: group
#: original_texis/lists.texi:1454
#, no-wrap
msgid ""
"(remove '(2) [(2) (1) (2)])\n"
"     @result{} [(1)]\n"
msgstr ""
"(remove '(2) [(2) (1) (2)])\n"
"     @result{} [(1)]\n"

#. type: quotation
#: original_texis/lists.texi:1463
msgid "@b{Common Lisp note:} The functions @code{member}, @code{delete} and @code{remove} in GNU Emacs Lisp are derived from Maclisp, not Common Lisp.  The Common Lisp versions do not use @code{equal} to compare elements."
msgstr "@b{Common Lispに関する注意:} GNU Emacs Lispの関数@code{member}、@code{delete}、@code{remove}はCommon Lispではなく、Maclispを継承する。Common Lispでは比較に@code{equal}を使用しない。"

#. type: defun
#: original_texis/lists.texi:1465
#, no-wrap
msgid "member-ignore-case object list"
msgstr "member-ignore-case object list"

#. type: defun
#: original_texis/lists.texi:1471
msgid "This function is like @code{member}, except that @var{object} should be a string and that it ignores differences in letter-case and text representation: upper-case and lower-case letters are treated as equal, and unibyte strings are converted to multibyte prior to comparison."
msgstr "この関数は@code{member}と同様だが、@var{object}が文字列でcaseとテキスト表現の違いを無視する。文字の大文字と小文字は等しいものとして扱われ、比較に先立ちユニバイト文字列はマルチバイト文字列に変換される。"

#. type: defun
#: original_texis/lists.texi:1473
#, no-wrap
msgid "delete-dups list"
msgstr "delete-dups list"

#. type: defun
#: original_texis/lists.texi:1478
msgid "This function destructively removes all @code{equal} duplicates from @var{list}, stores the result in @var{list} and returns it.  Of several @code{equal} occurrences of an element in @var{list}, @code{delete-dups} keeps the first one."
msgstr "この関数は@var{list}からすべての@code{equal}な重複を破壊的に取り除いて、結果を@var{list}に保管してそれをリターンする。@var{list}内の要素に@code{equal}な要素がいくつかあるなら、@code{delete-dups}は最初の要素を残す。"

#. type: Plain text
#: original_texis/lists.texi:1483
msgid "See also the function @code{add-to-list}, in @ref{List Variables}, for a way to add an element to a list stored in a variable and used as a set."
msgstr "変数に格納されたリストへの要素の追加や、それを集合として使用する方法については、@ref{List Variables}の関数@code{add-to-list}も参照してください。"

#. type: cindex
#: original_texis/lists.texi:1486
#, no-wrap
msgid "association list"
msgstr "association list"

#. type: cindex
#: original_texis/lists.texi:1487
#, no-wrap
msgid "alist"
msgstr "alist"

#. type: Plain text
#: original_texis/lists.texi:1496
msgid "An @dfn{association list}, or @dfn{alist} for short, records a mapping from keys to values.  It is a list of cons cells called @dfn{associations}: the @sc{car} of each cons cell is the @dfn{key}, and the @sc{cdr} is the @dfn{associated value}.@footnote{This usage of ``key'' is not related to the term ``key sequence''; it means a value used to look up an item in a table.  In this case, the table is the alist, and the alist associations are the items.}"
msgstr "@dfn{連想配列(association list、短くはalist)}は、キーと値のマッピングを記録します。これは@dfn{連想(associations)}と呼ばれるコンスセルのリストです。各コンスセルにおいて@sc{car}は@dfn{キー(key)}で、@sc{cdr}は@dfn{連想値(associated value)}となります。@footnote{ここでの``キー(key)''の使い方は、用語``キーシーケンス(key sequence)''とは関係ありません。キーはテーブルにあるアイテムを探すために使用される値という意味です。この場合、テーブルはalistでありalistはアイテムに関連付けられます。}"

#. type: Plain text
#: original_texis/lists.texi:1500
msgid "Here is an example of an alist.  The key @code{pine} is associated with the value @code{cones}; the key @code{oak} is associated with @code{acorns}; and the key @code{maple} is associated with @code{seeds}."
msgstr "以下はalistの例です。キー@code{pine}は値@code{cones}、キー@code{oak}は@code{acorns}、キー@code{maple}は@code{seeds}に関連付けられます。"

#. type: group
#: original_texis/lists.texi:1506
#, no-wrap
msgid ""
"((pine . cones)\n"
" (oak . acorns)\n"
" (maple . seeds))\n"
msgstr ""
"((pine . cones)\n"
" (oak . acorns)\n"
" (maple . seeds))\n"

#. type: Plain text
#: original_texis/lists.texi:1514
msgid "Both the values and the keys in an alist may be any Lisp objects.  For example, in the following alist, the symbol @code{a} is associated with the number @code{1}, and the string @code{\"b\"} is associated with the @emph{list} @code{(2 3)}, which is the @sc{cdr} of the alist element:"
msgstr "alist内の値とキーには、任意のLispオブジェクトを指定できます。たとえば以下のalist0では、シンボル@code{a}は数字@code{1}、文字列@code{\"b\"}は@emph{リスト}@code{(2 3)}(alist要素の@sc{cdr})に関連付けられます。"

#. type: example
#: original_texis/lists.texi:1517
#, no-wrap
msgid "((a . 1) (\"b\" 2 3))\n"
msgstr "((a . 1) (\"b\" 2 3))\n"

#. type: Plain text
#: original_texis/lists.texi:1522
msgid "Sometimes it is better to design an alist to store the associated value in the @sc{car} of the @sc{cdr} of the element.  Here is an example of such an alist:"
msgstr "要素の@sc{cdr}の@sc{car}に連想値を格納するようにalistデザインするほうがよい場合があります。以下はそのようなalistです。"

#. type: example
#: original_texis/lists.texi:1525
#, no-wrap
msgid "((rose red) (lily white) (buttercup yellow))\n"
msgstr "((rose red) (lily white) (buttercup yellow))\n"

#. type: Plain text
#: original_texis/lists.texi:1535
msgid "Here we regard @code{red} as the value associated with @code{rose}.  One advantage of this kind of alist is that you can store other related information---even a list of other items---in the @sc{cdr} of the @sc{cdr}.  One disadvantage is that you cannot use @code{rassq} (see below) to find the element containing a given value.  When neither of these considerations is important, the choice is a matter of taste, as long as you are consistent about it for any given alist."
msgstr "この例では、@code{red}が@code{rose}に関連付けられる値だと考えます。この種のalistの利点は、@sc{cdr}の@sc{cdr}の中に他の関連する情報 --- 他のアイテムのリストでさえも --- を格納することができることです。不利な点は、与えられた値を含む要素を見つけるために@code{rassq}(以下参照)を使用できないことです。これらを検討することが重要でない場合には、すべての与えられたalistにたいして一貫している限り、選択は好みの問題といえます。"

#. type: Plain text
#: original_texis/lists.texi:1539
msgid "The same alist shown above could be regarded as having the associated value in the @sc{cdr} of the element; the value associated with @code{rose} would be the list @code{(red)}."
msgstr "上記で示したのと同じalistは、要素の@sc{cdr}に連想値をもつと考えることができます。この場合、@code{rose}に関連付けられる値はリスト@code{(red)}になるでしょう。"

#. type: Plain text
#: original_texis/lists.texi:1545
msgid "Association lists are often used to record information that you might otherwise keep on a stack, since new associations may be added easily to the front of the list.  When searching an association list for an association with a given key, the first one found is returned, if there is more than one."
msgstr "連想リストは新しい連想値を簡単にリストの先頭に追加できるので、スタックに保持したいような情報を記録するのによく使用されます。連想リストから与えられたキーにたいして連想値を検索する場合、それが複数ある場合は、最初に見つかったものがreturnされます。"

#. type: Plain text
#: original_texis/lists.texi:1550
msgid "In Emacs Lisp, it is @emph{not} an error if an element of an association list is not a cons cell.  The alist search functions simply ignore such elements.  Many other versions of Lisp signal errors in such cases."
msgstr "Emacs Lispでは、連想リストがコンスセルでなくても、それは@emph{エラーではありません}。alist検索関数は、単にそのような要素を無視します。多くの他のバージョンのLispでは、このような場合はエラーをシグナルします。"

#. type: Plain text
#: original_texis/lists.texi:1555
msgid "Note that property lists are similar to association lists in several respects.  A property list behaves like an association list in which each key can occur only once.  @xref{Property Lists}, for a comparison of property lists and association lists."
msgstr "いくつかの観点において、プロパティーリストは連想リストと似ていることに注意してください。それぞれのキーが一度だけ出現するような場合、プロパティーリストは連想リストと同様に振る舞います。プロパティーリストと連想リストの比較については、@ref{Property Lists}を参照してください。"

#. type: defun
#: original_texis/lists.texi:1556
#, no-wrap
msgid "assoc key alist &optional testfn"
msgstr "assoc key alist &optional testfn"

#. type: defun
#: original_texis/lists.texi:1563
msgid "This function returns the first association for @var{key} in @var{alist}, comparing @var{key} against the alist elements using @var{testfn} if it is non-@code{nil} and @code{equal} otherwise (@pxref{Equality Predicates}).  It returns @code{nil} if no association in @var{alist} has a @sc{car} equal to @var{key}.  For example:"
msgstr "この関数はalist要素にたいして非@code{nil}なら@var{testfn}、それ以外ならを使用して、@var{alist}内から@var{key}をもつ最初の連想をリターンする。@sc{car}が@var{key}と@code{equal}であるような連想値が@var{alist}になければ、この関数は@code{nil}をリターンする。たとえば:"

#. type: smallexample
#: original_texis/lists.texi:1573
#, no-wrap
msgid ""
"(setq trees '((pine . cones) (oak . acorns) (maple . seeds)))\n"
"     @result{} ((pine . cones) (oak . acorns) (maple . seeds))\n"
"(assoc 'oak trees)\n"
"     @result{} (oak . acorns)\n"
"(cdr (assoc 'oak trees))\n"
"     @result{} acorns\n"
"(assoc 'birch trees)\n"
"     @result{} nil\n"
msgstr ""
"(setq trees '((pine . cones) (oak . acorns) (maple . seeds)))\n"
"     @result{} ((pine . cones) (oak . acorns) (maple . seeds))\n"
"(assoc 'oak trees)\n"
"     @result{} (oak . acorns)\n"
"(cdr (assoc 'oak trees))\n"
"     @result{} acorns\n"
"(assoc 'birch trees)\n"
"     @result{} nil\n"

#. type: defun
#: original_texis/lists.texi:1576
msgid "Here is another example, in which the keys and values are not symbols:"
msgstr "以下はキーと値がシンボルでない場合の例である:"

#. type: smallexample
#: original_texis/lists.texi:1582
#, no-wrap
msgid ""
"(setq needles-per-cluster\n"
"      '((2 \"Austrian Pine\" \"Red Pine\")\n"
"        (3 \"Pitch Pine\")\n"
"        (5 \"White Pine\")))\n"
"\n"
msgstr ""
"(setq needles-per-cluster\n"
"      '((2 \"Austrian Pine\" \"Red Pine\")\n"
"        (3 \"Pitch Pine\")\n"
"        (5 \"White Pine\")))\n"
"\n"

#. type: smallexample
#: original_texis/lists.texi:1587
#, no-wrap
msgid ""
"(cdr (assoc 3 needles-per-cluster))\n"
"     @result{} (\"Pitch Pine\")\n"
"(cdr (assoc 2 needles-per-cluster))\n"
"     @result{} (\"Austrian Pine\" \"Red Pine\")\n"
msgstr ""
"(cdr (assoc 3 needles-per-cluster))\n"
"     @result{} (\"Pitch Pine\")\n"
"(cdr (assoc 2 needles-per-cluster))\n"
"     @result{} (\"Austrian Pine\" \"Red Pine\")\n"

#. type: Plain text
#: original_texis/lists.texi:1593
msgid "The function @code{assoc-string} is much like @code{assoc} except that it ignores certain differences between strings.  @xref{Text Comparison}."
msgstr "関数@code{assoc-string}は@code{assoc}と似ていますが、文字列間の特定の違いを無視する点が異なります。@ref{Text Comparison}を参照してください。"

#. type: defun
#: original_texis/lists.texi:1594
#, no-wrap
msgid "rassoc value alist"
msgstr "rassoc value alist"

#. type: defun
#: original_texis/lists.texi:1598
msgid "This function returns the first association with value @var{value} in @var{alist}.  It returns @code{nil} if no association in @var{alist} has a @sc{cdr} @code{equal} to @var{value}."
msgstr "この関数は@var{alist}の中から値@var{value}をもつ最初の連想をリターンする。@sc{cdr}が@var{value}と@code{equal}であるような連想値が@var{alist}になければ、この関数は@code{nil}をリターンする。"

#. type: defun
#: original_texis/lists.texi:1602
msgid "@code{rassoc} is like @code{assoc} except that it compares the @sc{cdr} of each @var{alist} association instead of the @sc{car}.  You can think of this as reverse @code{assoc}, finding the key for a given value."
msgstr "@code{rassoc}は@code{assoc}と似てイルが、@sc{car}ではなく@var{alist}の連想値の@sc{cdr}を比較する。この関数は与えられた値に対応するキーを探す、@code{assoc}の逆バージョンと考えることができよう。"

#. type: defun
#: original_texis/lists.texi:1604
#, no-wrap
msgid "assq key alist"
msgstr "assq key alist"

#. type: defun
#: original_texis/lists.texi:1612
msgid "This function is like @code{assoc} in that it returns the first association for @var{key} in @var{alist}, but it makes the comparison using @code{eq}.  @code{assq} returns @code{nil} if no association in @var{alist} has a @sc{car} @code{eq} to @var{key}.  This function is used more often than @code{assoc}, since @code{eq} is faster than @code{equal} and most alists use symbols as keys.  @xref{Equality Predicates}."
msgstr "この関数は@var{alist}から@var{key}をもつ最初の連想値をリターンする点は@code{assoc}と同様だが、比較に@code{eq}を使用する点が異なる。@sc{car}が@var{key}と@code{eq}であるような連想値が@var{alist}内に存在しなければ@code{assq}は@code{nil}をリターンする。@code{eq}は@code{equal}より高速であり、ほとんどのalistはキーにシンボルを使用するので、この関数は@code{assoc}より多用される。@ref{Equality Predicates}を参照のこと。"

#. type: smallexample
#: original_texis/lists.texi:1618
#, no-wrap
msgid ""
"(setq trees '((pine . cones) (oak . acorns) (maple . seeds)))\n"
"     @result{} ((pine . cones) (oak . acorns) (maple . seeds))\n"
"(assq 'pine trees)\n"
"     @result{} (pine . cones)\n"
msgstr ""
"(setq trees '((pine . cones) (oak . acorns) (maple . seeds)))\n"
"     @result{} ((pine . cones) (oak . acorns) (maple . seeds))\n"
"(assq 'pine trees)\n"
"     @result{} (pine . cones)\n"

#. type: defun
#: original_texis/lists.texi:1622
msgid "On the other hand, @code{assq} is not usually useful in alists where the keys may not be symbols:"
msgstr "逆にキーがシンボルではないalistでは、通常は@code{assq}は有用ではない:"

#. type: smallexample
#: original_texis/lists.texi:1627
#, no-wrap
msgid ""
"(setq leaves\n"
"      '((\"simple leaves\" . oak)\n"
"        (\"compound leaves\" . horsechestnut)))\n"
"\n"
msgstr ""
"(setq leaves\n"
"      '((\"simple leaves\" . oak)\n"
"        (\"compound leaves\" . horsechestnut)))\n"
"\n"

#. type: smallexample
#: original_texis/lists.texi:1632
#, fuzzy, no-wrap
#| msgid ""
#| "(assq \"simple leaves\" leaves)\n"
#| "     @result{} nil\n"
#| "(assoc \"simple leaves\" leaves)\n"
#| "     @result{} (\"simple leaves\" . oak)\n"
msgid ""
"(assq \"simple leaves\" leaves)\n"
"     @result{} @r{Unspecified; might be @code{nil} or @code{(\"simple leaves\" . oak)}.}\n"
"(assoc \"simple leaves\" leaves)\n"
"     @result{} (\"simple leaves\" . oak)\n"
msgstr ""
"(assq \"simple leaves\" leaves)\n"
"     @result{} nil\n"
"(assoc \"simple leaves\" leaves)\n"
"     @result{} (\"simple leaves\" . oak)\n"

#. type: defun
#: original_texis/lists.texi:1635
#, no-wrap
msgid "alist-get key alist &optional default remove testfn"
msgstr "alist-get key alist &optional default remove testfn"

#. type: defun
#: original_texis/lists.texi:1643
msgid "This function is similar to @code{assq}.  It finds the first association @w{@code{(@var{key} . @var{value})}} by comparing @var{key} with @var{alist} elements, and, if found, returns the @var{value} of that association.  If no association is found, the function returns @var{default}.  Comparison of @var{key} against @var{alist} elements uses the function specified by @var{testfn}, defaulting to @code{eq}."
msgstr "この関数は@code{assq}と似ている。これは@var{alist}の要素の@var{key}を比較して最初の連想@w{@code{(@var{key} . @var{value})}}を見つける。連想が見つからなければ、関数は@var{default}をリターンする。@var{alist}にたいする@var{key}の比較には@var{testfn}で指定された関数を使用する(デフォルトは@code{eq})。"

#. type: defun
#: original_texis/lists.texi:1649
msgid "This is a generalized variable (@pxref{Generalized Variables})  that can be used to change a value with @code{setf}.  When using it to set a value, optional argument @var{remove} non-@code{nil} means to remove @var{key}'s association from @var{alist} if the new value is @code{eql} to @var{default}."
msgstr "これは@code{setf}での値の変更に使用できる汎変数(@ref{Generalized Variables}を参照)。値の値へのセットにこれを使用する際にオプション引数@var{remove}が@code{nil}の場合は、新たな値が@var{default}と@code{eql}なら@var{alist}から@var{key}の連想を削除することを意味する。"

#. type: defun
#: original_texis/lists.texi:1651
#, no-wrap
msgid "rassq value alist"
msgstr "rassq value alist"

#. type: defun
#: original_texis/lists.texi:1655
msgid "This function returns the first association with value @var{value} in @var{alist}.  It returns @code{nil} if no association in @var{alist} has a @sc{cdr} @code{eq} to @var{value}."
msgstr "この関数は、@var{alist}内から値@var{value}をもつ最初の連想値をリターンする。@var{alist}内に@sc{cdr}が@var{value}と@code{eq}であるような連想値が存在しないなら@code{nil}をリターンする。"

#. type: defun
#: original_texis/lists.texi:1659
msgid "@code{rassq} is like @code{assq} except that it compares the @sc{cdr} of each @var{alist} association instead of the @sc{car}.  You can think of this as reverse @code{assq}, finding the key for a given value."
msgstr "@code{rassq}は@code{assq}と似ていますが、@sc{car}ではなく@var{alist}の各連想の@sc{cdr}を比較します。この関数を、与えられた値に対応するキーを探す@code{assq}の逆バージョンと考えることができます。"

#. type: smallexample
#: original_texis/lists.texi:1664
#, no-wrap
msgid ""
"(setq trees '((pine . cones) (oak . acorns) (maple . seeds)))\n"
"\n"
msgstr ""
"(setq trees '((pine . cones) (oak . acorns) (maple . seeds)))\n"
"\n"

#. type: smallexample
#: original_texis/lists.texi:1669
#, no-wrap
msgid ""
"(rassq 'acorns trees)\n"
"     @result{} (oak . acorns)\n"
"(rassq 'spores trees)\n"
"     @result{} nil\n"
msgstr ""
"(rassq 'acorns trees)\n"
"     @result{} (oak . acorns)\n"
"(rassq 'spores trees)\n"
"     @result{} nil\n"

#. type: defun
#: original_texis/lists.texi:1673
msgid "@code{rassq} cannot search for a value stored in the @sc{car} of the @sc{cdr} of an element:"
msgstr "@code{rassq}は要素の@sc{cdr}の@sc{car}に保管された値の検索はできません:"

#. type: smallexample
#: original_texis/lists.texi:1676
#, no-wrap
msgid ""
"(setq colors '((rose red) (lily white) (buttercup yellow)))\n"
"\n"
msgstr ""
"(setq colors '((rose red) (lily white) (buttercup yellow)))\n"
"\n"

#. type: smallexample
#: original_texis/lists.texi:1679
#, no-wrap
msgid ""
"(rassq 'white colors)\n"
"     @result{} nil\n"
msgstr ""
"(rassq 'white colors)\n"
"     @result{} nil\n"

#. type: defun
#: original_texis/lists.texi:1684
msgid "In this case, the @sc{cdr} of the association @code{(lily white)} is not the symbol @code{white}, but rather the list @code{(white)}.  This becomes clearer if the association is written in dotted pair notation:"
msgstr "この場合、連想@code{(lily white)}の@sc{cdr}は@code{white}ではなくリスト@code{(white)}です。これは連想をドットペア表記で記述すると明確になります:"

#. type: smallexample
#: original_texis/lists.texi:1687
#, no-wrap
msgid "(lily white) @equiv{} (lily . (white))\n"
msgstr "(lily white) @equiv{} (lily . (white))\n"

#. type: defun
#: original_texis/lists.texi:1690
#, no-wrap
msgid "assoc-default key alist &optional test default"
msgstr "assoc-default key alist &optional test default"

#. type: defun
#: original_texis/lists.texi:1699
msgid "This function searches @var{alist} for a match for @var{key}.  For each element of @var{alist}, it compares the element (if it is an atom) or the element's @sc{car} (if it is a cons) against @var{key}, by calling @var{test} with two arguments: the element or its @sc{car}, and @var{key}.  The arguments are passed in that order so that you can get useful results using @code{string-match} with an alist that contains regular expressions (@pxref{Regexp Search}).  If @var{test} is omitted or @code{nil}, @code{equal} is used for comparison."
msgstr "この関数は、@var{key}にたいするマッチを@var{alist}から検索する。@var{alist}の各要素にたいして、この関数は@var{key}と要素(アトムの場合)、または要素の@sc{car}(コンスの場合)を比較する。比較は@var{test}に2つの引数 --- 要素(か要素の@sc{car})と@var{key} --- を与えて呼び出すことにより行なわれる。引数はこの順番で渡されるので、正規表現(@ref{Regexp Search}を参照)を含むalistでは、@code{string-match}を使用することにより有益な結果を得ることができる。@var{test}が省略または@code{nil}なら比較に@code{equal}が使用される。"

#. type: defun
#: original_texis/lists.texi:1704
msgid "If an alist element matches @var{key} by this criterion, then @code{assoc-default} returns a value based on this element.  If the element is a cons, then the value is the element's @sc{cdr}.  Otherwise, the return value is @var{default}."
msgstr "alistの要素がこの条件により@var{key}とマッチすると、@code{assoc-default}はその要素の値をリターンする。要素がコンスなら値は要素の@sc{cdr}、それ以外ならリターン値は@var{default}となる。"

#. type: defun
#: original_texis/lists.texi:1707
msgid "If no alist element matches @var{key}, @code{assoc-default} returns @code{nil}."
msgstr "@var{key}にマッチする要素がalistに存在しないければ、@code{assoc-default}は@code{nil}をリターンする。"

#. type: defun
#: original_texis/lists.texi:1709
#, no-wrap
msgid "copy-alist alist"
msgstr "copy-alist alist"

#. type: cindex
#: original_texis/lists.texi:1710
#, no-wrap
msgid "copying alists"
msgstr "copying alists"

#. type: defun
#: original_texis/lists.texi:1714
msgid "This function returns a two-level deep copy of @var{alist}: it creates a new copy of each association, so that you can alter the associations of the new alist without changing the old one."
msgstr "この関数は深さのレベルが2の@var{alist}のコピーをリターンする。この関数は各連想の新しいコピーを作成するので、元のalistを変更せずに新しいalistを変更できる。"

#. type: group
#: original_texis/lists.texi:1720
#, no-wrap
msgid ""
"(setq needles-per-cluster\n"
"      '((2 . (\"Austrian Pine\" \"Red Pine\"))\n"
"        (3 . (\"Pitch Pine\"))\n"
msgstr ""
"(setq needles-per-cluster\n"
"      '((2 . (\"Austrian Pine\" \"Red Pine\"))\n"
"        (3 . (\"Pitch Pine\"))\n"

#. type: smallexample
#: original_texis/lists.texi:1726
#, no-wrap
msgid ""
"        (5 . (\"White Pine\"))))\n"
"@result{}\n"
"((2 \"Austrian Pine\" \"Red Pine\")\n"
" (3 \"Pitch Pine\")\n"
" (5 \"White Pine\"))\n"
"\n"
msgstr ""
"        (5 . (\"White Pine\"))))\n"
"@result{}\n"
"((2 \"Austrian Pine\" \"Red Pine\")\n"
" (3 \"Pitch Pine\")\n"
" (5 \"White Pine\"))\n"
"\n"

#. type: smallexample
#: original_texis/lists.texi:1732
#, no-wrap
msgid ""
"(setq copy (copy-alist needles-per-cluster))\n"
"@result{}\n"
"((2 \"Austrian Pine\" \"Red Pine\")\n"
" (3 \"Pitch Pine\")\n"
" (5 \"White Pine\"))\n"
"\n"
msgstr ""
"(setq copy (copy-alist needles-per-cluster))\n"
"@result{}\n"
"((2 \"Austrian Pine\" \"Red Pine\")\n"
" (3 \"Pitch Pine\")\n"
" (5 \"White Pine\"))\n"
"\n"

#. type: smallexample
#: original_texis/lists.texi:1741
#, no-wrap
msgid ""
"(eq needles-per-cluster copy)\n"
"     @result{} nil\n"
"(equal needles-per-cluster copy)\n"
"     @result{} t\n"
"(eq (car needles-per-cluster) (car copy))\n"
"     @result{} nil\n"
"(cdr (car (cdr needles-per-cluster)))\n"
"     @result{} (\"Pitch Pine\")\n"
msgstr ""
"(eq needles-per-cluster copy)\n"
"     @result{} nil\n"
"(equal needles-per-cluster copy)\n"
"     @result{} t\n"
"(eq (car needles-per-cluster) (car copy))\n"
"     @result{} nil\n"
"(cdr (car (cdr needles-per-cluster)))\n"
"     @result{} (\"Pitch Pine\")\n"

#. type: group
#: original_texis/lists.texi:1745
#, no-wrap
msgid ""
"(eq (cdr (car (cdr needles-per-cluster)))\n"
"    (cdr (car (cdr copy))))\n"
"     @result{} t\n"
msgstr ""
"(eq (cdr (car (cdr needles-per-cluster)))\n"
"    (cdr (car (cdr copy))))\n"
"     @result{} t\n"

#. type: defun
#: original_texis/lists.texi:1750
msgid "This example shows how @code{copy-alist} makes it possible to change the associations of one copy without affecting the other:"
msgstr "以下の例は、どのようにして@code{copy-alist}が他に影響を与えずにコピーの連想を変更可能なのかを示す:"

#. type: group
#: original_texis/lists.texi:1756
#, no-wrap
msgid ""
"(setcdr (assq 3 copy) '(\"Martian Vacuum Pine\"))\n"
"(cdr (assq 3 needles-per-cluster))\n"
"     @result{} (\"Pitch Pine\")\n"
msgstr ""
"(setcdr (assq 3 copy) '(\"Martian Vacuum Pine\"))\n"
"(cdr (assq 3 needles-per-cluster))\n"
"     @result{} (\"Pitch Pine\")\n"

#. type: defun
#: original_texis/lists.texi:1760
#, no-wrap
msgid "assq-delete-all key alist"
msgstr "assq-delete-all key alist"

#. type: defun
#: original_texis/lists.texi:1767
msgid "This function deletes from @var{alist} all the elements whose @sc{car} is @code{eq} to @var{key}, much as if you used @code{delq} to delete each such element one by one.  It returns the shortened alist, and often modifies the original list structure of @var{alist}.  For correct results, use the return value of @code{assq-delete-all} rather than looking at the saved value of @var{alist}."
msgstr "この関数は、@code{delq}を使用してマッチする要素を1つずつ削除するときのように、@sc{car}が@var{key}と@code{eq}であるようなすべての要素を@var{alist}から削除する。この関数は短くなったalistをリターンし、@var{alist}の元のリスト構造を変更することもよくある。正しい結果を得るために、@var{alist}に保存された値ではなく@code{assq-delete-all}のリターン値を使用すること。"

#. type: example
#: original_texis/lists.texi:1775
#, fuzzy, no-wrap
#| msgid ""
#| "(setq alist '((foo 1) (bar 2) (foo 3) (lose 4)))\n"
#| "     @result{} ((foo 1) (bar 2) (foo 3) (lose 4))\n"
#| "(assq-delete-all 'foo alist)\n"
#| "     @result{} ((bar 2) (lose 4))\n"
#| "alist\n"
#| "     @result{} ((foo 1) (bar 2) (lose 4))\n"
msgid ""
"(setq alist (list '(foo 1) '(bar 2) '(foo 3) '(lose 4)))\n"
"     @result{} ((foo 1) (bar 2) (foo 3) (lose 4))\n"
"(assq-delete-all 'foo alist)\n"
"     @result{} ((bar 2) (lose 4))\n"
"alist\n"
"     @result{} ((foo 1) (bar 2) (lose 4))\n"
msgstr ""
"(setq alist '((foo 1) (bar 2) (foo 3) (lose 4)))\n"
"     @result{} ((foo 1) (bar 2) (foo 3) (lose 4))\n"
"(assq-delete-all 'foo alist)\n"
"     @result{} ((bar 2) (lose 4))\n"
"alist\n"
"     @result{} ((foo 1) (bar 2) (lose 4))\n"

#. type: defun
#: original_texis/lists.texi:1778
#, fuzzy, no-wrap
#| msgid "assoc key alist &optional testfn"
msgid "assoc-delete-all key alist &optional test"
msgstr "assoc key alist &optional testfn"

#. type: defun
#: original_texis/lists.texi:1784
msgid "This function is like @code{assq-delete-all} except that it accepts an optional argument @var{test}, a predicate function to compare the keys in @var{alist}.  If omitted or @code{nil}, @var{test} defaults to @code{equal}.  As @code{assq-delete-all}, this function often modifies the original list structure of @var{alist}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1786
#, no-wrap
msgid "rassq-delete-all value alist"
msgstr "rassq-delete-all value alist"

#. type: defun
#: original_texis/lists.texi:1793
msgid "This function deletes from @var{alist} all the elements whose @sc{cdr} is @code{eq} to @var{value}.  It returns the shortened alist, and often modifies the original list structure of @var{alist}.  @code{rassq-delete-all} is like @code{assq-delete-all} except that it compares the @sc{cdr} of each @var{alist} association instead of the @sc{car}."
msgstr "この関数は、@var{alist}から@sc{cdr}が@var{value}と@code{eq}であるようなすべての要素を削除する。この関数は短くなったリストをリターンし、@var{alist}の元のリスト構造を変更することもよくある。@code{rassq-delete-all}は@code{assq-delete-all}と似ているが、@sc{car}ではなく@var{alist}の各連想の@sc{cdr}を比較する。"

#. type: defmac
#: original_texis/lists.texi:1795
#, fuzzy, no-wrap
#| msgid "copy-alist alist"
msgid "let-alist alist body"
msgstr "copy-alist alist"

#. type: defmac
#: original_texis/lists.texi:1800
msgid "Creates a binding for each symbol used as keys the association list @var{alist}, prefixed with dot.  This can be useful when accessing several items in the same association list, and it's best understood through a simple example:"
msgstr ""

#. type: lisp
#: original_texis/lists.texi:1807
#, fuzzy, no-wrap
#| msgid ""
#| "(setq colors '((rose red) (lily white) (buttercup yellow)))\n"
#| "\n"
msgid ""
"(setq colors '((rose . red) (lily . white) (buttercup . yellow)))\n"
"(let-alist colors\n"
"  (if (eq .rose 'red)\n"
"      .lily))\n"
"=> white\n"
msgstr ""
"(setq colors '((rose red) (lily white) (buttercup yellow)))\n"
"\n"

#. type: defmac
#: original_texis/lists.texi:1814
msgid "The @var{body} is inspected at compilation time, and only the symbols that appear in @var{body} with a @samp{.} as the first character in the symbol name will be bound.  Finding the keys is done with @code{assq}, and the @code{cdr} of the return value of this @code{assq} is assigned as the value for the binding."
msgstr ""

#. type: defmac
#: original_texis/lists.texi:1816
msgid "Nested association lists is supported:"
msgstr ""

#. type: lisp
#: original_texis/lists.texi:1823
#, no-wrap
msgid ""
"(setq colors '((rose . red) (lily (belladonna . yellow) (brindisi . pink))))\n"
"(let-alist colors\n"
"  (if (eq .rose 'red)\n"
"      .lily.belladonna))\n"
"=> yellow\n"
msgstr ""

#. type: defmac
#: original_texis/lists.texi:1828
msgid "Nesting @code{let-alist} inside each other is allowed, but the code in the inner @code{let-alist} can't access the variables bound by the outer @code{let-alist}."
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1832
#, no-wrap
msgid "property list"
msgstr "property list"

#. type: cindex
#: original_texis/lists.texi:1833
#, no-wrap
msgid "plist"
msgstr "plist"

#. type: Plain text
#: original_texis/lists.texi:1839
msgid "A @dfn{property list} (@dfn{plist} for short) is a list of paired elements.  Each of the pairs associates a property name (usually a symbol) with a property or value.  Here is an example of a property list:"
msgstr "@dfn{プロパティーリスト(property list、短くはplist)}は、ペアになった要素のリストです。各ペアはプロパティー名(通常はシンボル)とプロパティー値を対応づけます。以下はプロパティーリストの例です:"

#. type: example
#: original_texis/lists.texi:1842
#, no-wrap
msgid "(pine cones numbers (1 2 3) color \"blue\")\n"
msgstr "(pine cones numbers (1 2 3) color \"blue\")\n"

#. type: Plain text
#: original_texis/lists.texi:1849
msgid "This property list associates @code{pine} with @code{cones}, @code{numbers} with @code{(1 2 3)}, and @code{color} with @code{\"blue\"}.  The property names and values can be any Lisp objects, but the names are usually symbols (as they are in this example)."
msgstr "このプロパティーリストは@code{pine}を@code{cones}、@code{numbers}を@code{(1 2 3)}、@code{color}を@code{\"blue\"}に関連づけます。プロパティー名とプロパティー値には任意のLispオブジェクトを指定できますが、通常プロパティー名は(この例のように)シンボルです。"

#. type: Plain text
#: original_texis/lists.texi:1855
msgid "Property lists are used in several contexts.  For instance, the function @code{put-text-property} takes an argument which is a property list, specifying text properties and associated values which are to be applied to text in a string or buffer.  @xref{Text Properties}."
msgstr "いくつかのコンテキストでプロパティーリストが使用されます。たとえば関数@code{put-text-property}はプロパティーリストを引数にとり、文字列やバッファー内のテキストにたいして、テキストプロパティーとテキストに適用するプロパティー値を指定します。@ref{Text Properties}を参照してください。"

#. type: Plain text
#: original_texis/lists.texi:1860
msgid "Another prominent use of property lists is for storing symbol properties.  Every symbol possesses a list of properties, used to record miscellaneous information about the symbol; these properties are stored in the form of a property list.  @xref{Symbol Properties}."
msgstr "プロパティーリストが頻繁に使用される他の例は、シンボルプロパティーの保管です。すべてのシンボルはシンボルに関する様々な情報を記録するために、プロパティーのリストを処理します。これらのプロパティーはプロパティーリストの形式で保管されます。@ref{Symbol Properties}を参照してください。"

#. type: node
#: original_texis/lists.texi:1865 original_texis/lists.texi:1867
#, no-wrap
msgid "Plists and Alists"
msgstr "Plists and Alists"

#. type: menuentry
#: original_texis/lists.texi:1865
msgid "Comparison of the advantages of property lists and association lists."
msgstr "プロパティーリストと連想リストの利点の比較。"

#. type: node
#: original_texis/lists.texi:1865 original_texis/lists.texi:1902
#, no-wrap
msgid "Plist Access"
msgstr "Plist Access"

#. type: menuentry
#: original_texis/lists.texi:1865
msgid "Accessing property lists stored elsewhere."
msgstr "他の場所に保管されたプロパティーリストへのアクセス。"

#. type: subsection
#: original_texis/lists.texi:1868
#, no-wrap
msgid "Property Lists and Association Lists"
msgstr "Property Lists and Association Lists"

#. type: cindex
#: original_texis/lists.texi:1869
#, no-wrap
msgid "plist vs. alist"
msgstr "plist vs. alist"

#. type: cindex
#: original_texis/lists.texi:1870
#, no-wrap
msgid "alist vs. plist"
msgstr "alist vs. plist"

#. type: cindex
#: original_texis/lists.texi:1872
#, no-wrap
msgid "property lists vs association lists"
msgstr "property lists vs association lists"

#. type: Plain text
#: original_texis/lists.texi:1877
msgid "Association lists (@pxref{Association Lists}) are very similar to property lists.  In contrast to association lists, the order of the pairs in the property list is not significant, since the property names must be distinct."
msgstr "連想リスト(@ref{Association Lists}を参照)は、プロパティーリストとよく似ています。連想リストとは対照的にプロパティー名は一意でなければならないので、プロパティーリスト内でペアの順序に意味はありません。"

#. type: Plain text
#: original_texis/lists.texi:1890
msgid "Property lists are better than association lists for attaching information to various Lisp function names or variables.  If your program keeps all such information in one association list, it will typically need to search that entire list each time it checks for an association for a particular Lisp function name or variable, which could be slow.  By contrast, if you keep the same information in the property lists of the function names or variables themselves, each search will scan only the length of one property list, which is usually short.  This is why the documentation for a variable is recorded in a property named @code{variable-documentation}.  The byte compiler likewise uses properties to record those functions needing special treatment."
msgstr "様々なLisp関数や変数に情報を付加するためには、連想リストよりプロパティーリストの方が適しています。プログラムでこのような情報すべてを1つの連想リストに保持する場合は、特定のLisp関数や変数にたいする連想をチェックする度にリスト全体を検索する必要が生じ、それにより遅くなる可能性があります。対照的に関数名や変数自体のプロパティーリストに同じ情報を保持すれば、検索ごとにそのプロパティーリストの長さだけを検索するようになり、通常はこちらの方が短時間で済みます。変数のドキュメントが@code{variable-documentation}という名前のプロパティーに記録されているのはこれが理由です。同様にバイトコンパイラーも、特別に扱う必要がある関数を記録するためにプロパティーを使用します。"

#. type: Plain text
#: original_texis/lists.texi:1901
msgid "However, association lists have their own advantages.  Depending on your application, it may be faster to add an association to the front of an association list than to update a property.  All properties for a symbol are stored in the same property list, so there is a possibility of a conflict between different uses of a property name.  (For this reason, it is a good idea to choose property names that are probably unique, such as by beginning the property name with the program's usual name-prefix for variables and functions.)  An association list may be used like a stack where associations are pushed on the front of the list and later discarded; this is not possible with a property list."
msgstr "とはいえ連想リストにも独自の利点があります。アプリケーションに依存しますが、プロパティーを更新するより連想リストの先頭に連想を追加する方が高速でしょう。シンボルにたいするすべてのプロパティーは同じプロパティーリストに保管されるので、プロパティー名を異なる用途のために使用すると衝突の可能性があります(この理由により、そのプログラムで通常の変数や関数の名前につけるプレフィクスをプロパティー名の先頭につけて、一意と思われるプロパティー名を選ぶのはよいアイデアだと言える)。連想リストは、連想をリストの先頭にpushして、その後にある連想は無視されるので、スタックと同様に使用できます。これはプロパティーリストでは不可能です。"

#. type: subsection
#: original_texis/lists.texi:1903
#, no-wrap
msgid "Property Lists Outside Symbols"
msgstr "Property Lists Outside Symbols"

#. type: cindex
#: original_texis/lists.texi:1904
#, no-wrap
msgid "plist access"
msgstr "plist access"

#. type: cindex
#: original_texis/lists.texi:1905
#, no-wrap
msgid "accessing plist properties"
msgstr "accessing plist properties"

#. type: Plain text
#: original_texis/lists.texi:1909
msgid "The following functions can be used to manipulate property lists.  They all compare property names using @code{eq}."
msgstr "以下の関数はプロパティーリストを操作するために使用されます。これらの関数はすべて、プロパティー名の比較に@code{eq}を使用します。"

#. type: defun
#: original_texis/lists.texi:1910
#, no-wrap
msgid "plist-get plist property"
msgstr "plist-get plist property"

#. type: defun
#: original_texis/lists.texi:1915
msgid "This returns the value of the @var{property} property stored in the property list @var{plist}.  It accepts a malformed @var{plist} argument.  If @var{property} is not found in the @var{plist}, it returns @code{nil}.  For example,"
msgstr "この関数はプロパティーリスト@var{plist}に保管された、プロパティー@var{property}の値をリターンする。この関数には不正な形式(malformed)の@var{plist}引数を指定できる。@var{plist}で@var{property}が見つからないと、この関数は@code{nil}をリターンする。たとえば、"

#. type: example
#: original_texis/lists.texi:1925
#, no-wrap
msgid ""
"(plist-get '(foo 4) 'foo)\n"
"     @result{} 4\n"
"(plist-get '(foo 4 bad) 'foo)\n"
"     @result{} 4\n"
"(plist-get '(foo 4 bad) 'bad)\n"
"     @result{} nil\n"
"(plist-get '(foo 4 bad) 'bar)\n"
"     @result{} nil\n"
msgstr ""
"(plist-get '(foo 4) 'foo)\n"
"     @result{} 4\n"
"(plist-get '(foo 4 bad) 'foo)\n"
"     @result{} 4\n"
"(plist-get '(foo 4 bad) 'bad)\n"
"     @result{} nil\n"
"(plist-get '(foo 4 bad) 'bar)\n"
"     @result{} nil\n"

#. type: defun
#: original_texis/lists.texi:1928
#, no-wrap
msgid "plist-put plist property value"
msgstr "plist-put plist property value"

#. type: defun
#: original_texis/lists.texi:1934
msgid "This stores @var{value} as the value of the @var{property} property in the property list @var{plist}.  It may modify @var{plist} destructively, or it may construct a new list structure without altering the old.  The function returns the modified property list, so you can store that back in the place where you got @var{plist}.  For example,"
msgstr "この関数はプロパティーリスト@var{plist}に、プロパティー@var{property}の値として@var{value}を保管する。この関数は@var{plist}を破壊的に変更するかもしれず、元のリスト構造を変更せずに新しいリストを構築することもある。この関数は変更されたプロパティーリストをリターンするので、@var{plist}を取得した場所に書き戻すことができる。たとえば、"

#. type: example
#: original_texis/lists.texi:1942
#, fuzzy, no-wrap
#| msgid ""
#| "(setq my-plist '(bar t foo 4))\n"
#| "     @result{} (bar t foo 4)\n"
#| "(setq my-plist (plist-put my-plist 'foo 69))\n"
#| "     @result{} (bar t foo 69)\n"
#| "(setq my-plist (plist-put my-plist 'quux '(a)))\n"
#| "     @result{} (bar t foo 69 quux (a))\n"
msgid ""
"(setq my-plist (list 'bar t 'foo 4))\n"
"     @result{} (bar t foo 4)\n"
"(setq my-plist (plist-put my-plist 'foo 69))\n"
"     @result{} (bar t foo 69)\n"
"(setq my-plist (plist-put my-plist 'quux '(a)))\n"
"     @result{} (bar t foo 69 quux (a))\n"
msgstr ""
"(setq my-plist '(bar t foo 4))\n"
"     @result{} (bar t foo 4)\n"
"(setq my-plist (plist-put my-plist 'foo 69))\n"
"     @result{} (bar t foo 69)\n"
"(setq my-plist (plist-put my-plist 'quux '(a)))\n"
"     @result{} (bar t foo 69 quux (a))\n"

#. type: defun
#: original_texis/lists.texi:1945
#, no-wrap
msgid "lax-plist-get plist property"
msgstr "lax-plist-get plist property"

#. type: defun
#: original_texis/lists.texi:1948
msgid "Like @code{plist-get} except that it compares properties using @code{equal} instead of @code{eq}."
msgstr "@code{plist-get}と同様だがプロパティーの比較に@code{eq}ではなく@code{equal}を使用する。"

#. type: defun
#: original_texis/lists.texi:1950
#, no-wrap
msgid "lax-plist-put plist property value"
msgstr "lax-plist-put plist property value"

#. type: defun
#: original_texis/lists.texi:1953
msgid "Like @code{plist-put} except that it compares properties using @code{equal} instead of @code{eq}."
msgstr "@code{plist-put}と同様だがプロパティーの比較に@code{eq}ではなく@code{equal}を使用する。"

#. type: defun
#: original_texis/lists.texi:1955
#, no-wrap
msgid "plist-member plist property"
msgstr "plist-member plist property"

#. type: defun
#: original_texis/lists.texi:1961
msgid "This returns non-@code{nil} if @var{plist} contains the given @var{property}.  Unlike @code{plist-get}, this allows you to distinguish between a missing property and a property with the value @code{nil}.  The value is actually the tail of @var{plist} whose @code{car} is @var{property}."
msgstr "この関数は与えられた@var{property}が@var{plist}に含まれるなら非@code{nil}をリターンする。@code{plist-get}とは異なりこの関数は存在しないプロパティーと、値が@code{nil}のプロパティーを区別できる。実際にリターンされる値は、@code{car}が@var{property}で始まる@var{plist}の末尾部分である。"
