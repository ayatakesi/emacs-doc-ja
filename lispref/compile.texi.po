# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Emacs 26.1\n"
"POT-Creation-Date: 2022-01-14 07:47+0900\n"
"PO-Revision-Date: 2022-01-10 21:30+0900\n"
"Last-Translator: Takeshi Ayanokoji <takeshi.ayanokoji@gmail.com>\n"
"Language-Team: Japanese <takeshi.ayanokoji@gmail.com>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: original_texis/compile.texi:5 original_texis/compile.texi:6
#, no-wrap
msgid "Byte Compilation"
msgstr "Byte Compilation"

#. type: cindex
#: original_texis/compile.texi:7
#, no-wrap
msgid "byte compilation"
msgstr "byte compilation"

#. type: item
#: original_texis/compile.texi:8 original_texis/compile.texi:589
#, no-wrap
msgid "byte-code"
msgstr "byte-code"

#. type: cindex
#: original_texis/compile.texi:9
#, no-wrap
msgid "compilation (Emacs Lisp)"
msgstr "compilation (Emacs Lisp)"

#. type: Plain text
#: original_texis/compile.texi:16
msgid "Emacs Lisp has a @dfn{compiler} that translates functions written in Lisp into a special representation called @dfn{byte-code} that can be executed more efficiently.  The compiler replaces Lisp function definitions with byte-code.  When a byte-code function is called, its definition is evaluated by the @dfn{byte-code interpreter}."
msgstr "Emacs LispにはLispで記述された関数をより効率的に実行できる、@dfn{バイトコード(byte-code)}と呼ばれる特別な表現に翻訳する@dfn{コンパイラー(compiler)}があります。コンパイラーはLispの関数定義をバイトコードに置き換えます。バイトコード関数が呼び出されたとき、その定義は@dfn{バイトコードインタープリター(byte-code interpreter)}により評価されます。"

#. type: Plain text
#: original_texis/compile.texi:22
msgid "Because the byte-compiled code is evaluated by the byte-code interpreter, instead of being executed directly by the machine's hardware (as true compiled code is), byte-code is completely transportable from machine to machine without recompilation.  It is not, however, as fast as true compiled code."
msgstr "バイトコンパイルされたコードは、(本当のコンパイル済みコードのように)そのマシンのハードウェアによって直接実行されるのではなく、バイトコンパイラーによって評価されるため、バイトコードはリコンパイルしなくてもマシン間での完全な可搬性を有します。しかし本当にコンパイルされたコードほど高速ではありません。"

#. type: Plain text
#: original_texis/compile.texi:25
msgid "In general, any version of Emacs can run byte-compiled code produced by recent earlier versions of Emacs, but the reverse is not true."
msgstr "一般的に任意のバージョンのEmacsはそれ以前のバージョンのEmacsにより生成されたバイトコンパイル済みコードを実行できますが、その逆は成り立ちません。"

#. type: vindex
#: original_texis/compile.texi:26
#, no-wrap
msgid "no-byte-compile"
msgstr "no-byte-compile"

#. type: Plain text
#: original_texis/compile.texi:29
msgid "If you do not want a Lisp file to be compiled, ever, put a file-local variable binding for @code{no-byte-compile} into it, like this:"
msgstr "あるLispファイルを常にコンパイルせずに実行したい場合は、以下のように@code{no-byte-compile}をバインドするファイルローカル変数を配置します:"

#. type: example
#: original_texis/compile.texi:32
#, no-wrap
msgid ";; -*-no-byte-compile: t; -*-\n"
msgstr ";; -*-no-byte-compile: t; -*-\n"

#. type: node
#: original_texis/compile.texi:43 original_texis/compile.texi:45
#, no-wrap
msgid "Speed of Byte-Code"
msgstr "Speed of Byte-Code"

#. type: menuentry
#: original_texis/compile.texi:43
msgid "An example of speedup from byte compilation."
msgstr "バイトコンパイルによるスピードアップ例。"

#. type: node
#: original_texis/compile.texi:43 original_texis/compile.texi:82
#, no-wrap
msgid "Compilation Functions"
msgstr "Compilation Functions"

#. type: menuentry
#: original_texis/compile.texi:43
msgid "Byte compilation functions."
msgstr "バイトコンパイル関数。"

#. type: node
#: original_texis/compile.texi:43 original_texis/compile.texi:244
#, no-wrap
msgid "Docs and Compilation"
msgstr "Docs and Compilation"

#. type: menuentry
#: original_texis/compile.texi:43
msgid "Dynamic loading of documentation strings."
msgstr "ドキュメント文字列のダイナミックロード。"

#. type: node
#: original_texis/compile.texi:43 original_texis/compile.texi:292
#, no-wrap
msgid "Dynamic Loading"
msgstr "Dynamic Loading"

#. type: menuentry
#: original_texis/compile.texi:43
msgid "Dynamic loading of individual functions."
msgstr "個々の関数のダイナミックロード。"

#. type: node
#: original_texis/compile.texi:43 original_texis/compile.texi:357
#, no-wrap
msgid "Eval During Compile"
msgstr "Eval During Compile"

#. type: menuentry
#: original_texis/compile.texi:43
msgid "Code to be evaluated when you compile."
msgstr "コンパイル時に評価されるコード。"

#. type: section
#: original_texis/compile.texi:43 original_texis/compile.texi:439
#: original_texis/compile.texi:440
#, no-wrap
msgid "Compiler Errors"
msgstr "Compiler Errors"

#. type: menuentry
#: original_texis/compile.texi:43
msgid "Handling compiler error messages."
msgstr "コンパイラーのエラーメッセージの扱い。"

#. type: node
#: original_texis/compile.texi:43 original_texis/compile.texi:556
#, no-wrap
msgid "Byte-Code Objects"
msgstr "Byte-Code Objects"

#. type: menuentry
#: original_texis/compile.texi:43
msgid "The data type used for byte-compiled functions."
msgstr "バイトコンパイル済み関数に使用されるデータ型。"

#. type: node
#: original_texis/compile.texi:43 original_texis/compile.texi:636
#, no-wrap
msgid "Disassembly"
msgstr "Disassembly"

#. type: menuentry
#: original_texis/compile.texi:43
msgid "Disassembling byte-code; how to read byte-code."
msgstr "バイトコードの逆アセンブル; バイトコードの読み方。"

#. type: section
#: original_texis/compile.texi:46
#, no-wrap
msgid "Performance of Byte-Compiled Code"
msgstr "Performance of Byte-Compiled Code"

#. type: Plain text
#: original_texis/compile.texi:51
msgid "A byte-compiled function is not as efficient as a primitive function written in C, but runs much faster than the version written in Lisp.  Here is an example:"
msgstr "バイトコンパイルされた関数はCで記述されたプリミティブ関数ほど効率的ではありませんが、Lispで記述されたバージョンよりは高速に実行されます。以下は例です:"

#. type: group
#: original_texis/compile.texi:60
#, no-wrap
msgid ""
"(defun silly-loop (n)\n"
"  \"Return the time, in seconds, to run N iterations of a loop.\"\n"
"  (let ((t1 (float-time)))\n"
"    (while (> (setq n (1- n)) 0))\n"
"    (- (float-time) t1)))\n"
"@result{} silly-loop\n"
msgstr ""
"(defun silly-loop (n)\n"
"  \"Return the time, in seconds, to run N iterations of a loop.\"\n"
"  (let ((t1 (float-time)))\n"
"    (while (> (setq n (1- n)) 0))\n"
"    (- (float-time) t1)))\n"
"@result{} silly-loop\n"

#. type: group
#: original_texis/compile.texi:65
#, no-wrap
msgid ""
"(silly-loop 50000000)\n"
"@result{} 10.235304117202759\n"
msgstr ""
"(silly-loop 50000000)\n"
"@result{} 10.235304117202759\n"

#. type: group
#: original_texis/compile.texi:70
#, no-wrap
msgid ""
"(byte-compile 'silly-loop)\n"
"@result{} @r{[Compiled code not shown]}\n"
msgstr ""
"(byte-compile 'silly-loop)\n"
"@result{} @r{[コンパイルされたコードは表示されない]}\n"

#. type: group
#: original_texis/compile.texi:75
#, no-wrap
msgid ""
"(silly-loop 50000000)\n"
"@result{} 3.705854892730713\n"
msgstr ""
"(silly-loop 50000000)\n"
"@result{} 3.705854892730713\n"

#. type: Plain text
#: original_texis/compile.texi:81
msgid "In this example, the interpreted code required 10 seconds to run, whereas the byte-compiled code required less than 4 seconds.  These results are representative, but actual results may vary."
msgstr "この例ではインタープリターによる実行には10秒を要しますが、バイトコンパイルされたコードは4秒未満です。これは典型的な結果例ですが、実際の結果はさまざまでしょう。"

#. type: section
#: original_texis/compile.texi:83
#, no-wrap
msgid "Byte-Compilation Functions"
msgstr "Byte-Compilation Functions"

#. type: cindex
#: original_texis/compile.texi:84
#, no-wrap
msgid "compilation functions"
msgstr "compilation functions"

#. type: Plain text
#: original_texis/compile.texi:90
msgid "You can byte-compile an individual function or macro definition with the @code{byte-compile} function.  You can compile a whole file with @code{byte-compile-file}, or several files with @code{byte-recompile-directory} or @code{batch-byte-compile}."
msgstr "@code{byte-compile}により、関数やマクロを個別にバイトコンパイルできます。@code{byte-compile-file}でファイル全体、@code{byte-recompile-directory}または@code{batch-byte-compile}で複数ファイルをコンパイルできます。"

#. type: vindex
#: original_texis/compile.texi:91
#, no-wrap
msgid "byte-compile-debug"
msgstr "byte-compile-debug"

#. type: Plain text
#: original_texis/compile.texi:99
msgid "Sometimes, the byte compiler produces warning and/or error messages (@pxref{Compiler Errors}, for details).  These messages are normally recorded in a buffer called @file{*Compile-Log*}, which uses Compilation mode.  @xref{Compilation Mode,,,emacs, The GNU Emacs Manual}.  However, if the variable @code{byte-compile-debug} is non-@code{nil}, error messages will be signaled as Lisp errors instead (@pxref{Errors})."
msgstr "バイトコンパイラーが警告および/またはエラーメッセージを生成することもあります(詳細は@ref{Compiler Errors}を参照)。これらのメッセージは通常はCompilationモードが使用する@file{*Compile-Log*}と呼ばれるバッファーに記録されます。@ref{Compilation Mode,,,emacs, The GNU Emacs Manual}を参照してください。しかし変数@code{byte-compile-debug}が非@code{nil}ならエラーメッセージはLispエラーとしてシグナルされます(@ref{Errors}を参照)。"

#. type: cindex
#: original_texis/compile.texi:100
#, no-wrap
msgid "macro compilation"
msgstr "macro compilation"

#. type: Plain text
#: original_texis/compile.texi:113
msgid "Be careful when writing macro calls in files that you intend to byte-compile.  Since macro calls are expanded when they are compiled, the macros need to be loaded into Emacs or the byte compiler will not do the right thing.  The usual way to handle this is with @code{require} forms which specify the files containing the needed macro definitions (@pxref{Named Features}).  Normally, the byte compiler does not evaluate the code that it is compiling, but it handles @code{require} forms specially, by loading the specified libraries.  To avoid loading the macro definition files when someone @emph{runs} the compiled program, write @code{eval-when-compile} around the @code{require} calls (@pxref{Eval During Compile}).  For more details, @xref{Compiling Macros}."
msgstr "バイトコンパイルを意図したファイル内にマクロ呼び出しを記述する際には注意が必要です。マクロ呼び出しはコンパイル時に展開されるので、そのマクロはEmacsにロードされる必要があります(さもないとバイトコンパイラーが正しく処理しないだろう)。これを処理する通常の方法は、必要なマクロ定義を含むファイルを@code{require}フォームで指定することです。バイトコンパイラーは通常はコンパイルするコードを評価しませんが、@code{require}フォームは指定されたライブラリーをロードすることにより特別に扱われます。誰かがコンパイルされたプログラムを@emph{実行}する際にマクロ定義ファイルのロードを回避するためには、@code{require}呼び出しの周囲に@code{eval-when-compile}を記述します(@ref{Eval During Compile}を参照)。詳細は@ref{Compiling Macros}を参照してください。"

#. type: Plain text
#: original_texis/compile.texi:117
msgid "Inline (@code{defsubst}) functions are less troublesome; if you compile a call to such a function before its definition is known, the call will still work right, it will just run slower."
msgstr "インライン関数(@code{defsubst})はこれほど面倒ではありません。定義が判明する前にそのような関数呼び出しをコンパイルした場合でも、その呼び出しは低速になるだけで正しく機能するでしょう。"

#. type: defun
#: original_texis/compile.texi:118
#, no-wrap
msgid "byte-compile symbol"
msgstr "byte-compile symbol"

#. type: defun
#: original_texis/compile.texi:125
msgid "This function byte-compiles the function definition of @var{symbol}, replacing the previous definition with the compiled one.  The function definition of @var{symbol} must be the actual code for the function; @code{byte-compile} does not handle function indirection.  The return value is the byte-code function object which is the compiled definition of @var{symbol} (@pxref{Byte-Code Objects})."
msgstr "この関数は@var{symbol}の関数定義をバイトコンパイルして、以前の定義をコンパイルされた定義に置き換える。@var{symbol}の関数定義は、その関数にたいする実際のコードでなければならない。@code{byte-compile}はインダイレクト関数を処理しない。リターン値は、@var{symbol}のコンパイルされた定義であるようなバイトコード関数ブジェクト(@ref{Byte-Code Objects}を参照)。"

#. type: group
#: original_texis/compile.texi:133
#, no-wrap
msgid ""
"(defun factorial (integer)\n"
"  \"Compute factorial of INTEGER.\"\n"
"  (if (= 1 integer) 1\n"
"    (* integer (factorial (1- integer)))))\n"
"@result{} factorial\n"
msgstr ""
"(defun factorial (integer)\n"
"  \"INTEGERの階乗を計算する。\"\n"
"  (if (= 1 integer) 1\n"
"    (* integer (factorial (1- integer)))))\n"
"@result{} factorial\n"

#. type: group
#: original_texis/compile.texi:142
#, no-wrap
msgid ""
"(byte-compile 'factorial)\n"
"@result{}\n"
"#[(integer)\n"
"  \"^H\\301U\\203^H^@@\\301\\207\\302^H\\303^HS!\\\"\\207\"\n"
"  [integer 1 * factorial]\n"
"  4 \"Compute factorial of INTEGER.\"]\n"
msgstr ""
"(byte-compile 'factorial)\n"
"@result{}\n"
"#[(integer)\n"
"  \"^H\\301U\\203^H^@@\\301\\207\\302^H\\303^HS!\\\"\\207\"\n"
"  [integer 1 * factorial]\n"
"  4 \"Compute factorial of INTEGER.\"]\n"

#. type: defun
#: original_texis/compile.texi:150
msgid "If @var{symbol}'s definition is a byte-code function object, @code{byte-compile} does nothing and returns @code{nil}.  It does not compile the symbol's definition again, since the original (non-compiled) code has already been replaced in the symbol's function cell by the byte-compiled code."
msgstr "@var{symbol}の定義がバイトコード関数オブジェクトなら、@code{byte-compile}は何も行わず@code{nil}をリターンする。そのシンボルの関数セル内の(コンパイルされていない)オリジナルのコードはすでにバイトコンパイルされたコードに置き換えられているので、シンボルの定義の再コンパイルはしない。"

#. type: defun
#: original_texis/compile.texi:154
msgid "The argument to @code{byte-compile} can also be a @code{lambda} expression.  In that case, the function returns the corresponding compiled code but does not store it anywhere."
msgstr "@code{byte-compile}の引数として@code{lambda}式も指定できる。この場合、関数は対応するコンパイル済みコードをリターンするが、それはどこにも格納されない。"

#. type: deffn
#: original_texis/compile.texi:156
#, no-wrap
msgid "Command compile-defun &optional arg"
msgstr "Command compile-defun &optional arg"

#. type: deffn
#: original_texis/compile.texi:161
msgid "This command reads the defun containing point, compiles it, and evaluates the result.  If you use this on a defun that is actually a function definition, the effect is to install a compiled version of that function."
msgstr "このコマンドはポイントを含むdefunを読み取りそれをコンパイルして結果を評価する。実際に関数定義であるようなdefunでこれを使用した場合には、その関数のコンパイル済みバージョンをインストールする効果がある。"

#. type: deffn
#: original_texis/compile.texi:165
msgid "@code{compile-defun} normally displays the result of evaluation in the echo area, but if @var{arg} is non-@code{nil}, it inserts the result in the current buffer after the form it has compiled."
msgstr "@code{compile-defun}は通常は評価した結果をエコーエリアに表示するが、@var{arg}が非@code{nil}ならフォームをコンパイルした後にカレントバッファーに結果を挿入する。"

#. type: deffn
#: original_texis/compile.texi:167
#, no-wrap
msgid "Command byte-compile-file filename"
msgstr "Command byte-compile-file filename"

#. type: deffn
#: original_texis/compile.texi:172
msgid "This function compiles a file of Lisp code named @var{filename} into a file of byte-code.  The output file's name is made by changing the @samp{.el} suffix into @samp{.elc}; if @var{filename} does not end in @samp{.el}, it adds @samp{.elc} to the end of @var{filename}."
msgstr "この関数は@var{filename}という名前のLispコードファイルを、バイトコードのファイルにコンパイルする。出力となるファイルの名前は、サフィックス@samp{.el}を@samp{.elc}に変更することにより作成される。@var{filename}が@samp{.el}で終了しない場合には、@samp{.elc}を@var{filename}の最後に付け足す。"

#. type: deffn
#: original_texis/compile.texi:179
msgid "Compilation works by reading the input file one form at a time.  If it is a definition of a function or macro, the compiled function or macro definition is written out.  Other forms are batched together, then each batch is compiled, and written so that its compiled code will be executed when the file is read.  All comments are discarded when the input file is read."
msgstr "コンパイルは入力ファイルから1つのフォームを逐次読み取ることにより機能する。フォームが関数かマクロなら、コンパイル済みの関数かマクロが書き込まれる。それ以外のフォームはまとめられて、まとめられたものごとにコンパイルされて、そのファイルが読まれたとき実行されるようにコンパイルされたコードが書き込まれる。入力ファイルを読み取る際には、すべてのコメントは無視される。"

#. type: deffn
#: original_texis/compile.texi:182
msgid "This command returns @code{t} if there were no errors and @code{nil} otherwise.  When called interactively, it prompts for the file name."
msgstr "このコマンドはエラーがなければ@code{t}、それ以外は@code{nil}をリターンする。インタラクティブに呼び出されたときは、ファイル名の入力をもとめる。"

#. type: group
#: original_texis/compile.texi:187
#, no-wrap
msgid ""
"$ ls -l push*\n"
"-rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el\n"
msgstr ""
"$ ls -l push*\n"
"-rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el\n"

#. type: group
#: original_texis/compile.texi:192
#, no-wrap
msgid ""
"(byte-compile-file \"~/emacs/push.el\")\n"
"     @result{} t\n"
msgstr ""
"(byte-compile-file \"~/emacs/push.el\")\n"
"     @result{} t\n"

#. type: group
#: original_texis/compile.texi:198
#, no-wrap
msgid ""
"$ ls -l push*\n"
"-rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el\n"
"-rw-rw-rw- 1 lewis lewis 638 Oct  8 20:25 push.elc\n"
msgstr ""
"$ ls -l push*\n"
"-rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el\n"
"-rw-rw-rw- 1 lewis lewis 638 Oct  8 20:25 push.elc\n"

#. type: deffn
#: original_texis/compile.texi:202
#, no-wrap
msgid "Command byte-recompile-directory directory &optional flag force follow-symlinks"
msgstr "Command byte-recompile-directory directory &optional flag force follow-symlinks"

#. type: cindex
#: original_texis/compile.texi:203
#, no-wrap
msgid "library compilation"
msgstr "library compilation"

#. type: deffn
#: original_texis/compile.texi:208
msgid "This command recompiles every @samp{.el} file in @var{directory} (or its subdirectories) that needs recompilation.  A file needs recompilation if a @samp{.elc} file exists but is older than the @samp{.el} file."
msgstr "このコマンドは@var{directory}(またはそのサブディレクトリー)内の、リコンパイルを要するすべての@samp{.el}ファイルをリコンパイルする。@samp{.elc}ファイルが存在して、それが@samp{.el}より古いファイルは、リコンパイルが必要となる。"

#. type: deffn
#: original_texis/compile.texi:214
msgid "When a @samp{.el} file has no corresponding @samp{.elc} file, @var{flag} says what to do.  If it is @code{nil}, this command ignores these files.  If @var{flag} is 0, it compiles them.  If it is neither @code{nil} nor 0, it asks the user whether to compile each such file, and asks about each subdirectory as well."
msgstr "@samp{.el}ファイルに対応する@samp{.elc}ファイルが存在しない場合に何を行うかを@var{flag}で指定する。@code{nil}なら、このコマンドはこれらのファイルを無視する。@var{flag}が0なら、それらをコンパイルする。@code{nil}と0以外なら、それらのファイルをコンパイルするかユーザーに尋ねて、同様にそれぞれのサブディレクトリーについても尋ねる。"

#. type: deffn
#: original_texis/compile.texi:217
msgid "Interactively, @code{byte-recompile-directory} prompts for @var{directory} and @var{flag} is the prefix argument."
msgstr "インタラクティブに呼び出されると、@code{byte-recompile-directory}は@var{directory}の入力を求めて、@var{flag}はプレフィクス引数となる。"

#. type: deffn
#: original_texis/compile.texi:220
msgid "If @var{force} is non-@code{nil}, this command recompiles every @samp{.el} file that has a @samp{.elc} file."
msgstr "@var{force}が非@code{nil}なら、このコマンドは@samp{.elc}ファイルが存在するすべての@samp{.el}ファイルをリコンパイルする。"

#. type: deffn
#: original_texis/compile.texi:224
msgid "This command will normally not compile @samp{.el} files that are symlinked.  If the optional @var{follow-symlink} parameter is non-@code{nil}, symlinked @samp{.el} will also be compiled."
msgstr "このコマンドは通常はシンボリックリンクであるような@samp{.el}ファイルをコンパイルしない。オプションの@var{follow-symlink}パラメーターが非@code{nil}なら、シンボリックリンクされた@samp{.el}もコンパイルされる。"

#. type: deffn
#: original_texis/compile.texi:226
msgid "The returned value is unpredictable."
msgstr "リターン値は不定。"

#. type: defun
#: original_texis/compile.texi:228
#, no-wrap
msgid "batch-byte-compile &optional noforce"
msgstr "batch-byte-compile &optional noforce"

#. type: defun
#: original_texis/compile.texi:235
msgid "This function runs @code{byte-compile-file} on files specified on the command line.  This function must be used only in a batch execution of Emacs, as it kills Emacs on completion.  An error in one file does not prevent processing of subsequent files, but no output file will be generated for it, and the Emacs process will terminate with a nonzero status code."
msgstr "この関数はコマンドラインで指定されたファイルにたいして@code{byte-compile-file}を実行する。この関数は処理が完了するとEmacsをkillするので、Emacsのバッチ実行でのみ使用しなければならない。1つのファイルでエラーが発生しても、それによって後続のファイルにたいする処理が妨げられることはないが、そのファイルにたいする出力ファイルは生成されず、Emacsプロセスは0以外のステータスコードで終了する。"

#. type: defun
#: original_texis/compile.texi:238
msgid "If @var{noforce} is non-@code{nil}, this function does not recompile files that have an up-to-date @samp{.elc} file."
msgstr "@var{noforce}が非@code{nil}なら、この関数は最新の@samp{.elc}ファイルがあるファイルをリコンパイルしない。"

#. type: example
#: original_texis/compile.texi:241
#, no-wrap
msgid "$ emacs -batch -f batch-byte-compile *.el\n"
msgstr "$ emacs -batch -f batch-byte-compile *.el\n"

#. type: section
#: original_texis/compile.texi:245
#, no-wrap
msgid "Documentation Strings and Compilation"
msgstr "Documentation Strings and Compilation"

#. type: cindex
#: original_texis/compile.texi:246
#, no-wrap
msgid "dynamic loading of documentation"
msgstr "dynamic loading of documentation"

#. type: Plain text
#: original_texis/compile.texi:253
msgid "When Emacs loads functions and variables from a byte-compiled file, it normally does not load their documentation strings into memory.  Each documentation string is dynamically loaded from the byte-compiled file only when needed.  This saves memory, and speeds up loading by skipping the processing of the documentation strings."
msgstr "Emacsがバイトコンパイルされたファイルから関数や変数をロードする際、通常はメモリー内にそれらのドキュメント文字列をロードしません。それぞれのドキュメント文字列は、必要なときだけバイトコンパイルされたファイルからダイナミック(dynamic: 動的)にロードされます。ドキュメント文字列の処理をスキップすることにより、メモリーが節約されてロードが高速になります。"

#. type: Plain text
#: original_texis/compile.texi:260
msgid "This feature has a drawback: if you delete, move, or alter the compiled file (such as by compiling a new version), Emacs may no longer be able to access the documentation string of previously-loaded functions or variables.  Such a problem normally only occurs if you build Emacs yourself, and happen to edit and/or recompile the Lisp source files.  To solve it, just reload each file after recompilation."
msgstr "この機能には欠点があります。コンパイル済みのファイルを削除や移動、または(新しいバージョンのコンパイル等で)変更した場合、Emacsは以前にロードした関数や変数のドキュメント文字列にアクセスできなくなるでしょう。このような問題は通常なら、あなた自身がEmacsをビルドしたときに、そのLispファイルを編集および/またはリコンパイルしたときだけ発生します。この問題は、リコンパイル後にそれぞれのファイルをリロードするだけで解決します。"

#. type: Plain text
#: original_texis/compile.texi:264
msgid "Dynamic loading of documentation strings from byte-compiled files is determined, at compile time, for each byte-compiled file.  It can be disabled via the option @code{byte-compile-dynamic-docstrings}."
msgstr "バイトコンパイルされたファイルからのドキュメント文字列のダイナミックロードは、バイトコンパイルされたファイルごとにコンパイル時に解決されます。これはオプション@code{byte-compile-dynamic-docstrings}で無効にできます。"

#. type: defopt
#: original_texis/compile.texi:265
#, no-wrap
msgid "byte-compile-dynamic-docstrings"
msgstr "byte-compile-dynamic-docstrings"

#. type: defopt
#: original_texis/compile.texi:268
msgid "If this is non-@code{nil}, the byte compiler generates compiled files that are set up for dynamic loading of documentation strings."
msgstr "これが非@code{nil}なら、バイトコンパイラーはドキュメント文字列をダイナミックロードするようにセットアップしたコンパイル済みファイルを生成する。"

#. type: defopt
#: original_texis/compile.texi:272
msgid "To disable the dynamic loading feature for a specific file, set this option to @code{nil} in its header line (@pxref{File Variables, , Local Variables in Files, emacs, The GNU Emacs Manual}), like this:"
msgstr "特定のファイルでダイナミックロード機能を無効にするには、以下のようにヘッダー行でこのオプションに@code{nil}をセットする(@ref{File Variables, , Local Variables in Files, emacs, The GNU Emacs Manual}を参照)。"

#. type: smallexample
#: original_texis/compile.texi:275
#, no-wrap
msgid "-*-byte-compile-dynamic-docstrings: nil;-*-\n"
msgstr "-*-byte-compile-dynamic-docstrings: nil;-*-\n"

#. type: defopt
#: original_texis/compile.texi:280
msgid "This is useful mainly if you expect to change the file, and you want Emacs sessions that have already loaded it to keep working when the file changes."
msgstr "これは主として、あるファイルを変更しようとしていて、そのファイルをすでにロード済みのEmacsセッションがファイルを変更した際にも正しく機能し続けることを望む場合に有用である。"

#. type: samp{#1}
#: original_texis/compile.texi:282
#, no-wrap
msgid "#@@@var{count}"
msgstr "#@@@var{count}"

#. type: samp{#1}
#: original_texis/compile.texi:283
#, no-wrap
msgid "#$"
msgstr "#$"

#. type: Plain text
#: original_texis/compile.texi:291
msgid "Internally, the dynamic loading of documentation strings is accomplished by writing compiled files with a special Lisp reader construct, @samp{#@@@var{count}}.  This construct skips the next @var{count} characters.  It also uses the @samp{#$} construct, which stands for the name of this file, as a string.  Do not use these constructs in Lisp source files; they are not designed to be clear to humans reading the file."
msgstr "内部的にはドキュメント文字列のダイナミックロードは、特殊なLispリーダー構文@samp{#@@@var{count}}とともにコンパイル済みファイルに書き込むことによって達成される。この構文は次の@var{count}文字をスキップする。さらに@samp{#$}構文も使用され、これはこのファイルの名前(文字列)を意味する。これらの構文をLispソースファイル内で使用しないこと。これらは人間がファイルを読む際に明確であるようにデザインされていない。"

#. type: section
#: original_texis/compile.texi:293
#, no-wrap
msgid "Dynamic Loading of Individual Functions"
msgstr "Dynamic Loading of Individual Functions"

#. type: cindex
#: original_texis/compile.texi:295
#, no-wrap
msgid "dynamic loading of functions"
msgstr "dynamic loading of functions"

#. type: cindex
#: original_texis/compile.texi:296
#, no-wrap
msgid "lazy loading"
msgstr "lazy loading"

#. type: Plain text
#: original_texis/compile.texi:304
msgid "When you compile a file, you can optionally enable the @dfn{dynamic function loading} feature (also known as @dfn{lazy loading}).  With dynamic function loading, loading the file doesn't fully read the function definitions in the file.  Instead, each function definition contains a place-holder which refers to the file.  The first time each function is called, it reads the full definition from the file, to replace the place-holder."
msgstr "ファイルをコンパイルするとき、オプションで@dfn{ダイナミック関数ロード(dynamic function loading)}機能(@dfn{laxyロード(lazy loading)とも呼ばれる})を有効にできます。ダイナミック関数ロードでは、ファイルのロードでファイル内の関数定義は完全には読み込まれません。かわりに各関数定義にはそのファイルを参照するプレースホルダーが含まれます。それぞれ関数が最初に呼び出されるときにそのプレースホルダーを置き換えるために、ファイルから完全な定義が読み込まれます。"

#. type: Plain text
#: original_texis/compile.texi:311
msgid "The advantage of dynamic function loading is that loading the file should become faster.  This is a good thing for a file which contains many separate user-callable functions, if using one of them does not imply you will probably also use the rest.  A specialized mode which provides many keyboard commands often has that usage pattern: a user may invoke the mode, but use only a few of the commands it provides."
msgstr "ファイルのロードがより高速になるだろうというのがダイナミック関数ロードの利点です。ユーザーが呼び出せる関数を多く含むファイルにとって、それらの関数のうち1つを使用したら多分残りの関数も使用するというのでなければ、これは利点になります。多くのキーボードコマンドを提供する特化したモードは、このパターンの使い方をする場合があります。ユーザーはそのモードを呼び出すかもしれませんが、使用するのはそのモードが提供するコマンドのわずか一部です。"

#. type: Plain text
#: original_texis/compile.texi:313
msgid "The dynamic loading feature has certain disadvantages:"
msgstr "ダイナミックロード機能には不利な点がいくつかあります:"

#. type: itemize
#: original_texis/compile.texi:318
msgid "If you delete or move the compiled file after loading it, Emacs can no longer load the remaining function definitions not already loaded."
msgstr "ロード後にコンパイル済みファイルの削除や移動を行うと、Emacsはまだロードされていない残りの関数定義をロードできなくなる。"

#. type: itemize
#: original_texis/compile.texi:323
msgid "If you alter the compiled file (such as by compiling a new version), then trying to load any function not already loaded will usually yield nonsense results."
msgstr "(新しいバージョンのコンパイル等で)コンパイル済みファイルを変更した場合に、まだロードされていない関数のロードを試みると通常は無意味な結果となる。"

#. type: Plain text
#: original_texis/compile.texi:329
msgid "These problems will never happen in normal circumstances with installed Emacs files.  But they are quite likely to happen with Lisp files that you are changing.  The easiest way to prevent these problems is to reload the new compiled file immediately after each recompilation."
msgstr "このような問題は通常の状況でインストールされたEmacsファイルでは決して発生しません。しかしあなたが変更したLispファイルでは発生し得ます。それぞれのファイルをリコンパイルしたらすぐに新たなコンパイル済みファイルをリロードするのが、これらの問題を回避する一番簡単な方法です。"

#. type: emph{#1}
#: original_texis/compile.texi:333
msgid "Experience shows that using dynamic function loading provides benefits that are hardly measurable, so this feature is deprecated since Emacs 27.1."
msgstr "ダイナミックな関数ロードの使用により提供される利点がほとんど計測できないという経験から、この機能はEmacs 27.1以降は廃止されます。"

#. type: Plain text
#: original_texis/compile.texi:340
msgid "The byte compiler uses the dynamic function loading feature if the variable @code{byte-compile-dynamic} is non-@code{nil} at compilation time.  Do not set this variable globally, since dynamic loading is desirable only for certain files.  Instead, enable the feature for specific source files with file-local variable bindings.  For example, you could do it by writing this text in the source file's first line:"
msgstr "コンパイル時に変数@code{byte-compile-dynamic}が非@code{nil}なら、バイトコンパイラーはダイナミック関数ロード機能を使用します。ダイナミックロードが望ましいのは特定のファイルにたいしてだけなので、この変数をグローバルにセットしないでください。そのかわりに、特定のソースファイルのファイルローカル変数でこの機能を有効にしてください。たとえばソースファイルの最初の行に以下のテキストを記述することにより、これを行うことができます:"

#. type: example
#: original_texis/compile.texi:343
#, no-wrap
msgid "-*-byte-compile-dynamic: t;-*-\n"
msgstr "-*-byte-compile-dynamic: t;-*-\n"

#. type: defvar
#: original_texis/compile.texi:345
#, no-wrap
msgid "byte-compile-dynamic"
msgstr "byte-compile-dynamic"

#. type: defvar
#: original_texis/compile.texi:348
msgid "If this is non-@code{nil}, the byte compiler generates compiled files that are set up for dynamic function loading."
msgstr "これが非@code{nil}なら、バイトコンパイラーはダイナミック関数ロード用にセットアップされたコンパイル済みファイルを生成する。"

#. type: defun
#: original_texis/compile.texi:350
#, no-wrap
msgid "fetch-bytecode function"
msgstr "fetch-bytecode function"

#. type: defun
#: original_texis/compile.texi:355
msgid "If @var{function} is a byte-code function object, this immediately finishes loading the byte code of @var{function} from its byte-compiled file, if it is not fully loaded already.  Otherwise, it does nothing.  It always returns @var{function}."
msgstr "@var{function}がバイトコード関数オブジェクトなら、それがまだ完全にロードされていなければ、バイトコンパイル済みのファイルからの@var{function}のバイトコードのロードを完了させる。それ以外なら何も行わない。この関数は常に@var{function}をリターンする。"

#. type: section
#: original_texis/compile.texi:358
#, no-wrap
msgid "Evaluation During Compilation"
msgstr "Evaluation During Compilation"

#. type: cindex
#: original_texis/compile.texi:359
#, no-wrap
msgid "eval during compilation"
msgstr "eval during compilation"

#. type: Plain text
#: original_texis/compile.texi:363
msgid "These features permit you to write code to be evaluated during compilation of a program."
msgstr "これらの機能によりプログラムのコンパイル中に評価されるコードを記述できます。"

#. type: defmac
#: original_texis/compile.texi:364
#, no-wrap
msgid "eval-and-compile body@dots{}"
msgstr "eval-and-compile body@dots{}"

#. type: defmac
#: original_texis/compile.texi:367
msgid "This form marks @var{body} to be evaluated both when you compile the containing code and when you run it (whether compiled or not)."
msgstr "このフォームはそれを含むコードがコンパイルされるとき、および(コンパイルされているかいないかに関わらず)実行されるときの両方で@var{body}が評価されるようにマークする。"

#. type: defmac
#: original_texis/compile.texi:373
msgid "You can get a similar result by putting @var{body} in a separate file and referring to that file with @code{require}.  That method is preferable when @var{body} is large.  Effectively @code{require} is automatically @code{eval-and-compile}, the package is loaded both when compiling and executing."
msgstr "@var{body}を別のファイルに配置して、そのファイルを@code{require}で参照すれば同様の結果が得られる。これは@var{body}が大きいときに望ましい方法である。事実上、@code{require}は自動的に@code{eval-and-compile}されて、そのパッケージはコンパイル時と実行時の両方でロードされる。"

#. type: defmac
#: original_texis/compile.texi:377
msgid "@code{autoload} is also effectively @code{eval-and-compile} too.  It's recognized when compiling, so uses of such a function don't produce ``not known to be defined'' warnings."
msgstr "@code{autoload}も実際は@code{eval-and-compile}される。これはコンパイル時に認識されるので、そのような関数の使用により警告``not known to be defined''は生成されない。"

#. type: defmac
#: original_texis/compile.texi:379
msgid "Most uses of @code{eval-and-compile} are fairly sophisticated."
msgstr "ほとんどの@code{eval-and-compile}の使用は、完全に妥当であると言えよう。"

#. type: defmac
#: original_texis/compile.texi:384
msgid "If a macro has a helper function to build its result, and that macro is used both locally and outside the package, then @code{eval-and-compile} should be used to get the helper both when compiling and then later when running."
msgstr "あるマクロがマクロの結果を構築するためのヘルパー関数をもち、そのマクロがそのパッケージにたいしてローカルと外部の両方で使用される場合には、コンパイル時と後の実行時にそのヘルパー関数を取得するために@code{eval-and-compile}を使用すること。"

#. type: defmac
#: original_texis/compile.texi:389
msgid "If functions are defined programmatically (with @code{fset} say), then @code{eval-and-compile} can be used to have that done at compile-time as well as run-time, so calls to those functions are checked (and warnings about ``not known to be defined'' suppressed)."
msgstr "これは関数がプログラム的に(@code{fset}で)定義されている場合には、コンパイル時と実行時にプログラム的な定義を行わせてそれらの関数の呼び出しをチェックするためにも使用できる(``not known to be defined''の警告は抑制される)。"

#. type: defmac
#: original_texis/compile.texi:391
#, no-wrap
msgid "eval-when-compile body@dots{}"
msgstr "eval-when-compile body@dots{}"

#. type: defmac
#: original_texis/compile.texi:397
msgid "This form marks @var{body} to be evaluated at compile time but not when the compiled program is loaded.  The result of evaluation by the compiler becomes a constant which appears in the compiled program.  If you load the source file, rather than compiling it, @var{body} is evaluated normally."
msgstr "このフォームは@var{body}がコンパイル時に評価され、コンパイルされたプログラムがロードされるときは評価されないようにマークする。コンパイラーによる評価の結果はコンパイル済みのプログラム内の定数となる。ソースファイルをコンパイルではなくロードすると、@var{body}は通常どおり評価される。"

#. type: cindex
#: original_texis/compile.texi:398
#, no-wrap
msgid "compile-time constant"
msgstr "compile-time constant"

#. type: defmac
#: original_texis/compile.texi:401
msgid "If you have a constant that needs some calculation to produce, @code{eval-when-compile} can do that at compile-time.  For example,"
msgstr "生成するために何らかの計算が必要な定数があるなら、@code{eval-when-compile}はコンパイル時にそれを行なうことができる。たとえば、"

#. type: lisp
#: original_texis/compile.texi:405
#, no-wrap
msgid ""
"(defvar my-regexp\n"
"  (eval-when-compile (regexp-opt '(\"aaa\" \"aba\" \"abb\"))))\n"
msgstr ""
"(defvar my-regexp\n"
"  (eval-when-compile (regexp-opt '(\"aaa\" \"aba\" \"abb\"))))\n"

#. type: cindex
#: original_texis/compile.texi:407
#, no-wrap
msgid "macros, at compile time"
msgstr "macros, at compile time"

#. type: defmac
#: original_texis/compile.texi:411
msgid "If you're using another package, but only need macros from it (the byte compiler will expand those), then @code{eval-when-compile} can be used to load it for compiling, but not executing.  For example,"
msgstr "他のパッケージを使用しているが、そのパッケージのマクロ(バイトコンパイラーはそれらを展開します)だけが必要なら、それらを実行せずにコンパイル用にロードさせるために@code{eval-when-compile}を使用できる。たとえば、"

#. type: lisp
#: original_texis/compile.texi:415
#, no-wrap
msgid ""
"(eval-when-compile\n"
"  (require 'my-macro-package))\n"
msgstr ""
"(eval-when-compile\n"
"  (require 'my-macro-package))\n"

#. type: defmac
#: original_texis/compile.texi:421
msgid "The same sort of thing goes for macros and @code{defsubst} functions defined locally and only for use within the file.  They are needed for compiling the file, but in most cases they are not needed for execution of the compiled file.  For example,"
msgstr "これらの事項は、マクロと@code{defsubst}関数がローカルに定義されていて、そのファイル内だけで使用されることを要求する。これらはそのファイルのコンパイルに必要だが、コンパイル済みファイルの実行には、ほとんどの場合必要ない。たとえば、"

#. type: lisp
#: original_texis/compile.texi:427
#, no-wrap
msgid ""
"(eval-when-compile\n"
"  (unless (fboundp 'some-new-thing)\n"
"    (defmacro 'some-new-thing ()\n"
"      (compatibility code))))\n"
msgstr ""
"(eval-when-compile\n"
"  (unless (fboundp 'some-new-thing)\n"
"    (defmacro 'some-new-thing ()\n"
"      (compatibility code))))\n"

#. type: defmac
#: original_texis/compile.texi:432
msgid "This is often good for code that's only a fallback for compatibility with other versions of Emacs."
msgstr "これは大抵は他のバージョンのEmacsとの互換性の保証のためのコードにたいしてのみ有用である。"

#. type: defmac
#: original_texis/compile.texi:437
msgid "@strong{Common Lisp Note:} At top level, @code{eval-when-compile} is analogous to the Common Lisp idiom @code{(eval-when (compile eval) @dots{})}.  Elsewhere, the Common Lisp @samp{#.} reader macro (but not when interpreting) is closer to what @code{eval-when-compile} does."
msgstr "@strong{Common Lispに関する注意:} トップレベルでは、@code{eval-when-compile}はCommon Lispのイディオム@code{(eval-when (compile eval) @dots{})}に類似する。トップレベル以外では、Common Lispのリーダーマクロ@samp{#.}(ただし解釈時を除く)が、@code{eval-when-compile}と近いことを行う。"

#. type: cindex
#: original_texis/compile.texi:441
#, no-wrap
msgid "compiler errors"
msgstr "compiler errors"

#. type: cindex
#: original_texis/compile.texi:442
#, no-wrap
msgid "byte-compiler errors"
msgstr "byte-compiler errors"

#. type: Plain text
#: original_texis/compile.texi:449
msgid "Error and warning messages from byte compilation are printed in a buffer named @file{*Compile-Log*}.  These messages include file names and line numbers identifying the location of the problem.  The usual Emacs commands for operating on compiler output can be used on these messages."
msgstr "バイトコンパイルのエラーメッセージと警告メッセージは、@file{*Compile-Log*}という名前のバッファーにプリントされます。これらのメッセージには、問題となる箇所を示すファイル名と行番号が含まれます。これらのメッセージにたいして、コンパイラー出力を操作する通常のEmacsコマンドが使用できます。"

#. type: Plain text
#: original_texis/compile.texi:458
msgid "When an error is due to invalid syntax in the program, the byte compiler might get confused about the error's exact location.  One way to investigate is to switch to the buffer @w{@file{ *Compiler Input*}}.  (This buffer name starts with a space, so it does not show up in the Buffer Menu.)  This buffer contains the program being compiled, and point shows how far the byte compiler was able to read; the cause of the error might be nearby.  @xref{Syntax Errors}, for some tips for locating syntax errors."
msgstr "あるエラーがプログラムのシンタックスに由来する場合、バイトコンパイラーはエラーの正確な位置の取得に際して混乱するかもしれません。バッファー@w{@file{ *Compiler Input*}}.にスイッチするのは、これを調べ1つの方法です(このバッファー名はスペースで始まるので、Buffer Menuに表示されない)。このバッファーにはコンパイルされたプログラムと、バイトコンパイラーが読み取った箇所からポイントがどれほど離れているかが含まれ、エラーの原因はその近傍の可能性があります。シンタックスエラーを見つけるヒントについては、@ref{Syntax Errors}を参照してください。"

#. type: cindex
#: original_texis/compile.texi:459
#, no-wrap
msgid "byte-compiler warnings"
msgstr "byte-compiler warnings"

#. type: cindex
#: original_texis/compile.texi:460
#, no-wrap
msgid "free variable, byte-compiler warning"
msgstr "free variable, byte-compiler warning"

#. type: cindex
#: original_texis/compile.texi:461
#, no-wrap
msgid "reference to free variable, compilation warning"
msgstr "reference to free variable, compilation warning"

#. type: cindex
#: original_texis/compile.texi:462
#, no-wrap
msgid "function not known to be defined, compilation warning"
msgstr "function not known to be defined, compilation warning"

#. type: Plain text
#: original_texis/compile.texi:468
msgid "A common type of warning issued by the byte compiler is for functions and variables that were used but not defined.  Such warnings report the line number for the end of the file, not the locations where the missing functions or variables were used; to find these, you must search the file manually."
msgstr "定義されていない関数や変数の使用は、バイトコンパイラーにより報告される警告のタイプとしては一般的です。そのような警告では、定義されていない関数や変数を使用した位置ではなく、そのファイルの最後の行の行番号が報告されるので、それを見つけるには手作業で検索しなければなりません。"

#. type: Plain text
#: original_texis/compile.texi:471
msgid "If you are sure that a warning message about a missing function or variable is unjustified, there are several ways to suppress it:"
msgstr "定義のない関数や変数の警告が間違いだと確信できる場合には、警告を抑制する方法がいくつかあります:"

#. type: itemize
#: original_texis/compile.texi:477
msgid "You can suppress the warning for a specific call to a function @var{func} by conditionalizing it on an @code{fboundp} test, like this:"
msgstr "関数@var{func}への特定の呼び出しにたいする警告は、それを条件式@code{fboundp}でテストすることで抑制できる:"

#. type: example
#: original_texis/compile.texi:480
#, no-wrap
msgid "(if (fboundp '@var{func}) ...(@var{func} ...)...)\n"
msgstr "(if (fboundp '@var{func}) ...(@var{func} ...)...)\n"

#. type: itemize
#: original_texis/compile.texi:486
msgid "The call to @var{func} must be in the @var{then-form} of the @code{if}, and @var{func} must appear quoted in the call to @code{fboundp}.  (This feature operates for @code{cond} as well.)"
msgstr "@var{func}への呼び出しは@code{if}文の@var{then-form}内になければならず、@var{func}は@code{fboundp}呼び出し内でクォートされていなければならない(この機能は@code{cond}でも同様に機能する)。"

#. type: itemize
#: original_texis/compile.texi:491
msgid "Likewise, you can suppress the warning for a specific use of a variable @var{variable} by conditionalizing it on a @code{boundp} test:"
msgstr "同じように、変数@var{variable}の特定の使用についの警告を、条件式内の@code{boundp}テストで抑制できる:"

#. type: example
#: original_texis/compile.texi:494
#, no-wrap
msgid "(if (boundp '@var{variable}) ...@var{variable}...)\n"
msgstr "(if (boundp '@var{variable}) ...@var{variable}...)\n"

#. type: itemize
#: original_texis/compile.texi:500
msgid "The reference to @var{variable} must be in the @var{then-form} of the @code{if}, and @var{variable} must appear quoted in the call to @code{boundp}."
msgstr "@var{variable}への参照は@code{if}文の@var{then-form}内になければならず、@var{variable}は@code{boundp}呼び出し内でクォートされていなければならない。"

#. type: itemize
#: original_texis/compile.texi:504
msgid "You can tell the compiler that a function is defined using @code{declare-function}.  @xref{Declaring Functions}."
msgstr "コンパイラーに関数が@code{declare-function}を使用して定義されていると告げることができる。@ref{Declaring Functions}を参照のこと。"

#. type: itemize
#: original_texis/compile.texi:511
msgid "Likewise, you can tell the compiler that a variable is defined using @code{defvar} with no initial value.  (Note that this marks the variable as special, i.e.@: dynamically bound, but only within the current lexical scope, or file if at top-level.)  @xref{Defining Variables}."
msgstr "同じように変数が初期値なしの@code{defvar}を使用して定義されているとコンパイラーに告げることができる(カレントレキシカルスコープ、またはトップレベルにあればファイルでのみダイナミックにバインドされているとして変数を特別な変数としてマークすることに注意。@ref{Defining Variables}を参照のこと。"

#. type: Plain text
#: original_texis/compile.texi:515
msgid "You can also suppress compiler warnings within a certain expression using the @code{with-suppressed-warnings} macro:"
msgstr "@code{with-suppressed-warnings}マクロを使用して特定の式にたいするコンパイラーの警告を抑制することもできます:"

#. type: defspec
#: original_texis/compile.texi:516
#, no-wrap
msgid "with-suppressed-warnings warnings body@dots{}"
msgstr "with-suppressed-warnings warnings body@dots{}"

#. type: defspec
#: original_texis/compile.texi:523
msgid "In execution, this is equivalent to @code{(progn @var{body}...)}, but the compiler does not issue warnings for the specified conditions in @var{body}.  @var{warnings} is an associative list of warning symbols and function/variable symbols they apply to.  For instance, if you wish to call an obsolete function called @code{foo}, but want to suppress the compilation warning, say:"
msgstr "これは実行においては@code{(progn @var{body}...)}と等価だが、コンパイラーは@var{body}内の指定したコンディションにたいする警告を発しない。@var{warnings}は警告シンボルと、それらを適用する関数/変数シンボルの連想リスト。たとえば@code{foo}という時代遅れ(obsolete)の関数を呼び出したいがコンパイル時の警告を抑止したければ、以下のようにする:"

#. type: lisp
#: original_texis/compile.texi:527
#, no-wrap
msgid ""
"(with-suppressed-warnings ((obsolete foo))\n"
"  (foo ...))\n"
msgstr ""
"(with-suppressed-warnings ((obsolete foo))\n"
"  (foo ...))\n"

#. type: Plain text
#: original_texis/compile.texi:532
msgid "For more coarse-grained suppression of compiler warnings, you can use the @code{with-no-warnings} construct:"
msgstr "コンパイラー警告の抑制をより粗く行うには@code{with-no-warnings}構文を使用できます:"

#. type: defspec
#: original_texis/compile.texi:536
#, no-wrap
msgid "with-no-warnings body@dots{}"
msgstr "with-no-warnings body@dots{}"

#. type: defspec
#: original_texis/compile.texi:540
msgid "In execution, this is equivalent to @code{(progn @var{body}...)}, but the compiler does not issue warnings for anything that occurs inside @var{body}."
msgstr "これは実行時には@code{(progn @var{body}...)}と等価だが、コンパイラーは@var{body}の中で起こるいかなる事項にたいしても警告を発しない。"

#. type: defspec
#: original_texis/compile.texi:545
msgid "We recommend that you use @code{with-suppressed-warnings} instead, but if you do use this construct, that you use it around the smallest possible piece of code to avoid missing possible warnings other than one you intend to suppress."
msgstr "わたしたちはかわりに@code{with-suppressed-warnings}の使用を推奨するが、この構文を使用する場合には、あなたが抑制したいと意図する警告以外の警告を失わないようにするために、可能な限り小さいコード断片にたいしてこの構文を使用すること。"

#. type: Plain text
#: original_texis/compile.texi:550
msgid "Byte compiler warnings can be controlled more precisely by setting the variable @code{byte-compile-warnings}.  See its documentation string for details."
msgstr "変数@code{byte-compile-warnings}をセットすることにより、コンパイラーの警告をより詳細に制御できます。詳細は変数のドキュメント文字列を参照してください。"

#. type: vindex
#: original_texis/compile.texi:551
#, no-wrap
msgid "byte-compile-error-on-warn"
msgstr "byte-compile-error-on-warn"

#. type: Plain text
#: original_texis/compile.texi:555
msgid "Sometimes you may wish the byte-compiler warnings to be reported using @code{error}.  If so, set @code{byte-compile-error-on-warn} to a non-@code{nil} value."
msgstr "@code{error}を使用してバイトコンパイラーの警告が報告されることを望む場合があるかもしれません。そのような場合には@code{byte-compile-error-on-warn}を非@code{nil}値にセットしてください。"

#. type: section
#: original_texis/compile.texi:557
#, no-wrap
msgid "Byte-Code Function Objects"
msgstr "Byte-Code Function Objects"

#. type: cindex
#: original_texis/compile.texi:558
#, no-wrap
msgid "compiled function"
msgstr "compiled function"

#. type: cindex
#: original_texis/compile.texi:559
#, no-wrap
msgid "byte-code function"
msgstr "byte-code function"

#. type: cindex
#: original_texis/compile.texi:560
#, no-wrap
msgid "byte-code object"
msgstr "byte-code object"

#. type: Plain text
#: original_texis/compile.texi:566
msgid "Byte-compiled functions have a special data type: they are @dfn{byte-code function objects}.  Whenever such an object appears as a function to be called, Emacs uses the byte-code interpreter to execute the byte-code."
msgstr "バイトコンパイルされた関数は、@dfn{バイトコード関数オブジェクト(byte-code function objects)}という特別なデータ型をもちます。関数呼び出しとしてそのようなオブジェクトが出現したとき、Emacsはそのバイトコードを実行するために、常にバイトコードインタープリターを使用します。"

#. type: Plain text
#: original_texis/compile.texi:573
msgid "Internally, a byte-code function object is much like a vector; its elements can be accessed using @code{aref}.  Its printed representation is like that for a vector, with an additional @samp{#} before the opening @samp{[}.  It must have at least four elements; there is no maximum number, but only the first six elements have any normal use.  They are:"
msgstr "内部的にはバイトコード関数オブジェクトはベクターとよく似ています。バイトコード関数オブジェクトの要素には@code{aref}を通じてアクセスできます。バイトコード関数オブジェクトのプリント表現(printed representation)はベクターと似ていて、開き@samp{[}の前に@samp{#}が追加されます。バイト関数オブジェクトは少なくとも4つの要素をもたねばならず、その要素数に上限はありません。しかし通常使用されるのは最初の6要素です。これらは:"

#. type: item
#: original_texis/compile.texi:575
#, no-wrap
msgid "argdesc"
msgstr "argdesc"

#. type: table
#: original_texis/compile.texi:583
msgid "The descriptor of the arguments.  This can either be a list of arguments, as described in @ref{Argument List}, or an integer encoding the required number of arguments.  In the latter case, the value of the descriptor specifies the minimum number of arguments in the bits zero to 6, and the maximum number of arguments in bits 8 to 14.  If the argument list uses @code{&rest}, then bit 7 is set; otherwise it's cleared."
msgstr "引数の記述子(descriptor)。これは@ref{Argument List}で説明されるような引数のリスト、または要求される引数の個数をエンコードする整数のいずれかである。後者の場合、その記述子の値は0ビットから6ビットで引数の最小個数、8ビットから14ビットで引数の最大個数を指定する。引数リストが@code{&rest}を使用するなら7ビットがセットされて、それい以外ならクリアーされる。"

#. type: table
#: original_texis/compile.texi:588
msgid "If @var{argdesc} is a list, the arguments will be dynamically bound before executing the byte code.  If @var{argdesc} is an integer, the arguments will be instead pushed onto the stack of the byte-code interpreter, before executing the code."
msgstr "@var{argdesc}がリストなら、そのバイトコード実行前に引数はダイナミックにバインドされる。@var{argdesc}が整数なら、引数リストはそのバイトコード実行前にバイトコーピンタープリンターのスタックにpushされる。"

#. type: table
#: original_texis/compile.texi:591
msgid "The string containing the byte-code instructions."
msgstr "バイトコード命令を含む文字列。"

#. type: item
#: original_texis/compile.texi:592
#, no-wrap
msgid "constants"
msgstr "constants"

#. type: table
#: original_texis/compile.texi:595
msgid "The vector of Lisp objects referenced by the byte code.  These include symbols used as function names and variable names."
msgstr "バイトコードにより参照されるLispオブジェクトのベクター。関数名と変数名に使用されるシンボルが含まれる。"

#. type: item
#: original_texis/compile.texi:596
#, no-wrap
msgid "stacksize"
msgstr "stacksize"

#. type: table
#: original_texis/compile.texi:598
msgid "The maximum stack size this function needs."
msgstr "この関数が要するスタックの最大サイズ。"

#. type: item
#: original_texis/compile.texi:599
#, no-wrap
msgid "docstring"
msgstr "docstring"

#. type: table
#: original_texis/compile.texi:604
msgid "The documentation string (if any); otherwise, @code{nil}.  The value may be a number or a list, in case the documentation string is stored in a file.  Use the function @code{documentation} to get the real documentation string (@pxref{Accessing Documentation})."
msgstr "(もしあれば)ドキュメント文字列。それ以外は@code{nil}。ドキュメント文字列がファイルに格納されている場合、値は数字かリストかもしれない。本当のドキュメント文字列の取得には、関数@code{documentation}を使用する(@ref{Accessing Documentation}を参照)。"

#. type: item
#: original_texis/compile.texi:605
#, no-wrap
msgid "interactive"
msgstr "interactive"

#. type: table
#: original_texis/compile.texi:608
msgid "The interactive spec (if any).  This can be a string or a Lisp expression.  It is @code{nil} for a function that isn't interactive."
msgstr "(もしあれば)インタラクティブ仕様。文字列かLisp式。インタラクティブでない関数では@code{nil}。"

#. type: Plain text
#: original_texis/compile.texi:613
msgid "Here's an example of a byte-code function object, in printed representation.  It is the definition of the command @code{backward-sexp}."
msgstr "以下はバイトコード関数オブジェクトのプリント表現の例です。これはコマンド@code{backward-sexp}の定義です。"

#. type: example
#: original_texis/compile.texi:621
#, no-wrap
msgid ""
"#[256\n"
"  \"\\211\\204^G^@@\\300\\262^A\\301^A[!\\207\"\n"
"  [1 forward-sexp]\n"
"  3\n"
"  1793299\n"
"  \"^p\"]\n"
msgstr ""
"#[256\n"
"  \"\\211\\204^G^@@\\300\\262^A\\301^A[!\\207\"\n"
"  [1 forward-sexp]\n"
"  3\n"
"  1793299\n"
"  \"^p\"]\n"

#. type: Plain text
#: original_texis/compile.texi:625
msgid "The primitive way to create a byte-code object is with @code{make-byte-code}:"
msgstr "バイトコードオブジェクトを作成するプリミティブな方法は@code{make-byte-code}です:"

#. type: defun
#: original_texis/compile.texi:626
#, no-wrap
msgid "make-byte-code &rest elements"
msgstr "make-byte-code &rest elements"

#. type: defun
#: original_texis/compile.texi:629
msgid "This function constructs and returns a byte-code function object with @var{elements} as its elements."
msgstr "この関数は@var{elements}を要素とするバイトコードオブジェクトを構築してリターンする。"

#. type: Plain text
#: original_texis/compile.texi:635
msgid "You should not try to come up with the elements for a byte-code function yourself, because if they are inconsistent, Emacs may crash when you call the function.  Always leave it to the byte compiler to create these objects; it makes the elements consistent (we hope)."
msgstr "あなた自身で要素を収集してバイトコード関数を構築しないでください。それらが矛盾する場合、その関数の呼び出しによりEmacsがクラッシュするかもしれません。これらのオブジェクトの作成は常にバイトコンパイラーにまかせてください。(願わくば)バイトコンパイラーは要素を矛盾なく構築します。"

#. type: section
#: original_texis/compile.texi:637
#, no-wrap
msgid "Disassembled Byte-Code"
msgstr "Disassembled Byte-Code"

#. type: cindex
#: original_texis/compile.texi:638
#, no-wrap
msgid "disassembled byte-code"
msgstr "disassembled byte-code"

#. type: Plain text
#: original_texis/compile.texi:644
msgid "People do not write byte-code; that job is left to the byte compiler.  But we provide a disassembler to satisfy a cat-like curiosity.  The disassembler converts the byte-compiled code into human-readable form."
msgstr "人はバイトコードを記述しません。それはバイトコンパイラーの仕事です。しかし好奇心を満たすために、わたしたちはディスアセンブラを提供しています。ディスアセンブラはバイトコードを人間が読めるフォームに変換します。"

#. type: Plain text
#: original_texis/compile.texi:650
msgid "The byte-code interpreter is implemented as a simple stack machine.  It pushes values onto a stack of its own, then pops them off to use them in calculations whose results are themselves pushed back on the stack.  When a byte-code function returns, it pops a value off the stack and returns it as the value of the function."
msgstr "バイトコードインタープリターは、シンプルなスタックマシンとして実装されています。これは値を自身のスタックにpushして、計算で使用するためにそれらをpopして取り出し、その結果を再びそのスタックにpushして戻します。バイトコード関数がリターンするときは、スタックから値をpopして取り出し、その関数の値としてリターンします。"

#. type: Plain text
#: original_texis/compile.texi:654
msgid "In addition to the stack, byte-code functions can use, bind, and set ordinary Lisp variables, by transferring values between variables and the stack."
msgstr "それに加えてスタックとバイトコード関数は、値を変数とスタック間で転送することにより、普通のLisp変数を使用したり、バインドやセットを行うことができます。"

#. type: deffn
#: original_texis/compile.texi:655
#, no-wrap
msgid "Command disassemble object &optional buffer-or-name"
msgstr "Command disassemble object &optional buffer-or-name"

#. type: deffn
#: original_texis/compile.texi:662
msgid "This command displays the disassembled code for @var{object}.  In interactive use, or if @var{buffer-or-name} is @code{nil} or omitted, the output goes in a buffer named @file{*Disassemble*}.  If @var{buffer-or-name} is non-@code{nil}, it must be a buffer or the name of an existing buffer.  Then the output goes there, at point, and point is left before the output."
msgstr "このコマンドは@var{object}にたいするディスアセンブルされたコードを表示する。インタラクティブに使用した場合、または@var{buffer-or-name}が@code{nil}か省略された場合は、@file{*Disassemble*}という名前のバッファーに出力します。@var{buffer-or-name}が非@code{nil}なら、それはバッファーもしくは既存のバッファーの名前でなければならない。その場合は、そのバッファーのポイント位置に出力され、ポイントは出力の前に残りされる。"

#. type: deffn
#: original_texis/compile.texi:667
msgid "The argument @var{object} can be a function name, a lambda expression (@pxref{Lambda Expressions}), or a byte-code object (@pxref{Byte-Code Objects}).  If it is a lambda expression, @code{disassemble} compiles it and disassembles the resulting compiled code."
msgstr "引数@var{object}には関数名、ラムダ式(@ref{Lambda Expressions}を参照)、またはバイトコードオブジェクト(@ref{Byte-Code Objects}を参照)を指定できる。ラムダ式なら@code{disassemble}はそれをコンパイルしてから、そのコンパイル済みコードをディスアセンブルする。"

#. type: Plain text
#: original_texis/compile.texi:672
msgid "Here are two examples of using the @code{disassemble} function.  We have added explanatory comments to help you relate the byte-code to the Lisp source; these do not appear in the output of @code{disassemble}."
msgstr "以下に@code{disassemble}関数を使用した例を2つ示します。バイトコードとLispソースを関連付ける助けとなるように、説明的なコメントを追加してあります。これらのコメントは@code{disassemble}の出力にはありません。"

#. type: group
#: original_texis/compile.texi:680
#, no-wrap
msgid ""
"(defun factorial (integer)\n"
"  \"Compute factorial of an integer.\"\n"
"  (if (= 1 integer) 1\n"
"    (* integer (factorial (1- integer)))))\n"
"     @result{} factorial\n"
msgstr ""
"(defun factorial (integer)\n"
"  \"Compute factorial of an integer.\"\n"
"  (if (= 1 integer) 1\n"
"    (* integer (factorial (1- integer)))))\n"
"     @result{} factorial\n"

#. type: group
#: original_texis/compile.texi:685
#, no-wrap
msgid ""
"(factorial 4)\n"
"     @result{} 24\n"
msgstr ""
"(factorial 4)\n"
"     @result{} 24\n"

#. type: group
#: original_texis/compile.texi:692
#, no-wrap
msgid ""
"(disassemble 'factorial)\n"
"     @print{} byte-code for factorial:\n"
" doc: Compute factorial of an integer.\n"
" args: (integer)\n"
msgstr ""
"(disassemble 'factorial)\n"
"     @print{} byte-code for factorial:\n"
" doc: Compute factorial of an integer.\n"
" args: (integer)\n"

#. type: group
#: original_texis/compile.texi:698
#, no-wrap
msgid ""
"0   varref   integer      ; @r{Get the value of @code{integer} and}\n"
"                          ;   @r{push it onto the stack.}\n"
"1   constant 1            ; @r{Push 1 onto stack.}\n"
msgstr ""
"0   varref   integer      ; @r{@code{integer}の値を取得して}\n"
"                          ;   @r{それをスタック上にpushする}\n"
"1   constant 1            ; @r{スタック上に1をpushする}\n"

#. type: group
#: original_texis/compile.texi:702
#, no-wrap
msgid ""
"2   eqlsign               ; @r{Pop top two values off stack, compare}\n"
"                          ;   @r{them, and push result onto stack.}\n"
msgstr ""
"2   eqlsign               ; @r{2つの値をスタックからpopして取り出し、}\n"
"                          ;   @r{それらを比較して結果をスタック上にpushする}\n"

#. type: group
#: original_texis/compile.texi:708
#, no-wrap
msgid ""
"3   goto-if-nil 1         ; @r{Pop and test top of stack;}\n"
"                          ;   @r{if @code{nil}, go to 1, else continue.}\n"
"6   constant 1            ; @r{Push 1 onto top of stack.}\n"
"7   return                ; @r{Return the top element of the stack.}\n"
msgstr ""
"3   goto-if-nil 1         ; @r{スタックのトップをpopしてテストする}\n"
"                          ;   @r{@code{nil}なら1へ、それ以外はcontinue}\n"
"6   constant 1            ; @r{スタックのトップに1をpushする}\n"
"7   return                ; @r{スタックのトップの要素をリターンする}\n"

#. type: group
#: original_texis/compile.texi:718
#, no-wrap
msgid ""
"8:1 varref   integer      ; @r{Push value of @code{integer} onto stack.}\n"
"9   constant factorial    ; @r{Push @code{factorial} onto stack.}\n"
"10  varref   integer      ; @r{Push value of @code{integer} onto stack.}\n"
"11  sub1                  ; @r{Pop @code{integer}, decrement value,}\n"
"                          ;   @r{push new value onto stack.}\n"
"12  call     1            ; @r{Call function @code{factorial} using first}\n"
"                          ;   @r{(i.e., top) stack element as argument;}\n"
"                          ;   @r{push returned value onto stack.}\n"
msgstr ""
"8:1 varref   integer      ; @r{@code{integer}の値をスタック上にpushする}\n"
"9   constant factorial    ; @r{@code{factorial}をスタック上にpushする}\n"
"10  varref   integer      ; @r{@code{integer}の値をスタック上にpushする}\n"
"11  sub1                  ; @r{@code{integer}をpopして値をデクリメントする}\n"
"                          ;   @r{スタック上に新しい値をpushする}\n"
"12  call     1            ; @r{スタックの最初(トップ)の要素を引数として}\n"
"                          ;   @r{関数@code{factorial}を呼び出す}\n"
"                          ;   @r{リターン値をスタック上にpushする}\n"

#. type: group
#: original_texis/compile.texi:723
#, no-wrap
msgid ""
"13 mult                   ; @r{Pop top two values off stack, multiply}\n"
"                          ;   @r{them, and push result onto stack.}\n"
"14 return                 ; @r{Return the top element of the stack.}\n"
msgstr ""
"13 mult                   ; @r{スタックのトップ2要素をpopして取り出し乗じ}\n"
"                          ;   @r{結果をスタック上にpushする}\n"
"14 return                 ; @r{スタックのトップ要素をリターンする}\n"

#. type: Plain text
#: original_texis/compile.texi:727
msgid "The @code{silly-loop} function is somewhat more complex:"
msgstr "@code{silly-loop}は幾分複雑です:"

#. type: group
#: original_texis/compile.texi:737
#, no-wrap
msgid ""
"(defun silly-loop (n)\n"
"  \"Return time before and after N iterations of a loop.\"\n"
"  (let ((t1 (current-time-string)))\n"
"    (while (> (setq n (1- n))\n"
"              0))\n"
"    (list t1 (current-time-string))))\n"
"     @result{} silly-loop\n"
msgstr ""
"(defun silly-loop (n)\n"
"  \"Return time before and after N iterations of a loop.\"\n"
"  (let ((t1 (current-time-string)))\n"
"    (while (> (setq n (1- n))\n"
"              0))\n"
"    (list t1 (current-time-string))))\n"
"     @result{} silly-loop\n"

#. type: group
#: original_texis/compile.texi:744
#, no-wrap
msgid ""
"(disassemble 'silly-loop)\n"
"     @print{} byte-code for silly-loop:\n"
" doc: Return time before and after N iterations of a loop.\n"
" args: (n)\n"
msgstr ""
"(disassemble 'silly-loop)\n"
"     @print{} byte-code for silly-loop:\n"
" doc: Return time before and after N iterations of a loop.\n"
" args: (n)\n"

#. type: group
#: original_texis/compile.texi:749
#, no-wrap
msgid ""
"0   constant current-time-string  ; @r{Push @code{current-time-string}}\n"
"                                  ;   @r{onto top of stack.}\n"
msgstr ""
"0   constant current-time-string  ; @r{@code{current-time-string}を}\n"
"                                  ;   @r{スタック上のトップにpushする}\n"

#. type: group
#: original_texis/compile.texi:753
#, no-wrap
msgid ""
"1   call     0            ; @r{Call @code{current-time-string} with no}\n"
"                          ;   @r{argument, push result onto stack.}\n"
msgstr ""
"1   call     0            ; @r{引数なしで@code{current-time-string}を呼び出し}\n"
"                          ;   @r{結果をスタック上にpushする}\n"

#. type: group
#: original_texis/compile.texi:756
#, no-wrap
msgid "2   varbind  t1           ; @r{Pop stack and bind @code{t1} to popped value.}\n"
msgstr "2   varbind  t1           ; @r{スタックをpopして@code{t1}にpopされた値をバインドする}\n"

#. type: group
#: original_texis/compile.texi:761
#, no-wrap
msgid ""
"3:1 varref   n            ; @r{Get value of @code{n} from the environment}\n"
"                          ;   @r{and push the value on the stack.}\n"
"4   sub1                  ; @r{Subtract 1 from top of stack.}\n"
msgstr ""
"3:1 varref   n            ; @r{環境から@code{n}の値を取得して}\n"
"                          ;   @r{その値をスタック上にpushする}\n"
"4   sub1                  ; @r{スタックのトップから1を減ずる}\n"

#. type: group
#: original_texis/compile.texi:767
#, no-wrap
msgid ""
"5   dup                   ; @r{Duplicate top of stack; i.e., copy the top}\n"
"                          ;   @r{of the stack and push copy onto stack.}\n"
"6   varset   n            ; @r{Pop the top of the stack,}\n"
"                          ;   @r{and bind @code{n} to the value.}\n"
"\n"
msgstr ""
"5   dup                   ; @r{スタックのトップを複製する}\n"
"                          ;   @r{たとえばスタックのトップをコピーしてスタック上にpushする}\n"
"6   varset   n            ; @r{スタックのトップをpopして}\n"
"                          ;   @r{@code{n}をその値にバインドする}\n"
"\n"

#. type: group
#: original_texis/compile.texi:770
#, no-wrap
msgid ""
";; @r{(In effect, the sequence @code{dup varset} copies the top of the stack}\n"
";; @r{into the value of @code{n} without popping it.)}\n"
msgstr ""
";; @r{(要はシーケンス@code{dup varset}はpopせずに}\n"
";; @r{ スタックのトップを@code{n}の値にコピーする)}\n"

#. type: group
#: original_texis/compile.texi:777
#, no-wrap
msgid ""
"7   constant 0            ; @r{Push 0 onto stack.}\n"
"8   gtr                   ; @r{Pop top two values off stack,}\n"
"                          ;   @r{test if @var{n} is greater than 0}\n"
"                          ;   @r{and push result onto stack.}\n"
msgstr ""
"7   constant 0            ; @r{スタック上に0をpushする}\n"
"8   gtr                   ; @r{スタックのトップ2値をpopして取り出し}\n"
"                          ;   @r{@var{n}が0より大かテストし}\n"
"                          ;   @r{結果をスタック上にpushする}\n"

#. type: group
#: original_texis/compile.texi:782
#, no-wrap
msgid ""
"9   goto-if-not-nil 1     ; @r{Goto 1 if @code{n} > 0}\n"
"                          ;   @r{(this continues the while loop)}\n"
"                          ;   @r{else continue.}\n"
msgstr ""
"9   goto-if-not-nil 1     ; @r{@code{n} > 0なら1へ}\n"
"                          ;   @r{(これはwhile-loopを継続する)}\n"
"                          ;   @r{それ以外はcontinue}\n"

#. type: group
#: original_texis/compile.texi:788
#, no-wrap
msgid ""
"12  varref   t1           ; @r{Push value of @code{t1} onto stack.}\n"
"13  constant current-time-string  ; @r{Push @code{current-time-string}}\n"
"                                  ;   @r{onto the top of the stack.}\n"
"14  call     0            ; @r{Call @code{current-time-string} again.}\n"
msgstr ""
"12  varref   t1           ; @r{@code{t1}の値をスタック上にpushする}\n"
"13  constant current-time-string  ; @r{@code{current-time-string}を}\n"
"                                  ;   @r{スタックのトップにpushする}\n"
"14  call     0            ; @r{再度@code{current-time-string}を呼び出す}\n"

#. type: group
#: original_texis/compile.texi:794
#, no-wrap
msgid ""
"15  unbind   1            ; @r{Unbind @code{t1} in local environment.}\n"
"16  list2                 ; @r{Pop top two elements off stack, create a}\n"
"                          ;   @r{list of them, and push it onto stack.}\n"
"17  return                ; @r{Return value of the top of stack.}\n"
msgstr ""
"15  unbind   1            ; @r{ローカル環境の@code{t1}をアンバインドする}\n"
"16  list2                 ; @r{スタックのトップ2要素をpopして取り出し}\n"
"                          ;   @r{それらのリストを作りスタック上にpushする}\n"
"17  return                ; @r{スタックのトップの値をリターンする}\n"

#. type: node
#: original_texis/compile.texi:797
#, no-wrap
msgid "Native Compilation"
msgstr "Native Compilation"

#. type: chapter
#: original_texis/compile.texi:798
#, no-wrap
msgid "Compilation of Lisp to Native Code"
msgstr "Compilation of Lisp to Native Code"

#. type: cindex
#: original_texis/compile.texi:799
#, no-wrap
msgid "native compilation"
msgstr "native compilation"

#. type: cindex
#: original_texis/compile.texi:800
#, no-wrap
msgid "compilation to native code (Emacs Lisp)"
msgstr "compilation to native code (Emacs Lisp)"

#. type: cindex
#: original_texis/compile.texi:802
#, no-wrap
msgid "native code"
msgstr "lispref/commands.texi.po"

#. type: Plain text
#: original_texis/compile.texi:811
msgid "In addition to the byte-compilation, described in @ref{Byte Compilation, the previous chapter}, Emacs can also optionally compile Lisp function definitions into a true compiled code, known as @dfn{native code}.  This feature uses the @file{libgccjit} library, which is part of the GCC distribution, and requires that Emacs be built with support for using that library.  It also requires to have GCC and Binutils (the assembler and linker) available on your system for you to be able to native-compile Lisp code."
msgstr "@ref{Byte Compilation, the previous chapter}で述べたバイトコンパイルに加えて、EmacsではオプションでLisp関数定義を@dfn{ネイティブコード(native code)}として知られている真のコンパイル済みコードにコンパイルすることもできます。この機能はGCCディストリビューションの一部である@file{libgccjit}を使用しており、そのライブラリー使用のサポートと共にEmacsがビルドされている必要があります。更にLispコードをネイティブコンパイルするために、システムにGCCとBinutils(アセンブラとリンカ)がインストールされている必要があります。"

#. type: vindex
#: original_texis/compile.texi:812
#, no-wrap
msgid "native-compile@r{, a Lisp feature}"
msgstr "native-compile@r{, a Lisp feature}"

#. type: Plain text
#: original_texis/compile.texi:816
msgid "To determine whether the current Emacs process can produce and load natively-compiled Lisp code, call @code{native-comp-available-p} (@pxref{Native-Compilation Functions})."
msgstr "Emacsのカレントプロセスでネイティブコンパイル済みLispコードの生成およびロードが可能かどうか判断するには、@code{native-comp-available-p} (@ref{Native-Compilation Functions}を参照)を呼び出してください。"

#. type: Plain text
#: original_texis/compile.texi:822
msgid "Unlike byte-compiled code, natively-compiled Lisp code is executed directly by the machine's hardware, and therefore runs at full speed that the host CPU can provide.  The resulting speedup generally depends on what the Lisp code does, but is usually 2.5 to 5 times faster than the corresponding byte-compiled code."
msgstr "バイトコンパイル済みコードとは異なり、ネイティブコンパイル済みLispコードはマシンのハードウェアにより直接実行されるので、ホストCPUが提供できる最高スピードで実行されます。このスピードアップの結果は一般的にはそのLispコードが何を行うかに依りますが、対応するバイトコンパイル済みコードに比べて、通常は2.5から5倍高速になります。"

#. type: Plain text
#: original_texis/compile.texi:830
msgid "Since native code is generally incompatible between different systems, the natively-compiled code is @emph{not} transportable from one machine to another, it can only be used on the same machine where it was produced or on very similar ones (having the same CPU and run-time libraries).  The transportability of natively-compiled code is the same as that of shared libraries (@file{.so} or @file{.dll} files)."
msgstr "一般的に異なるシステム間ではネイティブコードに互換性はないので、あるマシンから別のマシンへのネイティブコンパイル済みコードの可搬性は@emph{ありません}。ネイティブコンパイル済みコードはそれを生成したのと同じマシン、もしくは類似のマシン(同一のCPUおよびランタイムライブラリー)でのみ使用できます。ネイティブコンパイル済みコードの可搬性は、共有ライブラリー(@file{.so}や@file{.dll}のファイル)の可搬性と同様です。"

#. type: Plain text
#: original_texis/compile.texi:841
msgid "Libraries of natively-compiled code include crucial dependencies on Emacs Lisp primitives (@pxref{What Is a Function}) and their calling conventions, and thus Emacs usually won't load natively-compiled code produced by earlier or later Emacs versions; native compilation of the same Lisp code by a different Emacs version will usually produce a natively-compiled library under a unique file name that only that version of Emacs will be able to load.  However, the use of unique file names allows to have in the same directory several versions of the same Lisp library natively-compiled by several different versions of Emacs."
msgstr "ネイティブコンパイル済みコードのライブラリーにはEmacs Lispプリミティブ(@ref{What Is a Function}を参照)とそれらの呼び出し規約に関して重大な依存性が含まれているので、Emacsは通常はバージョンの異なるEmacsが生成したネイティブコンパイル済みコードをロードしません。同一のLispコードで異なるバージョンのEmacsがネイティブコンパイルしたコードは、ネイティブコンパイル済みライブラリーをそのバージョンのEmacsだけがロードできる一意なファイル名で生成します。しかし一意なファイル名の使用により、複数の異なるバージョンのEmacsによりネイティブコンパイルされた同一ライブラリーが、同一ディレクトリーに存在することになります。"

#. type: vindex
#: original_texis/compile.texi:842
#, no-wrap
msgid "no-native-compile"
msgstr "no-native-compile"

#. type: Plain text
#: original_texis/compile.texi:849
msgid "A non-@code{nil} file-local variable binding of @code{no-byte-compile} (@pxref{Byte Compilation}) also disables the native compilation of that file.  In addition, a similar variable @code{no-native-compile} disables just the native compilation of the file.  If both @code{no-byte-compile} and @code{no-native-compile} are specified, the former takes precedence."
msgstr "ファイルローカル変数として@code{no-byte-compile}に非@code{nil}をバインドしても、そのファイルのネイティブコンパイルが無効になります。加えて同様の変数@code{no-native-compile}は、ファイルのネイティブコンパイルだけを無効にします。@code{no-byte-compile}と@code{no-native-compile}の両方が指定された場合には、前者が優先されます。"

#. type: section
#: original_texis/compile.texi:853 original_texis/compile.texi:855
#: original_texis/compile.texi:856
#, no-wrap
msgid "Native-Compilation Functions"
msgstr "Native-Compilation Functions"

#. type: menuentry
#: original_texis/compile.texi:853
msgid "Functions to natively-compile Lisp."
msgstr "Lispをネイティブコンパイルする関数。"

#. type: section
#: original_texis/compile.texi:853 original_texis/compile.texi:973
#: original_texis/compile.texi:974
#, no-wrap
msgid "Native-Compilation Variables"
msgstr "Native-Compilation Variables"

#. type: menuentry
#: original_texis/compile.texi:853
msgid "Variables controlling native compilation."
msgstr "ネイティブコンパイルを制御する変数。"

#. type: cindex
#: original_texis/compile.texi:857
#, no-wrap
msgid "native-compilation functions"
msgstr "native-compilation functions"

#. type: Plain text
#: original_texis/compile.texi:865
msgid "Native-Compilation is implemented as a side effect of byte-compilation (@pxref{Byte Compilation}).  Thus, compiling Lisp code natively always produces its byte code as well, and therefore all the rules and caveats of preparing Lisp code for byte compilation (@pxref{Compilation Functions}) are valid for native-compilation as well."
msgstr "ネイティブコンパイルはバイトコンパイル(@ref{Byte Compilation}を参照)の副作用として実装されています。したがってLispコードをネイティブコンパイルすると、同様にバイトコードが常に生成されるため、バイトコンパイル用にLispコードを準備する際の規則や注意事項(@ref{Compilation Functions}を参照)は、ネイティブコンパイルでも同じようにすべて有効です。"

#. type: Plain text
#: original_texis/compile.texi:871
msgid "You can natively-compile either a single function or macro definition, or a whole file of Lisp code, with the @code{native-compile} function.  Natively-compiling a file will produce both the corresponding @file{.elc} file with byte code and the @file{.eln} file with native code."
msgstr "@code{native-compile}関数により単一の関数やマクロ、あるいはLispコードのファイル全体をネイティブコンパイルできます。ファイルをネイティブコンパイルすると、それに対応するバイトコードの@file{.elc}ファイルと、ネイティブコードの@file{.eln}ファイルの両方が生成されます。"

#. type: findex
#: original_texis/compile.texi:872
#, no-wrap
msgid "native-comp-limple-mode"
msgstr "native-comp-limple-mode"

#. type: defopt
#: original_texis/compile.texi:873 original_texis/compile.texi:1009
#, no-wrap
msgid "native-comp-verbose"
msgstr "native-comp-verbose"

#. type: Plain text
#: original_texis/compile.texi:882
msgid "Native compilation might produce warning or error messages; these are normally recorded in the buffer called @file{*Native-compile-Log*}.  In interactive sessions, it uses the special LIMPLE mode (@code{native-comp-limple-mode}), which sets up @code{font-lock} as appropriate for this log, and is otherwise the same as Fundamental mode.  Logging of messages resulting from native-compilation can be controlled by the @code{native-comp-verbose} variable (@pxref{Native-Compilation Variables})."
msgstr "ネイティブコンパイルでは警告やエラーが生成されるかもしれません。これらは通常は@file{*Native-compile-Log*}と呼ばれるバッファーに記録されます。このバッファーではインタラクティブなセッションではLIMPLEという特別なモードが使用されます。このモードではログにたいして適切な@code{font-lock}ロックをセットアップされて、それ以外はFundamentalモードと同じです。ネイティブコンパイルの結果メッセージのロギングは変数@code{native-comp-verbose}で制御できます(@ref{Native-Compilation Variables}を参照)。"

#. type: Plain text
#: original_texis/compile.texi:887
msgid "When Emacs is run non-interactively, messages produced by native-compilation are reported by calling @code{message} (@pxref{Displaying Messages}), and are usually displayed on the standard error stream of the terminal from which Emacs was invoked."
msgstr "Emacsが非インタラクティブに実行されている際には、ネイティブコンパイルによって生成されたメッセージは@code{message} (@ref{Displaying Messages}を参照)の呼び出しによって報告されます。これは通常はEmacsを呼び出した端末の標準エラーストリームに表示されます。"

#. type: defun
#: original_texis/compile.texi:888
#, no-wrap
msgid "native-compile function-or-file &optional output"
msgstr "native-compile function-or-file &optional output"

#. type: defun
#: original_texis/compile.texi:899
msgid "This function compiles @var{function-or-file} into native code.  The argument @var{function-or-file} can be a function symbol, a Lisp form, or a name (a string) of the file which contains the Emacs Lisp source code to compile.  If the optional argument @var{output} is provided, it must be a string specifying the name of the file to write the compiled code into.  Otherwise, if @var{function-or-file} is a function or a Lisp form, this function returns the compiled object, and if @var{function-or-file} is a file name, the function returns the full absolute name of the file it created for the compiled code.  The output file is by default given the @file{.eln} extension."
msgstr "この関数は@var{function-or-file}をネイティブコードにコンパイルする。引数@var{function-or-file}にはコンパイルする関数シンボル、Lispフォーム、またはEmacs Lispソースコードを含むファイル名(文字列)を指定できる。オプション引数@var{output}が与えられた場合には、コンパイル済みコードを書き込むファイルの名前を指定する文字列でなければならない。それ以外の場合には、@var{function-or-file}が関数かLispフォームならコンパイル済みオブジェクト、ファイル名ならコンパイル済みコード用に作成したファイルの完全な絶対ファイル名をリターンする。出力ファイルにはデフォルトで拡張子@file{.eln}が与えられる。"

#. type: defun
#: original_texis/compile.texi:904
msgid "This function runs the final phase of the native compilation, which invokes GCC via @file{libgccjit}, in a separate subprocess, which invokes the same Emacs executable as the process that called this function."
msgstr "この関数は@file{libgccjit}を通じて別のサブプロセス内でGCCを呼び出すネイティブコンパイルの最終フェーズを実行する。これはこの関数を呼び出したプロセスとして、同じEmacs実行可能形式を呼び出す。"

#. type: defun
#: original_texis/compile.texi:906
#, no-wrap
msgid "batch-native-compile &optional for-tarball"
msgstr "batch-native-compile &optional for-tarball"

#. type: defun
#: original_texis/compile.texi:920
msgid "This function runs native-compilation on files specified on the Emacs command line in batch mode.  It must be used only in a batch execution of Emacs, as it kills Emacs upon completion of the compilation.  If one or more of the files fail to compile, the Emacs process will attempt to compile all the other files, and will terminate with a non-zero status code.  The optional argument @var{for-tarball}, if non-@code{nil}, tells the function to place the resulting @file{.eln} files in the last directory mentioned in @code{native-comp-eln-load-path} (@pxref{Library Search}); this is meant to be used as part of building an Emacs source tarball for the first time, when the natively-compiled files, which are absent from the source tarball, should be generated in the build tree instead of the user's cache directory."
msgstr "この関数はbatchモードでEmacsのコマンドラインで指定されたファイルにたいしてネイティブコンパイルを実行する。これはコンパイル完了によりEmacsをkillするので、Emacsのバッチ実行でのみ使用しなければならない。1つ以上のファイルでコンパイルが失敗すると、Emacsプロセスはそれ以外のすべてのファイルのコンパイルを試みて、非0のexitステータスで終了する。オプション引数@var{for-tarball}が非@code{nil}なら、この関数はコンパイルした結果の@file{.eln}ファイルを@code{native-comp-eln-load-path}に記述された最後のディレクトリーに配置する(@ref{Library Search}を参照)。これは初回にEmacsソースtarballをビルドするときに、ソースtarballに含まれていないネイティブコンパイル済みファイルをユーザーのキャッシュディレクトリーではなくビルドツリー内に生成する必要がある際に使用されることを意図している。"

#. type: Plain text
#: original_texis/compile.texi:932
msgid "Native compilation can be run entirely asynchronously, in a subprocess of the main Emacs process.  This leaves the main Emacs process free to use while the compilation runs in the background.  This is the method used by Emacs to natively-compile any Lisp file or byte-compiled Lisp file that is loaded into Emacs, when no natively-compiled file for it is available.  Note that because of this use of a subprocess, native compilation may produce warning and errors which byte-compilation does not, and lisp code may thus need to be modified to work correctly.  See @code{native-comp-async-report-warnings-errors} in @pxref{Native-Compilation Variables} for more details."
msgstr "ネイティブコンパイルはメインのEmacsプロセスのサブプロセス中で、全体を非同期に実行できます。これによりバックグラウンドでコンパイルを実行する間、メインのEmacsプロセスをフリーにできます。これはEmacsにロードされた任意のLispファイルやバイトコンパイル済みLispファイルを、Emacsがネイティブコンパイルするために使用する手法です。サブプロセスをこのように使用することによって、ネイティブコンパイルではバイトコンパイルでは発生しない警告やエラーが生成されるかもしれず、それ故に正しく機能するようにLispコードの修整が必要かもしれないことに注意してください。詳細は@ref{Native-Compilation Variables}の@code{native-comp-async-report-warnings-errors}を参照してください。"

#. type: defun
#: original_texis/compile.texi:933
#, no-wrap
msgid "native-compile-async files &optional recursively load selector"
msgstr "native-compile-async files &optional recursively load selector"

#. type: defun
#: original_texis/compile.texi:943
msgid "This function compiles the named @var{files} asynchronously.  The argument @var{files} should be a single file name (a string) or a list of one or more file and/or directory names.  If directories are present in the list, the optional argument @var{recursively} should be non-@code{nil} to cause the compilation to recurse into those directories.  If @var{load} is non-@code{nil}, Emacs will load each file that it succeeded to compile.  The optional argument @var{selector} allows control of which of @var{files} will be compiled; it can have one of the following values:"
msgstr "この関数は@var{files}という名前のファイルを非同期にコンパイルする。引数@var{files}は単一のファイル名(文字列)、または1つ以上のファイルおよび/またはディレクトリー名のリストであること。このリスト中にディレクトリーが与えられた場合には、それらのディレクトリー内で再帰的にコンパイルするように、オプション引数@var{recursively}は非@code{nil}であること。@var{load}が非@code{nil}なら、Emacsはコンパイルが成功したそれぞれのファイルをロードする。オプション引数@var{selector}により@var{files}のどれをコンパイルするか制御できる。これには以下のいずれかの値を指定できる:"

#. type: item
#: original_texis/compile.texi:945
#, no-wrap
msgid "@code{nil} or omitted"
msgstr "@code{nil}または省略"

#. type: table
#: original_texis/compile.texi:947
msgid "Select all the files and directories in @var{files}."
msgstr "@var{files}内のすべてのファイルとディレクトリーを選択。"

#. type: item
#: original_texis/compile.texi:947
#, no-wrap
msgid "a regular expression string"
msgstr "正規表現文字列"

#. type: table
#: original_texis/compile.texi:949
msgid "Select the files and directories whose names match the regexp."
msgstr "このregexpに名前がマッチするファイルとディレクトリーを選択。"

#. type: item
#: original_texis/compile.texi:949
#, no-wrap
msgid "a function"
msgstr "関数"

#. type: table
#: original_texis/compile.texi:953
msgid "A predicate function, which will be called with each file and directory in @var{files}, and should return non-@code{nil} if the file or the directory should be selected for compilation."
msgstr "@var{files}内のファイルおよびディレクトリーそれぞれにたいして呼び出される述語関数。そのファイルまたはディレクトリーを選択する必要があるなら非@code{nil}をリターンすること。"

#. type: defun
#: original_texis/compile.texi:960
msgid "On systems with multiple CPU execution units, when @var{files} names more than one file, this function will normally start several compilation subprocesses in parallel, under the control of @code{native-comp-async-jobs-number} (@pxref{Native-Compilation Variables})."
msgstr "複数のCPU実行ユニットをもつシステムでは、この関数は@var{files}が複数のファイル名の際には、通常は@code{native-comp-async-jobs-number} (@ref{Native-Compilation Variables}を参照)の制御の下で複数のコンパイル用サブプロセスを並行で開始する。"

#. type: Plain text
#: original_texis/compile.texi:964
msgid "The following function allows Lisp programs to test whether native-compilation is available at runtime."
msgstr "以下の関数により、実行時にネイティブコンパイルが利用可能かどうかをLispプログラムがテストできます。"

#. type: defun
#: original_texis/compile.texi:965
#, no-wrap
msgid "native-comp-available-p"
msgstr "native-comp-available-p"

#. type: defun
#: original_texis/compile.texi:971
msgid "This function returns non-@code{nil} if the running Emacs process has the native-compilation support compiled into it.  On systems that load @file{libgccjit} dynamically, it also makes sure that library is available and can be loaded.  Lisp programs that need to know up front whether native-compilation is available should use this predicate."
msgstr "この関数は実行中のEmacsにネイティブコンパイルのサポートがコンパイルされていれば非@code{nil}をリターンする。@file{libgccjit}を動的にロードするシステムでは、ライブラリーｇ利用できロードできることも確認する。ネイティブコンパイルが利用可能か事前に知る必要があるLispプログラムはこの述語を使用すること。"

#. type: cindex
#: original_texis/compile.texi:975
#, no-wrap
msgid "native-compilation variables"
msgstr "native-compilation variables"

#. type: Plain text
#: original_texis/compile.texi:979
msgid "This section documents the variables that control native-compilation."
msgstr "このセクションではネイティブコンパイルを制御する変数について述べます。"

#. type: defopt
#: original_texis/compile.texi:980
#, no-wrap
msgid "native-comp-speed"
msgstr "native-comp-speed"

#. type: defopt
#: original_texis/compile.texi:988
msgid "This variable specifies the optimization level for native compilation.  Its value should be a number between @minus{}1 and 3.  Values between 0 and 3 specify the optimization levels equivalent to the corresponding compiler @option{-O0}, @option{-O1}, etc.@: command-line options of the compiler.  The value @minus{}1 means disable native-compilation; functions and files will be only byte-compiled.  The default value is 2."
msgstr "この変数はネイティブコンパイルの最適化レベルを指定する。値は@minus{}1から3の数値であること。値0から3はコンパイラーの対応する最適化レベル@option{-O0}、@option{-O1}、...のコマンドラインオプションと等しい。値@minus{}1はネイティブコンパイルの無効化を意味する。この場合には関数およびファイルはバイトコンパイルされる。デフォルト値は2。"

#. type: defopt
#: original_texis/compile.texi:990
#, no-wrap
msgid "native-comp-debug"
msgstr "native-comp-debug"

#. type: defopt
#: original_texis/compile.texi:994
msgid "This variable specifies the level of debugging information produced by native-compilation.  Its value should be a number between zero and 3, with the following meaning:"
msgstr "この変数はネイティブコンパイルが生成するデバッグ情報のレベルを指定する。値は0から3の数値で、以下のような意味をもつ:"

#. type: item
#: original_texis/compile.texi:996 original_texis/compile.texi:1018
#, no-wrap
msgid "0"
msgstr "0"

#. type: table
#: original_texis/compile.texi:998
msgid "No debugging output.  This is the default."
msgstr "デバッグ出力なし。これがデフォルト。"

#. type: item
#: original_texis/compile.texi:998 original_texis/compile.texi:1020
#, no-wrap
msgid "1"
msgstr "1"

#. type: table
#: original_texis/compile.texi:1001
msgid "Emit debugging symbols with the native code.  This allows easier debugging of the native code with debuggers such as @command{gdb}."
msgstr "ネイティブコードでデバッグシンボルを発行する。これは@command{gdb}のようなデバッガによるネイティブコードの電話を容易にする。"

#. type: item
#: original_texis/compile.texi:1001 original_texis/compile.texi:1022
#, no-wrap
msgid "2"
msgstr "2"

#. type: table
#: original_texis/compile.texi:1003
msgid "Like 1, and in addition dump pseudo-C code."
msgstr "1と同様だが、更に疑似Cコードをダンプする。"

#. type: item
#: original_texis/compile.texi:1003 original_texis/compile.texi:1025
#, no-wrap
msgid "3"
msgstr "3"

#. type: table
#: original_texis/compile.texi:1006
msgid "Like 2, and in addition dump the GCC intermediate passes and @file{libgccjit} log file."
msgstr "2と同様、更にGCC中間パス(GCC intermediate passes)と@file{libgccjit}ログファイルをダンプする。"

#. type: defopt
#: original_texis/compile.texi:1016
msgid "This variable controls the verbosity of native-compilation by suppressing some or all of the log messages emitted by it.  If its value is zero, the default, all of the log messages are suppressed.  Setting it to a value between 1 and 3 will allow logging of the messages whose level is above the value.  The values have the following interpretations:"
msgstr "この変数はネイティブコンパイルが発行する一部またはすべてのログメッセージを抑制することにより、ネイティブコンパイルの冗長性(verbosity)を制御する。値が0(デフォルト)なら、ログメッセージはすべて抑制される。1から3の値をセットすることにより、レベルが上述の値であるようなメッセージのロギングを可能にする。値には以下のような解釈がある:"

#. type: table
#: original_texis/compile.texi:1020
msgid "No logging.  This is the default."
msgstr "ログなし。これがデフォルト。"

#. type: table
#: original_texis/compile.texi:1022
msgid "Log the final @acronym{LIMPLE} representation of the code."
msgstr "コードの最終的な@acronym{LIMPLE}表現をログ。"

#. type: table
#: original_texis/compile.texi:1025
msgid "Log the @acronym{LAP}, the final @acronym{LIMPLE}, and some additional pass info."
msgstr "@acronym{LAP}、最終的な@acronym{LIMPLE}、および追加のパス情報をログ。"

#. type: table
#: original_texis/compile.texi:1027
msgid "Maximum verbosity: log everything."
msgstr "最大の冗長性。すべてをログ。"

#. type: defopt
#: original_texis/compile.texi:1030
#, no-wrap
msgid "native-comp-async-jobs-number"
msgstr "native-comp-async-jobs-number"

#. type: defopt
#: original_texis/compile.texi:1036
msgid "This variable determines the maximum number of native-compilation subprocesses that will be started simultaneously.  It should be a non-negative number.  The default value is zero, which means use half the number of the CPU execution units, or 1 if the CPU has only one execution unit."
msgstr "この変数は同時に開始するネイティブコンパイルのサブプロセスの最大数を決定する。非負の数値であること。デフォルト値0はCPU実行ユニットの半数の使用、1は単一の実行ユニットの使用を意味する。"

#. type: defopt
#: original_texis/compile.texi:1038
#, no-wrap
msgid "native-comp-async-report-warnings-errors"
msgstr "native-comp-async-report-warnings-errors"

#. type: defopt
#: original_texis/compile.texi:1045
msgid "If this variable's value is non-@code{nil}, warnings and errors from asynchronous native-compilation subprocesses are reported in the main Emacs session in a buffer named @file{*Warnings*}.  The default value @code{t} means display the resulting buffer.  To log warnings without popping up the @file{*Warnings*} buffer, set this variable to @code{silent}."
msgstr "この変数の値が非@code{nil}なら、ネイティブコンパイルの非同期サブプロセスからの警告とエラーは、メインのEmacsセッションの@file{*Warnings*}という名前のバッファーに報告される。デフォルト値の@code{t}はそのバッファーへの表示を意味する。@file{*Warnings*}バッファーをポップアップせずに警告をログするには、この変数に@code{silent}をセットすればよい。"

#. type: defopt
#: original_texis/compile.texi:1051
msgid "A common cause for asynchronous native-compilation to produce warnings is compiling a file that is missing some @code{require} of a necessary feature.  The feature may be loaded into the main emacs, but because native compilation always starts from a subprocess with a pristine environment, that may not be true for the subprocess."
msgstr "非同期ネイティブコンパイルで警告が生成されるのは、必要な機能にたいする@code{require}が欠落したファイルのコンパイルが原因であることが多い。この機能はメインのEmacsにロードされるかもしれないが、ネイティブコンパイルは常にサブプロセスから初期状態の環境で開始されるので、サブプロセスではロードされないかもしれない。"

#. type: defopt
#: original_texis/compile.texi:1053
#, no-wrap
msgid "native-comp-async-query-on-exit"
msgstr "native-comp-async-query-on-exit"

#. type: defopt
#: original_texis/compile.texi:1059
msgid "If this variable's value is non-nil, Emacs will query upon exiting whether to exit and kill any asynchronous native-compilation subprocesses that are still running, thus preventing the corresponding @file{.eln} files from being written.  If the value is @code{nil}, the default, Emacs will kill these subprocesses without querying."
msgstr "この変数の値が非nilなら、Emacsはexitに際して実行中のネイティブコンパイルの非同期サブプロセスをすべてkillしてexitするかどうかを尋ねる(対応する@file{.eln}ファイルへの書き込みを防ぐため)。値が@code{nil} (デフォルト)なら、Emacsは問い合わせを行わずにそれらのサブプロセスをkillする。"
