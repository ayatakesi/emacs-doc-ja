# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Emacs 24.5\n"
"POT-Creation-Date: 2019-10-14 22:47+0900\n"
"PO-Revision-Date: 2019-10-28 01:01+0900\n"
"Last-Translator: Takeshi Ayanokoji <takeshi.ayanokoji@gmail.com>\n"
"Language-Team: Japanese <takeshi.ayanokoji@gmail.com>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: original_texis/compile.texi:5 original_texis/compile.texi:6
#, no-wrap
msgid "Byte Compilation"
msgstr "Byte Compilation"

#. type: cindex
#: original_texis/compile.texi:7
#, no-wrap
msgid "byte compilation"
msgstr "byte compilation"

#. type: item
#: original_texis/compile.texi:8 original_texis/compile.texi:550
#, no-wrap
msgid "byte-code"
msgstr "byte-code"

#. type: cindex
#: original_texis/compile.texi:9
#, no-wrap
msgid "compilation (Emacs Lisp)"
msgstr "compilation (Emacs Lisp)"

#. type: Plain text
#: original_texis/compile.texi:16
msgid "Emacs Lisp has a @dfn{compiler} that translates functions written in Lisp into a special representation called @dfn{byte-code} that can be executed more efficiently.  The compiler replaces Lisp function definitions with byte-code.  When a byte-code function is called, its definition is evaluated by the @dfn{byte-code interpreter}."
msgstr "Emacs LispにはLispで記述された関数をより効率的に実行できる、@dfn{バイトコード(byte-code)}と呼ばれる特別な表現に翻訳する@dfn{コンパイラー(compiler)}があります。コンパイラーはLispの関数定義をバイトコードに置き換えます。バイトコード関数が呼び出されたとき、その定義は@dfn{バイトコードインタープリター(byte-code interpreter)}により評価されます。"

#. type: Plain text
#: original_texis/compile.texi:22
msgid "Because the byte-compiled code is evaluated by the byte-code interpreter, instead of being executed directly by the machine's hardware (as true compiled code is), byte-code is completely transportable from machine to machine without recompilation.  It is not, however, as fast as true compiled code."
msgstr "バイトコンパイルされたコードは、(本当のコンパイル済みコードのように)そのマシンのハードウェアによって直接実行されるのではなく、バイトコンパイラーによって評価されるため、バイトコードはリコンパイルしなくてもマシン間での完全な可搬性を有します。しかし本当にコンパイルされたコードほど高速ではありません。"

#. type: Plain text
#: original_texis/compile.texi:25
msgid "In general, any version of Emacs can run byte-compiled code produced by recent earlier versions of Emacs, but the reverse is not true."
msgstr "一般的に任意のバージョンのEmacsはそれ以前のバージョンのEmacsにより生成されたバイトコンパイル済みコードを実行できますが、その逆は成り立ちません。"

#. type: vindex
#: original_texis/compile.texi:26
#, no-wrap
msgid "no-byte-compile"
msgstr "no-byte-compile"

#. type: Plain text
#: original_texis/compile.texi:29
msgid "If you do not want a Lisp file to be compiled, ever, put a file-local variable binding for @code{no-byte-compile} into it, like this:"
msgstr "あるLispファイルを常にコンパイルせずに実行したい場合は、以下のように@code{no-byte-compile}をバインドするファイルローカル変数を配置します:"

#. type: example
#: original_texis/compile.texi:32
#, no-wrap
msgid ";; -*-no-byte-compile: t; -*-\n"
msgstr ";; -*-no-byte-compile: t; -*-\n"

#. type: node
#: original_texis/compile.texi:43 original_texis/compile.texi:45
#, no-wrap
msgid "Speed of Byte-Code"
msgstr "Speed of Byte-Code"

#. type: menuentry
#: original_texis/compile.texi:43
msgid "An example of speedup from byte compilation."
msgstr "バイトコンパイルによるスピードアップ例。"

#. type: node
#: original_texis/compile.texi:43 original_texis/compile.texi:82
#, no-wrap
msgid "Compilation Functions"
msgstr "Compilation Functions"

#. type: menuentry
#: original_texis/compile.texi:43
msgid "Byte compilation functions."
msgstr "バイトコンパイル関数。"

#. type: node
#: original_texis/compile.texi:43 original_texis/compile.texi:239
#, no-wrap
msgid "Docs and Compilation"
msgstr "Docs and Compilation"

#. type: menuentry
#: original_texis/compile.texi:43
msgid "Dynamic loading of documentation strings."
msgstr "ドキュメント文字列のダイナミックロード。"

#. type: node
#: original_texis/compile.texi:43 original_texis/compile.texi:287
#, no-wrap
msgid "Dynamic Loading"
msgstr "Dynamic Loading"

#. type: menuentry
#: original_texis/compile.texi:43
msgid "Dynamic loading of individual functions."
msgstr "個々の関数のダイナミックロード。"

#. type: node
#: original_texis/compile.texi:43 original_texis/compile.texi:348
#, no-wrap
msgid "Eval During Compile"
msgstr "Eval During Compile"

#. type: menuentry
#: original_texis/compile.texi:43
msgid "Code to be evaluated when you compile."
msgstr "コンパイル時に評価されるコード。"

#. type: section
#: original_texis/compile.texi:43 original_texis/compile.texi:430
#: original_texis/compile.texi:431
#, no-wrap
msgid "Compiler Errors"
msgstr "Compiler Errors"

#. type: menuentry
#: original_texis/compile.texi:43
msgid "Handling compiler error messages."
msgstr "コンパイラーのエラーメッセージの扱い。"

#. type: node
#: original_texis/compile.texi:43 original_texis/compile.texi:517
#, no-wrap
msgid "Byte-Code Objects"
msgstr "Byte-Code Objects"

#. type: menuentry
#: original_texis/compile.texi:43
msgid "The data type used for byte-compiled functions."
msgstr "バイトコンパイル済み関数に使用されるデータ型。"

#. type: node
#: original_texis/compile.texi:43 original_texis/compile.texi:597
#, no-wrap
msgid "Disassembly"
msgstr "Disassembly"

#. type: menuentry
#: original_texis/compile.texi:43
msgid "Disassembling byte-code; how to read byte-code."
msgstr "バイトコードの逆アセンブル; バイトコードの読み方。"

#. type: section
#: original_texis/compile.texi:46
#, no-wrap
msgid "Performance of Byte-Compiled Code"
msgstr "Performance of Byte-Compiled Code"

#. type: Plain text
#: original_texis/compile.texi:51
msgid "A byte-compiled function is not as efficient as a primitive function written in C, but runs much faster than the version written in Lisp.  Here is an example:"
msgstr "バイトコンパイルされた関数はCで記述されたプリミティブ関数ほど効率的ではありませんが、Lispで記述されたバージョンよりは高速に実行されます。以下は例です:"

#. type: group
#: original_texis/compile.texi:60
#, no-wrap
msgid ""
"(defun silly-loop (n)\n"
"  \"Return the time, in seconds, to run N iterations of a loop.\"\n"
"  (let ((t1 (float-time)))\n"
"    (while (> (setq n (1- n)) 0))\n"
"    (- (float-time) t1)))\n"
"@result{} silly-loop\n"
msgstr ""
"(defun silly-loop (n)\n"
"  \"Return the time, in seconds, to run N iterations of a loop.\"\n"
"  (let ((t1 (float-time)))\n"
"    (while (> (setq n (1- n)) 0))\n"
"    (- (float-time) t1)))\n"
"@result{} silly-loop\n"

#. type: group
#: original_texis/compile.texi:65
#, no-wrap
msgid ""
"(silly-loop 50000000)\n"
"@result{} 10.235304117202759\n"
msgstr ""
"(silly-loop 50000000)\n"
"@result{} 10.235304117202759\n"

#. type: group
#: original_texis/compile.texi:70
#, no-wrap
msgid ""
"(byte-compile 'silly-loop)\n"
"@result{} @r{[Compiled code not shown]}\n"
msgstr ""
"(byte-compile 'silly-loop)\n"
"@result{} @r{[コンパイルされたコードは表示されない]}\n"

#. type: group
#: original_texis/compile.texi:75
#, no-wrap
msgid ""
"(silly-loop 50000000)\n"
"@result{} 3.705854892730713\n"
msgstr ""
"(silly-loop 50000000)\n"
"@result{} 3.705854892730713\n"

#. type: Plain text
#: original_texis/compile.texi:81
msgid "In this example, the interpreted code required 10 seconds to run, whereas the byte-compiled code required less than 4 seconds.  These results are representative, but actual results may vary."
msgstr "この例ではインタープリターによる実行には10秒を要しますが、バイトコンパイルされたコードは4秒未満です。これは典型的な結果例ですが、実際の結果はさまざまでしょう。"

#. type: section
#: original_texis/compile.texi:83
#, no-wrap
msgid "Byte-Compilation Functions"
msgstr "Byte-Compilation Functions"

#. type: cindex
#: original_texis/compile.texi:84
#, no-wrap
msgid "compilation functions"
msgstr "compilation functions"

#. type: Plain text
#: original_texis/compile.texi:90
msgid "You can byte-compile an individual function or macro definition with the @code{byte-compile} function.  You can compile a whole file with @code{byte-compile-file}, or several files with @code{byte-recompile-directory} or @code{batch-byte-compile}."
msgstr "@code{byte-compile}により、関数やマクロを個別にバイトコンパイルできます。@code{byte-compile-file}でファイル全体、@code{byte-recompile-directory}または@code{batch-byte-compile}で複数ファイルをコンパイルできます。"

#. type: Plain text
#: original_texis/compile.texi:95
msgid "Sometimes, the byte compiler produces warning and/or error messages (@pxref{Compiler Errors}, for details).  These messages are recorded in a buffer called @file{*Compile-Log*}, which uses Compilation mode.  @xref{Compilation Mode,,,emacs, The GNU Emacs Manual}."
msgstr "バイトコンパイラーが警告、および/またはエラーメッセージを生成することもあります(詳細は@ref{Compiler Errors}を参照)。これらのメッセージはCompilationモードが使用する@file{*Compile-Log*}と呼ばれるバッファーに記録されます。@ref{Compilation Mode,,,emacs, The GNU Emacs Manual}を参照してください。"

#. type: cindex
#: original_texis/compile.texi:96
#, no-wrap
msgid "macro compilation"
msgstr "macro compilation"

#. type: Plain text
#: original_texis/compile.texi:109
msgid "Be careful when writing macro calls in files that you intend to byte-compile.  Since macro calls are expanded when they are compiled, the macros need to be loaded into Emacs or the byte compiler will not do the right thing.  The usual way to handle this is with @code{require} forms which specify the files containing the needed macro definitions (@pxref{Named Features}).  Normally, the byte compiler does not evaluate the code that it is compiling, but it handles @code{require} forms specially, by loading the specified libraries.  To avoid loading the macro definition files when someone @emph{runs} the compiled program, write @code{eval-when-compile} around the @code{require} calls (@pxref{Eval During Compile}).  For more details, @xref{Compiling Macros}."
msgstr "バイトコンパイルを意図したファイル内にマクロ呼び出しを記述する際には注意が必要です。マクロ呼び出しはコンパイル時に展開されるので、そのマクロはEmacsにロードされる必要があります(さもないとバイトコンパイラーが正しく処理しないだろう)。これを処理する通常の方法は、必要なマクロ定義を含むファイルを@code{require}フォームで指定することです。バイトコンパイラーは通常はコンパイルするコードを評価しませんが、@code{require}フォームは指定されたライブラリーをロードすることにより特別に扱われます。誰かがコンパイルされたプログラムを@emph{実行}する際にマクロ定義ファイルのロードを回避するためには、@code{require}呼び出しの周囲に@code{eval-when-compile}を記述します(@ref{Eval During Compile}を参照)。詳細は@ref{Compiling Macros}を参照してください。"

#. type: Plain text
#: original_texis/compile.texi:113
msgid "Inline (@code{defsubst}) functions are less troublesome; if you compile a call to such a function before its definition is known, the call will still work right, it will just run slower."
msgstr "インライン関数(@code{defsubst})はこれほど面倒ではありません。定義が判明する前にそのような関数呼び出しをコンパイルした場合でも、その呼び出しは低速になるだけで正しく機能するでしょう。"

#. type: defun
#: original_texis/compile.texi:114
#, no-wrap
msgid "byte-compile symbol"
msgstr "byte-compile symbol"

#. type: defun
#: original_texis/compile.texi:121
msgid "This function byte-compiles the function definition of @var{symbol}, replacing the previous definition with the compiled one.  The function definition of @var{symbol} must be the actual code for the function; @code{byte-compile} does not handle function indirection.  The return value is the byte-code function object which is the compiled definition of @var{symbol} (@pxref{Byte-Code Objects})."
msgstr "この関数は@var{symbol}の関数定義をバイトコンパイルして、以前の定義をコンパイルされた定義に置き換える。@var{symbol}の関数定義は、その関数にたいする実際のコードでなければならない。@code{byte-compile}はインダイレクト関数を処理しない。リターン値は、@var{symbol}のコンパイルされた定義であるようなバイトコード関数ブジェクト(@ref{Byte-Code Objects}を参照)。"

#. type: group
#: original_texis/compile.texi:129
#, no-wrap
msgid ""
"(defun factorial (integer)\n"
"  \"Compute factorial of INTEGER.\"\n"
"  (if (= 1 integer) 1\n"
"    (* integer (factorial (1- integer)))))\n"
"@result{} factorial\n"
msgstr ""
"(defun factorial (integer)\n"
"  \"INTEGERの階乗を計算する。\"\n"
"  (if (= 1 integer) 1\n"
"    (* integer (factorial (1- integer)))))\n"
"@result{} factorial\n"

#. type: group
#: original_texis/compile.texi:138
#, no-wrap
msgid ""
"(byte-compile 'factorial)\n"
"@result{}\n"
"#[(integer)\n"
"  \"^H\\301U\\203^H^@@\\301\\207\\302^H\\303^HS!\\\"\\207\"\n"
"  [integer 1 * factorial]\n"
"  4 \"Compute factorial of INTEGER.\"]\n"
msgstr ""
"(byte-compile 'factorial)\n"
"@result{}\n"
"#[(integer)\n"
"  \"^H\\301U\\203^H^@@\\301\\207\\302^H\\303^HS!\\\"\\207\"\n"
"  [integer 1 * factorial]\n"
"  4 \"Compute factorial of INTEGER.\"]\n"

#. type: defun
#: original_texis/compile.texi:146
msgid "If @var{symbol}'s definition is a byte-code function object, @code{byte-compile} does nothing and returns @code{nil}.  It does not compile the symbol's definition again, since the original (non-compiled) code has already been replaced in the symbol's function cell by the byte-compiled code."
msgstr "@var{symbol}の定義がバイトコード関数オブジェクトなら、@code{byte-compile}は何も行わず@code{nil}をリターンする。そのシンボルの関数セル内の(コンパイルされていない)オリジナルのコードはすでにバイトコンパイルされたコードに置き換えられているので、シンボルの定義の再コンパイルはしない。"

#. type: defun
#: original_texis/compile.texi:150
msgid "The argument to @code{byte-compile} can also be a @code{lambda} expression.  In that case, the function returns the corresponding compiled code but does not store it anywhere."
msgstr "@code{byte-compile}の引数として@code{lambda}式も指定できる。この場合、関数は対応するコンパイル済みコードをリターンするが、それはどこにも格納されない。"

#. type: deffn
#: original_texis/compile.texi:152
#, no-wrap
msgid "Command compile-defun &optional arg"
msgstr "Command compile-defun &optional arg"

#. type: deffn
#: original_texis/compile.texi:157
msgid "This command reads the defun containing point, compiles it, and evaluates the result.  If you use this on a defun that is actually a function definition, the effect is to install a compiled version of that function."
msgstr "このコマンドはポイントを含むdefunを読み取りそれをコンパイルして、結果を評価します。実際に関数定義であるようなdefunでこれを使用した場合は、その関数のコンパイル済みバージョンをインストールする効果があります。"

#. type: deffn
#: original_texis/compile.texi:161
msgid "@code{compile-defun} normally displays the result of evaluation in the echo area, but if @var{arg} is non-@code{nil}, it inserts the result in the current buffer after the form it compiled."
msgstr "@code{compile-defun}は通常は評価した結果をエコーエリアに表示するが、@var{arg}が非@code{nil}なら、そのフォームをコンパイルした後にカレントバッファーに結果を挿入する。"

#. type: deffn
#: original_texis/compile.texi:163
#, no-wrap
msgid "Command byte-compile-file filename &optional load"
msgstr "Command byte-compile-file filename &optional load"

#. type: deffn
#: original_texis/compile.texi:168
msgid "This function compiles a file of Lisp code named @var{filename} into a file of byte-code.  The output file's name is made by changing the @samp{.el} suffix into @samp{.elc}; if @var{filename} does not end in @samp{.el}, it adds @samp{.elc} to the end of @var{filename}."
msgstr "この関数は@var{filename}という名前のLispコードファイルを、バイトコードのファイルにコンパイルする。出力となるファイルの名前は、サフィックス@samp{.el}を@samp{.elc}に変更することにより作成される。@var{filename}が@samp{.el}で終了しない場合には、@samp{.elc}を@var{filename}の最後に付け足す。"

#. type: deffn
#: original_texis/compile.texi:175
msgid "Compilation works by reading the input file one form at a time.  If it is a definition of a function or macro, the compiled function or macro definition is written out.  Other forms are batched together, then each batch is compiled, and written so that its compiled code will be executed when the file is read.  All comments are discarded when the input file is read."
msgstr "コンパイルは入力ファイルから1つのフォームを逐次読み取ることにより機能する。フォームが関数かマクロなら、コンパイル済みの関数かマクロが書き込まれる。それ以外のフォームはまとめられて、まとめられたものごとにコンパイルされて、そのファイルが読まれたとき実行されるようにコンパイルされたコードが書き込まれる。入力ファイルを読み取る際には、すべてのコメントは無視される。"

#. type: deffn
#: original_texis/compile.texi:178
msgid "This command returns @code{t} if there were no errors and @code{nil} otherwise.  When called interactively, it prompts for the file name."
msgstr "このコマンドはエラーがなければ@code{t}、それ以外は@code{nil}をリターンする。インタラクティブに呼び出されたときは、ファイル名の入力をもとめる。"

#. type: deffn
#: original_texis/compile.texi:181
msgid "If @var{load} is non-@code{nil}, this command loads the compiled file after compiling it.  Interactively, @var{load} is the prefix argument."
msgstr "@var{load}が非@code{nil}なら、このコマンドはコンパイルした後にコンパイルしたファイルをロードする。インタラクティブに呼び出された場合、@var{load}はプレフィクス引数である。"

#. type: group
#: original_texis/compile.texi:186
#, no-wrap
msgid ""
"$ ls -l push*\n"
"-rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el\n"
msgstr ""
"$ ls -l push*\n"
"-rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el\n"

#. type: group
#: original_texis/compile.texi:191
#, no-wrap
msgid ""
"(byte-compile-file \"~/emacs/push.el\")\n"
"     @result{} t\n"
msgstr ""
"(byte-compile-file \"~/emacs/push.el\")\n"
"     @result{} t\n"

#. type: group
#: original_texis/compile.texi:197
#, no-wrap
msgid ""
"$ ls -l push*\n"
"-rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el\n"
"-rw-rw-rw- 1 lewis lewis 638 Oct  8 20:25 push.elc\n"
msgstr ""
"$ ls -l push*\n"
"-rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el\n"
"-rw-rw-rw- 1 lewis lewis 638 Oct  8 20:25 push.elc\n"

#. type: deffn
#: original_texis/compile.texi:201
#, no-wrap
msgid "Command byte-recompile-directory directory &optional flag force"
msgstr "Command byte-recompile-directory directory &optional flag force"

#. type: cindex
#: original_texis/compile.texi:202
#, no-wrap
msgid "library compilation"
msgstr "library compilation"

#. type: deffn
#: original_texis/compile.texi:207
msgid "This command recompiles every @samp{.el} file in @var{directory} (or its subdirectories) that needs recompilation.  A file needs recompilation if a @samp{.elc} file exists but is older than the @samp{.el} file."
msgstr "このコマンドは@var{directory}(またはそのサブディレクトリー)内の、リコンパイルを要するすべての@samp{.el}ファイルをリコンパイルする。@samp{.elc}ファイルが存在して、それが@samp{.el}より古いファイルは、リコンパイルが必要となる。"

#. type: deffn
#: original_texis/compile.texi:213
msgid "When a @samp{.el} file has no corresponding @samp{.elc} file, @var{flag} says what to do.  If it is @code{nil}, this command ignores these files.  If @var{flag} is 0, it compiles them.  If it is neither @code{nil} nor 0, it asks the user whether to compile each such file, and asks about each subdirectory as well."
msgstr "@samp{.el}ファイルに対応する@samp{.elc}ファイルが存在しない場合に何を行うかを@var{flag}で指定する。@code{nil}なら、このコマンドはこれらのファイルを無視する。@var{flag}が0なら、それらをコンパイルする。@code{nil}と0以外なら、それらのファイルをコンパイルするかユーザーに尋ねて、同様にそれぞれのサブディレクトリーについても尋ねる。"

#. type: deffn
#: original_texis/compile.texi:216
msgid "Interactively, @code{byte-recompile-directory} prompts for @var{directory} and @var{flag} is the prefix argument."
msgstr "インタラクティブに呼び出されると、@code{byte-recompile-directory}は@var{directory}の入力を求めて、@var{flag}はプレフィクス引数となる。"

#. type: deffn
#: original_texis/compile.texi:219
msgid "If @var{force} is non-@code{nil}, this command recompiles every @samp{.el} file that has a @samp{.elc} file."
msgstr "@var{force}が非@code{nil}なら、このコマンドは@samp{.elc}ファイルが存在するすべての@samp{.el}ファイルをリコンパイルする。"

#. type: deffn
#: original_texis/compile.texi:221
msgid "The returned value is unpredictable."
msgstr "リターン値は不定。"

#. type: defun
#: original_texis/compile.texi:223
#, no-wrap
msgid "batch-byte-compile &optional noforce"
msgstr "batch-byte-compile &optional noforce"

#. type: defun
#: original_texis/compile.texi:230
msgid "This function runs @code{byte-compile-file} on files specified on the command line.  This function must be used only in a batch execution of Emacs, as it kills Emacs on completion.  An error in one file does not prevent processing of subsequent files, but no output file will be generated for it, and the Emacs process will terminate with a nonzero status code."
msgstr "この関数はコマンドラインで指定されたファイルにたいして@code{byte-compile-file}を実行する。この関数は処理が完了するとEmacsをkillするので、Emacsのバッチ実行でのみ使用しなければならない。1つのファイルでエラーが発生しても、それによって後続のファイルにたいする処理が妨げられることはないが、そのファイルにたいする出力ファイルは生成されず、Emacsプロセスは0以外のステータスコードで終了する。"

#. type: defun
#: original_texis/compile.texi:233
msgid "If @var{noforce} is non-@code{nil}, this function does not recompile files that have an up-to-date @samp{.elc} file."
msgstr "@var{noforce}が非@code{nil}なら、この関数は最新の@samp{.elc}ファイルがあるファイルをリコンパイルしない。"

#. type: example
#: original_texis/compile.texi:236
#, no-wrap
msgid "$ emacs -batch -f batch-byte-compile *.el\n"
msgstr "$ emacs -batch -f batch-byte-compile *.el\n"

#. type: section
#: original_texis/compile.texi:240
#, no-wrap
msgid "Documentation Strings and Compilation"
msgstr "Documentation Strings and Compilation"

#. type: cindex
#: original_texis/compile.texi:241
#, no-wrap
msgid "dynamic loading of documentation"
msgstr "dynamic loading of documentation"

#. type: Plain text
#: original_texis/compile.texi:248
msgid "When Emacs loads functions and variables from a byte-compiled file, it normally does not load their documentation strings into memory.  Each documentation string is dynamically loaded from the byte-compiled file only when needed.  This saves memory, and speeds up loading by skipping the processing of the documentation strings."
msgstr "Emacsがバイトコンパイルされたファイルから関数や変数をロードする際、通常はメモリー内にそれらのドキュメント文字列をロードしません。それぞれのドキュメント文字列は、必要なときだけバイトコンパイルされたファイルからダイナミック(dynamic: 動的)にロードされます。ドキュメント文字列の処理をスキップすることにより、メモリーが節約されてロードが高速になります。"

#. type: Plain text
#: original_texis/compile.texi:255
msgid "This feature has a drawback: if you delete, move, or alter the compiled file (such as by compiling a new version), Emacs may no longer be able to access the documentation string of previously-loaded functions or variables.  Such a problem normally only occurs if you build Emacs yourself, and happen to edit and/or recompile the Lisp source files.  To solve it, just reload each file after recompilation."
msgstr "この機能には欠点があります。コンパイル済みのファイルを削除や移動、または(新しいバージョンのコンパイル等で)変更した場合、Emacsは以前にロードした関数や変数のドキュメント文字列にアクセスできなくなるでしょう。このような問題は通常なら、あなた自身がEmacsをビルドしたときに、そのLispファイルを編集および/またはリコンパイルしたときだけ発生します。この問題は、リコンパイル後にそれぞれのファイルをリロードするだけで解決します。"

#. type: Plain text
#: original_texis/compile.texi:259
msgid "Dynamic loading of documentation strings from byte-compiled files is determined, at compile time, for each byte-compiled file.  It can be disabled via the option @code{byte-compile-dynamic-docstrings}."
msgstr "バイトコンパイルされたファイルからのドキュメント文字列のダイナミックロードは、バイトコンパイルされたファイルごとにコンパイル時に解決されます。これはオプション@code{byte-compile-dynamic-docstrings}で無効にできます。"

#. type: defopt
#: original_texis/compile.texi:260
#, no-wrap
msgid "byte-compile-dynamic-docstrings"
msgstr "byte-compile-dynamic-docstrings"

#. type: defopt
#: original_texis/compile.texi:263
msgid "If this is non-@code{nil}, the byte compiler generates compiled files that are set up for dynamic loading of documentation strings."
msgstr "これが非@code{nil}なら、バイトコンパイラーはドキュメント文字列をダイナミックロードするようにセットアップしたコンパイル済みファイルを生成する。"

#. type: defopt
#: original_texis/compile.texi:267
msgid "To disable the dynamic loading feature for a specific file, set this option to @code{nil} in its header line (@pxref{File Variables, , Local Variables in Files, emacs, The GNU Emacs Manual}), like this:"
msgstr "特定のファイルでダイナミックロード機能を無効にするには、以下のようにヘッダー行でこのオプションに@code{nil}をセットする(@ref{File Variables, , Local Variables in Files, emacs, The GNU Emacs Manual}を参照)。"

#. type: smallexample
#: original_texis/compile.texi:270
#, no-wrap
msgid "-*-byte-compile-dynamic-docstrings: nil;-*-\n"
msgstr "-*-byte-compile-dynamic-docstrings: nil;-*-\n"

#. type: defopt
#: original_texis/compile.texi:275
msgid "This is useful mainly if you expect to change the file, and you want Emacs sessions that have already loaded it to keep working when the file changes."
msgstr "これは主として、あるファイルを変更しようとしていて、そのファイルをすでにロード済みのEmacsセッションがファイルを変更した際にも正しく機能し続けることを望む場合に有用である。"

#. type: samp{#1}
#: original_texis/compile.texi:277
#, no-wrap
msgid "#@@@var{count}"
msgstr "#@@@var{count}"

#. type: samp{#1}
#: original_texis/compile.texi:278
#, no-wrap
msgid "#$"
msgstr "#$"

#. type: Plain text
#: original_texis/compile.texi:286
msgid "Internally, the dynamic loading of documentation strings is accomplished by writing compiled files with a special Lisp reader construct, @samp{#@@@var{count}}.  This construct skips the next @var{count} characters.  It also uses the @samp{#$} construct, which stands for the name of this file, as a string.  Do not use these constructs in Lisp source files; they are not designed to be clear to humans reading the file."
msgstr "内部的にはドキュメント文字列のダイナミックロードは、特殊なLispリーダー構文@samp{#@@@var{count}}とともにコンパイル済みファイルに書き込むことによって達成される。この構文は次の@var{count}文字をスキップする。さらに@samp{#$}構文も使用され、これはこのファイルの名前(文字列)を意味する。これらの構文をLispソースファイル内で使用しないこと。これらは人間がファイルを読む際に明確であるようにデザインされていない。"

#. type: section
#: original_texis/compile.texi:288
#, no-wrap
msgid "Dynamic Loading of Individual Functions"
msgstr "Dynamic Loading of Individual Functions"

#. type: cindex
#: original_texis/compile.texi:290
#, no-wrap
msgid "dynamic loading of functions"
msgstr "dynamic loading of functions"

#. type: cindex
#: original_texis/compile.texi:291
#, no-wrap
msgid "lazy loading"
msgstr "lazy loading"

#. type: Plain text
#: original_texis/compile.texi:299
msgid "When you compile a file, you can optionally enable the @dfn{dynamic function loading} feature (also known as @dfn{lazy loading}).  With dynamic function loading, loading the file doesn't fully read the function definitions in the file.  Instead, each function definition contains a place-holder which refers to the file.  The first time each function is called, it reads the full definition from the file, to replace the place-holder."
msgstr "ファイルをコンパイルするとき、オプションで@dfn{ダイナミック関数ロード(dynamic function loading)}機能(@dfn{laxyロード(lazy loading)とも呼ばれる})を有効にできます。ダイナミック関数ロードでは、ファイルのロードでファイル内の関数定義は完全には読み込まれません。かわりに各関数定義にはそのファイルを参照するプレースホルダーが含まれます。それぞれ関数が最初に呼び出されるときにそのプレースホルダーを置き換えるために、ファイルから完全な定義が読み込まれます。"

#. type: Plain text
#: original_texis/compile.texi:306
msgid "The advantage of dynamic function loading is that loading the file becomes much faster.  This is a good thing for a file which contains many separate user-callable functions, if using one of them does not imply you will probably also use the rest.  A specialized mode which provides many keyboard commands often has that usage pattern: a user may invoke the mode, but use only a few of the commands it provides."
msgstr "ダイナミック関数ロードの利点は、ファイルのロードがより高速になることです。ユーザーが呼び出せる関数を多く含むファイルにとって、それらの関数のうち1つを使用したら多分残りの関数も使用するというのでなければ、これは利点になります。多くのキーボードコマンドを提供する特化したモードは、このパターンの使い方をする場合があります。ユーザーはそのモードを呼び出すかもしれませんが、使用するのはそのモードが提供するコマンドのわずか一部です。"

#. type: Plain text
#: original_texis/compile.texi:308
msgid "The dynamic loading feature has certain disadvantages:"
msgstr "ダイナミックロード機能には不利な点がいくつかあります:"

#. type: itemize
#: original_texis/compile.texi:313
msgid "If you delete or move the compiled file after loading it, Emacs can no longer load the remaining function definitions not already loaded."
msgstr "ロード後にコンパイル済みファイルの削除や移動を行うと、Emacsはまだロードされていない残りの関数定義をロードできなくなる。"

#. type: itemize
#: original_texis/compile.texi:318
msgid "If you alter the compiled file (such as by compiling a new version), then trying to load any function not already loaded will usually yield nonsense results."
msgstr "(新しいバージョンのコンパイル等で)コンパイル済みファイルを変更した場合に、まだロードされていない関数のロードを試みると通常は無意味な結果となる。"

#. type: Plain text
#: original_texis/compile.texi:324
msgid "These problems will never happen in normal circumstances with installed Emacs files.  But they are quite likely to happen with Lisp files that you are changing.  The easiest way to prevent these problems is to reload the new compiled file immediately after each recompilation."
msgstr "このような問題は通常の状況でインストールされたEmacsファイルでは決して発生しません。しかしあなたが変更したLispファイルでは発生し得ます。それぞれのファイルをリコンパイルしたらすぐに新たなコンパイル済みファイルをリロードするのが、これらの問題を回避する一番簡単な方法です。"

#. type: Plain text
#: original_texis/compile.texi:331
msgid "The byte compiler uses the dynamic function loading feature if the variable @code{byte-compile-dynamic} is non-@code{nil} at compilation time.  Do not set this variable globally, since dynamic loading is desirable only for certain files.  Instead, enable the feature for specific source files with file-local variable bindings.  For example, you could do it by writing this text in the source file's first line:"
msgstr "コンパイル時に変数@code{byte-compile-dynamic}が非@code{nil}なら、バイトコンパイラーはダイナミック関数ロード機能を使用します。ダイナミックロードが望ましいのは特定のファイルにたいしてだけなので、この変数をグローバルにセットしないでください。そのかわりに、特定のソースファイルのファイルローカル変数でこの機能を有効にしてください。たとえばソースファイルの最初の行に以下のテキストを記述することにより、これを行うことができます:"

#. type: example
#: original_texis/compile.texi:334
#, no-wrap
msgid "-*-byte-compile-dynamic: t;-*-\n"
msgstr "-*-byte-compile-dynamic: t;-*-\n"

#. type: defvar
#: original_texis/compile.texi:336
#, no-wrap
msgid "byte-compile-dynamic"
msgstr "byte-compile-dynamic"

#. type: defvar
#: original_texis/compile.texi:339
msgid "If this is non-@code{nil}, the byte compiler generates compiled files that are set up for dynamic function loading."
msgstr "これが非@code{nil}なら、バイトコンパイラーはダイナミック関数ロード用にセットアップされたコンパイル済みファイルを生成する。"

#. type: defun
#: original_texis/compile.texi:341
#, no-wrap
msgid "fetch-bytecode function"
msgstr "fetch-bytecode function"

#. type: defun
#: original_texis/compile.texi:346
msgid "If @var{function} is a byte-code function object, this immediately finishes loading the byte code of @var{function} from its byte-compiled file, if it is not fully loaded already.  Otherwise, it does nothing.  It always returns @var{function}."
msgstr "@var{function}がバイトコード関数オブジェクトなら、それがまだ完全にロードされていなければ、バイトコンパイル済みのファイルからの@var{function}のバイトコードのロードを完了させる。それ以外なら何も行わない。この関数は常に@var{function}をリターンする。"

#. type: section
#: original_texis/compile.texi:349
#, no-wrap
msgid "Evaluation During Compilation"
msgstr "Evaluation During Compilation"

#. type: cindex
#: original_texis/compile.texi:350
#, no-wrap
msgid "eval during compilation"
msgstr "eval during compilation"

#. type: Plain text
#: original_texis/compile.texi:354
msgid "These features permit you to write code to be evaluated during compilation of a program."
msgstr "これらの機能によりプログラムのコンパイル中に評価されるコードを記述できます。"

#. type: defspec
#: original_texis/compile.texi:355
#, no-wrap
msgid "eval-and-compile body@dots{}"
msgstr "eval-and-compile body@dots{}"

#. type: defspec
#: original_texis/compile.texi:358
msgid "This form marks @var{body} to be evaluated both when you compile the containing code and when you run it (whether compiled or not)."
msgstr "このフォームはそれを含むコードがコンパイルされるとき、および(コンパイルされているかいないかに関わらず)実行されるときの両方で@var{body}が評価されるようにマークする。"

#. type: defspec
#: original_texis/compile.texi:364
msgid "You can get a similar result by putting @var{body} in a separate file and referring to that file with @code{require}.  That method is preferable when @var{body} is large.  Effectively @code{require} is automatically @code{eval-and-compile}, the package is loaded both when compiling and executing."
msgstr "@var{body}を別のファイルに配置して、そのファイルを@code{require}で参照すれば同様の結果が得られる。これは@var{body}が大きいときに望ましい方法である。事実上、@code{require}は自動的に@code{eval-and-compile}されて、そのパッケージはコンパイル時と実行時の両方でロードされる。"

#. type: defspec
#: original_texis/compile.texi:368
msgid "@code{autoload} is also effectively @code{eval-and-compile} too.  It's recognized when compiling, so uses of such a function don't produce ``not known to be defined'' warnings."
msgstr "@code{autoload}も実際は@code{eval-and-compile}される。これはコンパイル時に認識されるので、そのような関数の使用により警告``not known to be defined''は生成されない。"

#. type: defspec
#: original_texis/compile.texi:370
msgid "Most uses of @code{eval-and-compile} are fairly sophisticated."
msgstr "ほとんどの@code{eval-and-compile}の使用は、完全に妥当であると言えよう。"

#. type: defspec
#: original_texis/compile.texi:375
msgid "If a macro has a helper function to build its result, and that macro is used both locally and outside the package, then @code{eval-and-compile} should be used to get the helper both when compiling and then later when running."
msgstr "あるマクロがマクロの結果を構築するためのヘルパー関数をもち、そのマクロがそのパッケージにたいしてローカルと外部の両方で使用される場合には、コンパイル時と後の実行時にそのヘルパー関数を取得するために@code{eval-and-compile}を使用すること。"

#. type: defspec
#: original_texis/compile.texi:380
msgid "If functions are defined programmatically (with @code{fset} say), then @code{eval-and-compile} can be used to have that done at compile-time as well as run-time, so calls to those functions are checked (and warnings about ``not known to be defined'' suppressed)."
msgstr "これは関数がプログラム的に(@code{fset}で)定義されている場合には、コンパイル時と実行時にプログラム的な定義を行わせてそれらの関数の呼び出しをチェックするためにも使用できる(``not known to be defined''の警告は抑制される)。"

#. type: defspec
#: original_texis/compile.texi:382
#, no-wrap
msgid "eval-when-compile body@dots{}"
msgstr "eval-when-compile body@dots{}"

#. type: defspec
#: original_texis/compile.texi:388
msgid "This form marks @var{body} to be evaluated at compile time but not when the compiled program is loaded.  The result of evaluation by the compiler becomes a constant which appears in the compiled program.  If you load the source file, rather than compiling it, @var{body} is evaluated normally."
msgstr "このフォームは@var{body}がコンパイル時に評価され、コンパイルされたプログラムがロードされるときは評価されないようにマークする。コンパイラーによる評価の結果はコンパイル済みのプログラム内の定数となる。ソースファイルをコンパイルではなくロードすると、@var{body}は通常どおり評価される。"

#. type: cindex
#: original_texis/compile.texi:389
#, no-wrap
msgid "compile-time constant"
msgstr "compile-time constant"

#. type: defspec
#: original_texis/compile.texi:392
msgid "If you have a constant that needs some calculation to produce, @code{eval-when-compile} can do that at compile-time.  For example,"
msgstr "生成するために何らかの計算が必要な定数があるなら、@code{eval-when-compile}はコンパイル時にそれを行なうことができる。たとえば、"

#. type: lisp
#: original_texis/compile.texi:396
#, no-wrap
msgid ""
"(defvar my-regexp\n"
"  (eval-when-compile (regexp-opt '(\"aaa\" \"aba\" \"abb\"))))\n"
msgstr ""
"(defvar my-regexp\n"
"  (eval-when-compile (regexp-opt '(\"aaa\" \"aba\" \"abb\"))))\n"

#. type: cindex
#: original_texis/compile.texi:398
#, no-wrap
msgid "macros, at compile time"
msgstr "macros, at compile time"

#. type: defspec
#: original_texis/compile.texi:402
msgid "If you're using another package, but only need macros from it (the byte compiler will expand those), then @code{eval-when-compile} can be used to load it for compiling, but not executing.  For example,"
msgstr "他のパッケージを使用しているが、そのパッケージのマクロ(バイトコンパイラーはそれらを展開します)だけが必要なら、それらを実行せずにコンパイル用にロードさせるために@code{eval-when-compile}を使用できる。たとえば、"

#. type: lisp
#: original_texis/compile.texi:406
#, no-wrap
msgid ""
"(eval-when-compile\n"
"  (require 'my-macro-package))\n"
msgstr ""
"(eval-when-compile\n"
"  (require 'my-macro-package))\n"

#. type: defspec
#: original_texis/compile.texi:412
msgid "The same sort of thing goes for macros and @code{defsubst} functions defined locally and only for use within the file.  They are needed for compiling the file, but in most cases they are not needed for execution of the compiled file.  For example,"
msgstr "これらの事項は、マクロと@code{defsubst}関数がローカルに定義されていて、そのファイル内だけで使用されることを要求する。これらはそのファイルのコンパイルに必要だが、コンパイル済みファイルの実行には、ほとんどの場合必要ない。たとえば、"

#. type: lisp
#: original_texis/compile.texi:418
#, no-wrap
msgid ""
"(eval-when-compile\n"
"  (unless (fboundp 'some-new-thing)\n"
"    (defmacro 'some-new-thing ()\n"
"      (compatibility code))))\n"
msgstr ""
"(eval-when-compile\n"
"  (unless (fboundp 'some-new-thing)\n"
"    (defmacro 'some-new-thing ()\n"
"      (compatibility code))))\n"

#. type: defspec
#: original_texis/compile.texi:423
msgid "This is often good for code that's only a fallback for compatibility with other versions of Emacs."
msgstr "これは大抵は他のバージョンのEmacsとの互換性の保証のためのコードにたいしてのみ有用である。"

#. type: defspec
#: original_texis/compile.texi:428
msgid "@strong{Common Lisp Note:} At top level, @code{eval-when-compile} is analogous to the Common Lisp idiom @code{(eval-when (compile eval) @dots{})}.  Elsewhere, the Common Lisp @samp{#.} reader macro (but not when interpreting) is closer to what @code{eval-when-compile} does."
msgstr "@strong{Common Lispに関する注意:} トップレベルでは、@code{eval-when-compile}はCommon Lispのイディオム@code{(eval-when (compile eval) @dots{})}に類似する。トップレベル以外では、Common Lispのリーダーマクロ@samp{#.}(ただし解釈時を除く)が、@code{eval-when-compile}と近いことを行う。"

#. type: cindex
#: original_texis/compile.texi:432
#, no-wrap
msgid "compiler errors"
msgstr "compiler errors"

#. type: Plain text
#: original_texis/compile.texi:439
msgid "Error and warning messages from byte compilation are printed in a buffer named @file{*Compile-Log*}.  These messages include file names and line numbers identifying the location of the problem.  The usual Emacs commands for operating on compiler output can be used on these messages."
msgstr "バイトコンパイルのエラーメッセージと警告メッセージは、@file{*Compile-Log*}という名前のバッファーにプリントされます。これらのメッセージには、問題となる箇所を示すファイル名と行番号が含まれます。これらのメッセージにたいして、コンパイラー出力を操作する通常のEmacsコマンドが使用できます。"

#. type: Plain text
#: original_texis/compile.texi:448
msgid "When an error is due to invalid syntax in the program, the byte compiler might get confused about the error's exact location.  One way to investigate is to switch to the buffer @w{@file{ *Compiler Input*}}.  (This buffer name starts with a space, so it does not show up in the Buffer Menu.)  This buffer contains the program being compiled, and point shows how far the byte compiler was able to read; the cause of the error might be nearby.  @xref{Syntax Errors}, for some tips for locating syntax errors."
msgstr "あるエラーがプログラムのシンタックスに由来する場合、バイトコンパイラーはエラーの正確な位置の取得に際して混乱するかもしれません。バッファー@w{@file{ *Compiler Input*}}.にスイッチするのは、これを調べ1つの方法です(このバッファー名はスペースで始まるので、Buffer Menuに表示されない)。このバッファーにはコンパイルされたプログラムと、バイトコンパイラーが読み取った箇所からポイントがどれほど離れているかが含まれ、エラーの原因はその近傍の可能性があります。シンタックスエラーを見つけるヒントについては、@ref{Syntax Errors}を参照してください。"

#. type: Plain text
#: original_texis/compile.texi:454
msgid "A common type of warning issued by the byte compiler is for functions and variables that were used but not defined.  Such warnings report the line number for the end of the file, not the locations where the missing functions or variables were used; to find these, you must search the file manually."
msgstr "定義されていない関数や変数の使用は、バイトコンパイラーにより報告される警告のタイプとしては一般的です。そのような警告では、定義されていない関数や変数を使用した位置ではなく、そのファイルの最後の行の行番号が報告されるので、それを見つけるには手作業で検索しなければなりません。"

#. type: Plain text
#: original_texis/compile.texi:457
msgid "If you are sure that a warning message about a missing function or variable is unjustified, there are several ways to suppress it:"
msgstr "定義のない関数や変数の警告が間違いだと確信できる場合には、警告を抑制する方法がいくつかあります:"

#. type: itemize
#: original_texis/compile.texi:463
msgid "You can suppress the warning for a specific call to a function @var{func} by conditionalizing it on an @code{fboundp} test, like this:"
msgstr "関数@var{func}への特定の呼び出しにたいする警告は、それを条件式@code{fboundp}でテストすることで抑制できる:"

#. type: example
#: original_texis/compile.texi:466
#, no-wrap
msgid "(if (fboundp '@var{func}) ...(@var{func} ...)...)\n"
msgstr "(if (fboundp '@var{func}) ...(@var{func} ...)...)\n"

#. type: itemize
#: original_texis/compile.texi:472
msgid "The call to @var{func} must be in the @var{then-form} of the @code{if}, and @var{func} must appear quoted in the call to @code{fboundp}.  (This feature operates for @code{cond} as well.)"
msgstr "@var{func}への呼び出しは@code{if}文の@var{then-form}内になければならず、@var{func}は@code{fboundp}呼び出し内でクォートされていなければならない(この機能は@code{cond}でも同様に機能する)。"

#. type: itemize
#: original_texis/compile.texi:477
msgid "Likewise, you can suppress the warning for a specific use of a variable @var{variable} by conditionalizing it on a @code{boundp} test:"
msgstr "同じように、変数@var{variable}の特定の使用についの警告を、条件式内の@code{boundp}テストで抑制できる:"

#. type: example
#: original_texis/compile.texi:480
#, no-wrap
msgid "(if (boundp '@var{variable}) ...@var{variable}...)\n"
msgstr "(if (boundp '@var{variable}) ...@var{variable}...)\n"

#. type: itemize
#: original_texis/compile.texi:486
msgid "The reference to @var{variable} must be in the @var{then-form} of the @code{if}, and @var{variable} must appear quoted in the call to @code{boundp}."
msgstr "@var{variable}への参照は@code{if}文の@var{then-form}内になければならず、@var{variable}は@code{boundp}呼び出し内でクォートされていなければならない。"

#. type: itemize
#: original_texis/compile.texi:490
msgid "You can tell the compiler that a function is defined using @code{declare-function}. @xref{Declaring Functions}."
msgstr "コンパイラーに関数が@code{declare-function}を使用して定義されていると告げることができる。@ref{Declaring Functions}を参照のこと。"

#. type: itemize
#: original_texis/compile.texi:495
msgid "Likewise, you can tell the compiler that a variable is defined using @code{defvar} with no initial value.  (Note that this marks the variable as special.)  @xref{Defining Variables}."
msgstr "同じように、その変数が初期値なしの@code{defvar}を使用して定義されているとコンパイラーに告げることができる(これはその変数を特別な変数としてマークすることに注意。@ref{Defining Variables}を参照)。"

#. type: Plain text
#: original_texis/compile.texi:499
msgid "You can also suppress any and all compiler warnings within a certain expression using the construct @code{with-no-warnings}:"
msgstr "@code{with-no-warnings}構文を使用して特定の式にたいするコンパイラーの任意の警告をすべて抑制することもできます:"

#. type: defspec
#: original_texis/compile.texi:503
#, no-wrap
msgid "with-no-warnings body@dots{}"
msgstr "with-no-warnings body@dots{}"

#. type: defspec
#: original_texis/compile.texi:507
msgid "In execution, this is equivalent to @code{(progn @var{body}...)}, but the compiler does not issue warnings for anything that occurs inside @var{body}."
msgstr "これは実行時には@code{(progn @var{body}...)}と等価だが、コンパイラーは@var{body}の中で起こるいかなる事項にたいしても警告を発しない。"

#. type: defspec
#: original_texis/compile.texi:511
msgid "We recommend that you use this construct around the smallest possible piece of code, to avoid missing possible warnings other than one you intend to suppress."
msgstr "わたしたちは、あなたが抑制したいと意図する警告以外の警告を失わないようにするために、可能な限り小さいコード断片にたいしてこの構文を使用することを推奨する。"

#. type: Plain text
#: original_texis/compile.texi:516
msgid "Byte compiler warnings can be controlled more precisely by setting the variable @code{byte-compile-warnings}.  See its documentation string for details."
msgstr "変数@code{byte-compile-warnings}をセットすることにより、コンパイラーの警告をより詳細に制御できます。詳細は変数のドキュメント文字列を参照してください。"

#. type: section
#: original_texis/compile.texi:518
#, no-wrap
msgid "Byte-Code Function Objects"
msgstr "Byte-Code Function Objects"

#. type: cindex
#: original_texis/compile.texi:519
#, no-wrap
msgid "compiled function"
msgstr "compiled function"

#. type: cindex
#: original_texis/compile.texi:520
#, no-wrap
msgid "byte-code function"
msgstr "byte-code function"

#. type: cindex
#: original_texis/compile.texi:521
#, no-wrap
msgid "byte-code object"
msgstr "byte-code object"

#. type: Plain text
#: original_texis/compile.texi:527
msgid "Byte-compiled functions have a special data type: they are @dfn{byte-code function objects}.  Whenever such an object appears as a function to be called, Emacs uses the byte-code interpreter to execute the byte-code."
msgstr "バイトコンパイルされた関数は、@dfn{バイトコード関数オブジェクト(byte-code function objects)}という特別なデータ型をもちます。関数呼び出しとしてそのようなオブジェクトが出現したとき、Emacsはそのバイトコードを実行するために、常にバイトコードインタープリターを使用します。"

#. type: Plain text
#: original_texis/compile.texi:534
msgid "Internally, a byte-code function object is much like a vector; its elements can be accessed using @code{aref}.  Its printed representation is like that for a vector, with an additional @samp{#} before the opening @samp{[}.  It must have at least four elements; there is no maximum number, but only the first six elements have any normal use.  They are:"
msgstr "内部的にはバイトコード関数オブジェクトはベクターとよく似ています。バイトコード関数オブジェクトの要素には@code{aref}を通じてアクセスできます。バイトコード関数オブジェクトのプリント表現(printed representation)はベクターと似ていて、開き@samp{[}の前に@samp{#}が追加されます。バイト関数オブジェクトは少なくとも4つの要素をもたねばならず、その要素数に上限はありません。しかし通常使用されるのは最初の6要素です。これらは:"

#. type: item
#: original_texis/compile.texi:536
#, no-wrap
msgid "argdesc"
msgstr "argdesc"

#. type: table
#: original_texis/compile.texi:544
msgid "The descriptor of the arguments.  This can either be a list of arguments, as described in @ref{Argument List}, or an integer encoding the required number of arguments.  In the latter case, the value of the descriptor specifies the minimum number of arguments in the bits zero to 6, and the maximum number of arguments in bits 8 to 14.  If the argument list uses @code{&rest}, then bit 7 is set; otherwise it's cleared."
msgstr "引数の記述子(descriptor)。これは@ref{Argument List}で説明されるような引数のリスト、または要求される引数の個数をエンコードする整数のいずれかである。後者の場合、その記述子の値は0ビットから6ビットで引数の最小個数、8ビットから14ビットで引数の最大個数を指定する。引数リストが@code{&rest}を使用するなら7ビットがセットされて、それい以外ならクリアーされる。"

#. type: table
#: original_texis/compile.texi:549
msgid "If @var{argdesc} is a list, the arguments will be dynamically bound before executing the byte code.  If @var{argdesc} is an integer, the arguments will be instead pushed onto the stack of the byte-code interpreter, before executing the code."
msgstr "@var{argdesc}がリストなら、そのバイトコード実行前に引数はダイナミックにバインドされる。@var{argdesc}が整数なら、引数リストはそのバイトコード実行前にバイトコーピンタープリンターのスタックにpushされる。"

#. type: table
#: original_texis/compile.texi:552
msgid "The string containing the byte-code instructions."
msgstr "バイトコード命令を含む文字列。"

#. type: item
#: original_texis/compile.texi:553
#, no-wrap
msgid "constants"
msgstr "constants"

#. type: table
#: original_texis/compile.texi:556
msgid "The vector of Lisp objects referenced by the byte code.  These include symbols used as function names and variable names."
msgstr "バイトコードにより参照されるLispオブジェクトのベクター。関数名と変数名に使用されるシンボルが含まれる。"

#. type: item
#: original_texis/compile.texi:557
#, no-wrap
msgid "stacksize"
msgstr "stacksize"

#. type: table
#: original_texis/compile.texi:559
msgid "The maximum stack size this function needs."
msgstr "この関数が要するスタックの最大サイズ。"

#. type: item
#: original_texis/compile.texi:560
#, no-wrap
msgid "docstring"
msgstr "docstring"

#. type: table
#: original_texis/compile.texi:565
msgid "The documentation string (if any); otherwise, @code{nil}.  The value may be a number or a list, in case the documentation string is stored in a file.  Use the function @code{documentation} to get the real documentation string (@pxref{Accessing Documentation})."
msgstr "(もしあれば)ドキュメント文字列。それ以外は@code{nil}。ドキュメント文字列がファイルに格納されている場合、値は数字かリストかもしれない。本当のドキュメント文字列の取得には、関数@code{documentation}を使用する(@ref{Accessing Documentation}を参照)。"

#. type: item
#: original_texis/compile.texi:566
#, no-wrap
msgid "interactive"
msgstr "interactive"

#. type: table
#: original_texis/compile.texi:569
msgid "The interactive spec (if any).  This can be a string or a Lisp expression.  It is @code{nil} for a function that isn't interactive."
msgstr "(もしあれば)インタラクティブ仕様。文字列かLisp式。インタラクティブでない関数では@code{nil}。"

#. type: Plain text
#: original_texis/compile.texi:574
msgid "Here's an example of a byte-code function object, in printed representation.  It is the definition of the command @code{backward-sexp}."
msgstr "以下はバイトコード関数オブジェクトのプリント表現の例です。これはコマンド@code{backward-sexp}の定義です。"

#. type: example
#: original_texis/compile.texi:582
#, no-wrap
msgid ""
"#[256\n"
"  \"\\211\\204^G^@@\\300\\262^A\\301^A[!\\207\"\n"
"  [1 forward-sexp]\n"
"  3\n"
"  1793299\n"
"  \"^p\"]\n"
msgstr ""
"#[256\n"
"  \"\\211\\204^G^@@\\300\\262^A\\301^A[!\\207\"\n"
"  [1 forward-sexp]\n"
"  3\n"
"  1793299\n"
"  \"^p\"]\n"

#. type: Plain text
#: original_texis/compile.texi:586
msgid "The primitive way to create a byte-code object is with @code{make-byte-code}:"
msgstr "バイトコードオブジェクトを作成するプリミティブな方法は@code{make-byte-code}です:"

#. type: defun
#: original_texis/compile.texi:587
#, no-wrap
msgid "make-byte-code &rest elements"
msgstr "make-byte-code &rest elements"

#. type: defun
#: original_texis/compile.texi:590
msgid "This function constructs and returns a byte-code function object with @var{elements} as its elements."
msgstr "この関数は@var{elements}を要素とするバイトコードオブジェクトを構築してリターンする。"

#. type: Plain text
#: original_texis/compile.texi:596
msgid "You should not try to come up with the elements for a byte-code function yourself, because if they are inconsistent, Emacs may crash when you call the function.  Always leave it to the byte compiler to create these objects; it makes the elements consistent (we hope)."
msgstr "あなた自身で要素を収集してバイトコード関数を構築しないでください。それらが矛盾する場合、その関数の呼び出しによりEmacsがクラッシュするかもしれません。これらのオブジェクトの作成は常にバイトコンパイラーにまかせてください。(願わくば)バイトコンパイラーは要素を矛盾なく構築します。"

#. type: section
#: original_texis/compile.texi:598
#, no-wrap
msgid "Disassembled Byte-Code"
msgstr "Disassembled Byte-Code"

#. type: cindex
#: original_texis/compile.texi:599
#, no-wrap
msgid "disassembled byte-code"
msgstr "disassembled byte-code"

#. type: Plain text
#: original_texis/compile.texi:605
msgid "People do not write byte-code; that job is left to the byte compiler.  But we provide a disassembler to satisfy a cat-like curiosity.  The disassembler converts the byte-compiled code into human-readable form."
msgstr "人はバイトコードを記述しません。それはバイトコンパイラーの仕事です。しかし好奇心を満たすために、わたしたちはディスアセンブラを提供しています。ディスアセンブラはバイトコードを人間が読めるフォームに変換します。"

#. type: Plain text
#: original_texis/compile.texi:611
msgid "The byte-code interpreter is implemented as a simple stack machine.  It pushes values onto a stack of its own, then pops them off to use them in calculations whose results are themselves pushed back on the stack.  When a byte-code function returns, it pops a value off the stack and returns it as the value of the function."
msgstr "バイトコードインタープリターは、シンプルなスタックマシンとして実装されています。これは値を自身のスタックにpushして、計算で使用するためにそれらをpopして取り出し、その結果を再びそのスタックにpushして戻します。バイトコード関数がリターンするときは、スタックから値をpopして取り出し、その関数の値としてリターンします。"

#. type: Plain text
#: original_texis/compile.texi:615
msgid "In addition to the stack, byte-code functions can use, bind, and set ordinary Lisp variables, by transferring values between variables and the stack."
msgstr "それに加えてスタックとバイトコード関数は、値を変数とスタック間で転送することにより、普通のLisp変数を使用したり、バインドやセットを行うことができます。"

#. type: deffn
#: original_texis/compile.texi:616
#, no-wrap
msgid "Command disassemble object &optional buffer-or-name"
msgstr "Command disassemble object &optional buffer-or-name"

#. type: deffn
#: original_texis/compile.texi:623
msgid "This command displays the disassembled code for @var{object}.  In interactive use, or if @var{buffer-or-name} is @code{nil} or omitted, the output goes in a buffer named @file{*Disassemble*}.  If @var{buffer-or-name} is non-@code{nil}, it must be a buffer or the name of an existing buffer.  Then the output goes there, at point, and point is left before the output."
msgstr "このコマンドは@var{object}にたいするディスアセンブルされたコードを表示する。インタラクティブに使用した場合、または@var{buffer-or-name}が@code{nil}か省略された場合は、@file{*Disassemble*}という名前のバッファーに出力します。@var{buffer-or-name}が非@code{nil}なら、それはバッファーもしくは既存のバッファーの名前でなければならない。その場合は、そのバッファーのポイント位置に出力され、ポイントは出力の前に残りされる。"

#. type: deffn
#: original_texis/compile.texi:628
msgid "The argument @var{object} can be a function name, a lambda expression (@pxref{Lambda Expressions}), or a byte-code object (@pxref{Byte-Code Objects}).  If it is a lambda expression, @code{disassemble} compiles it and disassembles the resulting compiled code."
msgstr "引数@var{object}には関数名、ラムダ式(@ref{Lambda Expressions}を参照)、またはバイトコードオブジェクト(@ref{Byte-Code Objects}を参照)を指定できる。ラムダ式なら@code{disassemble}はそれをコンパイルしてから、そのコンパイル済みコードをディスアセンブルする。"

#. type: Plain text
#: original_texis/compile.texi:633
msgid "Here are two examples of using the @code{disassemble} function.  We have added explanatory comments to help you relate the byte-code to the Lisp source; these do not appear in the output of @code{disassemble}."
msgstr "以下に@code{disassemble}関数を使用した例を2つ示します。バイトコードとLispソースを関連付ける助けとなるように、説明的なコメントを追加してあります。これらのコメントは@code{disassemble}の出力にはありません。"

#. type: group
#: original_texis/compile.texi:641
#, no-wrap
msgid ""
"(defun factorial (integer)\n"
"  \"Compute factorial of an integer.\"\n"
"  (if (= 1 integer) 1\n"
"    (* integer (factorial (1- integer)))))\n"
"     @result{} factorial\n"
msgstr ""
"(defun factorial (integer)\n"
"  \"Compute factorial of an integer.\"\n"
"  (if (= 1 integer) 1\n"
"    (* integer (factorial (1- integer)))))\n"
"     @result{} factorial\n"

#. type: group
#: original_texis/compile.texi:646
#, no-wrap
msgid ""
"(factorial 4)\n"
"     @result{} 24\n"
msgstr ""
"(factorial 4)\n"
"     @result{} 24\n"

#. type: group
#: original_texis/compile.texi:653
#, no-wrap
msgid ""
"(disassemble 'factorial)\n"
"     @print{} byte-code for factorial:\n"
" doc: Compute factorial of an integer.\n"
" args: (integer)\n"
msgstr ""
"(disassemble 'factorial)\n"
"     @print{} byte-code for factorial:\n"
" doc: Compute factorial of an integer.\n"
" args: (integer)\n"

#. type: group
#: original_texis/compile.texi:659
#, no-wrap
msgid ""
"0   varref   integer      ; @r{Get the value of @code{integer} and}\n"
"                          ;   @r{push it onto the stack.}\n"
"1   constant 1            ; @r{Push 1 onto stack.}\n"
msgstr ""
"0   varref   integer      ; @r{@code{integer}の値を取得して}\n"
"                          ;   @r{それをスタック上にpushする}\n"
"1   constant 1            ; @r{スタック上に1をpushする}\n"

#. type: group
#: original_texis/compile.texi:663
#, no-wrap
msgid ""
"2   eqlsign               ; @r{Pop top two values off stack, compare}\n"
"                          ;   @r{them, and push result onto stack.}\n"
msgstr ""
"2   eqlsign               ; @r{2つの値をスタックからpopして取り出し、}\n"
"                          ;   @r{それらを比較して結果をスタック上にpushする}\n"

#. type: group
#: original_texis/compile.texi:669
#, no-wrap
msgid ""
"3   goto-if-nil 1         ; @r{Pop and test top of stack;}\n"
"                          ;   @r{if @code{nil}, go to 1, else continue.}\n"
"6   constant 1            ; @r{Push 1 onto top of stack.}\n"
"7   return                ; @r{Return the top element of the stack.}\n"
msgstr ""
"3   goto-if-nil 1         ; @r{スタックのトップをpopしてテストする}\n"
"                          ;   @r{@code{nil}なら1へ、それ以外はcontinue}\n"
"6   constant 1            ; @r{スタックのトップに1をpushする}\n"
"7   return                ; @r{スタックのトップの要素をリターンする}\n"

#. type: group
#: original_texis/compile.texi:679
#, no-wrap
msgid ""
"8:1 varref   integer      ; @r{Push value of @code{integer} onto stack.}\n"
"9   constant factorial    ; @r{Push @code{factorial} onto stack.}\n"
"10  varref   integer      ; @r{Push value of @code{integer} onto stack.}\n"
"11  sub1                  ; @r{Pop @code{integer}, decrement value,}\n"
"                          ;   @r{push new value onto stack.}\n"
"12  call     1            ; @r{Call function @code{factorial} using first}\n"
"                          ;   @r{(i.e., top) stack element as argument;}\n"
"                          ;   @r{push returned value onto stack.}\n"
msgstr ""
"8:1 varref   integer      ; @r{@code{integer}の値をスタック上にpushする}\n"
"9   constant factorial    ; @r{@code{factorial}をスタック上にpushする}\n"
"10  varref   integer      ; @r{@code{integer}の値をスタック上にpushする}\n"
"11  sub1                  ; @r{@code{integer}をpopして値をデクリメントする}\n"
"                          ;   @r{スタック上に新しい値をpushする}\n"
"12  call     1            ; @r{スタックの最初(トップ)の要素を引数として}\n"
"                          ;   @r{関数@code{factorial}を呼び出す}\n"
"                          ;   @r{リターン値をスタック上にpushする}\n"

#. type: group
#: original_texis/compile.texi:684
#, no-wrap
msgid ""
"13 mult                   ; @r{Pop top two values off stack, multiply}\n"
"                          ;   @r{them, and push result onto stack.}\n"
"14 return                 ; @r{Return the top element of the stack.}\n"
msgstr ""
"13 mult                   ; @r{スタックのトップ2要素をpopして取り出し乗じ}\n"
"                          ;   @r{結果をスタック上にpushする}\n"
"14 return                 ; @r{スタックのトップ要素をリターンする}\n"

#. type: Plain text
#: original_texis/compile.texi:688
msgid "The @code{silly-loop} function is somewhat more complex:"
msgstr "@code{silly-loop}は幾分複雑です:"

#. type: group
#: original_texis/compile.texi:698
#, no-wrap
msgid ""
"(defun silly-loop (n)\n"
"  \"Return time before and after N iterations of a loop.\"\n"
"  (let ((t1 (current-time-string)))\n"
"    (while (> (setq n (1- n))\n"
"              0))\n"
"    (list t1 (current-time-string))))\n"
"     @result{} silly-loop\n"
msgstr ""
"(defun silly-loop (n)\n"
"  \"Return time before and after N iterations of a loop.\"\n"
"  (let ((t1 (current-time-string)))\n"
"    (while (> (setq n (1- n))\n"
"              0))\n"
"    (list t1 (current-time-string))))\n"
"     @result{} silly-loop\n"

#. type: group
#: original_texis/compile.texi:705
#, no-wrap
msgid ""
"(disassemble 'silly-loop)\n"
"     @print{} byte-code for silly-loop:\n"
" doc: Return time before and after N iterations of a loop.\n"
" args: (n)\n"
msgstr ""
"(disassemble 'silly-loop)\n"
"     @print{} byte-code for silly-loop:\n"
" doc: Return time before and after N iterations of a loop.\n"
" args: (n)\n"

#. type: group
#: original_texis/compile.texi:710
#, no-wrap
msgid ""
"0   constant current-time-string  ; @r{Push @code{current-time-string}}\n"
"                                  ;   @r{onto top of stack.}\n"
msgstr ""
"0   constant current-time-string  ; @r{@code{current-time-string}を}\n"
"                                  ;   @r{スタック上のトップにpushする}\n"

#. type: group
#: original_texis/compile.texi:714
#, no-wrap
msgid ""
"1   call     0            ; @r{Call @code{current-time-string} with no}\n"
"                          ;   @r{argument, push result onto stack.}\n"
msgstr ""
"1   call     0            ; @r{引数なしで@code{current-time-string}を呼び出し}\n"
"                          ;   @r{結果をスタック上にpushする}\n"

#. type: group
#: original_texis/compile.texi:717
#, no-wrap
msgid "2   varbind  t1           ; @r{Pop stack and bind @code{t1} to popped value.}\n"
msgstr "2   varbind  t1           ; @r{スタックをpopして@code{t1}にpopされた値をバインドする}\n"

#. type: group
#: original_texis/compile.texi:722
#, no-wrap
msgid ""
"3:1 varref   n            ; @r{Get value of @code{n} from the environment}\n"
"                          ;   @r{and push the value on the stack.}\n"
"4   sub1                  ; @r{Subtract 1 from top of stack.}\n"
msgstr ""
"3:1 varref   n            ; @r{環境から@code{n}の値を取得して}\n"
"                          ;   @r{その値をスタック上にpushする}\n"
"4   sub1                  ; @r{スタックのトップから1を減ずる}\n"

#. type: group
#: original_texis/compile.texi:728
#, no-wrap
msgid ""
"5   dup                   ; @r{Duplicate top of stack; i.e., copy the top}\n"
"                          ;   @r{of the stack and push copy onto stack.}\n"
"6   varset   n            ; @r{Pop the top of the stack,}\n"
"                          ;   @r{and bind @code{n} to the value.}\n"
"\n"
msgstr ""
"5   dup                   ; @r{スタックのトップを複製する}\n"
"                          ;   @r{たとえばスタックのトップをコピーしてスタック上にpushする}\n"
"6   varset   n            ; @r{スタックのトップをpopして}\n"
"                          ;   @r{@code{n}をその値にバインドする}\n"
"\n"

#. type: group
#: original_texis/compile.texi:731
#, no-wrap
msgid ""
";; @r{(In effect, the sequence @code{dup varset} copies the top of the stack}\n"
";; @r{into the value of @code{n} without popping it.)}\n"
msgstr ""
";; @r{(要はシーケンス@code{dup varset}はpopせずに}\n"
";; @r{ スタックのトップを@code{n}の値にコピーする)}\n"

#. type: group
#: original_texis/compile.texi:738
#, no-wrap
msgid ""
"7   constant 0            ; @r{Push 0 onto stack.}\n"
"8   gtr                   ; @r{Pop top two values off stack,}\n"
"                          ;   @r{test if @var{n} is greater than 0}\n"
"                          ;   @r{and push result onto stack.}\n"
msgstr ""
"7   constant 0            ; @r{スタック上に0をpushする}\n"
"8   gtr                   ; @r{スタックのトップ2値をpopして取り出し}\n"
"                          ;   @r{@var{n}が0より大かテストし}\n"
"                          ;   @r{結果をスタック上にpushする}\n"

#. type: group
#: original_texis/compile.texi:743
#, no-wrap
msgid ""
"9   goto-if-not-nil 1     ; @r{Goto 1 if @code{n} > 0}\n"
"                          ;   @r{(this continues the while loop)}\n"
"                          ;   @r{else continue.}\n"
msgstr ""
"9   goto-if-not-nil 1     ; @r{@code{n} > 0なら1へ}\n"
"                          ;   @r{(これはwhile-loopを継続する)}\n"
"                          ;   @r{それ以外はcontinue}\n"

#. type: group
#: original_texis/compile.texi:749
#, no-wrap
msgid ""
"12  varref   t1           ; @r{Push value of @code{t1} onto stack.}\n"
"13  constant current-time-string  ; @r{Push @code{current-time-string}}\n"
"                                  ;   @r{onto the top of the stack.}\n"
"14  call     0            ; @r{Call @code{current-time-string} again.}\n"
msgstr ""
"12  varref   t1           ; @r{@code{t1}の値をスタック上にpushする}\n"
"13  constant current-time-string  ; @r{@code{current-time-string}を}\n"
"                                  ;   @r{スタックのトップにpushする}\n"
"14  call     0            ; @r{再度@code{current-time-string}を呼び出す}\n"

#. type: group
#: original_texis/compile.texi:755
#, no-wrap
msgid ""
"15  unbind   1            ; @r{Unbind @code{t1} in local environment.}\n"
"16  list2                 ; @r{Pop top two elements off stack, create a}\n"
"                          ;   @r{list of them, and push it onto stack.}\n"
"17  return                ; @r{Return value of the top of stack.}\n"
msgstr ""
"15  unbind   1            ; @r{ローカル環境の@code{t1}をアンバインドする}\n"
"16  list2                 ; @r{スタックのトップ2要素をpopして取り出し}\n"
"                          ;   @r{それらのリストを作りスタック上にpushする}\n"
"17  return                ; @r{スタックのトップの値をリターンする}\n"
