# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2024-06-26 23:45+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: original_texis/eval.texi:6 original_texis/eval.texi:7
#, no-wrap
msgid "Evaluation"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:8
#, no-wrap
msgid "evaluation"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:9 original_texis/eval.texi:10
#, no-wrap
msgid "interpreter"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:11
#, no-wrap
msgid "value of expression"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:20
msgid ""
"The @dfn{evaluation} of expressions in Emacs Lisp is performed by the "
"@dfn{Lisp interpreter}---a program that receives a Lisp object as input and "
"computes its @dfn{value as an expression}.  How it does this depends on the "
"data type of the object, according to rules described in this chapter.  The "
"interpreter runs automatically to evaluate portions of your program, but can "
"also be called explicitly via the Lisp primitive function @code{eval}."
msgstr ""

#. type: node
#: original_texis/eval.texi:29 original_texis/eval.texi:31
#, no-wrap
msgid "Intro Eval"
msgstr ""

#. type: menuentry
#: original_texis/eval.texi:29
msgid "Evaluation in the scheme of things."
msgstr ""

#. type: node
#: original_texis/eval.texi:29 original_texis/eval.texi:103
#, no-wrap
msgid "Forms"
msgstr ""

#. type: menuentry
#: original_texis/eval.texi:29
msgid "How various sorts of objects are evaluated."
msgstr ""

#. type: section
#: original_texis/eval.texi:29 original_texis/eval.texi:508
#: original_texis/eval.texi:555 original_texis/eval.texi:556
#, no-wrap
msgid "Quoting"
msgstr ""

#. type: menuentry
#: original_texis/eval.texi:29
msgid "Avoiding evaluation (to put constants in the program)."
msgstr ""

#. type: section
#: original_texis/eval.texi:29 original_texis/eval.texi:620
#: original_texis/eval.texi:621
#, no-wrap
msgid "Backquote"
msgstr ""

#. type: menuentry
#: original_texis/eval.texi:29
msgid "Easier construction of list structure."
msgstr ""

#. type: section
#: original_texis/eval.texi:29 original_texis/eval.texi:717
#: original_texis/eval.texi:718
#, no-wrap
msgid "Eval"
msgstr ""

#. type: menuentry
#: original_texis/eval.texi:29
msgid "How to invoke the Lisp interpreter explicitly."
msgstr ""

#. type: node
#: original_texis/eval.texi:29 original_texis/eval.texi:908
#, no-wrap
msgid "Deferred Eval"
msgstr ""

#. type: menuentry
#: original_texis/eval.texi:29
msgid "Deferred and lazy evaluation of forms."
msgstr ""

#. type: section
#: original_texis/eval.texi:32
#, no-wrap
msgid "Introduction to Evaluation"
msgstr ""

#. type: ifnottex
#: original_texis/eval.texi:40
msgid ""
"The Lisp interpreter, or evaluator, is the part of Emacs that computes the "
"value of an expression that is given to it.  When a function written in Lisp "
"is called, the evaluator computes the value of the function by evaluating "
"the expressions in the function body.  Thus, running any Lisp program really "
"means running the Lisp interpreter."
msgstr ""

#. type: cindex
#: original_texis/eval.texi:42
#, no-wrap
msgid "form"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:43
#, no-wrap
msgid "expression"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:44
#, no-wrap
msgid "S-expression"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:45
#, no-wrap
msgid "sexp"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:54
msgid ""
"A Lisp object that is intended for evaluation is called a @dfn{form} or "
"@dfn{expression}@footnote{It is sometimes also referred to as an "
"@dfn{S-expression} or @dfn{sexp}, but we generally do not use this "
"terminology in this manual.}.  The fact that forms are data objects and not "
"merely text is one of the fundamental differences between Lisp-like "
"languages and typical programming languages.  Any object can be evaluated, "
"but in practice only numbers, symbols, lists and strings are evaluated very "
"often."
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:57
msgid ""
"In subsequent sections, we will describe the details of what evaluation "
"means for each kind of form."
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:65
msgid ""
"It is very common to read a Lisp form and then evaluate the form, but "
"reading and evaluation are separate activities, and either can be performed "
"alone.  Reading per se does not evaluate anything; it converts the printed "
"representation of a Lisp object to the object itself.  It is up to the "
"caller of @code{read} to specify whether this object is a form to be "
"evaluated, or serves some entirely different purpose.  @xref{Input "
"Functions}."
msgstr ""

#. type: cindex
#: original_texis/eval.texi:66
#, no-wrap
msgid "recursive evaluation"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:77
msgid ""
"Evaluation is a recursive process, and evaluating a form often involves "
"evaluating parts within that form.  For instance, when you evaluate a "
"@dfn{function call} form such as @code{(car x)}, Emacs first evaluates the "
"argument (the subform @code{x}).  After evaluating the argument, Emacs "
"@dfn{executes} the function (@code{car}), and if the function is written in "
"Lisp, execution works by evaluating the @dfn{body} of the function (in this "
"example, however, @code{car} is not a Lisp function; it is a primitive "
"function implemented in C).  @xref{Functions}, for more information about "
"functions and function calls."
msgstr ""

#. type: cindex
#: original_texis/eval.texi:78
#, no-wrap
msgid "environment"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:88
msgid ""
"Evaluation takes place in a context called the @dfn{environment}, which "
"consists of the current values and bindings of all Lisp variables "
"(@pxref{Variables}).@footnote{This definition of ``environment'' is "
"specifically not intended to include all the data that can affect the result "
"of a program.} Whenever a form refers to a variable without creating a new "
"binding for it, the variable evaluates to the value given by the current "
"environment.  Evaluating a form may also temporarily alter the environment "
"by binding variables (@pxref{Local Variables})."
msgstr ""

#. type: cindex
#: original_texis/eval.texi:89
#, no-wrap
msgid "side effect"
msgstr ""

#. type: anchor{#1}
#: original_texis/eval.texi:94
msgid "Definition of side effect"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:94
msgid ""
"Evaluating a form may also make changes that persist; these changes are "
"called @dfn{side effects}.  An example of a form that produces a side effect "
"is @code{(setq foo 1)}."
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:102
msgid ""
"Do not confuse evaluation with command key interpretation.  The editor "
"command loop translates keyboard input into a command (an interactively "
"callable function) using the active keymaps, and then uses "
"@code{call-interactively} to execute that command.  Executing the command "
"usually involves evaluation, if the command is written in Lisp; however, "
"this step is not considered a part of command key interpretation.  "
"@xref{Command Loop}."
msgstr ""

#. type: section
#: original_texis/eval.texi:104
#, no-wrap
msgid "Kinds of Forms"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:112
msgid ""
"A Lisp object that is intended to be evaluated is called a @dfn{form} (or an "
"@dfn{expression}).  How Emacs evaluates a form depends on its data type.  "
"Emacs has three different kinds of form that are evaluated differently: "
"symbols, lists, and all other types.  This section describes all three "
"kinds, one by one, starting with the other types, which are self-evaluating "
"forms."
msgstr ""

#. type: subsection
#: original_texis/eval.texi:125 original_texis/eval.texi:127
#: original_texis/eval.texi:128
#, no-wrap
msgid "Self-Evaluating Forms"
msgstr ""

#. type: menuentry
#: original_texis/eval.texi:125
msgid "Forms that evaluate to themselves."
msgstr ""

#. type: subsection
#: original_texis/eval.texi:125 original_texis/eval.texi:188
#: original_texis/eval.texi:189
#, no-wrap
msgid "Symbol Forms"
msgstr ""

#. type: menuentry
#: original_texis/eval.texi:125
msgid "Symbols evaluate as variables."
msgstr ""

#. type: node
#: original_texis/eval.texi:125 original_texis/eval.texi:226
#, no-wrap
msgid "Classifying Lists"
msgstr ""

#. type: menuentry
#: original_texis/eval.texi:125
msgid "How to distinguish various sorts of list forms."
msgstr ""

#. type: node
#: original_texis/eval.texi:125 original_texis/eval.texi:243
#, no-wrap
msgid "Function Indirection"
msgstr ""

#. type: menuentry
#: original_texis/eval.texi:125
msgid ""
"When a symbol appears as the car of a list, we find the real function via "
"the symbol."
msgstr ""

#. type: node
#: original_texis/eval.texi:125 original_texis/eval.texi:360
#, no-wrap
msgid "Function Forms"
msgstr ""

#. type: menuentry
#: original_texis/eval.texi:125
msgid "Forms that call functions."
msgstr ""

#. type: node
#: original_texis/eval.texi:125 original_texis/eval.texi:385
#, no-wrap
msgid "Macro Forms"
msgstr ""

#. type: menuentry
#: original_texis/eval.texi:125
msgid "Forms that call macros."
msgstr ""

#. type: subsection
#: original_texis/eval.texi:125 original_texis/eval.texi:432
#: original_texis/eval.texi:433
#, no-wrap
msgid "Special Forms"
msgstr ""

#. type: menuentry
#: original_texis/eval.texi:125
msgid ""
"Special forms are idiosyncratic primitives, most of them extremely "
"important."
msgstr ""

#. type: subsection
#: original_texis/eval.texi:125 original_texis/eval.texi:543
#: original_texis/eval.texi:544
#, no-wrap
msgid "Autoloading"
msgstr ""

#. type: menuentry
#: original_texis/eval.texi:125
msgid "Functions set up to load files containing their real definitions."
msgstr ""

#. type: cindex
#: original_texis/eval.texi:129
#, no-wrap
msgid "vector evaluation"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:130
#, no-wrap
msgid "literal evaluation"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:131
#, no-wrap
msgid "self-evaluating form"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:132
#, no-wrap
msgid "form, self-evaluating"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:141
msgid ""
"A @dfn{self-evaluating form} is any form that is not a list or symbol.  "
"Self-evaluating forms evaluate to themselves: the result of evaluation is "
"the same object that was evaluated.  Thus, the number 25 evaluates to 25, "
"and the string @code{\"foo\"} evaluates to the string @code{\"foo\"}.  "
"Likewise, evaluating a vector does not cause evaluation of the elements of "
"the vector---it returns the same vector with its contents unchanged."
msgstr ""

#. type: group
#: original_texis/eval.texi:146
#, no-wrap
msgid ""
"'123               ; @r{A number, shown without evaluation.}\n"
"     @result{} 123\n"
msgstr ""

#. type: group
#: original_texis/eval.texi:150
#, no-wrap
msgid ""
"123                ; @r{Evaluated as usual---result is the same.}\n"
"     @result{} 123\n"
msgstr ""

#. type: group
#: original_texis/eval.texi:154
#, no-wrap
msgid ""
"(eval '123)        ; @r{Evaluated \"by hand\"---result is the same.}\n"
"     @result{} 123\n"
msgstr ""

#. type: group
#: original_texis/eval.texi:158
#, no-wrap
msgid ""
"(eval (eval '123)) ; @r{Evaluating twice changes nothing.}\n"
"     @result{} 123\n"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:166
msgid ""
"A self-evaluating form yields a value that becomes part of the program, and "
"you should not try to modify it via @code{setcar}, @code{aset} or similar "
"operations.  The Lisp interpreter might unify the constants yielded by your "
"program's self-evaluating forms, so that these constants might share "
"structure.  @xref{Mutability}."
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:173
msgid ""
"It is common to write numbers, characters, strings, and even vectors in Lisp "
"code, taking advantage of the fact that they self-evaluate.  However, it is "
"quite unusual to do this for types that lack a read syntax, because there's "
"no way to write them textually.  It is possible to construct Lisp "
"expressions containing these types by means of a Lisp program.  Here is an "
"example:"
msgstr ""

#. type: group
#: original_texis/eval.texi:179
#, no-wrap
msgid ""
";; @r{Build an expression containing a buffer object.}\n"
"(setq print-exp (list 'print (current-buffer)))\n"
"     @result{} (print #<buffer eval.texi>)\n"
msgstr ""

#. type: group
#: original_texis/eval.texi:185
#, no-wrap
msgid ""
";; @r{Evaluate it.}\n"
"(eval print-exp)\n"
"     @print{} #<buffer eval.texi>\n"
"     @result{} #<buffer eval.texi>\n"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:190
#, no-wrap
msgid "symbol evaluation"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:191
#, no-wrap
msgid "symbol forms"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:192
#, no-wrap
msgid "forms, symbol"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:198
msgid ""
"When a symbol is evaluated, it is treated as a variable.  The result is the "
"variable's value, if it has one.  If the symbol has no value as a variable, "
"the Lisp interpreter signals an error.  For more information on the use of "
"variables, see @ref{Variables}."
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:202
msgid ""
"In the following example, we set the value of a symbol with @code{setq}.  "
"Then we evaluate the symbol, and get back the value that @code{setq} stored."
msgstr ""

#. type: group
#: original_texis/eval.texi:207
#, no-wrap
msgid ""
"(setq a 123)\n"
"     @result{} 123\n"
msgstr ""

#. type: group
#: original_texis/eval.texi:211
#, no-wrap
msgid ""
"(eval 'a)\n"
"     @result{} 123\n"
msgstr ""

#. type: group
#: original_texis/eval.texi:215
#, no-wrap
msgid ""
"a\n"
"     @result{} 123\n"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:225
msgid ""
"The symbols @code{nil} and @code{t} are treated specially, so that the value "
"of @code{nil} is always @code{nil}, and the value of @code{t} is always "
"@code{t}; you cannot set or bind them to any other values.  Thus, these two "
"symbols act like self-evaluating forms, even though @code{eval} treats them "
"like any other symbol.  A symbol whose name starts with @samp{:} also "
"self-evaluates in the same way; likewise, its value ordinarily cannot be "
"changed.  @xref{Constant Variables}."
msgstr ""

#. type: subsection
#: original_texis/eval.texi:227
#, no-wrap
msgid "Classification of List Forms"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:228
#, no-wrap
msgid "list form evaluation"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:229
#, no-wrap
msgid "forms, list"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:236
msgid ""
"A form that is a nonempty list is either a function call, a macro call, or a "
"special form, according to its first element.  These three kinds of forms "
"are evaluated in different ways, described below.  The remaining list "
"elements constitute the @dfn{arguments} for the function, macro, or special "
"form."
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:242
msgid ""
"The first step in evaluating a nonempty list is to examine its first "
"element.  This element alone determines what kind of form the list is and "
"how the rest of the list is to be processed.  The first element is "
"@emph{not} evaluated, as it would be in some Lisp dialects such as Scheme."
msgstr ""

#. type: subsection
#: original_texis/eval.texi:244
#, no-wrap
msgid "Symbol Function Indirection"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:245
#, no-wrap
msgid "symbol function indirection"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:246
#, no-wrap
msgid "indirection for functions"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:247
#, no-wrap
msgid "void function"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:255
msgid ""
"If the first element of the list is a symbol then evaluation examines the "
"symbol's function cell, and uses its contents instead of the original "
"symbol.  If the contents are another symbol, this process, called "
"@dfn{symbol function indirection}, is repeated until it obtains a "
"non-symbol.  @xref{Function Names}, for more information about symbol "
"function indirection."
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:260
msgid ""
"One possible consequence of this process is an infinite loop, in the event "
"that a symbol's function cell refers to the same symbol.  Otherwise, we "
"eventually obtain a non-symbol, which ought to be a function or other "
"suitable object."
msgstr ""

#. type: kindex
#: original_texis/eval.texi:261
#, no-wrap
msgid "invalid-function"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:267
msgid ""
"More precisely, we should now have a Lisp function (a lambda expression), a "
"byte-code function, a primitive function, a Lisp macro, a special form, or "
"an autoload object.  Each of these types is a case described in one of the "
"following sections.  If the object is not one of these types, Emacs signals "
"an @code{invalid-function} error."
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:274
msgid ""
"The following example illustrates the symbol indirection process.  We use "
"@code{fset} to set the function cell of a symbol and @code{symbol-function} "
"to get the function cell contents (@pxref{Function Cells}).  Specifically, "
"we store the symbol @code{car} into the function cell of @code{first}, and "
"the symbol @code{first} into the function cell of @code{erste}."
msgstr ""

#. type: group
#: original_texis/eval.texi:281
#, no-wrap
msgid ""
";; @r{Build this function cell linkage:}\n"
";;   -------------       -----        -------        -------\n"
";;  | #<subr car> | <-- | car |  <-- | first |  <-- | erste |\n"
";;   -------------       -----        -------        -------\n"
msgstr ""

#. type: group
#: original_texis/eval.texi:285
#, no-wrap
msgid ""
"(symbol-function 'car)\n"
"     @result{} #<subr car>\n"
msgstr ""

#. type: group
#: original_texis/eval.texi:289
#, no-wrap
msgid ""
"(fset 'first 'car)\n"
"     @result{} car\n"
msgstr ""

#. type: group
#: original_texis/eval.texi:293
#, no-wrap
msgid ""
"(fset 'erste 'first)\n"
"     @result{} first\n"
msgstr ""

#. type: group
#: original_texis/eval.texi:297
#, no-wrap
msgid ""
"(erste '(1 2 3))   ; @r{Call the function referenced by @code{erste}.}\n"
"     @result{} 1\n"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:303
msgid ""
"By contrast, the following example calls a function without any symbol "
"function indirection, because the first element is an anonymous Lisp "
"function, not a symbol."
msgstr ""

#. type: group
#: original_texis/eval.texi:309
#, no-wrap
msgid ""
"((lambda (arg) (erste arg))\n"
" '(1 2 3))\n"
"     @result{} 1\n"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:315
msgid ""
"Executing the function itself evaluates its body; this does involve symbol "
"function indirection when calling @code{erste}."
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:318
msgid ""
"This form is rarely used and is now deprecated.  Instead, you should write "
"it as:"
msgstr ""

#. type: group
#: original_texis/eval.texi:323
#, no-wrap
msgid ""
"(funcall (lambda (arg) (erste arg))\n"
"         '(1 2 3))\n"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:326
msgid "or just"
msgstr ""

#. type: group
#: original_texis/eval.texi:329
#, no-wrap
msgid "(let ((arg '(1 2 3))) (erste arg))\n"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:334
msgid ""
"The built-in function @code{indirect-function} provides an easy way to "
"perform symbol function indirection explicitly."
msgstr ""

#. type: defun
#: original_texis/eval.texi:335
#, no-wrap
msgid "indirect-function function &optional noerror"
msgstr ""

#. type: anchor{#1}
#: original_texis/eval.texi:341
msgid "Definition of indirect-function"
msgstr ""

#. type: defun
#: original_texis/eval.texi:341
msgid ""
"This function returns the meaning of @var{function} as a function.  If "
"@var{function} is a symbol, then it finds @var{function}'s function "
"definition and starts over with that value.  If @var{function} is not a "
"symbol, then it returns @var{function} itself."
msgstr ""

#. type: defun
#: original_texis/eval.texi:345
msgid ""
"This function returns @code{nil} if the final symbol is unbound.  It signals "
"a @code{cyclic-function-indirection} error if there is a loop in the chain "
"of symbols."
msgstr ""

#. type: defun
#: original_texis/eval.texi:348
msgid ""
"The optional argument @var{noerror} is obsolete, kept for backward "
"compatibility, and has no effect."
msgstr ""

#. type: defun
#: original_texis/eval.texi:350
msgid "Here is how you could define @code{indirect-function} in Lisp:"
msgstr ""

#. type: example
#: original_texis/eval.texi:357
#, no-wrap
msgid ""
"(defun indirect-function (function)\n"
"  (if (and function\n"
"           (symbolp function))\n"
"      (indirect-function (symbol-function function))\n"
"    function))\n"
msgstr ""

#. type: subsection
#: original_texis/eval.texi:361
#, no-wrap
msgid "Evaluation of Function Forms"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:362
#, no-wrap
msgid "function form evaluation"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:363
#, no-wrap
msgid "function call"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:364
#, no-wrap
msgid "forms, function call"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:370
msgid ""
"If the first element of a list being evaluated is a Lisp function object, "
"byte-code object or primitive function object, then that list is a "
"@dfn{function call}.  For example, here is a call to the function @code{+}:"
msgstr ""

#. type: example
#: original_texis/eval.texi:373
#, no-wrap
msgid "(+ 1 x)\n"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:384
msgid ""
"The first step in evaluating a function call is to evaluate the remaining "
"elements of the list from left to right.  The results are the actual "
"argument values, one value for each list element.  The next step is to call "
"the function with this list of arguments, effectively using the function "
"@code{apply} (@pxref{Calling Functions}).  If the function is written in "
"Lisp, the arguments are used to bind the argument variables of the function "
"(@pxref{Lambda Expressions}); then the forms in the function body are "
"evaluated in order, and the value of the last body form becomes the value of "
"the function call."
msgstr ""

#. type: subsection
#: original_texis/eval.texi:386
#, no-wrap
msgid "Lisp Macro Evaluation"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:387
#, no-wrap
msgid "macro call evaluation"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:388
#, no-wrap
msgid "forms, macro call"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:399
msgid ""
"If the first element of a list being evaluated is a macro object, then the "
"list is a @dfn{macro call}.  When a macro call is evaluated, the elements of "
"the rest of the list are @emph{not} initially evaluated.  Instead, these "
"elements themselves are used as the arguments of the macro.  The macro "
"definition computes a replacement form, called the @dfn{expansion} of the "
"macro, to be evaluated in place of the original form.  The expansion may be "
"any sort of form: a self-evaluating constant, a symbol, or a list.  If the "
"expansion is itself a macro call, this process of expansion repeats until "
"some other sort of form results."
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:404
msgid ""
"Ordinary evaluation of a macro call finishes by evaluating the expansion.  "
"However, the macro expansion is not necessarily evaluated right away, or at "
"all, because other programs also expand macro calls, and they may or may not "
"evaluate the expansions."
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:408
msgid ""
"Normally, the argument expressions are not evaluated as part of computing "
"the macro expansion, but instead appear as part of the expansion, so they "
"are computed when the expansion is evaluated."
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:410
msgid "For example, given a macro defined as follows:"
msgstr ""

#. type: group
#: original_texis/eval.texi:415
#, no-wrap
msgid ""
"(defmacro cadr (x)\n"
"  (list 'car (list 'cdr x)))\n"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:421
msgid ""
"an expression such as @code{(cadr (assq 'handler list))} is a macro call, "
"and its expansion is:"
msgstr ""

#. type: example
#: original_texis/eval.texi:424
#, no-wrap
msgid "(car (cdr (assq 'handler list)))\n"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:429
msgid "Note that the argument @code{(assq 'handler list)} appears in the expansion."
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:431
msgid "@xref{Macros}, for a complete description of Emacs Lisp macros."
msgstr ""

#. type: cindex
#: original_texis/eval.texi:434
#, no-wrap
msgid "special forms"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:435
#, no-wrap
msgid "forms, special"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:436
#, no-wrap
msgid "evaluation of special forms"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:442
msgid ""
"A @dfn{special form} is a primitive specially marked so that its arguments "
"are not all evaluated.  Most special forms define control structures or "
"perform variable bindings---things which functions cannot do."
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:446
msgid ""
"Each special form has its own rules for which arguments are evaluated and "
"which are used without evaluation.  Whether a particular argument is "
"evaluated may depend on the results of evaluating other arguments."
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:454
msgid ""
"If an expression's first symbol is that of a special form, the expression "
"should follow the rules of that special form; otherwise, Emacs's behavior is "
"not well-defined (though it will not crash).  For example, @code{((lambda "
"(x) x . 3) 4)} contains a subexpression that begins with @code{lambda} but "
"is not a well-formed @code{lambda} expression, so Emacs may signal an error, "
"or may return 3 or 4 or @code{nil}, or may behave in other ways."
msgstr ""

#. type: defun
#: original_texis/eval.texi:455
#, no-wrap
msgid "special-form-p object"
msgstr ""

#. type: defun
#: original_texis/eval.texi:458
msgid ""
"This predicate tests whether its argument is a special form, and returns "
"@code{t} if so, @code{nil} otherwise."
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:462
msgid ""
"Here is a list, in alphabetical order, of all of the special forms in Emacs "
"Lisp with a reference to where each is described."
msgstr ""

#. type: item
#: original_texis/eval.texi:464
#, no-wrap
msgid "and"
msgstr ""

#. type: pxref{#1}
#: original_texis/eval.texi:466 original_texis/eval.texi:500
msgid "Combining Conditions"
msgstr ""

#. type: item
#: original_texis/eval.texi:467
#, no-wrap
msgid "catch"
msgstr ""

#. type: pxref{#1}
#: original_texis/eval.texi:469
msgid "Catch and Throw"
msgstr ""

#. type: item
#: original_texis/eval.texi:470
#, no-wrap
msgid "cond"
msgstr ""

#. type: pxref{#1}
#: original_texis/eval.texi:472 original_texis/eval.texi:487
msgid "Conditionals"
msgstr ""

#. type: item
#: original_texis/eval.texi:473
#, no-wrap
msgid "condition-case"
msgstr ""

#. type: pxref{#1}
#: original_texis/eval.texi:475
msgid "Handling Errors"
msgstr ""

#. type: item
#: original_texis/eval.texi:476
#, no-wrap
msgid "defconst"
msgstr ""

#. type: pxref{#1}
#: original_texis/eval.texi:478 original_texis/eval.texi:481
msgid "Defining Variables"
msgstr ""

#. type: item
#: original_texis/eval.texi:479
#, no-wrap
msgid "defvar"
msgstr ""

#. type: item
#: original_texis/eval.texi:482
#, no-wrap
msgid "function"
msgstr ""

#. type: pxref{#1}
#: original_texis/eval.texi:484
msgid "Anonymous Functions"
msgstr ""

#. type: item
#: original_texis/eval.texi:485
#, no-wrap
msgid "if"
msgstr ""

#. type: item
#: original_texis/eval.texi:488
#, no-wrap
msgid "interactive"
msgstr ""

#. type: pxref{#1}
#: original_texis/eval.texi:490
msgid "Interactive Call"
msgstr ""

#. type: item
#: original_texis/eval.texi:491
#, no-wrap
msgid "lambda"
msgstr ""

#. type: pxref{#1}
#: original_texis/eval.texi:493
msgid "Lambda Expressions"
msgstr ""

#. type: item
#: original_texis/eval.texi:494
#, no-wrap
msgid "let"
msgstr ""

#. type: itemx
#: original_texis/eval.texi:495
#, no-wrap
msgid "let*"
msgstr ""

#. type: pxref{#1}
#: original_texis/eval.texi:497
msgid "Local Variables"
msgstr ""

#. type: item
#: original_texis/eval.texi:498
#, no-wrap
msgid "or"
msgstr ""

#. type: item
#: original_texis/eval.texi:501
#, no-wrap
msgid "prog1"
msgstr ""

#. type: itemx
#: original_texis/eval.texi:502
#, no-wrap
msgid "prog2"
msgstr ""

#. type: itemx
#: original_texis/eval.texi:503
#, no-wrap
msgid "progn"
msgstr ""

#. type: pxref{#1}
#: original_texis/eval.texi:505
msgid "Sequencing"
msgstr ""

#. type: item
#: original_texis/eval.texi:506
#, no-wrap
msgid "quote"
msgstr ""

#. type: item
#: original_texis/eval.texi:509
#, no-wrap
msgid "save-current-buffer"
msgstr ""

#. type: pxref{#1}
#: original_texis/eval.texi:511
msgid "Current Buffer"
msgstr ""

#. type: item
#: original_texis/eval.texi:512
#, no-wrap
msgid "save-excursion"
msgstr ""

#. type: pxref{#1}
#: original_texis/eval.texi:514
msgid "Excursions"
msgstr ""

#. type: item
#: original_texis/eval.texi:515
#, no-wrap
msgid "save-restriction"
msgstr ""

#. type: pxref{#1}
#: original_texis/eval.texi:517
msgid "Narrowing"
msgstr ""

#. type: item
#: original_texis/eval.texi:518
#, no-wrap
msgid "setq"
msgstr ""

#. type: pxref{#1}
#: original_texis/eval.texi:520
msgid "Setting Variables"
msgstr ""

#. type: item
#: original_texis/eval.texi:521
#, no-wrap
msgid "setq-default"
msgstr ""

#. type: pxref{#1}
#: original_texis/eval.texi:523
msgid "Creating Buffer-Local"
msgstr ""

#. type: item
#: original_texis/eval.texi:524
#, no-wrap
msgid "unwind-protect"
msgstr ""

#. type: pxref{#1}
#: original_texis/eval.texi:526
msgid "Nonlocal Exits"
msgstr ""

#. type: item
#: original_texis/eval.texi:527
#, no-wrap
msgid "while"
msgstr ""

#. type: pxref{#1}
#: original_texis/eval.texi:529
msgid "Iteration"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:531
#, no-wrap
msgid "CL note---special forms compared"
msgstr ""

#. type: quotation
#: original_texis/eval.texi:541
msgid ""
"@b{Common Lisp note:} Here are some comparisons of special forms in GNU "
"Emacs Lisp and Common Lisp.  @code{setq}, @code{if}, and @code{catch} are "
"special forms in both Emacs Lisp and Common Lisp.  @code{save-excursion} is "
"a special form in Emacs Lisp, but doesn't exist in Common Lisp.  "
"@code{throw} is a special form in Common Lisp (because it must be able to "
"throw multiple values), but it is a function in Emacs Lisp (which doesn't "
"have multiple values)."
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:554
msgid ""
"The @dfn{autoload} feature allows you to call a function or macro whose "
"function definition has not yet been loaded into Emacs.  It specifies which "
"file contains the definition.  When an autoload object appears as a symbol's "
"function definition, calling that symbol as a function automatically loads "
"the specified file; then it calls the real definition loaded from that "
"file.  The way to arrange for an autoload object to appear as a symbol's "
"function definition is described in @ref{Autoload}."
msgstr ""

#. type: cindex
#: original_texis/eval.texi:557
#, no-wrap
msgid "forms, quote"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:564
msgid ""
"The special form @code{quote} returns its single argument, as written, "
"without evaluating it.  This provides a way to include constant symbols and "
"lists, which are not self-evaluating objects, in a program.  (It is not "
"necessary to quote self-evaluating objects such as numbers, strings, and "
"vectors.)"
msgstr ""

#. type: defspec
#: original_texis/eval.texi:565
#, no-wrap
msgid "quote object"
msgstr ""

#. type: defspec
#: original_texis/eval.texi:569
msgid ""
"This special form returns @var{object}, without evaluating it.  The returned "
"value might be shared and should not be modified.  @xref{Self-Evaluating "
"Forms}."
msgstr ""

#. type: cindex
#: original_texis/eval.texi:571
#, no-wrap
msgid "@samp{'} for quoting"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:572
#, no-wrap
msgid "quoting using apostrophe"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:573
#, no-wrap
msgid "apostrophe for quoting"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:579
msgid ""
"Because @code{quote} is used so often in programs, Lisp provides a "
"convenient read syntax for it.  An apostrophe character (@samp{'})  followed "
"by a Lisp object (in read syntax) expands to a list whose first element is "
"@code{quote}, and whose second element is the object.  Thus, the read syntax "
"@code{'x} is an abbreviation for @code{(quote x)}."
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:581
msgid "Here are some examples of expressions that use @code{quote}:"
msgstr ""

#. type: group
#: original_texis/eval.texi:586
#, no-wrap
msgid ""
"(quote (+ 1 2))\n"
"     @result{} (+ 1 2)\n"
msgstr ""

#. type: group
#: original_texis/eval.texi:590
#, no-wrap
msgid ""
"(quote foo)\n"
"     @result{} foo\n"
msgstr ""

#. type: group
#: original_texis/eval.texi:594
#, no-wrap
msgid ""
"'foo\n"
"     @result{} foo\n"
msgstr ""

#. type: group
#: original_texis/eval.texi:598
#, no-wrap
msgid ""
"''foo\n"
"     @result{} 'foo\n"
msgstr ""

#. type: group
#: original_texis/eval.texi:602
#, no-wrap
msgid ""
"'(quote foo)\n"
"     @result{} 'foo\n"
msgstr ""

#. type: group
#: original_texis/eval.texi:606
#, no-wrap
msgid ""
"['foo]\n"
"     @result{} ['foo]\n"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:614
msgid ""
"Although the expressions @code{(list '+ 1 2)} and @code{'(+ 1 2)} both yield "
"lists equal to @code{(+ 1 2)}, the former yields a freshly-minted mutable "
"list whereas the latter yields a list built from conses that might be shared "
"and should not be modified.  @xref{Self-Evaluating Forms}."
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:619
msgid ""
"Other quoting constructs include @code{function} (@pxref{Anonymous "
"Functions}), which causes an anonymous lambda expression written in Lisp to "
"be compiled, and @samp{`} (@pxref{Backquote}), which is used to quote only "
"part of a list, while computing and substituting other parts."
msgstr ""

#. type: cindex
#: original_texis/eval.texi:622
#, no-wrap
msgid "backquote (list substitution)"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:623
#, no-wrap
msgid "` (list substitution)"
msgstr ""

#. type: findex
#: original_texis/eval.texi:624
#, no-wrap
msgid "`"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:625
#, no-wrap
msgid "forms, backquote"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:630
msgid ""
"@dfn{Backquote constructs} allow you to quote a list, but selectively "
"evaluate elements of that list.  In the simplest case, it is identical to "
"the special form"
msgstr ""

#. type: iftex
#: original_texis/eval.texi:632
msgid "@code{quote}."
msgstr ""

#. type: ifnottex
#: original_texis/eval.texi:636
msgid "@code{quote} (described in the previous section; @pxref{Quoting})."
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:638
msgid "For example, these two forms yield identical results:"
msgstr ""

#. type: group
#: original_texis/eval.texi:643
#, no-wrap
msgid ""
"`(a list of (+ 2 3) elements)\n"
"     @result{} (a list of (+ 2 3) elements)\n"
msgstr ""

#. type: group
#: original_texis/eval.texi:647
#, no-wrap
msgid ""
"'(a list of (+ 2 3) elements)\n"
"     @result{} (a list of (+ 2 3) elements)\n"
msgstr ""

#. type: findex
#: original_texis/eval.texi:650
#, no-wrap
msgid ", @r{(with backquote)}"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:655
msgid ""
"The special marker @samp{,} inside of the argument to backquote indicates a "
"value that isn't constant.  The Emacs Lisp evaluator evaluates the argument "
"of @samp{,}, and puts the value in the list structure:"
msgstr ""

#. type: group
#: original_texis/eval.texi:660
#, no-wrap
msgid ""
"`(a list of ,(+ 2 3) elements)\n"
"     @result{} (a list of 5 elements)\n"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:666
msgid ""
"Substitution with @samp{,} is allowed at deeper levels of the list structure "
"also.  For example:"
msgstr ""

#. type: group
#: original_texis/eval.texi:671
#, no-wrap
msgid ""
"`(1 2 (3 ,(+ 4 5)))\n"
"     @result{} (1 2 (3 9))\n"
msgstr ""

#. type: findex
#: original_texis/eval.texi:674
#, no-wrap
msgid ",@@ @r{(with backquote)}"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:675
#, no-wrap
msgid "splicing (with backquote)"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:681
msgid ""
"You can also @dfn{splice} an evaluated value into the resulting list, using "
"the special marker @samp{,@@}.  The elements of the spliced list become "
"elements at the same level as the other elements of the resulting list.  The "
"equivalent code without using @samp{`} is often unreadable.  Here are some "
"examples:"
msgstr ""

#. type: group
#: original_texis/eval.texi:686
#, no-wrap
msgid ""
"(setq some-list '(2 3))\n"
"     @result{} (2 3)\n"
msgstr ""

#. type: group
#: original_texis/eval.texi:690
#, no-wrap
msgid ""
"(cons 1 (append some-list '(4) some-list))\n"
"     @result{} (1 2 3 4 2 3)\n"
msgstr ""

#. type: group
#: original_texis/eval.texi:694
#, no-wrap
msgid ""
"`(1 ,@@some-list 4 ,@@some-list)\n"
"     @result{} (1 2 3 4 2 3)\n"
msgstr ""

#. type: group
#: original_texis/eval.texi:699
#, no-wrap
msgid ""
"(setq list '(hack foo bar))\n"
"     @result{} (hack foo bar)\n"
msgstr ""

#. type: group
#: original_texis/eval.texi:705
#, no-wrap
msgid ""
"(cons 'use\n"
"  (cons 'the\n"
"    (cons 'words (append (cdr list) '(as elements)))))\n"
"     @result{} (use the words foo bar as elements)\n"
msgstr ""

#. type: group
#: original_texis/eval.texi:709
#, no-wrap
msgid ""
"`(use the words ,@@(cdr list) as elements)\n"
"     @result{} (use the words foo bar as elements)\n"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:716
msgid ""
"If a subexpression of a backquote construct has no substitutions or splices, "
"it acts like @code{quote} in that it yields conses, vectors and strings that "
"might be shared and should not be modified.  @xref{Self-Evaluating Forms}."
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:730
msgid ""
"Most often, forms are evaluated automatically, by virtue of their occurrence "
"in a program being run.  On rare occasions, you may need to write code that "
"evaluates a form that is computed at run time, such as after reading a form "
"from text being edited or getting one from a property list.  On these "
"occasions, use the @code{eval} function.  Often @code{eval} is not needed "
"and something else should be used instead.  For example, to get the value of "
"a variable, while @code{eval} works, @code{symbol-value} is preferable; or "
"rather than store expressions in a property list that then need to go "
"through @code{eval}, it is better to store functions instead that are then "
"passed to @code{funcall}."
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:734
msgid ""
"The functions and variables described in this section evaluate forms, "
"specify limits to the evaluation process, or record recently returned "
"values.  Loading a file also does evaluation (@pxref{Loading})."
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:740
msgid ""
"It is generally cleaner and more flexible to store a function in a data "
"structure, and call it with @code{funcall} or @code{apply}, than to store an "
"expression in the data structure and evaluate it.  Using functions provides "
"the ability to pass information to them as arguments."
msgstr ""

#. type: defun
#: original_texis/eval.texi:741
#, no-wrap
msgid "eval form &optional lexical"
msgstr ""

#. type: defun
#: original_texis/eval.texi:746
msgid ""
"This is the basic function for evaluating an expression.  It evaluates "
"@var{form} in the current environment, and returns the result.  The type of "
"the @var{form} object determines how it is evaluated.  @xref{Forms}."
msgstr ""

#. type: defun
#: original_texis/eval.texi:755
msgid ""
"The argument @var{lexical} specifies the scoping rule for local variables "
"(@pxref{Variable Scoping}).  If it is omitted or @code{nil}, that means to "
"evaluate @var{form} using the default dynamic scoping rule.  If it is "
"@code{t}, that means to use the lexical scoping rule.  The value of "
"@var{lexical} can also be a non-empty alist specifying a particular "
"@dfn{lexical environment} for lexical bindings; however, this feature is "
"only useful for specialized purposes, such as in Emacs Lisp debuggers.  "
"@xref{Lexical Binding}."
msgstr ""

#. type: defun
#: original_texis/eval.texi:760
msgid ""
"Since @code{eval} is a function, the argument expression that appears in a "
"call to @code{eval} is evaluated twice: once as preparation before "
"@code{eval} is called, and again by the @code{eval} function itself.  Here "
"is an example:"
msgstr ""

#. type: group
#: original_texis/eval.texi:765
#, no-wrap
msgid ""
"(setq foo 'bar)\n"
"     @result{} bar\n"
msgstr ""

#. type: group
#: original_texis/eval.texi:775
#, no-wrap
msgid ""
"(setq bar 'baz)\n"
"     @result{} baz\n"
";; @r{Here @code{eval} receives argument @code{foo}}\n"
"(eval 'foo)\n"
"     @result{} bar\n"
";; @r{Here @code{eval} receives argument @code{bar}, which is the value of "
"@code{foo}}\n"
"(eval foo)\n"
"     @result{} baz\n"
msgstr ""

#. type: defun
#: original_texis/eval.texi:780
msgid ""
"The number of currently active calls to @code{eval} is limited to "
"@code{max-lisp-eval-depth} (see below)."
msgstr ""

#. type: deffn
#: original_texis/eval.texi:782
#, no-wrap
msgid "Command eval-region start end &optional stream read-function"
msgstr ""

#. type: anchor{#1}
#: original_texis/eval.texi:788
msgid "Definition of eval-region"
msgstr ""

#. type: deffn
#: original_texis/eval.texi:788
msgid ""
"This function evaluates the forms in the current buffer in the region "
"defined by the positions @var{start} and @var{end}.  It reads forms from the "
"region and calls @code{eval} on them until the end of the region is reached, "
"or until an error is signaled and not handled."
msgstr ""

#. type: deffn
#: original_texis/eval.texi:794
msgid ""
"By default, @code{eval-region} does not produce any output.  However, if "
"@var{stream} is non-@code{nil}, any output produced by output functions "
"(@pxref{Output Functions}), as well as the values that result from "
"evaluating the expressions in the region are printed using @var{stream}.  "
"@xref{Output Streams}."
msgstr ""

#. type: deffn
#: original_texis/eval.texi:802
msgid ""
"If @var{read-function} is non-@code{nil}, it should be a function, which is "
"used instead of @code{read} to read expressions one by one.  This function "
"is called with one argument, the stream for reading input.  You can also use "
"the variable @code{load-read-function} (@pxref{Definition of "
"load-read-function,, How Programs Do Loading})  to specify this function, "
"but it is more robust to use the @var{read-function} argument."
msgstr ""

#. type: deffn
#: original_texis/eval.texi:804
msgid "@code{eval-region} does not move point.  It always returns @code{nil}."
msgstr ""

#. type: cindex
#: original_texis/eval.texi:806
#, no-wrap
msgid "evaluation of buffer contents"
msgstr ""

#. type: deffn
#: original_texis/eval.texi:807
#, no-wrap
msgid "Command eval-buffer &optional buffer-or-name stream filename unibyte print"
msgstr ""

#. type: deffn
#: original_texis/eval.texi:822
msgid ""
"This is similar to @code{eval-region}, but the arguments provide different "
"optional features.  @code{eval-buffer} operates on the entire accessible "
"portion of buffer @var{buffer-or-name} (@pxref{Narrowing,,, emacs, The GNU "
"Emacs Manual}).  @var{buffer-or-name} can be a buffer, a buffer name (a "
"string), or @code{nil} (or omitted), which means to use the current buffer.  "
"@var{stream} is used as in @code{eval-region}, unless @var{stream} is "
"@code{nil} and @var{print} non-@code{nil}.  In that case, values that result "
"from evaluating the expressions are still discarded, but the output of the "
"output functions is printed in the echo area.  @var{filename} is the file "
"name to use for @code{load-history} (@pxref{Unloading}), and defaults to "
"@code{buffer-file-name} (@pxref{Buffer File Name}).  If @var{unibyte} is "
"non-@code{nil}, @code{read} converts strings to unibyte whenever possible."
msgstr ""

#. type: defopt
#: original_texis/eval.texi:824
#, no-wrap
msgid "max-lisp-eval-depth"
msgstr ""

#. type: anchor{#1}
#: original_texis/eval.texi:829
msgid "Definition of max-lisp-eval-depth"
msgstr ""

#. type: defopt
#: original_texis/eval.texi:829
msgid ""
"This variable defines the maximum depth allowed in calls to @code{eval}, "
"@code{apply}, and @code{funcall} before an error is signaled (with error "
"message @code{\"Lisp nesting exceeds max-lisp-eval-depth\"})."
msgstr ""

#. type: defopt
#: original_texis/eval.texi:838
msgid ""
"This limit, with the associated error when it is exceeded, is how Emacs Lisp "
"avoids infinite recursion on an ill-defined function.  If you increase the "
"value of @code{max-lisp-eval-depth} too much, such code can cause stack "
"overflow instead.  On some systems, this overflow can be handled.  In that "
"case, normal Lisp evaluation is interrupted and control is transferred back "
"to the top level command loop (@code{top-level}).  Note that there is no way "
"to enter Emacs Lisp debugger in this situation.  @xref{Error Debugging}."
msgstr ""

#. type: cindex
#: original_texis/eval.texi:839
#, no-wrap
msgid "Lisp nesting error"
msgstr ""

#. type: defopt
#: original_texis/eval.texi:845
msgid ""
"The depth limit counts internal uses of @code{eval}, @code{apply}, and "
"@code{funcall}, such as for calling the functions mentioned in Lisp "
"expressions, and recursive evaluation of function call arguments and "
"function body forms, as well as explicit calls in Lisp code."
msgstr ""

#. type: defopt
#: original_texis/eval.texi:851
msgid ""
"The default value of this variable is 1600.  If you set it to a value less "
"than 100, Lisp will reset it to 100 if the given value is reached.  Entry to "
"the Lisp debugger increases the value, if there is little room left, to make "
"sure the debugger itself has room to execute."
msgstr ""

#. type: defvar
#: original_texis/eval.texi:853
#, no-wrap
msgid "values"
msgstr ""

#. type: defvar
#: original_texis/eval.texi:860
msgid ""
"The value of this variable is a list of the values returned by all the "
"expressions that were read, evaluated, and printed from buffers (including "
"the minibuffer) by the standard Emacs commands which do this.  (Note that "
"this does @emph{not} include evaluation in @file{*ielm*} buffers, nor "
"evaluation using @kbd{C-j}, @kbd{C-x C-e}, and similar evaluation commands "
"in @code{lisp-interaction-mode}.)"
msgstr ""

#. type: defvar
#: original_texis/eval.texi:864
msgid ""
"This variable is obsolete, and will be removed in a future version, since it "
"constantly enlarges the memory footprint of the Emacs process.  For that "
"reason, we recommend against using it."
msgstr ""

#. type: defvar
#: original_texis/eval.texi:866
msgid "The elements of @code{values} are ordered most recent first."
msgstr ""

#. type: group
#: original_texis/eval.texi:871
#, no-wrap
msgid ""
"(setq x 1)\n"
"     @result{} 1\n"
msgstr ""

#. type: group
#: original_texis/eval.texi:875
#, no-wrap
msgid ""
"(list 'A (1+ 2) auto-save-default)\n"
"     @result{} (A 3 t)\n"
msgstr ""

#. type: group
#: original_texis/eval.texi:879
#, no-wrap
msgid ""
"values\n"
"     @result{} ((A 3 t) 1 @dots{})\n"
msgstr ""

#. type: defvar
#: original_texis/eval.texi:886
msgid ""
"This variable could be useful for referring back to values of forms recently "
"evaluated.  It is generally a bad idea to print the value of @code{values} "
"itself, since this may be very long.  Instead, examine particular elements, "
"like this:"
msgstr ""

#. type: group
#: original_texis/eval.texi:892
#, no-wrap
msgid ""
";; @r{Refer to the most recent evaluation result.}\n"
"(nth 0 values)\n"
"     @result{} (A 3 t)\n"
msgstr ""

#. type: group
#: original_texis/eval.texi:898
#, no-wrap
msgid ""
";; @r{That put a new element on,}\n"
";;   @r{so all elements move back one.}\n"
"(nth 1 values)\n"
"     @result{} (A 3 t)\n"
msgstr ""

#. type: group
#: original_texis/eval.texi:904
#, no-wrap
msgid ""
";; @r{This gets the element that was next-to-most-recent}\n"
";;   @r{before this example.}\n"
"(nth 3 values)\n"
"     @result{} 1\n"
msgstr ""

#. type: section
#: original_texis/eval.texi:909
#, no-wrap
msgid "Deferred and Lazy Evaluation"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:911
#, no-wrap
msgid "deferred evaluation"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:912
#, no-wrap
msgid "lazy evaluation"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:920
msgid ""
"Sometimes it is useful to delay the evaluation of an expression, for example "
"if you want to avoid performing a time-consuming calculation if it turns out "
"that the result is not needed in the future of the program.  The "
"@file{thunk} library provides the following functions and macros to support "
"such @dfn{deferred evaluation}:"
msgstr ""

#. type: cindex
#: original_texis/eval.texi:921
#, no-wrap
msgid "thunk"
msgstr ""

#. type: defmac
#: original_texis/eval.texi:922
#, no-wrap
msgid "thunk-delay forms@dots{}"
msgstr ""

#. type: defmac
#: original_texis/eval.texi:927
msgid ""
"Return a @dfn{thunk} for evaluating the @var{forms}.  A thunk is a closure "
"(@pxref{Closures}) that inherits the lexical environment of the "
"@code{thunk-delay} call.  Using this macro requires @code{lexical-binding}."
msgstr ""

#. type: defun
#: original_texis/eval.texi:929
#, no-wrap
msgid "thunk-force thunk"
msgstr ""

#. type: defun
#: original_texis/eval.texi:936
msgid ""
"Force @var{thunk} to perform the evaluation of the forms specified in the "
"@code{thunk-delay} that created the thunk.  The result of the evaluation of "
"the last form is returned.  The @var{thunk} also ``remembers'' that it has "
"been forced: Any further calls of @code{thunk-force} with the same "
"@var{thunk} will just return the same result without evaluating the forms "
"again."
msgstr ""

#. type: defmac
#: original_texis/eval.texi:938
#, no-wrap
msgid "thunk-let (bindings@dots{}) forms@dots{}"
msgstr ""

#. type: defmac
#: original_texis/eval.texi:946
msgid ""
"This macro is analogous to @code{let} but creates ``lazy'' variable "
"bindings.  Any binding has the form @w{@code{(@var{symbol} "
"@var{value-form})}}.  Unlike @code{let}, the evaluation of any "
"@var{value-form} is deferred until the binding of the according @var{symbol} "
"is used for the first time when evaluating the @var{forms}.  Any "
"@var{value-form} is evaluated at most once.  Using this macro requires "
"@code{lexical-binding}."
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:949
msgid "Example:"
msgstr ""

#. type: group
#: original_texis/eval.texi:959
#, no-wrap
msgid ""
"(defun f (number)\n"
"  (thunk-let ((derived-number\n"
"              (progn (message \"Calculating 1 plus 2 times %d\" number)\n"
"                     (1+ (* 2 number)))))\n"
"    (if (> number 10)\n"
"        derived-number\n"
"      number)))\n"
msgstr ""

#. type: group
#: original_texis/eval.texi:964
#, no-wrap
msgid ""
"(f 5)\n"
"@result{} 5\n"
msgstr ""

#. type: group
#: original_texis/eval.texi:970
#, no-wrap
msgid ""
"(f 12)\n"
"@print{} Calculating 1 plus 2 times 12\n"
"@result{} 25\n"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:976
msgid ""
"Because of the special nature of lazily bound variables, it is an error to "
"set them (e.g.@: with @code{setq})."
msgstr ""

#. type: defmac
#: original_texis/eval.texi:978
#, no-wrap
msgid "thunk-let* (bindings@dots{}) forms@dots{}"
msgstr ""

#. type: defmac
#: original_texis/eval.texi:982
msgid ""
"This is like @code{thunk-let} but any expression in @var{bindings} is "
"allowed to refer to preceding bindings in this @code{thunk-let*} form.  "
"Using this macro requires @code{lexical-binding}."
msgstr ""

#. type: group
#: original_texis/eval.texi:999
#, no-wrap
msgid ""
"(thunk-let* ((x (prog2 (message \"Calculating x...\")\n"
"                    (+ 1 1)\n"
"                  (message \"Finished calculating x\")))\n"
"             (y (prog2 (message \"Calculating y...\")\n"
"                    (+ x 1)\n"
"                  (message \"Finished calculating y\")))\n"
"             (z (prog2 (message \"Calculating z...\")\n"
"                    (+ y 1)\n"
"                  (message \"Finished calculating z\")))\n"
"             (a (prog2 (message \"Calculating a...\")\n"
"                    (+ z 1)\n"
"                  (message \"Finished calculating a\"))))\n"
"  (* z x))\n"
"\n"
msgstr ""

#. type: group
#: original_texis/eval.texi:1007
#, no-wrap
msgid ""
"@print{} Calculating z...\n"
"@print{} Calculating y...\n"
"@print{} Calculating x...\n"
"@print{} Finished calculating x\n"
"@print{} Finished calculating y\n"
"@print{} Finished calculating z\n"
"@result{} 8\n"
"\n"
msgstr ""

#. type: Plain text
#: original_texis/eval.texi:1018
msgid ""
"@code{thunk-let} and @code{thunk-let*} use thunks implicitly: their "
"expansion creates helper symbols and binds them to thunks wrapping the "
"binding expressions.  All references to the original variables in the body "
"@var{forms} are then replaced by an expression that calls @code{thunk-force} "
"with the according helper variable as the argument.  So, any code using "
"@code{thunk-let} or @code{thunk-let*} could be rewritten to use thunks, but "
"in many cases using these macros results in nicer code than using thunks "
"explicitly."
msgstr ""
