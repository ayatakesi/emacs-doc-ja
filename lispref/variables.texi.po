# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2019-10-24 05:56+0900\n"
"PO-Revision-Date: 2019-10-23 00:37+0900\n"
"Last-Translator: Takeshi Ayanokoji <takeshi.ayanokoji@gmail.com>\n"
"Language-Team: Japanese <takeshi.ayanokoji@gmail.com>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: original_texis/variables.texi:5 original_texis/variables.texi:6
#, no-wrap
msgid "Variables"
msgstr "Variables"

#. type: cindex
#: original_texis/variables.texi:7
#, no-wrap
msgid "variable"
msgstr "variable"

#. type: Plain text
#: original_texis/variables.texi:18
msgid "A @dfn{variable} is a name used in a program to stand for a value.  In Lisp, each variable is represented by a Lisp symbol (@pxref{Symbols}).  The variable name is simply the symbol's name, and the variable's value is stored in the symbol's value cell@footnote{To be precise, under the default @dfn{dynamic scoping} rule, the value cell always holds the variable's current value, but this is not the case under the @dfn{lexical scoping} rule.  @xref{Variable Scoping}, for details.}.  @xref{Symbol Components}.  In Emacs Lisp, the use of a symbol as a variable is independent of its use as a function name."
msgstr "@dfn{変数(variable)}とはプログラム内で値を表すために使用される名前です。Lispでは変数はそれぞれLispシンボルとして表されます(@ref{Symbols}を参照)。変数名は単にそのシンボルの名前であり、変数の値はそのシンボルの値セル(value cell)に格納されます@footnote{正確に言うとデフォルトの@dfn{ダイナミックスコープ(dynamic scoping)}のルールでは、値セルは常にその変数のカレント値を保持しますが、@dfn{レキシカルスコープ(lexical scoping)}では異なります。詳細は@ref{Variable Scoping}を参照してください。}。@ref{Symbol Components}を参照してください。Emacs Lispではシンボルを変数として使用することは、同じシンボルを関数名として使用することと関係ありません。"

#. type: Plain text
#: original_texis/variables.texi:25
msgid "As previously noted in this manual, a Lisp program is represented primarily by Lisp objects, and only secondarily as text.  The textual form of a Lisp program is given by the read syntax of the Lisp objects that constitute the program.  Hence, the textual form of a variable in a Lisp program is written using the read syntax for the symbol representing the variable."
msgstr "このマニュアルで前述したとおり、Lispプログラムはまず第1にLispオブジェクトとして表され、副次的にテキストとして表現されます。Lispプログラムのテキスト的な形式は、そのプログラムを構成するLispオブジェクトの入力構文により与えられます。したがってLispプログラム内の変数のテキスト的な形式は、その変数を表すシンボルの入力構文を使用して記述されます。"

#. type: section
#: original_texis/variables.texi:45 original_texis/variables.texi:47
#: original_texis/variables.texi:48
#, no-wrap
msgid "Global Variables"
msgstr "Global Variables"

#. type: menuentry
#: original_texis/variables.texi:45
msgid "Variable values that exist permanently, everywhere."
msgstr "どの場所でも永続的に存在する変数の値。"

#. type: node
#: original_texis/variables.texi:45 original_texis/variables.texi:99
#, no-wrap
msgid "Constant Variables"
msgstr "Constant Variables"

#. type: menuentry
#: original_texis/variables.texi:45
msgid "Certain \"variables\" have values that never change."
msgstr "変更されることのない値を持つ、ある種の\"変数\"。"

#. type: section
#: original_texis/variables.texi:45 original_texis/variables.texi:140
#: original_texis/variables.texi:141
#, no-wrap
msgid "Local Variables"
msgstr "Local Variables"

#. type: menuentry
#: original_texis/variables.texi:45
msgid "Variable values that exist only temporarily."
msgstr "一時的にのみ存在する存在する変数の値。"

#. type: node
#: original_texis/variables.texi:45 original_texis/variables.texi:289
#, no-wrap
msgid "Void Variables"
msgstr "Void Variables"

#. type: menuentry
#: original_texis/variables.texi:45
msgid "Symbols that lack values."
msgstr "値を持たないシンボル。"

#. type: node
#: original_texis/variables.texi:45 original_texis/variables.texi:385
#, no-wrap
msgid "Defining Variables"
msgstr "Defining Variables"

#. type: menuentry
#: original_texis/variables.texi:45
msgid "A definition says a symbol is used as a variable."
msgstr "シンボルが変数として使用されていることを宣言する定義。"

#. type: node
#: original_texis/variables.texi:45 original_texis/variables.texi:520
#, no-wrap
msgid "Tips for Defining"
msgstr "Tips for Defining"

#. type: menuentry
#: original_texis/variables.texi:45
msgid "Things you should think about when you define a variable."
msgstr "変数を定義するときに考慮すべき事項。"

#. type: node
#: original_texis/variables.texi:45 original_texis/variables.texi:611
#, no-wrap
msgid "Accessing Variables"
msgstr "Accessing Variables"

#. type: menuentry
#: original_texis/variables.texi:45
msgid "Examining values of variables whose names are known only at run time."
msgstr "実行時に判明する名前をもつ変数の値を確認する。"

#. type: node
#: original_texis/variables.texi:45 original_texis/variables.texi:667
#, no-wrap
msgid "Setting Variables"
msgstr "Setting Variables"

#. type: menuentry
#: original_texis/variables.texi:45
msgid "Storing new values in variables."
msgstr "変数に新しい値を格納する。"

#. type: node
#: original_texis/variables.texi:45 original_texis/variables.texi:769
#, no-wrap
msgid "Variable Scoping"
msgstr "Variable Scoping"

#. type: menuentry
#: original_texis/variables.texi:45
msgid "How Lisp chooses among local and global values."
msgstr "Lispがローカル値とグローバル値を選択する方法。"

#. type: section
#: original_texis/variables.texi:45 original_texis/variables.texi:1108
#: original_texis/variables.texi:1109
#, no-wrap
msgid "Buffer-Local Variables"
msgstr "Buffer-Local Variables"

#. type: menuentry
#: original_texis/variables.texi:45
msgid "Variable values in effect only in one buffer."
msgstr "1つのバッファーないだけで効果をもつ変数の値。"

#. type: section
#: original_texis/variables.texi:45 original_texis/variables.texi:1570
#: original_texis/variables.texi:1571
#, no-wrap
msgid "File Local Variables"
msgstr "File Local Variables"

#. type: menuentry
#: original_texis/variables.texi:45
msgid "Handling local variable lists in files."
msgstr "ファイル内にリストされたローカル変数の処理。"

#. type: section
#: original_texis/variables.texi:45 original_texis/variables.texi:1754
#: original_texis/variables.texi:1755
#, no-wrap
msgid "Directory Local Variables"
msgstr "Directory Local Variables"

#. type: menuentry
#: original_texis/variables.texi:45
msgid "Local variables common to all files in a directory."
msgstr "ディレクトリー内のすべてのファイルで共通のローカル変数。"

#. type: section
#: original_texis/variables.texi:45 original_texis/variables.texi:1860
#: original_texis/variables.texi:1861
#, no-wrap
msgid "Variable Aliases"
msgstr "Variable Aliases"

#. type: menuentry
#: original_texis/variables.texi:45
msgid "Variables that are aliases for other variables."
msgstr "他の変数のエイリアスとなる変数。"

#. type: section
#: original_texis/variables.texi:45 original_texis/variables.texi:1953
#: original_texis/variables.texi:1954
#, no-wrap
msgid "Variables with Restricted Values"
msgstr "Variables with Restricted Values"

#. type: menuentry
#: original_texis/variables.texi:45
msgid "Non-constant variables whose value can @emph{not} be an arbitrary Lisp object."
msgstr "任意のLispオブジェクトを値とすることが@emph{できない}、定数ではない変数。"

#. type: section
#: original_texis/variables.texi:45 original_texis/variables.texi:1989
#: original_texis/variables.texi:1990
#, no-wrap
msgid "Generalized Variables"
msgstr "Generalized Variables"

#. type: menuentry
#: original_texis/variables.texi:45
msgid "Extending the concept of variables."
msgstr "変数の概念の拡張。"

#. type: cindex
#: original_texis/variables.texi:49
#, no-wrap
msgid "global variable"
msgstr "global variable"

#. type: Plain text
#: original_texis/variables.texi:56
msgid "The simplest way to use a variable is @dfn{globally}.  This means that the variable has just one value at a time, and this value is in effect (at least for the moment) throughout the Lisp system.  The value remains in effect until you specify a new one.  When a new value replaces the old one, no trace of the old value remains in the variable."
msgstr "変数を使用するための一番シンプルな方法は、@dfn{グローバル(globally)}を使用する方法です。これはある時点でその変数はただ1つの値をもち、その値が(少なくともその時点では)Lispシステム全体で効果をもつことを意味します。あらたな値を指定するまでその値が効果をもちます。新しい値で古い値を置き換えるとき、古い値を追跡する情報は変数内に残りません。"

#. type: Plain text
#: original_texis/variables.texi:58
msgid "You specify a value for a symbol with @code{setq}.  For example,"
msgstr "シンボルの値は@code{setq}で指定します。たとえば、"

#. type: example
#: original_texis/variables.texi:61
#, no-wrap
msgid "(setq x '(a b))\n"
msgstr "(setq x '(a b))\n"

#. type: Plain text
#: original_texis/variables.texi:68
msgid "gives the variable @code{x} the value @code{(a b)}.  Note that @code{setq} is a special form (@pxref{Special Forms}); it does not evaluate its first argument, the name of the variable, but it does evaluate the second argument, the new value."
msgstr "これは変数@code{x}に値@code{(a b)}を与えます。@code{setq}はスペシャルフォームであることに注意してください。これは1番目の引数(変数の名前)は評価しませんが、2番目の引数(新しい値)は評価します。"

#. type: Plain text
#: original_texis/variables.texi:71
msgid "Once the variable has a value, you can refer to it by using the symbol itself as an expression.  Thus,"
msgstr "変数が一度値をもつと、そのシンボル自身を式として使用することによって参照することができます。したがって、"

#. type: group
#: original_texis/variables.texi:75
#, no-wrap
msgid "x @result{} (a b)\n"
msgstr "x @result{} (a b)\n"

#. type: Plain text
#: original_texis/variables.texi:80
msgid "assuming the @code{setq} form shown above has already been executed."
msgstr "これは上記の@code{setq}フォームが実行された場合です。"

#. type: Plain text
#: original_texis/variables.texi:83
msgid "If you do set the same variable again, the new value replaces the old one:"
msgstr "同じ変数を再びセットすると、古い値は新しい値で置き換えられます:"

#. type: group
#: original_texis/variables.texi:88
#, no-wrap
msgid ""
"x\n"
"     @result{} (a b)\n"
msgstr ""
"x\n"
"     @result{} (a b)\n"

#. type: group
#: original_texis/variables.texi:92
#, no-wrap
msgid ""
"(setq x 4)\n"
"     @result{} 4\n"
msgstr ""
"(setq x 4)\n"
"     @result{} 4\n"

#. type: group
#: original_texis/variables.texi:96
#, no-wrap
msgid ""
"x\n"
"     @result{} 4\n"
msgstr ""
"x\n"
"     @result{} 4\n"

#. type: section
#: original_texis/variables.texi:100
#, no-wrap
msgid "Variables that Never Change"
msgstr "Variables that Never Change"

#. type: cindex
#: original_texis/variables.texi:101
#, no-wrap
msgid "@code{setting-constant} error"
msgstr "@code{setting-constant} error"

#. type: cindex
#: original_texis/variables.texi:102
#, no-wrap
msgid "keyword symbol"
msgstr "keyword symbol"

#. type: cindex
#: original_texis/variables.texi:103
#, no-wrap
msgid "variable with constant value"
msgstr "variable with constant value"

#. type: cindex
#: original_texis/variables.texi:104 original_texis/variables.texi:470
#, no-wrap
msgid "constant variables"
msgstr "constant variables"

#. type: cindex
#: original_texis/variables.texi:105
#, no-wrap
msgid "symbol that evaluates to itself"
msgstr "symbol that evaluates to itself"

#. type: cindex
#: original_texis/variables.texi:106
#, no-wrap
msgid "symbol with constant value"
msgstr "symbol with constant value"

#. type: Plain text
#: original_texis/variables.texi:116
msgid "In Emacs Lisp, certain symbols normally evaluate to themselves.  These include @code{nil} and @code{t}, as well as any symbol whose name starts with @samp{:} (these are called @dfn{keywords}).  These symbols cannot be rebound, nor can their values be changed.  Any attempt to set or bind @code{nil} or @code{t} signals a @code{setting-constant} error.  The same is true for a keyword (a symbol whose name starts with @samp{:}), if it is interned in the standard obarray, except that setting such a symbol to itself is not an error."
msgstr "Emacs Lispでは特定のシンボルは、通常は自分自身に評価されます。これらのシンボルには@code{nil}と@code{t}、同様に名前が@samp{:}で始まる任意のシンボル(これらは@dfn{キーワード}と呼ばれる)が含まれます。これらのシンボルはリバインドや、値の変更はできません。@code{nil}や@code{t}へのセットやリバインドは、@code{setting-constant}エラーをシグナルします。これはキーワード(名前が@samp{:}で始まるシンボル)についても当てはまります。ただしキーワードが標準のobarrayにinternされていれば、そのようなシンボルを自分自身にセットしてもエラーになりません。"

#. type: group
#: original_texis/variables.texi:121
#, no-wrap
msgid ""
"nil @equiv{} 'nil\n"
"     @result{} nil\n"
msgstr ""
"nil @equiv{} 'nil\n"
"     @result{} nil\n"

#. type: group
#: original_texis/variables.texi:125
#, no-wrap
msgid ""
"(setq nil 500)\n"
"@error{} Attempt to set constant symbol: nil\n"
msgstr ""
"(setq nil 500)\n"
"@error{} Attempt to set constant symbol: nil\n"

#. type: defun
#: original_texis/variables.texi:128
#, no-wrap
msgid "keywordp object"
msgstr "keywordp object"

#. type: defun
#: original_texis/variables.texi:132
msgid "function returns @code{t} if @var{object} is a symbol whose name starts with @samp{:}, interned in the standard obarray, and returns @code{nil} otherwise."
msgstr "この関数は@var{object}が@samp{:}で始まる名前のシンボルであり、標準のobarrayにinternされていれば@code{t}、それ以外は@code{nil}をリターンする。"

#. type: Plain text
#: original_texis/variables.texi:139
msgid "These constants are fundamentally different from the ``constants'' defined using the @code{defconst} special form (@pxref{Defining Variables}).  A @code{defconst} form serves to inform human readers that you do not intend to change the value of a variable, but Emacs does not raise an error if you actually change it."
msgstr "これらの定数はスペシャルフォーム@code{defconst}(@ref{Defining Variables}を参照してください)を使用して定義された``定数(constant)''とは、根本的に異なります。@code{defconst}フォームは、人間の読み手に値の変更を意図しない変数であることを知らせる役目は果たしますが、実際にそれを変更しても、Emacsはエラーを起こしません。"

#. type: cindex
#: original_texis/variables.texi:142
#, no-wrap
msgid "binding local variables"
msgstr "binding local variables"

#. type: cindex
#: original_texis/variables.texi:143
#, no-wrap
msgid "local variables"
msgstr "local variables"

#. type: cindex
#: original_texis/variables.texi:144
#, no-wrap
msgid "local binding"
msgstr "local binding"

#. type: cindex
#: original_texis/variables.texi:145
#, no-wrap
msgid "global binding"
msgstr "global binding"

#. type: Plain text
#: original_texis/variables.texi:153
msgid "Global variables have values that last until explicitly superseded with new values.  Sometimes it is useful to give a variable a @dfn{local value}---a value that takes effect only within a certain part of a Lisp program.  When a variable has a local value, we say that it is @dfn{locally bound} to that value, and that it is a @dfn{local variable}."
msgstr "グローバル変数は新しい値で明示的に置き換えるまで値が持続します。変数に@dfn{ローカル値(local value)} --- Lispプログラム内の特定の部分で効果をもつ --- を与えると便利なときがあります。変数がローカル値をもつとき、わたしたちは変数がその値に@dfn{ローカルにバインド(locally bound)}されていると言い、その変数を@dfn{ローカル変数(local variable)}と呼びます。"

#. type: Plain text
#: original_texis/variables.texi:160
msgid "For example, when a function is called, its argument variables receive local values, which are the actual arguments supplied to the function call; these local bindings take effect within the body of the function.  To take another example, the @code{let} special form explicitly establishes local bindings for specific variables, which take effect within the body of the @code{let} form."
msgstr "たとえば関数が呼び出されるとき、関数の引数となる変数はローカル値(その関数の呼び出しにおいて実際の引数に与えられた値)を受け取ります。これらのローカルバインディングは、その関数のbody内で効果をもちます。他にもたとえばスペシャルフォーム@code{let}は特定の変数にたいして明示的にローカルなバインディングを確立し、これは@code{let}フォームのbody内で効果を持ちます。"

#. type: Plain text
#: original_texis/variables.texi:163
msgid "We also speak of the @dfn{global binding}, which is where (conceptually) the global value is kept."
msgstr "これにたいして@dfn{グローバルなバインディング(global binding)}とは、(概念的には)グローバルな値が保持される場所です。"

#. type: cindex
#: original_texis/variables.texi:164
#, no-wrap
msgid "shadowing of variables"
msgstr "shadowing of variables"

#. type: Plain text
#: original_texis/variables.texi:172
msgid "Establishing a local binding saves away the variable's previous value (or lack of one).  We say that the previous value is @dfn{shadowed}.  Both global and local values may be shadowed.  If a local binding is in effect, using @code{setq} on the local variable stores the specified value in the local binding.  When that local binding is no longer in effect, the previously shadowed value (or lack of one) comes back."
msgstr "ローカルバインディングを確立すると、その変数の以前の値は他の場所に保存されます(または失われる)。わたしたちはこれを、以前の値が@dfn{シャドー(shadowed)}されたと言います。シャドーはグローバル変数とローカル変数の両方で発生し得ます。ローカルバインディングが効果を持つときには、ローカル変数に@code{setq}を使用することにより、指定した値をローカルバインディングに格納します。ローカルバインディングが効果を持たなくなったとき、以前にシャドーされた値が復元されます(または失われる)。"

#. type: cindex
#: original_texis/variables.texi:173
#, no-wrap
msgid "current binding"
msgstr "current binding"

#. type: Plain text
#: original_texis/variables.texi:179
msgid "A variable can have more than one local binding at a time (e.g., if there are nested @code{let} forms that bind the variable).  The @dfn{current binding} is the local binding that is actually in effect.  It determines the value returned by evaluating the variable symbol, and it is the binding acted on by @code{setq}."
msgstr "変数は同時に複数のローカルバインディングを持つことができます(たとえばその変数をバインドするネストされた@code{let})。@dfn{カレントバインディング(current binding)}とは、実際に効果を持つローカルバインディングのことです。カレントバインディングは、その変数の評価によりリターンされる値を決定し、@code{setq}により影響を受けるバインディングです。"

#. type: Plain text
#: original_texis/variables.texi:190
msgid "For most purposes, you can think of the current binding as the ``innermost'' local binding, or the global binding if there is no local binding.  To be more precise, a rule called the @dfn{scoping rule} determines where in a program a local binding takes effect.  The default scoping rule in Emacs Lisp is called @dfn{dynamic scoping}, which simply states that the current binding at any given point in the execution of a program is the most recently-created binding for that variable that still exists.  For details about dynamic scoping, and an alternative scoping rule called @dfn{lexical scoping}, @xref{Variable Scoping}."
msgstr "ほとんどの用途において、``最内(innermost)''のローカルバインディング、ローカルバインディングがないときはグローバルバインディングを、カレントバインディングと考えることができます。より正確に言うと、@dfn{スコープルール(scoping rule)}と呼ばれるルールは、プログラム内でローカルバインディングが効果を持つ任意の与えられた場所を決定します。Emacs Lispのスコープルールは@dfn{ダイナミックスコープ(dynamic scoping)}と呼ばれ、これは単に実行中のプログラム内の与えられた位置でのカレントバインディングを示し、その変数がまだ存在する場合は、その変数にたいしてもっとも最近作成されたバインディングです。ダイナミックスコープについての詳細と、その代替である@dfn{レキシカルスコープ(lexical scoping)}と呼ばれるスコープルールについては、@ref{Variable Scoping}を参照してください。"

#. type: Plain text
#: original_texis/variables.texi:193
msgid "The special forms @code{let} and @code{let*} exist to create local bindings:"
msgstr "スペシャルフォーム@code{let}と@code{let*}は、ローカルバインディングを作成するために存在します:"

#. type: defspec
#: original_texis/variables.texi:194
#, no-wrap
msgid "let (bindings@dots{}) forms@dots{}"
msgstr "let (bindings@dots{}) forms@dots{}"

#. type: defspec
#: original_texis/variables.texi:199
msgid "This special form sets up local bindings for a certain set of variables, as specified by @var{bindings}, and then evaluates all of the @var{forms} in textual order.  Its return value is the value of the last form in @var{forms}."
msgstr "このスペシャルフォームは、@var{bindings}により指定される特定の変数セットにたいするローカルバインディングをセットアップしてから、@var{forms}のすべてをテキスト順に評価する。これは@var{forms}内の最後のフォームの値をリターンする。"

#. type: defspec
#: original_texis/variables.texi:205
msgid "Each of the @var{bindings} is either @w{(i) a} symbol, in which case that symbol is locally bound to @code{nil}; or @w{(ii) a} list of the form @code{(@var{symbol} @var{value-form})}, in which case @var{symbol} is locally bound to the result of evaluating @var{value-form}.  If @var{value-form} is omitted, @code{nil} is used."
msgstr "@var{bindings}の各バインディングは2つの形式のいずれかである。@w{(i)} シンボルなら、そのシンボルは@code{nil}にローカルにバインドされる。@w{(ii)} フォーム@code{(@var{symbol} @var{value-form})}のリストなら、@var{symbol}は@var{value-form}を評価した結果へローカルにバインドされる。@var{value-form}が省略されたら@code{nil}が使用される。"

#. type: defspec
#: original_texis/variables.texi:210
msgid "All of the @var{value-form}s in @var{bindings} are evaluated in the order they appear and @emph{before} binding any of the symbols to them.  Here is an example of this: @code{z} is bound to the old value of @code{y}, which is 2, not the new value of @code{y}, which is 1."
msgstr "@var{bindings}内のすべての@var{value-form}は、シンボルがそれらにバインドされる@emph{前}に、記述された順番に評価される。以下の例では@code{z}は@code{y}の新しい値(つまり1)にではなく、古い値(つまり2)にバインドされる。"

#. type: group
#: original_texis/variables.texi:215 original_texis/variables.texi:237
#, no-wrap
msgid ""
"(setq y 2)\n"
"     @result{} 2\n"
msgstr ""
"(setq y 2)\n"
"     @result{} 2\n"

#. type: group
#: original_texis/variables.texi:222
#, no-wrap
msgid ""
"(let ((y 1)\n"
"      (z y))\n"
"  (list y z))\n"
"     @result{} (1 2)\n"
msgstr ""
"(let ((y 1)\n"
"      (z y))\n"
"  (list y z))\n"
"     @result{} (1 2)\n"

#. type: defspec
#: original_texis/variables.texi:226
#, no-wrap
msgid "let* (bindings@dots{}) forms@dots{}"
msgstr "let* (bindings@dots{}) forms@dots{}"

#. type: defspec
#: original_texis/variables.texi:232
msgid "This special form is like @code{let}, but it binds each variable right after computing its local value, before computing the local value for the next variable.  Therefore, an expression in @var{bindings} can refer to the preceding symbols bound in this @code{let*} form.  Compare the following example with the example above for @code{let}."
msgstr "このスペシャルフォームは@code{let}と似ているが、次の変数値にたいするローカル値を計算する前に、ローカル値を計算してそれを変数にバインドする。したがて@var{bindings}内の式は、この@code{let*}フォーム内の前のシンボルのバインドを参照できる。以下の例を上記@code{let}の例と比較されたい。"

#. type: group
#: original_texis/variables.texi:244
#, no-wrap
msgid ""
"(let* ((y 1)\n"
"       (z y))    ; @r{Use the just-established value of @code{y}.}\n"
"  (list y z))\n"
"     @result{} (1 1)\n"
msgstr ""
"(let* ((y 1)\n"
"       (z y))    ; @r{@code{y}の値に今計算されたばかりの値を使用する}\n"
"  (list y z))\n"
"     @result{} (1 1)\n"

#. type: Plain text
#: original_texis/variables.texi:250
msgid "Here is a complete list of the other facilities that create local bindings:"
msgstr "以下はローカルバインディングを作成する他の機能のリストです:"

#. type: itemize
#: original_texis/variables.texi:254
msgid "Function calls (@pxref{Functions})."
msgstr "関数呼び出し(@ref{Functions}を参照)。"

#. type: itemize
#: original_texis/variables.texi:257
msgid "Macro calls (@pxref{Macros})."
msgstr "マクロ呼び出し(@ref{Macros}を参照)。"

#. type: itemize
#: original_texis/variables.texi:260
msgid "@code{condition-case} (@pxref{Errors})."
msgstr "@code{condition-case} (@ref{Errors}を参照)。"

#. type: Plain text
#: original_texis/variables.texi:267
msgid "Variables can also have buffer-local bindings (@pxref{Buffer-Local Variables}); a few variables have terminal-local bindings (@pxref{Multiple Terminals}).  These kinds of bindings work somewhat like ordinary local bindings, but they are localized depending on ``where'' you are in Emacs."
msgstr "変数はバッファーローカルなバインディングを持つこともできます(@ref{Buffer-Local Variables}を参照してください)。数は多くありませんが、端末ローカル(terminal-local)なバインディングをもつ変数もあります(@ref{Multiple Terminals}を参照してください)これらの種類のバインディングは、通常のローカルバインディングのように機能することもありますが、これらはEmacs内の``どこ''であるかに依存してローカライズされます。"

#. type: defopt
#: original_texis/variables.texi:268
#, no-wrap
msgid "max-specpdl-size"
msgstr "max-specpdl-size"

#. type: anchor{#1}
#: original_texis/variables.texi:270
msgid "Definition of max-specpdl-size"
msgstr "Definition of max-specpdl-size"

#. type: cindex
#: original_texis/variables.texi:270
#, no-wrap
msgid "variable limit error"
msgstr "variable limit error"

#. type: cindex
#: original_texis/variables.texi:271
#, no-wrap
msgid "evaluation error"
msgstr "evaluation error"

#. type: cindex
#: original_texis/variables.texi:272
#, no-wrap
msgid "infinite recursion"
msgstr "infinite recursion"

#. type: defopt
#: original_texis/variables.texi:278
msgid "This variable defines the limit on the total number of local variable bindings and @code{unwind-protect} cleanups (see @ref{Cleanups,, Cleaning Up from Nonlocal Exits}) that are allowed before Emacs signals an error (with data @code{\"Variable binding depth exceeds max-specpdl-size\"})."
msgstr "この変数はローカルな変数バインディングと、@code{unwind-protect}にゆるクリーンアップ(@ref{Cleanups,, Cleaning Up from Nonlocal Exits}を参照)の総数にたいする制限を定義し、この変数を越えるとEmacsは(データ@code{\"Variable binding depth exceeds max-specpdl-size\"}とともに)エラーをシグナルする。"

#. type: defopt
#: original_texis/variables.texi:283
msgid "This limit, with the associated error when it is exceeded, is one way that Lisp avoids infinite recursion on an ill-defined function.  @code{max-lisp-eval-depth} provides another limit on depth of nesting.  @xref{Definition of max-lisp-eval-depth,, Eval}."
msgstr "このリミットは、もし超過したときにエラーが関連付けられていれば、誤って定義された関数による無限再起を避けるための1つの手段になる。ネストの深さにたいする他の制限としては、@code{max-lisp-eval-depth}がある。@ref{Definition of max-lisp-eval-depth,, Eval}を参照のこと。"

#. type: defopt
#: original_texis/variables.texi:287
msgid "The default value is 1300.  Entry to the Lisp debugger increases the value, if there is little room left, to make sure the debugger itself has room to execute."
msgstr "デフォルト値は1300。Lispデバッガーのエントリーしたとき、もし残りが少なければ、デバッガーを実行するための空きを作るために値が増加される。"

#. type: section
#: original_texis/variables.texi:290
#, no-wrap
msgid "When a Variable is ``Void''"
msgstr "When a Variable is ``Void''"

#. type: cindex
#: original_texis/variables.texi:291
#, no-wrap
msgid "@code{void-variable} error"
msgstr "@code{void-variable} error"

#. type: cindex
#: original_texis/variables.texi:292
#, no-wrap
msgid "void variable"
msgstr "void variable"

#. type: Plain text
#: original_texis/variables.texi:296
msgid "We say that a variable is void if its symbol has an unassigned value cell (@pxref{Symbol Components})."
msgstr "シンボルの値セル(@ref{Symbol Components}を参照)に値が割り当てられていない場合、その変数はvoid(空)であると言います。"

#. type: Plain text
#: original_texis/variables.texi:305
msgid "Under Emacs Lisp's default dynamic scoping rule (@pxref{Variable Scoping}), the value cell stores the variable's current (local or global) value.  Note that an unassigned value cell is @emph{not} the same as having @code{nil} in the value cell.  The symbol @code{nil} is a Lisp object and can be the value of a variable, just as any other object can be; but it is still a value.  If a variable is void, trying to evaluate the variable signals a @code{void-variable} error, instead of returning a value."
msgstr "Emacs Lispのデフォルトであるダイナミックスコープルール(@ref{Variable Scoping}を参照)の下では、値セルはその変数のカレント値(ローカルまたはグローバル)を保持します。値が割り当てられていない値セルは、値セルに@code{nil}をもつのとは@emph{異なる}ことに注意してください。シンボル@code{nil}はLispオブジェクトであり、他のオブジェクトと同様に変数の値となることができます。@code{nil}は値なのです。変数がvoidの場合にその変数の評価を試みると、値をリターンするかわりに、@code{void-variable}エラーがシグナルされます。"

#. type: Plain text
#: original_texis/variables.texi:311
msgid "Under the optional lexical scoping rule, the value cell only holds the variable's global value---the value outside of any lexical binding construct.  When a variable is lexically bound, the local value is determined by the lexical environment; hence, variables can have local values even if their symbols' value cells are unassigned."
msgstr "オプションであるレキシカルスコープルール(lexical scoping rule)の下では、値セル保持できるのはその変数のグローバル値 --- 任意のレキシカルバインディング構造の外側の値だけです。変数がレキシカルにバインドされている場合、ローカル値はそのレキシカル環境により決定されます。したがってこれらのシンボルの値セルに値が割り当てられていなくても、変数はローカル値を持つことができます。"

#. type: defun
#: original_texis/variables.texi:312
#, no-wrap
msgid "makunbound symbol"
msgstr "makunbound symbol"

#. type: defun
#: original_texis/variables.texi:315
msgid "This function empties out the value cell of @var{symbol}, making the variable void.  It returns @var{symbol}."
msgstr "この関数は@var{symbol}の値セルを空にして、その変数をvoidにする。この関数は@var{symbol}をリターンする。"

#. type: defun
#: original_texis/variables.texi:321
msgid "If @var{symbol} has a dynamic local binding, @code{makunbound} voids the current binding, and this voidness lasts only as long as the local binding is in effect.  Afterwards, the previously shadowed local or global binding is reexposed; then the variable will no longer be void, unless the reexposed binding is void too."
msgstr "@var{symbol}がダイナミックなローカルバインディングをもつなら、@code{makunbound}はカレントのバインディングをvoidにして、そのローカルバインディングが効果を持つ限りvoidにする。その後で以前にシャドーされたローカル値(またはグローバル値)が再び有効になって、再び有効になった値がvoidでなければ、その変数はvoidではなくなる。"

#. type: defun
#: original_texis/variables.texi:323 original_texis/variables.texi:359
msgid "Here are some examples (assuming dynamic binding is in effect):"
msgstr "いくつか例を示す(ダイナミックバインディングが有効だとする):"

#. type: group
#: original_texis/variables.texi:332
#, no-wrap
msgid ""
"(setq x 1)               ; @r{Put a value in the global binding.}\n"
"     @result{} 1\n"
"(let ((x 2))             ; @r{Locally bind it.}\n"
"  (makunbound 'x)        ; @r{Void the local binding.}\n"
"  x)\n"
"@error{} Symbol's value as variable is void: x\n"
msgstr ""
"(setq x 1)               ; @r{グローバルバインディングに値をセットする}\n"
"     @result{} 1\n"
"(let ((x 2))             ; @r{それをローカルにバインドする}\n"
"  (makunbound 'x)        ; @r{ローカルバインディングをvoidにする}\n"
"  x)\n"
"@error{} Symbol's value as variable is void: x\n"

#. type: group
#: original_texis/variables.texi:336
#, no-wrap
msgid ""
"x                        ; @r{The global binding is unchanged.}\n"
"     @result{} 1\n"
"\n"
msgstr ""
"x                        ; @r{グローバルバインディングは変更されない}\n"
"     @result{} 1\n"
"\n"

#. type: group
#: original_texis/variables.texi:342
#, no-wrap
msgid ""
"(let ((x 2))             ; @r{Locally bind it.}\n"
"  (let ((x 3))           ; @r{And again.}\n"
"    (makunbound 'x)      ; @r{Void the innermost-local binding.}\n"
"    x))                  ; @r{And refer: it's void.}\n"
"@error{} Symbol's value as variable is void: x\n"
msgstr ""
"(let ((x 2))             ; @r{ローカルにバインドする}\n"
"  (let ((x 3))           ; @r{もう一度}\n"
"    (makunbound 'x)      ; @r{最内のローカルバインディングをvoidにする}\n"
"    x))                  ; @r{それを参照すると、void}\n"
"@error{} Symbol's value as variable is void: x\n"

#. type: group
#: original_texis/variables.texi:350
#, no-wrap
msgid ""
"(let ((x 2))\n"
"  (let ((x 3))\n"
"    (makunbound 'x))     ; @r{Void inner binding, then remove it.}\n"
"  x)                     ; @r{Now outer @code{let} binding is visible.}\n"
"     @result{} 2\n"
msgstr ""
"(let ((x 2))\n"
"  (let ((x 3))\n"
"    (makunbound 'x))     ; @r{内側のバインディングをvoidにしてから取り除く}\n"
"  x)                     ; @r{外側の@code{let}バインディングが有効になる}\n"
"     @result{} 2\n"

#. type: defun
#: original_texis/variables.texi:354
#, no-wrap
msgid "boundp variable"
msgstr "boundp variable"

#. type: defun
#: original_texis/variables.texi:357
msgid "This function returns @code{t} if @var{variable} (a symbol) is not void, and @code{nil} if it is void."
msgstr "この関数は@var{variable}(シンボル)がvoidでなければ@code{t}、voidなら@code{nil}をリターンする。"

#. type: group
#: original_texis/variables.texi:364
#, no-wrap
msgid ""
"(boundp 'abracadabra)          ; @r{Starts out void.}\n"
"     @result{} nil\n"
msgstr ""
"(boundp 'abracadabra)          ; @r{最初はvoid}\n"
"     @result{} nil\n"

#. type: group
#: original_texis/variables.texi:369
#, no-wrap
msgid ""
"(let ((abracadabra 5))         ; @r{Locally bind it.}\n"
"  (boundp 'abracadabra))\n"
"     @result{} t\n"
msgstr ""
"(let ((abracadabra 5))         ; @r{ローカルにバインドする}\n"
"  (boundp 'abracadabra))\n"
"     @result{} t\n"

#. type: group
#: original_texis/variables.texi:373
#, no-wrap
msgid ""
"(boundp 'abracadabra)          ; @r{Still globally void.}\n"
"     @result{} nil\n"
msgstr ""
"(boundp 'abracadabra)          ; @r{グローバルではまだvoid}\n"
"     @result{} nil\n"

#. type: group
#: original_texis/variables.texi:377
#, no-wrap
msgid ""
"(setq abracadabra 5)           ; @r{Make it globally nonvoid.}\n"
"     @result{} 5\n"
msgstr ""
"(setq abracadabra 5)           ; @r{グローバルで非voidにする}\n"
"     @result{} 5\n"

#. type: group
#: original_texis/variables.texi:381
#, no-wrap
msgid ""
"(boundp 'abracadabra)\n"
"     @result{} t\n"
msgstr ""
"(boundp 'abracadabra)\n"
"     @result{} t\n"

#. type: section
#: original_texis/variables.texi:386
#, no-wrap
msgid "Defining Global Variables"
msgstr "Defining Global Variables"

#. type: cindex
#: original_texis/variables.texi:387
#, no-wrap
msgid "variable definition"
msgstr "variable definition"

#. type: Plain text
#: original_texis/variables.texi:392
msgid "A @dfn{variable definition} is a construct that announces your intention to use a symbol as a global variable.  It uses the special forms @code{defvar} or @code{defconst}, which are documented below."
msgstr "@dfn{変数定義(variable definition)}とは、そのシンボルをグローバル変数として使用する意図を表明する構文です。これには以下で説明するスペシャルフォーム@code{defvar}や@code{defconst}が使用されます。"

#. type: Plain text
#: original_texis/variables.texi:399
msgid "A variable definition serves three purposes.  First, it informs people who read the code that the symbol is @emph{intended} to be used a certain way (as a variable).  Second, it informs the Lisp system of this, optionally supplying an initial value and a documentation string.  Third, it provides information to programming tools such as @command{etags}, allowing them to find where the variable was defined."
msgstr "変数宣言は3つの目的をもちます。1番目はコードを読む人にたいして、そのシンボルが特定の方法(変数として)使用されることを@emph{意図}したものだと知らせることです。2番目はLispシステムにたいしてオプションで初期値とドキュメント文字列を与えて、これを知らせることです。3番目は@command{etags}のようなプログラミングツールにたいして、その変数が定義されている場所を見つけられるように情報を提供することです。"

#. type: Plain text
#: original_texis/variables.texi:407
msgid "The difference between @code{defconst} and @code{defvar} is mainly a matter of intent, serving to inform human readers of whether the value should ever change.  Emacs Lisp does not actually prevent you from changing the value of a variable defined with @code{defconst}.  One notable difference between the two forms is that @code{defconst} unconditionally initializes the variable, whereas @code{defvar} initializes it only if it is originally void."
msgstr "@code{defconst}と@code{defvar}の主な違いは、人間の読み手に値が変更されるかどうかを知らせることにあります。Emacs Lispは実際に、@code{defconst}で定義された変数の値の変更を妨げません。この2つのフォームの特筆すべき違いは、@code{defconst}は無条件で変数を初期化して、@code{defvar}は変数が元々voidのときだけ初期化することです。"

#. type: Plain text
#: original_texis/variables.texi:411
msgid "To define a customizable variable, you should use @code{defcustom} (which calls @code{defvar} as a subroutine).  @xref{Variable Definitions}."
msgstr "カスタマイズ可能な変数を定義する場合は、@code{defcustom}を使用するべきです(これはサブルーチンとして@code{defvar}を呼び出す)。@ref{Variable Definitions}を参照してください。"

#. type: defspec
#: original_texis/variables.texi:412
#, no-wrap
msgid "defvar symbol [value [doc-string]]"
msgstr "defvar symbol [value [doc-string]]"

#. type: defspec
#: original_texis/variables.texi:418
msgid "This special form defines @var{symbol} as a variable.  Note that @var{symbol} is not evaluated; the symbol to be defined should appear explicitly in the @code{defvar} form.  The variable is marked as @dfn{special}, meaning that it should always be dynamically bound (@pxref{Variable Scoping})."
msgstr "このスペシャルフォームは変数として@var{symbol}を定義する。@var{symbol}が評価されないことに注意。シンボルは@code{defvar}フォーム内に明示的に表記して定義される必要がある。この変数は@dfn{特別}だとマークされて、これは常に変数がダイナミックにバインドされることを意味する(@ref{Variable Scoping}を参照)。"

#. type: defspec
#: original_texis/variables.texi:425
msgid "If @var{value} is specified, and @var{symbol} is void (i.e., it has no dynamically bound value; @pxref{Void Variables}), then @var{value} is evaluated and @var{symbol} is set to the result.  But if @var{symbol} is not void, @var{value} is not evaluated, and @var{symbol}'s value is left unchanged.  If @var{value} is omitted, the value of @var{symbol} is not changed in any case."
msgstr "@var{value}が指定されていて@var{symbol}がvoid(たとえばこのシンボルがダイナミックにバインドされた値を持たないとき。@ref{Void Variables}を参照)なら@var{value}が評価されて、その結果が@var{symbol}にセットされる。しかし@var{symbol}がvoidでなければ、@var{value}は評価されず@var{symbol}の値は変更されない。@var{value}が省略された場合は、いかなる場合も@var{symbol}の値は変更されない。"

#. type: defspec
#: original_texis/variables.texi:430
msgid "If @var{symbol} has a buffer-local binding in the current buffer, @code{defvar} acts on the default value, which is buffer-independent, rather than the buffer-local binding.  It sets the default value if the default value is void.  @xref{Buffer-Local Variables}."
msgstr "@var{symbol}がカレントバッファー内でバッファーローカルなバインディングをもつ場合、@code{defvar}はデフォルト値に作用する。デフォルト値はバッファーローカルなバインディングではなく、バッファーにたいして独立である。デフォルト値がvoidのときはデフォルト値をセットする。@ref{Buffer-Local Variables}を参照のこと。"

#. type: defspec
#: original_texis/variables.texi:435
msgid "If @var{symbol} is already lexically bound (e.g., if the @code{defvar} form occurs in a @code{let} form with lexical binding enabled), then @code{defvar} sets the dynamic value.  The lexical binding remains in effect until its binding construct exits.  @xref{Variable Scoping}."
msgstr "すでに@var{symbol}がレキシカルにバインドされている場合(たとえばレキシカルバインドが有効な状態で@code{let}フォーム内に@code{defvar}があるような場合)、@code{defvar}はダイナミックな値をセットする。バインディング構文を抜けるまで、レキシカルバインディングは効果をもつ。@ref{Variable Scoping}を参照のこと。"

#. type: defspec
#: original_texis/variables.texi:440
msgid "When you evaluate a top-level @code{defvar} form with @kbd{C-M-x} in Emacs Lisp mode (@code{eval-defun}), a special feature of @code{eval-defun} arranges to set the variable unconditionally, without testing whether its value is void."
msgstr "Emacs Lispモードで@kbd{C-M-x} (@code{eval-defun})でトップレベルの@code{defvar}を評価するとき、@code{eval-defun}の特別な機能はその値がvoidであるかテストすることなく、その変数を無条件にセットする。"

#. type: defspec
#: original_texis/variables.texi:444
msgid "If the @var{doc-string} argument is supplied, it specifies the documentation string for the variable (stored in the symbol's @code{variable-documentation} property).  @xref{Documentation}."
msgstr "引数@var{doc-string}が与えられたら、それは変数にたいするドキュメント文字列を指定する(そのシンボルの@code{variable-documentation}プロパティーに格納される)。@ref{Documentation}を参照のこと。"

#. type: defspec
#: original_texis/variables.texi:447
msgid "Here are some examples.  This form defines @code{foo} but does not initialize it:"
msgstr "以下にいくつか例を示す。これは@code{foo}を定義するが初期化は行わない:"

#. type: group
#: original_texis/variables.texi:452
#, no-wrap
msgid ""
"(defvar foo)\n"
"     @result{} foo\n"
msgstr ""
"(defvar foo)\n"
"     @result{} foo\n"

#. type: defspec
#: original_texis/variables.texi:457
msgid "This example initializes the value of @code{bar} to @code{23}, and gives it a documentation string:"
msgstr "以下の例は@code{bar}の値を@code{23}に初期化してドキュメント文字列を与える:"

#. type: group
#: original_texis/variables.texi:463
#, no-wrap
msgid ""
"(defvar bar 23\n"
"  \"The normal weight of a bar.\")\n"
"     @result{} bar\n"
msgstr ""
"(defvar bar 23\n"
"  \"The normal weight of a bar.\")\n"
"     @result{} bar\n"

#. type: defspec
#: original_texis/variables.texi:468
msgid "The @code{defvar} form returns @var{symbol}, but it is normally used at top level in a file where its value does not matter."
msgstr "@code{defvar}フォームは@var{symbol}をリターンするが、これは通常は値が問題にならないファイル内のトップレベルで使用される。"

#. type: defspec
#: original_texis/variables.texi:471
#, no-wrap
msgid "defconst symbol value [doc-string]"
msgstr "defconst symbol value [doc-string]"

#. type: defspec
#: original_texis/variables.texi:477
msgid "This special form defines @var{symbol} as a value and initializes it.  It informs a person reading your code that @var{symbol} has a standard global value, established here, that should not be changed by the user or by other programs.  Note that @var{symbol} is not evaluated; the symbol to be defined must appear explicitly in the @code{defconst}."
msgstr "このスペシャルフォームはある値で@var{symbol}を定義して、それを初期化する。これはコードを読む人に、@var{symbol}がここで設定される標準的なグローバル値をもち、ユーザーや他のプログラムがそれを変更すべきではないことを知らせる。@var{symbol}が評価されないことに注意。定義されるシンボルは@code{defconst}内に明示的に記されなければならない。"

#. type: defspec
#: original_texis/variables.texi:482
msgid "The @code{defconst} form, like @code{defvar}, marks the variable as @dfn{special}, meaning that it should always be dynamically bound (@pxref{Variable Scoping}).  In addition, it marks the variable as risky (@pxref{File Local Variables})."
msgstr "@code{defvar}と同様、@code{defconst}は変数を@dfn{特別} --- この変数が常にダイナミックにバインドされているという意味 --- であるとマークする(@ref{Variable Scoping}を参照)。加えてこれはその変数を危険であるとマークする(@ref{File Local Variables}を参照)。"

#. type: defspec
#: original_texis/variables.texi:489
msgid "@code{defconst} always evaluates @var{value}, and sets the value of @var{symbol} to the result.  If @var{symbol} does have a buffer-local binding in the current buffer, @code{defconst} sets the default value, not the buffer-local value.  (But you should not be making buffer-local bindings for a symbol that is defined with @code{defconst}.)"
msgstr "@code{defconst}は常に@var{value}を評価して、その結果を@var{symbol}の値にセットする。カレントバッファー内で@var{symbol}がバッファーローカルなバインディングをもつなら、@code{defconst}はデフォルト値ではなくバッファーローカルな値をセットする(しかし@code{defconst}で定義されたシンボルにたいしてバッファーローカルなバインディングを作らないこと)。"

#. type: defspec
#: original_texis/variables.texi:495
msgid "An example of the use of @code{defconst} is Emacs's definition of @code{float-pi}---the mathematical constant @math{pi}, which ought not to be changed by anyone (attempts by the Indiana State Legislature notwithstanding).  As the second form illustrates, however, @code{defconst} is only advisory."
msgstr "@code{defconst}の使い方の例は、Emacsの@code{float-pi} --- (たとえインディアナ州議会が何を試みようと)何者かにより変更されるべきではない数学定数@math{pi}にたいする定義である。しかし2番目の@code{defconst}の例のように、これは単にアドバイス的なものである。"

#. type: group
#: original_texis/variables.texi:500
#, no-wrap
msgid ""
"(defconst float-pi 3.141592653589793 \"The value of Pi.\")\n"
"     @result{} float-pi\n"
msgstr ""
"(defconst float-pi 3.141592653589793 \"The value of Pi.\")\n"
"     @result{} float-pi\n"

#. type: group
#: original_texis/variables.texi:504
#, no-wrap
msgid ""
"(setq float-pi 3)\n"
"     @result{} float-pi\n"
msgstr ""
"(setq float-pi 3)\n"
"     @result{} float-pi\n"

#. type: group
#: original_texis/variables.texi:508
#, no-wrap
msgid ""
"float-pi\n"
"     @result{} 3\n"
msgstr ""
"float-pi\n"
"     @result{} 3\n"

#. type: Plain text
#: original_texis/variables.texi:519
msgid "@strong{Warning:} If you use a @code{defconst} or @code{defvar} special form while the variable has a local binding (made with @code{let}, or a function argument), it sets the local binding rather than the global binding.  This is not what you usually want.  To prevent this, use these special forms at top level in a file, where normally no local binding is in effect, and make sure to load the file before making a local binding for the variable."
msgstr "@strong{警告:} 変数がローカルバインディングをもつとき(@code{let}により作成された、または関数の引数の場合)に、スペシャルフォーム@code{defconst}または@code{defvar}を使用すると、これらのフォームはグローバルバインディングではなく、ローカルバインディングをセットします。これは通常は、あなたが望むことではないはずです。これを防ぐには、これらのスペシャルフォームをファイル内のトップレベルで使用します。この場所は通常、何のローカルバインディングも効果をもたないので、その変数にたいするローカルバインディングが作成される前にファイルがロードされることが確実だからです。"

#. type: section
#: original_texis/variables.texi:521
#, no-wrap
msgid "Tips for Defining Variables Robustly"
msgstr "Tips for Defining Variables Robustly"

#. type: Plain text
#: original_texis/variables.texi:526
msgid "When you define a variable whose value is a function, or a list of functions, use a name that ends in @samp{-function} or @samp{-functions}, respectively."
msgstr "値が関数(または関数のリスト)であるような変数を定義するときには、変数の名前の最後に@samp{-function}(または@samp{-functions})を使用します。"

#. type: Plain text
#: original_texis/variables.texi:529
msgid "There are several other variable name conventions; here is a complete list:"
msgstr "他にも変数名に関する慣習があります。以下はその完全なリストです:"

#. type: item
#: original_texis/variables.texi:531
#, no-wrap
msgid "@dots{}-hook"
msgstr "@dots{}-hook"

#. type: table
#: original_texis/variables.texi:533
msgid "The variable is a normal hook (@pxref{Hooks})."
msgstr "変数はノーマルフック(@ref{Hooks}を参照)。"

#. type: item
#: original_texis/variables.texi:534
#, no-wrap
msgid "@dots{}-function"
msgstr "@dots{}-function"

#. type: table
#: original_texis/variables.texi:536
msgid "The value is a function."
msgstr "値は関数。"

#. type: item
#: original_texis/variables.texi:537
#, no-wrap
msgid "@dots{}-functions"
msgstr "@dots{}-functions"

#. type: table
#: original_texis/variables.texi:539
msgid "The value is a list of functions."
msgstr "値は関数のリスト。"

#. type: item
#: original_texis/variables.texi:540
#, no-wrap
msgid "@dots{}-form"
msgstr "@dots{}-form"

#. type: table
#: original_texis/variables.texi:542
msgid "The value is a form (an expression)."
msgstr "値はフォーム(式)。"

#. type: item
#: original_texis/variables.texi:543
#, no-wrap
msgid "@dots{}-forms"
msgstr "@dots{}-forms"

#. type: table
#: original_texis/variables.texi:545
msgid "The value is a list of forms (expressions)."
msgstr "値はフォーム(式)のリスト。"

#. type: item
#: original_texis/variables.texi:546
#, no-wrap
msgid "@dots{}-predicate"
msgstr "@dots{}-predicate"

#. type: table
#: original_texis/variables.texi:550
msgid "The value is a predicate---a function of one argument that returns non-@code{nil} for ``good'' arguments and @code{nil} for ``bad'' arguments."
msgstr "値は述語(predicate) --- 1つの引数をとる関数 --- で、引数が``正しい(good)''\"場合は非@code{nil}、``正しくない(bad)''場合は@code{nil}をreturnします。"

#. type: item
#: original_texis/variables.texi:551
#, no-wrap
msgid "@dots{}-flag"
msgstr "@dots{}-flag"

#. type: table
#: original_texis/variables.texi:555
msgid "The value is significant only as to whether it is @code{nil} or not.  Since such variables often end up acquiring more values over time, this convention is not strongly recommended."
msgstr "@code{nil}か否かだけが意味をもつような値。結局そのような変数は、やがては多くの値をもつことが多いので、この慣習を強く推奨はしない。"

#. type: item
#: original_texis/variables.texi:556
#, no-wrap
msgid "@dots{}-program"
msgstr "@dots{}-program"

#. type: table
#: original_texis/variables.texi:558
msgid "The value is a program name."
msgstr "値はプログラム名。"

#. type: item
#: original_texis/variables.texi:559
#, no-wrap
msgid "@dots{}-command"
msgstr "@dots{}-command"

#. type: table
#: original_texis/variables.texi:561
msgid "The value is a whole shell command."
msgstr "値は完全なシェルコマンド。"

#. type: item
#: original_texis/variables.texi:562
#, no-wrap
msgid "@dots{}-switches"
msgstr "@dots{}-switches"

#. type: table
#: original_texis/variables.texi:564
msgid "The value specifies options for a command."
msgstr "値はコマンドにたいして指定するオプション。"

#. type: Plain text
#: original_texis/variables.texi:568
msgid "When you define a variable, always consider whether you should mark it as ``safe'' or ``risky''; see @ref{File Local Variables}."
msgstr "変数を定義するときは、その変数を``安全(safe)''とマークすべきか、それとも``危険(risky)''とマークすべきかを常に考慮してください。@ref{File Local Variables}を参照してください。"

#. type: Plain text
#: original_texis/variables.texi:572
msgid "When defining and initializing a variable that holds a complicated value (such as a keymap with bindings in it), it's best to put the entire computation of the value into the @code{defvar}, like this:"
msgstr "複雑な値を保持する変数(バインディングをもつkeymapなど)の定義や初期化を行う場合は、以下のように値の計算をすべて@code{defvar}の中に配置するのが最良です:"

#. type: example
#: original_texis/variables.texi:580
#, no-wrap
msgid ""
"(defvar my-mode-map\n"
"  (let ((map (make-sparse-keymap)))\n"
"    (define-key map \"\\C-c\\C-a\" 'my-command)\n"
"    @dots{}\n"
"    map)\n"
"  @var{docstring})\n"
msgstr ""
"(defvar my-mode-map\n"
"  (let ((map (make-sparse-keymap)))\n"
"    (define-key map \"\\C-c\\C-a\" 'my-command)\n"
"    @dots{}\n"
"    map)\n"
"  @var{docstring})\n"

#. type: Plain text
#: original_texis/variables.texi:591
msgid "This method has several benefits.  First, if the user quits while loading the file, the variable is either still uninitialized or initialized properly, never in-between.  If it is still uninitialized, reloading the file will initialize it properly.  Second, reloading the file once the variable is initialized will not alter it; that is important if the user has run hooks to alter part of the contents (such as, to rebind keys).  Third, evaluating the @code{defvar} form with @kbd{C-M-x} will reinitialize the map completely."
msgstr "この方法にはいくつかの利点があります。1つ目はファールをロード中にユーザーが中断した場合、変数はまだ初期化されていないか、初期化されているかのどちらかであり、その中間ということはありません。まだ初期化されていなければ、ファイルをリロードすれば正しく初期化されます。2つ目は一度初期化された変数は、ファイルをリロードしても変更されないことです。コンテンツの一部を変更(たとえばキーのリバインド)するフックをユーザーが実行した場合などに、これは重要です。3つ目は@kbd{C-M-x}で@code{defvar}を評価すると、そのマップは完全に再初期化されることです。"

#. type: Plain text
#: original_texis/variables.texi:595
msgid "Putting so much code in the @code{defvar} form has one disadvantage: it puts the documentation string far away from the line which names the variable.  Here's a safe way to avoid that:"
msgstr "@code{defvar}フォーム内に多すぎるコードを配置することが不利な点が1つあります。ドキュメント文字列が変数の名前から離れた場所に配置されることです。これを避ける安全な方法は以下の方法です:"

#. type: example
#: original_texis/variables.texi:604
#, no-wrap
msgid ""
"(defvar my-mode-map nil\n"
"  @var{docstring})\n"
"(unless my-mode-map\n"
"  (let ((map (make-sparse-keymap)))\n"
"    (define-key map \"\\C-c\\C-a\" 'my-command)\n"
"    @dots{}\n"
"    (setq my-mode-map map)))\n"
msgstr ""
"(defvar my-mode-map nil\n"
"  @var{docstring})\n"
"(unless my-mode-map\n"
"  (let ((map (make-sparse-keymap)))\n"
"    (define-key map \"\\C-c\\C-a\" 'my-command)\n"
"    @dots{}\n"
"    (setq my-mode-map map)))\n"

#. type: Plain text
#: original_texis/variables.texi:610
msgid "This has all the same advantages as putting the initialization inside the @code{defvar}, except that you must type @kbd{C-M-x} twice, once on each form, if you do want to reinitialize the variable."
msgstr "これは初期化を@code{defvar}の内側に配置した場合とまったく同じ利点をもちますが、変数を再度初期化したい場合は、各フォームにたいして1回ずつ、@kbd{C-M-x}を2回タイプしなければならない点が異なります。"

#. type: section
#: original_texis/variables.texi:612
#, no-wrap
msgid "Accessing Variable Values"
msgstr "Accessing Variable Values"

#. type: Plain text
#: original_texis/variables.texi:616
msgid "The usual way to reference a variable is to write the symbol which names it.  @xref{Symbol Forms}."
msgstr "変数を参照する通常の方法は、それに名前をつけるシンボルを記述する方法です。@ref{Symbol Forms}を参照してください。"

#. type: Plain text
#: original_texis/variables.texi:621
msgid "Occasionally, you may want to reference a variable which is only determined at run time.  In that case, you cannot specify the variable name in the text of the program.  You can use the @code{symbol-value} function to extract the value."
msgstr "実行時にのみ決定される変数を参照したいときがあるかもしれません。そのような場合、プログラム中のテキストで変数名を指定することはできません。そのような値を抽出するために@code{symbol-value}を使うことができます。"

#. type: defun
#: original_texis/variables.texi:622
#, no-wrap
msgid "symbol-value symbol"
msgstr "symbol-value symbol"

#. type: defun
#: original_texis/variables.texi:627
msgid "This function returns the value stored in @var{symbol}'s value cell.  This is where the variable's current (dynamic) value is stored.  If the variable has no local binding, this is simply its global value.  If the variable is void, a @code{void-variable} error is signaled."
msgstr "この関数は@var{symbol}の値セルに格納された値をリターンする。これはその変数の(ダイナミックな)カレント値が格納された場所である。その変数がローカルバインディングをもたなければ単にその変数のグローバル値になる。変数がvoidなら@code{void-variable}はエラーをシグナルする。"

#. type: defun
#: original_texis/variables.texi:632
msgid "If the variable is lexically bound, the value reported by @code{symbol-value} is not necessarily the same as the variable's lexical value, which is determined by the lexical environment rather than the symbol's value cell.  @xref{Variable Scoping}."
msgstr "その変数がレキシカルにバインドされていれば、@code{symbol-value}が報告する値は、その変数のレキシカル値と同じである必要はない。レキシカル値はそのシンボルの値セルではなく、レキシカル環境により決定される。@ref{Variable Scoping}を参照のこと。"

#. type: group
#: original_texis/variables.texi:637
#, no-wrap
msgid ""
"(setq abracadabra 5)\n"
"     @result{} 5\n"
msgstr ""
"(setq abracadabra 5)\n"
"     @result{} 5\n"

#. type: group
#: original_texis/variables.texi:641
#, no-wrap
msgid ""
"(setq foo 9)\n"
"     @result{} 9\n"
msgstr ""
"(setq foo 9)\n"
"     @result{} 9\n"

#. type: group
#: original_texis/variables.texi:649
#, no-wrap
msgid ""
";; @r{Here the symbol @code{abracadabra}}\n"
";;   @r{is the symbol whose value is examined.}\n"
"(let ((abracadabra 'foo))\n"
"  (symbol-value 'abracadabra))\n"
"     @result{} foo\n"
msgstr ""
";; @r{ここでシンボル@code{abracadabra}}\n"
";;   @r{は値がテストされるシンボル}\n"
"(let ((abracadabra 'foo))\n"
"  (symbol-value 'abracadabra))\n"
"     @result{} foo\n"

#. type: group
#: original_texis/variables.texi:658
#, no-wrap
msgid ""
";; @r{Here, the value of @code{abracadabra},}\n"
";;   @r{which is @code{foo},}\n"
";;   @r{is the symbol whose value is examined.}\n"
"(let ((abracadabra 'foo))\n"
"  (symbol-value abracadabra))\n"
"     @result{} 9\n"
msgstr ""
";; @r{ここでは@code{abracadabra}の値、}\n"
";;   @r{つまり@code{foo}が値を}\n"
";;   @r{テストされるシンボル}\n"
"(let ((abracadabra 'foo))\n"
"  (symbol-value abracadabra))\n"
"     @result{} 9\n"

#. type: group
#: original_texis/variables.texi:663
#, no-wrap
msgid ""
"(symbol-value 'abracadabra)\n"
"     @result{} 5\n"
msgstr ""
"(symbol-value 'abracadabra)\n"
"     @result{} 5\n"

#. type: section
#: original_texis/variables.texi:668
#, no-wrap
msgid "Setting Variable Values"
msgstr "Setting Variable Values"

#. type: Plain text
#: original_texis/variables.texi:673
msgid "The usual way to change the value of a variable is with the special form @code{setq}.  When you need to compute the choice of variable at run time, use the function @code{set}."
msgstr "ある変数の値を変更する通常の方法は、スペシャルフォーム@code{setq}を使用する方法です。実行時に変数選択を計算する必要がある場合には関数@code{set}を使用します。"

#. type: defspec
#: original_texis/variables.texi:674
#, no-wrap
msgid "setq [symbol form]@dots{}"
msgstr "setq [symbol form]@dots{}"

#. type: defspec
#: original_texis/variables.texi:679
msgid "This special form is the most common method of changing a variable's value.  Each @var{symbol} is given a new value, which is the result of evaluating the corresponding @var{form}.  The current binding of the symbol is changed."
msgstr "このスペシャルフォームは、変数の値を変更するためのもっとも一般的な方法である。@var{symbol}にはそれぞれ、新しい値(対応する@var{form}が評価された結果)が与えられる。そのシンボルのカレントバインディングは変更される。"

#. type: defspec
#: original_texis/variables.texi:683
msgid "@code{setq} does not evaluate @var{symbol}; it sets the symbol that you write.  We say that this argument is @dfn{automatically quoted}.  The @samp{q} in @code{setq} stands for ``quoted''."
msgstr "@code{setq}は@var{symbol}を評価せずに、記述されたシンボルをセットする。この引数のことを@dfn{自動的にクォートされた(automatically quoted)}と呼ぶ。@code{setq}の@samp{q}は``quoted(クォートされた)''が由来。"

#. type: defspec
#: original_texis/variables.texi:685
msgid "The value of the @code{setq} form is the value of the last @var{form}."
msgstr "@code{setq}フォームの値は最後の@var{form}の値となる。"

#. type: group
#: original_texis/variables.texi:690
#, no-wrap
msgid ""
"(setq x (1+ 2))\n"
"     @result{} 3\n"
msgstr ""
"(setq x (1+ 2))\n"
"     @result{} 3\n"

#. type: example
#: original_texis/variables.texi:693
#, no-wrap
msgid ""
"x                   ; @r{@code{x} now has a global value.}\n"
"     @result{} 3\n"
msgstr ""
"x                   ; @r{ここで@code{x}はグローバル値をもつ}\n"
"     @result{} 3\n"

#. type: group
#: original_texis/variables.texi:698
#, no-wrap
msgid ""
"(let ((x 5))\n"
"  (setq x 6)        ; @r{The local binding of @code{x} is set.}\n"
"  x)\n"
"     @result{} 6\n"
msgstr ""
"(let ((x 5))\n"
"  (setq x 6)        ; @r{@code{x}のローカルバインディングをセット}\n"
"  x)\n"
"     @result{} 6\n"

#. type: example
#: original_texis/variables.texi:701
#, no-wrap
msgid ""
"x                   ; @r{The global value is unchanged.}\n"
"     @result{} 3\n"
msgstr ""
"x                   ; @r{グローバル値は変更されない}\n"
"     @result{} 3\n"

#. type: defspec
#: original_texis/variables.texi:706
msgid "Note that the first @var{form} is evaluated, then the first @var{symbol} is set, then the second @var{form} is evaluated, then the second @var{symbol} is set, and so on:"
msgstr "1番目の@var{form}が評価されてから1番目の@var{symbol}がセット、次に2番目の@var{form}が評価されてから@var{symbol}が評価されて、...となることに注意:"

#. type: group
#: original_texis/variables.texi:712
#, no-wrap
msgid ""
"(setq x 10          ; @r{Notice that @code{x} is set before}\n"
"      y (1+ x))     ;   @r{the value of @code{y} is computed.}\n"
"     @result{} 11\n"
msgstr ""
"(setq x 10          ; @r{ここで、@code{x}がセットされるのは}\n"
"      y (1+ x))     ;   @r{@code{y}の計算前であることに注目}\n"
"     @result{} 11\n"

#. type: defun
#: original_texis/variables.texi:716
#, no-wrap
msgid "set symbol value"
msgstr "set symbol value"

#. type: defun
#: original_texis/variables.texi:721
msgid "This function puts @var{value} in the value cell of @var{symbol}.  Since it is a function rather than a special form, the expression written for @var{symbol} is evaluated to obtain the symbol to set.  The return value is @var{value}."
msgstr "この関数は@var{symbol}の値セルに@var{value}を配置する。これはスペシャルフォームではなく関数なので、シンボルにセットするために@var{symbol}に記述された式は評価される。リターン値は@var{value}。"

#. type: defun
#: original_texis/variables.texi:728
msgid "When dynamic variable binding is in effect (the default), @code{set} has the same effect as @code{setq}, apart from the fact that @code{set} evaluates its @var{symbol} argument whereas @code{setq} does not.  But when a variable is lexically bound, @code{set} affects its @emph{dynamic} value, whereas @code{setq} affects its current (lexical) value.  @xref{Variable Scoping}."
msgstr "ダイナミックな変数バインドが有効(デフォルト)なら、@code{set}は自身の引数@var{symbol}を評価するが、@code{setq}は評価しないという点を除き、@code{set}は@code{setq}と同じ効果をもつ。しかし変数がレキシカルバインドなら、@code{set}は変数の@emph{ダイナミック}な値に、@code{setq}は変数のカレント値(レキシカル値)に影響する。@ref{Variable Scoping}を参照のこと。"

#. type: group
#: original_texis/variables.texi:733
#, no-wrap
msgid ""
"(set one 1)\n"
"@error{} Symbol's value as variable is void: one\n"
msgstr ""
"(set one 1)\n"
"@error{} Symbol's value as variable is void: one\n"

#. type: group
#: original_texis/variables.texi:737
#, no-wrap
msgid ""
"(set 'one 1)\n"
"     @result{} 1\n"
msgstr ""
"(set 'one 1)\n"
"     @result{} 1\n"

#. type: group
#: original_texis/variables.texi:741
#, no-wrap
msgid ""
"(set 'two 'one)\n"
"     @result{} one\n"
msgstr ""
"(set 'two 'one)\n"
"     @result{} one\n"

#. type: group
#: original_texis/variables.texi:745
#, no-wrap
msgid ""
"(set two 2)         ; @r{@code{two} evaluates to symbol @code{one}.}\n"
"     @result{} 2\n"
msgstr ""
"(set two 2)         ; @r{@code{two}はシンボル@code{one}に評価される}\n"
"     @result{} 2\n"

#. type: group
#: original_texis/variables.texi:753
#, no-wrap
msgid ""
"one                 ; @r{So it is @code{one} that was set.}\n"
"     @result{} 2\n"
"(let ((one 1))      ; @r{This binding of @code{one} is set,}\n"
"  (set 'one 3)      ;   @r{not the global value.}\n"
"  one)\n"
"     @result{} 3\n"
msgstr ""
"one                 ; @r{したがって@code{one}がセットされる}\n"
"     @result{} 2\n"
"(let ((one 1))      ; @r{@code{one}のこのバインディングがセットされる}\n"
"  (set 'one 3)      ;   @r{のであってグローバル値はセットされない}\n"
"  one)\n"
"     @result{} 3\n"

#. type: group
#: original_texis/variables.texi:757
#, no-wrap
msgid ""
"one\n"
"     @result{} 2\n"
msgstr ""
"one\n"
"     @result{} 2\n"

#. type: defun
#: original_texis/variables.texi:762
msgid "If @var{symbol} is not actually a symbol, a @code{wrong-type-argument} error is signaled."
msgstr "@var{symbol}が実際のシンボルでなければ@code{wrong-type-argument}エラーがシグナルされる。"

#. type: example
#: original_texis/variables.texi:766
#, no-wrap
msgid ""
"(set '(x y) 'z)\n"
"@error{} Wrong type argument: symbolp, (x y)\n"
msgstr ""
"(set '(x y) 'z)\n"
"@error{} Wrong type argument: symbolp, (x y)\n"

#. type: section
#: original_texis/variables.texi:770
#, no-wrap
msgid "Scoping Rules for Variable Bindings"
msgstr "Scoping Rules for Variable Bindings"

#. type: cindex
#: original_texis/variables.texi:771
#, no-wrap
msgid "scoping rule"
msgstr "scoping rule"

#. type: Plain text
#: original_texis/variables.texi:776
msgid "When you create a local binding for a variable, that binding takes effect only within a limited portion of the program (@pxref{Local Variables}).  This section describes exactly what this means."
msgstr "ある変数にたいするローカルバインディングを作成するとき、そのバインディングはプログラムの限られた一部だけに効果をもちます(@ref{Local Variables}を参照)。このセクションでは、これが正確には何を意味するかについて説明します。"

#. type: cindex
#: original_texis/variables.texi:777
#, no-wrap
msgid "scope"
msgstr "scope"

#. type: cindex
#: original_texis/variables.texi:778
#, no-wrap
msgid "extent"
msgstr "extent"

#. type: Plain text
#: original_texis/variables.texi:783
msgid "Each local binding has a certain @dfn{scope} and @dfn{extent}.  @dfn{Scope} refers to @emph{where} in the textual source code the binding can be accessed.  @dfn{Extent} refers to @emph{when}, as the program is executing, the binding exists."
msgstr "ローカルバインディングはそれぞれ、個別に@dfn{スコープ(scope: 範囲という意味)}と@dfn{エクステント(extent: これも範囲を意味する)}をもちます。@dfn{スコープ}はそのバインディングにアクセスできるのが、テキストのソースコードの@emph{どこ(where)}であるかを示します。@dfn{エクステント}はプログラムの実行中に、そのバインディングが存在するのが@emph{いつ(when)}であるかを示します。"

#. type: cindex
#: original_texis/variables.texi:784
#, no-wrap
msgid "dynamic binding"
msgstr "dynamic binding"

#. type: cindex
#: original_texis/variables.texi:785
#, no-wrap
msgid "dynamic scope"
msgstr "dynamic scope"

#. type: cindex
#: original_texis/variables.texi:786
#, no-wrap
msgid "dynamic extent"
msgstr "dynamic extent"

#. type: Plain text
#: original_texis/variables.texi:793
msgid "By default, the local bindings that Emacs creates are @dfn{dynamic bindings}.  Such a binding has @dfn{dynamic scope}, meaning that any part of the program can potentially access the variable binding.  It also has @dfn{dynamic extent}, meaning that the binding lasts only while the binding construct (such as the body of a @code{let} form) is being executed."
msgstr "デフォルトではEmacsが作成したローカルバインディングは、@dfn{ダイナミックバインディング(dynamic binding)}です。このようなバインディングは@dfn{ダイナミックスコープ(dynamic scope)}をもち、それはプログラムの任意の範囲が、その変数バインディングにアクセスするかもしれないことを意味します。これは@dfn{ダイナミックエクステント(dynamic extent)}ももっています。これはそのバインディング構造(@code{let}フォームのbodyなど)が実行される間だけ、そのバインディングが存続することを意味します。"

#. type: cindex
#: original_texis/variables.texi:794
#, no-wrap
msgid "lexical binding"
msgstr "lexical binding"

#. type: cindex
#: original_texis/variables.texi:795
#, no-wrap
msgid "lexical scope"
msgstr "lexical scope"

#. type: cindex
#: original_texis/variables.texi:796
#, no-wrap
msgid "indefinite extent"
msgstr "indefinite extent"

#. type: Plain text
#: original_texis/variables.texi:805
msgid "Emacs can optionally create @dfn{lexical bindings}.  A lexical binding has @dfn{lexical scope}, meaning that any reference to the variable must be located textually within the binding construct@footnote{With some exceptions; for instance, a lexical binding can also be accessed from the Lisp debugger.}.  It also has @dfn{indefinite extent}, meaning that under some circumstances the binding can live on even after the binding construct has finished executing, by means of special objects called @dfn{closures}."
msgstr "Emacsはオプションで@dfn{レキシカルバインディング(lexical binding)}を作成することができます。レキシカルバインディングは@dfn{レキシカルスコープ(lexical scope)}をもち、これはその変数にたいするすべての参照が、バインディング構文内にテキスト的に配置されなければならないことを意味します@footnote{これにはいくつか例外があります。たとえばレキシカルバインディングは、Lispデバッガーからもアクセスできます。}。レキシカルバインディングは@dfn{不定エクステント(indefinite extent)}ももっています。これはある状況下において、@dfn{クロージャー(closures)}と呼ばれるスペシャルオブジェクトにより、バインディング構造が実行を終えた後でさえも、存続し続けることを意味します。"

#. type: Plain text
#: original_texis/variables.texi:809
msgid "The following subsections describe dynamic binding and lexical binding in greater detail, and how to enable lexical binding in Emacs Lisp programs."
msgstr "以降のサブセクションでは、ダイナミックバインディングとレキシカルバインディング、およびEmacs Lispプログラムでレキシカルバインディングを有効にする方法についてより詳細に説明します。"

#. type: subsection
#: original_texis/variables.texi:815 original_texis/variables.texi:817
#: original_texis/variables.texi:818
#, no-wrap
msgid "Dynamic Binding"
msgstr "Dynamic Binding"

#. type: menuentry
#: original_texis/variables.texi:815
msgid "The default for binding local variables in Emacs."
msgstr "Emacs内でのローカル変数にたいするデフォルトのバインディング。"

#. type: node
#: original_texis/variables.texi:815 original_texis/variables.texi:888
#, no-wrap
msgid "Dynamic Binding Tips"
msgstr "Dynamic Binding Tips"

#. type: menuentry
#: original_texis/variables.texi:815
msgid "Avoiding problems with dynamic binding."
msgstr "ダイナミックバインディングによる問題を回避する。"

#. type: subsection
#: original_texis/variables.texi:815 original_texis/variables.texi:933
#: original_texis/variables.texi:934
#, no-wrap
msgid "Lexical Binding"
msgstr "Lexical Binding"

#. type: menuentry
#: original_texis/variables.texi:815
msgid "A different type of local variable binding."
msgstr "ローカル変数にたいする他の種類のバインディング。"

#. type: subsection
#: original_texis/variables.texi:815 original_texis/variables.texi:1042
#: original_texis/variables.texi:1043
#, no-wrap
msgid "Using Lexical Binding"
msgstr "Using Lexical Binding"

#. type: menuentry
#: original_texis/variables.texi:815
msgid "How to enable lexical binding."
msgstr "レキシカルバインディングを有効にする方法。"

#. type: Plain text
#: original_texis/variables.texi:825
msgid "By default, the local variable bindings made by Emacs are dynamic bindings.  When a variable is dynamically bound, its current binding at any point in the execution of the Lisp program is simply the most recently-created dynamic local binding for that symbol, or the global binding if there is no such local binding."
msgstr "デフォルトでは、Emacsにより作成されるローカル変数のバインディングはダイナミックバインディングです。ある変数がダイナミックにバインドされていると、Lispプログラムの実行における任意のポイントでのカレントバインディングは、単にそのシンボルにたいしてもっとも最近作成されたダイナミックなローカルバインディング、またはそのようなローカルバインディングが存在しなければグローバルバインディングになります。"

#. type: Plain text
#: original_texis/variables.texi:828
msgid "Dynamic bindings have dynamic scope and extent, as shown by the following example:"
msgstr "以下の例のように、ダイナミックバインディングはダイナミックスコープとダイナミックエクステントをもちます:"

#. type: group
#: original_texis/variables.texi:832
#, no-wrap
msgid ""
"(defvar x -99)  ; @r{@code{x} receives an initial value of @minus{}99.}\n"
"\n"
msgstr ""
"(defvar x -99)  ; @r{@code{x}は初期値として@minus{}99を受け取る}\n"
"\n"

#. type: group
#: original_texis/variables.texi:835 original_texis/variables.texi:961
#, no-wrap
msgid ""
"(defun getx ()\n"
"  x)            ; @r{@code{x} is used ``free'' in this function.}\n"
"\n"
msgstr ""
"(defun getx ()\n"
"  x)            ; @r{この関数内では、@code{x}は``自由''に使用される。}\n"
"\n"

#. type: group
#: original_texis/variables.texi:839
#, no-wrap
msgid ""
"(let ((x 1))    ; @r{@code{x} is dynamically bound.}\n"
"  (getx))\n"
"     @result{} 1\n"
"\n"
msgstr ""
"(let ((x 1))    ; @r{@code{x}はダイナミックにバインドされている}\n"
"  (getx))\n"
"     @result{} 1\n"
"\n"

#. type: group
#: original_texis/variables.texi:842 original_texis/variables.texi:874
#, no-wrap
msgid ""
";; @r{After the @code{let} form finishes, @code{x} reverts to its}\n"
";; @r{previous value, which is @minus{}99.}\n"
"\n"
msgstr ""
";; @r{@code{let}フォームが終了した後に}\n"
";; @r{@code{x}は前の値@minus{}99にリバートされる}\n"
"\n"

#. type: group
#: original_texis/variables.texi:845
#, no-wrap
msgid ""
"(getx)\n"
"     @result{} -99\n"
msgstr ""
"(getx)\n"
"     @result{} -99\n"

#. type: Plain text
#: original_texis/variables.texi:856
msgid "The function @code{getx} refers to @code{x}.  This is a ``free'' reference, in the sense that there is no binding for @code{x} within that @code{defun} construct itself.  When we call @code{getx} from within a @code{let} form in which @code{x} is (dynamically) bound, it retrieves the local value (i.e., 1).  But when we call @code{getx} outside the @code{let} form, it retrieves the global value (i.e., @minus{}99)."
msgstr "関数@code{getx}は@code{x}を参照します。@code{defun}構造自体の中に@code{x}にたいするバインディングが存在しないと意味において、これは``自由''な参照です。@code{x}が(ダイナミックに)バインドされている@code{let}フォーム内から@code{getx}を呼び出すと、ローカル値(つまり1)が取得されます。しかし、その後@code{let}フォームの外側から@code{getx}を呼び出すと、グローバル値(つまり@minus{}99)が取得されます。"

#. type: Plain text
#: original_texis/variables.texi:859
msgid "Here is another example, which illustrates setting a dynamically bound variable using @code{setq}:"
msgstr "以下は@code{setq}を使用してダイナミックに変数をバインドする例です:"

#. type: group
#: original_texis/variables.texi:863
#, no-wrap
msgid ""
"(defvar x -99)      ; @r{@code{x} receives an initial value of @minus{}99.}\n"
"\n"
msgstr ""
"(defvar x -99)      ; @r{@code{x}は初期値として@minus{}99を受け取る}\n"
"\n"

#. type: group
#: original_texis/variables.texi:866
#, no-wrap
msgid ""
"(defun addx ()\n"
"  (setq x (1+ x)))  ; @r{Add 1 to @code{x} and return its new value.}\n"
"\n"
msgstr ""
"(defun addx ()\n"
"  (setq x (1+ x)))  ; @r{@code{x}に1加算して新しい値をリターンする}\n"
"\n"

#. type: group
#: original_texis/variables.texi:871
#, no-wrap
msgid ""
"(let ((x 1))\n"
"  (addx)\n"
"  (addx))\n"
"     @result{} 3           ; @r{The two @code{addx} calls add to @code{x} twice.}\n"
"\n"
msgstr ""
"(let ((x 1))\n"
"  (addx)\n"
"  (addx))\n"
"     @result{} 3           ; @r{@code{addx}を2回呼び出すと@code{x}に2回加算される}\n"
"\n"

#. type: group
#: original_texis/variables.texi:877
#, no-wrap
msgid ""
"(addx)\n"
"     @result{} -98\n"
msgstr ""
"(addx)\n"
"     @result{} -98\n"

#. type: Plain text
#: original_texis/variables.texi:887
msgid "Dynamic binding is implemented in Emacs Lisp in a simple way.  Each symbol has a value cell, which specifies its current dynamic value (or absence of value).  @xref{Symbol Components}.  When a symbol is given a dynamic local binding, Emacs records the contents of the value cell (or absence thereof) in a stack, and stores the new local value in the value cell.  When the binding construct finishes executing, Emacs pops the old value off the stack, and puts it in the value cell."
msgstr "Emacs Lispでのダイナミックバインディングは、シンプルな方法で実装されています。シンボルはそれぞれ、シンボルのカレントのダイナミック値(または値の不在)を指定する値セルをもちます。@ref{Symbol Components}を参照してください。あるシンボルがダイナミックなローカル値を与えられたとき、Emacsは値セルの内容(または値の不在)をスタックに記録して、新しいローカル値を値セルに格納します。バインディング構文が実行を終えたとき、Emacsはスタックから古い値をpopして値セルにそれを配置します。"

#. type: subsection
#: original_texis/variables.texi:889
#, no-wrap
msgid "Proper Use of Dynamic Binding"
msgstr "Proper Use of Dynamic Binding"

#. type: Plain text
#: original_texis/variables.texi:896
msgid "Dynamic binding is a powerful feature, as it allows programs to refer to variables that are not defined within their local textual scope.  However, if used without restraint, this can also make programs hard to understand.  There are two clean ways to use this technique:"
msgstr "ダイナミックバインディングは、プログラムにたいしてテキスト的なローカルスコープ内で定義されていない変数を参照することを許容する、強力な機能です。しかし無制限に使用した場合には、プログラムの理解を困難にしてしまうこともあります。このテクニックを使用するために2つの明解な方法があります:"

#. type: itemize
#: original_texis/variables.texi:905
msgid "If a variable has no global definition, use it as a local variable only within a binding construct, such as the body of the @code{let} form where the variable was bound.  If this convention is followed consistently throughout a program, the value of the variable will not affect, nor be affected by, any uses of the same variable symbol elsewhere in the program."
msgstr "ある変数がグローバルな定義をもたなければ、ローカル変数としてバインディング構文内(その変数がバインドされる@code{let}フォームのbodyなどの場所)だけでそれを使用する。プログラムでこの慣習に一貫してしたがえば、プログラム内の他の場所で同じ変数シンボルを任意に使用しても、その変数の値に影響を与えたり、影響を受けることがなくなる。"

#. type: itemize
#: original_texis/variables.texi:913
msgid "Otherwise, define the variable with @code{defvar}, @code{defconst}, or @code{defcustom}.  @xref{Defining Variables}.  Usually, the definition should be at top-level in an Emacs Lisp file.  As far as possible, it should include a documentation string which explains the meaning and purpose of the variable.  You should also choose the variable's name to avoid name conflicts (@pxref{Coding Conventions})."
msgstr "それ以外なら@code{defvar}、@code{defconst}、@code{defcustom}で変数を定義する。@ref{Defining Variables}を参照のこと。この定義は通常はEmacs Lispファイル内のトップレベルにあること。この定義には変数の意味と目的を説明するドキュメント文字列を可能な限り含めるべきである。また名前の衝突を避けるように変数を命名すること(@ref{Coding Conventions}を参照)。"

#. type: itemize
#: original_texis/variables.texi:919
msgid "Then you can bind the variable anywhere in a program, knowing reliably what the effect will be.  Wherever you encounter the variable, it will be easy to refer back to the definition, e.g., via the @kbd{C-h v} command (provided the variable definition has been loaded into Emacs).  @xref{Name Help,,, emacs, The GNU Emacs Manual}."
msgstr "そうすればプログラム内のどこか別の場所で、それが何に影響するか確信をもって変数をバインドすることができます。その変数にどこで出会っても、(たとえば変数の定義がEmacsにロードされていれば@kbd{C-h v}コマンドを通じて)定義を参照するのが簡単になります。@ref{Name Help,,, emacs, The GNU Emacs Manual}を参照してください。"

#. type: itemize
#: original_texis/variables.texi:922
msgid "For example, it is common to use local bindings for customizable variables like @code{case-fold-search}:"
msgstr "たとえば@code{case-fold-search}のようなカスタマイズ可能な変数にたいしてローカルバインディングを使用するのは一般的です:"

#. type: group
#: original_texis/variables.texi:929
#, no-wrap
msgid ""
"(defun search-for-abc ()\n"
"  \"Search for the string \\\"abc\\\", ignoring case differences.\"\n"
"  (let ((case-fold-search nil))\n"
"    (re-search-forward \"abc\")))\n"
msgstr ""
"(defun search-for-abc ()\n"
"  \"Search for the string \\\"abc\\\", ignoring case differences.\"\n"
"  (let ((case-fold-search nil))\n"
"    (re-search-forward \"abc\")))\n"

#. type: Plain text
#: original_texis/variables.texi:942
msgid "Lexical binding was introduced to Emacs, as an optional feature, in version 24.1.  We expect its importance to increase in the future.  Lexical binding opens up many more opportunities for optimization, so programs using it are likely to run faster in future Emacs versions.  Lexical binding is also more compatible with concurrency, which we want to add to Emacs in the future."
msgstr "Emacsのバージョン24.1からオプションの機能としてレキシカルバインディングが導入されました。わたしたちはこの機能の重要性が、将来増加することを期待しています。レキシカルバインディングは最適化の機会をより広げるので、この機能を使用するプログラムはおそらくEmacsの将来のバージョンで高速に実行されるようになるでしょう。レキシカルバインディングは、わたしたちがEmacsに将来追加したいと考える並列性(concurrency)とも互換性があります。"

#. type: Plain text
#: original_texis/variables.texi:946
msgid "A lexically-bound variable has @dfn{lexical scope}, meaning that any reference to the variable must be located textually within the binding construct.  Here is an example"
msgstr "レキシカルにバインドされた変数は@dfn{レキシカルスコープ(lexical scope)}をもちます。これはその変数にたいする参照が、そのバインディング構文内にテキスト的に配置されなければならないことを意味しています。以下は例です"

#. type: iftex
#: original_texis/variables.texi:948
msgid "(see the next subsection, for how to actually enable lexical binding):"
msgstr "(実際にレキシカルバインディングを有功にする方法は、次のサブセクションを参照のこと):"

#. type: ifnottex
#: original_texis/variables.texi:951
msgid "(@pxref{Using Lexical Binding}, for how to actually enable lexical binding):"
msgstr "(実際にレキシカルバインディングを有功にする方法は、@ref{Using Lexical Binding}を参照のこと):"

#. type: group
#: original_texis/variables.texi:958
#, no-wrap
msgid ""
"(let ((x 1))    ; @r{@code{x} is lexically bound.}\n"
"  (+ x 3))\n"
"     @result{} 4\n"
"\n"
msgstr ""
"(let ((x 1))    ; @r{@code{x}はレキシカルにバインドされる}\n"
"  (+ x 3))\n"
"     @result{} 4\n"
"\n"

#. type: group
#: original_texis/variables.texi:965
#, no-wrap
msgid ""
"(let ((x 1))    ; @r{@code{x} is lexically bound.}\n"
"  (getx))\n"
"@error{} Symbol's value as variable is void: x\n"
msgstr ""
"(let ((x 1))    ; @r{@code{x}はレキシカルにバインドされる}\n"
"  (getx))\n"
"@error{} Symbol's value as variable is void: x\n"

#. type: Plain text
#: original_texis/variables.texi:975
msgid "Here, the variable @code{x} has no global value.  When it is lexically bound within a @code{let} form, it can be used in the textual confines of that @code{let} form.  But it can @emph{not} be used from within a @code{getx} function called from the @code{let} form, since the function definition of @code{getx} occurs outside the @code{let} form itself."
msgstr "ここでは@code{x}はグローバル値をもちません。@code{let}フォーム内でレキシカルにバインドされたとき、この変数は@code{let}のテキスト境界内で使用できます。しかしこの@code{let}内から呼び出される@code{getx}関数からは、@code{getx}の関数定義が@code{let}フォームの外側なので使用することが@emph{できません}。"

#. type: cindex
#: original_texis/variables.texi:976
#, no-wrap
msgid "lexical environment"
msgstr "lexical environment"

#. type: Plain text
#: original_texis/variables.texi:983
msgid "Here is how lexical binding works.  Each binding construct defines a @dfn{lexical environment}, specifying the symbols that are bound within the construct and their local values.  When the Lisp evaluator wants the current value of a variable, it looks first in the lexical environment; if the variable is not specified in there, it looks in the symbol's value cell, where the dynamic value is stored."
msgstr "レキシカルバインディングが機能する方法を説明します。各バインディング構造は、その構造および構造のローカル値でバインドされるシンボルを指定することにより、@dfn{レキシカル環境(lexical environment)}を定義します。Lispの評価機能(Lisp evaluator)がある変数のカレント値を得たいときは、最初にレキシカル環境内を探します。そこで変数が指定されていなければ、ダイナミック値が格納されるシンボルの値セルを探します。"

#. type: Plain text
#: original_texis/variables.texi:991
msgid "(Internally, the lexical environment is an alist of symbol-value pairs, with the final element in the alist being the symbol @code{t} rather than a cons cell.  Such an alist can be passed as the second argument to the @code{eval} function, in order to specify a lexical environment in which to evaluate a form.  @xref{Eval}.  Most Emacs Lisp programs, however, should not interact directly with lexical environments in this way; only specialized programs like debuggers.)"
msgstr "(内部的にはレキシカル環境はシンボルと値がペアになったalistでり、alistの最後の要素はコンスセルではなくシンボル@code{t}である。そのようなalistはフォームを評価するためのレキシカル環境を指定するために、@code{eval}関数の2番目の引数として渡すことができる。@ref{Eval}を参照のこと。しかしほとんどのEmacs Lispプログラムは、この方法で直接レキシカル環境を使用するべきではない。デバッガーのような特化されたプログラムだけが使用すること。)"

#. type: cindex
#: original_texis/variables.texi:992
#, no-wrap
msgid "closures, example of using"
msgstr "closures, example of using"

#. type: Plain text
#: original_texis/variables.texi:998
msgid "Lexical bindings have indefinite extent.  Even after a binding construct has finished executing, its lexical environment can be ``kept around'' in Lisp objects called @dfn{closures}.  A closure is created when you define a named or anonymous function with lexical binding enabled.  @xref{Closures}, for details."
msgstr "レキシカルバインディングは不定エクステント(indefinite extent)をもちます。バインディング構造が終了した後でも、そのレキシカル環境は@dfn{クロージャー(closures)}と呼ばれるLispオブジェクト内に``保持''されるかもしれ、あせん。クロージャーはレキシカルバインディングが有効な、名前つきまたは無名(anonymous)の関数が作成されたときに作成されます。詳細は@ref{Closures}を参照してください。"

#. type: Plain text
#: original_texis/variables.texi:1002
msgid "When a closure is called as a function, any lexical variable references within its definition use the retained lexical environment.  Here is an example:"
msgstr "クロージャーが関数として呼び出されたとき、その関数の定義内のレキシカル変数にたいする任意の参照は、維持されたレキシカル環境を使用します。以下は例です:"

#. type: example
#: original_texis/variables.texi:1006
#, no-wrap
msgid ""
"(defvar my-ticker nil)   ; @r{We will use this dynamically bound}\n"
"                         ; @r{variable to store a closure.}\n"
"\n"
msgstr ""
"(defvar my-ticker nil)   ; @r{クロージャーを格納するために}\n"
"                         ; @r{この変数を使用する}\n"
"\n"

#. type: example
#: original_texis/variables.texi:1012
#, no-wrap
msgid ""
"(let ((x 0))             ; @r{@code{x} is lexically bound.}\n"
"  (setq my-ticker (lambda ()\n"
"                    (setq x (1+ x)))))\n"
"    @result{} (closure ((x . 0) t) ()\n"
"          (setq x (1+ x)))\n"
"\n"
msgstr ""
"(let ((x 0))             ; @r{@code{x}はレキシカルにバインドされる}\n"
"  (setq my-ticker (lambda ()\n"
"                    (setq x (1+ x)))))\n"
"    @result{} (closure ((x . 0) t) ()\n"
"          (setq x (1+ x)))\n"
"\n"

#. type: example
#: original_texis/variables.texi:1015
#, no-wrap
msgid ""
"(funcall my-ticker)\n"
"    @result{} 1\n"
"\n"
msgstr ""
"(funcall my-ticker)\n"
"    @result{} 1\n"
"\n"

#. type: example
#: original_texis/variables.texi:1018
#, no-wrap
msgid ""
"(funcall my-ticker)\n"
"    @result{} 2\n"
"\n"
msgstr ""
"(funcall my-ticker)\n"
"    @result{} 2\n"
"\n"

#. type: example
#: original_texis/variables.texi:1021
#, no-wrap
msgid ""
"(funcall my-ticker)\n"
"    @result{} 3\n"
"\n"
msgstr ""
"(funcall my-ticker)\n"
"    @result{} 3\n"
"\n"

#. type: example
#: original_texis/variables.texi:1024
#, no-wrap
msgid ""
"x                        ; @r{Note that @code{x} has no global value.}\n"
"@error{} Symbol's value as variable is void: x\n"
msgstr ""
"x                        ; @r{@code{x}はグローバル値をもたないことに注意}\n"
"@error{} Symbol's value as variable is void: x\n"

#. type: Plain text
#: original_texis/variables.texi:1035
msgid "The @code{let} binding defines a lexical environment in which the variable @code{x} is locally bound to 0.  Within this binding construct, we define a lambda expression which increments @code{x} by one and returns the incremented value.  This lambda expression is automatically turned into a closure, in which the lexical environment lives on even after the @code{let} binding construct has exited.  Each time we evaluate the closure, it increments @code{x}, using the binding of @code{x} in that lexical environment."
msgstr "@code{let}バインディングは、内部に変数@code{x}をもつレキシカル環境を定義して、変数は0にローカルにバインドされます。このバインディング構文内で@code{x}を1増加して、増加された値をリターンするクロージャーを定義しています。このラムダ式は自動的にクロージャーとなり、たとえ@code{let}構文を抜けた後でも、その内部ではレキシカル環境が存続します。クロージャーを評価するときは、毎回レキシカル環境内の@code{x}のバインディングが使用されて、@code{x}が加算されます。"

#. type: Plain text
#: original_texis/variables.texi:1041
msgid "Note that functions like @code{symbol-value}, @code{boundp}, and @code{set} only retrieve or modify a variable's dynamic binding (i.e., the contents of its symbol's value cell).  Also, the code in the body of a @code{defun} or @code{defmacro} cannot refer to surrounding lexical variables."
msgstr "@code{symbol-value}、@code{boundp}、@code{set}のような関数は、変数のダイナミックバインディング(つまりそのシンボルの値セル)だけを取得(または変更)することに注意してください。@code{defun}(または@code{defmacro})のbody内のコードも、周囲のレキシカル変数は参照できません。"

#. type: Plain text
#: original_texis/variables.texi:1048
msgid "When loading an Emacs Lisp file or evaluating a Lisp buffer, lexical binding is enabled if the buffer-local variable @code{lexical-binding} is non-@code{nil}:"
msgstr "Emacs LispファイルのロードやLispバッファーを評価するとき、バッファーローカルな変数@code{lexical-binding}が非@code{nil}なら、レキシカルバインディングが有効になります:"

#. type: defvar
#: original_texis/variables.texi:1049
#, no-wrap
msgid "lexical-binding"
msgstr "lexical-binding"

#. type: defvar
#: original_texis/variables.texi:1058
msgid "If this buffer-local variable is non-@code{nil}, Emacs Lisp files and buffers are evaluated using lexical binding instead of dynamic binding.  (However, special variables are still dynamically bound; see below.)  If @code{nil}, dynamic binding is used for all local variables.  This variable is typically set for a whole Emacs Lisp file, as a file local variable (@pxref{File Local Variables}).  Note that unlike other such variables, this one must be set in the first line of a file."
msgstr "このバッファーローカルな変数が非@code{nil}なら、Emacs Lispファイルとバッファーはダイナミックバインディングではなくレキシカルバインディングを使用して評価される(しかし特別な変数はダイナミックにバインドされたまま。以下を照)。@code{nil}ならすべてのローカル変数にたいしてダイナミックバインディングが使用される。この変数は、通常はファイルローカル変数として、Emacs Lispファイル全体にたいしてセットされる(@ref{File Local Variables}を参照)。他のファイルローカル変数などとは異なり、ファイルの最初の行でセットされなければならないことに注意。"

#. type: Plain text
#: original_texis/variables.texi:1064
msgid "When evaluating Emacs Lisp code directly using an @code{eval} call, lexical binding is enabled if the @var{lexical} argument to @code{eval} is non-@code{nil}.  @xref{Eval}."
msgstr "@code{eval}呼び出しを使用してEmacs Lispコードを直接評価するとき、@code{eval}の@var{lexical}引数が非@code{nil}なら、レキシカルバインディングが有効になります。@ref{Eval}を参照してください。"

#. type: cindex
#: original_texis/variables.texi:1065
#, no-wrap
msgid "special variables"
msgstr "special variables"

#. type: Plain text
#: original_texis/variables.texi:1072
msgid "Even when lexical binding is enabled, certain variables will continue to be dynamically bound.  These are called @dfn{special variables}.  Every variable that has been defined with @code{defvar}, @code{defcustom} or @code{defconst} is a special variable (@pxref{Defining Variables}).  All other variables are subject to lexical binding."
msgstr "レキシカルバインディングが有効な場合でも、特定の変数はダイナミックにバインドされたままです。これらは@dfn{スペシャル変数(special variable)}と呼ばれます。@code{defvar}、@code{defcustom}、@code{defconst}で定義されたすべての変数はスペシャル変数です(@ref{Defining Variables}を参照)。その他のすべての変数はレキシカルバインディングの対象になります。"

#. type: defun
#: original_texis/variables.texi:1073
#, no-wrap
msgid "special-variable-p symbol"
msgstr "special-variable-p symbol"

#. type: defun
#: original_texis/variables.texi:1078
msgid "This function returns non-@code{nil} if @var{symbol} is a special variable (i.e., it has a @code{defvar}, @code{defcustom}, or @code{defconst} variable definition).  Otherwise, the return value is @code{nil}."
msgstr "この関数は@var{symbol}がスペシャル変数(つまり変数が@code{defvar}、@code{defcustom}、@code{defconst}による定義をもつ)なら非@code{nil}をリターンする。、それ以外ならリターン値は@code{nil}。"

#. type: Plain text
#: original_texis/variables.texi:1084
msgid "The use of a special variable as a formal argument in a function is discouraged.  Doing so gives rise to unspecified behavior when lexical binding mode is enabled (it may use lexical binding sometimes, and dynamic binding other times)."
msgstr "関数内での通常の引数としてのスペシャル変数の使用は、推奨されません。レキシカルバインディングモードが有効なときにこれを行うと、(あるときはレキシカルバインディング、またあるときはダイナミックバインディングのような)不定な動作が起こります。"

#. type: Plain text
#: original_texis/variables.texi:1091
msgid "Converting an Emacs Lisp program to lexical binding is easy.  First, add a file-local variable setting of @code{lexical-binding} to @code{t} in the header line of the Emacs Lisp source file (@pxref{File Local Variables}).  Second, check that every variable in the program which needs to be dynamically bound has a variable definition, so that it is not inadvertently bound lexically."
msgstr "Emacs Lispプログラムをレキシカルバインディングに変換するのは簡単です。最初にEmacs Lispソースファイルのヘッダー行で@code{lexical-binding}を@code{t}にして、ファイルローカル変数を追加します(@ref{File Local Variables}を参照)。次に意図せずレキシカルにバインドしてしまわないように、ダイナミックなバインドをもつ必要がある変数が変数定義をもつことを各変数ごとにチェックします。"

#. type: cindex
#: original_texis/variables.texi:1092
#, no-wrap
msgid "free variable"
msgstr "free variable"

#. type: cindex
#: original_texis/variables.texi:1093
#, no-wrap
msgid "unused lexical variable"
msgstr "unused lexical variable"

#. type: Plain text
#: original_texis/variables.texi:1102
msgid "A simple way to find out which variables need a variable definition is to byte-compile the source file.  @xref{Byte Compilation}.  If a non-special variable is used outside of a @code{let} form, the byte-compiler will warn about reference or assignment to a ``free variable''.  If a non-special variable is bound but not used within a @code{let} form, the byte-compiler will warn about an ``unused lexical variable''.  The byte-compiler will also issue a warning if you use a special variable as a function argument."
msgstr "どの変数が変数定義をもつ必要があるか見つけるシンプルな方法は、ソースファイルをバイトコンパイルすることです。@ref{Byte Compilation}を参照してください。@code{let}フォームの外で非スペシャル変数が使用されている場合、バイトコンパイラーは``free variable''にたいする参照または割り当てについて警告するでしょう。非スペシャル変数がバインドされているが、@code{let}フォーム内で使用されていない場合、バイトコンパイラーは``unused lexical variable''に関して警告するでしょう。バイトコンパイラーは、スペシャル変数を関数の引数として使用している場合も、問題を警告します。"

#. type: Plain text
#: original_texis/variables.texi:1107
msgid "(To silence byte-compiler warnings about unused variables, just use a variable name that start with an underscore.  The byte-compiler interprets this as an indication that this is a variable known not to be used.)"
msgstr "(使用されていない変数についての警告を抑制するためには、単に変数名をアンダースコアーで開始すればよい。そうすればバイトコンパイラーはその変数が使用されないことを示すと解釈する。)"

#. type: cindex
#: original_texis/variables.texi:1110
#, no-wrap
msgid "variable, buffer-local"
msgstr "variable, buffer-local"

#. type: cindex
#: original_texis/variables.texi:1111
#, no-wrap
msgid "buffer-local variables"
msgstr "buffer-local variables"

#. type: Plain text
#: original_texis/variables.texi:1120
msgid "Global and local variable bindings are found in most programming languages in one form or another.  Emacs, however, also supports additional, unusual kinds of variable binding, such as @dfn{buffer-local} bindings, which apply only in one buffer.  Having different values for a variable in different buffers is an important customization method.  (Variables can also have bindings that are local to each terminal.  @xref{Multiple Terminals}.)"
msgstr "グローバルおよびローカルな変数バインディングは、いずれかの形式をほとんどのプログラミング言語で見つけることができます。しかしEmacsは1つのバッファーだけに適用される@dfn{バッファーローカル(buffer-local)}なバインディング用に、普通には存在しない類の変数バインディングもサポートしています。ある変数にたいして異なるバッファーごとに別の値をもつのは、カスタマイズでの重要な手法です(変数は端末ごとにローカルなバインディングをもつこともできる。@ref{Multiple Terminals}を参照)。"

#. type: node
#: original_texis/variables.texi:1126 original_texis/variables.texi:1128
#, no-wrap
msgid "Intro to Buffer-Local"
msgstr "Intro to Buffer-Local"

#. type: menuentry
#: original_texis/variables.texi:1126
msgid "Introduction and concepts."
msgstr "イントロダクションと概念。"

#. type: node
#: original_texis/variables.texi:1126 original_texis/variables.texi:1222
#, no-wrap
msgid "Creating Buffer-Local"
msgstr "Creating Buffer-Local"

#. type: menuentry
#: original_texis/variables.texi:1126
msgid "Creating and destroying buffer-local bindings."
msgstr "バッファーローカルなバインディングの作成と削除。"

#. type: node
#: original_texis/variables.texi:1126 original_texis/variables.texi:1451
#, no-wrap
msgid "Default Value"
msgstr "Default Value"

#. type: menuentry
#: original_texis/variables.texi:1126
msgid "The default value is seen in buffers that don't have their own buffer-local values."
msgstr "自身ではバッファーローカルな値をもたないバッファーで参照されるデフォルト値。"

#. type: subsection
#: original_texis/variables.texi:1129
#, no-wrap
msgid "Introduction to Buffer-Local Variables"
msgstr "Introduction to Buffer-Local Variables"

#. type: Plain text
#: original_texis/variables.texi:1137
msgid "A buffer-local variable has a buffer-local binding associated with a particular buffer.  The binding is in effect when that buffer is current; otherwise, it is not in effect.  If you set the variable while a buffer-local binding is in effect, the new value goes in that binding, so its other bindings are unchanged.  This means that the change is visible only in the buffer where you made it."
msgstr "バッファーローカル変数は特定のバッファーに関連づけられた、バッファーローカルなバインディングをもちます。このバインディングはそのバッファーがカレントのときに効果をもち、カレントでないときには効果がありません。バッファーローカルなバインディングが効力をもつときにその変数をセットすると、そのバインディングは新しい値をもちますが他のバインディングは変更されません。これはバッファーローカルなバインディングを作成したバッファーだけで変更が見えることを意味します。"

#. type: Plain text
#: original_texis/variables.texi:1141
msgid "The variable's ordinary binding, which is not associated with any specific buffer, is called the @dfn{default binding}.  In most cases, this is the global binding."
msgstr "その変数にたいする特定のバッファーに関連しない通常のバインディングは、@dfn{デフォルトバインディング(default binding)}と呼ばれます。これはほとんどの場合はグローバルバインディングです。"

#. type: Plain text
#: original_texis/variables.texi:1149
msgid "A variable can have buffer-local bindings in some buffers but not in other buffers.  The default binding is shared by all the buffers that don't have their own bindings for the variable.  (This includes all newly-created buffers.)  If you set the variable in a buffer that does not have a buffer-local binding for it, this sets the default binding, so the new value is visible in all the buffers that see the default binding."
msgstr "変数はあるバッファーではバッファーローカルなバインディングをもつことができ、他のバッファーではもたないことができます。デフォルトバインディングは、その変数にたいして自身のバインディングをもたないすべてのバッファーで共有されます(これには新たに作成されたバッファーが含まれる)。ある変数にたいして、その変数のバッファーローカルなバインディングをもたないバッファーでその変数をセットすると、それによりデフォルトバインディングがセットされるので、デフォルトバインディングを参照するすべてのバッファーで新しい値を見ることになります。"

#. type: Plain text
#: original_texis/variables.texi:1156
msgid "The most common use of buffer-local bindings is for major modes to change variables that control the behavior of commands.  For example, C mode and Lisp mode both set the variable @code{paragraph-start} to specify that only blank lines separate paragraphs.  They do this by making the variable buffer-local in the buffer that is being put into C mode or Lisp mode, and then setting it to the new value for that mode.  @xref{Major Modes}."
msgstr "バッファーローカルなバインディングのもっとも一般的な使用は、メジャーモードがコマンドの動作を制御するために変数を変更する場合です。たとえばCモードやLispモードは、空行だけがパラグラフの区切りになるように変数@code{paragraph-start}をセットします。これらのモードは、CモードやLispモードになるようなバッファー内でこの変数をバッファーローカルにすることでこれを行って、その後そのモードにたいする新しい値をセットします。@ref{Major Modes}を参照してください。"

#. type: Plain text
#: original_texis/variables.texi:1162
msgid "The usual way to make a buffer-local binding is with @code{make-local-variable}, which is what major mode commands typically use.  This affects just the current buffer; all other buffers (including those yet to be created) will continue to share the default value unless they are explicitly given their own buffer-local bindings."
msgstr "バッファーローカルなバインディングを作成する通常の方法は、@code{make-local-variable}による方法で、これは通常はメジャーモードが使用します。これはカレントバッファーだけに効果があります。その他すべてのバッファー(まだ作成されていないバッファーを含む)は、それらのバッファー自身が明示的にバッファーローカルなバインディングを与えるまでデフォルト値を共有し続けます。"

#. type: cindex
#: original_texis/variables.texi:1163
#, no-wrap
msgid "automatically buffer-local"
msgstr "automatically buffer-local"

#. type: Plain text
#: original_texis/variables.texi:1176
msgid "A more powerful operation is to mark the variable as @dfn{automatically buffer-local} by calling @code{make-variable-buffer-local}.  You can think of this as making the variable local in all buffers, even those yet to be created.  More precisely, the effect is that setting the variable automatically makes the variable local to the current buffer if it is not already so.  All buffers start out by sharing the default value of the variable as usual, but setting the variable creates a buffer-local binding for the current buffer.  The new value is stored in the buffer-local binding, leaving the default binding untouched.  This means that the default value cannot be changed with @code{setq} in any buffer; the only way to change it is with @code{setq-default}."
msgstr "変数を@dfn{自動的にバッファーローカルになる}ようにマークする、より強力な操作は@code{make-variable-buffer-local}を呼び出すことにより行われます。これはたとえその変数がまだ作成されていなくても、変数をすべてのバッファーにたいしてローカルにすると考えることができます。より正確には変数を自動的にセットすることにより、その変数がカレントバッファーにたいしてローカルでなくても、変数をローカルにする効果があります。すべてのバッファーは最初は通常のようにデフォルト値を共有しますが、変数をセットすることでカレントバッファーにたいしてバッファーローカルなバインディングを作成します。新たな値はバッファーローカルなバインディングに格納され、デフォルトバインディングは変更されずに残ります。これは任意のバッファーで@code{setq}によりデフォルト値を変更できないことを意味します。変更する唯一の方法は@code{setq-default}だけです。"

#. type: Plain text
#: original_texis/variables.texi:1188
msgid "@strong{Warning:} When a variable has buffer-local bindings in one or more buffers, @code{let} rebinds the binding that's currently in effect.  For instance, if the current buffer has a buffer-local value, @code{let} temporarily rebinds that.  If no buffer-local bindings are in effect, @code{let} rebinds the default value.  If inside the @code{let} you then change to a different current buffer in which a different binding is in effect, you won't see the @code{let} binding any more.  And if you exit the @code{let} while still in the other buffer, you won't see the unbinding occur (though it will occur properly).  Here is an example to illustrate:"
msgstr "@strong{警告:} ある変数が1つ以上のバッファーでバッファーローカルなバインディングをもつ際に、@code{let}はそのとき効力がある変数のバインディングをリバインドします。たとえばカレントバッファーがバッファーローカルな値をもつなら、@code{let}は一時的にそれをリバインドします。効力があるバッファーローカルなバインディングが存在しなければ@code{let}はデフォルト値をリバインドします。@code{let}の内部で、別のバインディングが効力をもつ別のバッファーをカレントバッファーにすると、それ以上@code{let}バインディングを参照できなくなります。他のバッファーにいる間に@code{let}を抜けると、(たとえそれが正しくても)バインディングの解消を見ることはできません。以下にこれを示します:"

#. type: group
#: original_texis/variables.texi:1194
#, no-wrap
msgid ""
"(setq foo 'g)\n"
"(set-buffer \"a\")\n"
"(make-local-variable 'foo)\n"
msgstr ""
"(setq foo 'g)\n"
"(set-buffer \"a\")\n"
"(make-local-variable 'foo)\n"

#. type: example
#: original_texis/variables.texi:1201
#, no-wrap
msgid ""
"(setq foo 'a)\n"
"(let ((foo 'temp))\n"
"  ;; foo @result{} 'temp  ; @r{let binding in buffer @samp{a}}\n"
"  (set-buffer \"b\")\n"
"  ;; foo @result{} 'g     ; @r{the global value since foo is not local in @samp{b}}\n"
"  @var{body}@dots{})\n"
msgstr ""
"(setq foo 'a)\n"
"(let ((foo 'temp))\n"
"  ;; foo @result{} 'temp  ; @r{バッファー@samp{a}内でのletバインディング}\n"
"  (set-buffer \"b\")\n"
"  ;; foo @result{} 'g     ; @r{fooは@samp{b}にたいしてローカルではないためグローバル値}\n"
"  @var{body}@dots{})\n"

#. type: group
#: original_texis/variables.texi:1204
#, no-wrap
msgid ""
"foo @result{} 'g        ; @r{exiting restored the local value in buffer @samp{a},}\n"
"                 ; @r{but we don't see that in buffer @samp{b}}\n"
msgstr ""
"foo @result{} 'g        ; @r{exitによりバッファー@samp{a}のローカル値が復元されるが}\n"
"                 ; @r{バッファー@samp{b}では見ることができない}\n"

#. type: group
#: original_texis/variables.texi:1208
#, no-wrap
msgid ""
"(set-buffer \"a\") ; @r{verify the local value was restored}\n"
"foo @result{} 'a\n"
msgstr ""
"(set-buffer \"a\") ; @r{ローカル値が復元されたことを確認}\n"
"foo @result{} 'a\n"

#. type: Plain text
#: original_texis/variables.texi:1214
msgid "Note that references to @code{foo} in @var{body} access the buffer-local binding of buffer @samp{b}."
msgstr "@var{body}内の@code{foo}にたいする参照は、バッファー@samp{b}のバッファーローカルなバインディングにアクセスすることに注意してください。"

#. type: Plain text
#: original_texis/variables.texi:1218
msgid "When a file specifies local variable values, these become buffer-local values when you visit the file.  @xref{File Variables,,, emacs, The GNU Emacs Manual}."
msgstr "あるファイルがローカル変数の値をセットする場合、これらの変数はファイルをvisitするときバッファーローカルな値になります。@ref{File Variables,,, emacs, The GNU Emacs Manual}を参照してください。"

#. type: Plain text
#: original_texis/variables.texi:1221
msgid "A buffer-local variable cannot be made terminal-local (@pxref{Multiple Terminals})."
msgstr "バッファーローカル変数を端末ローカル(terminal-local)にすることはできません(@ref{Multiple Terminals}を参照)。"

#. type: subsection
#: original_texis/variables.texi:1223
#, no-wrap
msgid "Creating and Deleting Buffer-Local Bindings"
msgstr "Creating and Deleting Buffer-Local Bindings"

#. type: deffn
#: original_texis/variables.texi:1225
#, no-wrap
msgid "Command make-local-variable variable"
msgstr "Command make-local-variable variable"

#. type: deffn
#: original_texis/variables.texi:1229
msgid "This function creates a buffer-local binding in the current buffer for @var{variable} (a symbol).  Other buffers are not affected.  The value returned is @var{variable}."
msgstr "この関数はカレントバッファー内で、@var{variable}(シンボル)にたいするバッファーローカルなバインディングを作成する。他のバッファーは影響を受けない。リターンされる値は@var{variable}。"

#. type: deffn
#: original_texis/variables.texi:1233
msgid "The buffer-local value of @var{variable} starts out as the same value @var{variable} previously had.  If @var{variable} was void, it remains void."
msgstr "@var{variable}のバッファーローカルな値は、最初は以前に@var{variable}がもっていた値と同じ値をもつ。@var{variable}がvoidのときはvoidのまま。"

#. type: group
#: original_texis/variables.texi:1239
#, no-wrap
msgid ""
";; @r{In buffer @samp{b1}:}\n"
"(setq foo 5)                ; @r{Affects all buffers.}\n"
"     @result{} 5\n"
msgstr ""
";; @r{バッファー@samp{b1}で行う:}\n"
"(setq foo 5)                ; @r{すべてのバッファーに影響する。}\n"
"     @result{} 5\n"

#. type: group
#: original_texis/variables.texi:1243
#, no-wrap
msgid ""
"(make-local-variable 'foo)  ; @r{Now it is local in @samp{b1}.}\n"
"     @result{} foo\n"
msgstr ""
"(make-local-variable 'foo)  ; @r{@samp{b1}内でローカルになった}\n"
"     @result{} foo\n"

#. type: group
#: original_texis/variables.texi:1247
#, no-wrap
msgid ""
"foo                         ; @r{That did not change}\n"
"     @result{} 5                   ;   @r{the value.}\n"
msgstr ""
"foo                         ; @r{値は変更されない}\n"
"     @result{} 5\n"

#. type: group
#: original_texis/variables.texi:1251
#, no-wrap
msgid ""
"(setq foo 6)                ; @r{Change the value}\n"
"     @result{} 6                   ;   @r{in @samp{b1}.}\n"
msgstr ""
"(setq foo 6)                ; @r{@samp{b1}内で値を変更}\n"
"     @result{} 6\n"

#. type: group
#: original_texis/variables.texi:1255
#, no-wrap
msgid ""
"foo\n"
"     @result{} 6\n"
msgstr ""
"foo\n"
"     @result{} 6\n"

#. type: group
#: original_texis/variables.texi:1262
#, no-wrap
msgid ""
";; @r{In buffer @samp{b2}, the value hasn't changed.}\n"
"(with-current-buffer \"b2\"\n"
"  foo)\n"
"     @result{} 5\n"
msgstr ""
";; @r{バッファー@samp{b2}では、値は変更されていない}\n"
"(with-current-buffer \"b2\"\n"
"  foo)\n"
"     @result{} 5\n"

#. type: deffn
#: original_texis/variables.texi:1270
msgid "Making a variable buffer-local within a @code{let}-binding for that variable does not work reliably, unless the buffer in which you do this is not current either on entry to or exit from the @code{let}.  This is because @code{let} does not distinguish between different kinds of bindings; it knows only which variable the binding was made for."
msgstr "変数を@code{let}バインディングでバッファーローカルにしても、@code{let}への出入り時の両方でこれを行うバッファーがカレントでなければ信頼性はない。これは@code{let}がバインディングの種類を区別しないからである。@code{let}に解るのはバインディングが作成される変数だけである。"

#. type: deffn
#: original_texis/variables.texi:1274
msgid "If the variable is terminal-local (@pxref{Multiple Terminals}), this function signals an error.  Such variables cannot have buffer-local bindings as well."
msgstr "変数が端末ローカル(@ref{Multiple Terminals}を参照)なら、この関数はエラーをシグナルする。そのような変数はバッファーローカルなバインディングをもつことができない。"

#. type: deffn
#: original_texis/variables.texi:1279
msgid "@strong{Warning:} do not use @code{make-local-variable} for a hook variable.  The hook variables are automatically made buffer-local as needed if you use the @var{local} argument to @code{add-hook} or @code{remove-hook}."
msgstr "@strong{警告:} フック変数にたいして@code{make-local-variable}を使用しないこと。フック変数は@code{add-hook}か@code{remove-hook}の@var{local}引数を使用すると、必要に応じて自動でバッファーローカルになる。"

#. type: defmac
#: original_texis/variables.texi:1281
#, no-wrap
msgid "setq-local variable value"
msgstr "setq-local variable value"

#. type: defmac
#: original_texis/variables.texi:1286
msgid "This macro creates a buffer-local binding in the current buffer for @var{variable}, and gives it the buffer-local value @var{value}.  It is equivalent to calling @code{make-local-variable} followed by @code{setq}.  @var{variable} should be an unquoted symbol."
msgstr "このマクロはカレントバッファー内で@var{variable}にたいするバッファーローカルなバインディングを作成して、それにバッファーローカルな値@var{value}を与える。このマクロは@code{make-local-variable}に続けて@code{setq}を呼び出すのと同じ。@var{variable}はクォートされていないシンボル。"

#. type: deffn
#: original_texis/variables.texi:1288
#, no-wrap
msgid "Command make-variable-buffer-local variable"
msgstr "Command make-variable-buffer-local variable"

#. type: deffn
#: original_texis/variables.texi:1295
msgid "This function marks @var{variable} (a symbol) automatically buffer-local, so that any subsequent attempt to set it will make it local to the current buffer at the time.  Unlike @code{make-local-variable}, with which it is often confused, this cannot be undone, and affects the behavior of the variable in all buffers."
msgstr "このコマンドは@var{variable}(シンボル)が自動的にバッファーローカルになるようにマークするので、それ以降にその変数へのセットを試みると、その時点でカレントのバッファーにローカルになる。しばしば混乱を招く@code{make-local-variable}とは異なり、これが取り消されることはなく、すべてのバッファー内での変数の挙動に影響する。"

#. type: deffn
#: original_texis/variables.texi:1301
msgid "A peculiar wrinkle of this feature is that binding the variable (with @code{let} or other binding constructs) does not create a buffer-local binding for it.  Only setting the variable (with @code{set} or @code{setq}), while the variable does not have a @code{let}-style binding that was made in the current buffer, does so."
msgstr "この機能特有の欠点は、(@code{let}やその他のバインディング構文による)変数のバインディングが、その変数にたいするバッファーローカルなバインディングを作成しないことである。(@code{set}や@code{setq}による)変数のセットだけは、その変数がカレントバッファーで作成された@code{let}スタイルのバインディングをもたないので、ローカルなバインディングを作成する。"

#. type: deffn
#: original_texis/variables.texi:1307
msgid "If @var{variable} does not have a default value, then calling this command will give it a default value of @code{nil}.  If @var{variable} already has a default value, that value remains unchanged.  Subsequently calling @code{makunbound} on @var{variable} will result in a void buffer-local value and leave the default value unaffected."
msgstr "@var{variable}がデフォルト値をもたない場合、このコマンドの呼び出しは@code{nil}のデフォルト値を与える。@var{variable}がすでにデフォルト値をもつなら、その値は変更されずに残る。それ以降に@var{variable}にたいして@code{makunbound}を呼び出すと、バッファーローカル値をvoidにして、デフォルト値は影響を受けずに残る。"

#. type: deffn
#: original_texis/variables.texi:1309
msgid "The value returned is @var{variable}."
msgstr "▼リターン値は@var{variable}。"

#. type: deffn
#: original_texis/variables.texi:1315
msgid "@strong{Warning:} Don't assume that you should use @code{make-variable-buffer-local} for user-option variables, simply because users @emph{might} want to customize them differently in different buffers.  Users can make any variable local, when they wish to.  It is better to leave the choice to them."
msgstr "@strong{警告:} ユーザーオプション変数では、ユーザーは異なるバッファーにたいして異なるカスタマイズを望む@emph{かもしれない}ので、@code{make-variable-buffer-local}を使うべきだと決め込むべきではない。ユーザーは望むなら任意の変数をローカルにできる。その選択の余地を残すほうがよい。"

#. type: deffn
#: original_texis/variables.texi:1321
msgid "The time to use @code{make-variable-buffer-local} is when it is crucial that no two buffers ever share the same binding.  For example, when a variable is used for internal purposes in a Lisp program which depends on having separate values in separate buffers, then using @code{make-variable-buffer-local} can be the best solution."
msgstr "@code{make-variable-buffer-local}を使用すべきなのは、複数のバッファーが同じバインディングを共有しないことが自明な場合である。たとえばバッファーごとに個別な値をもつことに依存するLispプログラム内の内部プロセスにたいして変数が使用されるときは、@code{make-variable-buffer-local}の使用が最善の解決策になるかもしれない。"

#. type: defmac
#: original_texis/variables.texi:1323
#, no-wrap
msgid "defvar-local variable value &optional docstring"
msgstr "defvar-local variable value &optional docstring"

#. type: defmac
#: original_texis/variables.texi:1329
msgid "This macro defines @var{variable} as a variable with initial value @var{value} and @var{docstring}, and marks it as automatically buffer-local.  It is equivalent to calling @code{defvar} followed by @code{make-variable-buffer-local}.  @var{variable} should be an unquoted symbol."
msgstr "このマクロは@var{variable}を初期値@var{value}と@var{docstring}の変数として定義して、それを自動的にバッファーローカルとマークする。これは@code{defvar}の後につづけて@code{make-variable-buffer-local}を呼び出すのと同じ。@var{variable}はクォートされていないシンボル。"

#. type: defun
#: original_texis/variables.texi:1331
#, no-wrap
msgid "local-variable-p variable &optional buffer"
msgstr "local-variable-p variable &optional buffer"

#. type: defun
#: original_texis/variables.texi:1335
msgid "This returns @code{t} if @var{variable} is buffer-local in buffer @var{buffer} (which defaults to the current buffer); otherwise, @code{nil}."
msgstr "これは@var{variable}がバッファー@var{buffer}(デフォルトはカレントバッファー)内でバッファーローカルなら@code{t}、それ以外は@code{nil}をリターンする。"

#. type: defun
#: original_texis/variables.texi:1337
#, no-wrap
msgid "local-variable-if-set-p variable &optional buffer"
msgstr "local-variable-if-set-p variable &optional buffer"

#. type: defun
#: original_texis/variables.texi:1342
msgid "This returns @code{t} if @var{variable} either has a buffer-local value in buffer @var{buffer}, or is automatically buffer-local.  Otherwise, it returns @code{nil}.  If omitted or @code{nil}, @var{buffer} defaults to the current buffer."
msgstr "これは@var{variable}がバッファー@var{buffer}内でバッファーローカル値をもつ、または自動的にバッファーローカルになるなら@code{t}、それ以外は@code{nil}をリターンする。@var{buffer}が省略または@code{nil}の場合のデフォルトはカレントバッファー。"

#. type: defun
#: original_texis/variables.texi:1344
#, no-wrap
msgid "buffer-local-value variable buffer"
msgstr "buffer-local-value variable buffer"

#. type: defun
#: original_texis/variables.texi:1349
msgid "This function returns the buffer-local binding of @var{variable} (a symbol) in buffer @var{buffer}.  If @var{variable} does not have a buffer-local binding in buffer @var{buffer}, it returns the default value (@pxref{Default Value}) of @var{variable} instead."
msgstr "この関数はバッファー@var{buffer}内の、@var{variable}(シンボル)のバッファーローカルなバインディングをリターンする。@var{variable}がバッファー@var{buffer}内でバッファーローカルなバインディングをもたなければ、かわりに@var{variable}のデフォルト値(@ref{Default Value}を参照)をリターンする。"

#. type: defun
#: original_texis/variables.texi:1351
#, no-wrap
msgid "buffer-local-variables &optional buffer"
msgstr "buffer-local-variables &optional buffer"

#. type: defun
#: original_texis/variables.texi:1359
msgid "This function returns a list describing the buffer-local variables in buffer @var{buffer}.  (If @var{buffer} is omitted, the current buffer is used.)  Normally, each list element has the form @w{@code{(@var{sym} . @var{val})}}, where @var{sym} is a buffer-local variable (a symbol) and @var{val} is its buffer-local value.  But when a variable's buffer-local binding in @var{buffer} is void, its list element is just @var{sym}."
msgstr "この関数はバッファー@var{buffer}内のバッファーローカル変数を表すリストをリターンする(@var{buffer}が省略された場合はカレントバッファーが使用される)。リストの各要素は通常は@w{@code{(@var{sym} . @var{val})}}という形式をもつ。ここで@var{sym}はバッファーローカル変数(シンボル)、@var{val}はバッファーローカル値。しかし@var{buffer}内のある変数のバッファーローカルなバインディングがvoidなら、その変数に対応するリスト要素は単に@var{sym}となる。"

#. type: group
#: original_texis/variables.texi:1366
#, no-wrap
msgid ""
"(make-local-variable 'foobar)\n"
"(makunbound 'foobar)\n"
"(make-local-variable 'bind-me)\n"
"(setq bind-me 69)\n"
msgstr ""
"(make-local-variable 'foobar)\n"
"(makunbound 'foobar)\n"
"(make-local-variable 'bind-me)\n"
"(setq bind-me 69)\n"

#. type: example
#: original_texis/variables.texi:1373
#, no-wrap
msgid ""
"(setq lcl (buffer-local-variables))\n"
"    ;; @r{First, built-in variables local in all buffers:}\n"
"@result{} ((mark-active . nil)\n"
"    (buffer-undo-list . nil)\n"
"    (mode-name . \"Fundamental\")\n"
"    @dots{}\n"
msgstr ""
"(setq lcl (buffer-local-variables))\n"
"    ;; @r{最初はすべてのバッファー内でローカルなビルトイン変数:}\n"
"@result{} ((mark-active . nil)\n"
"    (buffer-undo-list . nil)\n"
"    (mode-name . \"Fundamental\")\n"
"    @dots{}\n"

#. type: group
#: original_texis/variables.texi:1379
#, no-wrap
msgid ""
"    ;; @r{Next, non-built-in buffer-local variables.}\n"
"    ;; @r{This one is buffer-local and void:}\n"
"    foobar\n"
"    ;; @r{This one is buffer-local and nonvoid:}\n"
"    (bind-me . 69))\n"
msgstr ""
"    ;; @r{次にビルトインでないバッファーローカル変数}\n"
"    ;; @r{This one is buffer-local and void:}\n"
"    foobar\n"
"    ;; @r{これはバッファーローカルでvoidではない:}\n"
"    (bind-me . 69))\n"

#. type: defun
#: original_texis/variables.texi:1384
msgid "Note that storing new values into the @sc{cdr}s of cons cells in this list does @emph{not} change the buffer-local values of the variables."
msgstr "このリスト内のコンスセルの@sc{cdr}に新たな値を格納しても、その変数のバッファーローカル値は@emph{変化しない}ことに注意。"

#. type: deffn
#: original_texis/variables.texi:1386
#, no-wrap
msgid "Command kill-local-variable variable"
msgstr "Command kill-local-variable variable"

#. type: deffn
#: original_texis/variables.texi:1393
msgid "This function deletes the buffer-local binding (if any) for @var{variable} (a symbol) in the current buffer.  As a result, the default binding of @var{variable} becomes visible in this buffer.  This typically results in a change in the value of @var{variable}, since the default value is usually different from the buffer-local value just eliminated."
msgstr "この関数はカレントバッファー内の@var{variable}(シンボル)にたいするバッファーローカルなバインディング(もしあれば)を削除する。その結果として、このバッファー内で@var{variable}のデフォルトバインディングが可視になる。これは通常は@var{variable}の値を変更する。デフォルト値は削除されたバッファーローカル値とは異なるのが普通だからである。"

#. type: deffn
#: original_texis/variables.texi:1398
msgid "If you kill the buffer-local binding of a variable that automatically becomes buffer-local when set, this makes the default value visible in the current buffer.  However, if you set the variable again, that will once again create a buffer-local binding for it."
msgstr "セットしたとき自動的にバッファーローカルになる変数のバッファーローカルなバインディングをkillすると、これによりカレントバッファー内でデフォルト値が可視になる。しかし変数を再度セットすると、その変数にたいするバッファーローカルなバインディングが再作成される。"

#. type: deffn
#: original_texis/variables.texi:1400
msgid "@code{kill-local-variable} returns @var{variable}."
msgstr "@code{kill-local-variable}は@var{variable}をreturnします。"

#. type: deffn
#: original_texis/variables.texi:1404
msgid "This function is a command because it is sometimes useful to kill one buffer-local variable interactively, just as it is useful to create buffer-local variables interactively."
msgstr "この関数はコマンドである。なぜならバッファーローカル変数のインタラクティブな作成が有用な場合があるように、あるバッファーローカル変数のインタラクティブなkillが有用な場合があるからである。"

#. type: cindex
#: original_texis/variables.texi:1406
#, no-wrap
msgid "local variables, killed by major mode"
msgstr "local variables, killed by major mode"

#. type: defun
#: original_texis/variables.texi:1407
#, no-wrap
msgid "kill-all-local-variables"
msgstr "kill-all-local-variables"

#. type: defun
#: original_texis/variables.texi:1413
msgid "This function eliminates all the buffer-local variable bindings of the current buffer except for variables marked as ``permanent'' and local hook functions that have a non-@code{nil} @code{permanent-local-hook} property (@pxref{Setting Hooks}).  As a result, the buffer will see the default values of most variables."
msgstr "この関数は、``permanent(永続的)''とマークされた変数、および@code{permanent-local-hook}プロパティーに非@code{nil}をもつローカルフック関数(@ref{Setting Hooks})を除き、カレントバッファーのすべてのバッファーローカルなバインディングを解消します。結果として、そのバッファーはほとんどの変数のデフォルト値を参照するようになります。"

#. type: defun
#: original_texis/variables.texi:1419
msgid "This function also resets certain other information pertaining to the buffer: it sets the local keymap to @code{nil}, the syntax table to the value of @code{(standard-syntax-table)}, the case table to @code{(standard-case-table)}, and the abbrev table to the value of @code{fundamental-mode-abbrev-table}."
msgstr "この関数はそのバッファーに関連する他の特定の情報もリセットする。これはローカルキーマップを@code{nil}、構文テーブルを@code{(standard-syntax-table)}の値、caseテーブルを@code{(standard-case-table)}、abbrevテーブルを@code{fundamental-mode-abbrev-table}の値にセットする。"

#. type: defun
#: original_texis/variables.texi:1422
msgid "The very first thing this function does is run the normal hook @code{change-major-mode-hook} (see below)."
msgstr "この関数が1番最初に行うのはノーマルフック@code{change-major-mode-hook}(以下参照)の実行である。"

#. type: defun
#: original_texis/variables.texi:1427
msgid "Every major mode command begins by calling this function, which has the effect of switching to Fundamental mode and erasing most of the effects of the previous major mode.  To ensure that this does its job, the variables that major modes set should not be marked permanent."
msgstr "すべてのメジャーモードコマンドは、Fundamentalモードにスイッチする効果をもち、以前のメジャーモードのほとんどの効果を消去する、この関数を呼び出すことによって開始されます。この関数が処理を行うのを確実にするために、メジャーモードがセットする変数はpermanentとマークすべきではない。"

#. type: defun
#: original_texis/variables.texi:1429
msgid "@code{kill-all-local-variables} returns @code{nil}."
msgstr "@code{kill-all-local-variables} returns @code{nil}."

#. type: defvar
#: original_texis/variables.texi:1431
#, no-wrap
msgid "change-major-mode-hook"
msgstr "change-major-mode-hook"

#. type: defvar
#: original_texis/variables.texi:1437
msgid "The function @code{kill-all-local-variables} runs this normal hook before it does anything else.  This gives major modes a way to arrange for something special to be done if the user switches to a different major mode.  It is also useful for buffer-specific minor modes that should be forgotten if the user changes the major mode."
msgstr "関数@code{kill-all-local-variables}は、何か他のことを行う前にまずこのノーマルフックを実行する。この関数はメジャーモードにたいして、ユーザーが他のメジャーモードにスイッチした場合に行われる何か特別なことを準備する方法を与える。この関数はユーザーがメジャーモードを変更した場合に忘れられるべき、バッファー固有のマイナーモードにたいしても有用。"

#. type: defvar
#: original_texis/variables.texi:1441
msgid "For best results, make this variable buffer-local, so that it will disappear after doing its job and will not interfere with the subsequent major mode.  @xref{Hooks}."
msgstr "最善の結果を得るために、この変数をバッファーローカルにすれば、処理が終了したときに消えるので、以降のメジャーモードに干渉しなくなる。@ref{Hooks}を参照のこと。"

#. type: cindex
#: original_texis/variables.texi:1443
#, no-wrap
msgid "permanent local variable"
msgstr "permanent local variable"

#. type: Plain text
#: original_texis/variables.texi:1450
msgid "A buffer-local variable is @dfn{permanent} if the variable name (a symbol) has a @code{permanent-local} property that is non-@code{nil}.  Such variables are unaffected by @code{kill-all-local-variables}, and their local bindings are therefore not cleared by changing major modes.  Permanent locals are appropriate for data pertaining to where the file came from or how to save it, rather than with how to edit the contents."
msgstr "変数名(シンボル)が非@code{nil}の@code{permanent-local}プロパティーをもつなら、そのバッファーローカル変数は@dfn{permanent(永続的)}です。そのような変数は@code{kill-all-local-variables}の影響を受けず、したがってメジャーモードの変更によりそれらのローカルバインディングは作成されません。permanentなローカル変数はファイルの内容を編集する方法ではなく、どこから読み込んだファイルか、あるいはどのように保存するかといったことに関連するデータに適しています。"

#. type: subsection
#: original_texis/variables.texi:1452
#, no-wrap
msgid "The Default Value of a Buffer-Local Variable"
msgstr "The Default Value of a Buffer-Local Variable"

#. type: cindex
#: original_texis/variables.texi:1453
#, no-wrap
msgid "default value"
msgstr "default value"

#. type: Plain text
#: original_texis/variables.texi:1459
msgid "The global value of a variable with buffer-local bindings is also called the @dfn{default} value, because it is the value that is in effect whenever neither the current buffer nor the selected frame has its own binding for the variable."
msgstr "バッファーローカルなバインディングをもつ変数のグローバル値も@dfn{デフォルト値(default)}値と呼ばれます。なぜならその変数にたいしてカレントバッファーや選択されたフレームもバインディングをもたなければ、その値が常に効果をもつからです。"

#. type: Plain text
#: original_texis/variables.texi:1467
msgid "The functions @code{default-value} and @code{setq-default} access and change a variable's default value regardless of whether the current buffer has a buffer-local binding.  For example, you could use @code{setq-default} to change the default setting of @code{paragraph-start} for most buffers; and this would work even when you are in a C or Lisp mode buffer that has a buffer-local value for this variable."
msgstr "関数@code{default-value}と@code{setq-default}は、カレントバッファーがバッファーローカルなバインディングをもつかどうかに関わらず、その変数のデフォルト値にアクセスまたは変更します。たとえばほとんどのバッファーにたいして、@code{paragraph-start}のデフォルトのセッティングを変更するために、@code{setq-default}を使用できます。そしてこの変数にたいするバッファーローカルな値をもつCモードやLispモードにいるときでさえ、これは機能します。"

#. type: Plain text
#: original_texis/variables.texi:1472
msgid "The special forms @code{defvar} and @code{defconst} also set the default value (if they set the variable at all), rather than any buffer-local value."
msgstr "スペシャルフォーム@code{defvar}と@code{defconst}もバッファーローカルな値ではなく、(もし変数にセットする場合は)デフォルト値をセットします。"

#. type: defun
#: original_texis/variables.texi:1473
#, no-wrap
msgid "default-value symbol"
msgstr "default-value symbol"

#. type: defun
#: original_texis/variables.texi:1478
msgid "This function returns @var{symbol}'s default value.  This is the value that is seen in buffers and frames that do not have their own values for this variable.  If @var{symbol} is not buffer-local, this is equivalent to @code{symbol-value} (@pxref{Accessing Variables})."
msgstr "この関数は@var{symbol}のデフォルト値をリターンする。これはこの変数にたいして独自の値をもたないバッファーやフレームから参照される値である。@var{symbol}がバッファーローカルでなければ、これは@code{symbol-value}(@ref{Accessing Variables}を参照)と同じ。"

#. type: defun
#: original_texis/variables.texi:1481
#, no-wrap
msgid "default-boundp symbol"
msgstr "default-boundp symbol"

#. type: defun
#: original_texis/variables.texi:1485
msgid "The function @code{default-boundp} tells you whether @var{symbol}'s default value is nonvoid.  If @code{(default-boundp 'foo)} returns @code{nil}, then @code{(default-value 'foo)} would get an error."
msgstr "関数@code{default-boundp}は@var{symbol}のデフォルト値がvoidでないか報告する。@code{(default-boundp 'foo)}が@code{nil}をリターンした場合には@code{(default-value 'foo)}はエラーになる。"

#. type: defun
#: original_texis/variables.texi:1488
msgid "@code{default-boundp} is to @code{default-value} as @code{boundp} is to @code{symbol-value}."
msgstr "@code{default-boundp}は@code{default-value}、@code{boundp}は@code{symbol-value}にたいする述語である。"

#. type: defspec
#: original_texis/variables.texi:1490
#, no-wrap
msgid "setq-default [symbol form]@dots{}"
msgstr "setq-default [symbol form]@dots{}"

#. type: defspec
#: original_texis/variables.texi:1495
msgid "This special form gives each @var{symbol} a new default value, which is the result of evaluating the corresponding @var{form}.  It does not evaluate @var{symbol}, but does evaluate @var{form}.  The value of the @code{setq-default} form is the value of the last @var{form}."
msgstr "このスペシャルフォームは各@var{symbol}に新たなデフォルト値として、対応する@var{form}を評価した結果を与える。これは@var{symbol}を評価しないが@var{form}は評価する。@code{setq-default}フォームの値は最後の@var{form}の値。"

#. type: defspec
#: original_texis/variables.texi:1502
msgid "If a @var{symbol} is not buffer-local for the current buffer, and is not marked automatically buffer-local, @code{setq-default} has the same effect as @code{setq}.  If @var{symbol} is buffer-local for the current buffer, then this changes the value that other buffers will see (as long as they don't have a buffer-local value), but not the value that the current buffer sees."
msgstr "カレントバッファーにたいして@var{symbol}がバッファーローカルでなく、自動的にバッファーローカルにマークされていなければ、@code{setq-default}は@code{setq}と同じ効果をもつ。カレントバッファーにたいして@var{symbol}がバッファーローカルなら、(バッファーローカルな値をもたない)他のバッファーから参照できる値を変更するが、それはカレントバッファーが参照する値ではない。"

#. type: group
#: original_texis/variables.texi:1508
#, no-wrap
msgid ""
";; @r{In buffer @samp{foo}:}\n"
"(make-local-variable 'buffer-local)\n"
"     @result{} buffer-local\n"
msgstr ""
";; @r{バッファー@samp{foo}で行う:}\n"
"(make-local-variable 'buffer-local)\n"
"     @result{} buffer-local\n"

#. type: group
#: original_texis/variables.texi:1512
#, no-wrap
msgid ""
"(setq buffer-local 'value-in-foo)\n"
"     @result{} value-in-foo\n"
msgstr ""
"(setq buffer-local 'value-in-foo)\n"
"     @result{} value-in-foo\n"

#. type: group
#: original_texis/variables.texi:1516
#, no-wrap
msgid ""
"(setq-default buffer-local 'new-default)\n"
"     @result{} new-default\n"
msgstr ""
"(setq-default buffer-local 'new-default)\n"
"     @result{} new-default\n"

#. type: group
#: original_texis/variables.texi:1520
#, no-wrap
msgid ""
"buffer-local\n"
"     @result{} value-in-foo\n"
msgstr ""
"buffer-local\n"
"     @result{} value-in-foo\n"

#. type: group
#: original_texis/variables.texi:1524 original_texis/variables.texi:1534
#, no-wrap
msgid ""
"(default-value 'buffer-local)\n"
"     @result{} new-default\n"
msgstr ""
"(default-value 'buffer-local)\n"
"     @result{} new-default\n"

#. type: group
#: original_texis/variables.texi:1530
#, no-wrap
msgid ""
";; @r{In (the new) buffer @samp{bar}:}\n"
"buffer-local\n"
"     @result{} new-default\n"
msgstr ""
";; @r{(新しい)バッファー@samp{bar}で行う:}\n"
"buffer-local\n"
"     @result{} new-default\n"

#. type: group
#: original_texis/variables.texi:1538
#, no-wrap
msgid ""
"(setq buffer-local 'another-default)\n"
"     @result{} another-default\n"
msgstr ""
"(setq buffer-local 'another-default)\n"
"     @result{} another-default\n"

#. type: group
#: original_texis/variables.texi:1542
#, no-wrap
msgid ""
"(default-value 'buffer-local)\n"
"     @result{} another-default\n"
msgstr ""
"(default-value 'buffer-local)\n"
"     @result{} another-default\n"

#. type: group
#: original_texis/variables.texi:1550
#, no-wrap
msgid ""
";; @r{Back in buffer @samp{foo}:}\n"
"buffer-local\n"
"     @result{} value-in-foo\n"
"(default-value 'buffer-local)\n"
"     @result{} another-default\n"
msgstr ""
";; @r{バッファー@samp{foo}に戻って行う:}\n"
"buffer-local\n"
"     @result{} value-in-foo\n"
"(default-value 'buffer-local)\n"
"     @result{} another-default\n"

#. type: defun
#: original_texis/variables.texi:1554
#, no-wrap
msgid "set-default symbol value"
msgstr "set-default symbol value"

#. type: defun
#: original_texis/variables.texi:1557
msgid "This function is like @code{setq-default}, except that @var{symbol} is an ordinary evaluated argument."
msgstr "この関数は@code{setq-default}と似ているが、@var{symbol}は通常の引数として評価される。"

#. type: group
#: original_texis/variables.texi:1562
#, no-wrap
msgid ""
"(set-default (car '(a b c)) 23)\n"
"     @result{} 23\n"
msgstr ""
"(set-default (car '(a b c)) 23)\n"
"     @result{} 23\n"

#. type: group
#: original_texis/variables.texi:1566
#, no-wrap
msgid ""
"(default-value 'a)\n"
"     @result{} 23\n"
msgstr ""
"(default-value 'a)\n"
"     @result{} 23\n"

#. type: cindex
#: original_texis/variables.texi:1572
#, no-wrap
msgid "file local variables"
msgstr "file local variables"

#. type: Plain text
#: original_texis/variables.texi:1580
msgid "A file can specify local variable values; Emacs uses these to create buffer-local bindings for those variables in the buffer visiting that file.  @xref{File Variables, , Local Variables in Files, emacs, The GNU Emacs Manual}, for basic information about file-local variables.  This section describes the functions and variables that affect how file-local variables are processed."
msgstr "ファイルにローカル変数の値を指定できます。そのファイルをvisitしているバッファー内で、これらの変数にたいしてバッファーローカルなバインディングを作成するために、Emacsはこれらを使用します。ファイルローカル変数の基本的な情報については、@ref{File Variables, , Local Variables in Files, emacs, The GNU Emacs Manual}を参照してください。このセクションではファイルローカル変数が処理される方法に影響する関数と変数を説明します。"

#. type: Plain text
#: original_texis/variables.texi:1586
msgid "If a file-local variable could specify an arbitrary function or Lisp expression that would be called later, visiting a file could take over your Emacs.  Emacs protects against this by automatically setting only those file-local variables whose specified values are known to be safe.  Other file-local variables are set only if the user agrees."
msgstr "ファイルローカル変数が勝手に関数や、後で呼び出されるLisp式を指定できたら、ファイルのvisitによってEmacsが乗っ取られてしまうかもしれません。Emacsは既知のファイルローカル変数だけにたいして、指定された値が安全だと自動的にセットすることにより、この危険から保護します。これ以外のファイルローカル変数は、ユーザーが同意した場合のみセットされます。"

#. type: Plain text
#: original_texis/variables.texi:1591
msgid "For additional safety, @code{read-circle} is temporarily bound to @code{nil} when Emacs reads file-local variables (@pxref{Input Functions}).  This prevents the Lisp reader from recognizing circular and shared Lisp structures (@pxref{Circular Objects})."
msgstr "追加の安全策としてEmacsがファイルローカル変数を読み込むとき、一時的に@code{read-circle}を@code{nil}にバインドします(@ref{Input Functions}を参照)。これは循環認識と共有されたLisp構造からLispリーダーを保護します(@ref{Circular Objects}を参照)。"

#. type: defopt
#: original_texis/variables.texi:1592
#, no-wrap
msgid "enable-local-variables"
msgstr "enable-local-variables"

#. type: defopt
#: original_texis/variables.texi:1595
msgid "This variable controls whether to process file-local variables.  The possible values are:"
msgstr "この変数はファイルローカル変数を処理するかどうかを制御する。以下の値が利用できる:"

#. type: item
#: original_texis/variables.texi:1597
#, no-wrap
msgid "@code{t} (the default)"
msgstr "@code{t}(デフォルト)"

#. type: table
#: original_texis/variables.texi:1599
msgid "Set the safe variables, and query (once) about any unsafe variables."
msgstr "安全な変数をセット、安全でない変数は問い合わせる(1回)。"

#. type: code{#1}
#: original_texis/variables.texi:1599
#, no-wrap
msgid ":safe"
msgstr ":safe"

#. type: table
#: original_texis/variables.texi:1601
msgid "Set only the safe variables and do not query."
msgstr "安全な変数だけをセット、問い合わせはしない。"

#. type: code{#1}
#: original_texis/variables.texi:1601
#, no-wrap
msgid ":all"
msgstr ":all"

#. type: table
#: original_texis/variables.texi:1603
msgid "Set all the variables and do not query."
msgstr "問い合わせをせずに、すべての変数をセット。"

#. type: code{#1}
#: original_texis/variables.texi:1603
#, no-wrap
msgid "nil"
msgstr "nil"

#. type: table
#: original_texis/variables.texi:1605
msgid "Don't set any variables."
msgstr "変数をセットしない。"

#. type: item
#: original_texis/variables.texi:1605
#, no-wrap
msgid "anything else"
msgstr "その他"

#. type: table
#: original_texis/variables.texi:1607
msgid "Query (once) about all the variables."
msgstr "すべての変数にたいして問い合わせる(1回)。"

#. type: defvar
#: original_texis/variables.texi:1610
#, no-wrap
msgid "inhibit-local-variables-regexps"
msgstr "inhibit-local-variables-regexps"

#. type: defvar
#: original_texis/variables.texi:1615
msgid "This is a list of regular expressions.  If a file has a name matching an element of this list, then it is not scanned for any form of file-local variable.  For examples of why you might want to use this, @pxref{Auto Major Mode}."
msgstr "これは正規表現のリストである。ファイルがこのリストの要素にマッチする名前をもつなら、すべてのファイルローカル変数のフォームはスキャンされない。どんなときにこれを使いたいかの例は、@ref{Auto Major Mode}を参照のこと。"

#. type: defun
#: original_texis/variables.texi:1617
#, no-wrap
msgid "hack-local-variables &optional mode-only"
msgstr "hack-local-variables &optional mode-only"

#. type: defun
#: original_texis/variables.texi:1624
msgid "This function parses, and binds or evaluates as appropriate, any local variables specified by the contents of the current buffer.  The variable @code{enable-local-variables} has its effect here.  However, this function does not look for the @samp{mode:} local variable in the @w{@samp{-*-}} line.  @code{set-auto-mode} does that, also taking @code{enable-local-variables} into account (@pxref{Auto Major Mode})."
msgstr "この関数はカレントバッファーの内容により指定された任意のローカル変数にたいしてパースを行い、適切にバインドと評価を行う。変数@code{enable-local-variables}はここでも効果をもつ。しかしこの関数は@w{@samp{-*-}}行の、@samp{mode:}ローカル変数を探さない。@code{set-auto-mode}はこれを行って@code{enable-local-variables}も考慮する(@ref{Auto Major Mode}を参照)。"

#. type: defun
#: original_texis/variables.texi:1633
msgid "This function works by walking the alist stored in @code{file-local-variables-alist} and applying each local variable in turn.  It calls @code{before-hack-local-variables-hook} and @code{hack-local-variables-hook} before and after applying the variables, respectively.  It only calls the before-hook if the alist is non-@code{nil}; it always calls the other hook.  This function ignores a @samp{mode} element if it specifies the same major mode as the buffer already has."
msgstr "この関数は@code{file-local-variables-alist}内に格納されたalistを調べて、各ローカル変数を順に適用することにより機能する。この関数は変数に適用する前(か後)に、@code{before-hack-local-variables-hook}(か@code{hack-local-variables-hook})を呼び出す。alistが非@code{nil}の場合のみ、事前のフック(before-hook)を呼び出し、その他のフックは常に呼び出す。この関数はそのバッファーがすでにもつメジャーモードと同じメジャーモードが指定された場合は@samp{mode}要素を無視する。"

#. type: defun
#: original_texis/variables.texi:1639
msgid "If the optional argument @var{mode-only} is non-@code{nil}, then all this function does is return a symbol specifying the major mode, if the @w{@samp{-*-}} line or the local variables list specifies one, and @code{nil} otherwise.  It does not set the mode nor any other file-local variable."
msgstr "オプションの引数@var{mode-only}が非@code{nil}なら、メジャーモードを指定するシンボルをリターンするのがこの関数が行うのすべてであり、@w{@samp{-*-}}行かローカル変数リストがメジャーモードを指定していればそのモード、それ以外は@code{nil}をリターンする。この関数はモードや他のファイルローカル変数をセットしない。"

#. type: defvar
#: original_texis/variables.texi:1641
#, no-wrap
msgid "file-local-variables-alist"
msgstr "file-local-variables-alist"

#. type: defvar
#: original_texis/variables.texi:1649
msgid "This buffer-local variable holds the alist of file-local variable settings.  Each element of the alist is of the form @w{@code{(@var{var} . @var{value})}}, where @var{var} is a symbol of the local variable and @var{value} is its value.  When Emacs visits a file, it first collects all the file-local variables into this alist, and then the @code{hack-local-variables} function applies them one by one."
msgstr "このバッファーローカルな変数は、ファイルローカル変数のセッティングのalistを保持する。alistの各要素は@w{@code{(@var{var} . @var{value})}}という形式で、@var{var}はローカル変数のシンボル、@var{value}はその値である。Emacsがファイルをvisitするとき、最初にすべてのファイルローカル変数をこのalistに収集して、その後で変数に1つずつ関数@code{hack-local-variables}を適用する。"

#. type: defvar
#: original_texis/variables.texi:1651
#, no-wrap
msgid "before-hack-local-variables-hook"
msgstr "before-hack-local-variables-hook"

#. type: defvar
#: original_texis/variables.texi:1654
msgid "Emacs calls this hook immediately before applying file-local variables stored in @code{file-local-variables-alist}."
msgstr "Emacsは@code{file-local-variables-alist}に格納されたファイルローカル変数を適用する直前にこのフックを呼び出す。"

#. type: defvar
#: original_texis/variables.texi:1656
#, no-wrap
msgid "hack-local-variables-hook"
msgstr "hack-local-variables-hook"

#. type: defvar
#: original_texis/variables.texi:1659
msgid "Emacs calls this hook immediately after it finishes applying file-local variables stored in @code{file-local-variables-alist}."
msgstr "Emacsは@code{file-local-variables-alist}に格納されたファイルローカル変数を適用し終えた直後にこのフックを呼び出す。"

#. type: cindex
#: original_texis/variables.texi:1661
#, no-wrap
msgid "safe local variable"
msgstr "safe local variable"

#. type: Plain text
#: original_texis/variables.texi:1670
msgid "You can specify safe values for a variable with a @code{safe-local-variable} property.  The property has to be a function of one argument; any value is safe if the function returns non-@code{nil} given that value.  Many commonly-encountered file variables have @code{safe-local-variable} properties; these include @code{fill-column}, @code{fill-prefix}, and @code{indent-tabs-mode}.  For boolean-valued variables that are safe, use @code{booleanp} as the property value."
msgstr "ある変数にたいして@code{safe-local-variable}プロパティーによって安全な値を指定できます。このプロパティーは引数を1つとる関数です。与えられた値にたいして、その関数が非@code{nil}をリターンしたらその値は安全です。一般的に目にするファイル変数の多くは、@code{safe-local-variable}プロパティーをもちます。これらのファイル変数には@code{fill-column}、@code{fill-prefix}、@code{indent-tabs-mode}が含まれます。ブーリーン値の変数にたいしては、プロパティーの値に@code{booleanp}を使用します。"

#. type: Plain text
#: original_texis/variables.texi:1675
msgid "When defining a user option using @code{defcustom}, you can set its @code{safe-local-variable} property by adding the arguments @code{:safe @var{function}} to @code{defcustom} (@pxref{Variable Definitions})."
msgstr "@code{defcustom}を使用してユーザーオプションを定義する際、@code{defcustom}に引数@code{:safe @var{function}}を追加することにより、@code{safe-local-variable}プロパティーをセットできます(@ref{Variable Definitions}を参照)。"

#. type: defopt
#: original_texis/variables.texi:1676
#, no-wrap
msgid "safe-local-variable-values"
msgstr "safe-local-variable-values"

#. type: defopt
#: original_texis/variables.texi:1681
msgid "This variable provides another way to mark some variable values as safe.  It is a list of cons cells @code{(@var{var} . @var{val})}, where @var{var} is a variable name and @var{val} is a value which is safe for that variable."
msgstr "この変数はある変数の値が安全であることをマークする、別の方法を提供する。これはコンスセル@code{(@var{var} . @var{val})}のリストであり@var{var}は変数名、@var{val}はその変数にたいして安全な値である。"

#. type: defopt
#: original_texis/variables.texi:1687
msgid "When Emacs asks the user whether or not to obey a set of file-local variable specifications, the user can choose to mark them as safe.  Doing so adds those variable/value pairs to @code{safe-local-variable-values}, and saves it to the user's custom file."
msgstr "Emacsが一連のファイルローカル変数にしたがうかどうかユーザーに尋ねるとき、ユーザーはそれらの変数が安全だとマークすることができる。安全とマークすると@code{safe-local-variable-values}にこれらのvariable/valueペアーが追加されて、ユーザーのカスタムファイルに保存する。"

#. type: defun
#: original_texis/variables.texi:1689
#, no-wrap
msgid "safe-local-variable-p sym val"
msgstr "safe-local-variable-p sym val"

#. type: defun
#: original_texis/variables.texi:1692
msgid "This function returns non-@code{nil} if it is safe to give @var{sym} the value @var{val}, based on the above criteria."
msgstr "この関数は上記の条件に基づき、@var{sym}に値@var{val}を与えても安全ななら非@code{nil}をリターンする。"

#. type: Plain text
#: original_texis/variables.texi:1700
msgid "Some variables are considered @dfn{risky}.  If a variable is risky, it is never entered automatically into @code{safe-local-variable-values}; Emacs always queries before setting a risky variable, unless the user explicitly allows a value by customizing @code{safe-local-variable-values} directly."
msgstr "いくつかの変数は@dfn{危険(risky)}だと判断されます。ある変数が危険なら、その変数が@code{safe-local-variable-values}に自動的に追加されることはありません。ユーザーが@code{safe-local-variable-values}を直接カスタマイズすることで明示的に値を許さない限り、危険な変数をセットする前にEmacsは常に確認を求めます。"

#. type: Plain text
#: original_texis/variables.texi:1714
msgid "Any variable whose name has a non-@code{nil} @code{risky-local-variable} property is considered risky.  When you define a user option using @code{defcustom}, you can set its @code{risky-local-variable} property by adding the arguments @code{:risky @var{value}} to @code{defcustom} (@pxref{Variable Definitions}).  In addition, any variable whose name ends in any of @samp{-command}, @samp{-frame-alist}, @samp{-function}, @samp{-functions}, @samp{-hook}, @samp{-hooks}, @samp{-form}, @samp{-forms}, @samp{-map}, @samp{-map-alist}, @samp{-mode-alist}, @samp{-program}, or @samp{-predicate} is automatically considered risky.  The variables @samp{font-lock-keywords}, @samp{font-lock-keywords} followed by a digit, and @samp{font-lock-syntactic-keywords} are also considered risky."
msgstr "名前が非@code{nil}の@code{risky-local-variable}プロパティーをもつすべての変数は危険だと判断されます。@code{defcustom}を使用してユーザーオプションを定義するとき、@code{defcustom}に引数@code{:risky @var{value}}を追加することにより、ユーザーオプションに@code{risky-local-variable}プロパティーをセットできます。それに加えて名前が@samp{-command}、@samp{-frame-alist}、@samp{-function}、@samp{-functions}、@samp{-hook}、@samp{-hooks}、@samp{-form}、@samp{-forms}、@samp{-map}、@samp{-map-alist}、@samp{-mode-alist}、@samp{-program}、@samp{-predicate}で終わるすべての変数は自動的に危険だと判断されます。後に数字をともなう変数@samp{font-lock-keywords}と@samp{font-lock-keywords}、さらには@samp{font-lock-syntactic-keywords}も危険だと判断されます。"

#. type: defun
#: original_texis/variables.texi:1715
#, no-wrap
msgid "risky-local-variable-p sym"
msgstr "risky-local-variable-p sym"

#. type: defun
#: original_texis/variables.texi:1718
msgid "This function returns non-@code{nil} if @var{sym} is a risky variable, based on the above criteria."
msgstr "この関数は@var{sym}が上記の条件にもとづき危険な変数なら非@code{nil}をリターンする。"

#. type: defvar
#: original_texis/variables.texi:1720
#, no-wrap
msgid "ignored-local-variables"
msgstr "ignored-local-variables"

#. type: defvar
#: original_texis/variables.texi:1724
msgid "This variable holds a list of variables that should not be given local values by files.  Any value specified for one of these variables is completely ignored."
msgstr "この変数はファイルによりローカル値を与えらるべきではない変数のリストを保持する。これらの変数に指定された任意の値は、完全に無視される。"

#. type: Plain text
#: original_texis/variables.texi:1728
msgid "The @samp{Eval:} ``variable'' is also a potential loophole, so Emacs normally asks for confirmation before handling it."
msgstr "``変数''@samp{Eval:}も抜け道になる可能性があるので、Emacsは通常はそれを処理する前に確認を求めます。"

#. type: defopt
#: original_texis/variables.texi:1729
#, no-wrap
msgid "enable-local-eval"
msgstr "enable-local-eval"

#. type: defopt
#: original_texis/variables.texi:1735
msgid "This variable controls processing of @samp{Eval:} in @samp{-*-} lines or local variables lists in files being visited.  A value of @code{t} means process them unconditionally; @code{nil} means ignore them; anything else means ask the user what to do for each file.  The default value is @code{maybe}."
msgstr "この変数は@samp{-*-}の行中、またはvisitされるファイル内のローカル変数リストにたいする、@samp{Eval:}の処理を制御する。値@code{t}は無条件に実行し、@code{nil}はそれらを無視することを意味します。それ以外なら各ファイルにたいして何を行うか、ユーザーに確認を求めることを意味する。デフォルト値は@code{maybe}。"

#. type: defopt
#: original_texis/variables.texi:1737
#, no-wrap
msgid "safe-local-eval-forms"
msgstr "safe-local-eval-forms"

#. type: defopt
#: original_texis/variables.texi:1741
msgid "This variable holds a list of expressions that are safe to evaluate when found in the @samp{Eval:} ``variable'' in a file local variables list."
msgstr "この変数はファイルローカル変数リスト内で@samp{Eval:}``変数''が見つかった際に評価しても安全な式のリストを保持する。"

#. type: Plain text
#: original_texis/variables.texi:1749
msgid "If the expression is a function call and the function has a @code{safe-local-eval-function} property, the property value determines whether the expression is safe to evaluate.  The property value can be a predicate to call to test the expression, a list of such predicates (it's safe if any predicate succeeds), or @code{t} (always safe provided the arguments are constant)."
msgstr "式が関数呼び出しであり、その関数が@code{safe-local-eval-function}プロパティーをもつなら、その式の評価が安全かどうかはそのプロパティー値が決定します。プロパティー値はその式をテストするための述語(predicate)、そのような述語のリスト(成功した述語があれば安全)、または@code{t}(引数が定数である限り常に安全)を指定できます。"

#. type: Plain text
#: original_texis/variables.texi:1753
msgid "Text properties are also potential loopholes, since their values could include functions to call.  So Emacs discards all text properties from string values specified for file-local variables."
msgstr "テキストプロパティーには、それらの値に関数呼び出しを含めることができるので抜け道になる可能性があります。したがってEmacsはファイルローカル変数にたいして指定された文字列値から、テキストプロパティーを取り除きます。"

#. type: cindex
#: original_texis/variables.texi:1756
#, no-wrap
msgid "directory local variables"
msgstr "directory local variables"

#. type: Plain text
#: original_texis/variables.texi:1763
msgid "A directory can specify local variable values common to all files in that directory; Emacs uses these to create buffer-local bindings for those variables in buffers visiting any file in that directory.  This is useful when the files in the directory belong to some @dfn{project} and therefore share the same local variables."
msgstr "ディレクトリーは、そのディレクトリー内のすべてのファイルに共通なローカル変数値を指定することができます。Emacsはそのディレクトリー内の任意のファイルをvisitしているバッファー内で、それらの変数にたいするバッファーローカルなバインディングを作成するためにこれを使用します。これはそのディレクトリー内のファイルが何らかの@dfn{プロジェクト}に属していて、同じローカル変数を共有するときなどに有用です。"

#. type: Plain text
#: original_texis/variables.texi:1767
msgid "There are two different methods for specifying directory local variables: by putting them in a special file, or by defining a @dfn{project class} for that directory."
msgstr "ディレクトリーローカル変数を指定するために2つの異なる方法があります: 1つは特別なファイルにそれを記述する方法、もう1つはそのディレクトリーに@dfn{プロジェクトクラス(project class)}を定義する方法です。"

#. type: defvr
#: original_texis/variables.texi:1768
#, no-wrap
msgid "Constant dir-locals-file"
msgstr "Constant dir-locals-file"

#. type: defvr
#: original_texis/variables.texi:1783
msgid "This constant is the name of the file where Emacs expects to find the directory-local variables.  The name of the file is @file{.dir-locals.el}@footnote{ The MS-DOS version of Emacs uses @file{_dir-locals.el} instead, due to limitations of the DOS filesystems.  }.  A file by that name in a directory causes Emacs to apply its settings to any file in that directory or any of its subdirectories (optionally, you can exclude subdirectories; see below).  If some of the subdirectories have their own @file{.dir-locals.el} files, Emacs uses the settings from the deepest file it finds starting from the file's directory and moving up the directory tree.  The file specifies local variables as a specially formatted list; see @ref{Directory Variables, , Per-directory Local Variables, emacs, The GNU Emacs Manual}, for more details."
msgstr "この定数はEmacsがディレクトリーローカル変数が見つけることができると期待するファイルの名前である。ファイル名は@file{.dir-locals.el}@footnote{MS-DOS版のEmacsはDOSファイルシステムの制限により、かわりに@file{_dir-locals.el}という名前を使用します。}。ディレクトリー内でその名前をもつファイルにより、Emacsはディレクトリー内の任意のファイル、または任意のサブディレクトリー(オプションでサブディレクトリーを除外できる。以下参照)にセッティングを適用する。独自に@file{.dir-locals.el}をもつサブディレクトリーがあるなら、Emacsはサブディレクトリーで見つかった1番深いファイルのディレクトリーからディレクトリーツリーを上方に移動しつつ、1番深いファイルのセッティングを使用する。このファイルはローカル変数をフォーマットされたリストとして指定する。詳細は@ref{Directory Variables, , Per-directory Local Variables, emacs, The GNU Emacs Manual}を参照のこと。"

#. type: defun
#: original_texis/variables.texi:1785
#, no-wrap
msgid "hack-dir-local-variables"
msgstr "hack-dir-local-variables"

#. type: defun
#: original_texis/variables.texi:1794
msgid "This function reads the @code{.dir-locals.el} file and stores the directory-local variables in @code{file-local-variables-alist} that is local to the buffer visiting any file in the directory, without applying them.  It also stores the directory-local settings in @code{dir-locals-class-alist}, where it defines a special class for the directory in which @file{.dir-locals.el} file was found.  This function works by calling @code{dir-locals-set-class-variables} and @code{dir-locals-set-directory-class}, described below."
msgstr "この関数は@code{.dir-locals.el}ファイルを読み込み、そのディレクトリー内の任意のファイルをvisitしているバッファーにローカルな@code{file-local-variables-alist}内に、それらを適用することなくディレクトリーローカル変数を格納する。この関数はディレクトリーローカルなセッティングも@code{dir-locals-class-alist}(@file{.dir-locals.el}ファイルが見つかったディレクトリーにたいする特別なクラスを定義する)内に格納する。この関数は以下で説明するように、@code{dir-locals-set-class-variables}と@code{dir-locals-set-directory-class}を呼び出すことにより機能する。"

#. type: defun
#: original_texis/variables.texi:1796
#, no-wrap
msgid "hack-dir-local-variables-non-file-buffer"
msgstr "hack-dir-local-variables-non-file-buffer"

#. type: defun
#: original_texis/variables.texi:1803
msgid "This function looks for directory-local variables, and immediately applies them in the current buffer.  It is intended to be called in the mode commands for non-file buffers, such as Dired buffers, to let them obey directory-local variable settings.  For non-file buffers, Emacs looks for directory-local variables in @code{default-directory} and its parent directories."
msgstr "この関数はディレクトリーローカル変数を探して、即座にそれらをカレントバッファーに適用する。これはDiredバッファーのような、非ファイルバッファーをディレクトリーローカル変数のセッティングにしたがわせるために、モードコマンド呼び出しの中から呼び出されることを意図したものである。非ファイルバッファーにたいしては、Emacsは@code{default-directory}とその親ディレクトリーの中から、ディレクトリーローカル変数を探す。"

#. type: defun
#: original_texis/variables.texi:1805
#, no-wrap
msgid "dir-locals-set-class-variables class variables"
msgstr "dir-locals-set-class-variables class variables"

#. type: defun
#: original_texis/variables.texi:1820
msgid "This function defines a set of variable settings for the named @var{class}, which is a symbol.  You can later assign the class to one or more directories, and Emacs will apply those variable settings to all files in those directories.  The list in @var{variables} can be of one of the two forms: @code{(@var{major-mode} . @var{alist})} or @code{(@var{directory} . @var{list})}.  With the first form, if the file's buffer turns on a mode that is derived from @var{major-mode}, then the all the variables in the associated @var{alist} are applied; @var{alist} should be of the form @code{(@var{name} . @var{value})}.  A special value @code{nil} for @var{major-mode} means the settings are applicable to any mode.  In @var{alist}, you can use a special @var{name}: @code{subdirs}.  If the associated value is @code{nil}, the alist is only applied to files in the relevant directory, not to those in any subdirectories."
msgstr "この関数は@var{class}という名前がつけられたシンボルにたいして、一連の変数セッティングを定義する。ユーザーは後からこのクラスを1つ以上のディレクトリーに割り当てることができる。そしてEmacsはこれらの変数セッティングを、それらのディレクトリー内のすべてのファイルに適用するだろう。@var{variables}内のリストは2つの形式 --- @code{(@var{major-mode} . @var{alist})}か@code{(@var{directory} . @var{list})} --- のいずれかをもつことができる。1番目の形式ではそのファイルのバッファーが@var{major-mode}を継承するモードに切り替わるときに、連想リスト@var{alist}内のすべての変数が適用される。@var{alist}は@code{(@var{name} . @var{value})}という形式。@var{major-mode}にたいする特別な値@code{nil}は、そのセッティングが任意のモードに適用できることを意味する。@var{alist}内では特別な@var{name}として、@code{subdirs}を使用することができる。連想値が@code{nil}なら、alistは関連するディレクトリー内のファイルだけに適用され、それらのサブディレクトリーには適用されない。"

#. type: defun
#: original_texis/variables.texi:1825
msgid "With the second form of @var{variables}, if @var{directory} is the initial substring of the file's directory, then @var{list} is applied recursively by following the above rules; @var{list} should be of one of the two forms accepted by this function in @var{variables}."
msgstr "@var{variables}の2番目の形式では、@var{directory}がそのファイルのディレクトリーの最初のサブディレクトリーなら、上記のルールにしたがい@var{list}が再帰的に適用される。@var{list}はこの関数の@var{variables}で指定できる2つの形式のうち1つを指定する。"

#. type: defun
#: original_texis/variables.texi:1827
#, no-wrap
msgid "dir-locals-set-directory-class directory class &optional mtime"
msgstr "dir-locals-set-directory-class directory class &optional mtime"

#. type: defun
#: original_texis/variables.texi:1833
msgid "This function assigns @var{class} to all the files in @code{directory} and its subdirectories.  Thereafter, all the variable settings specified for @var{class} will be applied to any visited file in @var{directory} and its children.  @var{class} must have been already defined by @code{dir-locals-set-class-variables}."
msgstr "この関数は@code{directory}とサブディレクトリー内のすべてのファイルに@var{class}を割り当てる。その後、@var{class}にたいして指定されたすべての変数セッティングは、@var{directory}とその子ディレクトリー内でvisitされたすべてのファイルに適用される。@var{class}は事前に@code{dir-locals-set-class-variables}で定義されていなければならない。"

#. type: defun
#: original_texis/variables.texi:1840
msgid "Emacs uses this function internally when it loads directory variables from a @code{.dir-locals.el} file.  In that case, the optional argument @var{mtime} holds the file modification time (as returned by @code{file-attributes}).  Emacs uses this time to check stored local variables are still valid.  If you are assigning a class directly, not via a file, this argument should be @code{nil}."
msgstr "Emacsが@code{.dir-locals.el}ファイルからディレクトリー変数をロードする際、内部的にこの関数を使用する。その場合、オプションの引数@var{mtime}はファイルの修正日時(modification time。@code{file-attributes}によりリターンされる)を保持する。Emacsは記憶されたローカル変数がまだ有効化チェックするために、この日時を使用する。ファイルを介さず直接クラスを割り当てる場合、この引数は@code{nil}になる。"

#. type: defvar
#: original_texis/variables.texi:1842
#, no-wrap
msgid "dir-locals-class-alist"
msgstr "dir-locals-class-alist"

#. type: defvar
#: original_texis/variables.texi:1845
msgid "This alist holds the class symbols and the associated variable settings.  It is updated by @code{dir-locals-set-class-variables}."
msgstr "このalistはクラスシンボル(class symbol)とそれに関連づけられる変数のセッティングを保持する。これは@code{dir-locals-set-class-variables}により更新される。"

#. type: defvar
#: original_texis/variables.texi:1847
#, no-wrap
msgid "dir-locals-directory-cache"
msgstr "dir-locals-directory-cache"

#. type: defvar
#: original_texis/variables.texi:1852
msgid "This alist holds directory names, their assigned class names, and modification times of the associated directory local variables file (if there is one).  The function @code{dir-locals-set-directory-class} updates this list."
msgstr "このalistはディレクトリー名、それらに割り当てられたクラス名、およびこのエントリーに関連するディレクトリーローカル変数ファイルの修正日時を保持する。関数@code{dir-locals-set-directory-class}はこのlistを更新する。"

#. type: defvar
#: original_texis/variables.texi:1854
#, no-wrap
msgid "enable-dir-local-variables"
msgstr "enable-dir-local-variables"

#. type: defvar
#: original_texis/variables.texi:1858
msgid "If @code{nil}, directory-local variables are ignored.  This variable may be useful for modes that want to ignore directory-locals while still respecting file-local variables (@pxref{File Local Variables})."
msgstr "@code{nil}ならディレクトリーローカル変数は無視される。この変数はファイルローカル変数(@ref{File Local Variables}を参照)にはしたがうが、ディレクトリーローカル変数は無視したいモードにたいして有用かもしれない。"

#. type: cindex
#: original_texis/variables.texi:1862
#, no-wrap
msgid "variable aliases"
msgstr "variable aliases"

#. type: cindex
#: original_texis/variables.texi:1863
#, no-wrap
msgid "alias, for variables"
msgstr "alias, for variables"

#. type: Plain text
#: original_texis/variables.texi:1872
msgid "It is sometimes useful to make two variables synonyms, so that both variables always have the same value, and changing either one also changes the other.  Whenever you change the name of a variable---either because you realize its old name was not well chosen, or because its meaning has partly changed---it can be useful to keep the old name as an @emph{alias} of the new one for compatibility.  You can do this with @code{defvaralias}."
msgstr "シノニムとして2つの変数を作成できれば便利なときがあります。2つの変数は常に同じ値をもち、どちらか一方を変更すると、もう一方も変更されます。変数の名前を変更  --- 古い名前はよく考慮して選択されたものではなかったとか、変数の意味が部分的に変更された等の理由で --- するとき、互換性のために新しい名前の@emph{エイリアス(alias)}として古い名前を維持できれば便利なときがあるかもしれません。@code{defvaralias}によってこれを行うことができます。"

#. type: defun
#: original_texis/variables.texi:1873
#, no-wrap
msgid "defvaralias new-alias base-variable &optional docstring"
msgstr "defvaralias new-alias base-variable &optional docstring"

#. type: defun
#: original_texis/variables.texi:1880
msgid "This function defines the symbol @var{new-alias} as a variable alias for symbol @var{base-variable}. This means that retrieving the value of @var{new-alias} returns the value of @var{base-variable}, and changing the value of @var{new-alias} changes the value of @var{base-variable}.  The two aliased variable names always share the same value and the same bindings."
msgstr "この関数はシンボル@var{base-variable}のエイリアスとして、シンボル@var{new-alias}を定義する。これは@var{new-alias}から値を取得すると@var{base-variable}の値がリターンされ、@var{new-alias}の値を変更すると@var{base-variable}の値が変更されることを意味する。エイリアスされた2つの変数名は、常に同じ値と同じバインディングを共有する。"

#. type: defun
#: original_texis/variables.texi:1886
msgid "If the @var{docstring} argument is non-@code{nil}, it specifies the documentation for @var{new-alias}; otherwise, the alias gets the same documentation as @var{base-variable} has, if any, unless @var{base-variable} is itself an alias, in which case @var{new-alias} gets the documentation of the variable at the end of the chain of aliases."
msgstr "@var{docstring}引数が非@code{nil}なら、それは@var{new-alias}のドキュメント文字列を指定する。それ以外なら、エイリアスは(もしあれば)@var{base-variable}と同じドキュメント文字列となる。ただしそれは@var{base-variable}自体がエイリアスではない場合で、エイリアスなら@var{new-alias}はエイリアスチェーンの最後の変数のドキュメント文字列になる。"

#. type: defun
#: original_texis/variables.texi:1888
msgid "This function returns @var{base-variable}."
msgstr "この関数は@var{base-variable}をリターンする。"

#. type: Plain text
#: original_texis/variables.texi:1894
msgid "Variable aliases are convenient for replacing an old name for a variable with a new name.  @code{make-obsolete-variable} declares that the old name is obsolete and therefore that it may be removed at some stage in the future."
msgstr "変数のエイリアスは、変数にたいする古い名前を新しい名前に置き換える便利な方法です。@code{make-obsolete-variable}は古い名前を陳腐化(obsolete)していると宣言して。それが将来のある時点で削除されるかもしれないことを宣言します。"

#. type: defun
#: original_texis/variables.texi:1895
#, no-wrap
msgid "make-obsolete-variable obsolete-name current-name when &optional access-type"
msgstr "make-obsolete-variable obsolete-name current-name when &optional access-type"

#. type: defun
#: original_texis/variables.texi:1904
msgid "This function makes the byte compiler warn that the variable @var{obsolete-name} is obsolete.  If @var{current-name} is a symbol, it is the variable's new name; then the warning message says to use @var{current-name} instead of @var{obsolete-name}.  If @var{current-name} is a string, this is the message and there is no replacement variable.  @var{when} should be a string indicating when the variable was first made obsolete (usually a version number string)."
msgstr "この関数はバイトコンパイラーに変数@var{obsolete-name}が陳腐化していると警告させる。@var{current-name}がシンボルなら、それはこの変数の新たな名前である。警告メッセージはその後、@var{obsolete-name}のかわりに@var{current-name}を使用するよう告げるようになる。@var{current-name}が文字列なら、それはメッセージであり、置き換えられる変数はない。@var{when}はその変数が最初に陳腐化するのがいつかを示す文字列(通常はバージョン番号文字列)。"

#. type: defun
#: original_texis/variables.texi:1908
msgid "The optional argument @var{access-type}, if non-@code{nil}, should should specify the kind of access that will trigger obsolescence warnings; it can be either @code{get} or @code{set}."
msgstr "オプションの引数@var{access-type}は、非@code{nil}の場合は陳腐化の警告を引き起こすアクセスの種類を指定します。@code{get}または@code{set}を指定できます。"

#. type: Plain text
#: original_texis/variables.texi:1912
msgid "You can make two variables synonyms and declare one obsolete at the same time using the macro @code{define-obsolete-variable-alias}."
msgstr "2つの変数シノニムを作成してマクロ@code{define-obsolete-variable-alias}を使用することにより、1つが陳腐化していると同時に宣言できます。"

#. type: defmac
#: original_texis/variables.texi:1913
#, no-wrap
msgid "define-obsolete-variable-alias obsolete-name current-name &optional when docstring"
msgstr "define-obsolete-variable-alias obsolete-name current-name &optional when docstring"

#. type: defmac
#: original_texis/variables.texi:1917
msgid "This macro marks the variable @var{obsolete-name} as obsolete and also makes it an alias for the variable @var{current-name}.  It is equivalent to the following:"
msgstr "このマクロは変数@var{obsolete-name}が陳腐化しているとマークして、それを変数@var{current-name}にたいするエイリアスにする。これは以下と等価である:"

#. type: example
#: original_texis/variables.texi:1921
#, no-wrap
msgid ""
"(defvaralias @var{obsolete-name} @var{current-name} @var{docstring})\n"
"(make-obsolete-variable @var{obsolete-name} @var{current-name} @var{when})\n"
msgstr ""
"(defvaralias @var{obsolete-name} @var{current-name} @var{docstring})\n"
"(make-obsolete-variable @var{obsolete-name} @var{current-name} @var{when})\n"

#. type: defun
#: original_texis/variables.texi:1924
#, no-wrap
msgid "indirect-variable variable"
msgstr "indirect-variable variable"

#. type: defun
#: original_texis/variables.texi:1928
msgid "This function returns the variable at the end of the chain of aliases of @var{variable}.  If @var{variable} is not a symbol, or if @var{variable} is not defined as an alias, the function returns @var{variable}."
msgstr "この関数は@var{variable}のエイリアスチェーンの最後の変数をリターンする。@var{variable}がシンボルでない、または@var{variable}がエイリアスとして定義されていなければ、この関数は@var{variable}をリターンする。"

#. type: defun
#: original_texis/variables.texi:1931
msgid "This function signals a @code{cyclic-variable-indirection} error if there is a loop in the chain of symbols."
msgstr "この関数はシンボルのチェーンがループしていたら、@code{cyclic-variable-indirection}エラーをシグナルする。"

#. type: example
#: original_texis/variables.texi:1942
#, no-wrap
msgid ""
"(defvaralias 'foo 'bar)\n"
"(indirect-variable 'foo)\n"
"     @result{} bar\n"
"(indirect-variable 'bar)\n"
"     @result{} bar\n"
"(setq bar 2)\n"
"bar\n"
"     @result{} 2\n"
msgstr ""
"(defvaralias 'foo 'bar)\n"
"(indirect-variable 'foo)\n"
"     @result{} bar\n"
"(indirect-variable 'bar)\n"
"     @result{} bar\n"
"(setq bar 2)\n"
"bar\n"
"     @result{} 2\n"

#. type: group
#: original_texis/variables.texi:1945
#, no-wrap
msgid ""
"foo\n"
"     @result{} 2\n"
msgstr ""
"foo\n"
"     @result{} 2\n"

#. type: example
#: original_texis/variables.texi:1951
#, no-wrap
msgid ""
"(setq foo 0)\n"
"bar\n"
"     @result{} 0\n"
"foo\n"
"     @result{} 0\n"
msgstr ""
"(setq foo 0)\n"
"bar\n"
"     @result{} 0\n"
"foo\n"
"     @result{} 0\n"

#. type: cindex
#: original_texis/variables.texi:1955
#, no-wrap
msgid "lisp variables defined in C, restrictions"
msgstr "lisp variables defined in C, restrictions"

#. type: Plain text
#: original_texis/variables.texi:1966
msgid "Ordinary Lisp variables can be assigned any value that is a valid Lisp object.  However, certain Lisp variables are not defined in Lisp, but in C@.  Most of these variables are defined in the C code using @code{DEFVAR_LISP}.  Like variables defined in Lisp, these can take on any value.  However, some variables are defined using @code{DEFVAR_INT} or @code{DEFVAR_BOOL}.  @xref{Defining Lisp variables in C,, Writing Emacs Primitives}, in particular the description of functions of the type @code{syms_of_@var{filename}}, for a brief discussion of the C implementation."
msgstr "通常のLisp変数には、有効なLispオブジェクトである任意の値を割り当てることができます。しかしLispではなくCで定義されたLisp変数もあります。これらの変数のほとんどは、@code{DEFVAR_LISP}を使用してCコードで定義されています。Lispで定義された変数と同様、これらは任意の値をとることができます。しかしいくつかの変数は@code{DEFVAR_INT}や@code{DEFVAR_BOOL}を使用して定義されています。C実装の概要的な議論は、@ref{Defining Lisp variables in C,, Writing Emacs Primitives}、特に@code{syms_of_@var{filename}}型の関数の説明を参照してください。"

#. type: Plain text
#: original_texis/variables.texi:1970
msgid "Variables of type @code{DEFVAR_BOOL} can only take on the values @code{nil} or @code{t}.  Attempting to assign them any other value will set them to @code{t}:"
msgstr "@code{DEFVAR_BOOL}型の変数は、値に@code{nil}か@code{t}しかとることができません。他の値の割り当てを試みると@code{t}がセットされます:"

#. type: example
#: original_texis/variables.texi:1975
#, no-wrap
msgid ""
"(let ((display-hourglass 5))\n"
"  display-hourglass)\n"
"     @result{} t\n"
msgstr ""
"(let ((display-hourglass 5))\n"
"  display-hourglass)\n"
"     @result{} t\n"

#. type: defvar
#: original_texis/variables.texi:1977
#, no-wrap
msgid "byte-boolean-vars"
msgstr "byte-boolean-vars"

#. type: defvar
#: original_texis/variables.texi:1979
msgid "This variable holds a list of all variables of type @code{DEFVAR_BOOL}."
msgstr "この変数は@code{DEFVAR_BOOL}型のすべての変数のリストを保持する。"

#. type: Plain text
#: original_texis/variables.texi:1983
msgid "Variables of type @code{DEFVAR_INT} can take on only integer values.  Attempting to assign them any other value will result in an error:"
msgstr "@code{DEFVAR_INT}型の変数は、整数値だけをとることができます。他の値の割り当てを試みると結果はエラーになります:"

#. type: example
#: original_texis/variables.texi:1987
#, no-wrap
msgid ""
"(setq undo-limit 1000.0)\n"
"@error{} Wrong type argument: integerp, 1000.0\n"
msgstr ""
"(setq undo-limit 1000.0)\n"
"@error{} Wrong type argument: integerp, 1000.0\n"

#. type: cindex
#: original_texis/variables.texi:1992
#, no-wrap
msgid "generalized variable"
msgstr "generalized variable"

#. type: cindex
#: original_texis/variables.texi:1993
#, no-wrap
msgid "place form"
msgstr "place form"

#. type: Plain text
#: original_texis/variables.texi:1999
msgid "A @dfn{generalized variable} or @dfn{place form} is one of the many places in Lisp memory where values can be stored.  The simplest place form is a regular Lisp variable.  But the @sc{car}s and @sc{cdr}s of lists, elements of arrays, properties of symbols, and many other locations are also places where Lisp values are stored."
msgstr "@dfn{ジェネリック変数(generalized variable： 汎変数)}または@dfn{placeフォーム(place form)}は、値が格納されるLispメモリー内の多くの場所のうちの1つです。1番シンプルなplaceフォームは通常のLisp変数です。しかしリストの@sc{car}と@sc{cdr}、配列の要素、シンボルのプロパティー、その他多くのロケーション(location)もLisp値が格納される場所です。"

#. type: Plain text
#: original_texis/variables.texi:2005
msgid "Generalized variables are analogous to ``lvalues'' in the C language, where @samp{x = a[i]} gets an element from an array and @samp{a[i] = x} stores an element using the same notation.  Just as certain forms like @code{a[i]} can be lvalues in C, there is a set of forms that can be generalized variables in Lisp."
msgstr "ジェネリック変数は、C言語の``lvalues(左辺値)''と類似しています。C言語のlvalueでは、@samp{x = a[i]}で配列から要素を取得し、同じ表記を使用して、@samp{a[i] = x}で要素を格納します。@code{a[i]}のような特定のフォームが、Cではlvalueになれるように、Lispでジェネリック変数になることができる一連のフォームが存在します。"

#. type: node
#: original_texis/variables.texi:2009 original_texis/variables.texi:2011
#, no-wrap
msgid "Setting Generalized Variables"
msgstr "Setting Generalized Variables"

#. type: menuentry
#: original_texis/variables.texi:2009
msgid "The @code{setf} macro."
msgstr "@code{setf}マクロ。"

#. type: node
#: original_texis/variables.texi:2009 original_texis/variables.texi:2102
#, no-wrap
msgid "Adding Generalized Variables"
msgstr "Adding Generalized Variables"

#. type: menuentry
#: original_texis/variables.texi:2009
msgid "Defining new @code{setf} forms."
msgstr "新たな@code{setf}フォームの定義。"

#. type: subsection
#: original_texis/variables.texi:2012
#, no-wrap
msgid "The @code{setf} Macro"
msgstr "The @code{setf} Macro"

#. type: Plain text
#: original_texis/variables.texi:2021
msgid "The @code{setf} macro is the most basic way to operate on generalized variables.  The @code{setf} form is like @code{setq}, except that it accepts arbitrary place forms on the left side rather than just symbols.  For example, @code{(setf (car a) b)} sets the car of @code{a} to @code{b}, doing the same operation as @code{(setcar a b)}, but without having to remember two separate functions for setting and accessing every type of place."
msgstr "@code{setf}マクロはジェネリック変数を操作する、もっとも基本的な方法です。@code{setf}フォームは@code{setq}と似ていますが、シンボルだけでなく左辺の任意のplaceフォームを受け入れます。たとえば@code{(setf (car a) b)}は@code{a}のcarを@code{b}にセットして、@code{(setcar a b)}と同じ操作を行いますが、すべてのplace型へのセットとアクセスを行うために2つの別個の関数を覚える必要はありません。"

#. type: defmac
#: original_texis/variables.texi:2022
#, no-wrap
msgid "setf [place form]@dots{}"
msgstr "setf [place form]@dots{}"

#. type: defmac
#: original_texis/variables.texi:2028
msgid "This macro evaluates @var{form} and stores it in @var{place}, which must be a valid generalized variable form.  If there are several @var{place} and @var{form} pairs, the assignments are done sequentially just as with @code{setq}.  @code{setf} returns the value of the last @var{form}."
msgstr "このマクロは@var{form}を評価して、それを@var{place}に格納する。@var{place}は有効なジェネリック変数フォームでなければならない。複数の@var{place}/@var{form}ペアーがある場合、割り当ては@code{setq}の場合と同様。@code{setf}は最後の@var{form}の値をリターンする。"

#. type: Plain text
#: original_texis/variables.texi:2032
msgid "The following Lisp forms will work as generalized variables, and so may appear in the @var{place} argument of @code{setf}:"
msgstr "以下のLispフォームはジェネリック変数として機能するので、@code{setf}の@var{place}引数にすることができます:"

#. type: itemize
#: original_texis/variables.texi:2042
msgid "A symbol naming a variable.  In other words, @code{(setf x y)} is exactly equivalent to @code{(setq x y)}, and @code{setq} itself is strictly speaking redundant given that @code{setf} exists.  Many programmers continue to prefer @code{setq} for setting simple variables, though, purely for stylistic or historical reasons.  The macro @code{(setf x y)} actually expands to @code{(setq x y)}, so there is no performance penalty for using it in compiled code."
msgstr "変数を命名するシンボル。言い換えると@code{(setf x y)}は完全に@code{(setq x y)}と等しく、厳密に言うと@code{setq}自体は@code{setf}が存在するので冗長である。これは純粋にスタイルと歴史的な理由によるが、多くのプログラマーは依然として単純な変数へのセットに@code{setq}を好む。実際にはマクロ@code{(setf x y)}は@code{(setq x y)}に展開されるので、コンパイルされたコードでこれを使用することにパフォーマンス的な不利はない。"

#. type: itemize
#: original_texis/variables.texi:2045
msgid "A call to any of the following standard Lisp functions:"
msgstr "以下の標準的なLisp関数の呼び出し:"

#. type: smallexample
#: original_texis/variables.texi:2053
#, no-wrap
msgid ""
"aref      cddr      symbol-function\n"
"car       elt       symbol-plist\n"
"caar      get       symbol-value\n"
"cadr      gethash\n"
"cdr       nth\n"
"cdar      nthcdr\n"
msgstr ""
"aref      cddr      symbol-function\n"
"car       elt       symbol-plist\n"
"caar      get       symbol-value\n"
"cadr      gethash\n"
"cdr       nth\n"
"cdar      nthcdr\n"

#. type: itemize
#: original_texis/variables.texi:2057
msgid "A call to any of the following Emacs-specific functions:"
msgstr "以下のEmacs特有な関数の呼び出し:"

#. type: smallexample
#: original_texis/variables.texi:2069
#, no-wrap
msgid ""
"default-value                 process-get\n"
"frame-parameter               process-sentinel\n"
"terminal-parameter            window-buffer\n"
"keymap-parent                 window-display-table\n"
"match-data                    window-dedicated-p\n"
"overlay-get                   window-hscroll\n"
"overlay-start                 window-parameter\n"
"overlay-end                   window-point\n"
"process-buffer                window-start\n"
"process-filter\n"
msgstr ""
"default-value                 process-get\n"
"frame-parameter               process-sentinel\n"
"terminal-parameter            window-buffer\n"
"keymap-parent                 window-display-table\n"
"match-data                    window-dedicated-p\n"
"overlay-get                   window-hscroll\n"
"overlay-start                 window-parameter\n"
"overlay-end                   window-point\n"
"process-buffer                window-start\n"
"process-filter\n"

#. type: Plain text
#: original_texis/variables.texi:2075
msgid "@code{setf} signals an error if you pass a @var{place} form that it does not know how to handle."
msgstr "どのように処理すれば良いか未知な@var{place}フォームを渡すと、@code{setf}はエラーをシグナルします。"

#. type: Plain text
#: original_texis/variables.texi:2082
msgid "Note that for @code{nthcdr}, the list argument of the function must itself be a valid @var{place} form.  For example, @code{(setf (nthcdr 0 foo) 7)} will set @code{foo} itself to 7."
msgstr "@code{nthcdr}の場合、関数のリスト引数はそれ自体が有効な@var{place}フォームでなければならないことに注意してください。たとえば@code{(setf (nthcdr 0 foo) 7)}は、@code{foo}自体に7をセットするでしょう。"

#. type: Plain text
#: original_texis/variables.texi:2096
msgid "The macros @code{push} (@pxref{List Variables}) and @code{pop} (@pxref{List Elements}) can manipulate generalized variables, not just lists.  @code{(pop @var{place})} removes and returns the first element of the list stored in @var{place}.  It is analogous to @code{(prog1 (car @var{place}) (setf @var{place} (cdr @var{place})))}, except that it takes care to evaluate all subforms only once.  @code{(push @var{x} @var{place})} inserts @var{x} at the front of the list stored in @var{place}.  It is analogous to @code{(setf @var{place} (cons @var{x} @var{place}))}, except for evaluation of the subforms.  Note that @code{push} and @code{pop} on an @code{nthcdr} place can be used to insert or delete at any position in a list."
msgstr "マクロ@code{push}(@ref{List Variables}を参照)と@code{pop}(@ref{List Elements}を参照)は、リストだけでなくジェネリック変数を操作できます。@code{(pop @var{place})}は@var{place}内に格納されたリストの最初の要素を削除してリターンします。これは@code{(prog1 (car @var{place}) (setf @var{place} (cdr @var{place})))}と似ていますが、すべてのサブフォームを一度だけ評価します。@code{(push @var{x} @var{place})}は@var{place}内に格納されたリストの1番前に@var{x}を挿入します。これは@code{(setf @var{place} (cons @var{x} @var{place}))}と似ていますが、サブフォームの評価が異なります。@code{nthcdr} placeへの@code{push}と@code{pop}は、リスト内の任意の位置での挿入ち削除に使用できることに注意してください。"

#. type: Plain text
#: original_texis/variables.texi:2100
msgid "The @file{cl-lib} library defines various extensions for generalized variables, including additional @code{setf} places.  @xref{Generalized Variables,,, cl, Common Lisp Extensions}."
msgstr "@file{cl-lib}ライブラリーでは追加の@code{setf} placeを含む、ジェネリック変数にたいするさまざまな拡張が定義されています。@ref{Generalized Variables,,, cl, Common Lisp Extensions}を参照してください。"

#. type: subsection
#: original_texis/variables.texi:2103
#, no-wrap
msgid "Defining new @code{setf} forms"
msgstr "Defining new @code{setf} forms"

#. type: Plain text
#: original_texis/variables.texi:2107
msgid "This section describes how to define new forms that @code{setf} can operate on."
msgstr "このセクションでは、@code{setf}が操作できる新たなフォームの定義方法を説明します。"

#. type: defmac
#: original_texis/variables.texi:2108
#, no-wrap
msgid "gv-define-simple-setter name setter &optional fix-return"
msgstr "gv-define-simple-setter name setter &optional fix-return"

#. type: defmac
#: original_texis/variables.texi:2114
msgid "This macro enables you to easily define @code{setf} methods for simple cases.  @var{name} is the name of a function, macro, or special form.  You can use this macro whenever @var{name} has a directly corresponding @var{setter} function that updates it, e.g., @code{(gv-define-simple-setter car setcar)}."
msgstr "このマクロは単純なケースで@code{setf}メソッドを簡単に定義することを可能にする。@var{name}は関数、マクロ、スペシャルフォームの名前。@var{name}がそれを更新するための対応する@var{setter}関数をもつなら、このマクロを使用できる(たとえば@code{(gv-define-simple-setter car setcar)})。"

#. type: defmac
#: original_texis/variables.texi:2116
msgid "This macro translates a call of the form"
msgstr "このマクロは以下のフォームの呼び出しを"

#. type: example
#: original_texis/variables.texi:2119
#, no-wrap
msgid "(setf (@var{name} @var{args}@dots{}) @var{value})\n"
msgstr "(setf (@var{name} @var{args}@dots{}) @var{value})\n"

#. type: defmac
#: original_texis/variables.texi:2122
msgid "into"
msgstr "以下のように変換する。"

#. type: example
#: original_texis/variables.texi:2124
#, no-wrap
msgid "(@var{setter} @var{args}@dots{} @var{value})\n"
msgstr "(@var{setter} @var{args}@dots{} @var{value})\n"

#. type: defmac
#: original_texis/variables.texi:2133
msgid "Such a @code{setf} call is documented to return @var{value}.  This is no problem with, e.g., @code{car} and @code{setcar}, because @code{setcar} returns the value that it set.  If your @var{setter} function does not return @var{value}, use a non-@code{nil} value for the @var{fix-return} argument of @code{gv-define-simple-setter}.  This expands into something equivalent to"
msgstr "このような@code{setf}の呼び出しは@var{value}をリターンするとドキュメントされている。これは@code{car}と@code{setcar}では問題はない。@code{setcar}はそれがセットする値をリターンするからである。@var{setter}関数が@var{value}をリターンしない場合には、@code{gv-define-simple-setter}の@var{fix-return}引数に、非@code{nil}値を使用すること。これは以下のようなものに展開される"

#. type: example
#: original_texis/variables.texi:2137
#, no-wrap
msgid ""
"(let ((temp @var{value}))\n"
"  (@var{setter} @var{args}@dots{} temp)\n"
"  temp)\n"
msgstr ""
"(let ((temp @var{value}))\n"
"  (@var{setter} @var{args}@dots{} temp)\n"
"  temp)\n"

#. type: defmac
#: original_texis/variables.texi:2139
msgid "so ensuring that it returns the correct result."
msgstr "これで正しい結果がリターンされることが保証される。"

#. type: defmac
#: original_texis/variables.texi:2142
#, no-wrap
msgid "gv-define-setter name arglist &rest body"
msgstr "gv-define-setter name arglist &rest body"

#. type: defmac
#: original_texis/variables.texi:2147
msgid "This macro allows for more complex @code{setf} expansions than the previous form.  You may need to use this form, for example, if there is no simple setter function to call, or if there is one but it requires different arguments to the place form."
msgstr "このマクロは上述のフォームより複雑な@code{setf}展開を可能にする。たとえば呼び出すべきシンプルなsetter関数が存在しないときや、もしそれが存在してもplaceフォームとは異なる引数を要求するなら、このフォームを使う必要があるかもしれない。"

#. type: defmac
#: original_texis/variables.texi:2155
msgid "This macro expands the form @code{(setf (@var{name} @var{args}@dots{}) @var{value})} by first binding the @code{setf} argument forms @code{(@var{value} @var{args}@dots{})} according to @var{arglist}, and then executing @var{body}.  @var{body} should return a Lisp form that does the assignment, and finally returns the value that was set.  An example of using this macro is:"
msgstr "このマクロは最初に@code{setf}引数フォーム@code{(@var{value} @var{args}@dots{})}を@var{arglist}にバインドして、その後@var{body}を実行することによって、フォーム@code{(setf (@var{name} @var{args}@dots{}) @var{value})}を展開する。@var{body}は割り当てを行うLispフォームをリターンして、最終的にはセットされた値をリターンすること。以下はこのマクロの使用例である:"

#. type: example
#: original_texis/variables.texi:2158
#, no-wrap
msgid "(gv-define-setter caar (val x) `(setcar (car ,x) ,val))\n"
msgstr "(gv-define-setter caar (val x) `(setcar (car ,x) ,val))\n"

#. type: findex
#: original_texis/variables.texi:2161
#, no-wrap
msgid "gv-define-expander"
msgstr "gv-define-expander"

#. type: findex
#: original_texis/variables.texi:2162
#, no-wrap
msgid "gv-letplace"
msgstr "gv-letplace"

#. type: Plain text
#: original_texis/variables.texi:2169
msgid "For more control over the expansion, see the macro @code{gv-define-expander}.  The macro @code{gv-letplace} can be useful in defining macros that perform similarly to @code{setf}; for example, the @code{incf} macro of Common Lisp.  Consult the source file @file{gv.el} for more details."
msgstr "展開をさらに制御するならマクロ@code{gv-define-expander}を参照してください。マクロ@code{gv-letplace}は@code{setf}のような処理を行うマクロを定義するのに有用です。詳細は@file{gv.el}のソースファイルを参照してください。"

#. type: cindex
#: original_texis/variables.texi:2170
#, no-wrap
msgid "CL note---no @code{setf} functions"
msgstr "CL note---no @code{setf} functions"

#. type: quotation
#: original_texis/variables.texi:2181
msgid "@b{Common Lisp note:} Common Lisp defines another way to specify the @code{setf} behavior of a function, namely ``@code{setf} functions'', whose names are lists @code{(setf @var{name})} rather than symbols.  For example, @code{(defun (setf foo) @dots{})} defines the function that is used when @code{setf} is applied to @code{foo}.  Emacs does not support this.  It is a compile-time error to use @code{setf} on a form that has not already had an appropriate expansion defined.  In Common Lisp, this is not an error since the function @code{(setf @var{func})} might be defined later."
msgstr "@b{Common Lispに関する注意:} Common Lispは関数の@code{setf}、すなわち``@code{setf}関数''の挙動を指定するための別の方法を定義します。@code{setf}関数の名前はシンボルではなく。リスト@code{(setf @var{name})}です。たとえば@code{(defun (setf foo) @dots{})}は、@code{setf}が@code{foo}に適用されるときに使用される関数を定義します。Emacsはこれをサポートしません。適切な展開が定義されていないフォームに@code{setf}を使用すると、コンパイル時にエラーとなります。Common Lispでは、関数@code{(setf @var{func})}が後で定義されるので、エラーにはなりません。"
