# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Emacs 26.1-\n"
"POT-Creation-Date: 2020-08-02 05:45+0900\n"
"PO-Revision-Date: 2020-07-13 22:50+0900\n"
"Last-Translator: Takeshi Ayanokoji <takeshi.ayanokoji@gmail.com>\n"
"Language-Team: Japanese <takeshi.ayanokoji@gmail.com>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: original_texis/variables.texi:5 original_texis/variables.texi:6
#, no-wrap
msgid "Variables"
msgstr "Variables"

#. type: cindex
#: original_texis/variables.texi:7
#, no-wrap
msgid "variable"
msgstr "variable"

#. type: Plain text
#: original_texis/variables.texi:18
msgid "A @dfn{variable} is a name used in a program to stand for a value.  In Lisp, each variable is represented by a Lisp symbol (@pxref{Symbols}).  The variable name is simply the symbol's name, and the variable's value is stored in the symbol's value cell@footnote{To be precise, under the default @dfn{dynamic scoping} rule, the value cell always holds the variable's current value, but this is not the case under the @dfn{lexical scoping} rule.  @xref{Variable Scoping}, for details.}.  @xref{Symbol Components}.  In Emacs Lisp, the use of a symbol as a variable is independent of its use as a function name."
msgstr "@dfn{変数(variable)}とはプログラム内で値を表すために使用される名前です。Lispでは変数はそれぞれLispシンボルとして表されます(@ref{Symbols}を参照)。変数名は単にそのシンボルの名前であり、変数の値はそのシンボルの値セル(value cell)に格納されます@footnote{正確に言うとデフォルトの@dfn{ダイナミックスコープ(dynamic scoping)}のルールでは、値セルは常にその変数のカレント値を保持しますが、@dfn{レキシカルスコープ(lexical scoping)}では異なります。詳細は@ref{Variable Scoping}を参照してください。}。@ref{Symbol Components}を参照してください。Emacs Lispではシンボルを変数として使用することは、同じシンボルを関数名として使用することと関係ありません。"

#. type: Plain text
#: original_texis/variables.texi:25
msgid "As previously noted in this manual, a Lisp program is represented primarily by Lisp objects, and only secondarily as text.  The textual form of a Lisp program is given by the read syntax of the Lisp objects that constitute the program.  Hence, the textual form of a variable in a Lisp program is written using the read syntax for the symbol representing the variable."
msgstr "このマニュアルで前述したとおり、Lispプログラムはまず第1にLispオブジェクトとして表され、副次的にテキストとして表現されます。Lispプログラムのテキスト的な形式は、そのプログラムを構成するLispオブジェクトの入力構文により与えられます。したがってLispプログラム内の変数のテキスト的な形式は、その変数を表すシンボルの入力構文を使用して記述されます。"

#. type: section
#: original_texis/variables.texi:47 original_texis/variables.texi:49
#: original_texis/variables.texi:50
#, no-wrap
msgid "Global Variables"
msgstr "Global Variables"

#. type: menuentry
#: original_texis/variables.texi:47
msgid "Variable values that exist permanently, everywhere."
msgstr "どの場所でも永続的に存在する変数の値。"

#. type: node
#: original_texis/variables.texi:47 original_texis/variables.texi:101
#, no-wrap
msgid "Constant Variables"
msgstr "Constant Variables"

#. type: menuentry
#: original_texis/variables.texi:47
msgid "Variables that never change."
msgstr "Variables that never change."

#. type: section
#: original_texis/variables.texi:47 original_texis/variables.texi:149
#: original_texis/variables.texi:150
#, no-wrap
msgid "Local Variables"
msgstr "Local Variables"

#. type: menuentry
#: original_texis/variables.texi:47
msgid "Variable values that exist only temporarily."
msgstr "一時的にのみ存在する存在する変数の値。"

#. type: node
#: original_texis/variables.texi:47 original_texis/variables.texi:330
#, no-wrap
msgid "Void Variables"
msgstr "Void Variables"

#. type: menuentry
#: original_texis/variables.texi:47
msgid "Symbols that lack values."
msgstr "値を持たないシンボル。"

#. type: node
#: original_texis/variables.texi:47 original_texis/variables.texi:426
#, no-wrap
msgid "Defining Variables"
msgstr "Defining Variables"

#. type: menuentry
#: original_texis/variables.texi:47
msgid "A definition says a symbol is used as a variable."
msgstr "シンボルが変数として使用されていることを宣言する定義。"

#. type: node
#: original_texis/variables.texi:47 original_texis/variables.texi:571
#, no-wrap
msgid "Tips for Defining"
msgstr "Tips for Defining"

#. type: menuentry
#: original_texis/variables.texi:47
msgid "Things you should think about when you define a variable."
msgstr "変数を定義するときに考慮すべき事項。"

#. type: node
#: original_texis/variables.texi:47 original_texis/variables.texi:671
#, no-wrap
msgid "Accessing Variables"
msgstr "Accessing Variables"

#. type: menuentry
#: original_texis/variables.texi:47
msgid "Examining values of variables whose names are known only at run time."
msgstr "実行時に判明する名前をもつ変数の値を確認する。"

#. type: node
#: original_texis/variables.texi:47 original_texis/variables.texi:727
#, no-wrap
msgid "Setting Variables"
msgstr "Setting Variables"

#. type: menuentry
#: original_texis/variables.texi:47
msgid "Storing new values in variables."
msgstr "変数に新しい値を格納する。"

#. type: node
#: original_texis/variables.texi:47 original_texis/variables.texi:829
#, no-wrap
msgid "Watching Variables"
msgstr "Watching Variables"

#. type: section
#: original_texis/variables.texi:47 original_texis/variables.texi:830
#, no-wrap
msgid "Running a function when a variable is changed."
msgstr "変数が変更されたときに実行される関数。"

#. type: node
#: original_texis/variables.texi:47 original_texis/variables.texi:891
#, no-wrap
msgid "Variable Scoping"
msgstr "Variable Scoping"

#. type: menuentry
#: original_texis/variables.texi:47
msgid "How Lisp chooses among local and global values."
msgstr "Lispがローカル値とグローバル値を選択する方法。"

#. type: section
#: original_texis/variables.texi:47 original_texis/variables.texi:1272
#: original_texis/variables.texi:1273
#, no-wrap
msgid "Buffer-Local Variables"
msgstr "Buffer-Local Variables"

#. type: menuentry
#: original_texis/variables.texi:47
msgid "Variable values in effect only in one buffer."
msgstr "1つのバッファーないだけで効果をもつ変数の値。"

#. type: section
#: original_texis/variables.texi:47 original_texis/variables.texi:1785
#: original_texis/variables.texi:1786
#, no-wrap
msgid "File Local Variables"
msgstr "File Local Variables"

#. type: menuentry
#: original_texis/variables.texi:47
msgid "Handling local variable lists in files."
msgstr "ファイル内にリストされたローカル変数の処理。"

#. type: section
#: original_texis/variables.texi:47 original_texis/variables.texi:1993
#: original_texis/variables.texi:1994
#, no-wrap
msgid "Directory Local Variables"
msgstr "Directory Local Variables"

#. type: menuentry
#: original_texis/variables.texi:47
msgid "Local variables common to all files in a directory."
msgstr "ディレクトリー内のすべてのファイルで共通のローカル変数。"

#. type: section
#: original_texis/variables.texi:47 original_texis/variables.texi:2104
#: original_texis/variables.texi:2105
#, no-wrap
msgid "Connection Local Variables"
msgstr "Connection Local Variables"

#. type: menuentry
#: original_texis/variables.texi:47
msgid "Local variables common for remote connections."
msgstr "リモート接続で共通なローカル変数。"

#. type: section
#: original_texis/variables.texi:47 original_texis/variables.texi:2273
#: original_texis/variables.texi:2274
#, no-wrap
msgid "Variable Aliases"
msgstr "Variable Aliases"

#. type: menuentry
#: original_texis/variables.texi:47
msgid "Variables that are aliases for other variables."
msgstr "他の変数のエイリアスとなる変数。"

#. type: section
#: original_texis/variables.texi:47 original_texis/variables.texi:2366
#: original_texis/variables.texi:2367
#, no-wrap
msgid "Variables with Restricted Values"
msgstr "Variables with Restricted Values"

#. type: menuentry
#: original_texis/variables.texi:47
msgid "Non-constant variables whose value can @emph{not} be an arbitrary Lisp object."
msgstr "任意のLispオブジェクトを値とすることが@emph{できない}、定数ではない変数。"

#. type: section
#: original_texis/variables.texi:47 original_texis/variables.texi:2402
#: original_texis/variables.texi:2403
#, no-wrap
msgid "Generalized Variables"
msgstr "Generalized Variables"

#. type: menuentry
#: original_texis/variables.texi:47
msgid "Extending the concept of variables."
msgstr "変数の概念の拡張。"

#. type: cindex
#: original_texis/variables.texi:51
#, no-wrap
msgid "global variable"
msgstr "global variable"

#. type: Plain text
#: original_texis/variables.texi:58
msgid "The simplest way to use a variable is @dfn{globally}.  This means that the variable has just one value at a time, and this value is in effect (at least for the moment) throughout the Lisp system.  The value remains in effect until you specify a new one.  When a new value replaces the old one, no trace of the old value remains in the variable."
msgstr "変数を使用するための一番シンプルな方法は、@dfn{グローバル(globally)}を使用する方法です。これはある時点でその変数はただ1つの値をもち、その値が(少なくともその時点では)Lispシステム全体で効果をもつことを意味します。あらたな値を指定するまでその値が効果をもちます。新しい値で古い値を置き換えるとき、古い値を追跡する情報は変数内に残りません。"

#. type: Plain text
#: original_texis/variables.texi:60
msgid "You specify a value for a symbol with @code{setq}.  For example,"
msgstr "シンボルの値は@code{setq}で指定します。たとえば、"

#. type: example
#: original_texis/variables.texi:63
#, no-wrap
msgid "(setq x '(a b))\n"
msgstr "(setq x '(a b))\n"

#. type: Plain text
#: original_texis/variables.texi:70
msgid "gives the variable @code{x} the value @code{(a b)}.  Note that @code{setq} is a special form (@pxref{Special Forms}); it does not evaluate its first argument, the name of the variable, but it does evaluate the second argument, the new value."
msgstr "これは変数@code{x}に値@code{(a b)}を与えます。@code{setq}はスペシャルフォームであることに注意してください。これは1番目の引数(変数の名前)は評価しませんが、2番目の引数(新しい値)は評価します。"

#. type: Plain text
#: original_texis/variables.texi:73
msgid "Once the variable has a value, you can refer to it by using the symbol itself as an expression.  Thus,"
msgstr "変数が一度値をもつと、そのシンボル自身を式として使用することによって参照することができます。したがって、"

#. type: group
#: original_texis/variables.texi:77
#, no-wrap
msgid "x @result{} (a b)\n"
msgstr "x @result{} (a b)\n"

#. type: Plain text
#: original_texis/variables.texi:82
msgid "assuming the @code{setq} form shown above has already been executed."
msgstr "これは上記の@code{setq}フォームが実行された場合です。"

#. type: Plain text
#: original_texis/variables.texi:85
msgid "If you do set the same variable again, the new value replaces the old one:"
msgstr "同じ変数を再びセットすると、古い値は新しい値で置き換えられます:"

#. type: group
#: original_texis/variables.texi:90
#, no-wrap
msgid ""
"x\n"
"     @result{} (a b)\n"
msgstr ""
"x\n"
"     @result{} (a b)\n"

#. type: group
#: original_texis/variables.texi:94
#, no-wrap
msgid ""
"(setq x 4)\n"
"     @result{} 4\n"
msgstr ""
"(setq x 4)\n"
"     @result{} 4\n"

#. type: group
#: original_texis/variables.texi:98
#, no-wrap
msgid ""
"x\n"
"     @result{} 4\n"
msgstr ""
"x\n"
"     @result{} 4\n"

#. type: section
#: original_texis/variables.texi:102
#, no-wrap
msgid "Variables that Never Change"
msgstr "Variables that Never Change"

#. type: cindex
#: original_texis/variables.texi:103
#, no-wrap
msgid "@code{setting-constant} error"
msgstr "@code{setting-constant} error"

#. type: cindex
#: original_texis/variables.texi:104
#, no-wrap
msgid "keyword symbol"
msgstr "keyword symbol"

#. type: cindex
#: original_texis/variables.texi:105
#, no-wrap
msgid "variable with constant value"
msgstr "variable with constant value"

#. type: cindex
#: original_texis/variables.texi:106 original_texis/variables.texi:521
#, no-wrap
msgid "constant variables"
msgstr "constant variables"

#. type: cindex
#: original_texis/variables.texi:107
#, no-wrap
msgid "symbol that evaluates to itself"
msgstr "symbol that evaluates to itself"

#. type: cindex
#: original_texis/variables.texi:108
#, no-wrap
msgid "symbol with constant value"
msgstr "symbol with constant value"

#. type: Plain text
#: original_texis/variables.texi:118
msgid "In Emacs Lisp, certain symbols normally evaluate to themselves.  These include @code{nil} and @code{t}, as well as any symbol whose name starts with @samp{:} (these are called @dfn{keywords}).  These symbols cannot be rebound, nor can their values be changed.  Any attempt to set or bind @code{nil} or @code{t} signals a @code{setting-constant} error.  The same is true for a keyword (a symbol whose name starts with @samp{:}), if it is interned in the standard obarray, except that setting such a symbol to itself is not an error."
msgstr "Emacs Lispでは特定のシンボルは、通常は自分自身に評価されます。これらのシンボルには@code{nil}と@code{t}、同様に名前が@samp{:}で始まる任意のシンボル(これらは@dfn{キーワード}と呼ばれる)が含まれます。これらのシンボルはリバインドや、値の変更はできません。@code{nil}や@code{t}へのセットやリバインドは、@code{setting-constant}エラーをシグナルします。これはキーワード(名前が@samp{:}で始まるシンボル)についても当てはまります。ただしキーワードが標準のobarrayにinternされていれば、そのようなシンボルを自分自身にセットしてもエラーになりません。"

#. type: group
#: original_texis/variables.texi:123
#, no-wrap
msgid ""
"nil @equiv{} 'nil\n"
"     @result{} nil\n"
msgstr ""
"nil @equiv{} 'nil\n"
"     @result{} nil\n"

#. type: group
#: original_texis/variables.texi:127
#, no-wrap
msgid ""
"(setq nil 500)\n"
"@error{} Attempt to set constant symbol: nil\n"
msgstr ""
"(setq nil 500)\n"
"@error{} Attempt to set constant symbol: nil\n"

#. type: defun
#: original_texis/variables.texi:130
#, no-wrap
msgid "keywordp object"
msgstr "keywordp object"

#. type: defun
#: original_texis/variables.texi:134
msgid "function returns @code{t} if @var{object} is a symbol whose name starts with @samp{:}, interned in the standard obarray, and returns @code{nil} otherwise."
msgstr "この関数は@var{object}が@samp{:}で始まる名前のシンボルであり、標準のobarrayにinternされていれば@code{t}、それ以外は@code{nil}をリターンする。"

#. type: Plain text
#: original_texis/variables.texi:141
msgid "These constants are fundamentally different from the constants defined using the @code{defconst} special form (@pxref{Defining Variables}).  A @code{defconst} form serves to inform human readers that you do not intend to change the value of a variable, but Emacs does not raise an error if you actually change it."
msgstr "これらの定数はスペシャルフォーム@code{defconst}(@ref{Defining Variables}を参照)を使用して定義された定数(constant)とは根本的に異なります。@code{defconst}フォームは、人間の読み手に値の変更を意図しない変数であることを知らせる役目は果たしますが、実際にそれを変更してもEmacsはエラーを起こしません。"

#. type: cindex
#: original_texis/variables.texi:142
#, no-wrap
msgid "read-only variables"
msgstr "read-only variables"

#. type: Plain text
#: original_texis/variables.texi:148
msgid "A small number of additional symbols are made read-only for various practical reasons.  These include @code{enable-multibyte-characters}, @code{most-positive-fixnum}, @code{most-negative-fixnum}, and a few others.  Any attempt to set or bind these also signals a @code{setting-constant} error."
msgstr "現実的な種々の理由により、追加で少数のシンボルが読み取り専用になります。これらには@code{enable-multibyte-characters}、@code{most-positive-fixnum}、@code{most-negative-fixnum}の他にいくつかのシンボルが含まれます。これらにたいしてセットやバインドを試みると、すべて@code{setting-constant}エラーがシグナルされます。"

#. type: cindex
#: original_texis/variables.texi:151
#, no-wrap
msgid "binding local variables"
msgstr "binding local variables"

#. type: cindex
#: original_texis/variables.texi:152
#, no-wrap
msgid "local variables"
msgstr "local variables"

#. type: cindex
#: original_texis/variables.texi:153
#, no-wrap
msgid "local binding"
msgstr "local binding"

#. type: cindex
#: original_texis/variables.texi:154
#, no-wrap
msgid "global binding"
msgstr "global binding"

#. type: Plain text
#: original_texis/variables.texi:162
msgid "Global variables have values that last until explicitly superseded with new values.  Sometimes it is useful to give a variable a @dfn{local value}---a value that takes effect only within a certain part of a Lisp program.  When a variable has a local value, we say that it is @dfn{locally bound} to that value, and that it is a @dfn{local variable}."
msgstr "グローバル変数は新しい値で明示的に置き換えるまで値が持続します。変数に@dfn{ローカル値(local value)} --- Lispプログラム内の特定の部分で効果をもつ --- を与えると便利なときがあります。変数がローカル値をもつとき、わたしたちは変数がその値に@dfn{ローカルにバインド(locally bound)}されていると言い、その変数を@dfn{ローカル変数(local variable)}と呼びます。"

#. type: Plain text
#: original_texis/variables.texi:169
msgid "For example, when a function is called, its argument variables receive local values, which are the actual arguments supplied to the function call; these local bindings take effect within the body of the function.  To take another example, the @code{let} special form explicitly establishes local bindings for specific variables, which take effect only within the body of the @code{let} form."
msgstr "たとえば関数が呼び出されるとき、関数の引数となる変数はローカル値(その関数の呼び出しにおいて実際の引数に与えられた値)を受け取ります。これらのローカルバインディングは関数のbody内で効果をもちます。他にもたとえばスペシャルフォーム@code{let}は特定の変数にたいして明示的にローカルなバインディングを確立して、これは@code{let}フォームのbody内だけで効果を持ちます。"

#. type: Plain text
#: original_texis/variables.texi:172
msgid "We also speak of the @dfn{global binding}, which is where (conceptually) the global value is kept."
msgstr "これにたいして@dfn{グローバルなバインディング(global binding)}とは、(概念的には)グローバルな値が保持される場所です。"

#. type: cindex
#: original_texis/variables.texi:173
#, no-wrap
msgid "shadowing of variables"
msgstr "shadowing of variables"

#. type: Plain text
#: original_texis/variables.texi:181
msgid "Establishing a local binding saves away the variable's previous value (or lack of one).  We say that the previous value is @dfn{shadowed}.  Both global and local values may be shadowed.  If a local binding is in effect, using @code{setq} on the local variable stores the specified value in the local binding.  When that local binding is no longer in effect, the previously shadowed value (or lack of one) comes back."
msgstr "ローカルバインディングを確立すると、その変数の以前の値は他の場所に保存されます(または失われる)。わたしたちはこれを、以前の値が@dfn{シャドー(shadowed)}されたと言います。シャドーはグローバル変数とローカル変数の両方で発生し得ます。ローカルバインディングが効果を持つときには、ローカル変数に@code{setq}を使用することにより、指定した値をローカルバインディングに格納します。ローカルバインディングが効果を持たなくなったとき、以前にシャドーされた値が復元されます(または失われる)。"

#. type: cindex
#: original_texis/variables.texi:182
#, no-wrap
msgid "current binding"
msgstr "current binding"

#. type: Plain text
#: original_texis/variables.texi:188
msgid "A variable can have more than one local binding at a time (e.g., if there are nested @code{let} forms that bind the variable).  The @dfn{current binding} is the local binding that is actually in effect.  It determines the value returned by evaluating the variable symbol, and it is the binding acted on by @code{setq}."
msgstr "変数は同時に複数のローカルバインディングを持つことができます(たとえばその変数をバインドするネストされた@code{let})。@dfn{カレントバインディング(current binding)}とは、実際に効果を持つローカルバインディングのことです。カレントバインディングは、その変数の評価によりリターンされる値を決定し、@code{setq}により影響を受けるバインディングです。"

#. type: Plain text
#: original_texis/variables.texi:199
msgid "For most purposes, you can think of the current binding as the innermost local binding, or the global binding if there is no local binding.  To be more precise, a rule called the @dfn{scoping rule} determines where in a program a local binding takes effect.  The default scoping rule in Emacs Lisp is called @dfn{dynamic scoping}, which simply states that the current binding at any given point in the execution of a program is the most recently-created binding for that variable that still exists.  For details about dynamic scoping, and an alternative scoping rule called @dfn{lexical scoping}, @xref{Variable Scoping}."
msgstr "ほとんどの用途において、最内(innermost)のローカルバインディングとローカルバインディングをもたないグローバルバインディングを、カレントバインディングと考えることができます。より正確に言うと、@dfn{スコープルール(scoping rule)}と呼ばれるルールは、プログラム内でローカルバインディングが効果を持つ任意の与えられた場所を決定します。Emacs Lispのスコープルールは@dfn{ダイナミックスコープ(dynamic scoping)}と呼ばれ、これは単に実行中のプログラム内の与えられた位置でのカレントバインディングを示しており、その変数がまだ存在すれば、その変数にたいしてもっとも最近作成されたバインディングです。ダイナミックスコープについての詳細、およびその代替である@dfn{レキシカルスコープ(lexical scoping)}と呼ばれるスコープルールについては、@ref{Variable Scoping}を参照してください。"

#. type: Plain text
#: original_texis/variables.texi:202
msgid "The special forms @code{let} and @code{let*} exist to create local bindings:"
msgstr "スペシャルフォーム@code{let}と@code{let*}は、ローカルバインディングを作成するために存在します:"

#. type: defspec
#: original_texis/variables.texi:203
#, no-wrap
msgid "let (bindings@dots{}) forms@dots{}"
msgstr "let (bindings@dots{}) forms@dots{}"

#. type: defspec
#: original_texis/variables.texi:209
msgid "This special form sets up local bindings for a certain set of variables, as specified by @var{bindings}, and then evaluates all of the @var{forms} in textual order.  Its return value is the value of the last form in @var{forms}.  The local bindings set up by @code{let} will be in effect only within the body of @var{forms}."
msgstr "このスペシャルフォームは@var{bindings}により指定される特定の変数セットにたいするローカルバインディングをセットアップしてから、@var{forms}のすべてをテキスト順に評価する。これは@var{forms}内の最後のフォームの値をリターンする。@code{let}がセットアップしたローカルバインディングは@var{forms}のbody内でのみ効果をもつ。"

#. type: defspec
#: original_texis/variables.texi:215
msgid "Each of the @var{bindings} is either @w{(i) a} symbol, in which case that symbol is locally bound to @code{nil}; or @w{(ii) a} list of the form @code{(@var{symbol} @var{value-form})}, in which case @var{symbol} is locally bound to the result of evaluating @var{value-form}.  If @var{value-form} is omitted, @code{nil} is used."
msgstr "@var{bindings}の各バインディングは2つの形式のいずれかである。@w{(i)} シンボルなら、そのシンボルは@code{nil}にローカルにバインドされる。@w{(ii)} フォーム@code{(@var{symbol} @var{value-form})}のリストなら、@var{symbol}は@var{value-form}を評価した結果へローカルにバインドされる。@var{value-form}が省略されたら@code{nil}が使用される。"

#. type: defspec
#: original_texis/variables.texi:220
msgid "All of the @var{value-form}s in @var{bindings} are evaluated in the order they appear and @emph{before} binding any of the symbols to them.  Here is an example of this: @code{z} is bound to the old value of @code{y}, which is 2, not the new value of @code{y}, which is 1."
msgstr "@var{bindings}内のすべての@var{value-form}は、シンボルがそれらにバインドされる@emph{前}に、記述された順番に評価される。以下の例では@code{z}は@code{y}の新しい値(つまり1)にではなく、古い値(つまり2)にバインドされる。"

#. type: group
#: original_texis/variables.texi:225 original_texis/variables.texi:259
#, no-wrap
msgid ""
"(setq y 2)\n"
"     @result{} 2\n"
msgstr ""
"(setq y 2)\n"
"     @result{} 2\n"

#. type: group
#: original_texis/variables.texi:232
#, no-wrap
msgid ""
"(let ((y 1)\n"
"      (z y))\n"
"  (list y z))\n"
"     @result{} (1 2)\n"
msgstr ""
"(let ((y 1)\n"
"      (z y))\n"
"  (list y z))\n"
"     @result{} (1 2)\n"

#. type: defspec
#: original_texis/variables.texi:237
msgid "On the other hand, the order of @emph{bindings} is unspecified: in the following example, either 1 or 2 might be printed."
msgstr "その一方で@emph{bindings}の順序は指定されない。以下の例では1か2のどちらかがプリントされる。"

#. type: example
#: original_texis/variables.texi:242
#, no-wrap
msgid ""
"(let ((x 1)\n"
"      (x 2))\n"
"  (print x))\n"
msgstr ""
"(let ((x 1)\n"
"      (x 2))\n"
"  (print x))\n"

#. type: defspec
#: original_texis/variables.texi:246
msgid "Therefore, avoid binding a variable more than once in a single @code{let} form."
msgstr "したがって単一の@code{let}フォーム内で変数を複数回バインディングするのは避けること。"

#. type: defspec
#: original_texis/variables.texi:248
#, no-wrap
msgid "let* (bindings@dots{}) forms@dots{}"
msgstr "let* (bindings@dots{}) forms@dots{}"

#. type: defspec
#: original_texis/variables.texi:254
msgid "This special form is like @code{let}, but it binds each variable right after computing its local value, before computing the local value for the next variable.  Therefore, an expression in @var{bindings} can refer to the preceding symbols bound in this @code{let*} form.  Compare the following example with the example above for @code{let}."
msgstr "このスペシャルフォームは@code{let}と似ているが、次の変数値にたいするローカル値を計算する前に、ローカル値を計算してそれを変数にバインドする。したがて@var{bindings}内の式は、この@code{let*}フォーム内の前のシンボルのバインドを参照できる。以下の例を上記@code{let}の例と比較されたい。"

#. type: group
#: original_texis/variables.texi:266
#, no-wrap
msgid ""
"(let* ((y 1)\n"
"       (z y))    ; @r{Use the just-established value of @code{y}.}\n"
"  (list y z))\n"
"     @result{} (1 1)\n"
msgstr ""
"(let* ((y 1)\n"
"       (z y))    ; @r{@code{y}の値に今計算されたばかりの値を使用する}\n"
"  (list y z))\n"
"     @result{} (1 1)\n"

#. type: defspec
#: original_texis/variables.texi:270
#, fuzzy, no-wrap
#| msgid "let (bindings@dots{}) forms@dots{}"
msgid "letrec (bindings@dots{}) forms@dots{}"
msgstr "let (bindings@dots{}) forms@dots{}"

#. type: defspec
#: original_texis/variables.texi:277
msgid "This special form is like @code{let*}, but all the variables are bound before any of the local values are computed.  The values are then assigned to the locally bound variables.  This is only useful when lexical binding is in effect, and you want to create closures that refer to bindings that would otherwise not yet be in effect when using @code{let*}."
msgstr ""

#. type: defspec
#: original_texis/variables.texi:280
msgid "For instance, here's a closure that removes itself from a hook after being run once:"
msgstr ""

#. type: lisp
#: original_texis/variables.texi:286
#, no-wrap
msgid ""
"(letrec ((hookfun (lambda ()\n"
"                    (message \"Run once\")\n"
"                    (remove-hook 'post-command-hook hookfun))))\n"
"  (add-hook 'post-command-hook hookfun))\n"
msgstr ""

#. type: Plain text
#: original_texis/variables.texi:291
msgid "Here is a complete list of the other facilities that create local bindings:"
msgstr "以下はローカルバインディングを作成する他の機能のリストです:"

#. type: itemize
#: original_texis/variables.texi:295
msgid "Function calls (@pxref{Functions})."
msgstr "関数呼び出し(@ref{Functions}を参照)。"

#. type: itemize
#: original_texis/variables.texi:298
msgid "Macro calls (@pxref{Macros})."
msgstr "マクロ呼び出し(@ref{Macros}を参照)。"

#. type: itemize
#: original_texis/variables.texi:301
msgid "@code{condition-case} (@pxref{Errors})."
msgstr "@code{condition-case} (@ref{Errors}を参照)。"

#. type: Plain text
#: original_texis/variables.texi:308
msgid "Variables can also have buffer-local bindings (@pxref{Buffer-Local Variables}); a few variables have terminal-local bindings (@pxref{Multiple Terminals}).  These kinds of bindings work somewhat like ordinary local bindings, but they are localized depending on where you are in Emacs."
msgstr "変数はバッファーローカルなバインディングを持つこともできます(@ref{Buffer-Local Variables}を参照)。数は多くありませんが、端末ローカル(terminal-local)なバインディングをもつ変数もあります(@ref{Multiple Terminals}を参照)。この種のバインディングは、通常のローカルバインディングのように機能することもありますが、これらはEmacs内のどこにいるかに依存してローカルになります。"

#. type: defopt
#: original_texis/variables.texi:309
#, no-wrap
msgid "max-specpdl-size"
msgstr "max-specpdl-size"

#. type: anchor{#1}
#: original_texis/variables.texi:311
msgid "Definition of max-specpdl-size"
msgstr "Definition of max-specpdl-size"

#. type: cindex
#: original_texis/variables.texi:311
#, no-wrap
msgid "variable limit error"
msgstr "variable limit error"

#. type: cindex
#: original_texis/variables.texi:312
#, no-wrap
msgid "evaluation error"
msgstr "evaluation error"

#. type: cindex
#: original_texis/variables.texi:313
#, no-wrap
msgid "infinite recursion"
msgstr "infinite recursion"

#. type: defopt
#: original_texis/variables.texi:319
msgid "This variable defines the limit on the total number of local variable bindings and @code{unwind-protect} cleanups (see @ref{Cleanups,, Cleaning Up from Nonlocal Exits}) that are allowed before Emacs signals an error (with data @code{\"Variable binding depth exceeds max-specpdl-size\"})."
msgstr "この変数はローカルな変数バインディングと、@code{unwind-protect}にゆるクリーンアップ(@ref{Cleanups,, Cleaning Up from Nonlocal Exits}を参照)の総数にたいする制限を定義し、この変数を越えるとEmacsは(データ@code{\"Variable binding depth exceeds max-specpdl-size\"}とともに)エラーをシグナルする。"

#. type: defopt
#: original_texis/variables.texi:324
msgid "This limit, with the associated error when it is exceeded, is one way that Lisp avoids infinite recursion on an ill-defined function.  @code{max-lisp-eval-depth} provides another limit on depth of nesting.  @xref{Definition of max-lisp-eval-depth,, Eval}."
msgstr "このリミットは、もし超過したときにエラーが関連付けられていれば、誤って定義された関数による無限再起を避けるための1つの手段になる。ネストの深さにたいする他の制限としては、@code{max-lisp-eval-depth}がある。@ref{Definition of max-lisp-eval-depth,, Eval}を参照のこと。"

#. type: defopt
#: original_texis/variables.texi:328
#, fuzzy
#| msgid "The default value is 1300.  Entry to the Lisp debugger increases the value, if there is little room left, to make sure the debugger itself has room to execute."
msgid "The default value is 1600.  Entry to the Lisp debugger increases the value, if there is little room left, to make sure the debugger itself has room to execute."
msgstr "デフォルト値は1300。Lispデバッガーのエントリーしたとき、もし残りが少なければ、デバッガーを実行するための空きを作るために値が増加される。"

#. type: section
#: original_texis/variables.texi:331
#, no-wrap
msgid "When a Variable is Void"
msgstr "When a Variable is Void"

#. type: cindex
#: original_texis/variables.texi:332
#, no-wrap
msgid "@code{void-variable} error"
msgstr "@code{void-variable} error"

#. type: cindex
#: original_texis/variables.texi:333
#, no-wrap
msgid "void variable"
msgstr "void variable"

#. type: Plain text
#: original_texis/variables.texi:337
msgid "We say that a variable is void if its symbol has an unassigned value cell (@pxref{Symbol Components})."
msgstr "シンボルの値セル(@ref{Symbol Components}を参照)に値が割り当てられていない場合、その変数はvoid(空)であると言います。"

#. type: Plain text
#: original_texis/variables.texi:346
msgid "Under Emacs Lisp's default dynamic scoping rule (@pxref{Variable Scoping}), the value cell stores the variable's current (local or global) value.  Note that an unassigned value cell is @emph{not} the same as having @code{nil} in the value cell.  The symbol @code{nil} is a Lisp object and can be the value of a variable, just as any other object can be; but it is still a value.  If a variable is void, trying to evaluate the variable signals a @code{void-variable} error, instead of returning a value."
msgstr "Emacs Lispのデフォルトであるダイナミックスコープルール(@ref{Variable Scoping}を参照)の下では、値セルはその変数のカレント値(ローカルまたはグローバル)を保持します。値が割り当てられていない値セルは、値セルに@code{nil}をもつのとは@emph{異なる}ことに注意してください。シンボル@code{nil}はLispオブジェクトであり、他のオブジェクトと同様に変数の値となることができます。@code{nil}は値なのです。変数がvoidの場合にその変数の評価を試みると、値をリターンするかわりに、@code{void-variable}エラーがシグナルされます。"

#. type: Plain text
#: original_texis/variables.texi:352
msgid "Under the optional lexical scoping rule, the value cell only holds the variable's global value---the value outside of any lexical binding construct.  When a variable is lexically bound, the local value is determined by the lexical environment; hence, variables can have local values even if their symbols' value cells are unassigned."
msgstr "オプションであるレキシカルスコープルール(lexical scoping rule)の下では、値セル保持できるのはその変数のグローバル値 --- 任意のレキシカルバインディング構造の外側の値だけです。変数がレキシカルにバインドされている場合、ローカル値はそのレキシカル環境により決定されます。したがってこれらのシンボルの値セルに値が割り当てられていなくても、変数はローカル値を持つことができます。"

#. type: defun
#: original_texis/variables.texi:353
#, no-wrap
msgid "makunbound symbol"
msgstr "makunbound symbol"

#. type: defun
#: original_texis/variables.texi:356
msgid "This function empties out the value cell of @var{symbol}, making the variable void.  It returns @var{symbol}."
msgstr "この関数は@var{symbol}の値セルを空にして、その変数をvoidにする。この関数は@var{symbol}をリターンする。"

#. type: defun
#: original_texis/variables.texi:362
msgid "If @var{symbol} has a dynamic local binding, @code{makunbound} voids the current binding, and this voidness lasts only as long as the local binding is in effect.  Afterwards, the previously shadowed local or global binding is reexposed; then the variable will no longer be void, unless the reexposed binding is void too."
msgstr "@var{symbol}がダイナミックなローカルバインディングをもつなら、@code{makunbound}はカレントのバインディングをvoidにして、そのローカルバインディングが効果を持つ限りvoidにする。その後で以前にシャドーされたローカル値(またはグローバル値)が再び有効になって、再び有効になった値がvoidでなければ、その変数はvoidではなくなる。"

#. type: defun
#: original_texis/variables.texi:364 original_texis/variables.texi:400
msgid "Here are some examples (assuming dynamic binding is in effect):"
msgstr "いくつか例を示す(ダイナミックバインディングが有効だとする):"

#. type: group
#: original_texis/variables.texi:373
#, no-wrap
msgid ""
"(setq x 1)               ; @r{Put a value in the global binding.}\n"
"     @result{} 1\n"
"(let ((x 2))             ; @r{Locally bind it.}\n"
"  (makunbound 'x)        ; @r{Void the local binding.}\n"
"  x)\n"
"@error{} Symbol's value as variable is void: x\n"
msgstr ""
"(setq x 1)               ; @r{グローバルバインディングに値をセットする}\n"
"     @result{} 1\n"
"(let ((x 2))             ; @r{それをローカルにバインドする}\n"
"  (makunbound 'x)        ; @r{ローカルバインディングをvoidにする}\n"
"  x)\n"
"@error{} Symbol's value as variable is void: x\n"

#. type: group
#: original_texis/variables.texi:377
#, no-wrap
msgid ""
"x                        ; @r{The global binding is unchanged.}\n"
"     @result{} 1\n"
"\n"
msgstr ""
"x                        ; @r{グローバルバインディングは変更されない}\n"
"     @result{} 1\n"
"\n"

#. type: group
#: original_texis/variables.texi:383
#, no-wrap
msgid ""
"(let ((x 2))             ; @r{Locally bind it.}\n"
"  (let ((x 3))           ; @r{And again.}\n"
"    (makunbound 'x)      ; @r{Void the innermost-local binding.}\n"
"    x))                  ; @r{And refer: it's void.}\n"
"@error{} Symbol's value as variable is void: x\n"
msgstr ""
"(let ((x 2))             ; @r{ローカルにバインドする}\n"
"  (let ((x 3))           ; @r{もう一度}\n"
"    (makunbound 'x)      ; @r{最内のローカルバインディングをvoidにする}\n"
"    x))                  ; @r{それを参照すると、void}\n"
"@error{} Symbol's value as variable is void: x\n"

#. type: group
#: original_texis/variables.texi:391
#, no-wrap
msgid ""
"(let ((x 2))\n"
"  (let ((x 3))\n"
"    (makunbound 'x))     ; @r{Void inner binding, then remove it.}\n"
"  x)                     ; @r{Now outer @code{let} binding is visible.}\n"
"     @result{} 2\n"
msgstr ""
"(let ((x 2))\n"
"  (let ((x 3))\n"
"    (makunbound 'x))     ; @r{内側のバインディングをvoidにしてから取り除く}\n"
"  x)                     ; @r{外側の@code{let}バインディングが有効になる}\n"
"     @result{} 2\n"

#. type: defun
#: original_texis/variables.texi:395
#, no-wrap
msgid "boundp variable"
msgstr "boundp variable"

#. type: defun
#: original_texis/variables.texi:398
msgid "This function returns @code{t} if @var{variable} (a symbol) is not void, and @code{nil} if it is void."
msgstr "この関数は@var{variable}(シンボル)がvoidでなければ@code{t}、voidなら@code{nil}をリターンする。"

#. type: group
#: original_texis/variables.texi:405
#, no-wrap
msgid ""
"(boundp 'abracadabra)          ; @r{Starts out void.}\n"
"     @result{} nil\n"
msgstr ""
"(boundp 'abracadabra)          ; @r{最初はvoid}\n"
"     @result{} nil\n"

#. type: group
#: original_texis/variables.texi:410
#, no-wrap
msgid ""
"(let ((abracadabra 5))         ; @r{Locally bind it.}\n"
"  (boundp 'abracadabra))\n"
"     @result{} t\n"
msgstr ""
"(let ((abracadabra 5))         ; @r{ローカルにバインドする}\n"
"  (boundp 'abracadabra))\n"
"     @result{} t\n"

#. type: group
#: original_texis/variables.texi:414
#, no-wrap
msgid ""
"(boundp 'abracadabra)          ; @r{Still globally void.}\n"
"     @result{} nil\n"
msgstr ""
"(boundp 'abracadabra)          ; @r{グローバルではまだvoid}\n"
"     @result{} nil\n"

#. type: group
#: original_texis/variables.texi:418
#, no-wrap
msgid ""
"(setq abracadabra 5)           ; @r{Make it globally nonvoid.}\n"
"     @result{} 5\n"
msgstr ""
"(setq abracadabra 5)           ; @r{グローバルで非voidにする}\n"
"     @result{} 5\n"

#. type: group
#: original_texis/variables.texi:422
#, no-wrap
msgid ""
"(boundp 'abracadabra)\n"
"     @result{} t\n"
msgstr ""
"(boundp 'abracadabra)\n"
"     @result{} t\n"

#. type: section
#: original_texis/variables.texi:427
#, no-wrap
msgid "Defining Global Variables"
msgstr "Defining Global Variables"

#. type: cindex
#: original_texis/variables.texi:428
#, no-wrap
msgid "variable definition"
msgstr "variable definition"

#. type: Plain text
#: original_texis/variables.texi:433
msgid "A @dfn{variable definition} is a construct that announces your intention to use a symbol as a global variable.  It uses the special forms @code{defvar} or @code{defconst}, which are documented below."
msgstr "@dfn{変数定義(variable definition)}とは、そのシンボルをグローバル変数として使用する意図を表明する構文です。これには以下で説明するスペシャルフォーム@code{defvar}や@code{defconst}が使用されます。"

#. type: Plain text
#: original_texis/variables.texi:440
msgid "A variable definition serves three purposes.  First, it informs people who read the code that the symbol is @emph{intended} to be used a certain way (as a variable).  Second, it informs the Lisp system of this, optionally supplying an initial value and a documentation string.  Third, it provides information to programming tools such as @command{etags}, allowing them to find where the variable was defined."
msgstr "変数宣言は3つの目的をもちます。1番目はコードを読む人にたいして、そのシンボルが特定の方法(変数として)使用されることを@emph{意図}したものだと知らせることです。2番目はLispシステムにたいしてオプションで初期値とドキュメント文字列を与えて、これを知らせることです。3番目は@command{etags}のようなプログラミングツールにたいして、その変数が定義されている場所を見つけられるように情報を提供することです。"

#. type: Plain text
#: original_texis/variables.texi:448
msgid "The difference between @code{defconst} and @code{defvar} is mainly a matter of intent, serving to inform human readers of whether the value should ever change.  Emacs Lisp does not actually prevent you from changing the value of a variable defined with @code{defconst}.  One notable difference between the two forms is that @code{defconst} unconditionally initializes the variable, whereas @code{defvar} initializes it only if it is originally void."
msgstr "@code{defconst}と@code{defvar}の主な違いは、人間の読み手に値が変更されるかどうかを知らせることにあります。Emacs Lispは実際に、@code{defconst}で定義された変数の値の変更を妨げません。この2つのフォームの特筆すべき違いは、@code{defconst}は無条件で変数を初期化して、@code{defvar}は変数が元々voidのときだけ初期化することです。"

#. type: Plain text
#: original_texis/variables.texi:452
msgid "To define a customizable variable, you should use @code{defcustom} (which calls @code{defvar} as a subroutine).  @xref{Variable Definitions}."
msgstr "カスタマイズ可能な変数を定義する場合は、@code{defcustom}を使用するべきです(これはサブルーチンとして@code{defvar}を呼び出す)。@ref{Variable Definitions}を参照してください。"

#. type: defspec
#: original_texis/variables.texi:453
#, no-wrap
msgid "defvar symbol [value [doc-string]]"
msgstr "defvar symbol [value [doc-string]]"

#. type: defspec
#: original_texis/variables.texi:459
msgid "This special form defines @var{symbol} as a variable.  Note that @var{symbol} is not evaluated; the symbol to be defined should appear explicitly in the @code{defvar} form.  The variable is marked as @dfn{special}, meaning that it should always be dynamically bound (@pxref{Variable Scoping})."
msgstr "このスペシャルフォームは変数として@var{symbol}を定義する。@var{symbol}が評価されないことに注意。シンボルは@code{defvar}フォーム内に明示的に表記して定義される必要がある。この変数は@dfn{特別}だとマークされて、これは常に変数がダイナミックにバインドされることを意味する(@ref{Variable Scoping}を参照)。"

#. type: defspec
#: original_texis/variables.texi:466
msgid "If @var{value} is specified, and @var{symbol} is void (i.e., it has no dynamically bound value; @pxref{Void Variables}), then @var{value} is evaluated and @var{symbol} is set to the result.  But if @var{symbol} is not void, @var{value} is not evaluated, and @var{symbol}'s value is left unchanged.  If @var{value} is omitted, the value of @var{symbol} is not changed in any case."
msgstr "@var{value}が指定されていて@var{symbol}がvoid(たとえばこのシンボルがダイナミックにバインドされた値を持たないとき。@ref{Void Variables}を参照)なら@var{value}が評価されて、その結果が@var{symbol}にセットされる。しかし@var{symbol}がvoidでなければ、@var{value}は評価されず@var{symbol}の値は変更されない。@var{value}が省略された場合は、いかなる場合も@var{symbol}の値は変更されない。"

#. type: defspec
#: original_texis/variables.texi:472
msgid "Note that specifying a value, even @code{nil}, marks the variable as special permanently.  Whereas if @var{value} is omitted then the variable is only marked special locally (i.e.@: within the current lexical scope, or file if at the top-level).  This can be useful for suppressing byte compilation warnings, see @ref{Compiler Errors}."
msgstr "たとえ@code{nil}であっても値を指定することにより、その変数は特別だと永続的にマークされることに注意。一方で@var{value}が省略されると変数はローカル(カレントのレキシカルスコープまたはトップレベルにあればファイル)でのみ特別だとマークされる。これはバイトコンパイルの警告を抑止するために有用。@ref{Compiler Errors}を参照のこと。"

#. type: defspec
#: original_texis/variables.texi:477
msgid "If @var{symbol} has a buffer-local binding in the current buffer, @code{defvar} acts on the default value, which is buffer-independent, rather than the buffer-local binding.  It sets the default value if the default value is void.  @xref{Buffer-Local Variables}."
msgstr "@var{symbol}がカレントバッファー内でバッファーローカルなバインディングをもつ場合、@code{defvar}はデフォルト値に作用する。デフォルト値はバッファーローカルなバインディングではなく、バッファーにたいして独立である。デフォルト値がvoidのときはデフォルト値をセットする。@ref{Buffer-Local Variables}を参照のこと。"

#. type: defspec
#: original_texis/variables.texi:482
msgid "If @var{symbol} is already lexically bound (e.g., if the @code{defvar} form occurs in a @code{let} form with lexical binding enabled), then @code{defvar} sets the dynamic value.  The lexical binding remains in effect until its binding construct exits.  @xref{Variable Scoping}."
msgstr "すでに@var{symbol}がレキシカルにバインドされている場合(たとえばレキシカルバインドが有効な状態で@code{let}フォーム内に@code{defvar}があるような場合)、@code{defvar}はダイナミックな値をセットする。バインディング構文を抜けるまで、レキシカルバインディングは効果をもつ。@ref{Variable Scoping}を参照のこと。"

#. type: cindex
#: original_texis/variables.texi:483
#, no-wrap
msgid "@code{eval-defun}, and @code{defvar} forms"
msgstr "control.texi.po"

#. type: defspec
#: original_texis/variables.texi:488
msgid "When you evaluate a top-level @code{defvar} form with @kbd{C-M-x} in Emacs Lisp mode (@code{eval-defun}), a special feature of @code{eval-defun} arranges to set the variable unconditionally, without testing whether its value is void."
msgstr "Emacs Lispモードで@kbd{C-M-x} (@code{eval-defun})でトップレベルの@code{defvar}を評価するとき、@code{eval-defun}の特別な機能はその値がvoidであるかテストすることなく、その変数を無条件にセットする。"

#. type: defspec
#: original_texis/variables.texi:492
msgid "If the @var{doc-string} argument is supplied, it specifies the documentation string for the variable (stored in the symbol's @code{variable-documentation} property).  @xref{Documentation}."
msgstr "引数@var{doc-string}が与えられたら、それは変数にたいするドキュメント文字列を指定する(そのシンボルの@code{variable-documentation}プロパティーに格納される)。@ref{Documentation}を参照のこと。"

#. type: defspec
#: original_texis/variables.texi:495
msgid "Here are some examples.  This form defines @code{foo} but does not initialize it:"
msgstr "以下にいくつか例を示す。これは@code{foo}を定義するが初期化は行わない:"

#. type: group
#: original_texis/variables.texi:500
#, no-wrap
msgid ""
"(defvar foo)\n"
"     @result{} foo\n"
msgstr ""
"(defvar foo)\n"
"     @result{} foo\n"

#. type: defspec
#: original_texis/variables.texi:505
msgid "This example initializes the value of @code{bar} to @code{23}, and gives it a documentation string:"
msgstr "以下の例は@code{bar}の値を@code{23}に初期化してドキュメント文字列を与える:"

#. type: group
#: original_texis/variables.texi:511
#, no-wrap
msgid ""
"(defvar bar 23\n"
"  \"The normal weight of a bar.\")\n"
"     @result{} bar\n"
msgstr ""
"(defvar bar 23\n"
"  \"The normal weight of a bar.\")\n"
"     @result{} bar\n"

#. type: defspec
#: original_texis/variables.texi:516
msgid "The @code{defvar} form returns @var{symbol}, but it is normally used at top level in a file where its value does not matter."
msgstr "@code{defvar}フォームは@var{symbol}をリターンするが、これは通常は値が問題にならないファイル内のトップレベルで使用される。"

#. type: defspec
#: original_texis/variables.texi:519
msgid "For a more elaborate example of using @code{defvar} without a value, see @ref{Local defvar example}."
msgstr "値をもたない@code{defvar}のより詳細な使用例は@ref{Local defvar example}を参照のこと。"

#. type: defspec
#: original_texis/variables.texi:522
#, no-wrap
msgid "defconst symbol value [doc-string]"
msgstr "defconst symbol value [doc-string]"

#. type: defspec
#: original_texis/variables.texi:528
msgid "This special form defines @var{symbol} as a value and initializes it.  It informs a person reading your code that @var{symbol} has a standard global value, established here, that should not be changed by the user or by other programs.  Note that @var{symbol} is not evaluated; the symbol to be defined must appear explicitly in the @code{defconst}."
msgstr "このスペシャルフォームはある値で@var{symbol}を定義して、それを初期化する。これはコードを読む人に、@var{symbol}がここで設定される標準的なグローバル値をもち、ユーザーや他のプログラムがそれを変更すべきではないことを知らせる。@var{symbol}が評価されないことに注意。定義されるシンボルは@code{defconst}内に明示的に記されなければならない。"

#. type: defspec
#: original_texis/variables.texi:533
msgid "The @code{defconst} form, like @code{defvar}, marks the variable as @dfn{special}, meaning that it should always be dynamically bound (@pxref{Variable Scoping}).  In addition, it marks the variable as risky (@pxref{File Local Variables})."
msgstr "@code{defvar}と同様、@code{defconst}は変数を@dfn{特別} --- この変数が常にダイナミックにバインドされているという意味 --- であるとマークする(@ref{Variable Scoping}を参照)。加えてこれはその変数を危険であるとマークする(@ref{File Local Variables}を参照)。"

#. type: defspec
#: original_texis/variables.texi:540
msgid "@code{defconst} always evaluates @var{value}, and sets the value of @var{symbol} to the result.  If @var{symbol} does have a buffer-local binding in the current buffer, @code{defconst} sets the default value, not the buffer-local value.  (But you should not be making buffer-local bindings for a symbol that is defined with @code{defconst}.)"
msgstr "@code{defconst}は常に@var{value}を評価して、その結果を@var{symbol}の値にセットする。カレントバッファー内で@var{symbol}がバッファーローカルなバインディングをもつなら、@code{defconst}はデフォルト値ではなくバッファーローカルな値をセットする(しかし@code{defconst}で定義されたシンボルにたいしてバッファーローカルなバインディングを作らないこと)。"

#. type: defspec
#: original_texis/variables.texi:546
msgid "An example of the use of @code{defconst} is Emacs's definition of @code{float-pi}---the mathematical constant @math{pi}, which ought not to be changed by anyone (attempts by the Indiana State Legislature notwithstanding).  As the second form illustrates, however, @code{defconst} is only advisory."
msgstr "@code{defconst}の使い方の例は、Emacsの@code{float-pi} --- (たとえインディアナ州議会が何を試みようと)何者かにより変更されるべきではない数学定数@math{pi}にたいする定義である。しかし2番目の@code{defconst}の例のように、これは単にアドバイス的なものである。"

#. type: group
#: original_texis/variables.texi:551
#, no-wrap
msgid ""
"(defconst float-pi 3.141592653589793 \"The value of Pi.\")\n"
"     @result{} float-pi\n"
msgstr ""
"(defconst float-pi 3.141592653589793 \"The value of Pi.\")\n"
"     @result{} float-pi\n"

#. type: group
#: original_texis/variables.texi:555
#, no-wrap
msgid ""
"(setq float-pi 3)\n"
"     @result{} float-pi\n"
msgstr ""
"(setq float-pi 3)\n"
"     @result{} float-pi\n"

#. type: group
#: original_texis/variables.texi:559
#, no-wrap
msgid ""
"float-pi\n"
"     @result{} 3\n"
msgstr ""
"float-pi\n"
"     @result{} 3\n"

#. type: Plain text
#: original_texis/variables.texi:570
msgid "@strong{Warning:} If you use a @code{defconst} or @code{defvar} special form while the variable has a local binding (made with @code{let}, or a function argument), it sets the local binding rather than the global binding.  This is not what you usually want.  To prevent this, use these special forms at top level in a file, where normally no local binding is in effect, and make sure to load the file before making a local binding for the variable."
msgstr "@strong{警告:} 変数がローカルバインディングをもつとき(@code{let}により作成された、または関数の引数の場合)に、スペシャルフォーム@code{defconst}または@code{defvar}を使用すると、これらのフォームはグローバルバインディングではなく、ローカルバインディングをセットします。これは通常は、あなたが望むことではないはずです。これを防ぐには、これらのスペシャルフォームをファイル内のトップレベルで使用します。この場所は通常、何のローカルバインディングも効果をもたないので、その変数にたいするローカルバインディングが作成される前にファイルがロードされることが確実だからです。"

#. type: section
#: original_texis/variables.texi:572
#, no-wrap
msgid "Tips for Defining Variables Robustly"
msgstr "Tips for Defining Variables Robustly"

#. type: Plain text
#: original_texis/variables.texi:577
msgid "When you define a variable whose value is a function, or a list of functions, use a name that ends in @samp{-function} or @samp{-functions}, respectively."
msgstr "値が関数(または関数のリスト)であるような変数を定義するときには、変数の名前の最後に@samp{-function}(または@samp{-functions})を使用します。"

#. type: Plain text
#: original_texis/variables.texi:580
msgid "There are several other variable name conventions; here is a complete list:"
msgstr "他にも変数名に関する慣習があります。以下はその完全なリストです:"

#. type: item
#: original_texis/variables.texi:582
#, no-wrap
msgid "@dots{}-hook"
msgstr "@dots{}-hook"

#. type: table
#: original_texis/variables.texi:584
msgid "The variable is a normal hook (@pxref{Hooks})."
msgstr "変数はノーマルフック(@ref{Hooks}を参照)。"

#. type: item
#: original_texis/variables.texi:585
#, no-wrap
msgid "@dots{}-function"
msgstr "@dots{}-function"

#. type: table
#: original_texis/variables.texi:587
msgid "The value is a function."
msgstr "値は関数。"

#. type: item
#: original_texis/variables.texi:588
#, no-wrap
msgid "@dots{}-functions"
msgstr "@dots{}-functions"

#. type: table
#: original_texis/variables.texi:590
msgid "The value is a list of functions."
msgstr "値は関数のリスト。"

#. type: item
#: original_texis/variables.texi:591
#, no-wrap
msgid "@dots{}-form"
msgstr "@dots{}-form"

#. type: table
#: original_texis/variables.texi:593
msgid "The value is a form (an expression)."
msgstr "値はフォーム(式)。"

#. type: item
#: original_texis/variables.texi:594
#, no-wrap
msgid "@dots{}-forms"
msgstr "@dots{}-forms"

#. type: table
#: original_texis/variables.texi:596
msgid "The value is a list of forms (expressions)."
msgstr "値はフォーム(式)のリスト。"

#. type: item
#: original_texis/variables.texi:597
#, no-wrap
msgid "@dots{}-predicate"
msgstr "@dots{}-predicate"

#. type: table
#: original_texis/variables.texi:600
msgid "The value is a predicate---a function of one argument that returns non-@code{nil} for success and @code{nil} for failure."
msgstr "値は述語(predicate) --- 1つの引数をとる関数 --- であり成功なら非@code{nil}、失敗なら@code{nil}をリターンする。"

#. type: item
#: original_texis/variables.texi:601
#, no-wrap
msgid "@dots{}-flag"
msgstr "@dots{}-flag"

#. type: table
#: original_texis/variables.texi:605
msgid "The value is significant only as to whether it is @code{nil} or not.  Since such variables often end up acquiring more values over time, this convention is not strongly recommended."
msgstr "@code{nil}か否かだけが意味をもつような値。結局そのような変数は、やがては多くの値をもつことが多いので、この慣習を強く推奨はしない。"

#. type: item
#: original_texis/variables.texi:606
#, no-wrap
msgid "@dots{}-program"
msgstr "@dots{}-program"

#. type: table
#: original_texis/variables.texi:608
msgid "The value is a program name."
msgstr "値はプログラム名。"

#. type: item
#: original_texis/variables.texi:609
#, no-wrap
msgid "@dots{}-command"
msgstr "@dots{}-command"

#. type: table
#: original_texis/variables.texi:611
msgid "The value is a whole shell command."
msgstr "値は完全なシェルコマンド。"

#. type: item
#: original_texis/variables.texi:612
#, no-wrap
msgid "@dots{}-switches"
msgstr "@dots{}-switches"

#. type: table
#: original_texis/variables.texi:614
msgid "The value specifies options for a command."
msgstr "値はコマンドにたいして指定するオプション。"

#. type: item
#: original_texis/variables.texi:615
#, no-wrap
msgid "@var{prefix}--@dots{}"
msgstr "@var{prefix}--@dots{}"

#. type: table
#: original_texis/variables.texi:619
msgid "The variable is intended for internal use and is defined in the file @file{@var{prefix}.el}.  (Emacs code contributed before 2018 may follow other conventions, which are being phased out.)"
msgstr "これは内部的な使用を意図した変数でありファイル@file{@var{prefix}.el}内で定義される(他の規約にしたがうかもしれない2018年以前に貢献されたEmacsコードは段階的に廃止される)。"

#. type: item
#: original_texis/variables.texi:620
#, no-wrap
msgid "@dots{}-internal"
msgstr "@dots{}-internal"

#. type: table
#: original_texis/variables.texi:624
msgid "The variable is intended for internal use and is defined in C code.  (Emacs code contributed before 2018 may follow other conventions, which are being phased out.)"
msgstr "これは内部的な使用を意図した変数でありファイルCコード内で定義される(他の規約にしたがうかもしれない2018年以前に貢献されたEmacsコードは段階的に廃止される)。"

#. type: Plain text
#: original_texis/variables.texi:628
msgid "When you define a variable, always consider whether you should mark it as safe or risky; see @ref{File Local Variables}."
msgstr "変数を定義するときは、その変数を安全(safe)とマークすべきか、それとも危険(risky)とマークすべきかを常に考慮してください。@ref{File Local Variables}を参照してください。"

#. type: Plain text
#: original_texis/variables.texi:632
msgid "When defining and initializing a variable that holds a complicated value (such as a keymap with bindings in it), it's best to put the entire computation of the value into the @code{defvar}, like this:"
msgstr "複雑な値を保持する変数(バインディングをもつkeymapなど)の定義や初期化を行う場合は、以下のように値の計算をすべて@code{defvar}の中に配置するのが最良です:"

#. type: example
#: original_texis/variables.texi:640
#, no-wrap
msgid ""
"(defvar my-mode-map\n"
"  (let ((map (make-sparse-keymap)))\n"
"    (define-key map \"\\C-c\\C-a\" 'my-command)\n"
"    @dots{}\n"
"    map)\n"
"  @var{docstring})\n"
msgstr ""
"(defvar my-mode-map\n"
"  (let ((map (make-sparse-keymap)))\n"
"    (define-key map \"\\C-c\\C-a\" 'my-command)\n"
"    @dots{}\n"
"    map)\n"
"  @var{docstring})\n"

#. type: Plain text
#: original_texis/variables.texi:651
msgid "This method has several benefits.  First, if the user quits while loading the file, the variable is either still uninitialized or initialized properly, never in-between.  If it is still uninitialized, reloading the file will initialize it properly.  Second, reloading the file once the variable is initialized will not alter it; that is important if the user has run hooks to alter part of the contents (such as, to rebind keys).  Third, evaluating the @code{defvar} form with @kbd{C-M-x} will reinitialize the map completely."
msgstr "この方法にはいくつかの利点があります。1つ目はファールをロード中にユーザーが中断した場合、変数はまだ初期化されていないか、初期化されているかのどちらかであり、その中間ということはありません。まだ初期化されていなければ、ファイルをリロードすれば正しく初期化されます。2つ目は一度初期化された変数は、ファイルをリロードしても変更されないことです。コンテンツの一部を変更(たとえばキーのリバインド)するフックをユーザーが実行した場合などに、これは重要です。3つ目は@kbd{C-M-x}で@code{defvar}を評価すると、そのマップは完全に再初期化されることです。"

#. type: Plain text
#: original_texis/variables.texi:655
msgid "Putting so much code in the @code{defvar} form has one disadvantage: it puts the documentation string far away from the line which names the variable.  Here's a safe way to avoid that:"
msgstr "@code{defvar}フォーム内に多すぎるコードを配置することが不利な点が1つあります。ドキュメント文字列が変数の名前から離れた場所に配置されることです。これを避ける安全な方法は以下の方法です:"

#. type: example
#: original_texis/variables.texi:664
#, no-wrap
msgid ""
"(defvar my-mode-map nil\n"
"  @var{docstring})\n"
"(unless my-mode-map\n"
"  (let ((map (make-sparse-keymap)))\n"
"    (define-key map \"\\C-c\\C-a\" 'my-command)\n"
"    @dots{}\n"
"    (setq my-mode-map map)))\n"
msgstr ""
"(defvar my-mode-map nil\n"
"  @var{docstring})\n"
"(unless my-mode-map\n"
"  (let ((map (make-sparse-keymap)))\n"
"    (define-key map \"\\C-c\\C-a\" 'my-command)\n"
"    @dots{}\n"
"    (setq my-mode-map map)))\n"

#. type: Plain text
#: original_texis/variables.texi:670
msgid "This has all the same advantages as putting the initialization inside the @code{defvar}, except that you must type @kbd{C-M-x} twice, once on each form, if you do want to reinitialize the variable."
msgstr "これは初期化を@code{defvar}の内側に配置した場合とまったく同じ利点をもちますが、変数を再度初期化したい場合は、各フォームにたいして1回ずつ、@kbd{C-M-x}を2回タイプしなければならない点が異なります。"

#. type: section
#: original_texis/variables.texi:672
#, no-wrap
msgid "Accessing Variable Values"
msgstr "Accessing Variable Values"

#. type: Plain text
#: original_texis/variables.texi:676
msgid "The usual way to reference a variable is to write the symbol which names it.  @xref{Symbol Forms}."
msgstr "変数を参照する通常の方法は、それに名前をつけるシンボルを記述する方法です。@ref{Symbol Forms}を参照してください。"

#. type: Plain text
#: original_texis/variables.texi:681
msgid "Occasionally, you may want to reference a variable which is only determined at run time.  In that case, you cannot specify the variable name in the text of the program.  You can use the @code{symbol-value} function to extract the value."
msgstr "実行時にのみ決定される変数を参照したいときがあるかもしれません。そのような場合、プログラム中のテキストで変数名を指定することはできません。そのような値を抽出するために@code{symbol-value}を使うことができます。"

#. type: defun
#: original_texis/variables.texi:682
#, no-wrap
msgid "symbol-value symbol"
msgstr "symbol-value symbol"

#. type: defun
#: original_texis/variables.texi:687
msgid "This function returns the value stored in @var{symbol}'s value cell.  This is where the variable's current (dynamic) value is stored.  If the variable has no local binding, this is simply its global value.  If the variable is void, a @code{void-variable} error is signaled."
msgstr "この関数は@var{symbol}の値セルに格納された値をリターンする。これはその変数の(ダイナミックな)カレント値が格納された場所である。その変数がローカルバインディングをもたなければ単にその変数のグローバル値になる。変数がvoidなら@code{void-variable}はエラーをシグナルする。"

#. type: defun
#: original_texis/variables.texi:692
msgid "If the variable is lexically bound, the value reported by @code{symbol-value} is not necessarily the same as the variable's lexical value, which is determined by the lexical environment rather than the symbol's value cell.  @xref{Variable Scoping}."
msgstr "その変数がレキシカルにバインドされていれば、@code{symbol-value}が報告する値は、その変数のレキシカル値と同じである必要はない。レキシカル値はそのシンボルの値セルではなく、レキシカル環境により決定される。@ref{Variable Scoping}を参照のこと。"

#. type: group
#: original_texis/variables.texi:697
#, no-wrap
msgid ""
"(setq abracadabra 5)\n"
"     @result{} 5\n"
msgstr ""
"(setq abracadabra 5)\n"
"     @result{} 5\n"

#. type: group
#: original_texis/variables.texi:701
#, no-wrap
msgid ""
"(setq foo 9)\n"
"     @result{} 9\n"
msgstr ""
"(setq foo 9)\n"
"     @result{} 9\n"

#. type: group
#: original_texis/variables.texi:709
#, no-wrap
msgid ""
";; @r{Here the symbol @code{abracadabra}}\n"
";;   @r{is the symbol whose value is examined.}\n"
"(let ((abracadabra 'foo))\n"
"  (symbol-value 'abracadabra))\n"
"     @result{} foo\n"
msgstr ""
";; @r{ここでシンボル@code{abracadabra}}\n"
";;   @r{は値がテストされるシンボル}\n"
"(let ((abracadabra 'foo))\n"
"  (symbol-value 'abracadabra))\n"
"     @result{} foo\n"

#. type: group
#: original_texis/variables.texi:718
#, no-wrap
msgid ""
";; @r{Here, the value of @code{abracadabra},}\n"
";;   @r{which is @code{foo},}\n"
";;   @r{is the symbol whose value is examined.}\n"
"(let ((abracadabra 'foo))\n"
"  (symbol-value abracadabra))\n"
"     @result{} 9\n"
msgstr ""
";; @r{ここでは@code{abracadabra}の値、}\n"
";;   @r{つまり@code{foo}が値を}\n"
";;   @r{テストされるシンボル}\n"
"(let ((abracadabra 'foo))\n"
"  (symbol-value abracadabra))\n"
"     @result{} 9\n"

#. type: group
#: original_texis/variables.texi:723
#, no-wrap
msgid ""
"(symbol-value 'abracadabra)\n"
"     @result{} 5\n"
msgstr ""
"(symbol-value 'abracadabra)\n"
"     @result{} 5\n"

#. type: section
#: original_texis/variables.texi:728
#, no-wrap
msgid "Setting Variable Values"
msgstr "Setting Variable Values"

#. type: Plain text
#: original_texis/variables.texi:733
msgid "The usual way to change the value of a variable is with the special form @code{setq}.  When you need to compute the choice of variable at run time, use the function @code{set}."
msgstr "ある変数の値を変更する通常の方法は、スペシャルフォーム@code{setq}を使用する方法です。実行時に変数選択を計算する必要がある場合には関数@code{set}を使用します。"

#. type: defspec
#: original_texis/variables.texi:734
#, no-wrap
msgid "setq [symbol form]@dots{}"
msgstr "setq [symbol form]@dots{}"

#. type: defspec
#: original_texis/variables.texi:739
msgid "This special form is the most common method of changing a variable's value.  Each @var{symbol} is given a new value, which is the result of evaluating the corresponding @var{form}.  The current binding of the symbol is changed."
msgstr "このスペシャルフォームは、変数の値を変更するためのもっとも一般的な方法である。@var{symbol}にはそれぞれ、新しい値(対応する@var{form}が評価された結果)が与えられる。そのシンボルのカレントバインディングは変更される。"

#. type: defspec
#: original_texis/variables.texi:743
msgid "@code{setq} does not evaluate @var{symbol}; it sets the symbol that you write.  We say that this argument is @dfn{automatically quoted}.  The @samp{q} in @code{setq} stands for ``quoted''."
msgstr "@code{setq}は@var{symbol}を評価せずに、記述されたシンボルをセットする。この引数のことを@dfn{自動的にクォートされた(automatically quoted)}と呼ぶ。@code{setq}の@samp{q}は``quoted(クォートされた)''が由来。"

#. type: defspec
#: original_texis/variables.texi:745
msgid "The value of the @code{setq} form is the value of the last @var{form}."
msgstr "@code{setq}フォームの値は最後の@var{form}の値となる。"

#. type: group
#: original_texis/variables.texi:750
#, no-wrap
msgid ""
"(setq x (1+ 2))\n"
"     @result{} 3\n"
msgstr ""
"(setq x (1+ 2))\n"
"     @result{} 3\n"

#. type: example
#: original_texis/variables.texi:753
#, no-wrap
msgid ""
"x                   ; @r{@code{x} now has a global value.}\n"
"     @result{} 3\n"
msgstr ""
"x                   ; @r{ここで@code{x}はグローバル値をもつ}\n"
"     @result{} 3\n"

#. type: group
#: original_texis/variables.texi:758
#, no-wrap
msgid ""
"(let ((x 5))\n"
"  (setq x 6)        ; @r{The local binding of @code{x} is set.}\n"
"  x)\n"
"     @result{} 6\n"
msgstr ""
"(let ((x 5))\n"
"  (setq x 6)        ; @r{@code{x}のローカルバインディングをセット}\n"
"  x)\n"
"     @result{} 6\n"

#. type: example
#: original_texis/variables.texi:761
#, no-wrap
msgid ""
"x                   ; @r{The global value is unchanged.}\n"
"     @result{} 3\n"
msgstr ""
"x                   ; @r{グローバル値は変更されない}\n"
"     @result{} 3\n"

#. type: defspec
#: original_texis/variables.texi:766
msgid "Note that the first @var{form} is evaluated, then the first @var{symbol} is set, then the second @var{form} is evaluated, then the second @var{symbol} is set, and so on:"
msgstr "1番目の@var{form}が評価されてから1番目の@var{symbol}がセット、次に2番目の@var{form}が評価されてから@var{symbol}が評価されて、...となることに注意:"

#. type: group
#: original_texis/variables.texi:772
#, no-wrap
msgid ""
"(setq x 10          ; @r{Notice that @code{x} is set before}\n"
"      y (1+ x))     ;   @r{the value of @code{y} is computed.}\n"
"     @result{} 11\n"
msgstr ""
"(setq x 10          ; @r{ここで、@code{x}がセットされるのは}\n"
"      y (1+ x))     ;   @r{@code{y}の計算前であることに注目}\n"
"     @result{} 11\n"

#. type: defun
#: original_texis/variables.texi:776
#, no-wrap
msgid "set symbol value"
msgstr "set symbol value"

#. type: defun
#: original_texis/variables.texi:781
msgid "This function puts @var{value} in the value cell of @var{symbol}.  Since it is a function rather than a special form, the expression written for @var{symbol} is evaluated to obtain the symbol to set.  The return value is @var{value}."
msgstr "この関数は@var{symbol}の値セルに@var{value}を配置する。これはスペシャルフォームではなく関数なので、シンボルにセットするために@var{symbol}に記述された式は評価される。リターン値は@var{value}。"

#. type: defun
#: original_texis/variables.texi:788
msgid "When dynamic variable binding is in effect (the default), @code{set} has the same effect as @code{setq}, apart from the fact that @code{set} evaluates its @var{symbol} argument whereas @code{setq} does not.  But when a variable is lexically bound, @code{set} affects its @emph{dynamic} value, whereas @code{setq} affects its current (lexical) value.  @xref{Variable Scoping}."
msgstr "ダイナミックな変数バインドが有効(デフォルト)なら、@code{set}は自身の引数@var{symbol}を評価するが、@code{setq}は評価しないという点を除き、@code{set}は@code{setq}と同じ効果をもつ。しかし変数がレキシカルバインドなら、@code{set}は変数の@emph{ダイナミック}な値に、@code{setq}は変数のカレント値(レキシカル値)に影響する。@ref{Variable Scoping}を参照のこと。"

#. type: group
#: original_texis/variables.texi:793
#, no-wrap
msgid ""
"(set one 1)\n"
"@error{} Symbol's value as variable is void: one\n"
msgstr ""
"(set one 1)\n"
"@error{} Symbol's value as variable is void: one\n"

#. type: group
#: original_texis/variables.texi:797
#, no-wrap
msgid ""
"(set 'one 1)\n"
"     @result{} 1\n"
msgstr ""
"(set 'one 1)\n"
"     @result{} 1\n"

#. type: group
#: original_texis/variables.texi:801
#, no-wrap
msgid ""
"(set 'two 'one)\n"
"     @result{} one\n"
msgstr ""
"(set 'two 'one)\n"
"     @result{} one\n"

#. type: group
#: original_texis/variables.texi:805
#, no-wrap
msgid ""
"(set two 2)         ; @r{@code{two} evaluates to symbol @code{one}.}\n"
"     @result{} 2\n"
msgstr ""
"(set two 2)         ; @r{@code{two}はシンボル@code{one}に評価される}\n"
"     @result{} 2\n"

#. type: group
#: original_texis/variables.texi:813
#, no-wrap
msgid ""
"one                 ; @r{So it is @code{one} that was set.}\n"
"     @result{} 2\n"
"(let ((one 1))      ; @r{This binding of @code{one} is set,}\n"
"  (set 'one 3)      ;   @r{not the global value.}\n"
"  one)\n"
"     @result{} 3\n"
msgstr ""
"one                 ; @r{したがって@code{one}がセットされる}\n"
"     @result{} 2\n"
"(let ((one 1))      ; @r{@code{one}のこのバインディングがセットされる}\n"
"  (set 'one 3)      ;   @r{のであってグローバル値はセットされない}\n"
"  one)\n"
"     @result{} 3\n"

#. type: group
#: original_texis/variables.texi:817
#, no-wrap
msgid ""
"one\n"
"     @result{} 2\n"
msgstr ""
"one\n"
"     @result{} 2\n"

#. type: defun
#: original_texis/variables.texi:822
msgid "If @var{symbol} is not actually a symbol, a @code{wrong-type-argument} error is signaled."
msgstr "@var{symbol}が実際のシンボルでなければ@code{wrong-type-argument}エラーがシグナルされる。"

#. type: example
#: original_texis/variables.texi:826
#, no-wrap
msgid ""
"(set '(x y) 'z)\n"
"@error{} Wrong type argument: symbolp, (x y)\n"
msgstr ""
"(set '(x y) 'z)\n"
"@error{} Wrong type argument: symbolp, (x y)\n"

#. type: cindex
#: original_texis/variables.texi:831
#, no-wrap
msgid "variable watchpoints"
msgstr "variable watchpoints"

#. type: cindex
#: original_texis/variables.texi:832
#, no-wrap
msgid "watchpoints for Lisp variables"
msgstr "watchpoints for Lisp variables"

#. type: Plain text
#: original_texis/variables.texi:839
#, fuzzy
#| msgid "It is sometimes useful to take some action when a variable changes its value.  The watchpoint facility provides the means to do so.  Some possible uses for this feature include keeping display in sync with variable settings, and invoking the debugger to track down unexpected changes to variables (@pxref{Variable Debugging})."
msgid "It is sometimes useful to take some action when a variable changes its value.  The @dfn{variable watchpoint} facility provides the means to do so.  Some possible uses for this feature include keeping display in sync with variable settings, and invoking the debugger to track down unexpected changes to variables (@pxref{Variable Debugging})."
msgstr "変数の値が変化したときに何らかのアクションを行えれば便利なときがあります。watchpoint機能はそのための機能を提供します。この機能の有効な利用方法としては変数セッティングと表示の同期、変数への予期せぬ変更を追跡するためのデバッガの呼び出しが含まれます(@ref{Variable Debugging}を参照)。"

#. type: Plain text
#: original_texis/variables.texi:842
msgid "The following functions may be used to manipulate and query the watch functions for a variable."
msgstr "以下の関数は関数にたいするwatch関数の操作や問い合わせに使用できます。"

#. type: defun
#: original_texis/variables.texi:843
#, no-wrap
msgid "add-variable-watcher symbol watch-function"
msgstr "add-variable-watcher symbol watch-function"

#. type: defun
#: original_texis/variables.texi:847
msgid "This function arranges for @var{watch-function} to be called whenever @var{symbol} is modified.  Modifications through aliases (@pxref{Variable Aliases}) will have the same effect."
msgstr "この関数は@var{symbol}が変化したときは常に@var{watch-function}が呼び出されるようにアレンジする。エイリアスを介した変更にも同じ効果をもつ(@ref{Variable Aliases}を参照)。"

#. type: defun
#: original_texis/variables.texi:859
#, fuzzy
#| msgid "@var{symbol} is the variable being changed.  @var{newval} is the value it will be changed to.  @var{operation} is a symbol representing the kind of change, one of: `set', `let', `unlet', `makunbound', and `defvaralias'.  @var{where} is a buffer if the buffer-local value of the variable is being changed, @code{nil} otherwise."
msgid "@var{watch-function} will be called, just before changing the value of @var{symbol}, with 4 arguments: @var{symbol}, @var{newval}, @var{operation}, and @var{where}.  @var{symbol} is the variable being changed.  @var{newval} is the value it will be changed to.  (The old value is available to @var{watch-function} as the value of @var{symbol}, since it was not yet changed to @var{newval}.)  @var{operation} is a symbol representing the kind of change, one of: @code{set}, @code{let}, @code{unlet}, @code{makunbound}, or @code{defvaralias}.  @var{where} is a buffer if the buffer-local value of the variable is being changed, @code{nil} otherwise."
msgstr "@var{symbol}は変更された変数、@var{newval}は変更される新しい値、@var{operation}は変更の種別を表すシンボルであり`set'、`let'、`unlet'、`makunbound'、`defvaralias'のいずれか。@var{where}はその変数のバッファーローカル値が変更された場合にはバッファー、それ以外なら@code{nil}。"

#. type: defun
#: original_texis/variables.texi:861
#, fuzzy, no-wrap
#| msgid "remove-variable-watch symbol watch-function"
msgid "remove-variable-watcher symbol watch-function"
msgstr "remove-variable-watch symbol watch-function"

#. type: defun
#: original_texis/variables.texi:864
msgid "This function removes @var{watch-function} from @var{symbol}'s list of watchers."
msgstr "この関数は@var{symbol}のwatcherリストから@var{watch-function}を削除する。"

#. type: defun
#: original_texis/variables.texi:866
#, no-wrap
msgid "get-variable-watchers symbol"
msgstr "get-variable-watchers symbol"

#. type: defun
#: original_texis/variables.texi:869
msgid "This function returns the list of @var{symbol}'s active watcher functions."
msgstr "この関数は@var{symbol}のアクティブなwatcher関数のリストをリターンする。"

#. type: subsection
#: original_texis/variables.texi:871
#, no-wrap
msgid "Limitations"
msgstr "Limitations"

#. type: Plain text
#: original_texis/variables.texi:875
msgid "There are a couple of ways in which a variable could be modified (or at least appear to be modified) without triggering a watchpoint."
msgstr "watchpointをトリガーせずに変数が変更される(または少なくとも変更されたように見える)方法がいくつかあります。"

#. type: Plain text
#: original_texis/variables.texi:879
msgid "Since watchpoints are attached to symbols, modification to the objects contained within variables (e.g., by a list modification function @pxref{Modifying Lists}) is not caught by this mechanism."
msgstr "watchpointはシンボルにアタッチされるので変数内に含まれるオブジェクトの変更(リスト変更関数による変更。@ref{Modifying Lists}を参照のこと)はこのメカニズムにより検出されません。"

#. type: Plain text
#: original_texis/variables.texi:882
msgid "Additionally, C code can modify the value of variables directly, bypassing the watchpoint mechanism."
msgstr "さらにCのコードはwatchpointメカニズムをバイパスして変数の値を直接変更できます。"

#. type: Plain text
#: original_texis/variables.texi:889
msgid "A minor limitation of this feature, again because it targets symbols, is that only variables of dynamic scope may be watched.  This poses little difficulty, since modifications to lexical variables can be discovered easily by inspecting the code within the scope of the variable (unlike dynamic variables, which can be modified by any code at all, @pxref{Variable Scoping})."
msgstr "繰り返しになりますがこれはシンボルをターゲットとするので、この機能のマイナーな制限はダイナミックなスコープをもつ変数だけをウォッチできるということです。レキシカル変数への変更は変数スコープ内のコードを調べれば容易に発見できるので、これが問題をもたらすことは稀でしょう(結局のところいかなるコードからも変更され得るダイナミック変数とは異なる。@ref{Variable Scoping}を参照のこと)。"

#. type: section
#: original_texis/variables.texi:892
#, no-wrap
msgid "Scoping Rules for Variable Bindings"
msgstr "Scoping Rules for Variable Bindings"

#. type: cindex
#: original_texis/variables.texi:893
#, no-wrap
msgid "scoping rule"
msgstr "scoping rule"

#. type: Plain text
#: original_texis/variables.texi:898
msgid "When you create a local binding for a variable, that binding takes effect only within a limited portion of the program (@pxref{Local Variables}).  This section describes exactly what this means."
msgstr "ある変数にたいするローカルバインディングを作成するとき、そのバインディングはプログラムの限られた一部だけに効果をもちます(@ref{Local Variables}を参照)。このセクションでは、これが正確には何を意味するかについて説明します。"

#. type: cindex
#: original_texis/variables.texi:899
#, no-wrap
msgid "scope"
msgstr "scope"

#. type: cindex
#: original_texis/variables.texi:900
#, no-wrap
msgid "extent"
msgstr "extent"

#. type: Plain text
#: original_texis/variables.texi:905
msgid "Each local binding has a certain @dfn{scope} and @dfn{extent}.  @dfn{Scope} refers to @emph{where} in the textual source code the binding can be accessed.  @dfn{Extent} refers to @emph{when}, as the program is executing, the binding exists."
msgstr "ローカルバインディングはそれぞれ、個別に@dfn{スコープ(scope: 範囲という意味)}と@dfn{エクステント(extent: これも範囲を意味する)}をもちます。@dfn{スコープ}はそのバインディングにアクセスできるのが、テキストのソースコードの@emph{どこ(where)}であるかを示します。@dfn{エクステント}はプログラムの実行中に、そのバインディングが存在するのが@emph{いつ(when)}であるかを示します。"

#. type: cindex
#: original_texis/variables.texi:906
#, no-wrap
msgid "dynamic binding"
msgstr "dynamic binding"

#. type: cindex
#: original_texis/variables.texi:907
#, no-wrap
msgid "dynamic scope"
msgstr "dynamic scope"

#. type: cindex
#: original_texis/variables.texi:908
#, no-wrap
msgid "dynamic extent"
msgstr "dynamic extent"

#. type: Plain text
#: original_texis/variables.texi:915
msgid "By default, the local bindings that Emacs creates are @dfn{dynamic bindings}.  Such a binding has @dfn{dynamic scope}, meaning that any part of the program can potentially access the variable binding.  It also has @dfn{dynamic extent}, meaning that the binding lasts only while the binding construct (such as the body of a @code{let} form) is being executed."
msgstr "デフォルトではEmacsが作成したローカルバインディングは、@dfn{ダイナミックバインディング(dynamic binding)}です。このようなバインディングは@dfn{ダイナミックスコープ(dynamic scope)}をもち、それはプログラムの任意の範囲が、その変数バインディングにアクセスするかもしれないことを意味します。これは@dfn{ダイナミックエクステント(dynamic extent)}ももっています。これはそのバインディング構造(@code{let}フォームのbodyなど)が実行される間だけ、そのバインディングが存続することを意味します。"

#. type: cindex
#: original_texis/variables.texi:916
#, no-wrap
msgid "lexical binding"
msgstr "lexical binding"

#. type: cindex
#: original_texis/variables.texi:917
#, no-wrap
msgid "lexical scope"
msgstr "lexical scope"

#. type: cindex
#: original_texis/variables.texi:918
#, no-wrap
msgid "indefinite extent"
msgstr "indefinite extent"

#. type: Plain text
#: original_texis/variables.texi:927
msgid "Emacs can optionally create @dfn{lexical bindings}.  A lexical binding has @dfn{lexical scope}, meaning that any reference to the variable must be located textually within the binding construct@footnote{With some exceptions; for instance, a lexical binding can also be accessed from the Lisp debugger.}.  It also has @dfn{indefinite extent}, meaning that under some circumstances the binding can live on even after the binding construct has finished executing, by means of special objects called @dfn{closures}."
msgstr "Emacsはオプションで@dfn{レキシカルバインディング(lexical binding)}を作成することができます。レキシカルバインディングは@dfn{レキシカルスコープ(lexical scope)}をもち、これはその変数にたいするすべての参照が、バインディング構文内にテキスト的に配置されなければならないことを意味します@footnote{これにはいくつか例外があります。たとえばレキシカルバインディングは、Lispデバッガーからもアクセスできます。}。レキシカルバインディングは@dfn{不定エクステント(indefinite extent)}ももっています。これはある状況下において、@dfn{クロージャー(closures)}と呼ばれるスペシャルオブジェクトにより、バインディング構造が実行を終えた後でさえも、存続し続けることを意味します。"

#. type: Plain text
#: original_texis/variables.texi:931
msgid "The following subsections describe dynamic binding and lexical binding in greater detail, and how to enable lexical binding in Emacs Lisp programs."
msgstr "以降のサブセクションでは、ダイナミックバインディングとレキシカルバインディング、およびEmacs Lispプログラムでレキシカルバインディングを有効にする方法についてより詳細に説明します。"

#. type: subsection
#: original_texis/variables.texi:937 original_texis/variables.texi:939
#: original_texis/variables.texi:940
#, no-wrap
msgid "Dynamic Binding"
msgstr "Dynamic Binding"

#. type: menuentry
#: original_texis/variables.texi:937
msgid "The default for binding local variables in Emacs."
msgstr "Emacs内でのローカル変数にたいするデフォルトのバインディング。"

#. type: node
#: original_texis/variables.texi:937 original_texis/variables.texi:1010
#, no-wrap
msgid "Dynamic Binding Tips"
msgstr "Dynamic Binding Tips"

#. type: menuentry
#: original_texis/variables.texi:937
msgid "Avoiding problems with dynamic binding."
msgstr "ダイナミックバインディングによる問題を回避する。"

#. type: subsection
#: original_texis/variables.texi:937 original_texis/variables.texi:1056
#: original_texis/variables.texi:1057
#, no-wrap
msgid "Lexical Binding"
msgstr "Lexical Binding"

#. type: menuentry
#: original_texis/variables.texi:937
msgid "A different type of local variable binding."
msgstr "ローカル変数にたいする他の種類のバインディング。"

#. type: subsection
#: original_texis/variables.texi:937 original_texis/variables.texi:1167
#: original_texis/variables.texi:1168
#, no-wrap
msgid "Using Lexical Binding"
msgstr "Using Lexical Binding"

#. type: menuentry
#: original_texis/variables.texi:937
msgid "How to enable lexical binding."
msgstr "レキシカルバインディングを有効にする方法。"

#. type: Plain text
#: original_texis/variables.texi:947
msgid "By default, the local variable bindings made by Emacs are dynamic bindings.  When a variable is dynamically bound, its current binding at any point in the execution of the Lisp program is simply the most recently-created dynamic local binding for that symbol, or the global binding if there is no such local binding."
msgstr "デフォルトでは、Emacsにより作成されるローカル変数のバインディングはダイナミックバインディングです。ある変数がダイナミックにバインドされていると、Lispプログラムの実行における任意のポイントでのカレントバインディングは、単にそのシンボルにたいしてもっとも最近作成されたダイナミックなローカルバインディング、またはそのようなローカルバインディングが存在しなければグローバルバインディングになります。"

#. type: Plain text
#: original_texis/variables.texi:950
msgid "Dynamic bindings have dynamic scope and extent, as shown by the following example:"
msgstr "以下の例のように、ダイナミックバインディングはダイナミックスコープとダイナミックエクステントをもちます:"

#. type: group
#: original_texis/variables.texi:954
#, no-wrap
msgid ""
"(defvar x -99)  ; @r{@code{x} receives an initial value of @minus{}99.}\n"
"\n"
msgstr ""
"(defvar x -99)  ; @r{@code{x}は初期値として@minus{}99を受け取る}\n"
"\n"

#. type: group
#: original_texis/variables.texi:957 original_texis/variables.texi:1084
#, no-wrap
msgid ""
"(defun getx ()\n"
"  x)            ; @r{@code{x} is used free in this function.}\n"
"\n"
msgstr ""
"(defun getx ()\n"
"  x)            ; @r{この関数内では@code{x}は自由に使用される}\n"
"\n"

#. type: group
#: original_texis/variables.texi:961
#, no-wrap
msgid ""
"(let ((x 1))    ; @r{@code{x} is dynamically bound.}\n"
"  (getx))\n"
"     @result{} 1\n"
"\n"
msgstr ""
"(let ((x 1))    ; @r{@code{x}はダイナミックにバインドされている}\n"
"  (getx))\n"
"     @result{} 1\n"
"\n"

#. type: group
#: original_texis/variables.texi:964 original_texis/variables.texi:996
#, no-wrap
msgid ""
";; @r{After the @code{let} form finishes, @code{x} reverts to its}\n"
";; @r{previous value, which is @minus{}99.}\n"
"\n"
msgstr ""
";; @r{@code{let}フォームが終了した後に}\n"
";; @r{@code{x}は前の値@minus{}99にリバートされる}\n"
"\n"

#. type: group
#: original_texis/variables.texi:967
#, no-wrap
msgid ""
"(getx)\n"
"     @result{} -99\n"
msgstr ""
"(getx)\n"
"     @result{} -99\n"

#. type: Plain text
#: original_texis/variables.texi:978
msgid "The function @code{getx} refers to @code{x}.  This is a @dfn{free} reference, in the sense that there is no binding for @code{x} within that @code{defun} construct itself.  When we call @code{getx} from within a @code{let} form in which @code{x} is (dynamically) bound, it retrieves the local value (i.e., 1).  But when we call @code{getx} outside the @code{let} form, it retrieves the global value (i.e., @minus{}99)."
msgstr "関数@code{getx}は@code{x}を参照します。@code{defun}構文自体の中に@code{x}にたいするバインディングが存在しないという意味において、これは@dfn{フリー}な参照です。@code{x}が(ダイナミックに)バインドされている@code{let}フォーム内から@code{getx}を呼び出すと、ローカル値(つまり1)が取得されます。しかしその後@code{let}フォームの外側から@code{getx}を呼び出すと、グローバル値(つまり@minus{}99)が取得されます。"

#. type: Plain text
#: original_texis/variables.texi:981
msgid "Here is another example, which illustrates setting a dynamically bound variable using @code{setq}:"
msgstr "以下は@code{setq}を使用してダイナミックに変数をバインドする例です:"

#. type: group
#: original_texis/variables.texi:985
#, no-wrap
msgid ""
"(defvar x -99)      ; @r{@code{x} receives an initial value of @minus{}99.}\n"
"\n"
msgstr ""
"(defvar x -99)      ; @r{@code{x}は初期値として@minus{}99を受け取る}\n"
"\n"

#. type: group
#: original_texis/variables.texi:988
#, no-wrap
msgid ""
"(defun addx ()\n"
"  (setq x (1+ x)))  ; @r{Add 1 to @code{x} and return its new value.}\n"
"\n"
msgstr ""
"(defun addx ()\n"
"  (setq x (1+ x)))  ; @r{@code{x}に1加算して新しい値をリターンする}\n"
"\n"

#. type: group
#: original_texis/variables.texi:993
#, no-wrap
msgid ""
"(let ((x 1))\n"
"  (addx)\n"
"  (addx))\n"
"     @result{} 3           ; @r{The two @code{addx} calls add to @code{x} twice.}\n"
"\n"
msgstr ""
"(let ((x 1))\n"
"  (addx)\n"
"  (addx))\n"
"     @result{} 3           ; @r{@code{addx}を2回呼び出すと@code{x}に2回加算される}\n"
"\n"

#. type: group
#: original_texis/variables.texi:999
#, no-wrap
msgid ""
"(addx)\n"
"     @result{} -98\n"
msgstr ""
"(addx)\n"
"     @result{} -98\n"

#. type: Plain text
#: original_texis/variables.texi:1009
msgid "Dynamic binding is implemented in Emacs Lisp in a simple way.  Each symbol has a value cell, which specifies its current dynamic value (or absence of value).  @xref{Symbol Components}.  When a symbol is given a dynamic local binding, Emacs records the contents of the value cell (or absence thereof) in a stack, and stores the new local value in the value cell.  When the binding construct finishes executing, Emacs pops the old value off the stack, and puts it in the value cell."
msgstr "Emacs Lispでのダイナミックバインディングは、シンプルな方法で実装されています。シンボルはそれぞれ、シンボルのカレントのダイナミック値(または値の不在)を指定する値セルをもちます。@ref{Symbol Components}を参照してください。あるシンボルがダイナミックなローカル値を与えられたとき、Emacsは値セルの内容(または値の不在)をスタックに記録して、新しいローカル値を値セルに格納します。バインディング構文が実行を終えたとき、Emacsはスタックから古い値をpopして値セルにそれを配置します。"

#. type: subsection
#: original_texis/variables.texi:1011
#, no-wrap
msgid "Proper Use of Dynamic Binding"
msgstr "Proper Use of Dynamic Binding"

#. type: Plain text
#: original_texis/variables.texi:1018
msgid "Dynamic binding is a powerful feature, as it allows programs to refer to variables that are not defined within their local textual scope.  However, if used without restraint, this can also make programs hard to understand.  There are two clean ways to use this technique:"
msgstr "ダイナミックバインディングは、プログラムにたいしてテキスト的なローカルスコープ内で定義されていない変数を参照することを許容する、強力な機能です。しかし無制限に使用した場合には、プログラムの理解を困難にしてしまうこともあります。このテクニックを使用するために2つの明解な方法があります:"

#. type: itemize
#: original_texis/variables.texi:1027
msgid "If a variable has no global definition, use it as a local variable only within a binding construct, such as the body of the @code{let} form where the variable was bound.  If this convention is followed consistently throughout a program, the value of the variable will not affect, nor be affected by, any uses of the same variable symbol elsewhere in the program."
msgstr "ある変数がグローバルな定義をもたなければ、ローカル変数としてバインディング構文内(その変数がバインドされる@code{let}フォームのbodyなどの場所)だけでそれを使用する。プログラムでこの慣習に一貫してしたがえば、プログラム内の他の場所で同じ変数シンボルを任意に使用しても、その変数の値に影響を与えたり、影響を受けることがなくなる。"

#. type: itemize
#: original_texis/variables.texi:1036
msgid "Otherwise, define the variable with @code{defvar}, @code{defconst} (@pxref{Defining Variables}), or @code{defcustom} (@pxref{Variable Definitions}).  Usually, the definition should be at top-level in an Emacs Lisp file.  As far as possible, it should include a documentation string which explains the meaning and purpose of the variable.  You should also choose the variable's name to avoid name conflicts (@pxref{Coding Conventions})."
msgstr "それ以外では@code{defvar}、@code{defconst} (@ref{Defining Variables}を参照)、@code{defcustom} (@ref{Variable Definitions}を参照)で変数を定義する。この定義は通常はEmacs Lispファイル内のトップレベルであること。この定義には可能な限り変数の意味と目的を説明するドキュメント文字列を含めること。また名前の衝突を避けるように変数を命名すること(@ref{Coding Conventions}を参照)。"

#. type: itemize
#: original_texis/variables.texi:1042
msgid "Then you can bind the variable anywhere in a program, knowing reliably what the effect will be.  Wherever you encounter the variable, it will be easy to refer back to the definition, e.g., via the @kbd{C-h v} command (provided the variable definition has been loaded into Emacs).  @xref{Name Help,,, emacs, The GNU Emacs Manual}."
msgstr "そうすればプログラム内のどこか別の場所で、それが何に影響するか確信をもって変数をバインドすることができます。その変数にどこで出会っても、(たとえば変数の定義がEmacsにロードされていれば@kbd{C-h v}コマンドを通じて)定義を参照するのが簡単になります。@ref{Name Help,,, emacs, The GNU Emacs Manual}を参照してください。"

#. type: itemize
#: original_texis/variables.texi:1045
msgid "For example, it is common to use local bindings for customizable variables like @code{case-fold-search}:"
msgstr "たとえば@code{case-fold-search}のようなカスタマイズ可能な変数にたいしてローカルバインディングを使用するのは一般的です:"

#. type: group
#: original_texis/variables.texi:1052
#, no-wrap
msgid ""
"(defun search-for-abc ()\n"
"  \"Search for the string \\\"abc\\\", ignoring case differences.\"\n"
"  (let ((case-fold-search t))\n"
"    (re-search-forward \"abc\")))\n"
msgstr ""
"(defun search-for-abc ()\n"
"  \"Search for the string \\\"abc\\\", ignoring case differences.\"\n"
"  (let ((case-fold-search t))\n"
"    (re-search-forward \"abc\")))\n"

#. type: Plain text
#: original_texis/variables.texi:1065
msgid "Lexical binding was introduced to Emacs, as an optional feature, in version 24.1.  We expect its importance to increase with time.  Lexical binding opens up many more opportunities for optimization, so programs using it are likely to run faster in future Emacs versions.  Lexical binding is also more compatible with concurrency, which was added to Emacs in version 26.1."
msgstr "Emacsのバージョン24.1からオプションの機能としてレキシカルバインディングが導入されました。わたしたちはこの機能の重要性が時とともに増加することを期待します。レキシカルバインディングは最適化の機会をより広げるので、この機能を使用するプログラムはおそらく将来のEmacsバージョンで高速に実行されるようになるでしょう。レキシカルバインディングは、わたしたちがバージョン26。1のEmacsで追加した並列性(concurrency)とも互換があります。"

#. type: Plain text
#: original_texis/variables.texi:1069
msgid "A lexically-bound variable has @dfn{lexical scope}, meaning that any reference to the variable must be located textually within the binding construct.  Here is an example"
msgstr "レキシカルにバインドされた変数は@dfn{レキシカルスコープ(lexical scope)}をもちます。これはその変数にたいする参照が、そのバインディング構文内にテキスト的に配置されなければならないことを意味しています。以下は例です"

#. type: iftex
#: original_texis/variables.texi:1071
msgid "(see the next subsection, for how to actually enable lexical binding):"
msgstr "(実際にレキシカルバインディングを有功にする方法は、次のサブセクションを参照のこと):"

#. type: ifnottex
#: original_texis/variables.texi:1074
msgid "(@pxref{Using Lexical Binding}, for how to actually enable lexical binding):"
msgstr "(実際にレキシカルバインディングを有功にする方法は、@ref{Using Lexical Binding}を参照のこと):"

#. type: group
#: original_texis/variables.texi:1081
#, no-wrap
msgid ""
"(let ((x 1))    ; @r{@code{x} is lexically bound.}\n"
"  (+ x 3))\n"
"     @result{} 4\n"
"\n"
msgstr ""
"(let ((x 1))    ; @r{@code{x}はレキシカルにバインドされる}\n"
"  (+ x 3))\n"
"     @result{} 4\n"
"\n"

#. type: group
#: original_texis/variables.texi:1088
#, no-wrap
msgid ""
"(let ((x 1))    ; @r{@code{x} is lexically bound.}\n"
"  (getx))\n"
"@error{} Symbol's value as variable is void: x\n"
msgstr ""
"(let ((x 1))    ; @r{@code{x}はレキシカルにバインドされる}\n"
"  (getx))\n"
"@error{} Symbol's value as variable is void: x\n"

#. type: Plain text
#: original_texis/variables.texi:1098
msgid "Here, the variable @code{x} has no global value.  When it is lexically bound within a @code{let} form, it can be used in the textual confines of that @code{let} form.  But it can @emph{not} be used from within a @code{getx} function called from the @code{let} form, since the function definition of @code{getx} occurs outside the @code{let} form itself."
msgstr "ここでは@code{x}はグローバル値をもちません。@code{let}フォーム内でレキシカルにバインドされたとき、この変数は@code{let}のテキスト境界内で使用できます。しかしこの@code{let}内から呼び出される@code{getx}関数からは、@code{getx}の関数定義が@code{let}フォームの外側なので使用することが@emph{できません}。"

#. type: cindex
#: original_texis/variables.texi:1099
#, no-wrap
msgid "lexical environment"
msgstr "lexical environment"

#. type: Plain text
#: original_texis/variables.texi:1106
msgid "Here is how lexical binding works.  Each binding construct defines a @dfn{lexical environment}, specifying the variables that are bound within the construct and their local values.  When the Lisp evaluator wants the current value of a variable, it looks first in the lexical environment; if the variable is not specified in there, it looks in the symbol's value cell, where the dynamic value is stored."
msgstr "レキシカルバインディングが機能する方法を説明します。バインディング構文はぞれぞれ、その構文内でローカル値にバインドする変数を指定する、@dfn{レキシカル環境(lexical environment)}を定義します。Lispの評価機能(Lisp evaluator)が、ある変数のカレント値を得たいときは、最初にレキシカル環境内を探します。そこで変数が指定されていなければ、ダイナミック値が格納されるシンボルの値セルを探します。"

#. type: Plain text
#: original_texis/variables.texi:1114
msgid "(Internally, the lexical environment is an alist of symbol-value pairs, with the final element in the alist being the symbol @code{t} rather than a cons cell.  Such an alist can be passed as the second argument to the @code{eval} function, in order to specify a lexical environment in which to evaluate a form.  @xref{Eval}.  Most Emacs Lisp programs, however, should not interact directly with lexical environments in this way; only specialized programs like debuggers.)"
msgstr "(内部的にはレキシカル環境はシンボルと値がペアになったalistでり、alistの最後の要素はコンスセルではなくシンボル@code{t}である。そのようなalistはフォームを評価するためのレキシカル環境を指定するために、@code{eval}関数の2番目の引数として渡すことができる。@ref{Eval}を参照のこと。しかしほとんどのEmacs Lispプログラムは、この方法で直接レキシカル環境を使用するべきではない。デバッガーのような特化されたプログラムだけが使用すること。)"

#. type: cindex
#: original_texis/variables.texi:1115
#, no-wrap
msgid "closures, example of using"
msgstr "closures, example of using"

#. type: Plain text
#: original_texis/variables.texi:1121
msgid "Lexical bindings have indefinite extent.  Even after a binding construct has finished executing, its lexical environment can be ``kept around'' in Lisp objects called @dfn{closures}.  A closure is created when you define a named or anonymous function with lexical binding enabled.  @xref{Closures}, for details."
msgstr "レキシカルバインディングは不定エクステント(indefinite extent)をもちます。バインディング構造が終了した後でも、そのレキシカル環境は@dfn{クロージャー(closures)}と呼ばれるLispオブジェクト内に``保持''されるかもしれ、あせん。クロージャーはレキシカルバインディングが有効な、名前つきまたは無名(anonymous)の関数が作成されたときに作成されます。詳細は@ref{Closures}を参照してください。"

#. type: Plain text
#: original_texis/variables.texi:1125
msgid "When a closure is called as a function, any lexical variable references within its definition use the retained lexical environment.  Here is an example:"
msgstr "クロージャーが関数として呼び出されたとき、その関数の定義内のレキシカル変数にたいする任意の参照は、維持されたレキシカル環境を使用します。以下は例です:"

#. type: example
#: original_texis/variables.texi:1129
#, no-wrap
msgid ""
"(defvar my-ticker nil)   ; @r{We will use this dynamically bound}\n"
"                         ; @r{variable to store a closure.}\n"
"\n"
msgstr ""
"(defvar my-ticker nil)   ; @r{クロージャーを格納するために}\n"
"                         ; @r{この変数を使用する}\n"
"\n"

#. type: example
#: original_texis/variables.texi:1135
#, no-wrap
msgid ""
"(let ((x 0))             ; @r{@code{x} is lexically bound.}\n"
"  (setq my-ticker (lambda ()\n"
"                    (setq x (1+ x)))))\n"
"    @result{} (closure ((x . 0) t) ()\n"
"          (setq x (1+ x)))\n"
"\n"
msgstr ""
"(let ((x 0))             ; @r{@code{x}はレキシカルにバインドされる}\n"
"  (setq my-ticker (lambda ()\n"
"                    (setq x (1+ x)))))\n"
"    @result{} (closure ((x . 0) t) ()\n"
"          (setq x (1+ x)))\n"
"\n"

#. type: example
#: original_texis/variables.texi:1138
#, no-wrap
msgid ""
"(funcall my-ticker)\n"
"    @result{} 1\n"
"\n"
msgstr ""
"(funcall my-ticker)\n"
"    @result{} 1\n"
"\n"

#. type: example
#: original_texis/variables.texi:1141
#, no-wrap
msgid ""
"(funcall my-ticker)\n"
"    @result{} 2\n"
"\n"
msgstr ""
"(funcall my-ticker)\n"
"    @result{} 2\n"
"\n"

#. type: example
#: original_texis/variables.texi:1144
#, no-wrap
msgid ""
"(funcall my-ticker)\n"
"    @result{} 3\n"
"\n"
msgstr ""
"(funcall my-ticker)\n"
"    @result{} 3\n"
"\n"

#. type: example
#: original_texis/variables.texi:1147
#, no-wrap
msgid ""
"x                        ; @r{Note that @code{x} has no global value.}\n"
"@error{} Symbol's value as variable is void: x\n"
msgstr ""
"x                        ; @r{@code{x}はグローバル値をもたないことに注意}\n"
"@error{} Symbol's value as variable is void: x\n"

#. type: Plain text
#: original_texis/variables.texi:1158
msgid "The @code{let} binding defines a lexical environment in which the variable @code{x} is locally bound to 0.  Within this binding construct, we define a lambda expression which increments @code{x} by one and returns the incremented value.  This lambda expression is automatically turned into a closure, in which the lexical environment lives on even after the @code{let} binding construct has exited.  Each time we evaluate the closure, it increments @code{x}, using the binding of @code{x} in that lexical environment."
msgstr "@code{let}バインディングは、内部に変数@code{x}をもつレキシカル環境を定義して、変数は0にローカルにバインドされます。このバインディング構文内で@code{x}を1増加して、増加された値をリターンするクロージャーを定義しています。このラムダ式は自動的にクロージャーとなり、たとえ@code{let}構文を抜けた後でも、その内部ではレキシカル環境が存続します。クロージャーを評価するときは、毎回レキシカル環境内の@code{x}のバインディングが使用されて、@code{x}が加算されます。"

#. type: Plain text
#: original_texis/variables.texi:1166
msgid "Note that unlike dynamic variables which are tied to the symbol object itself, the relationship between lexical variables and symbols is only present in the interpreter (or compiler).  Therefore, functions which take a symbol argument (like @code{symbol-value}, @code{boundp}, and @code{set}) can only retrieve or modify a variable's dynamic binding (i.e., the contents of its symbol's value cell)."
msgstr "シンボルオブジェクト自体に束縛されるダイナミック変数と異なり、レキシカル変数とシンボルの関係はインタープリター(かコンパイラー)内にのみ存在します。したがって(@code{symbol-value}、@code{boundp}、@code{set}のような)シンボル引数を受け取る関数ができるのは、変数のダイナミックなバインディング(そのシンボルの値セルの内容)の取得と変更だけです。"

#. type: Plain text
#: original_texis/variables.texi:1173
msgid "When loading an Emacs Lisp file or evaluating a Lisp buffer, lexical binding is enabled if the buffer-local variable @code{lexical-binding} is non-@code{nil}:"
msgstr "Emacs LispファイルのロードやLispバッファーを評価するとき、バッファーローカルな変数@code{lexical-binding}が非@code{nil}なら、レキシカルバインディングが有効になります:"

#. type: defvar
#: original_texis/variables.texi:1174
#, no-wrap
msgid "lexical-binding"
msgstr "lexical-binding"

#. type: defvar
#: original_texis/variables.texi:1183
msgid "If this buffer-local variable is non-@code{nil}, Emacs Lisp files and buffers are evaluated using lexical binding instead of dynamic binding.  (However, special variables are still dynamically bound; see below.)  If @code{nil}, dynamic binding is used for all local variables.  This variable is typically set for a whole Emacs Lisp file, as a file local variable (@pxref{File Local Variables}).  Note that unlike other such variables, this one must be set in the first line of a file."
msgstr "このバッファーローカルな変数が非@code{nil}なら、Emacs Lispファイルとバッファーはダイナミックバインディングではなくレキシカルバインディングを使用して評価される(しかし特別な変数はダイナミックにバインドされたまま。以下を照)。@code{nil}ならすべてのローカル変数にたいしてダイナミックバインディングが使用される。この変数は、通常はファイルローカル変数として、Emacs Lispファイル全体にたいしてセットされる(@ref{File Local Variables}を参照)。他のファイルローカル変数などとは異なり、ファイルの最初の行でセットされなければならないことに注意。"

#. type: Plain text
#: original_texis/variables.texi:1189
msgid "When evaluating Emacs Lisp code directly using an @code{eval} call, lexical binding is enabled if the @var{lexical} argument to @code{eval} is non-@code{nil}.  @xref{Eval}."
msgstr "@code{eval}呼び出しを使用してEmacs Lispコードを直接評価するとき、@code{eval}の@var{lexical}引数が非@code{nil}なら、レキシカルバインディングが有効になります。@ref{Eval}を参照してください。"

#. type: findex
#: original_texis/variables.texi:1190
#, no-wrap
msgid "eval-expression@r{, and }lexical-binding"
msgstr ""

#. type: Plain text
#: original_texis/variables.texi:1198
msgid "Lexical binding is also enabled in Lisp Interaction and IELM mode, used in the @file{*scratch*} and @file{*ielm*} buffers, and also when evaluating expressions via @kbd{M-:} (@code{eval-expression}) and when processing the @option{--eval} command-line options of Emacs (@pxref{Action Arguments,,, emacs, The GNU Emacs Manual}) and @command{emacsclient} (@pxref{emacsclient Options,,, emacs, The GNU Emacs Manual})."
msgstr ""

#. type: cindex
#: original_texis/variables.texi:1199
#, no-wrap
msgid "special variables"
msgstr "special variables"

#. type: Plain text
#: original_texis/variables.texi:1206
msgid "Even when lexical binding is enabled, certain variables will continue to be dynamically bound.  These are called @dfn{special variables}.  Every variable that has been defined with @code{defvar}, @code{defcustom} or @code{defconst} is a special variable (@pxref{Defining Variables}).  All other variables are subject to lexical binding."
msgstr "レキシカルバインディングが有効な場合でも、特定の変数はダイナミックにバインドされたままです。これらは@dfn{スペシャル変数(special variable)}と呼ばれます。@code{defvar}、@code{defcustom}、@code{defconst}で定義されたすべての変数はスペシャル変数です(@ref{Defining Variables}を参照)。その他のすべての変数はレキシカルバインディングの対象になります。"

#. type: anchor{#1}
#: original_texis/variables.texi:1211
msgid "Local defvar example"
msgstr "Local defvar example"

#. type: Plain text
#: original_texis/variables.texi:1211
msgid "Using @code{defvar} without a value, it is possible to bind a variable dynamically just in one file, or in just one part of a file while still binding it lexically elsewhere.  For example:"
msgstr "値なしで@code{defvar}を使用することにより、他の場所ではレキシカルにバインドされている状態のまま、単一ファイルやファイルの一部だけで変数をダイナミックにバインドすることが可能になります。たとえば:"

#. type: group
#: original_texis/variables.texi:1219
#, no-wrap
msgid ""
"(let (_)\n"
"  (defvar x)      ; @r{Let-bindings of @code{x} will be dynamic within this let.}\n"
"  (let ((x -99))  ; @r{This is a dynamic binding of @code{x}.}\n"
"    (defun get-dynamic-x ()\n"
"      x)))\n"
"\n"
msgstr ""
"(let (_)\n"
"  (defvar x)      ; @r{@code{x}へのletバインドはこのlet内ではダイナミック}\n"
"  (let ((x -99))  ; @r{これは@code{x}のダイナミックバインド}\n"
"    (defun get-dynamic-x ()\n"
"      x)))\n"
"\n"

#. type: group
#: original_texis/variables.texi:1223
#, no-wrap
msgid ""
"(let ((x 'lexical)) ; @r{This is a lexical binding of @code{x}.}\n"
"  (defun get-lexical-x ()\n"
"    x))\n"
"\n"
msgstr ""
"(let ((x 'lexical)) ; @r{これは@code{x}のレキシカルバインド}\n"
"  (defun get-lexical-x ()\n"
"    x))\n"
"\n"

#. type: group
#: original_texis/variables.texi:1230
#, no-wrap
msgid ""
"(let (_)\n"
"  (defvar x)\n"
"  (let ((x 'dynamic))\n"
"    (list (get-lexical-x)\n"
"          (get-dynamic-x))))\n"
"    @result{} (lexical dynamic)\n"
msgstr ""
"(let (_)\n"
"  (defvar x)\n"
"  (let ((x 'dynamic))\n"
"    (list (get-lexical-x)\n"
"          (get-dynamic-x))))\n"
"    @result{} (lexical dynamic)\n"

#. type: defun
#: original_texis/variables.texi:1233
#, no-wrap
msgid "special-variable-p symbol"
msgstr "special-variable-p symbol"

#. type: defun
#: original_texis/variables.texi:1238
msgid "This function returns non-@code{nil} if @var{symbol} is a special variable (i.e., it has a @code{defvar}, @code{defcustom}, or @code{defconst} variable definition).  Otherwise, the return value is @code{nil}."
msgstr "この関数は@var{symbol}がスペシャル変数(つまり変数が@code{defvar}、@code{defcustom}、@code{defconst}による定義をもつ)なら非@code{nil}をリターンする。、それ以外ならリターン値は@code{nil}。"

#. type: defun
#: original_texis/variables.texi:1242
msgid "Note that since this is a function, it can only return non-@code{nil} for variables which are permanently special, but not for those that are only special in the current lexical scope."
msgstr ""

#. type: Plain text
#: original_texis/variables.texi:1248
msgid "The use of a special variable as a formal argument in a function is discouraged.  Doing so gives rise to unspecified behavior when lexical binding mode is enabled (it may use lexical binding sometimes, and dynamic binding other times)."
msgstr "関数内での通常の引数としてのスペシャル変数の使用は、推奨されません。レキシカルバインディングモードが有効なときにこれを行うと、(あるときはレキシカルバインディング、またあるときはダイナミックバインディングのような)不定な動作が起こります。"

#. type: Plain text
#: original_texis/variables.texi:1255
msgid "Converting an Emacs Lisp program to lexical binding is easy.  First, add a file-local variable setting of @code{lexical-binding} to @code{t} in the header line of the Emacs Lisp source file (@pxref{File Local Variables}).  Second, check that every variable in the program which needs to be dynamically bound has a variable definition, so that it is not inadvertently bound lexically."
msgstr "Emacs Lispプログラムをレキシカルバインディングに変換するのは簡単です。最初にEmacs Lispソースファイルのヘッダー行で@code{lexical-binding}を@code{t}にして、ファイルローカル変数を追加します(@ref{File Local Variables}を参照)。次に意図せずレキシカルにバインドしてしまわないように、ダイナミックなバインドをもつ必要がある変数が変数定義をもつことを各変数ごとにチェックします。"

#. type: cindex
#: original_texis/variables.texi:1256
#, no-wrap
msgid "free variable"
msgstr "free variable"

#. type: cindex
#: original_texis/variables.texi:1257
#, no-wrap
msgid "unused lexical variable"
msgstr "unused lexical variable"

#. type: Plain text
#: original_texis/variables.texi:1266
msgid "A simple way to find out which variables need a variable definition is to byte-compile the source file.  @xref{Byte Compilation}.  If a non-special variable is used outside of a @code{let} form, the byte-compiler will warn about reference or assignment to a free variable.  If a non-special variable is bound but not used within a @code{let} form, the byte-compiler will warn about an unused lexical variable.  The byte-compiler will also issue a warning if you use a special variable as a function argument."
msgstr "どの変数が変数定義をもつ必要があるか見つけるシンプルな方法は、ソースファイルをバイトコンパイルすることです。@ref{Byte Compilation}を参照してください。@code{let}フォームの外側で非スペシャル変数が使用されていれば、バイトコンパイラーはフリーな変数にたいする参照や割り当てについて警告するでしょう。非スペシャル変数がバインドされているが@code{let}フォーム内で使用されていなければ、バイトコンパイラーは使用されないレキシカル変数に関して警告するでしょう。バイトコンパイラーは、スペシャル変数を関数の引数として使用している場合も問題を警告します。"

#. type: Plain text
#: original_texis/variables.texi:1271
msgid "(To silence byte-compiler warnings about unused variables, just use a variable name that starts with an underscore.  The byte-compiler interprets this as an indication that this is a variable known not to be used.)"
msgstr "(使用されていない変数についての警告を抑制するためには単に変数名をアンダースコアーで開始する。そうすればバイトコンパイラーは変数が使用されないことを示すと解釈する。)"

#. type: cindex
#: original_texis/variables.texi:1274
#, no-wrap
msgid "variable, buffer-local"
msgstr "variable, buffer-local"

#. type: cindex
#: original_texis/variables.texi:1275
#, no-wrap
msgid "buffer-local variables"
msgstr "buffer-local variables"

#. type: Plain text
#: original_texis/variables.texi:1284
msgid "Global and local variable bindings are found in most programming languages in one form or another.  Emacs, however, also supports additional, unusual kinds of variable binding, such as @dfn{buffer-local} bindings, which apply only in one buffer.  Having different values for a variable in different buffers is an important customization method.  (Variables can also have bindings that are local to each terminal.  @xref{Multiple Terminals}.)"
msgstr "グローバルおよびローカルな変数バインディングは、いずれかの形式をほとんどのプログラミング言語で見つけることができます。しかしEmacsは1つのバッファーだけに適用される@dfn{バッファーローカル(buffer-local)}なバインディング用に、普通には存在しない類の変数バインディングもサポートしています。ある変数にたいして異なるバッファーごとに別の値をもつのは、カスタマイズでの重要な手法です(変数は端末ごとにローカルなバインディングをもつこともできる。@ref{Multiple Terminals}を参照)。"

#. type: node
#: original_texis/variables.texi:1290 original_texis/variables.texi:1292
#, no-wrap
msgid "Intro to Buffer-Local"
msgstr "Intro to Buffer-Local"

#. type: menuentry
#: original_texis/variables.texi:1290
msgid "Introduction and concepts."
msgstr "イントロダクションと概念。"

#. type: node
#: original_texis/variables.texi:1290 original_texis/variables.texi:1386
#, no-wrap
msgid "Creating Buffer-Local"
msgstr "Creating Buffer-Local"

#. type: menuentry
#: original_texis/variables.texi:1290
msgid "Creating and destroying buffer-local bindings."
msgstr "バッファーローカルなバインディングの作成と削除。"

#. type: node
#: original_texis/variables.texi:1290 original_texis/variables.texi:1627
#, no-wrap
msgid "Default Value"
msgstr "Default Value"

#. type: menuentry
#: original_texis/variables.texi:1290
msgid "The default value is seen in buffers that don't have their own buffer-local values."
msgstr "自身ではバッファーローカルな値をもたないバッファーで参照されるデフォルト値。"

#. type: subsection
#: original_texis/variables.texi:1293
#, no-wrap
msgid "Introduction to Buffer-Local Variables"
msgstr "Introduction to Buffer-Local Variables"

#. type: Plain text
#: original_texis/variables.texi:1301
msgid "A buffer-local variable has a buffer-local binding associated with a particular buffer.  The binding is in effect when that buffer is current; otherwise, it is not in effect.  If you set the variable while a buffer-local binding is in effect, the new value goes in that binding, so its other bindings are unchanged.  This means that the change is visible only in the buffer where you made it."
msgstr "バッファーローカル変数は特定のバッファーに関連づけられた、バッファーローカルなバインディングをもちます。このバインディングはそのバッファーがカレントのときに効果をもち、カレントでないときには効果がありません。バッファーローカルなバインディングが効力をもつときにその変数をセットすると、そのバインディングは新しい値をもちますが他のバインディングは変更されません。これはバッファーローカルなバインディングを作成したバッファーだけで変更が見えることを意味します。"

#. type: Plain text
#: original_texis/variables.texi:1305
msgid "The variable's ordinary binding, which is not associated with any specific buffer, is called the @dfn{default binding}.  In most cases, this is the global binding."
msgstr "その変数にたいする特定のバッファーに関連しない通常のバインディングは、@dfn{デフォルトバインディング(default binding)}と呼ばれます。これはほとんどの場合はグローバルバインディングです。"

#. type: Plain text
#: original_texis/variables.texi:1313
msgid "A variable can have buffer-local bindings in some buffers but not in other buffers.  The default binding is shared by all the buffers that don't have their own bindings for the variable.  (This includes all newly-created buffers.)  If you set the variable in a buffer that does not have a buffer-local binding for it, this sets the default binding, so the new value is visible in all the buffers that see the default binding."
msgstr "変数はあるバッファーではバッファーローカルなバインディングをもつことができ、他のバッファーではもたないことができます。デフォルトバインディングは、その変数にたいして自身のバインディングをもたないすべてのバッファーで共有されます(これには新たに作成されたバッファーが含まれる)。ある変数にたいして、その変数のバッファーローカルなバインディングをもたないバッファーでその変数をセットすると、それによりデフォルトバインディングがセットされるので、デフォルトバインディングを参照するすべてのバッファーで新しい値を見ることになります。"

#. type: Plain text
#: original_texis/variables.texi:1320
msgid "The most common use of buffer-local bindings is for major modes to change variables that control the behavior of commands.  For example, C mode and Lisp mode both set the variable @code{paragraph-start} to specify that only blank lines separate paragraphs.  They do this by making the variable buffer-local in the buffer that is being put into C mode or Lisp mode, and then setting it to the new value for that mode.  @xref{Major Modes}."
msgstr "バッファーローカルなバインディングのもっとも一般的な使用は、メジャーモードがコマンドの動作を制御するために変数を変更する場合です。たとえばCモードやLispモードは、空行だけがパラグラフの区切りになるように変数@code{paragraph-start}をセットします。これらのモードは、CモードやLispモードになるようなバッファー内でこの変数をバッファーローカルにすることでこれを行って、その後そのモードにたいする新しい値をセットします。@ref{Major Modes}を参照してください。"

#. type: Plain text
#: original_texis/variables.texi:1326
msgid "The usual way to make a buffer-local binding is with @code{make-local-variable}, which is what major mode commands typically use.  This affects just the current buffer; all other buffers (including those yet to be created) will continue to share the default value unless they are explicitly given their own buffer-local bindings."
msgstr "バッファーローカルなバインディングを作成する通常の方法は、@code{make-local-variable}による方法で、これは通常はメジャーモードが使用します。これはカレントバッファーだけに効果があります。その他すべてのバッファー(まだ作成されていないバッファーを含む)は、それらのバッファー自身が明示的にバッファーローカルなバインディングを与えるまでデフォルト値を共有し続けます。"

#. type: cindex
#: original_texis/variables.texi:1327
#, no-wrap
msgid "automatically buffer-local"
msgstr "automatically buffer-local"

#. type: Plain text
#: original_texis/variables.texi:1340
msgid "A more powerful operation is to mark the variable as @dfn{automatically buffer-local} by calling @code{make-variable-buffer-local}.  You can think of this as making the variable local in all buffers, even those yet to be created.  More precisely, the effect is that setting the variable automatically makes the variable local to the current buffer if it is not already so.  All buffers start out by sharing the default value of the variable as usual, but setting the variable creates a buffer-local binding for the current buffer.  The new value is stored in the buffer-local binding, leaving the default binding untouched.  This means that the default value cannot be changed with @code{setq} in any buffer; the only way to change it is with @code{setq-default}."
msgstr "変数を@dfn{自動的にバッファーローカルになる}ようにマークする、より強力な操作は@code{make-variable-buffer-local}を呼び出すことにより行われます。これはたとえその変数がまだ作成されていなくても、変数をすべてのバッファーにたいしてローカルにすると考えることができます。より正確には変数を自動的にセットすることにより、その変数がカレントバッファーにたいしてローカルでなくても、変数をローカルにする効果があります。すべてのバッファーは最初は通常のようにデフォルト値を共有しますが、変数をセットすることでカレントバッファーにたいしてバッファーローカルなバインディングを作成します。新たな値はバッファーローカルなバインディングに格納され、デフォルトバインディングは変更されずに残ります。これは任意のバッファーで@code{setq}によりデフォルト値を変更できないことを意味します。変更する唯一の方法は@code{setq-default}だけです。"

#. type: Plain text
#: original_texis/variables.texi:1352
msgid "@strong{Warning:} When a variable has buffer-local bindings in one or more buffers, @code{let} rebinds the binding that's currently in effect.  For instance, if the current buffer has a buffer-local value, @code{let} temporarily rebinds that.  If no buffer-local bindings are in effect, @code{let} rebinds the default value.  If inside the @code{let} you then change to a different current buffer in which a different binding is in effect, you won't see the @code{let} binding any more.  And if you exit the @code{let} while still in the other buffer, you won't see the unbinding occur (though it will occur properly).  Here is an example to illustrate:"
msgstr "@strong{警告:} ある変数が1つ以上のバッファーでバッファーローカルなバインディングをもつ際に、@code{let}はそのとき効力がある変数のバインディングをリバインドします。たとえばカレントバッファーがバッファーローカルな値をもつなら、@code{let}は一時的にそれをリバインドします。効力があるバッファーローカルなバインディングが存在しなければ@code{let}はデフォルト値をリバインドします。@code{let}の内部で、別のバインディングが効力をもつ別のバッファーをカレントバッファーにすると、それ以上@code{let}バインディングを参照できなくなります。他のバッファーにいる間に@code{let}を抜けると、(たとえそれが正しくても)バインディングの解消を見ることはできません。以下にこれを示します:"

#. type: group
#: original_texis/variables.texi:1358
#, no-wrap
msgid ""
"(setq foo 'g)\n"
"(set-buffer \"a\")\n"
"(make-local-variable 'foo)\n"
msgstr ""
"(setq foo 'g)\n"
"(set-buffer \"a\")\n"
"(make-local-variable 'foo)\n"

#. type: example
#: original_texis/variables.texi:1365
#, no-wrap
msgid ""
"(setq foo 'a)\n"
"(let ((foo 'temp))\n"
"  ;; foo @result{} 'temp  ; @r{let binding in buffer @samp{a}}\n"
"  (set-buffer \"b\")\n"
"  ;; foo @result{} 'g     ; @r{the global value since foo is not local in @samp{b}}\n"
"  @var{body}@dots{})\n"
msgstr ""
"(setq foo 'a)\n"
"(let ((foo 'temp))\n"
"  ;; foo @result{} 'temp  ; @r{バッファー@samp{a}内でのletバインディング}\n"
"  (set-buffer \"b\")\n"
"  ;; foo @result{} 'g     ; @r{fooは@samp{b}にたいしてローカルではないためグローバル値}\n"
"  @var{body}@dots{})\n"

#. type: group
#: original_texis/variables.texi:1368
#, no-wrap
msgid ""
"foo @result{} 'g        ; @r{exiting restored the local value in buffer @samp{a},}\n"
"                 ; @r{but we don't see that in buffer @samp{b}}\n"
msgstr ""
"foo @result{} 'g        ; @r{exitによりバッファー@samp{a}のローカル値が復元されるが}\n"
"                 ; @r{バッファー@samp{b}では見ることができない}\n"

#. type: group
#: original_texis/variables.texi:1372
#, no-wrap
msgid ""
"(set-buffer \"a\") ; @r{verify the local value was restored}\n"
"foo @result{} 'a\n"
msgstr ""
"(set-buffer \"a\") ; @r{ローカル値が復元されたことを確認}\n"
"foo @result{} 'a\n"

#. type: Plain text
#: original_texis/variables.texi:1378
msgid "Note that references to @code{foo} in @var{body} access the buffer-local binding of buffer @samp{b}."
msgstr "@var{body}内の@code{foo}にたいする参照は、バッファー@samp{b}のバッファーローカルなバインディングにアクセスすることに注意してください。"

#. type: Plain text
#: original_texis/variables.texi:1382
msgid "When a file specifies local variable values, these become buffer-local values when you visit the file.  @xref{File Variables,,, emacs, The GNU Emacs Manual}."
msgstr "あるファイルがローカル変数の値をセットする場合、これらの変数はファイルをvisitするときバッファーローカルな値になります。@ref{File Variables,,, emacs, The GNU Emacs Manual}を参照してください。"

#. type: Plain text
#: original_texis/variables.texi:1385
msgid "A buffer-local variable cannot be made terminal-local (@pxref{Multiple Terminals})."
msgstr "バッファーローカル変数を端末ローカル(terminal-local)にすることはできません(@ref{Multiple Terminals}を参照)。"

#. type: subsection
#: original_texis/variables.texi:1387
#, no-wrap
msgid "Creating and Deleting Buffer-Local Bindings"
msgstr "Creating and Deleting Buffer-Local Bindings"

#. type: deffn
#: original_texis/variables.texi:1389
#, no-wrap
msgid "Command make-local-variable variable"
msgstr "Command make-local-variable variable"

#. type: deffn
#: original_texis/variables.texi:1393
msgid "This function creates a buffer-local binding in the current buffer for @var{variable} (a symbol).  Other buffers are not affected.  The value returned is @var{variable}."
msgstr "この関数はカレントバッファー内で、@var{variable}(シンボル)にたいするバッファーローカルなバインディングを作成する。他のバッファーは影響を受けない。リターンされる値は@var{variable}。"

#. type: deffn
#: original_texis/variables.texi:1397
msgid "The buffer-local value of @var{variable} starts out as the same value @var{variable} previously had.  If @var{variable} was void, it remains void."
msgstr "@var{variable}のバッファーローカルな値は、最初は以前に@var{variable}がもっていた値と同じ値をもつ。@var{variable}がvoidのときはvoidのまま。"

#. type: group
#: original_texis/variables.texi:1403
#, no-wrap
msgid ""
";; @r{In buffer @samp{b1}:}\n"
"(setq foo 5)                ; @r{Affects all buffers.}\n"
"     @result{} 5\n"
msgstr ""
";; @r{バッファー@samp{b1}で行う:}\n"
"(setq foo 5)                ; @r{すべてのバッファーに影響する。}\n"
"     @result{} 5\n"

#. type: group
#: original_texis/variables.texi:1407
#, no-wrap
msgid ""
"(make-local-variable 'foo)  ; @r{Now it is local in @samp{b1}.}\n"
"     @result{} foo\n"
msgstr ""
"(make-local-variable 'foo)  ; @r{@samp{b1}内でローカルになった}\n"
"     @result{} foo\n"

#. type: group
#: original_texis/variables.texi:1411
#, no-wrap
msgid ""
"foo                         ; @r{That did not change}\n"
"     @result{} 5                   ;   @r{the value.}\n"
msgstr ""
"foo                         ; @r{値は変更されない}\n"
"     @result{} 5\n"

#. type: group
#: original_texis/variables.texi:1415
#, no-wrap
msgid ""
"(setq foo 6)                ; @r{Change the value}\n"
"     @result{} 6                   ;   @r{in @samp{b1}.}\n"
msgstr ""
"(setq foo 6)                ; @r{@samp{b1}内で値を変更}\n"
"     @result{} 6\n"

#. type: group
#: original_texis/variables.texi:1419
#, no-wrap
msgid ""
"foo\n"
"     @result{} 6\n"
msgstr ""
"foo\n"
"     @result{} 6\n"

#. type: group
#: original_texis/variables.texi:1426
#, no-wrap
msgid ""
";; @r{In buffer @samp{b2}, the value hasn't changed.}\n"
"(with-current-buffer \"b2\"\n"
"  foo)\n"
"     @result{} 5\n"
msgstr ""
";; @r{バッファー@samp{b2}では、値は変更されていない}\n"
"(with-current-buffer \"b2\"\n"
"  foo)\n"
"     @result{} 5\n"

#. type: deffn
#: original_texis/variables.texi:1434
msgid "Making a variable buffer-local within a @code{let}-binding for that variable does not work reliably, unless the buffer in which you do this is not current either on entry to or exit from the @code{let}.  This is because @code{let} does not distinguish between different kinds of bindings; it knows only which variable the binding was made for."
msgstr "変数を@code{let}バインディングでバッファーローカルにしても、@code{let}への出入り時の両方でこれを行うバッファーがカレントでなければ信頼性はない。これは@code{let}がバインディングの種類を区別しないからである。@code{let}に解るのはバインディングが作成される変数だけである。"

#. type: deffn
#: original_texis/variables.texi:1437 original_texis/variables.texi:1485
msgid "It is an error to make a constant or a read-only variable buffer-local.  @xref{Constant Variables}."
msgstr "定数や読み取り専用の変数をバッファーローカルにするとエラーになる。@ref{Constant Variables}を参照のこと。"

#. type: deffn
#: original_texis/variables.texi:1441
msgid "If the variable is terminal-local (@pxref{Multiple Terminals}), this function signals an error.  Such variables cannot have buffer-local bindings as well."
msgstr "変数が端末ローカル(@ref{Multiple Terminals}を参照)なら、この関数はエラーをシグナルする。そのような変数はバッファーローカルなバインディングをもつことができない。"

#. type: deffn
#: original_texis/variables.texi:1446
msgid "@strong{Warning:} do not use @code{make-local-variable} for a hook variable.  The hook variables are automatically made buffer-local as needed if you use the @var{local} argument to @code{add-hook} or @code{remove-hook}."
msgstr "@strong{警告:} フック変数にたいして@code{make-local-variable}を使用しないこと。フック変数は@code{add-hook}か@code{remove-hook}の@var{local}引数を使用すると、必要に応じて自動でバッファーローカルになる。"

#. type: defmac
#: original_texis/variables.texi:1448
#, fuzzy, no-wrap
#| msgid "setq-local variable value"
msgid "setq-local &rest pairs"
msgstr "setq-local variable value"

#. type: defmac
#: original_texis/variables.texi:1454
#, fuzzy
#| msgid "This macro creates a buffer-local binding in the current buffer for @var{variable}, and gives it the buffer-local value @var{value}.  It is equivalent to calling @code{make-local-variable} followed by @code{setq}.  @var{variable} should be an unquoted symbol."
msgid "@var{pairs} is a list of variable and value pairs.  This macro creates a buffer-local binding in the current buffer for each of the variables, and gives them a buffer-local value.  It is equivalent to calling @code{make-local-variable} followed by @code{setq} for each of the variables.  The variables should be unquoted symbols."
msgstr "このマクロはカレントバッファー内で@var{variable}にたいするバッファーローカルなバインディングを作成して、それにバッファーローカルな値@var{value}を与える。このマクロは@code{make-local-variable}に続けて@code{setq}を呼び出すのと同じ。@var{variable}はクォートされていないシンボル。"

#. type: lisp
#: original_texis/variables.texi:1458
#, no-wrap
msgid ""
"(setq-local var1 \"value1\"\n"
"            var2 \"value2\")\n"
msgstr ""

#. type: deffn
#: original_texis/variables.texi:1461
#, no-wrap
msgid "Command make-variable-buffer-local variable"
msgstr "Command make-variable-buffer-local variable"

#. type: deffn
#: original_texis/variables.texi:1468
msgid "This function marks @var{variable} (a symbol) automatically buffer-local, so that any subsequent attempt to set it will make it local to the current buffer at the time.  Unlike @code{make-local-variable}, with which it is often confused, this cannot be undone, and affects the behavior of the variable in all buffers."
msgstr "このコマンドは@var{variable}(シンボル)が自動的にバッファーローカルになるようにマークするので、それ以降にその変数へのセットを試みると、その時点でカレントのバッファーにローカルになる。しばしば混乱を招く@code{make-local-variable}とは異なり、これが取り消されることはなく、すべてのバッファー内での変数の挙動に影響する。"

#. type: deffn
#: original_texis/variables.texi:1474
msgid "A peculiar wrinkle of this feature is that binding the variable (with @code{let} or other binding constructs) does not create a buffer-local binding for it.  Only setting the variable (with @code{set} or @code{setq}), while the variable does not have a @code{let}-style binding that was made in the current buffer, does so."
msgstr "この機能特有の欠点は、(@code{let}やその他のバインディング構文による)変数のバインディングが、その変数にたいするバッファーローカルなバインディングを作成しないことである。(@code{set}や@code{setq}による)変数のセットだけは、その変数がカレントバッファーで作成された@code{let}スタイルのバインディングをもたないので、ローカルなバインディングを作成する。"

#. type: deffn
#: original_texis/variables.texi:1480
msgid "If @var{variable} does not have a default value, then calling this command will give it a default value of @code{nil}.  If @var{variable} already has a default value, that value remains unchanged.  Subsequently calling @code{makunbound} on @var{variable} will result in a void buffer-local value and leave the default value unaffected."
msgstr "@var{variable}がデフォルト値をもたない場合、このコマンドの呼び出しは@code{nil}のデフォルト値を与える。@var{variable}がすでにデフォルト値をもつなら、その値は変更されずに残る。それ以降に@var{variable}にたいして@code{makunbound}を呼び出すと、バッファーローカル値をvoidにして、デフォルト値は影響を受けずに残る。"

#. type: deffn
#: original_texis/variables.texi:1482
msgid "The value returned is @var{variable}."
msgstr "▼リターン値は@var{variable}。"

#. type: deffn
#: original_texis/variables.texi:1491
msgid "@strong{Warning:} Don't assume that you should use @code{make-variable-buffer-local} for user-option variables, simply because users @emph{might} want to customize them differently in different buffers.  Users can make any variable local, when they wish to.  It is better to leave the choice to them."
msgstr "@strong{警告:} ユーザーオプション変数では、ユーザーは異なるバッファーにたいして異なるカスタマイズを望む@emph{かもしれない}ので、@code{make-variable-buffer-local}を使うべきだと決め込むべきではない。ユーザーは望むなら任意の変数をローカルにできる。その選択の余地を残すほうがよい。"

#. type: deffn
#: original_texis/variables.texi:1497
msgid "The time to use @code{make-variable-buffer-local} is when it is crucial that no two buffers ever share the same binding.  For example, when a variable is used for internal purposes in a Lisp program which depends on having separate values in separate buffers, then using @code{make-variable-buffer-local} can be the best solution."
msgstr "@code{make-variable-buffer-local}を使用すべきなのは、複数のバッファーが同じバインディングを共有しないことが自明な場合である。たとえばバッファーごとに個別な値をもつことに依存するLispプログラム内の内部プロセスにたいして変数が使用されるときは、@code{make-variable-buffer-local}の使用が最善の解決策になるかもしれない。"

#. type: defmac
#: original_texis/variables.texi:1499
#, no-wrap
msgid "defvar-local variable value &optional docstring"
msgstr "defvar-local variable value &optional docstring"

#. type: defmac
#: original_texis/variables.texi:1505
msgid "This macro defines @var{variable} as a variable with initial value @var{value} and @var{docstring}, and marks it as automatically buffer-local.  It is equivalent to calling @code{defvar} followed by @code{make-variable-buffer-local}.  @var{variable} should be an unquoted symbol."
msgstr "このマクロは@var{variable}を初期値@var{value}と@var{docstring}の変数として定義して、それを自動的にバッファーローカルとマークする。これは@code{defvar}の後につづけて@code{make-variable-buffer-local}を呼び出すのと同じ。@var{variable}はクォートされていないシンボル。"

#. type: defun
#: original_texis/variables.texi:1507
#, no-wrap
msgid "local-variable-p variable &optional buffer"
msgstr "local-variable-p variable &optional buffer"

#. type: defun
#: original_texis/variables.texi:1511
msgid "This returns @code{t} if @var{variable} is buffer-local in buffer @var{buffer} (which defaults to the current buffer); otherwise, @code{nil}."
msgstr "これは@var{variable}がバッファー@var{buffer}(デフォルトはカレントバッファー)内でバッファーローカルなら@code{t}、それ以外は@code{nil}をリターンする。"

#. type: defun
#: original_texis/variables.texi:1513
#, no-wrap
msgid "local-variable-if-set-p variable &optional buffer"
msgstr "local-variable-if-set-p variable &optional buffer"

#. type: defun
#: original_texis/variables.texi:1518
msgid "This returns @code{t} if @var{variable} either has a buffer-local value in buffer @var{buffer}, or is automatically buffer-local.  Otherwise, it returns @code{nil}.  If omitted or @code{nil}, @var{buffer} defaults to the current buffer."
msgstr "これは@var{variable}がバッファー@var{buffer}内でバッファーローカル値をもつ、または自動的にバッファーローカルになるなら@code{t}、それ以外は@code{nil}をリターンする。@var{buffer}が省略または@code{nil}の場合のデフォルトはカレントバッファー。"

#. type: defun
#: original_texis/variables.texi:1520
#, no-wrap
msgid "buffer-local-value variable buffer"
msgstr "buffer-local-value variable buffer"

#. type: defun
#: original_texis/variables.texi:1525
msgid "This function returns the buffer-local binding of @var{variable} (a symbol) in buffer @var{buffer}.  If @var{variable} does not have a buffer-local binding in buffer @var{buffer}, it returns the default value (@pxref{Default Value}) of @var{variable} instead."
msgstr "この関数はバッファー@var{buffer}内の、@var{variable}(シンボル)のバッファーローカルなバインディングをリターンする。@var{variable}がバッファー@var{buffer}内でバッファーローカルなバインディングをもたなければ、かわりに@var{variable}のデフォルト値(@ref{Default Value}を参照)をリターンする。"

#. type: defun
#: original_texis/variables.texi:1527
#, no-wrap
msgid "buffer-local-variables &optional buffer"
msgstr "buffer-local-variables &optional buffer"

#. type: defun
#: original_texis/variables.texi:1535
msgid "This function returns a list describing the buffer-local variables in buffer @var{buffer}.  (If @var{buffer} is omitted, the current buffer is used.)  Normally, each list element has the form @w{@code{(@var{sym} . @var{val})}}, where @var{sym} is a buffer-local variable (a symbol) and @var{val} is its buffer-local value.  But when a variable's buffer-local binding in @var{buffer} is void, its list element is just @var{sym}."
msgstr "この関数はバッファー@var{buffer}内のバッファーローカル変数を表すリストをリターンする(@var{buffer}が省略された場合はカレントバッファーが使用される)。リストの各要素は通常は@w{@code{(@var{sym} . @var{val})}}という形式をもつ。ここで@var{sym}はバッファーローカル変数(シンボル)、@var{val}はバッファーローカル値。しかし@var{buffer}内のある変数のバッファーローカルなバインディングがvoidなら、その変数に対応するリスト要素は単に@var{sym}となる。"

#. type: group
#: original_texis/variables.texi:1542
#, no-wrap
msgid ""
"(make-local-variable 'foobar)\n"
"(makunbound 'foobar)\n"
"(make-local-variable 'bind-me)\n"
"(setq bind-me 69)\n"
msgstr ""
"(make-local-variable 'foobar)\n"
"(makunbound 'foobar)\n"
"(make-local-variable 'bind-me)\n"
"(setq bind-me 69)\n"

#. type: example
#: original_texis/variables.texi:1549
#, no-wrap
msgid ""
"(setq lcl (buffer-local-variables))\n"
"    ;; @r{First, built-in variables local in all buffers:}\n"
"@result{} ((mark-active . nil)\n"
"    (buffer-undo-list . nil)\n"
"    (mode-name . \"Fundamental\")\n"
"    @dots{}\n"
msgstr ""
"(setq lcl (buffer-local-variables))\n"
"    ;; @r{最初はすべてのバッファー内でローカルなビルトイン変数:}\n"
"@result{} ((mark-active . nil)\n"
"    (buffer-undo-list . nil)\n"
"    (mode-name . \"Fundamental\")\n"
"    @dots{}\n"

#. type: group
#: original_texis/variables.texi:1555
#, no-wrap
msgid ""
"    ;; @r{Next, non-built-in buffer-local variables.}\n"
"    ;; @r{This one is buffer-local and void:}\n"
"    foobar\n"
"    ;; @r{This one is buffer-local and nonvoid:}\n"
"    (bind-me . 69))\n"
msgstr ""
"    ;; @r{次にビルトインでないバッファーローカル変数}\n"
"    ;; @r{This one is buffer-local and void:}\n"
"    foobar\n"
"    ;; @r{これはバッファーローカルでvoidではない:}\n"
"    (bind-me . 69))\n"

#. type: defun
#: original_texis/variables.texi:1560
msgid "Note that storing new values into the @sc{cdr}s of cons cells in this list does @emph{not} change the buffer-local values of the variables."
msgstr "このリスト内のコンスセルの@sc{cdr}に新たな値を格納しても、その変数のバッファーローカル値は@emph{変化しない}ことに注意。"

#. type: deffn
#: original_texis/variables.texi:1562
#, no-wrap
msgid "Command kill-local-variable variable"
msgstr "Command kill-local-variable variable"

#. type: deffn
#: original_texis/variables.texi:1569
msgid "This function deletes the buffer-local binding (if any) for @var{variable} (a symbol) in the current buffer.  As a result, the default binding of @var{variable} becomes visible in this buffer.  This typically results in a change in the value of @var{variable}, since the default value is usually different from the buffer-local value just eliminated."
msgstr "この関数はカレントバッファー内の@var{variable}(シンボル)にたいするバッファーローカルなバインディング(もしあれば)を削除する。その結果として、このバッファー内で@var{variable}のデフォルトバインディングが可視になる。これは通常は@var{variable}の値を変更する。デフォルト値は削除されたバッファーローカル値とは異なるのが普通だからである。"

#. type: deffn
#: original_texis/variables.texi:1574
msgid "If you kill the buffer-local binding of a variable that automatically becomes buffer-local when set, this makes the default value visible in the current buffer.  However, if you set the variable again, that will once again create a buffer-local binding for it."
msgstr "セットしたとき自動的にバッファーローカルになる変数のバッファーローカルなバインディングをkillすると、これによりカレントバッファー内でデフォルト値が可視になる。しかし変数を再度セットすると、その変数にたいするバッファーローカルなバインディングが再作成される。"

#. type: deffn
#: original_texis/variables.texi:1576
msgid "@code{kill-local-variable} returns @var{variable}."
msgstr "@code{kill-local-variable}は@var{variable}をreturnします。"

#. type: deffn
#: original_texis/variables.texi:1580
msgid "This function is a command because it is sometimes useful to kill one buffer-local variable interactively, just as it is useful to create buffer-local variables interactively."
msgstr "この関数はコマンドである。なぜならバッファーローカル変数のインタラクティブな作成が有用な場合があるように、あるバッファーローカル変数のインタラクティブなkillが有用な場合があるからである。"

#. type: cindex
#: original_texis/variables.texi:1582
#, no-wrap
msgid "local variables, killed by major mode"
msgstr "local variables, killed by major mode"

#. type: defun
#: original_texis/variables.texi:1583
#, no-wrap
msgid "kill-all-local-variables"
msgstr "kill-all-local-variables"

#. type: defun
#: original_texis/variables.texi:1589
msgid "This function eliminates all the buffer-local variable bindings of the current buffer except for variables marked as permanent and local hook functions that have a non-@code{nil} @code{permanent-local-hook} property (@pxref{Setting Hooks}).  As a result, the buffer will see the default values of most variables."
msgstr "この関数はpermanent(永続的)とマークされた変数と@code{permanent-local-hook}プロパティーに非@code{nil}をもつローカルフック関数(@ref{Setting Hooks}を参照)を除き、カレントバッファーのすべてのバッファーローカルなバインディングを解消する。結果として、そのバッファーのほとんどの変数がデフォルト値を参照するようになる。"

#. type: defun
#: original_texis/variables.texi:1595
msgid "This function also resets certain other information pertaining to the buffer: it sets the local keymap to @code{nil}, the syntax table to the value of @code{(standard-syntax-table)}, the case table to @code{(standard-case-table)}, and the abbrev table to the value of @code{fundamental-mode-abbrev-table}."
msgstr "この関数はそのバッファーに関連する他の特定の情報もリセットする。これはローカルキーマップを@code{nil}、構文テーブルを@code{(standard-syntax-table)}の値、caseテーブルを@code{(standard-case-table)}、abbrevテーブルを@code{fundamental-mode-abbrev-table}の値にセットする。"

#. type: defun
#: original_texis/variables.texi:1598
msgid "The very first thing this function does is run the normal hook @code{change-major-mode-hook} (see below)."
msgstr "この関数が1番最初に行うのはノーマルフック@code{change-major-mode-hook}(以下参照)の実行である。"

#. type: defun
#: original_texis/variables.texi:1603
msgid "Every major mode command begins by calling this function, which has the effect of switching to Fundamental mode and erasing most of the effects of the previous major mode.  To ensure that this does its job, the variables that major modes set should not be marked permanent."
msgstr "すべてのメジャーモードコマンドは、Fundamentalモードにスイッチする効果をもち、以前のメジャーモードのほとんどの効果を消去する、この関数を呼び出すことによって開始されます。この関数が処理を行うのを確実にするために、メジャーモードがセットする変数はpermanentとマークすべきではない。"

#. type: defun
#: original_texis/variables.texi:1605
msgid "@code{kill-all-local-variables} returns @code{nil}."
msgstr "@code{kill-all-local-variables} returns @code{nil}."

#. type: defvar
#: original_texis/variables.texi:1607
#, no-wrap
msgid "change-major-mode-hook"
msgstr "change-major-mode-hook"

#. type: defvar
#: original_texis/variables.texi:1613
msgid "The function @code{kill-all-local-variables} runs this normal hook before it does anything else.  This gives major modes a way to arrange for something special to be done if the user switches to a different major mode.  It is also useful for buffer-specific minor modes that should be forgotten if the user changes the major mode."
msgstr "関数@code{kill-all-local-variables}は、何か他のことを行う前にまずこのノーマルフックを実行する。この関数はメジャーモードにたいして、ユーザーが他のメジャーモードにスイッチした場合に行われる何か特別なことを準備する方法を与える。この関数はユーザーがメジャーモードを変更した場合に忘れられるべき、バッファー固有のマイナーモードにたいしても有用。"

#. type: defvar
#: original_texis/variables.texi:1617
msgid "For best results, make this variable buffer-local, so that it will disappear after doing its job and will not interfere with the subsequent major mode.  @xref{Hooks}."
msgstr "最善の結果を得るために、この変数をバッファーローカルにすれば、処理が終了したときに消えるので、以降のメジャーモードに干渉しなくなる。@ref{Hooks}を参照のこと。"

#. type: cindex
#: original_texis/variables.texi:1619
#, no-wrap
msgid "permanent local variable"
msgstr "permanent local variable"

#. type: Plain text
#: original_texis/variables.texi:1626
msgid "A buffer-local variable is @dfn{permanent} if the variable name (a symbol) has a @code{permanent-local} property that is non-@code{nil}.  Such variables are unaffected by @code{kill-all-local-variables}, and their local bindings are therefore not cleared by changing major modes.  Permanent locals are appropriate for data pertaining to where the file came from or how to save it, rather than with how to edit the contents."
msgstr "変数名(シンボル)が非@code{nil}の@code{permanent-local}プロパティーをもつなら、そのバッファーローカル変数は@dfn{permanent(永続的)}です。そのような変数は@code{kill-all-local-variables}の影響を受けず、したがってメジャーモードの変更によりそれらのローカルバインディングは作成されません。permanentなローカル変数はファイルの内容を編集する方法ではなく、どこから読み込んだファイルか、あるいはどのように保存するかといったことに関連するデータに適しています。"

#. type: subsection
#: original_texis/variables.texi:1628
#, no-wrap
msgid "The Default Value of a Buffer-Local Variable"
msgstr "The Default Value of a Buffer-Local Variable"

#. type: cindex
#: original_texis/variables.texi:1629
#, no-wrap
msgid "default value"
msgstr "default value"

#. type: Plain text
#: original_texis/variables.texi:1635
msgid "The global value of a variable with buffer-local bindings is also called the @dfn{default} value, because it is the value that is in effect whenever neither the current buffer nor the selected frame has its own binding for the variable."
msgstr "バッファーローカルなバインディングをもつ変数のグローバル値も@dfn{デフォルト値(default)}値と呼ばれます。なぜならその変数にたいしてカレントバッファーや選択されたフレームもバインディングをもたなければ、その値が常に効果をもつからです。"

#. type: Plain text
#: original_texis/variables.texi:1643
msgid "The functions @code{default-value} and @code{setq-default} access and change a variable's default value regardless of whether the current buffer has a buffer-local binding.  For example, you could use @code{setq-default} to change the default setting of @code{paragraph-start} for most buffers; and this would work even when you are in a C or Lisp mode buffer that has a buffer-local value for this variable."
msgstr "関数@code{default-value}と@code{setq-default}は、カレントバッファーがバッファーローカルなバインディングをもつかどうかに関わらず、その変数のデフォルト値にアクセスまたは変更します。たとえばほとんどのバッファーにたいして、@code{paragraph-start}のデフォルトのセッティングを変更するために、@code{setq-default}を使用できます。そしてこの変数にたいするバッファーローカルな値をもつCモードやLispモードにいるときでさえ、これは機能します。"

#. type: Plain text
#: original_texis/variables.texi:1648
msgid "The special forms @code{defvar} and @code{defconst} also set the default value (if they set the variable at all), rather than any buffer-local value."
msgstr "スペシャルフォーム@code{defvar}と@code{defconst}もバッファーローカルな値ではなく、(もし変数にセットする場合は)デフォルト値をセットします。"

#. type: defun
#: original_texis/variables.texi:1649
#, no-wrap
msgid "default-value symbol"
msgstr "default-value symbol"

#. type: defun
#: original_texis/variables.texi:1654
msgid "This function returns @var{symbol}'s default value.  This is the value that is seen in buffers and frames that do not have their own values for this variable.  If @var{symbol} is not buffer-local, this is equivalent to @code{symbol-value} (@pxref{Accessing Variables})."
msgstr "この関数は@var{symbol}のデフォルト値をリターンする。これはこの変数にたいして独自の値をもたないバッファーやフレームから参照される値である。@var{symbol}がバッファーローカルでなければ、これは@code{symbol-value}(@ref{Accessing Variables}を参照)と同じ。"

#. type: defun
#: original_texis/variables.texi:1657
#, no-wrap
msgid "default-boundp symbol"
msgstr "default-boundp symbol"

#. type: defun
#: original_texis/variables.texi:1661
msgid "The function @code{default-boundp} tells you whether @var{symbol}'s default value is nonvoid.  If @code{(default-boundp 'foo)} returns @code{nil}, then @code{(default-value 'foo)} would get an error."
msgstr "関数@code{default-boundp}は@var{symbol}のデフォルト値がvoidでないか報告する。@code{(default-boundp 'foo)}が@code{nil}をリターンした場合には@code{(default-value 'foo)}はエラーになる。"

#. type: defun
#: original_texis/variables.texi:1664
msgid "@code{default-boundp} is to @code{default-value} as @code{boundp} is to @code{symbol-value}."
msgstr "@code{default-boundp}は@code{default-value}、@code{boundp}は@code{symbol-value}にたいする述語である。"

#. type: defspec
#: original_texis/variables.texi:1666
#, no-wrap
msgid "setq-default [symbol form]@dots{}"
msgstr "setq-default [symbol form]@dots{}"

#. type: defspec
#: original_texis/variables.texi:1671
msgid "This special form gives each @var{symbol} a new default value, which is the result of evaluating the corresponding @var{form}.  It does not evaluate @var{symbol}, but does evaluate @var{form}.  The value of the @code{setq-default} form is the value of the last @var{form}."
msgstr "このスペシャルフォームは各@var{symbol}に新たなデフォルト値として、対応する@var{form}を評価した結果を与える。これは@var{symbol}を評価しないが@var{form}は評価する。@code{setq-default}フォームの値は最後の@var{form}の値。"

#. type: defspec
#: original_texis/variables.texi:1678
msgid "If a @var{symbol} is not buffer-local for the current buffer, and is not marked automatically buffer-local, @code{setq-default} has the same effect as @code{setq}.  If @var{symbol} is buffer-local for the current buffer, then this changes the value that other buffers will see (as long as they don't have a buffer-local value), but not the value that the current buffer sees."
msgstr "カレントバッファーにたいして@var{symbol}がバッファーローカルでなく、自動的にバッファーローカルにマークされていなければ、@code{setq-default}は@code{setq}と同じ効果をもつ。カレントバッファーにたいして@var{symbol}がバッファーローカルなら、(バッファーローカルな値をもたない)他のバッファーから参照できる値を変更するが、それはカレントバッファーが参照する値ではない。"

#. type: group
#: original_texis/variables.texi:1684
#, no-wrap
msgid ""
";; @r{In buffer @samp{foo}:}\n"
"(make-local-variable 'buffer-local)\n"
"     @result{} buffer-local\n"
msgstr ""
";; @r{バッファー@samp{foo}で行う:}\n"
"(make-local-variable 'buffer-local)\n"
"     @result{} buffer-local\n"

#. type: group
#: original_texis/variables.texi:1688
#, no-wrap
msgid ""
"(setq buffer-local 'value-in-foo)\n"
"     @result{} value-in-foo\n"
msgstr ""
"(setq buffer-local 'value-in-foo)\n"
"     @result{} value-in-foo\n"

#. type: group
#: original_texis/variables.texi:1692
#, no-wrap
msgid ""
"(setq-default buffer-local 'new-default)\n"
"     @result{} new-default\n"
msgstr ""
"(setq-default buffer-local 'new-default)\n"
"     @result{} new-default\n"

#. type: group
#: original_texis/variables.texi:1696
#, no-wrap
msgid ""
"buffer-local\n"
"     @result{} value-in-foo\n"
msgstr ""
"buffer-local\n"
"     @result{} value-in-foo\n"

#. type: group
#: original_texis/variables.texi:1700 original_texis/variables.texi:1710
#, no-wrap
msgid ""
"(default-value 'buffer-local)\n"
"     @result{} new-default\n"
msgstr ""
"(default-value 'buffer-local)\n"
"     @result{} new-default\n"

#. type: group
#: original_texis/variables.texi:1706
#, no-wrap
msgid ""
";; @r{In (the new) buffer @samp{bar}:}\n"
"buffer-local\n"
"     @result{} new-default\n"
msgstr ""
";; @r{(新しい)バッファー@samp{bar}で行う:}\n"
"buffer-local\n"
"     @result{} new-default\n"

#. type: group
#: original_texis/variables.texi:1714
#, no-wrap
msgid ""
"(setq buffer-local 'another-default)\n"
"     @result{} another-default\n"
msgstr ""
"(setq buffer-local 'another-default)\n"
"     @result{} another-default\n"

#. type: group
#: original_texis/variables.texi:1718
#, no-wrap
msgid ""
"(default-value 'buffer-local)\n"
"     @result{} another-default\n"
msgstr ""
"(default-value 'buffer-local)\n"
"     @result{} another-default\n"

#. type: group
#: original_texis/variables.texi:1726
#, no-wrap
msgid ""
";; @r{Back in buffer @samp{foo}:}\n"
"buffer-local\n"
"     @result{} value-in-foo\n"
"(default-value 'buffer-local)\n"
"     @result{} another-default\n"
msgstr ""
";; @r{バッファー@samp{foo}に戻って行う:}\n"
"buffer-local\n"
"     @result{} value-in-foo\n"
"(default-value 'buffer-local)\n"
"     @result{} another-default\n"

#. type: defun
#: original_texis/variables.texi:1730
#, no-wrap
msgid "set-default symbol value"
msgstr "set-default symbol value"

#. type: defun
#: original_texis/variables.texi:1733
msgid "This function is like @code{setq-default}, except that @var{symbol} is an ordinary evaluated argument."
msgstr "この関数は@code{setq-default}と似ているが、@var{symbol}は通常の引数として評価される。"

#. type: group
#: original_texis/variables.texi:1738
#, no-wrap
msgid ""
"(set-default (car '(a b c)) 23)\n"
"     @result{} 23\n"
msgstr ""
"(set-default (car '(a b c)) 23)\n"
"     @result{} 23\n"

#. type: group
#: original_texis/variables.texi:1742
#, no-wrap
msgid ""
"(default-value 'a)\n"
"     @result{} 23\n"
msgstr ""
"(default-value 'a)\n"
"     @result{} 23\n"

#. type: Plain text
#: original_texis/variables.texi:1753
msgid "A variable can be let-bound (@pxref{Local Variables}) to a value.  This makes its global value shadowed by the binding; @code{default-value} will then return the value from that binding, not the global value, and @code{set-default} will be prevented from setting the global value (it will change the let-bound value instead).  The following two functions allow to reference the global value even if it's shadowed by a let-binding."
msgstr "ある変数に値をletバインドできます(@ref{Local Variables}を参照)。このバインディングにより変数のグローバル値はシャドーされます。@code{default-value}はグローバル値ではなくそのバインディングの値をリターンして、@code{set-default}によるグローバル値のセットは防がれます(かわりにletバインドされた値が変更される)。以下の2つの関数によりletバインドでグローバル値がシャドーされていてもグローバル値を参照できます。"

#. type: cindex
#: original_texis/variables.texi:1754
#, no-wrap
msgid "top-level default value"
msgstr "top-level default value"

#. type: defun
#: original_texis/variables.texi:1755
#, no-wrap
msgid "default-toplevel-value symbol"
msgstr "default-toplevel-value symbol"

#. type: defun
#: original_texis/variables.texi:1758
msgid "This function returns the @dfn{top-level} default value of @var{symbol}, which is its value outside of any let-binding."
msgstr "この関数は@var{symbol}にたいするすべてのletバインディングの外部の値として@dfn{トップレベル}のデフォルト値をリターンする。"

#. type: group
#: original_texis/variables.texi:1764
#, no-wrap
msgid ""
"(defvar variable 'global-value)\n"
"    @result{} variable\n"
msgstr ""
"(defvar variable 'global-value)\n"
"    @result{} variable\n"

#. type: group
#: original_texis/variables.texi:1769
#, no-wrap
msgid ""
"(let ((variable 'let-binding))\n"
"  (default-value 'variable))\n"
"    @result{} let-binding\n"
msgstr ""
"(let ((variable 'let-binding))\n"
"  (default-value 'variable))\n"
"    @result{} let-binding\n"

#. type: group
#: original_texis/variables.texi:1774
#, no-wrap
msgid ""
"(let ((variable 'let-binding))\n"
"  (default-toplevel-value 'variable))\n"
"    @result{} global-value\n"
msgstr ""
"(let ((variable 'let-binding))\n"
"  (default-toplevel-value 'variable))\n"
"    @result{} global-value\n"

#. type: defun
#: original_texis/variables.texi:1777
#, no-wrap
msgid "set-default-toplevel-value symbol value"
msgstr "set-default-toplevel-value symbol value"

#. type: defun
#: original_texis/variables.texi:1782
msgid "This function sets the top-level default value of @var{symbol} to the specified @var{value}.  This comes in handy when you want to set the global value of @var{symbol} regardless of whether your code runs in the context of @var{symbol}'s let-binding."
msgstr "この関数は@var{symbol}のトップレベルのデフォルト値に指定された@var{value}をセットする。これはコードが@var{symbol}のletバインディングのコンテキスト下で実行中かどうかとは無関係に@var{symbol}のグローバル値をセットしたいときに便利。"

#. type: cindex
#: original_texis/variables.texi:1787
#, no-wrap
msgid "file local variables"
msgstr "file local variables"

#. type: Plain text
#: original_texis/variables.texi:1795
msgid "A file can specify local variable values; Emacs uses these to create buffer-local bindings for those variables in the buffer visiting that file.  @xref{File Variables, , Local Variables in Files, emacs, The GNU Emacs Manual}, for basic information about file-local variables.  This section describes the functions and variables that affect how file-local variables are processed."
msgstr "ファイルにローカル変数の値を指定できます。そのファイルをvisitしているバッファー内で、これらの変数にたいしてバッファーローカルなバインディングを作成するために、Emacsはこれらを使用します。ファイルローカル変数の基本的な情報については、@ref{File Variables, , Local Variables in Files, emacs, The GNU Emacs Manual}を参照してください。このセクションではファイルローカル変数が処理される方法に影響する関数と変数を説明します。"

#. type: Plain text
#: original_texis/variables.texi:1801
msgid "If a file-local variable could specify an arbitrary function or Lisp expression that would be called later, visiting a file could take over your Emacs.  Emacs protects against this by automatically setting only those file-local variables whose specified values are known to be safe.  Other file-local variables are set only if the user agrees."
msgstr "ファイルローカル変数が勝手に関数や、後で呼び出されるLisp式を指定できたら、ファイルのvisitによってEmacsが乗っ取られてしまうかもしれません。Emacsは既知のファイルローカル変数だけにたいして、指定された値が安全だと自動的にセットすることにより、この危険から保護します。これ以外のファイルローカル変数は、ユーザーが同意した場合のみセットされます。"

#. type: Plain text
#: original_texis/variables.texi:1806
msgid "For additional safety, @code{read-circle} is temporarily bound to @code{nil} when Emacs reads file-local variables (@pxref{Input Functions}).  This prevents the Lisp reader from recognizing circular and shared Lisp structures (@pxref{Circular Objects})."
msgstr "追加の安全策としてEmacsがファイルローカル変数を読み込むとき、一時的に@code{read-circle}を@code{nil}にバインドします(@ref{Input Functions}を参照)。これは循環認識と共有されたLisp構造からLispリーダーを保護します(@ref{Circular Objects}を参照)。"

#. type: defopt
#: original_texis/variables.texi:1807
#, no-wrap
msgid "enable-local-variables"
msgstr "enable-local-variables"

#. type: defopt
#: original_texis/variables.texi:1810
msgid "This variable controls whether to process file-local variables.  The possible values are:"
msgstr "この変数はファイルローカル変数を処理するかどうかを制御する。以下の値が利用できる:"

#. type: item
#: original_texis/variables.texi:1812
#, no-wrap
msgid "@code{t} (the default)"
msgstr "@code{t}(デフォルト)"

#. type: table
#: original_texis/variables.texi:1814
msgid "Set the safe variables, and query (once) about any unsafe variables."
msgstr "安全な変数をセット、安全でない変数は問い合わせる(1回)。"

#. type: code{#1}
#: original_texis/variables.texi:1814
#, no-wrap
msgid ":safe"
msgstr ":safe"

#. type: table
#: original_texis/variables.texi:1816
msgid "Set only the safe variables and do not query."
msgstr "安全な変数だけをセット、問い合わせはしない。"

#. type: code{#1}
#: original_texis/variables.texi:1816
#, no-wrap
msgid ":all"
msgstr ":all"

#. type: table
#: original_texis/variables.texi:1818
msgid "Set all the variables and do not query."
msgstr "問い合わせをせずに、すべての変数をセット。"

#. type: code{#1}
#: original_texis/variables.texi:1818
#, no-wrap
msgid "nil"
msgstr "nil"

#. type: table
#: original_texis/variables.texi:1820
msgid "Don't set any variables."
msgstr "変数をセットしない。"

#. type: item
#: original_texis/variables.texi:1820
#, no-wrap
msgid "anything else"
msgstr "その他"

#. type: table
#: original_texis/variables.texi:1822
msgid "Query (once) about all the variables."
msgstr "すべての変数にたいして問い合わせる(1回)。"

#. type: defvar
#: original_texis/variables.texi:1825
#, no-wrap
msgid "inhibit-local-variables-regexps"
msgstr "inhibit-local-variables-regexps"

#. type: defvar
#: original_texis/variables.texi:1830
msgid "This is a list of regular expressions.  If a file has a name matching an element of this list, then it is not scanned for any form of file-local variable.  For examples of why you might want to use this, @pxref{Auto Major Mode}."
msgstr "これは正規表現のリストである。ファイルがこのリストの要素にマッチする名前をもつなら、すべてのファイルローカル変数のフォームはスキャンされない。どんなときにこれを使いたいかの例は、@ref{Auto Major Mode}を参照のこと。"

#. type: defun
#: original_texis/variables.texi:1832
#, no-wrap
msgid "hack-local-variables &optional handle-mode"
msgstr "hack-local-variables &optional handle-mode"

#. type: defun
#: original_texis/variables.texi:1839
msgid "This function parses, and binds or evaluates as appropriate, any local variables specified by the contents of the current buffer.  The variable @code{enable-local-variables} has its effect here.  However, this function does not look for the @samp{mode:} local variable in the @w{@samp{-*-}} line.  @code{set-auto-mode} does that, also taking @code{enable-local-variables} into account (@pxref{Auto Major Mode})."
msgstr "この関数はカレントバッファーの内容により指定された任意のローカル変数にたいしてパースを行い、適切にバインドと評価を行う。変数@code{enable-local-variables}はここでも効果をもつ。しかしこの関数は@w{@samp{-*-}}行の、@samp{mode:}ローカル変数を探さない。@code{set-auto-mode}はこれを行って@code{enable-local-variables}も考慮する(@ref{Auto Major Mode}を参照)。"

#. type: defun
#: original_texis/variables.texi:1848
msgid "This function works by walking the alist stored in @code{file-local-variables-alist} and applying each local variable in turn.  It calls @code{before-hack-local-variables-hook} and @code{hack-local-variables-hook} before and after applying the variables, respectively.  It only calls the before-hook if the alist is non-@code{nil}; it always calls the other hook.  This function ignores a @samp{mode} element if it specifies the same major mode as the buffer already has."
msgstr "この関数は@code{file-local-variables-alist}内に格納されたalistを調べて、各ローカル変数を順に適用することにより機能する。この関数は変数に適用する前(か後)に、@code{before-hack-local-variables-hook}(か@code{hack-local-variables-hook})を呼び出す。alistが非@code{nil}の場合のみ、事前のフック(before-hook)を呼び出し、その他のフックは常に呼び出す。この関数はそのバッファーがすでにもつメジャーモードと同じメジャーモードが指定された場合は@samp{mode}要素を無視する。"

#. type: defun
#: original_texis/variables.texi:1858
msgid "If the optional argument @var{handle-mode} is @code{t}, then all this function does is return a symbol specifying the major mode, if the @w{@samp{-*-}} line or the local variables list specifies one, and @code{nil} otherwise.  It does not set the mode or any other file-local variable.  If @var{handle-mode} has any value other than @code{nil} or @code{t}, any settings of @samp{mode} in the @w{@samp{-*-}} line or the local variables list are ignored, and the other settings are applied.  If @var{handle-mode} is @code{nil}, all the file local variables are set."
msgstr "オプションの引数@var{handle-mode}が@code{t}なら、この関数が行うのはメジャーモードを指定するシンボルをリターンすることだけであり、@w{@samp{-*-}}行やローカル変数リストがメジャーモードを指定していればそのモード、それ以外は@code{nil}をリターンする。この関数はモードや他のファイルローカル変数をセットしない。@var{handle-mode}の値が@code{nil}と@code{t}のいずれでもなければ@w{@samp{-*-}}行の@samp{mode}に関するすべてのセッティングとローカル変数リストは無視されて、別のセッティングが適用される。@var{handle-mode}が@code{nil}ならすべてのファイルローカル変数がセットされる。"

#. type: defvar
#: original_texis/variables.texi:1860
#, no-wrap
msgid "file-local-variables-alist"
msgstr "file-local-variables-alist"

#. type: defvar
#: original_texis/variables.texi:1868
msgid "This buffer-local variable holds the alist of file-local variable settings.  Each element of the alist is of the form @w{@code{(@var{var} . @var{value})}}, where @var{var} is a symbol of the local variable and @var{value} is its value.  When Emacs visits a file, it first collects all the file-local variables into this alist, and then the @code{hack-local-variables} function applies them one by one."
msgstr "このバッファーローカルな変数は、ファイルローカル変数のセッティングのalistを保持する。alistの各要素は@w{@code{(@var{var} . @var{value})}}という形式で、@var{var}はローカル変数のシンボル、@var{value}はその値である。Emacsがファイルをvisitするとき、最初にすべてのファイルローカル変数をこのalistに収集して、その後で変数に1つずつ関数@code{hack-local-variables}を適用する。"

#. type: defvar
#: original_texis/variables.texi:1870
#, no-wrap
msgid "before-hack-local-variables-hook"
msgstr "before-hack-local-variables-hook"

#. type: defvar
#: original_texis/variables.texi:1873
msgid "Emacs calls this hook immediately before applying file-local variables stored in @code{file-local-variables-alist}."
msgstr "Emacsは@code{file-local-variables-alist}に格納されたファイルローカル変数を適用する直前にこのフックを呼び出す。"

#. type: defvar
#: original_texis/variables.texi:1875
#, no-wrap
msgid "hack-local-variables-hook"
msgstr "hack-local-variables-hook"

#. type: defvar
#: original_texis/variables.texi:1878
msgid "Emacs calls this hook immediately after it finishes applying file-local variables stored in @code{file-local-variables-alist}."
msgstr "Emacsは@code{file-local-variables-alist}に格納されたファイルローカル変数を適用し終えた直後にこのフックを呼び出す。"

#. type: cindex
#: original_texis/variables.texi:1880
#, no-wrap
msgid "safe local variable"
msgstr "safe local variable"

#. type: Plain text
#: original_texis/variables.texi:1889
msgid "You can specify safe values for a variable with a @code{safe-local-variable} property.  The property has to be a function of one argument; any value is safe if the function returns non-@code{nil} given that value.  Many commonly-encountered file variables have @code{safe-local-variable} properties; these include @code{fill-column}, @code{fill-prefix}, and @code{indent-tabs-mode}.  For boolean-valued variables that are safe, use @code{booleanp} as the property value."
msgstr "ある変数にたいして@code{safe-local-variable}プロパティーによって安全な値を指定できます。このプロパティーは引数を1つとる関数です。与えられた値にたいして、その関数が非@code{nil}をリターンしたらその値は安全です。一般的に目にするファイル変数の多くは、@code{safe-local-variable}プロパティーをもちます。これらのファイル変数には@code{fill-column}、@code{fill-prefix}、@code{indent-tabs-mode}が含まれます。ブーリーン値の変数にたいしては、プロパティーの値に@code{booleanp}を使用します。"

#. type: Plain text
#: original_texis/variables.texi:1894
msgid "If you want to define @code{safe-local-variable} properties for variables defined in C source code, add the names and the properties of those variables to the list in the ``Safe local variables'' section of @file{files.el}."
msgstr "Cソースコード内で定義された変数に@code{safe-local-variable}プロパティを定義したければ、それらの変数の名前とプロパティを@file{files.el}のセクション``Safe local variables''のリストに追加してください。"

#. type: cindex
#: original_texis/variables.texi:1895
#, no-wrap
msgid "autoload cookie, and safe values of variable"
msgstr "autoload cookie, and safe values of variable"

#. type: Plain text
#: original_texis/variables.texi:1904
msgid "When defining a user option using @code{defcustom}, you can set its @code{safe-local-variable} property by adding the arguments @code{:safe @var{function}} to @code{defcustom} (@pxref{Variable Definitions}).  However, a safety predicate defined using @code{:safe} will only be known once the package that contains the @code{defcustom} is loaded, which is often too late.  As an alternative, you can use the autoload cookie (@pxref{Autoload}) to assign the option its safety predicate, like this:"
msgstr "@code{defcustom}を使用してユーザーオプションを定義する際には、@code{defcustom}に引数@code{:safe @var{function}}を追加して@code{safe-local-variable}プロパティをセットできます(@ref{Variable Definitions}を参照)。しかし@code{:safe}を使用して定義された安全性の述語は、その@code{defcustom}を含むパッケージのロード時の一度だけ認識されるものであり、それでは遅すぎることがしばしばあります。代替策としては、以下のようにオプションに安全性の述語を割り当てるためにautoloadクッキー(@ref{Autoload}を参照)を使用できます:"

#. type: lisp
#: original_texis/variables.texi:1907
#, no-wrap
msgid ";;;###autoload (put '@var{var} 'safe-local-variable '@var{pred})\n"
msgstr ";;;###autoload (put '@var{var} 'safe-local-variable '@var{pred})\n"

#. type: Plain text
#: original_texis/variables.texi:1914
msgid "The safe value definitions specified with @code{autoload} are copied into the package's autoloads file (@file{loaddefs.el} for most packages bundled with Emacs), and are known to Emacs since the beginning of a session."
msgstr "@code{autoload}で指定された安全な値の定義は、そのパッケージのautoloadファイル(Emacsに同梱されたパッケージのほとんどでは@file{loaddefs.el})にコピーされて、セッションの開始からEmacsにより認識されます。"

#. type: defopt
#: original_texis/variables.texi:1915
#, no-wrap
msgid "safe-local-variable-values"
msgstr "safe-local-variable-values"

#. type: defopt
#: original_texis/variables.texi:1920
msgid "This variable provides another way to mark some variable values as safe.  It is a list of cons cells @code{(@var{var} . @var{val})}, where @var{var} is a variable name and @var{val} is a value which is safe for that variable."
msgstr "この変数はある変数の値が安全であることをマークする、別の方法を提供する。これはコンスセル@code{(@var{var} . @var{val})}のリストであり@var{var}は変数名、@var{val}はその変数にたいして安全な値である。"

#. type: defopt
#: original_texis/variables.texi:1926
msgid "When Emacs asks the user whether or not to obey a set of file-local variable specifications, the user can choose to mark them as safe.  Doing so adds those variable/value pairs to @code{safe-local-variable-values}, and saves it to the user's custom file."
msgstr "Emacsが一連のファイルローカル変数にしたがうかどうかユーザーに尋ねるとき、ユーザーはそれらの変数が安全だとマークすることができる。安全とマークすると@code{safe-local-variable-values}にこれらのvariable/valueペアーが追加されて、ユーザーのカスタムファイルに保存する。"

#. type: defun
#: original_texis/variables.texi:1928
#, no-wrap
msgid "safe-local-variable-p sym val"
msgstr "safe-local-variable-p sym val"

#. type: defun
#: original_texis/variables.texi:1931
msgid "This function returns non-@code{nil} if it is safe to give @var{sym} the value @var{val}, based on the above criteria."
msgstr "この関数は上記の条件に基づき、@var{sym}に値@var{val}を与えても安全ななら非@code{nil}をリターンする。"

#. type: Plain text
#: original_texis/variables.texi:1939
msgid "Some variables are considered @dfn{risky}.  If a variable is risky, it is never entered automatically into @code{safe-local-variable-values}; Emacs always queries before setting a risky variable, unless the user explicitly allows a value by customizing @code{safe-local-variable-values} directly."
msgstr "いくつかの変数は@dfn{危険(risky)}だと判断されます。ある変数が危険なら、その変数が@code{safe-local-variable-values}に自動的に追加されることはありません。ユーザーが@code{safe-local-variable-values}を直接カスタマイズすることで明示的に値を許さない限り、危険な変数をセットする前にEmacsは常に確認を求めます。"

#. type: Plain text
#: original_texis/variables.texi:1953
msgid "Any variable whose name has a non-@code{nil} @code{risky-local-variable} property is considered risky.  When you define a user option using @code{defcustom}, you can set its @code{risky-local-variable} property by adding the arguments @code{:risky @var{value}} to @code{defcustom} (@pxref{Variable Definitions}).  In addition, any variable whose name ends in any of @samp{-command}, @samp{-frame-alist}, @samp{-function}, @samp{-functions}, @samp{-hook}, @samp{-hooks}, @samp{-form}, @samp{-forms}, @samp{-map}, @samp{-map-alist}, @samp{-mode-alist}, @samp{-program}, or @samp{-predicate} is automatically considered risky.  The variables @samp{font-lock-keywords}, @samp{font-lock-keywords} followed by a digit, and @samp{font-lock-syntactic-keywords} are also considered risky."
msgstr "名前が非@code{nil}の@code{risky-local-variable}プロパティーをもつすべての変数は危険だと判断されます。@code{defcustom}を使用してユーザーオプションを定義するとき、@code{defcustom}に引数@code{:risky @var{value}}を追加することにより、ユーザーオプションに@code{risky-local-variable}プロパティーをセットできます。それに加えて名前が@samp{-command}、@samp{-frame-alist}、@samp{-function}、@samp{-functions}、@samp{-hook}、@samp{-hooks}、@samp{-form}、@samp{-forms}、@samp{-map}、@samp{-map-alist}、@samp{-mode-alist}、@samp{-program}、@samp{-predicate}で終わるすべての変数は自動的に危険だと判断されます。後に数字をともなう変数@samp{font-lock-keywords}と@samp{font-lock-keywords}、さらには@samp{font-lock-syntactic-keywords}も危険だと判断されます。"

#. type: defun
#: original_texis/variables.texi:1954
#, no-wrap
msgid "risky-local-variable-p sym"
msgstr "risky-local-variable-p sym"

#. type: defun
#: original_texis/variables.texi:1957
msgid "This function returns non-@code{nil} if @var{sym} is a risky variable, based on the above criteria."
msgstr "この関数は@var{sym}が上記の条件にもとづき危険な変数なら非@code{nil}をリターンする。"

#. type: defvar
#: original_texis/variables.texi:1959
#, no-wrap
msgid "ignored-local-variables"
msgstr "ignored-local-variables"

#. type: defvar
#: original_texis/variables.texi:1963
msgid "This variable holds a list of variables that should not be given local values by files.  Any value specified for one of these variables is completely ignored."
msgstr "この変数はファイルによりローカル値を与えらるべきではない変数のリストを保持する。これらの変数に指定された任意の値は、完全に無視される。"

#. type: Plain text
#: original_texis/variables.texi:1967
msgid "The @samp{Eval:} ``variable'' is also a potential loophole, so Emacs normally asks for confirmation before handling it."
msgstr "``変数''@samp{Eval:}も抜け道になる可能性があるので、Emacsは通常はそれを処理する前に確認を求めます。"

#. type: defopt
#: original_texis/variables.texi:1968
#, no-wrap
msgid "enable-local-eval"
msgstr "enable-local-eval"

#. type: defopt
#: original_texis/variables.texi:1974
msgid "This variable controls processing of @samp{Eval:} in @samp{-*-} lines or local variables lists in files being visited.  A value of @code{t} means process them unconditionally; @code{nil} means ignore them; anything else means ask the user what to do for each file.  The default value is @code{maybe}."
msgstr "この変数は@samp{-*-}の行中、またはvisitされるファイル内のローカル変数リストにたいする、@samp{Eval:}の処理を制御する。値@code{t}は無条件に実行し、@code{nil}はそれらを無視することを意味します。それ以外なら各ファイルにたいして何を行うか、ユーザーに確認を求めることを意味する。デフォルト値は@code{maybe}。"

#. type: defopt
#: original_texis/variables.texi:1976
#, no-wrap
msgid "safe-local-eval-forms"
msgstr "safe-local-eval-forms"

#. type: defopt
#: original_texis/variables.texi:1980
msgid "This variable holds a list of expressions that are safe to evaluate when found in the @samp{Eval:} ``variable'' in a file local variables list."
msgstr "この変数はファイルローカル変数リスト内で@samp{Eval:}``変数''が見つかった際に評価しても安全な式のリストを保持する。"

#. type: Plain text
#: original_texis/variables.texi:1988
msgid "If the expression is a function call and the function has a @code{safe-local-eval-function} property, the property value determines whether the expression is safe to evaluate.  The property value can be a predicate to call to test the expression, a list of such predicates (it's safe if any predicate succeeds), or @code{t} (always safe provided the arguments are constant)."
msgstr "式が関数呼び出しであり、その関数が@code{safe-local-eval-function}プロパティーをもつなら、その式の評価が安全かどうかはそのプロパティー値が決定します。プロパティー値はその式をテストするための述語(predicate)、そのような述語のリスト(成功した述語があれば安全)、または@code{t}(引数が定数である限り常に安全)を指定できます。"

#. type: Plain text
#: original_texis/variables.texi:1992
msgid "Text properties are also potential loopholes, since their values could include functions to call.  So Emacs discards all text properties from string values specified for file-local variables."
msgstr "テキストプロパティーには、それらの値に関数呼び出しを含めることができるので抜け道になる可能性があります。したがってEmacsはファイルローカル変数にたいして指定された文字列値から、テキストプロパティーを取り除きます。"

#. type: cindex
#: original_texis/variables.texi:1995
#, no-wrap
msgid "directory local variables"
msgstr "directory local variables"

#. type: Plain text
#: original_texis/variables.texi:2002
msgid "A directory can specify local variable values common to all files in that directory; Emacs uses these to create buffer-local bindings for those variables in buffers visiting any file in that directory.  This is useful when the files in the directory belong to some @dfn{project} and therefore share the same local variables."
msgstr "ディレクトリーは、そのディレクトリー内のすべてのファイルに共通なローカル変数値を指定することができます。Emacsはそのディレクトリー内の任意のファイルをvisitしているバッファー内で、それらの変数にたいするバッファーローカルなバインディングを作成するためにこれを使用します。これはそのディレクトリー内のファイルが何らかの@dfn{プロジェクト}に属していて、同じローカル変数を共有するときなどに有用です。"

#. type: Plain text
#: original_texis/variables.texi:2006
msgid "There are two different methods for specifying directory local variables: by putting them in a special file, or by defining a @dfn{project class} for that directory."
msgstr "ディレクトリーローカル変数を指定するために2つの異なる方法があります: 1つは特別なファイルにそれを記述する方法、もう1つはそのディレクトリーに@dfn{プロジェクトクラス(project class)}を定義する方法です。"

#. type: defvr
#: original_texis/variables.texi:2007
#, no-wrap
msgid "Constant dir-locals-file"
msgstr "Constant dir-locals-file"

#. type: defvr
#: original_texis/variables.texi:2027
#, fuzzy
#| msgid "This constant is the name of the file where Emacs expects to find the directory-local variables.  The name of the file is @file{.dir-locals.el}@footnote{ The MS-DOS version of Emacs uses @file{_dir-locals.el} instead, due to limitations of the DOS filesystems.  }.  A file by that name in a directory causes Emacs to apply its settings to any file in that directory or any of its subdirectories (optionally, you can exclude subdirectories; see below).  If some of the subdirectories have their own @file{.dir-locals.el} files, Emacs uses the settings from the deepest file it finds starting from the file's directory and moving up the directory tree.  This constant is also used to derive the name of a second dir-locals file @file{.dir-locals-2.el}.  If this second dir-locals file is present, then that is loaded instead of @file{.dir-locals.el}.  This is useful when @file{.dir-locals.el} is under version control in a shared repository and cannot be used for personal customizations.  The file specifies local variables as a specially formatted list; see @ref{Directory Variables, , Per-directory Local Variables, emacs, The GNU Emacs Manual}, for more details."
msgid "This constant is the name of the file where Emacs expects to find the directory-local variables.  The name of the file is @file{.dir-locals.el}@footnote{ The MS-DOS version of Emacs uses @file{_dir-locals.el} instead, due to limitations of the DOS filesystems.  }.  A file by that name in a directory causes Emacs to apply its settings to any file in that directory or any of its subdirectories (optionally, you can exclude subdirectories; see below).  If some of the subdirectories have their own @file{.dir-locals.el} files, Emacs uses the settings from the deepest file it finds starting from the file's directory and moving up the directory tree.  This constant is also used to derive the name of a second dir-locals file @file{.dir-locals-2.el}.  If this second dir-locals file is present, then that is loaded in addition to @file{.dir-locals.el}.  This is useful when @file{.dir-locals.el} is under version control in a shared repository and cannot be used for personal customizations.  The file specifies local variables as a specially formatted list; see @ref{Directory Variables, , Per-directory Local Variables, emacs, The GNU Emacs Manual}, for more details."
msgstr "この定数はEmacsがディレクトリーローカル変数を見つけることができると期待するファイルの名前。ファイル名は@file{.dir-locals.el}@footnote{MS-DOS版のEmacsはDOSファイルシステムの制限により、かわりに@file{_dir-locals.el}という名前を使用します。}。ディレクトリー内でその名前をもつファイルによりEmacsはディレクトリー内の任意のファイル、または任意のサブディレクトリー(オプションでサブディレクトリーを除外できる。以下参照し)にセッティングを適用する。独自に@file{.dir-locals.el}をもつサブディレクトリーがある場合には、Emacsはサブディレクトリーで見つかったもっとも深いファイルのディレクトリーからディレクトリーツリーを上方に移動しながら、もっとも深いファイルのセッティングを使用する。この定数は2番目のdir-localsファイル@file{.dir-locals-2.el}の名前を導出するためにも使用される。この2番目のdir-localsファイルが与えられた場合には、そのファイルが@file{.dir-locals.el}のかわりにロードされる。これは@file{.dir-locals.el}がバージョンコントロールの共有リポジトリの配下にあって個人のカスタマイズ用に使用できないときに有用。このファイルはローカル変数をフォーマットされたリストとして指定する。詳細は@ref{Directory Variables, , Per-directory Local Variables, emacs, The GNU Emacs Manual}を参照のこと。"

#. type: defun
#: original_texis/variables.texi:2029
#, no-wrap
msgid "hack-dir-local-variables"
msgstr "hack-dir-local-variables"

#. type: defun
#: original_texis/variables.texi:2038
msgid "This function reads the @code{.dir-locals.el} file and stores the directory-local variables in @code{file-local-variables-alist} that is local to the buffer visiting any file in the directory, without applying them.  It also stores the directory-local settings in @code{dir-locals-class-alist}, where it defines a special class for the directory in which @file{.dir-locals.el} file was found.  This function works by calling @code{dir-locals-set-class-variables} and @code{dir-locals-set-directory-class}, described below."
msgstr "この関数は@code{.dir-locals.el}ファイルを読み込み、そのディレクトリー内の任意のファイルをvisitしているバッファーにローカルな@code{file-local-variables-alist}内に、それらを適用することなくディレクトリーローカル変数を格納する。この関数はディレクトリーローカルなセッティングも@code{dir-locals-class-alist}(@file{.dir-locals.el}ファイルが見つかったディレクトリーにたいする特別なクラスを定義する)内に格納する。この関数は以下で説明するように、@code{dir-locals-set-class-variables}と@code{dir-locals-set-directory-class}を呼び出すことにより機能する。"

#. type: defun
#: original_texis/variables.texi:2040
#, no-wrap
msgid "hack-dir-local-variables-non-file-buffer"
msgstr "hack-dir-local-variables-non-file-buffer"

#. type: defun
#: original_texis/variables.texi:2047
msgid "This function looks for directory-local variables, and immediately applies them in the current buffer.  It is intended to be called in the mode commands for non-file buffers, such as Dired buffers, to let them obey directory-local variable settings.  For non-file buffers, Emacs looks for directory-local variables in @code{default-directory} and its parent directories."
msgstr "この関数はディレクトリーローカル変数を探して、即座にそれらをカレントバッファーに適用する。これはDiredバッファーのような、非ファイルバッファーをディレクトリーローカル変数のセッティングにしたがわせるために、モードコマンド呼び出しの中から呼び出されることを意図したものである。非ファイルバッファーにたいしては、Emacsは@code{default-directory}とその親ディレクトリーの中から、ディレクトリーローカル変数を探す。"

#. type: defun
#: original_texis/variables.texi:2049
#, no-wrap
msgid "dir-locals-set-class-variables class variables"
msgstr "dir-locals-set-class-variables class variables"

#. type: defun
#: original_texis/variables.texi:2064
msgid "This function defines a set of variable settings for the named @var{class}, which is a symbol.  You can later assign the class to one or more directories, and Emacs will apply those variable settings to all files in those directories.  The list in @var{variables} can be of one of the two forms: @code{(@var{major-mode} . @var{alist})} or @code{(@var{directory} . @var{list})}.  With the first form, if the file's buffer turns on a mode that is derived from @var{major-mode}, then all the variables in the associated @var{alist} are applied; @var{alist} should be of the form @code{(@var{name} . @var{value})}.  A special value @code{nil} for @var{major-mode} means the settings are applicable to any mode.  In @var{alist}, you can use a special @var{name}: @code{subdirs}.  If the associated value is @code{nil}, the alist is only applied to files in the relevant directory, not to those in any subdirectories."
msgstr "この関数は@var{class}という名前がつけられたシンボルにたいして一連の変数セッティングを定義する。その後はこのクラスを1つ以上のディレクトリーに割り当てることができるので、Emacsはこれらの変数セッティングをディレクトリー内のすべてのファイルに適用する。@var{variables}内のリストは2つの形式 --- @code{(@var{major-mode} . @var{alist})}、または@code{(@var{directory} . @var{list})} --- のうちのいずれかをもつことができる。1番目の形式ではそのファイルのバッファーが@var{major-mode}を継承するモードに切り替わるときに、連想リスト@var{alist}内のすべての変数が適用される。@var{alist}は@code{(@var{name} . @var{value})}という形式。@var{major-mode}にたいする特別な値@code{nil}は、そのセッティングが任意のモードに適用できることを意味する。@var{alist}内では特別な@var{name}として@code{subdirs}を使用することができる。連想値が@code{nil}ならalistは関連するディレクトリー内のファイルだけに適用されて、それらのサブディレクトリーには適用されない。"

#. type: defun
#: original_texis/variables.texi:2069
msgid "With the second form of @var{variables}, if @var{directory} is the initial substring of the file's directory, then @var{list} is applied recursively by following the above rules; @var{list} should be of one of the two forms accepted by this function in @var{variables}."
msgstr "@var{variables}の2番目の形式では、@var{directory}がそのファイルのディレクトリーの最初のサブディレクトリーなら、上記のルールにしたがい@var{list}が再帰的に適用される。@var{list}はこの関数の@var{variables}で指定できる2つの形式のうち1つを指定する。"

#. type: defun
#: original_texis/variables.texi:2071
#, no-wrap
msgid "dir-locals-set-directory-class directory class &optional mtime"
msgstr "dir-locals-set-directory-class directory class &optional mtime"

#. type: defun
#: original_texis/variables.texi:2077
msgid "This function assigns @var{class} to all the files in @code{directory} and its subdirectories.  Thereafter, all the variable settings specified for @var{class} will be applied to any visited file in @var{directory} and its children.  @var{class} must have been already defined by @code{dir-locals-set-class-variables}."
msgstr "この関数は@code{directory}とサブディレクトリー内のすべてのファイルに@var{class}を割り当てる。その後、@var{class}にたいして指定されたすべての変数セッティングは、@var{directory}とその子ディレクトリー内でvisitされたすべてのファイルに適用される。@var{class}は事前に@code{dir-locals-set-class-variables}で定義されていなければならない。"

#. type: defun
#: original_texis/variables.texi:2084
msgid "Emacs uses this function internally when it loads directory variables from a @code{.dir-locals.el} file.  In that case, the optional argument @var{mtime} holds the file modification time (as returned by @code{file-attributes}).  Emacs uses this time to check stored local variables are still valid.  If you are assigning a class directly, not via a file, this argument should be @code{nil}."
msgstr "Emacsが@code{.dir-locals.el}ファイルからディレクトリー変数をロードする際、内部的にこの関数を使用する。その場合、オプションの引数@var{mtime}はファイルの修正日時(modification time。@code{file-attributes}によりリターンされる)を保持する。Emacsは記憶されたローカル変数がまだ有効化チェックするために、この日時を使用する。ファイルを介さず直接クラスを割り当てる場合、この引数は@code{nil}になる。"

#. type: defvar
#: original_texis/variables.texi:2086
#, no-wrap
msgid "dir-locals-class-alist"
msgstr "dir-locals-class-alist"

#. type: defvar
#: original_texis/variables.texi:2089
msgid "This alist holds the class symbols and the associated variable settings.  It is updated by @code{dir-locals-set-class-variables}."
msgstr "このalistはクラスシンボル(class symbol)とそれに関連づけられる変数のセッティングを保持する。これは@code{dir-locals-set-class-variables}により更新される。"

#. type: defvar
#: original_texis/variables.texi:2091
#, no-wrap
msgid "dir-locals-directory-cache"
msgstr "dir-locals-directory-cache"

#. type: defvar
#: original_texis/variables.texi:2096
msgid "This alist holds directory names, their assigned class names, and modification times of the associated directory local variables file (if there is one).  The function @code{dir-locals-set-directory-class} updates this list."
msgstr "このalistはディレクトリー名、それらに割り当てられたクラス名、およびこのエントリーに関連するディレクトリーローカル変数ファイルの修正日時を保持する。関数@code{dir-locals-set-directory-class}はこのlistを更新する。"

#. type: defvar
#: original_texis/variables.texi:2098
#, no-wrap
msgid "enable-dir-local-variables"
msgstr "enable-dir-local-variables"

#. type: defvar
#: original_texis/variables.texi:2102
msgid "If @code{nil}, directory-local variables are ignored.  This variable may be useful for modes that want to ignore directory-locals while still respecting file-local variables (@pxref{File Local Variables})."
msgstr "@code{nil}ならディレクトリーローカル変数は無視される。この変数はファイルローカル変数(@ref{File Local Variables}を参照)にはしたがうが、ディレクトリーローカル変数は無視したいモードにたいして有用かもしれない。"

#. type: cindex
#: original_texis/variables.texi:2106
#, no-wrap
msgid "connection local variables"
msgstr "connection local variables"

#. type: Plain text
#: original_texis/variables.texi:2111
msgid "Connection-local variables provide a general mechanism for different variable settings in buffers with a remote connection.  They are bound and set depending on the remote connection a buffer is dedicated to."
msgstr "接続ローカル変数(connection-local variable)はリモート接続をもつバッファにおいて、異なる変数セッティングにたいする汎用のメカニズムを提供します。これはそのリモート接続に専用のバッファーに応じてバインドおよびセットされる変数です。"

#. type: defun
#: original_texis/variables.texi:2112
#, no-wrap
msgid "connection-local-set-profile-variables profile variables"
msgstr "connection-local-set-profile-variables profile variables"

#. type: defun
#: original_texis/variables.texi:2119
msgid "This function defines a set of variable settings for the connection @var{profile}, which is a symbol.  You can later assign the connection profile to one or more remote connections, and Emacs will apply those variable settings to all process buffers for those connections.  The list in @var{variables} is an alist of the form @code{(@var{name}@tie{}.@tie{}@var{value})}.  Example:"
msgstr "この関数は接続@var{profile} (シンボル)にたいする一連の変数セッティングを定義する。この接続プロファイルに後から1つ以上のリモート接続を割り当てることができ、Emacsはそれらの接続にたいするすべてのプロセスバッファーにそれらの変数セッティングを適用するだろう。@var{variables}内のリストは@code{(@var{name}@tie{}.@tie{}@var{value})}という形式のalist。たとえば:"

#. type: group
#: original_texis/variables.texi:2128
#, no-wrap
msgid ""
"(connection-local-set-profile-variables\n"
"  'remote-bash\n"
"  '((shell-file-name . \"/bin/bash\")\n"
"    (shell-command-switch . \"-c\")\n"
"    (shell-interactive-switch . \"-i\")\n"
"    (shell-login-switch . \"-l\")))\n"
msgstr ""
"(connection-local-set-profile-variables\n"
"  'remote-bash\n"
"  '((shell-file-name . \"/bin/bash\")\n"
"    (shell-command-switch . \"-c\")\n"
"    (shell-interactive-switch . \"-i\")\n"
"    (shell-login-switch . \"-l\")))\n"

#. type: group
#: original_texis/variables.texi:2137
#, no-wrap
msgid ""
"(connection-local-set-profile-variables\n"
"  'remote-ksh\n"
"  '((shell-file-name . \"/bin/ksh\")\n"
"    (shell-command-switch . \"-c\")\n"
"    (shell-interactive-switch . \"-i\")\n"
"    (shell-login-switch . \"-l\")))\n"
msgstr ""
"(connection-local-set-profile-variables\n"
"  'remote-ksh\n"
"  '((shell-file-name . \"/bin/ksh\")\n"
"    (shell-command-switch . \"-c\")\n"
"    (shell-interactive-switch . \"-i\")\n"
"    (shell-login-switch . \"-l\")))\n"

#. type: group
#: original_texis/variables.texi:2143
#, no-wrap
msgid ""
"(connection-local-set-profile-variables\n"
"  'remote-null-device\n"
"  '((null-device . \"/dev/null\")))\n"
msgstr ""
"(connection-local-set-profile-variables\n"
"  'remote-null-device\n"
"  '((null-device . \"/dev/null\")))\n"

#. type: defvar
#: original_texis/variables.texi:2147
#, no-wrap
msgid "connection-local-profile-alist"
msgstr "connection-local-profile-alist"

#. type: defvar
#: original_texis/variables.texi:2151
msgid "This alist holds the connection profile symbols and the associated variable settings.  It is updated by @code{connection-local-set-profile-variables}."
msgstr "このalistは接続プロファイルシンボルと連想変数セッティングを保持する。これは@code{connection-local-set-profile-variables}により更新される。"

#. type: defun
#: original_texis/variables.texi:2153
#, no-wrap
msgid "connection-local-set-profiles criteria &rest profiles"
msgstr "connection-local-set-profiles criteria &rest profiles"

#. type: defun
#: original_texis/variables.texi:2162
msgid "This function assigns @var{profiles}, which are symbols, to all remote connections identified by @var{criteria}.  @var{criteria} is a plist identifying a connection and the application using this connection.  Property names might be @code{:application}, @code{:protocol}, @code{:user} and @code{:machine}.  The property value of @code{:application} is a symbol, all other property values are strings.  All properties are optional; if @var{criteria} is @code{nil}, it always applies.  Example:"
msgstr "この関数は@var{criteria}で識別されるすべてのリモート接続に@var{profiles} (シンボル)を割り当てる。@var{criteria}は接続を識別するplistであり、アプリケーションはその接続を使用する。プロパティ名は@code{:application}、@code{:protocol}、@code{:user}、@code{:machine}のいずれか。@code{:application}のプロパティ値はシンボル、それ以外のプロパティ値は文字列。プロパティはすべてオプション。@var{criteria}が@code{nil}なら常に適用される。たとえば:"

#. type: group
#: original_texis/variables.texi:2168
#, no-wrap
msgid ""
"(connection-local-set-profiles\n"
"  '(:application 'tramp :protocol \"ssh\" :machine \"localhost\")\n"
"  'remote-bash 'remote-null-device)\n"
msgstr ""
"(connection-local-set-profiles\n"
"  '(:application 'tramp :protocol \"ssh\" :machine \"localhost\")\n"
"  'remote-bash 'remote-null-device)\n"

#. type: group
#: original_texis/variables.texi:2175
#, no-wrap
msgid ""
"(connection-local-set-profiles\n"
"  '(:application 'tramp :protocol \"sudo\"\n"
"    :user \"root\" :machine \"localhost\")\n"
"  'remote-ksh 'remote-null-device)\n"
msgstr ""
"(connection-local-set-profiles\n"
"  '(:application 'tramp :protocol \"sudo\"\n"
"    :user \"root\" :machine \"localhost\")\n"
"  'remote-ksh 'remote-null-device)\n"

#. type: defun
#: original_texis/variables.texi:2180
msgid "If @var{criteria} is @code{nil}, it applies for all remote connections.  Therefore, the example above would be equivalent to"
msgstr "@var{criteria}が@code{nil}ならすべてのリモート接続に適用される。したがって上記の例は以下と等価"

#. type: group
#: original_texis/variables.texi:2186
#, no-wrap
msgid ""
"(connection-local-set-profiles\n"
"  '(:application 'tramp :protocol \"ssh\" :machine \"localhost\")\n"
"  'remote-bash)\n"
msgstr ""
"(connection-local-set-profiles\n"
"  '(:application 'tramp :protocol \"ssh\" :machine \"localhost\")\n"
"  'remote-bash)\n"

#. type: group
#: original_texis/variables.texi:2193
#, no-wrap
msgid ""
"(connection-local-set-profiles\n"
"  '(:application 'tramp :protocol \"sudo\"\n"
"    :user \"root\" :machine \"localhost\")\n"
"  'remote-ksh)\n"
msgstr ""
"(connection-local-set-profiles\n"
"  '(:application 'tramp :protocol \"sudo\"\n"
"    :user \"root\" :machine \"localhost\")\n"
"  'remote-ksh)\n"

#. type: group
#: original_texis/variables.texi:2198
#, no-wrap
msgid ""
"(connection-local-set-profiles\n"
"  nil 'remote-null-device)\n"
msgstr ""
"(connection-local-set-profiles\n"
"  nil 'remote-null-device)\n"

#. type: defun
#: original_texis/variables.texi:2203
msgid "Any connection profile of @var{profiles} must have been already defined by @code{connection-local-set-profile-variables}."
msgstr "@var{profiles}のすべてのプロファイルは@code{connection-local-set-profile-variables}で定義済みでなければならない。"

#. type: defvar
#: original_texis/variables.texi:2205
#, no-wrap
msgid "connection-local-criteria-alist"
msgstr "connection-local-criteria-alist"

#. type: defvar
#: original_texis/variables.texi:2209
msgid "This alist contains connection criteria and their assigned profile names.  The function @code{connection-local-set-profiles} updates this list."
msgstr "このalistは接続のcriteria(判断基準)それに割り当てられたとprofileの名前を含む。関数@code{connection-local-set-profiles}はこのリストを更新する。"

#. type: defun
#: original_texis/variables.texi:2211
#, no-wrap
msgid "hack-connection-local-variables criteria"
msgstr "hack-connection-local-variables criteria"

#. type: defun
#: original_texis/variables.texi:2216
msgid "This function collects applicable connection-local variables associated with @var{criteria} in @code{connection-local-variables-alist}, without applying them.  Example:"
msgstr "この関数は@code{connection-local-variables-alist}内の@var{criteria}に関連する適用可能な接続ローカル変数を適用することなく収集する。たとえば:"

#. type: group
#: original_texis/variables.texi:2221
#, no-wrap
msgid ""
"(hack-connection-local-variables\n"
"  '(:application 'tramp :protocol \"ssh\" :machine \"localhost\"))\n"
msgstr ""
"(hack-connection-local-variables\n"
"  '(:application 'tramp :protocol \"ssh\" :machine \"localhost\"))\n"

#. type: group
#: original_texis/variables.texi:2230
#, no-wrap
msgid ""
"connection-local-variables-alist\n"
"     @result{} ((null-device . \"/dev/null\")\n"
"        (shell-login-switch . \"-l\")\n"
"        (shell-interactive-switch . \"-i\")\n"
"        (shell-command-switch . \"-c\")\n"
"        (shell-file-name . \"/bin/bash\"))\n"
msgstr ""
"connection-local-variables-alist\n"
"     @result{} ((null-device . \"/dev/null\")\n"
"        (shell-login-switch . \"-l\")\n"
"        (shell-interactive-switch . \"-i\")\n"
"        (shell-command-switch . \"-c\")\n"
"        (shell-file-name . \"/bin/bash\"))\n"

#. type: defun
#: original_texis/variables.texi:2234
#, no-wrap
msgid "hack-connection-local-variables-apply criteria"
msgstr "hack-connection-local-variables-apply criteria"

#. type: defun
#: original_texis/variables.texi:2237
msgid "This function looks for connection-local variables according to @var{criteria}, and immediately applies them in the current buffer."
msgstr "この関数は@var{criteria}に対応する接続ローカル変数を探してカレントバッファーに即座に適用する。"

#. type: defmac
#: original_texis/variables.texi:2239
#, fuzzy, no-wrap
#| msgid "with-connection-local-profiles profiles &rest body"
msgid "with-connection-local-variables &rest body"
msgstr "with-connection-local-profiles profiles &rest body"

#. type: defmac
#: original_texis/variables.texi:2242
#, fuzzy
#| msgid "All connection-local variables, which are specified by a connection profile in @var{profiles}, are applied."
msgid "All connection-local variables, which are specified by @code{default-directory}, are applied."
msgstr "@var{profiles}内の接続プロファイルで指定されるすべての接続ローカル変数を適用する。"

#. type: defmac
#: original_texis/variables.texi:2245
msgid "After that, @var{body} is executed, and the connection-local variables are unwound.  Example:"
msgstr "その後に@var{body}を実行して接続ローカル変数を非バインド化する。たとえば:"

#. type: group
#: original_texis/variables.texi:2252
#, no-wrap
msgid ""
"(connection-local-set-profile-variables\n"
"  'remote-perl\n"
"  '((perl-command-name . \"/usr/local/bin/perl\")\n"
"    (perl-command-switch . \"-e %s\")))\n"
msgstr ""
"(connection-local-set-profile-variables\n"
"  'remote-perl\n"
"  '((perl-command-name . \"/usr/local/bin/perl\")\n"
"    (perl-command-switch . \"-e %s\")))\n"

#. type: group
#: original_texis/variables.texi:2258
#, fuzzy, no-wrap
#| msgid ""
#| "(connection-local-set-profiles\n"
#| "  '(:application 'tramp :protocol \"ssh\" :machine \"localhost\")\n"
#| "  'remote-bash)\n"
msgid ""
"(connection-local-set-profiles\n"
"  '(:application 'tramp :protocol \"ssh\" :machine \"remotehost\")\n"
"  'remote-perl)\n"
msgstr ""
"(connection-local-set-profiles\n"
"  '(:application 'tramp :protocol \"ssh\" :machine \"localhost\")\n"
"  'remote-bash)\n"

#. type: group
#: original_texis/variables.texi:2264
#, no-wrap
msgid ""
"(let ((default-directory \"/ssh:remotehost:/working/dir/\"))\n"
"  (with-connection-local-variables\n"
"    do something useful))\n"
msgstr ""

#. type: defvar
#: original_texis/variables.texi:2268
#, no-wrap
msgid "enable-connection-local-variables"
msgstr "enable-connection-local-variables"

#. type: defvar
#: original_texis/variables.texi:2271
msgid "If @code{nil}, connection-local variables are ignored.  This variable shall be changed temporarily only in special modes."
msgstr "@code{nil}なら接続ローカル変数を無視する。この変数は特殊なモード内でのみ一時的に変更されるべきである。"

#. type: cindex
#: original_texis/variables.texi:2275
#, no-wrap
msgid "variable aliases"
msgstr "variable aliases"

#. type: cindex
#: original_texis/variables.texi:2276
#, no-wrap
msgid "alias, for variables"
msgstr "alias, for variables"

#. type: Plain text
#: original_texis/variables.texi:2285
msgid "It is sometimes useful to make two variables synonyms, so that both variables always have the same value, and changing either one also changes the other.  Whenever you change the name of a variable---either because you realize its old name was not well chosen, or because its meaning has partly changed---it can be useful to keep the old name as an @emph{alias} of the new one for compatibility.  You can do this with @code{defvaralias}."
msgstr "シノニムとして2つの変数を作成できれば便利なときがあります。2つの変数は常に同じ値をもち、どちらか一方を変更すると、もう一方も変更されます。変数の名前を変更  --- 古い名前はよく考慮して選択されたものではなかったとか、変数の意味が部分的に変更された等の理由で --- するとき、互換性のために新しい名前の@emph{エイリアス(alias)}として古い名前を維持できれば便利なときがあるかもしれません。@code{defvaralias}によってこれを行うことができます。"

#. type: defun
#: original_texis/variables.texi:2286
#, no-wrap
msgid "defvaralias new-alias base-variable &optional docstring"
msgstr "defvaralias new-alias base-variable &optional docstring"

#. type: defun
#: original_texis/variables.texi:2293
msgid "This function defines the symbol @var{new-alias} as a variable alias for symbol @var{base-variable}. This means that retrieving the value of @var{new-alias} returns the value of @var{base-variable}, and changing the value of @var{new-alias} changes the value of @var{base-variable}.  The two aliased variable names always share the same value and the same bindings."
msgstr "この関数はシンボル@var{base-variable}のエイリアスとして、シンボル@var{new-alias}を定義する。これは@var{new-alias}から値を取得すると@var{base-variable}の値がリターンされ、@var{new-alias}の値を変更すると@var{base-variable}の値が変更されることを意味する。エイリアスされた2つの変数名は、常に同じ値と同じバインディングを共有する。"

#. type: defun
#: original_texis/variables.texi:2299
msgid "If the @var{docstring} argument is non-@code{nil}, it specifies the documentation for @var{new-alias}; otherwise, the alias gets the same documentation as @var{base-variable} has, if any, unless @var{base-variable} is itself an alias, in which case @var{new-alias} gets the documentation of the variable at the end of the chain of aliases."
msgstr "@var{docstring}引数が非@code{nil}なら、それは@var{new-alias}のドキュメント文字列を指定する。それ以外なら、エイリアスは(もしあれば)@var{base-variable}と同じドキュメント文字列となる。ただしそれは@var{base-variable}自体がエイリアスではない場合で、エイリアスなら@var{new-alias}はエイリアスチェーンの最後の変数のドキュメント文字列になる。"

#. type: defun
#: original_texis/variables.texi:2301
msgid "This function returns @var{base-variable}."
msgstr "この関数は@var{base-variable}をリターンする。"

#. type: Plain text
#: original_texis/variables.texi:2307
msgid "Variable aliases are convenient for replacing an old name for a variable with a new name.  @code{make-obsolete-variable} declares that the old name is obsolete and therefore that it may be removed at some stage in the future."
msgstr "変数のエイリアスは、変数にたいする古い名前を新しい名前に置き換える便利な方法です。@code{make-obsolete-variable}は古い名前を陳腐化(obsolete)していると宣言して。それが将来のある時点で削除されるかもしれないことを宣言します。"

#. type: defun
#: original_texis/variables.texi:2308
#, no-wrap
msgid "make-obsolete-variable obsolete-name current-name when &optional access-type"
msgstr "make-obsolete-variable obsolete-name current-name when &optional access-type"

#. type: defun
#: original_texis/variables.texi:2317
msgid "This function makes the byte compiler warn that the variable @var{obsolete-name} is obsolete.  If @var{current-name} is a symbol, it is the variable's new name; then the warning message says to use @var{current-name} instead of @var{obsolete-name}.  If @var{current-name} is a string, this is the message and there is no replacement variable.  @var{when} should be a string indicating when the variable was first made obsolete (usually a version number string)."
msgstr "この関数はバイトコンパイラーに変数@var{obsolete-name}が陳腐化していると警告させる。@var{current-name}がシンボルなら、それはこの変数の新たな名前である。警告メッセージはその後、@var{obsolete-name}のかわりに@var{current-name}を使用するよう告げるようになる。@var{current-name}が文字列なら、それはメッセージであり、置き換えられる変数はない。@var{when}はその変数が最初に陳腐化するのがいつかを示す文字列(通常はバージョン番号文字列)。"

#. type: defun
#: original_texis/variables.texi:2321
msgid "The optional argument @var{access-type}, if non-@code{nil}, should specify the kind of access that will trigger obsolescence warnings; it can be either @code{get} or @code{set}."
msgstr "オプションの引数@var{access-type}が非@code{nil}なら、それは陳腐化の警告を引き起こすアクセスの種類を指定すること。@code{get}か@code{set}を指定できる。"

#. type: Plain text
#: original_texis/variables.texi:2325
msgid "You can make two variables synonyms and declare one obsolete at the same time using the macro @code{define-obsolete-variable-alias}."
msgstr "2つの変数シノニムを作成してマクロ@code{define-obsolete-variable-alias}を使用することにより、1つが陳腐化していると同時に宣言できます。"

#. type: defmac
#: original_texis/variables.texi:2326
#, no-wrap
msgid "define-obsolete-variable-alias obsolete-name current-name &optional when docstring"
msgstr "define-obsolete-variable-alias obsolete-name current-name &optional when docstring"

#. type: defmac
#: original_texis/variables.texi:2330
msgid "This macro marks the variable @var{obsolete-name} as obsolete and also makes it an alias for the variable @var{current-name}.  It is equivalent to the following:"
msgstr "このマクロは変数@var{obsolete-name}が陳腐化しているとマークして、それを変数@var{current-name}にたいするエイリアスにする。これは以下と等価である:"

#. type: example
#: original_texis/variables.texi:2334
#, no-wrap
msgid ""
"(defvaralias @var{obsolete-name} @var{current-name} @var{docstring})\n"
"(make-obsolete-variable @var{obsolete-name} @var{current-name} @var{when})\n"
msgstr ""
"(defvaralias @var{obsolete-name} @var{current-name} @var{docstring})\n"
"(make-obsolete-variable @var{obsolete-name} @var{current-name} @var{when})\n"

#. type: defun
#: original_texis/variables.texi:2337
#, no-wrap
msgid "indirect-variable variable"
msgstr "indirect-variable variable"

#. type: defun
#: original_texis/variables.texi:2341
msgid "This function returns the variable at the end of the chain of aliases of @var{variable}.  If @var{variable} is not a symbol, or if @var{variable} is not defined as an alias, the function returns @var{variable}."
msgstr "この関数は@var{variable}のエイリアスチェーンの最後の変数をリターンする。@var{variable}がシンボルでない、または@var{variable}がエイリアスとして定義されていなければ、この関数は@var{variable}をリターンする。"

#. type: defun
#: original_texis/variables.texi:2344
msgid "This function signals a @code{cyclic-variable-indirection} error if there is a loop in the chain of symbols."
msgstr "この関数はシンボルのチェーンがループしていたら、@code{cyclic-variable-indirection}エラーをシグナルする。"

#. type: example
#: original_texis/variables.texi:2355
#, no-wrap
msgid ""
"(defvaralias 'foo 'bar)\n"
"(indirect-variable 'foo)\n"
"     @result{} bar\n"
"(indirect-variable 'bar)\n"
"     @result{} bar\n"
"(setq bar 2)\n"
"bar\n"
"     @result{} 2\n"
msgstr ""
"(defvaralias 'foo 'bar)\n"
"(indirect-variable 'foo)\n"
"     @result{} bar\n"
"(indirect-variable 'bar)\n"
"     @result{} bar\n"
"(setq bar 2)\n"
"bar\n"
"     @result{} 2\n"

#. type: group
#: original_texis/variables.texi:2358
#, no-wrap
msgid ""
"foo\n"
"     @result{} 2\n"
msgstr ""
"foo\n"
"     @result{} 2\n"

#. type: example
#: original_texis/variables.texi:2364
#, no-wrap
msgid ""
"(setq foo 0)\n"
"bar\n"
"     @result{} 0\n"
"foo\n"
"     @result{} 0\n"
msgstr ""
"(setq foo 0)\n"
"bar\n"
"     @result{} 0\n"
"foo\n"
"     @result{} 0\n"

#. type: cindex
#: original_texis/variables.texi:2368
#, no-wrap
msgid "lisp variables defined in C, restrictions"
msgstr "lisp variables defined in C, restrictions"

#. type: Plain text
#: original_texis/variables.texi:2379
msgid "Ordinary Lisp variables can be assigned any value that is a valid Lisp object.  However, certain Lisp variables are not defined in Lisp, but in C@.  Most of these variables are defined in the C code using @code{DEFVAR_LISP}.  Like variables defined in Lisp, these can take on any value.  However, some variables are defined using @code{DEFVAR_INT} or @code{DEFVAR_BOOL}.  @xref{Defining Lisp variables in C,, Writing Emacs Primitives}, in particular the description of functions of the type @code{syms_of_@var{filename}}, for a brief discussion of the C implementation."
msgstr "通常のLisp変数には、有効なLispオブジェクトである任意の値を割り当てることができます。しかしLispではなくCで定義されたLisp変数もあります。これらの変数のほとんどは、@code{DEFVAR_LISP}を使用してCコードで定義されています。Lispで定義された変数と同様、これらは任意の値をとることができます。しかしいくつかの変数は@code{DEFVAR_INT}や@code{DEFVAR_BOOL}を使用して定義されています。C実装の概要的な議論は、@ref{Defining Lisp variables in C,, Writing Emacs Primitives}、特に@code{syms_of_@var{filename}}型の関数の説明を参照してください。"

#. type: Plain text
#: original_texis/variables.texi:2383
msgid "Variables of type @code{DEFVAR_BOOL} can only take on the values @code{nil} or @code{t}.  Attempting to assign them any other value will set them to @code{t}:"
msgstr "@code{DEFVAR_BOOL}型の変数は、値に@code{nil}か@code{t}しかとることができません。他の値の割り当てを試みると@code{t}がセットされます:"

#. type: example
#: original_texis/variables.texi:2388
#, no-wrap
msgid ""
"(let ((display-hourglass 5))\n"
"  display-hourglass)\n"
"     @result{} t\n"
msgstr ""
"(let ((display-hourglass 5))\n"
"  display-hourglass)\n"
"     @result{} t\n"

#. type: defvar
#: original_texis/variables.texi:2390
#, no-wrap
msgid "byte-boolean-vars"
msgstr "byte-boolean-vars"

#. type: defvar
#: original_texis/variables.texi:2392
msgid "This variable holds a list of all variables of type @code{DEFVAR_BOOL}."
msgstr "この変数は@code{DEFVAR_BOOL}型のすべての変数のリストを保持する。"

#. type: Plain text
#: original_texis/variables.texi:2396
msgid "Variables of type @code{DEFVAR_INT} can take on only integer values.  Attempting to assign them any other value will result in an error:"
msgstr "@code{DEFVAR_INT}型の変数は、整数値だけをとることができます。他の値の割り当てを試みると結果はエラーになります:"

#. type: example
#: original_texis/variables.texi:2400
#, no-wrap
msgid ""
"(setq undo-limit 1000.0)\n"
"@error{} Wrong type argument: integerp, 1000.0\n"
msgstr ""
"(setq undo-limit 1000.0)\n"
"@error{} Wrong type argument: integerp, 1000.0\n"

#. type: cindex
#: original_texis/variables.texi:2405
#, no-wrap
msgid "generalized variable"
msgstr "generalized variable"

#. type: cindex
#: original_texis/variables.texi:2406
#, no-wrap
msgid "place form"
msgstr "place form"

#. type: Plain text
#: original_texis/variables.texi:2413
msgid "A @dfn{generalized variable} or @dfn{place form} is one of the many places in Lisp memory where values can be stored using the @code{setf} macro (@pxref{Setting Generalized Variables}).  The simplest place form is a regular Lisp variable.  But the @sc{car}s and @sc{cdr}s of lists, elements of arrays, properties of symbols, and many other locations are also places where Lisp values get stored."
msgstr "@dfn{ジェネリック変数(generalized variable： 汎変数)}または@dfn{place form}は@code{setf}マクロ(@ref{Setting Generalized Variables}を参照)を使用して値が格納される、Lispメモリー内の多くの場所のうちの1つです。1番シンプルなplace formは通常のLisp変数です。しかしリストの@sc{car}と@sc{cdr}、配列の要素、シンボルのプロパティー、その他多くのロケーション(location)もLisp値が格納される場所です。"

#. type: Plain text
#: original_texis/variables.texi:2419
msgid "Generalized variables are analogous to lvalues in the C language, where @samp{x = a[i]} gets an element from an array and @samp{a[i] = x} stores an element using the same notation.  Just as certain forms like @code{a[i]} can be lvalues in C, there is a set of forms that can be generalized variables in Lisp."
msgstr "ジェネリック変数は、C言語のlvalues(左辺値)と類似しています。C言語のlvalueでは@samp{x = a[i]}で配列から要素を取得し、同じ表記を使用して@samp{a[i] = x}で要素を格納します。Cでは@code{a[i]}のような特定のフォームがlvalueになれるように、Lispでジェネリック変数になることができる一連のフォームが存在します。"

#. type: node
#: original_texis/variables.texi:2423 original_texis/variables.texi:2425
#, no-wrap
msgid "Setting Generalized Variables"
msgstr "Setting Generalized Variables"

#. type: menuentry
#: original_texis/variables.texi:2423
msgid "The @code{setf} macro."
msgstr "@code{setf}マクロ。"

#. type: node
#: original_texis/variables.texi:2423 original_texis/variables.texi:2517
#, no-wrap
msgid "Adding Generalized Variables"
msgstr "Adding Generalized Variables"

#. type: menuentry
#: original_texis/variables.texi:2423
msgid "Defining new @code{setf} forms."
msgstr "新たな@code{setf}フォームの定義。"

#. type: subsection
#: original_texis/variables.texi:2426
#, no-wrap
msgid "The @code{setf} Macro"
msgstr "The @code{setf} Macro"

#. type: Plain text
#: original_texis/variables.texi:2435
msgid "The @code{setf} macro is the most basic way to operate on generalized variables.  The @code{setf} form is like @code{setq}, except that it accepts arbitrary place forms on the left side rather than just symbols.  For example, @code{(setf (car a) b)} sets the car of @code{a} to @code{b}, doing the same operation as @code{(setcar a b)}, but without you having to use two separate functions for setting and accessing this type of place."
msgstr "@code{setf}マクロはジェネリック変数を操作するもっとも基本的な方法です。@code{setf}フォームは@code{setq}と似ていますが、シンボルだけでなく左辺の任意のplace formを受け入れます。たとえば@code{(setf (car a) b)}は@code{a}のcarを@code{b}にセットして@code{(setcar a b)}と同じ操作を行いますが、このタイプのplaceにセットやアクセスするために2つの関数を個別に覚える必要はありません。"

#. type: defmac
#: original_texis/variables.texi:2436
#, no-wrap
msgid "setf [place form]@dots{}"
msgstr "setf [place form]@dots{}"

#. type: defmac
#: original_texis/variables.texi:2442
msgid "This macro evaluates @var{form} and stores it in @var{place}, which must be a valid generalized variable form.  If there are several @var{place} and @var{form} pairs, the assignments are done sequentially just as with @code{setq}.  @code{setf} returns the value of the last @var{form}."
msgstr "このマクロは@var{form}を評価して、それを@var{place}に格納する。@var{place}は有効なジェネリック変数フォームでなければならない。複数の@var{place}/@var{form}ペアーがある場合、割り当ては@code{setq}の場合と同様。@code{setf}は最後の@var{form}の値をリターンする。"

#. type: Plain text
#: original_texis/variables.texi:2447
msgid "The following Lisp forms are the forms in Emacs that will work as generalized variables, and so may appear in the @var{place} argument of @code{setf}:"
msgstr "以下のLispフォームはEmacsではジェネリック変数として機能するフォームなので、@code{setf}の@var{place}引数にすることができます:"

#. type: itemize
#: original_texis/variables.texi:2457
msgid "A symbol.  In other words, @code{(setf x y)} is exactly equivalent to @code{(setq x y)}, and @code{setq} itself is strictly speaking redundant given that @code{setf} exists.  Most programmers will continue to prefer @code{setq} for setting simple variables, though, for stylistic and historical reasons.  The macro @code{(setf x y)} actually expands to @code{(setq x y)}, so there is no performance penalty for using it in compiled code."
msgstr "シンボル。言い換えると、@code{(setf x y)}は完全に@code{(setq x y)}と正に等しく、厳密に言うと@code{setq}自体は@code{setf}が存在するので冗長です。これは純粋にスタイルと歴史的な理由によりますが、ほとんどのプログラマーは依然として単純な変数へのセットには@code{setq}の方を好みます。マクロ@code{(setf x y)}は実際には@code{(setq x y)}に展開されるので、コンパイルされたコードでこれを使用することにパフォーマンス的な不利はありません。"

#. type: itemize
#: original_texis/variables.texi:2460
msgid "A call to any of the following standard Lisp functions:"
msgstr "以下の標準的なLisp関数の呼び出し:"

#. type: smallexample
#: original_texis/variables.texi:2468
#, no-wrap
msgid ""
"aref      cddr      symbol-function\n"
"car       elt       symbol-plist\n"
"caar      get       symbol-value\n"
"cadr      gethash\n"
"cdr       nth\n"
"cdar      nthcdr\n"
msgstr ""
"aref      cddr      symbol-function\n"
"car       elt       symbol-plist\n"
"caar      get       symbol-value\n"
"cadr      gethash\n"
"cdr       nth\n"
"cdar      nthcdr\n"

#. type: itemize
#: original_texis/variables.texi:2472
msgid "A call to any of the following Emacs-specific functions:"
msgstr "以下のEmacs特有な関数の呼び出し:"

#. type: smallexample
#: original_texis/variables.texi:2484
#, no-wrap
msgid ""
"alist-get                     process-get\n"
"frame-parameter               process-sentinel\n"
"terminal-parameter            window-buffer\n"
"keymap-parent                 window-display-table\n"
"match-data                    window-dedicated-p\n"
"overlay-get                   window-hscroll\n"
"overlay-start                 window-parameter\n"
"overlay-end                   window-point\n"
"process-buffer                window-start\n"
"process-filter                default-value\n"
msgstr ""
"alist-get                     process-get\n"
"frame-parameter               process-sentinel\n"
"terminal-parameter            window-buffer\n"
"keymap-parent                 window-display-table\n"
"match-data                    window-dedicated-p\n"
"overlay-get                   window-hscroll\n"
"overlay-start                 window-parameter\n"
"overlay-end                   window-point\n"
"process-buffer                window-start\n"
"process-filter                default-value\n"

#. type: Plain text
#: original_texis/variables.texi:2490
msgid "@code{setf} signals an error if you pass a @var{place} form that it does not know how to handle."
msgstr "どのように処理すれば良いか未知な@var{place}フォームを渡すと、@code{setf}はエラーをシグナルします。"

#. type: Plain text
#: original_texis/variables.texi:2497
msgid "Note that for @code{nthcdr}, the list argument of the function must itself be a valid @var{place} form.  For example, @code{(setf (nthcdr 0 foo) 7)} will set @code{foo} itself to 7."
msgstr "@code{nthcdr}の場合、関数のリスト引数はそれ自体が有効な@var{place}フォームでなければならないことに注意してください。たとえば@code{(setf (nthcdr 0 foo) 7)}は、@code{foo}自体に7をセットするでしょう。"

#. type: Plain text
#: original_texis/variables.texi:2511
msgid "The macros @code{push} (@pxref{List Variables}) and @code{pop} (@pxref{List Elements}) can manipulate generalized variables, not just lists.  @code{(pop @var{place})} removes and returns the first element of the list stored in @var{place}.  It is analogous to @code{(prog1 (car @var{place}) (setf @var{place} (cdr @var{place})))}, except that it takes care to evaluate all subforms only once.  @code{(push @var{x} @var{place})} inserts @var{x} at the front of the list stored in @var{place}.  It is analogous to @code{(setf @var{place} (cons @var{x} @var{place}))}, except for evaluation of the subforms.  Note that @code{push} and @code{pop} on an @code{nthcdr} place can be used to insert or delete at any position in a list."
msgstr "マクロ@code{push}(@ref{List Variables}を参照)と@code{pop}(@ref{List Elements}を参照)は、リストだけでなくジェネリック変数を操作できます。@code{(pop @var{place})}は@var{place}内に格納されたリストの最初の要素を削除してリターンします。これは@code{(prog1 (car @var{place}) (setf @var{place} (cdr @var{place})))}と似ていますが、すべてのサブフォームを一度だけ評価します。@code{(push @var{x} @var{place})}は@var{place}内に格納されたリストの1番前に@var{x}を挿入します。これは@code{(setf @var{place} (cons @var{x} @var{place}))}と似ていますが、サブフォームの評価が異なります。@code{nthcdr} placeへの@code{push}と@code{pop}は、リスト内の任意の位置での挿入ち削除に使用できることに注意してください。"

#. type: Plain text
#: original_texis/variables.texi:2515
msgid "The @file{cl-lib} library defines various extensions for generalized variables, including additional @code{setf} places.  @xref{Generalized Variables,,, cl, Common Lisp Extensions}."
msgstr "@file{cl-lib}ライブラリーでは追加の@code{setf} placeを含む、ジェネリック変数にたいするさまざまな拡張が定義されています。@ref{Generalized Variables,,, cl, Common Lisp Extensions}を参照してください。"

#. type: subsection
#: original_texis/variables.texi:2518
#, no-wrap
msgid "Defining new @code{setf} forms"
msgstr "Defining new @code{setf} forms"

#. type: Plain text
#: original_texis/variables.texi:2522
msgid "This section describes how to define new forms that @code{setf} can operate on."
msgstr "このセクションでは、@code{setf}が操作できる新たなフォームの定義方法を説明します。"

#. type: defmac
#: original_texis/variables.texi:2523
#, no-wrap
msgid "gv-define-simple-setter name setter &optional fix-return"
msgstr "gv-define-simple-setter name setter &optional fix-return"

#. type: defmac
#: original_texis/variables.texi:2529
msgid "This macro enables you to easily define @code{setf} methods for simple cases.  @var{name} is the name of a function, macro, or special form.  You can use this macro whenever @var{name} has a directly corresponding @var{setter} function that updates it, e.g., @code{(gv-define-simple-setter car setcar)}."
msgstr "このマクロは単純なケースで@code{setf}メソッドを簡単に定義することを可能にする。@var{name}は関数、マクロ、スペシャルフォームの名前。@var{name}がそれを更新するための対応する@var{setter}関数をもつなら、このマクロを使用できる(たとえば@code{(gv-define-simple-setter car setcar)})。"

#. type: defmac
#: original_texis/variables.texi:2531
msgid "This macro translates a call of the form"
msgstr "このマクロは以下のフォームの呼び出しを"

#. type: example
#: original_texis/variables.texi:2534
#, no-wrap
msgid "(setf (@var{name} @var{args}@dots{}) @var{value})\n"
msgstr "(setf (@var{name} @var{args}@dots{}) @var{value})\n"

#. type: defmac
#: original_texis/variables.texi:2537
msgid "into"
msgstr "以下のように変換する。"

#. type: example
#: original_texis/variables.texi:2539
#, no-wrap
msgid "(@var{setter} @var{args}@dots{} @var{value})\n"
msgstr "(@var{setter} @var{args}@dots{} @var{value})\n"

#. type: defmac
#: original_texis/variables.texi:2548
msgid "Such a @code{setf} call is documented to return @var{value}.  This is no problem with, e.g., @code{car} and @code{setcar}, because @code{setcar} returns the value that it set.  If your @var{setter} function does not return @var{value}, use a non-@code{nil} value for the @var{fix-return} argument of @code{gv-define-simple-setter}.  This expands into something equivalent to"
msgstr "このような@code{setf}の呼び出しは@var{value}をリターンするとドキュメントされている。これは@code{car}と@code{setcar}では問題はない。@code{setcar}はそれがセットする値をリターンするからである。@var{setter}関数が@var{value}をリターンしない場合には、@code{gv-define-simple-setter}の@var{fix-return}引数に、非@code{nil}値を使用すること。これは以下のようなものに展開される"

#. type: example
#: original_texis/variables.texi:2552
#, no-wrap
msgid ""
"(let ((temp @var{value}))\n"
"  (@var{setter} @var{args}@dots{} temp)\n"
"  temp)\n"
msgstr ""
"(let ((temp @var{value}))\n"
"  (@var{setter} @var{args}@dots{} temp)\n"
"  temp)\n"

#. type: defmac
#: original_texis/variables.texi:2554
msgid "so ensuring that it returns the correct result."
msgstr "これで正しい結果がリターンされることが保証される。"

#. type: defmac
#: original_texis/variables.texi:2557
#, no-wrap
msgid "gv-define-setter name arglist &rest body"
msgstr "gv-define-setter name arglist &rest body"

#. type: defmac
#: original_texis/variables.texi:2562
msgid "This macro allows for more complex @code{setf} expansions than the previous form.  You may need to use this form, for example, if there is no simple setter function to call, or if there is one but it requires different arguments to the place form."
msgstr "このマクロは上述のフォームより複雑な@code{setf}展開を可能にする。たとえば呼び出すべきシンプルなsetter関数が存在しないときや、もしそれが存在してもplaceフォームとは異なる引数を要求するなら、このフォームを使う必要があるかもしれない。"

#. type: defmac
#: original_texis/variables.texi:2570
msgid "This macro expands the form @code{(setf (@var{name} @var{args}@dots{}) @var{value})} by first binding the @code{setf} argument forms @code{(@var{value} @var{args}@dots{})} according to @var{arglist}, and then executing @var{body}.  @var{body} should return a Lisp form that does the assignment, and finally returns the value that was set.  An example of using this macro is:"
msgstr "このマクロは最初に@code{setf}引数フォーム@code{(@var{value} @var{args}@dots{})}を@var{arglist}にバインドして、その後@var{body}を実行することによって、フォーム@code{(setf (@var{name} @var{args}@dots{}) @var{value})}を展開する。@var{body}は割り当てを行うLispフォームをリターンして、最終的にはセットされた値をリターンすること。以下はこのマクロの使用例である:"

#. type: example
#: original_texis/variables.texi:2573
#, no-wrap
msgid "(gv-define-setter caar (val x) `(setcar (car ,x) ,val))\n"
msgstr "(gv-define-setter caar (val x) `(setcar (car ,x) ,val))\n"

#. type: defmac
#: original_texis/variables.texi:2576
#, fuzzy, no-wrap
#| msgid "gv-define-expander"
msgid "gv-define-expander name handler"
msgstr "gv-define-expander"

#. type: defmac
#: original_texis/variables.texi:2580
msgid "For more control over the expansion, the @code{gv-define-expander} macro can be used.  For instance, a settable @code{substring} could be implemented this way:"
msgstr ""

#. type: example
#: original_texis/variables.texi:2590
#, no-wrap
msgid ""
"(gv-define-expander substring\n"
"  (lambda (do place from &optional to)\n"
"    (gv-letplace (getter setter) place\n"
"      (macroexp-let2* nil ((start from) (end to))\n"
"        (funcall do `(substring ,getter ,start ,end)\n"
"                 (lambda (v)\n"
"                   (funcall setter `(cl--set-substring\n"
"                                     ,getter ,start ,end ,v))))))))\n"
msgstr ""

#. type: defmac
#: original_texis/variables.texi:2593
#, no-wrap
msgid "gv-letplace (getter setter) place &rest body"
msgstr ""

#. type: defmac
#: original_texis/variables.texi:2597
#, fuzzy
#| msgid "For more control over the expansion, see the macro @code{gv-define-expander}.  The macro @code{gv-letplace} can be useful in defining macros that perform similarly to @code{setf}; for example, the @code{incf} macro of Common Lisp.  Consult the source file @file{gv.el} for more details."
msgid "The macro @code{gv-letplace} can be useful in defining macros that perform similarly to @code{setf}; for example, the @code{incf} macro of Common Lisp could be implemented this way:"
msgstr "展開をさらに制御するならマクロ@code{gv-define-expander}を参照してください。マクロ@code{gv-letplace}は@code{setf}のような処理を行うマクロを定義するのに有用です。詳細は@file{gv.el}のソースファイルを参照してください。"

#. type: example
#: original_texis/variables.texi:2603
#, no-wrap
msgid ""
"(defmacro incf (place &optional n)\n"
"  (gv-letplace (getter setter) place\n"
"    (macroexp-let2 nil v (or n 1)\n"
"      (funcall setter `(+ ,v ,getter)))))\n"
msgstr ""

#. type: defmac
#: original_texis/variables.texi:2610
msgid "@var{getter} will be bound to a copyable expression that returns the value of @var{place}.  @var{setter} will be bound to a function that takes an expression @var{v} and returns a new expression that sets @var{place} to @var{v}.  @var{body} should return a Emacs Lisp expression manipulating @var{place} via @var{getter} and @var{setter}."
msgstr ""

#. type: Plain text
#: original_texis/variables.texi:2613
msgid "Consult the source file @file{gv.el} for more details."
msgstr ""

#. type: cindex
#: original_texis/variables.texi:2614
#, no-wrap
msgid "CL note---no @code{setf} functions"
msgstr "CL note---no @code{setf} functions"

#. type: quotation
#: original_texis/variables.texi:2625
msgid "@b{Common Lisp note:} Common Lisp defines another way to specify the @code{setf} behavior of a function, namely @code{setf} functions, whose names are lists @code{(setf @var{name})} rather than symbols.  For example, @code{(defun (setf foo) @dots{})} defines the function that is used when @code{setf} is applied to @code{foo}.  Emacs does not support this.  It is a compile-time error to use @code{setf} on a form that has not already had an appropriate expansion defined.  In Common Lisp, this is not an error since the function @code{(setf @var{func})} might be defined later."
msgstr "@b{Common Lispに関する注意:} Common Lispは関数としての@code{setf}、すなわち関数名がシンボルではなくリスト@code{(setf @var{name})}であるような@code{setf}関数の挙動を指定するために別の方法を定義する。たとえば@code{(defun (setf foo) @dots{})}は、@code{setf}が@code{foo}に適用されるときに使用される関数を定義する。Emacsはこれをサポートしない。適切な展開が定義されていないフォームに@code{setf}を使用するとコンパイル時エラーとなる。Common Lispでは後で関数@code{(setf @var{func})}が定義されるのでエラーにならない。"
