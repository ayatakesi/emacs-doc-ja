# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2024-04-18 06:15+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: node
#: original_texis/sequences.texi:6
#, no-wrap
msgid "Sequences Arrays Vectors"
msgstr ""

#. type: chapter
#: original_texis/sequences.texi:7
#, no-wrap
msgid "Sequences, Arrays, and Vectors"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:8
#, no-wrap
msgid "sequence"
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:14
msgid ""
"The @dfn{sequence} type is the union of two other Lisp types: lists and "
"arrays.  In other words, any list is a sequence, and any array is a "
"sequence.  The common property that all sequences have is that each is an "
"ordered collection of elements."
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:18
msgid ""
"An @dfn{array} is a fixed-length object with a slot for each of its "
"elements.  All the elements are accessible in constant time.  The four types "
"of arrays are strings, vectors, char-tables and bool-vectors."
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:24
msgid ""
"A list is a sequence of elements, but it is not a single primitive object; "
"it is made of cons cells, one cell per element.  Finding the @var{n}th "
"element requires looking through @var{n} cons cells, so elements farther "
"from the beginning of the list take longer to access.  But it is possible to "
"add elements to the list, or remove elements."
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:26
msgid "The following diagram shows the relationship between these types:"
msgstr ""

#. type: group
#: original_texis/sequences.texi:45
#, no-wrap
msgid ""
"          _____________________________________________\n"
"         |                                             |\n"
"         |          Sequence                           |\n"
"         |  ______   ________________________________  |\n"
"         | |      | |                                | |\n"
"         | | List | |             Array              | |\n"
"         | |      | |    ________       ________     | |\n"
"         | |______| |   |        |     |        |    | |\n"
"         |          |   | Vector |     | String |    | |\n"
"         |          |   |________|     |________|    | |\n"
"         |          |  ____________   _____________  | |\n"
"         |          | |            | |             | | |\n"
"         |          | | Char-table | | Bool-vector | | |\n"
"         |          | |____________| |_____________| | |\n"
"         |          |________________________________| |\n"
"         |_____________________________________________|\n"
msgstr ""

#. type: node
#: original_texis/sequences.texi:57 original_texis/sequences.texi:59
#, no-wrap
msgid "Sequence Functions"
msgstr ""

#. type: menuentry
#: original_texis/sequences.texi:57
msgid "Functions that accept any kind of sequence."
msgstr ""

#. type: section
#: original_texis/sequences.texi:57 original_texis/sequences.texi:1233
#: original_texis/sequences.texi:1234
#, no-wrap
msgid "Arrays"
msgstr ""

#. type: menuentry
#: original_texis/sequences.texi:57
msgid "Characteristics of arrays in Emacs Lisp."
msgstr ""

#. type: node
#: original_texis/sequences.texi:57 original_texis/sequences.texi:1301
#, no-wrap
msgid "Array Functions"
msgstr ""

#. type: menuentry
#: original_texis/sequences.texi:57
msgid "Functions specifically for arrays."
msgstr ""

#. type: section
#: original_texis/sequences.texi:57 original_texis/sequences.texi:1404
#: original_texis/sequences.texi:1405
#, no-wrap
msgid "Vectors"
msgstr ""

#. type: menuentry
#: original_texis/sequences.texi:57
msgid "Special characteristics of Emacs Lisp vectors."
msgstr ""

#. type: node
#: original_texis/sequences.texi:57 original_texis/sequences.texi:1444
#, no-wrap
msgid "Vector Functions"
msgstr ""

#. type: menuentry
#: original_texis/sequences.texi:57
msgid "Functions specifically for vectors."
msgstr ""

#. type: section
#: original_texis/sequences.texi:57 original_texis/sequences.texi:1534
#: original_texis/sequences.texi:1535
#, no-wrap
msgid "Char-Tables"
msgstr ""

#. type: menuentry
#: original_texis/sequences.texi:57
msgid "How to work with char-tables."
msgstr ""

#. type: node
#: original_texis/sequences.texi:57 original_texis/sequences.texi:1710
#, no-wrap
msgid "Bool-Vectors"
msgstr ""

#. type: menuentry
#: original_texis/sequences.texi:57
msgid "How to work with bool-vectors."
msgstr ""

#. type: node
#: original_texis/sequences.texi:57 original_texis/sequences.texi:1827
#, no-wrap
msgid "Rings"
msgstr ""

#. type: menuentry
#: original_texis/sequences.texi:57
msgid "Managing a fixed-size ring of objects."
msgstr ""

#. type: section
#: original_texis/sequences.texi:60
#, no-wrap
msgid "Sequences"
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:63
msgid "This section describes functions that accept any kind of sequence."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:64
#, no-wrap
msgid "sequencep object"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:68
msgid ""
"This function returns @code{t} if @var{object} is a list, vector, string, "
"bool-vector, or char-table, @code{nil} otherwise.  See also @code{seqp} "
"below."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:70
#, no-wrap
msgid "length sequence"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:71
#, no-wrap
msgid "string length"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:72
#, no-wrap
msgid "list length"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:73
#, no-wrap
msgid "vector length"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:74
#, no-wrap
msgid "sequence length"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:75
#, no-wrap
msgid "bool-vector length"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:76
#, no-wrap
msgid "char-table length"
msgstr ""

#. type: anchor{#1}
#: original_texis/sequences.texi:84
msgid "Definition of length"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:84
msgid ""
"This function returns the number of elements in @var{sequence}.  The "
"function signals the @code{wrong-type-argument} error if the argument is not "
"a sequence or is a dotted list; it signals the @code{circular-list} error if "
"the argument is a circular list.  For a char-table, the value returned is "
"always one more than the maximum Emacs character code."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:86
msgid ""
"@xref{Definition of safe-length}, for the related function "
"@code{safe-length}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:91
#, no-wrap
msgid ""
"(length '(1 2 3))\n"
"    @result{} 3\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:95
#, no-wrap
msgid ""
"(length ())\n"
"    @result{} 0\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:99
#, no-wrap
msgid ""
"(length \"foobar\")\n"
"    @result{} 6\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:103
#, no-wrap
msgid ""
"(length [1 2 3])\n"
"    @result{} 3\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:107
#, no-wrap
msgid ""
"(length (make-bool-vector 5 nil))\n"
"    @result{} 5\n"
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:113
msgid "See also @code{string-bytes}, in @ref{Text Representations}."
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:118
msgid ""
"If you need to compute the width of a string on display, you should use "
"@code{string-width} (@pxref{Size of Displayed Text}), not @code{length}, "
"since @code{length} only counts the number of characters, but does not "
"account for the display width of each character."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:119
#, no-wrap
msgid "length< sequence length"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:123
msgid ""
"Return non-@code{nil} if @var{sequence} is shorter than @var{length}.  This "
"may be more efficient than computing the length of @var{sequence} if "
"@var{sequence} is a long list."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:125
#, no-wrap
msgid "length> sequence length"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:127
msgid "Return non-@code{nil} if @var{sequence} is longer than @var{length}."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:129
#, no-wrap
msgid "length= sequence length"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:132
msgid ""
"Return non-@code{nil} if the length of @var{sequence} is equal to "
"@var{length}."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:134
#, no-wrap
msgid "elt sequence index"
msgstr ""

#. type: anchor{#1}
#: original_texis/sequences.texi:136
msgid "Definition of elt"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:136
#, no-wrap
msgid "elements of sequences"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:143
msgid ""
"This function returns the element of @var{sequence} indexed by @var{index}.  "
"Legitimate values of @var{index} are integers ranging from 0 up to one less "
"than the length of @var{sequence}.  If @var{sequence} is a list, "
"out-of-range values behave as for @code{nth}.  @xref{Definition of nth}.  "
"Otherwise, out-of-range values trigger an @code{args-out-of-range} error."
msgstr ""

#. type: group
#: original_texis/sequences.texi:148
#, no-wrap
msgid ""
"(elt [1 2 3 4] 2)\n"
"     @result{} 3\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:152
#, no-wrap
msgid ""
"(elt '(1 2 3 4) 2)\n"
"     @result{} 3\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:157
#, no-wrap
msgid ""
";; @r{We use @code{string} to show clearly which character @code{elt} "
"returns.}\n"
"(string (elt \"1234\" 2))\n"
"     @result{} \"3\"\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:161
#, no-wrap
msgid ""
"(elt [1 2 3 4] 4)\n"
"     @error{} Args out of range: [1 2 3 4], 4\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:165
#, no-wrap
msgid ""
"(elt [1 2 3 4] -1)\n"
"     @error{} Args out of range: [1 2 3 4], -1\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:170
msgid ""
"This function generalizes @code{aref} (@pxref{Array Functions}) and "
"@code{nth} (@pxref{Definition of nth})."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:172
#, no-wrap
msgid "copy-sequence seqr"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:173
#, no-wrap
msgid "copying sequences"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:180
msgid ""
"This function returns a copy of @var{seqr}, which should be either a "
"sequence or a record.  The copy is the same type of object as the original, "
"and it has the same elements in the same order.  However, if @var{seqr} is "
"empty, like a string or a vector of zero length, the value returned by this "
"function might not be a copy, but an empty object of the same type and "
"identical to @var{seqr}."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:186
msgid ""
"Storing a new element into the copy does not affect the original @var{seqr}, "
"and vice versa.  However, the elements of the copy are not copies; they are "
"identical (@code{eq}) to the elements of the original.  Therefore, changes "
"made within these elements, as found via the copy, are also visible in the "
"original."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:191
msgid ""
"If the argument is a string with text properties, the property list in the "
"copy is itself a copy, not shared with the original's property list.  "
"However, the actual values of the properties are shared.  @xref{Text "
"Properties}."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:194
msgid ""
"This function does not work for dotted lists.  Trying to copy a circular "
"list may cause an infinite loop."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:198
msgid ""
"See also @code{append} in @ref{Building Lists}, @code{concat} in "
"@ref{Creating Strings}, and @code{vconcat} in @ref{Vector Functions}, for "
"other ways to copy sequences."
msgstr ""

#. type: group
#: original_texis/sequences.texi:203
#, no-wrap
msgid ""
"(setq bar (list 1 2))\n"
"     @result{} (1 2)\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:207
#, no-wrap
msgid ""
"(setq x (vector 'foo bar))\n"
"     @result{} [foo (1 2)]\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:211
#, no-wrap
msgid ""
"(setq y (copy-sequence x))\n"
"     @result{} [foo (1 2)]\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:216
#, no-wrap
msgid ""
"(eq x y)\n"
"     @result{} nil\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:220
#, no-wrap
msgid ""
"(equal x y)\n"
"     @result{} t\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:224
#, no-wrap
msgid ""
"(eq (elt x 1) (elt y 1))\n"
"     @result{} t\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:231
#, no-wrap
msgid ""
";; @r{Replacing an element of one sequence.}\n"
"(aset x 0 'quux)\n"
"x @result{} [quux (1 2)]\n"
"y @result{} [foo (1 2)]\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:238
#, no-wrap
msgid ""
";; @r{Modifying the inside of a shared element.}\n"
"(setcar (aref x 1) 69)\n"
"x @result{} [quux (69 2)]\n"
"y @result{} [foo (69 2)]\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:242
#, no-wrap
msgid "reverse sequence"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:243
#, no-wrap
msgid "string reverse"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:244
#, no-wrap
msgid "list reverse"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:245
#, no-wrap
msgid "vector reverse"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:246
#, no-wrap
msgid "sequence reverse"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:250
msgid ""
"This function creates a new sequence whose elements are the elements of "
"@var{sequence}, but in reverse order.  The original argument @var{sequence} "
"is @emph{not} altered.  Note that char-tables cannot be reversed."
msgstr ""

#. type: group
#: original_texis/sequences.texi:255
#, no-wrap
msgid ""
"(setq x '(1 2 3 4))\n"
"     @result{} (1 2 3 4)\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:261
#, no-wrap
msgid ""
"(reverse x)\n"
"     @result{} (4 3 2 1)\n"
"x\n"
"     @result{} (1 2 3 4)\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:265
#, no-wrap
msgid ""
"(setq x [1 2 3 4])\n"
"     @result{} [1 2 3 4]\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:271
#, no-wrap
msgid ""
"(reverse x)\n"
"     @result{} [4 3 2 1]\n"
"x\n"
"     @result{} [1 2 3 4]\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:275
#, no-wrap
msgid ""
"(setq x \"xyzzy\")\n"
"     @result{} \"xyzzy\"\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:281
#, no-wrap
msgid ""
"(reverse x)\n"
"     @result{} \"yzzyx\"\n"
"x\n"
"     @result{} \"xyzzy\"\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:285
#, no-wrap
msgid "nreverse sequence"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:286
#, no-wrap
msgid "reversing a string"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:287
#, no-wrap
msgid "reversing a list"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:288
#, no-wrap
msgid "reversing a vector"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:291
msgid ""
"This function reverses the order of the elements of @var{sequence}.  Unlike "
"@code{reverse} the original @var{sequence} may be modified."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:293
msgid "For example:"
msgstr ""

#. type: group
#: original_texis/sequences.texi:298
#, no-wrap
msgid ""
"(setq x (list 'a 'b 'c))\n"
"     @result{} (a b c)\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:304
#, no-wrap
msgid ""
"x\n"
"     @result{} (a b c)\n"
"(nreverse x)\n"
"     @result{} (c b a)\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:309
#, no-wrap
msgid ""
";; @r{The cons cell that was first is now last.}\n"
"x\n"
"     @result{} (a)\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:314
msgid ""
"To avoid confusion, we usually store the result of @code{nreverse} back in "
"the same variable which held the original list:"
msgstr ""

#. type: example
#: original_texis/sequences.texi:317
#, no-wrap
msgid "(setq x (nreverse x))\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:321
msgid ""
"Here is the @code{nreverse} of our favorite example, @code{(a b c)}, "
"presented graphically:"
msgstr ""

#. type: group
#: original_texis/sequences.texi:332
#, no-wrap
msgid ""
"@r{Original list head:}                       @r{Reversed list:}\n"
" -------------        -------------        ------------\n"
"| car  | cdr  |      | car  | cdr  |      | car | cdr  |\n"
"|   a  |  nil |<--   |   b  |   o  |<--   |   c |   o  |\n"
"|      |      |   |  |      |   |  |   |  |     |   |  |\n"
" -------------    |   --------- | -    |   -------- | -\n"
"                  |             |      |            |\n"
"                   -------------        ------------\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:336
msgid "For the vector, it is even simpler because you don't need setq:"
msgstr ""

#. type: example
#: original_texis/sequences.texi:344
#, no-wrap
msgid ""
"(setq x (copy-sequence [1 2 3 4]))\n"
"     @result{} [1 2 3 4]\n"
"(nreverse x)\n"
"     @result{} [4 3 2 1]\n"
"x\n"
"     @result{} [4 3 2 1]\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:350
msgid ""
"Note that unlike @code{reverse}, this function doesn't work with strings.  "
"Although you can alter string data by using @code{aset}, it is strongly "
"encouraged to treat strings as immutable even when they are mutable.  "
"@xref{Mutability}."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:353
#, no-wrap
msgid "sort sequence predicate"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:354
#, no-wrap
msgid "stable sort"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:355
#, no-wrap
msgid "sorting lists"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:356
#, no-wrap
msgid "sorting vectors"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:364
msgid ""
"This function sorts @var{sequence} stably.  Note that this function doesn't "
"work for all sequences; it may be used only for lists and vectors.  If "
"@var{sequence} is a list, it is modified destructively.  This functions "
"returns the sorted @var{sequence} and compares elements using "
"@var{predicate}.  A stable sort is one in which elements with equal sort "
"keys maintain their relative order before and after the sort.  Stability is "
"important when successive sorts are used to order elements according to "
"different criteria."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:369
msgid ""
"The argument @var{predicate} must be a function that accepts two arguments.  "
"It is called with two elements of @var{sequence}.  To get an increasing "
"order sort, the @var{predicate} should return non-@code{nil} if the first "
"element is ``less'' than the second, or @code{nil} if not."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:378
msgid ""
"The comparison function @var{predicate} must give reliable results for any "
"given pair of arguments, at least within a single call to @code{sort}.  It "
"must be @dfn{antisymmetric}; that is, if @var{a} is less than @var{b}, "
"@var{b} must not be less than @var{a}.  It must be @dfn{transitive}---that "
"is, if @var{a} is less than @var{b}, and @var{b} is less than @var{c}, then "
"@var{a} must be less than @var{c}.  If you use a comparison function which "
"does not meet these requirements, the result of @code{sort} is "
"unpredictable."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:384
msgid ""
"The destructive aspect of @code{sort} for lists is that it reuses the cons "
"cells forming @var{sequence} by changing their contents, possibly "
"rearranging them in a different order.  This means that the value of the "
"input list is undefined after sorting; only the list returned by @code{sort} "
"has a well-defined value.  Example:"
msgstr ""

#. type: group
#: original_texis/sequences.texi:391
#, no-wrap
msgid ""
"(setq nums (list 2 1 4 3 0))\n"
"(sort nums #'<)\n"
"     @result{} (0 1 2 3 4)\n"
"     ; nums is unpredictable at this point\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:396
msgid ""
"Most often we store the result back into the variable that held the original "
"list:"
msgstr ""

#. type: example
#: original_texis/sequences.texi:399
#, no-wrap
msgid "(setq nums (sort nums #'<))\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:403
msgid ""
"If you wish to make a sorted copy without destroying the original, copy it "
"first and then sort:"
msgstr ""

#. type: group
#: original_texis/sequences.texi:409
#, no-wrap
msgid ""
"(setq nums (list 2 1 4 3 0))\n"
"(sort (copy-sequence nums) #'<)\n"
"     @result{} (0 1 2 3 4)\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:413
#, no-wrap
msgid ""
"nums\n"
"     @result{} (2 1 4 3 0)\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:421
msgid ""
"For the better understanding of what stable sort is, consider the following "
"vector example.  After sorting, all items whose @code{car} is 8 are grouped "
"at the beginning of @code{vector}, but their relative order is preserved.  "
"All items whose @code{car} is 9 are grouped at the end of @code{vector}, but "
"their relative order is also preserved:"
msgstr ""

#. type: group
#: original_texis/sequences.texi:430
#, no-wrap
msgid ""
"(setq\n"
"  vector\n"
"  (vector '(8 . \"xxx\") '(9 . \"aaa\") '(8 . \"bbb\") '(9 . \"zzz\")\n"
"          '(9 . \"ppp\") '(8 . \"ttt\") '(8 . \"eee\") '(9 . \"fff\")))\n"
"     @result{} [(8 . \"xxx\") (9 . \"aaa\") (8 . \"bbb\") (9 . \"zzz\")\n"
"         (9 . \"ppp\") (8 . \"ttt\") (8 . \"eee\") (9 . \"fff\")]\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:435
#, no-wrap
msgid ""
"(sort vector (lambda (x y) (< (car x) (car y))))\n"
"     @result{} [(8 . \"xxx\") (8 . \"bbb\") (8 . \"ttt\") (8 . \"eee\")\n"
"         (9 . \"aaa\") (9 . \"zzz\") (9 . \"ppp\") (9 . \"fff\")]\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:441
msgid ""
"@xref{Sorting}, for more functions that perform sorting.  See "
"@code{documentation} in @ref{Accessing Documentation}, for a useful example "
"of @code{sort}."
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:443
#, no-wrap
msgid "sequence functions in seq"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:444
#, no-wrap
msgid "seq library"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:445
#, no-wrap
msgid "sequences, generalized"
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:448
msgid ""
"The @file{seq.el} library provides the following additional sequence "
"manipulation macros and functions, prefixed with @code{seq-}."
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:454
msgid ""
"All functions defined in this library are free of side-effects; i.e., they "
"do not modify any sequence (list, vector, or string) that you pass as an "
"argument.  Unless otherwise stated, the result is a sequence of the same "
"type as the input.  For those functions that take a predicate, this should "
"be a function of one argument."
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:459
msgid ""
"The @file{seq.el} library can be extended to work with additional types of "
"sequential data-structures.  For that purpose, all functions are defined "
"using @code{cl-defgeneric}.  @xref{Generic Functions}, for more details "
"about using @code{cl-defgeneric} for adding extensions."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:460
#, no-wrap
msgid "seq-elt sequence index"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:466
msgid ""
"This function returns the element of @var{sequence} at the specified "
"@var{index}, which is an integer whose valid value range is zero to one less "
"than the length of @var{sequence}.  For out-of-range values on built-in "
"sequence types, @code{seq-elt} behaves like @code{elt}.  For the details, "
"see @ref{Definition of elt}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:471
#, no-wrap
msgid ""
"(seq-elt [1 2 3 4] 2)\n"
"@result{} 3\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:476
msgid ""
"@code{seq-elt} returns places settable using @code{setf} (@pxref{Setting "
"Generalized Variables})."
msgstr ""

#. type: group
#: original_texis/sequences.texi:483
#, no-wrap
msgid ""
"(setq vec [1 2 3 4])\n"
"(setf (seq-elt vec 2) 5)\n"
"vec\n"
"@result{} [1 2 5 4]\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:487
#, no-wrap
msgid "seq-length sequence"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:491
msgid ""
"This function returns the number of elements in @var{sequence}.  For "
"built-in sequence types, @code{seq-length} behaves like @code{length}.  "
"@xref{Definition of length}."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:493
#, no-wrap
msgid "seqp object"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:498
msgid ""
"This function returns non-@code{nil} if @var{object} is a sequence (a list "
"or array), or any additional type of sequence defined via @file{seq.el} "
"generic functions.  This is an extensible variant of @code{sequencep}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:503
#, no-wrap
msgid ""
"(seqp [1 2])\n"
"@result{} t\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:507
#, no-wrap
msgid ""
"(seqp 2)\n"
"@result{} nil\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:511
#, no-wrap
msgid "seq-drop sequence n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:515
msgid ""
"This function returns all but the first @var{n} (an integer)  elements of "
"@var{sequence}.  If @var{n} is negative or zero, the result is "
"@var{sequence}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:520
#, no-wrap
msgid ""
"(seq-drop [1 2 3 4 5 6] 3)\n"
"@result{} [4 5 6]\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:524
#, no-wrap
msgid ""
"(seq-drop \"hello world\" -4)\n"
"@result{} \"hello world\"\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:528
#, no-wrap
msgid "seq-take sequence n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:532
msgid ""
"This function returns the first @var{n} (an integer) elements of "
"@var{sequence}.  If @var{n} is negative or zero, the result is @code{nil}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:537
#, no-wrap
msgid ""
"(seq-take '(1 2 3 4) 3)\n"
"@result{} (1 2 3)\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:541
#, no-wrap
msgid ""
"(seq-take [1 2 3 4] 0)\n"
"@result{} []\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:545
#, no-wrap
msgid "seq-take-while predicate sequence"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:548
msgid ""
"This function returns the members of @var{sequence} in order, stopping "
"before the first one for which @var{predicate} returns @code{nil}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:553
#, no-wrap
msgid ""
"(seq-take-while (lambda (elt) (> elt 0)) '(1 2 3 -1 -2))\n"
"@result{} (1 2 3)\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:557
#, no-wrap
msgid ""
"(seq-take-while (lambda (elt) (> elt 0)) [-1 4 6])\n"
"@result{} []\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:561
#, no-wrap
msgid "seq-drop-while predicate sequence"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:564
msgid ""
"This function returns the members of @var{sequence} in order, starting from "
"the first one for which @var{predicate} returns @code{nil}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:569
#, no-wrap
msgid ""
"(seq-drop-while (lambda (elt) (> elt 0)) '(1 2 3 -1 -2))\n"
"@result{} (-1 -2)\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:573
#, no-wrap
msgid ""
"(seq-drop-while (lambda (elt) (< elt 0)) [1 4 6])\n"
"@result{} [1 4 6]\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:577
#, no-wrap
msgid "seq-split sequence length"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:582
msgid ""
"This function returns a list consisting of sub-sequences of @var{sequence} "
"of (at most) length @var{length}.  (The final element may be shorter than "
"@var{length} if the length of @var{sequence} isn't a multiple of "
"@var{length}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:587
#, no-wrap
msgid ""
"(seq-split [0 1 2 3 4] 2)\n"
"@result{} ([0 1] [2 3] [4])\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:591
#, no-wrap
msgid "seq-do function sequence"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:595
msgid ""
"This function applies @var{function} to each element of @var{sequence} in "
"turn (presumably for side effects), and returns @var{sequence}."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:597
#, no-wrap
msgid "seq-map function sequence"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:600
msgid ""
"This function returns the result of applying @var{function} to each element "
"of @var{sequence}.  The returned value is a list."
msgstr ""

#. type: group
#: original_texis/sequences.texi:605
#, no-wrap
msgid ""
"(seq-map #'1+ '(2 4 6))\n"
"@result{} (3 5 7)\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:609
#, no-wrap
msgid ""
"(seq-map #'symbol-name [foo bar])\n"
"@result{} (\"foo\" \"bar\")\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:613
#, no-wrap
msgid "seq-map-indexed function sequence"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:617
msgid ""
"This function returns the result of applying @var{function} to each element "
"of @var{sequence} and its index within @var{seq}.  The returned value is a "
"list."
msgstr ""

#. type: group
#: original_texis/sequences.texi:624
#, no-wrap
msgid ""
"(seq-map-indexed (lambda (elt idx)\n"
"                   (list idx elt))\n"
"                 '(a b c))\n"
"@result{} ((0 a) (1 b) (2 c))\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:628
#, no-wrap
msgid "seq-mapn function &rest sequences"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:634
msgid ""
"This function returns the result of applying @var{function} to each element "
"of @var{sequences}.  The arity (@pxref{What Is a Function, subr-arity}) of "
"@var{function} must match the number of sequences.  Mapping stops at the end "
"of the shortest sequence, and the returned value is a list."
msgstr ""

#. type: group
#: original_texis/sequences.texi:639
#, no-wrap
msgid ""
"(seq-mapn #'+ '(2 4 6) '(20 40 60))\n"
"@result{} (22 44 66)\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:643
#, no-wrap
msgid ""
"(seq-mapn #'concat '(\"moskito\" \"bite\") [\"bee\" \"sting\"])\n"
"@result{} (\"moskitobee\" \"bitesting\")\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:647
#, no-wrap
msgid "seq-filter predicate sequence"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:648
#, no-wrap
msgid "filtering sequences"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:651
msgid ""
"This function returns a list of all the elements in @var{sequence} for which "
"@var{predicate} returns non-@code{nil}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:656
#, no-wrap
msgid ""
"(seq-filter (lambda (elt) (> elt 0)) [1 -1 3 -3 5])\n"
"@result{} (1 3 5)\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:660
#, no-wrap
msgid ""
"(seq-filter (lambda (elt) (> elt 0)) '(-1 -3 -5))\n"
"@result{} nil\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:664
#, no-wrap
msgid "seq-remove predicate sequence"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:665 original_texis/sequences.texi:682
#, no-wrap
msgid "removing from sequences"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:668
msgid ""
"This function returns a list of all the elements in @var{sequence} for which "
"@var{predicate} returns @code{nil}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:673
#, no-wrap
msgid ""
"(seq-remove (lambda (elt) (> elt 0)) [1 -1 3 -3 5])\n"
"@result{} (-1 -3)\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:677
#, no-wrap
msgid ""
"(seq-remove (lambda (elt) (< elt 0)) '(-1 -3 -5))\n"
"@result{} nil\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:681
#, no-wrap
msgid "seq-remove-at-position sequence n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:686
msgid ""
"This function returns a copy of @var{sequence} where the element at "
"(zero-based) index @var{n} got removed.  The result is a sequence of the "
"same type as @var{sequence}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:691
#, no-wrap
msgid ""
"(seq-remove-at-position [1 -1 3 -3 5] 0)\n"
"@result{} [-1 3 -3 5]\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:695
#, no-wrap
msgid ""
"(seq-remove-at-position [1 -1 3 -3 5] 3)\n"
"@result{} [1 -1 3 5]\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:699
#, no-wrap
msgid "seq-keep function sequence"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:702
msgid ""
"This function returns a list of all non-@code{nil} results from calling "
"@var{function} on the elements in @var{sequence}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:707
#, no-wrap
msgid ""
"(seq-keep #'cl-digit-char-p '(?6 ?a ?7))\n"
"@result{} (6 7)\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:712
#, no-wrap
msgid "seq-reduce function sequence initial-value"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:713
#, no-wrap
msgid "reducing sequences"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:719
msgid ""
"This function returns the result of calling @var{function} with "
"@var{initial-value} and the first element of @var{sequence}, then calling "
"@var{function} with that result and the second element of @var{sequence}, "
"then with that result and the third element of @var{sequence}, etc.  "
"@var{function} should be a function of two arguments."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:723
msgid ""
"@var{function} is called with two arguments.  @var{initial-value} (and then "
"the accumulated value) is used as the first argument, and the elements in "
"@var{sequence} are used for the second argument."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:726
msgid ""
"If @var{sequence} is empty, this returns @var{initial-value} without calling "
"@var{function}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:731
#, no-wrap
msgid ""
"(seq-reduce #'+ [1 2 3 4] 0)\n"
"@result{} 10\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:735
#, no-wrap
msgid ""
"(seq-reduce #'+ '(1 2 3 4) 5)\n"
"@result{} 15\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:739
#, no-wrap
msgid ""
"(seq-reduce #'+ '() 3)\n"
"@result{} 3\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:743
#, no-wrap
msgid "seq-some predicate sequence"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:746
msgid ""
"This function returns the first non-@code{nil} value returned by applying "
"@var{predicate} to each element of @var{sequence} in turn."
msgstr ""

#. type: group
#: original_texis/sequences.texi:751
#, no-wrap
msgid ""
"(seq-some #'numberp [\"abc\" 1 nil])\n"
"@result{} t\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:755
#, no-wrap
msgid ""
"(seq-some #'numberp [\"abc\" \"def\"])\n"
"@result{} nil\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:759
#, no-wrap
msgid ""
"(seq-some #'null [\"abc\" 1 nil])\n"
"@result{} t\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:763
#, no-wrap
msgid ""
"(seq-some #'1+ [2 4 6])\n"
"@result{} 3\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:767
#, no-wrap
msgid "seq-find predicate sequence &optional default"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:771
msgid ""
"This function returns the first element in @var{sequence} for which "
"@var{predicate} returns non-@code{nil}.  If no element matches "
"@var{predicate}, the function returns @var{default}."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:775
msgid ""
"Note that this function has an ambiguity if the found element is identical "
"to @var{default}, as in that case it cannot be known whether an element was "
"found or not."
msgstr ""

#. type: group
#: original_texis/sequences.texi:780
#, no-wrap
msgid ""
"(seq-find #'numberp [\"abc\" 1 nil])\n"
"@result{} 1\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:784
#, no-wrap
msgid ""
"(seq-find #'numberp [\"abc\" \"def\"])\n"
"@result{} nil\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:788
#, no-wrap
msgid "seq-every-p predicate sequence"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:791
msgid ""
"This function returns non-@code{nil} if applying @var{predicate} to every "
"element of @var{sequence} returns non-@code{nil}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:796
#, no-wrap
msgid ""
"(seq-every-p #'numberp [2 4 6])\n"
"@result{} t\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:800
#, no-wrap
msgid ""
"(seq-every-p #'numberp [2 4 \"6\"])\n"
"@result{} nil\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:804
#, no-wrap
msgid "seq-empty-p sequence"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:806
msgid "This function returns non-@code{nil} if @var{sequence} is empty."
msgstr ""

#. type: group
#: original_texis/sequences.texi:811
#, no-wrap
msgid ""
"(seq-empty-p \"not empty\")\n"
"@result{} nil\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:815
#, no-wrap
msgid ""
"(seq-empty-p \"\")\n"
"@result{} t\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:819
#, no-wrap
msgid "seq-count predicate sequence"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:822
msgid ""
"This function returns the number of elements in @var{sequence} for which "
"@var{predicate} returns non-@code{nil}."
msgstr ""

#. type: example
#: original_texis/sequences.texi:826
#, no-wrap
msgid ""
"(seq-count (lambda (elt) (> elt 0)) [-1 2 0 3 -2])\n"
"@result{} 2\n"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:829
#, no-wrap
msgid "sorting sequences"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:830
#, no-wrap
msgid "seq-sort function sequence"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:834
msgid ""
"This function returns a copy of @var{sequence} that is sorted according to "
"@var{function}, a function of two arguments that returns non-@code{nil} if "
"the first argument should sort before the second."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:836
#, no-wrap
msgid "seq-sort-by function predicate sequence"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:840
msgid ""
"This function is similar to @code{seq-sort}, but the elements of "
"@var{sequence} are transformed by applying @var{function} on them before "
"being sorted.  @var{function} is a function of one argument."
msgstr ""

#. type: example
#: original_texis/sequences.texi:844
#, no-wrap
msgid ""
"(seq-sort-by #'seq-length #'> [\"a\" \"ab\" \"abc\"])\n"
"@result{} [\"abc\" \"ab\" \"a\"]\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:848
#, no-wrap
msgid "seq-contains-p sequence elt &optional function"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:853
msgid ""
"This function returns non-@code{nil} if at least one element in "
"@var{sequence} is equal to @var{elt}.  If the optional argument "
"@var{function} is non-@code{nil}, it is a function of two arguments to use "
"instead of the default @code{equal}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:858
#, no-wrap
msgid ""
"(seq-contains-p '(symbol1 symbol2) 'symbol1)\n"
"@result{} t\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:862
#, no-wrap
msgid ""
"(seq-contains-p '(symbol1 symbol2) 'symbol3)\n"
"@result{} nil\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:867
#, no-wrap
msgid "seq-set-equal-p sequence1 sequence2 &optional testfn"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:872
msgid ""
"This function checks whether @var{sequence1} and @var{sequence2} contain the "
"same elements, regardless of the order. If the optional argument "
"@var{testfn} is non-@code{nil}, it is a function of two arguments to use "
"instead of the default @code{equal}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:877
#, no-wrap
msgid ""
"(seq-set-equal-p '(a b c) '(c b a))\n"
"@result{} t\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:881
#, no-wrap
msgid ""
"(seq-set-equal-p '(a b c) '(c b))\n"
"@result{} nil\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:885
#, no-wrap
msgid ""
"(seq-set-equal-p '(\"a\" \"b\" \"c\") '(\"c\" \"b\" \"a\"))\n"
"@result{} t\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:889
#, no-wrap
msgid ""
"(seq-set-equal-p '(\"a\" \"b\" \"c\") '(\"c\" \"b\" \"a\") #'eq)\n"
"@result{} nil\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:894
#, no-wrap
msgid "seq-position sequence elt &optional function"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:899
msgid ""
"This function returns the (zero-based) index of the first element in "
"@var{sequence} that is equal to @var{elt}.  If the optional argument "
"@var{function} is non-@code{nil}, it is a function of two arguments to use "
"instead of the default @code{equal}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:904
#, no-wrap
msgid ""
"(seq-position '(a b c) 'b)\n"
"@result{} 1\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:908
#, no-wrap
msgid ""
"(seq-position '(a b c) 'd)\n"
"@result{} nil\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:912
#, no-wrap
msgid "seq-positions sequence elt &optional testfn"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:917
msgid ""
"This function returns a list of the (zero-based) indices of the elements in "
"@var{sequence} for which @var{testfn} returns non-@code{nil} when passed the "
"element and @var{elt} as arguments. @var{testfn} defaults to @code{equal}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:922
#, no-wrap
msgid ""
"(seq-positions '(a b c a d) 'a)\n"
"@result{} (0 3)\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:926
#, no-wrap
msgid ""
"(seq-positions '(a b c a d) 'z)\n"
"@result{} nil\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:930
#, no-wrap
msgid ""
"(seq-positions '(11 5 7 12 9 15) 10 #'>=)\n"
"@result{} (0 3 5)\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:934
#, no-wrap
msgid "seq-uniq sequence &optional function"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:938
msgid ""
"This function returns a list of the elements of @var{sequence} with "
"duplicates removed.  If the optional argument @var{function} is "
"non-@code{nil}, it is a function of two arguments to use instead of the "
"default @code{equal}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:943
#, no-wrap
msgid ""
"(seq-uniq '(1 2 2 1 3))\n"
"@result{} (1 2 3)\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:947
#, no-wrap
msgid ""
"(seq-uniq '(1 2 2.0 1.0) #'=)\n"
"@result{} (1 2)\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:951
#, no-wrap
msgid "seq-subseq sequence start &optional end"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:952
#, no-wrap
msgid "sub-sequence"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:957
msgid ""
"This function returns a subset of @var{sequence} from @var{start} to "
"@var{end}, both integers (@var{end} defaults to the last element).  If "
"@var{start} or @var{end} is negative, it counts from the end of "
"@var{sequence}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:962
#, no-wrap
msgid ""
"(seq-subseq '(1 2 3 4 5) 1)\n"
"@result{} (2 3 4 5)\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:966
#, no-wrap
msgid ""
"(seq-subseq '[1 2 3 4 5] 1 3)\n"
"@result{} [2 3]\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:970
#, no-wrap
msgid ""
"(seq-subseq '[1 2 3 4 5] -3 -1)\n"
"@result{} [3 4]\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:974
#, no-wrap
msgid "seq-concatenate type &rest sequences"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:978
msgid ""
"This function returns a sequence of type @var{type} made of the "
"concatenation of @var{sequences}.  @var{type} may be: @code{vector}, "
"@code{list} or @code{string}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:983
#, no-wrap
msgid ""
"(seq-concatenate 'list '(1 2) '(3 4) [5 6])\n"
"@result{} (1 2 3 4 5 6)\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:987
#, no-wrap
msgid ""
"(seq-concatenate 'string \"Hello \" \"world\")\n"
"@result{} \"Hello world\"\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:991
#, no-wrap
msgid "seq-mapcat function sequence &optional type"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:996
msgid ""
"This function returns the result of applying @code{seq-concatenate} to the "
"result of applying @var{function} to each element of @var{sequence}.  The "
"result is a sequence of type @var{type}, or a list if @var{type} is "
"@code{nil}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:1001
#, no-wrap
msgid ""
"(seq-mapcat #'seq-reverse '((3 2 1) (6 5 4)))\n"
"@result{} (1 2 3 4 5 6)\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1005
#, no-wrap
msgid "seq-partition sequence n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1010
msgid ""
"This function returns a list of the elements of @var{sequence} grouped into "
"sub-sequences of length @var{n}.  The last sequence may contain less "
"elements than @var{n}.  @var{n} must be an integer.  If @var{n} is a "
"negative integer or 0, the return value is @code{nil}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:1015
#, no-wrap
msgid ""
"(seq-partition '(0 1 2 3 4 5 6 7) 3)\n"
"@result{} ((0 1 2) (3 4 5) (6 7))\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1019
#, no-wrap
msgid "seq-union sequence1 sequence2 &optional function"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:1020
#, no-wrap
msgid "sequences, union of"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:1021
#, no-wrap
msgid "union of sequences"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1028
msgid ""
"This function returns a list of the elements that appear either in "
"@var{sequence1} or @var{sequence2}.  The elements of the returned list are "
"all unique, in the sense that no two elements there will compare equal.  If "
"the optional argument @var{function} is non-@code{nil}, it should be a "
"function of two arguments to use to compare elements, instead of the default "
"@code{equal}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:1033
#, no-wrap
msgid ""
"(seq-union [1 2 3] [3 5])\n"
"@result{} (1 2 3 5)\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1037
#, no-wrap
msgid "seq-intersection sequence1 sequence2 &optional function"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:1038
#, no-wrap
msgid "sequences, intersection of"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:1039
#, no-wrap
msgid "intersection of sequences"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1044
msgid ""
"This function returns a list of the elements that appear both in "
"@var{sequence1} and @var{sequence2}.  If the optional argument "
"@var{function} is non-@code{nil}, it is a function of two arguments to use "
"to compare elements instead of the default @code{equal}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:1049
#, no-wrap
msgid ""
"(seq-intersection [2 3 4 5] [1 3 5 6 7])\n"
"@result{} (3 5)\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1054
#, no-wrap
msgid "seq-difference sequence1 sequence2 &optional function"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1059
msgid ""
"This function returns a list of the elements that appear in @var{sequence1} "
"but not in @var{sequence2}.  If the optional argument @var{function} is "
"non-@code{nil}, it is a function of two arguments to use to compare elements "
"instead of the default @code{equal}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:1064
#, no-wrap
msgid ""
"(seq-difference '(2 3 4 5) [1 3 5 6 7])\n"
"@result{} (2 4)\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1068
#, no-wrap
msgid "seq-group-by function sequence"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1072
msgid ""
"This function separates the elements of @var{sequence} into an alist whose "
"keys are the result of applying @var{function} to each element of "
"@var{sequence}.  Keys are compared using @code{equal}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:1077
#, no-wrap
msgid ""
"(seq-group-by #'integerp '(1 2.1 3 2 3.2))\n"
"@result{} ((t 1 3 2) (nil 2.1 3.2))\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:1081
#, no-wrap
msgid ""
"(seq-group-by #'car '((a 1) (b 2) (a 3) (c 4)))\n"
"@result{} ((b (b 2)) (a (a 1) (a 3)) (c (c 4)))\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1085
#, no-wrap
msgid "seq-into sequence type"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:1086
#, no-wrap
msgid "convert sequence to another type"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:1087
#, no-wrap
msgid "list to vector"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:1088
#, no-wrap
msgid "vector to list"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:1089
#, no-wrap
msgid "string to vector"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1093
msgid ""
"This function converts the sequence @var{sequence} into a sequence of type "
"@var{type}.  @var{type} can be one of the following symbols: @code{vector}, "
"@code{string} or @code{list}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:1098
#, no-wrap
msgid ""
"(seq-into [1 2 3] 'list)\n"
"@result{} (1 2 3)\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:1102
#, no-wrap
msgid ""
"(seq-into nil 'vector)\n"
"@result{} []\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:1106
#, no-wrap
msgid ""
"(seq-into \"hello\" 'vector)\n"
"@result{} [104 101 108 108 111]\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1110
#, no-wrap
msgid "seq-min sequence"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:1111
#, no-wrap
msgid "minimum value of sequence"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:1112
#, no-wrap
msgid "sequence minimum"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1116
msgid ""
"This function returns the smallest element of @var{sequence}.  The elements "
"of @var{sequence} must be numbers or markers (@pxref{Markers})."
msgstr ""

#. type: group
#: original_texis/sequences.texi:1121
#, no-wrap
msgid ""
"(seq-min [3 1 2])\n"
"@result{} 1\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:1125
#, no-wrap
msgid ""
"(seq-min \"Hello\")\n"
"@result{} 72\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1129
#, no-wrap
msgid "seq-max sequence"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:1130
#, no-wrap
msgid "maximum value of sequence"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:1131
#, no-wrap
msgid "sequence maximum"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1134
msgid ""
"This function returns the largest element of @var{sequence}.  The elements "
"of @var{sequence} must be numbers or markers."
msgstr ""

#. type: group
#: original_texis/sequences.texi:1139
#, no-wrap
msgid ""
"(seq-max [1 3 2])\n"
"@result{} 3\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:1143
#, no-wrap
msgid ""
"(seq-max \"Hello\")\n"
"@result{} 111\n"
msgstr ""

#. type: defmac
#: original_texis/sequences.texi:1147
#, no-wrap
msgid "seq-doseq (var sequence) body@dots{}"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:1148
#, no-wrap
msgid "sequence iteration"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:1149
#, no-wrap
msgid "iteration over vector or string"
msgstr ""

#. type: defmac
#: original_texis/sequences.texi:1153
msgid ""
"This macro is like @code{dolist} (@pxref{Iteration, dolist}), except that "
"@var{sequence} can be a list, vector or string.  This is primarily useful "
"for side-effects."
msgstr ""

#. type: anchor{#1}
#: original_texis/sequences.texi:1156
msgid "seq-let"
msgstr ""

#. type: defmac
#: original_texis/sequences.texi:1156
#, no-wrap
msgid "seq-let var-sequence val-sequence body@dots{}"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:1157 original_texis/sequences.texi:1196
#, no-wrap
msgid "sequence destructuring"
msgstr ""

#. type: defmac
#: original_texis/sequences.texi:1163
msgid ""
"This macro binds the variables defined in @var{var-sequence} to the values "
"that are the corresponding elements of @var{val-sequence}.  This is known as "
"@dfn{destructuring binding}.  The elements of @var{var-sequence} can "
"themselves include sequences, allowing for nested destructuring."
msgstr ""

#. type: defmac
#: original_texis/sequences.texi:1167
msgid ""
"The @var{var-sequence} sequence can also include the @code{&rest} marker "
"followed by a variable name to be bound to the rest of @var{val-sequence}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:1173
#, no-wrap
msgid ""
"(seq-let [first second] [1 2 3 4]\n"
"  (list first second))\n"
"@result{} (1 2)\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:1178
#, no-wrap
msgid ""
"(seq-let (_ a _ b) '(1 2 3 4)\n"
"  (list a b))\n"
"@result{} (2 4)\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:1183
#, no-wrap
msgid ""
"(seq-let [a [b [c]]] [1 [2 [3]]]\n"
"  (list a b c))\n"
"@result{} (1 2 3)\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:1187
#, no-wrap
msgid ""
"(seq-let [a b &rest others] [1 2 3 4]\n"
"  others)\n"
msgstr ""

#. type: example
#: original_texis/sequences.texi:1189
#, no-wrap
msgid "@result{} [3 4]\n"
msgstr ""

#. type: defmac
#: original_texis/sequences.texi:1193
msgid ""
"The @code{pcase} patterns provide an alternative facility for destructuring "
"binding, see @ref{Destructuring with pcase Patterns}."
msgstr ""

#. type: defmac
#: original_texis/sequences.texi:1195
#, no-wrap
msgid "seq-setq var-sequence val-sequence"
msgstr ""

#. type: defmac
#: original_texis/sequences.texi:1200
msgid ""
"This macro works similarly to @code{seq-let}, except that values are "
"assigned to variables as if by @code{setq} instead of as in a @code{let} "
"binding."
msgstr ""

#. type: group
#: original_texis/sequences.texi:1208
#, no-wrap
msgid ""
"(let ((a nil)\n"
"      (b nil))\n"
"  (seq-setq (_ a _ b) '(1 2 3 4))\n"
"  (list a b))\n"
"@result{} (2 4)\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1212
#, no-wrap
msgid "seq-random-elt sequence"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1214
msgid "This function returns an element of @var{sequence} taken at random."
msgstr ""

#. type: group
#: original_texis/sequences.texi:1227
#, no-wrap
msgid ""
"(seq-random-elt [1 2 3 4])\n"
"@result{} 3\n"
"(seq-random-elt [1 2 3 4])\n"
"@result{} 2\n"
"(seq-random-elt [1 2 3 4])\n"
"@result{} 4\n"
"(seq-random-elt [1 2 3 4])\n"
"@result{} 2\n"
"(seq-random-elt [1 2 3 4])\n"
"@result{} 1\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1231
msgid "If @var{sequence} is empty, this function signals an error."
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:1235
#, no-wrap
msgid "array"
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:1242
msgid ""
"An @dfn{array} object has slots that hold a number of other Lisp objects, "
"called the elements of the array.  Any element of an array may be accessed "
"in constant time.  In contrast, the time to access an element of a list is "
"proportional to the position of that element in the list."
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:1249
msgid ""
"Emacs defines four types of array, all one-dimensional: @dfn{strings} "
"(@pxref{String Type}), @dfn{vectors} (@pxref{Vector Type}), "
"@dfn{bool-vectors} (@pxref{Bool-Vector Type}), and @dfn{char-tables} "
"(@pxref{Char-Table Type}).  Vectors and char-tables can hold elements of any "
"type, but strings can only hold characters, and bool-vectors can only hold "
"@code{t} and @code{nil}."
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:1251
msgid "All four kinds of array share these characteristics:"
msgstr ""

#. type: itemize
#: original_texis/sequences.texi:1257
msgid ""
"The first element of an array has index zero, the second element has index "
"1, and so on.  This is called @dfn{zero-origin} indexing.  For example, an "
"array of four elements has indices 0, 1, 2, @w{and 3}."
msgstr ""

#. type: itemize
#: original_texis/sequences.texi:1261
msgid ""
"The length of the array is fixed once you create it; you cannot change the "
"length of an existing array."
msgstr ""

#. type: itemize
#: original_texis/sequences.texi:1265
msgid ""
"For purposes of evaluation, the array is a constant---i.e., it evaluates to "
"itself."
msgstr ""

#. type: itemize
#: original_texis/sequences.texi:1269
msgid ""
"The elements of an array may be referenced or changed with the functions "
"@code{aref} and @code{aset}, respectively (@pxref{Array Functions})."
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:1274
msgid ""
"When you create an array, other than a char-table, you must specify its "
"length.  You cannot specify the length of a char-table, because that is "
"determined by the range of character codes."
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:1278
msgid ""
"In principle, if you want an array of text characters, you could use either "
"a string or a vector.  In practice, we always choose strings for such "
"applications, for four reasons:"
msgstr ""

#. type: itemize
#: original_texis/sequences.texi:1282
msgid "They occupy one-fourth the space of a vector of the same elements."
msgstr ""

#. type: itemize
#: original_texis/sequences.texi:1286
msgid "Strings are printed in a way that shows the contents more clearly as text."
msgstr ""

#. type: itemize
#: original_texis/sequences.texi:1289
msgid "Strings can hold text properties.  @xref{Text Properties}."
msgstr ""

#. type: itemize
#: original_texis/sequences.texi:1294
msgid ""
"Many of the specialized editing and I/O facilities of Emacs accept only "
"strings.  For example, you cannot insert a vector of characters into a "
"buffer the way you can insert a string.  @xref{Strings and Characters}."
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:1300
msgid ""
"By contrast, for an array of keyboard input characters (such as a key "
"sequence), a vector may be necessary, because many keyboard input characters "
"are outside the range that will fit in a string.  @xref{Key Sequence Input}."
msgstr ""

#. type: section
#: original_texis/sequences.texi:1302
#, no-wrap
msgid "Functions that Operate on Arrays"
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:1306
msgid "In this section, we describe the functions that accept all types of arrays."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1307
#, no-wrap
msgid "arrayp object"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1310
msgid ""
"This function returns @code{t} if @var{object} is an array (i.e., a vector, "
"a string, a bool-vector or a char-table)."
msgstr ""

#. type: group
#: original_texis/sequences.texi:1319
#, no-wrap
msgid ""
"(arrayp [a])\n"
"     @result{} t\n"
"(arrayp \"asdf\")\n"
"     @result{} t\n"
"(arrayp (syntax-table))    ;; @r{A char-table.}\n"
"     @result{} t\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1323
#, no-wrap
msgid "aref arr index"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:1324
#, no-wrap
msgid "array elements"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1327
msgid ""
"This function returns the @var{index}th element of the array or record "
"@var{arr}.  The first element is at index zero."
msgstr ""

#. type: group
#: original_texis/sequences.texi:1334
#, no-wrap
msgid ""
"(setq primes [2 3 5 7 11 13])\n"
"     @result{} [2 3 5 7 11 13]\n"
"(aref primes 4)\n"
"     @result{} 11\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:1338
#, no-wrap
msgid ""
"(aref \"abcdefg\" 1)\n"
"     @result{} 98           ; @r{@samp{b} is @acronym{ASCII} code 98.}\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1342
msgid "See also the function @code{elt}, in @ref{Sequence Functions}."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1344
#, no-wrap
msgid "aset array index object"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1347
msgid ""
"This function sets the @var{index}th element of @var{array} to be "
"@var{object}.  It returns @var{object}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:1356
#, no-wrap
msgid ""
"(setq w (vector 'foo 'bar 'baz))\n"
"     @result{} [foo bar baz]\n"
"(aset w 0 'fu)\n"
"     @result{} fu\n"
"w\n"
"     @result{} [fu bar baz]\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:1366
#, no-wrap
msgid ""
";; @r{@code{copy-sequence} copies the string to be modified later.}\n"
"(setq x (copy-sequence \"asdfasfd\"))\n"
"     @result{} \"asdfasfd\"\n"
"(aset x 3 ?Z)\n"
"     @result{} 90\n"
"x\n"
"     @result{} \"asdZasfd\"\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1370
msgid "The @var{array} should be mutable.  @xref{Mutability}."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1374
msgid ""
"If @var{array} is a string and @var{object} is not a character, a "
"@code{wrong-type-argument} error results.  The function converts a unibyte "
"string to multibyte if necessary to insert a character."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1376
#, no-wrap
msgid "fillarray array object"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1379
msgid ""
"This function fills the array @var{array} with @var{object}, so that each "
"element of @var{array} is @var{object}.  It returns @var{array}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:1388
#, no-wrap
msgid ""
"(setq a (copy-sequence [a b c d e f g]))\n"
"     @result{} [a b c d e f g]\n"
"(fillarray a 0)\n"
"     @result{} [0 0 0 0 0 0 0]\n"
"a\n"
"     @result{} [0 0 0 0 0 0 0]\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:1394
#, no-wrap
msgid ""
"(setq s (copy-sequence \"When in the course\"))\n"
"     @result{} \"When in the course\"\n"
"(fillarray s ?-)\n"
"     @result{} \"------------------\"\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1399
msgid ""
"If @var{array} is a string and @var{object} is not a character, a "
"@code{wrong-type-argument} error results."
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:1403
msgid ""
"The general sequence functions @code{copy-sequence} and @code{length} are "
"often useful for objects known to be arrays.  @xref{Sequence Functions}."
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:1406
#, no-wrap
msgid "vector (type)"
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:1415
msgid ""
"A @dfn{vector} is a general-purpose array whose elements can be any Lisp "
"objects.  (By contrast, the elements of a string can only be characters.  "
"@xref{Strings and Characters}.)  Vectors are used in Emacs for many "
"purposes: as key sequences (@pxref{Key Sequences}), as symbol-lookup tables "
"(@pxref{Creating Symbols}), as part of the representation of a byte-compiled "
"function (@pxref{Byte Compilation}), and more."
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:1418
msgid ""
"Like other arrays, vectors use zero-origin indexing: the first element has "
"index 0."
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:1423
msgid ""
"Vectors are printed with square brackets surrounding the elements.  Thus, a "
"vector whose elements are the symbols @code{a}, @code{b} and @code{a} is "
"printed as @code{[a b a]}.  You can write vectors in the same way in Lisp "
"input."
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:1430
msgid ""
"A vector, like a string or a number, is considered a constant for "
"evaluation: the result of evaluating it is the same vector.  This does not "
"evaluate or even examine the elements of the vector.  @xref{Self-Evaluating "
"Forms}.  Vectors written with square brackets should not be modified via "
"@code{aset} or other destructive operations.  @xref{Mutability}."
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:1432
msgid "Here are examples illustrating these principles:"
msgstr ""

#. type: group
#: original_texis/sequences.texi:1441
#, no-wrap
msgid ""
"(setq avector [1 two '(three) \"four\" [five]])\n"
"     @result{} [1 two '(three) \"four\" [five]]\n"
"(eval avector)\n"
"     @result{} [1 two '(three) \"four\" [five]]\n"
"(eq avector (eval avector))\n"
"     @result{} t\n"
msgstr ""

#. type: section
#: original_texis/sequences.texi:1445
#, no-wrap
msgid "Functions for Vectors"
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:1448
msgid "Here are some functions that relate to vectors:"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1449
#, no-wrap
msgid "vectorp object"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1451
msgid "This function returns @code{t} if @var{object} is a vector."
msgstr ""

#. type: group
#: original_texis/sequences.texi:1458
#, no-wrap
msgid ""
"(vectorp [a])\n"
"     @result{} t\n"
"(vectorp \"asdf\")\n"
"     @result{} nil\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1462
#, no-wrap
msgid "vector &rest objects"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1465
msgid ""
"This function creates and returns a vector whose elements are the arguments, "
"@var{objects}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:1472
#, no-wrap
msgid ""
"(vector 'foo 23 [bar baz] \"rats\")\n"
"     @result{} [foo 23 [bar baz] \"rats\"]\n"
"(vector)\n"
"     @result{} []\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1476
#, no-wrap
msgid "make-vector length object"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1479
msgid ""
"This function returns a new vector consisting of @var{length} elements, each "
"initialized to @var{object}."
msgstr ""

#. type: group
#: original_texis/sequences.texi:1484
#, no-wrap
msgid ""
"(setq sleepy (make-vector 9 'Z))\n"
"     @result{} [Z Z Z Z Z Z Z Z Z]\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1488
#, no-wrap
msgid "vconcat &rest sequences"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:1489
#, no-wrap
msgid "copying vectors"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1494
msgid ""
"This function returns a new vector containing all the elements of "
"@var{sequences}.  The arguments @var{sequences} may be proper lists, "
"vectors, strings or bool-vectors.  If no @var{sequences} are given, the "
"empty vector is returned."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1497
msgid ""
"The value is either the empty vector, or is a newly constructed nonempty "
"vector that is not @code{eq} to any existing vector."
msgstr ""

#. type: group
#: original_texis/sequences.texi:1504
#, no-wrap
msgid ""
"(setq a (vconcat '(A B C) '(D E F)))\n"
"     @result{} [A B C D E F]\n"
"(eq a (vconcat a))\n"
"     @result{} nil\n"
msgstr ""

#. type: group
#: original_texis/sequences.texi:1510
#, no-wrap
msgid ""
"(vconcat)\n"
"     @result{} []\n"
"(vconcat [A B C] \"aa\" '(foo (6 7)))\n"
"     @result{} [A B C 97 97 foo (6 7)]\n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1516
msgid ""
"The @code{vconcat} function also allows byte-code function objects as "
"arguments.  This is a special feature to make it easy to access the entire "
"contents of a byte-code function object.  @xref{Byte-Code Objects}."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1520
msgid ""
"For other concatenation functions, see @code{mapconcat} in @ref{Mapping "
"Functions}, @code{concat} in @ref{Creating Strings}, and @code{append} in "
"@ref{Building Lists}."
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:1524
msgid ""
"The @code{append} function also provides a way to convert a vector into a "
"list with the same elements:"
msgstr ""

#. type: group
#: original_texis/sequences.texi:1531
#, no-wrap
msgid ""
"(setq avector [1 two (quote (three)) \"four\" [five]])\n"
"     @result{} [1 two '(three) \"four\" [five]]\n"
"(append avector nil)\n"
"     @result{} (1 two '(three) \"four\" [five])\n"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:1536
#, no-wrap
msgid "char-tables"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:1537
#, no-wrap
msgid "extra slots of char-table"
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:1547
msgid ""
"A char-table is much like a vector, except that it is indexed by character "
"codes.  Any valid character code, without modifiers, can be used as an index "
"in a char-table.  You can access a char-table's elements with @code{aref} "
"and @code{aset}, as with any array.  In addition, a char-table can have "
"@dfn{extra slots} to hold additional data not associated with particular "
"character codes.  Like vectors, char-tables are constants when evaluated, "
"and can hold elements of any type."
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:1548
#, no-wrap
msgid "subtype of char-table"
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:1551
msgid "Each char-table has a @dfn{subtype}, a symbol, which serves two purposes:"
msgstr ""

#. type: itemize
#: original_texis/sequences.texi:1559
msgid ""
"The subtype provides an easy way to tell what the char-table is for.  For "
"instance, display tables are char-tables with @code{display-table} as the "
"subtype, and syntax tables are char-tables with @code{syntax-table} as the "
"subtype.  The subtype can be queried using the function "
"@code{char-table-subtype}, described below."
msgstr ""

#. type: itemize
#: original_texis/sequences.texi:1567
msgid ""
"The subtype controls the number of @dfn{extra slots} in the char-table.  "
"This number is specified by the subtype's @code{char-table-extra-slots} "
"symbol property (@pxref{Symbol Properties}), whose value should be an "
"integer between 0 and 10.  If the subtype has no such symbol property, the "
"char-table has no extra slots."
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:1569
#, no-wrap
msgid "parent of char-table"
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:1576
msgid ""
"A char-table can have a @dfn{parent}, which is another char-table.  If it "
"does, then whenever the char-table specifies @code{nil} for a particular "
"character @var{c}, it inherits the value specified in the parent.  In other "
"words, @code{(aref @var{char-table} @var{c})} returns the value from the "
"parent of @var{char-table} if @var{char-table} itself specifies @code{nil}."
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:1577
#, no-wrap
msgid "default value of char-table"
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:1581
msgid ""
"A char-table can also have a @dfn{default value}.  If so, then @code{(aref "
"@var{char-table} @var{c})} returns the default value whenever the char-table "
"does not specify any other non-@code{nil} value."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1582
#, no-wrap
msgid "make-char-table subtype &optional init"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1587
msgid ""
"Return a newly-created char-table, with subtype @var{subtype} (a symbol).  "
"Each element is initialized to @var{init}, which defaults to @code{nil}.  "
"You cannot alter the subtype of a char-table after the char-table is "
"created."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1590
msgid ""
"There is no argument to specify the length of the char-table, because all "
"char-tables have room for any valid character code as an index."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1597
msgid ""
"If @var{subtype} has the @code{char-table-extra-slots} symbol property, that "
"specifies the number of extra slots in the char-table.  This should be an "
"integer between 0 and 10; otherwise, @code{make-char-table} raises an "
"error.  If @var{subtype} has no @code{char-table-extra-slots} symbol "
"property (@pxref{Property Lists}), the char-table has no extra slots."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1599
#, no-wrap
msgid "char-table-p object"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1602
msgid ""
"This function returns @code{t} if @var{object} is a char-table, and "
"@code{nil} otherwise."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1604
#, no-wrap
msgid "char-table-subtype char-table"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1606
msgid "This function returns the subtype symbol of @var{char-table}."
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:1610
msgid ""
"There is no special function to access default values in a char-table.  To "
"do that, use @code{char-table-range} (see below)."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1611
#, no-wrap
msgid "char-table-parent char-table"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1614
msgid ""
"This function returns the parent of @var{char-table}.  The parent is always "
"either @code{nil} or another char-table."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1616
#, no-wrap
msgid "set-char-table-parent char-table new-parent"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1618
msgid "This function sets the parent of @var{char-table} to @var{new-parent}."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1620
#, no-wrap
msgid "char-table-extra-slot char-table n"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1624
msgid ""
"This function returns the contents of extra slot @var{n} (zero based)  of "
"@var{char-table}.  The number of extra slots in a char-table is determined "
"by its subtype."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1626
#, no-wrap
msgid "set-char-table-extra-slot char-table n value"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1629
msgid ""
"This function stores @var{value} in extra slot @var{n} (zero based) of "
"@var{char-table}."
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:1633
msgid ""
"A char-table can specify an element value for a single character code; it "
"can also specify a value for an entire character set."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1634
#, no-wrap
msgid "char-table-range char-table range"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1637
msgid ""
"This returns the value specified in @var{char-table} for a range of "
"characters @var{range}.  Here are the possibilities for @var{range}:"
msgstr ""

#. type: code{#1}
#: original_texis/sequences.texi:1639 original_texis/sequences.texi:1658
#, no-wrap
msgid "nil"
msgstr ""

#. type: table
#: original_texis/sequences.texi:1641 original_texis/sequences.texi:1660
msgid "Refers to the default value."
msgstr ""

#. type: var{#1}
#: original_texis/sequences.texi:1642 original_texis/sequences.texi:1664
#, no-wrap
msgid "char"
msgstr ""

#. type: table
#: original_texis/sequences.texi:1645 original_texis/sequences.texi:1667
msgid ""
"Refers to the element for character @var{char} (supposing @var{char} is a "
"valid character code)."
msgstr ""

#. type: code{#1}
#: original_texis/sequences.texi:1646 original_texis/sequences.texi:1668
#, no-wrap
msgid "(@var{from} . @var{to})"
msgstr ""

#. type: table
#: original_texis/sequences.texi:1650
msgid ""
"A cons cell refers to all the characters in the inclusive range "
"@samp{[@var{from}..@var{to}]}.  In this case, the function returns the value "
"for the character specified by @var{from}."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1653
#, no-wrap
msgid "set-char-table-range char-table range value"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1656
msgid ""
"This function sets the value in @var{char-table} for a range of characters "
"@var{range}.  Here are the possibilities for @var{range}:"
msgstr ""

#. type: code{#1}
#: original_texis/sequences.texi:1661
#, no-wrap
msgid "t"
msgstr ""

#. type: table
#: original_texis/sequences.texi:1663
msgid "Refers to the whole range of character codes."
msgstr ""

#. type: table
#: original_texis/sequences.texi:1671
msgid ""
"A cons cell refers to all the characters in the inclusive range "
"@samp{[@var{from}..@var{to}]}."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1674
#, no-wrap
msgid "map-char-table function char-table"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1682
msgid ""
"This function calls its argument @var{function} for each element of "
"@var{char-table} that has a non-@code{nil} value.  The call to "
"@var{function} is with two arguments, a key and a value.  The key is a "
"possible @var{range} argument for @code{char-table-range}---either a valid "
"character or a cons cell @code{(@var{from} . @var{to})}, specifying a range "
"of characters that share the same value.  The value is what "
"@code{(char-table-range @var{char-table} @var{key})} returns."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1685
msgid ""
"Overall, the key-value pairs passed to @var{function} describe all the "
"values stored in @var{char-table}."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1689
msgid ""
"The return value is always @code{nil}; to make calls to "
"@code{map-char-table} useful, @var{function} should have side effects.  For "
"example, here is how to examine the elements of the syntax table:"
msgstr ""

#. type: example
#: original_texis/sequences.texi:1707
#, no-wrap
msgid ""
"(let (accumulator)\n"
"   (map-char-table\n"
"    (lambda (key value)\n"
"      (setq accumulator\n"
"            (cons (list\n"
"                   (if (consp key)\n"
"                       (list (car key) (cdr key))\n"
"                     key)\n"
"                   value)\n"
"                  accumulator)))\n"
"    (syntax-table))\n"
"   accumulator)\n"
"@result{}\n"
"(((2597602 4194303) (2)) ((2597523 2597601) (3))\n"
" ... (65379 (5 . 65378)) (65378 (4 . 65379)) (65377 (1))\n"
" ... (12 (0)) (11 (3)) (10 (12)) (9 (0)) ((0 8) (3)))\n"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:1711 original_texis/sequences.texi:1712
#, no-wrap
msgid "Bool-vectors"
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:1720
msgid ""
"A bool-vector is much like a vector, except that it stores only the values "
"@code{t} and @code{nil}.  If you try to store any non-@code{nil} value into "
"an element of the bool-vector, the effect is to store @code{t} there.  As "
"with all arrays, bool-vector indices start from 0, and the length cannot be "
"changed once the bool-vector is created.  Bool-vectors are constants when "
"evaluated."
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:1724
msgid ""
"Several functions work specifically with bool-vectors; aside from that, you "
"manipulate them with same functions used for other kinds of arrays."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1725
#, no-wrap
msgid "make-bool-vector length initial"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1728
msgid ""
"Return a new bool-vector of @var{length} elements, each one initialized to "
"@var{initial}."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1730
#, no-wrap
msgid "bool-vector &rest objects"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1733
msgid ""
"This function creates and returns a bool-vector whose elements are the "
"arguments, @var{objects}."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1735
#, no-wrap
msgid "bool-vector-p object"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1738
msgid ""
"This returns @code{t} if @var{object} is a bool-vector, and @code{nil} "
"otherwise."
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:1741
msgid "There are also some bool-vector set operation functions, described below:"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1742
#, no-wrap
msgid "bool-vector-exclusive-or a b &optional c"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1746
msgid ""
"Return @dfn{bitwise exclusive or} of bool vectors @var{a} and @var{b}.  If "
"optional argument @var{c} is given, the result of this operation is stored "
"into @var{c}.  All arguments should be bool vectors of the same length."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1748
#, no-wrap
msgid "bool-vector-union a b &optional c"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1752
msgid ""
"Return @dfn{bitwise or} of bool vectors @var{a} and @var{b}.  If optional "
"argument @var{c} is given, the result of this operation is stored into "
"@var{c}.  All arguments should be bool vectors of the same length."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1754
#, no-wrap
msgid "bool-vector-intersection a b &optional c"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1758
msgid ""
"Return @dfn{bitwise and} of bool vectors @var{a} and @var{b}.  If optional "
"argument @var{c} is given, the result of this operation is stored into "
"@var{c}.  All arguments should be bool vectors of the same length."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1760
#, no-wrap
msgid "bool-vector-set-difference a b &optional c"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1764
msgid ""
"Return @dfn{set difference} of bool vectors @var{a} and @var{b}.  If "
"optional argument @var{c} is given, the result of this operation is stored "
"into @var{c}.  All arguments should be bool vectors of the same length."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1766
#, no-wrap
msgid "bool-vector-not a &optional b"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1770
msgid ""
"Return @dfn{set complement} of bool vector @var{a}.  If optional argument "
"@var{b} is given, the result of this operation is stored into @var{b}.  All "
"arguments should be bool vectors of the same length."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1772
#, no-wrap
msgid "bool-vector-subsetp a b"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1776
msgid ""
"Return @code{t} if every @code{t} value in @var{a} is also @code{t} in "
"@var{b}, @code{nil} otherwise.  All arguments should be bool vectors of the "
"same length."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1778
#, no-wrap
msgid "bool-vector-count-consecutive a b i"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1782
msgid ""
"Return the number of consecutive elements in @var{a} equal @var{b} starting "
"at @var{i}.  @code{a} is a bool vector, @var{b} is @code{t} or @code{nil}, "
"and @var{i} is an index into @code{a}."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1784
#, no-wrap
msgid "bool-vector-count-population a"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1786
msgid "Return the number of elements that are @code{t} in bool vector @var{a}."
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:1790
msgid "The printed form represents up to 8 boolean values as a single character:"
msgstr ""

#. type: group
#: original_texis/sequences.texi:1797
#, no-wrap
msgid ""
"(bool-vector t nil t nil)\n"
"     @result{} #&4\"^E\"\n"
"(bool-vector)\n"
"     @result{} #&0\"\"\n"
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:1801
msgid "You can use @code{vconcat} to print a bool-vector like other vectors:"
msgstr ""

#. type: group
#: original_texis/sequences.texi:1806
#, no-wrap
msgid ""
"(vconcat (bool-vector nil t nil t))\n"
"     @result{} [nil t nil t]\n"
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:1811
msgid "Here is another example of creating, examining, and updating a bool-vector:"
msgstr ""

#. type: example
#: original_texis/sequences.texi:1821
#, no-wrap
msgid ""
"(setq bv (make-bool-vector 5 t))\n"
"     @result{} #&5\"^_\"\n"
"(aref bv 1)\n"
"     @result{} t\n"
"(aset bv 3 nil)\n"
"     @result{} nil\n"
"bv\n"
"     @result{} #&5\"^W\"\n"
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:1826
msgid ""
"These results make sense because the binary codes for control-_ and "
"control-W are 11111 and 10111, respectively."
msgstr ""

#. type: section
#: original_texis/sequences.texi:1828
#, no-wrap
msgid "Managing a Fixed-Size Ring of Objects"
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:1830
#, no-wrap
msgid "ring data structure"
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:1835
msgid ""
"A @dfn{ring} is a fixed-size data structure that supports insertion, "
"deletion, rotation, and modulo-indexed reference and traversal.  An "
"efficient ring data structure is implemented by the @code{ring} package.  It "
"provides the functions listed in this section."
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:1840
msgid ""
"Note that several rings in Emacs, like the kill ring and the mark ring, are "
"actually implemented as simple lists, @emph{not} using the @code{ring} "
"package; thus the following functions won't work on them."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1841
#, no-wrap
msgid "make-ring size"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1844
msgid ""
"This returns a new ring capable of holding @var{size} objects.  @var{size} "
"should be an integer."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1846
#, no-wrap
msgid "ring-p object"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1848
msgid "This returns @code{t} if @var{object} is a ring, @code{nil} otherwise."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1850
#, no-wrap
msgid "ring-size ring"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1852
msgid "This returns the maximum capacity of the @var{ring}."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1854
#, no-wrap
msgid "ring-length ring"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1857
msgid ""
"This returns the number of objects that @var{ring} currently contains.  The "
"value will never exceed that returned by @code{ring-size}."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1859
#, no-wrap
msgid "ring-elements ring"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1861
msgid "This returns a list of the objects in @var{ring}, in order, newest first."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1863
#, no-wrap
msgid "ring-copy ring"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1866
msgid ""
"This returns a new ring which is a copy of @var{ring}.  The new ring "
"contains the same (@code{eq}) objects as @var{ring}."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1868
#, no-wrap
msgid "ring-empty-p ring"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1870
msgid "This returns @code{t} if @var{ring} is empty, @code{nil} otherwise."
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:1876
msgid ""
"The newest element in the ring always has index 0.  Higher indices "
"correspond to older elements.  Indices are computed modulo the ring length.  "
"Index @minus{}1 corresponds to the oldest element, @minus{}2 to the "
"next-oldest, and so forth."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1877
#, no-wrap
msgid "ring-ref ring index"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1881
msgid ""
"This returns the object in @var{ring} found at index @var{index}.  "
"@var{index} may be negative or greater than the ring length.  If @var{ring} "
"is empty, @code{ring-ref} signals an error."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1883
#, no-wrap
msgid "ring-insert ring object"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1886
msgid ""
"This inserts @var{object} into @var{ring}, making it the newest element, and "
"returns @var{object}."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1889
msgid ""
"If the ring is full, insertion removes the oldest element to make room for "
"the new element."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1891
#, no-wrap
msgid "ring-remove ring &optional index"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1896
msgid ""
"Remove an object from @var{ring}, and return that object.  The argument "
"@var{index} specifies which item to remove; if it is @code{nil}, that means "
"to remove the oldest item.  If @var{ring} is empty, @code{ring-remove} "
"signals an error."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1898
#, no-wrap
msgid "ring-insert-at-beginning ring object"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1901
msgid ""
"This inserts @var{object} into @var{ring}, treating it as the oldest "
"element.  The return value is not significant."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1904
msgid ""
"If the ring is full, this function removes the newest element to make room "
"for the inserted element."
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1906
#, no-wrap
msgid "ring-resize ring size"
msgstr ""

#. type: defun
#: original_texis/sequences.texi:1909
msgid ""
"Set the size of @var{ring} to @var{size}.  If the new size is smaller, then "
"the oldest items in the ring are discarded."
msgstr ""

#. type: cindex
#: original_texis/sequences.texi:1911
#, no-wrap
msgid "fifo data structure"
msgstr ""

#. type: Plain text
#: original_texis/sequences.texi:1914
msgid ""
"If you are careful not to exceed the ring size, you can use the ring as a "
"first-in-first-out queue.  For example:"
msgstr ""

#. type: lisp
#: original_texis/sequences.texi:1923
#, no-wrap
msgid ""
"(let ((fifo (make-ring 5)))\n"
"  (mapc (lambda (obj) (ring-insert fifo obj))\n"
"        '(0 one \"two\"))\n"
"  (list (ring-remove fifo) t\n"
"        (ring-remove fifo) t\n"
"        (ring-remove fifo)))\n"
"     @result{} (0 t one t \"two\")\n"
msgstr ""
