# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2019-10-14 22:48+0900\n"
"PO-Revision-Date: 2019-10-27 15:41+0900\n"
"Last-Translator: Takeshi Ayanokoji <takeshi.ayanokoji@gmail.com>\n"
"Language-Team: Japanese <takeshi.ayanokoji@gmail.com>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: original_texis/loading.texi:6 original_texis/loading.texi:7
#, no-wrap
msgid "Loading"
msgstr "Loading"

#. type: cindex
#: original_texis/loading.texi:8
#, no-wrap
msgid "loading"
msgstr "loading"

#. type: cindex
#: original_texis/loading.texi:9
#, no-wrap
msgid "library"
msgstr "library"

#. type: cindex
#: original_texis/loading.texi:10
#, no-wrap
msgid "Lisp library"
msgstr "Lisp library"

#. type: Plain text
#: original_texis/loading.texi:16
msgid "Loading a file of Lisp code means bringing its contents into the Lisp environment in the form of Lisp objects.  Emacs finds and opens the file, reads the text, evaluates each form, and then closes the file.  Such a file is also called a @dfn{Lisp library}."
msgstr "Lispコードのファイルをロードすることは、その内容をLispオブジェクト形式でLisp環境に取り込むことを意味します。Emacsはファイルを探してオープンして、テキストを読み込んで各フォームを評価してから、そのファイルをクローズします。そのようなファイルは@dfn{Lispライブラリー(Lisp library)}とも呼ばれます。"

#. type: Plain text
#: original_texis/loading.texi:22
msgid "The load functions evaluate all the expressions in a file just as the @code{eval-buffer} function evaluates all the expressions in a buffer.  The difference is that the load functions read and evaluate the text in the file as found on disk, not the text in an Emacs buffer."
msgstr "@code{eval-buffer}関数がバッファー内のすべての式を評価するのと同様に、load関数はファイル内のすべての式を評価します。異なるのはEmacsバッファー内のテキストではなく、load関数はディスク上で見つかったファイル内のテキストを読み込んで評価することです。"

#. type: cindex
#: original_texis/loading.texi:23
#, no-wrap
msgid "top-level form"
msgstr "top-level form"

#. type: Plain text
#: original_texis/loading.texi:31
msgid "The loaded file must contain Lisp expressions, either as source code or as byte-compiled code.  Each form in the file is called a @dfn{top-level form}.  There is no special format for the forms in a loadable file; any form in a file may equally well be typed directly into a buffer and evaluated there.  (Indeed, most code is tested this way.)  Most often, the forms are function definitions and variable definitions."
msgstr "ロードされたファイルは、ソースコードかバイトコンパイルされたコードとしてLisp式を含んでいなければなりません。このファイル内の各フォームは@dfn{トップレベルフォーム(top-level form)}と呼ばれます。ロード可能なファイル内のフォームにたいする特別なフォーマットはありません。ファイル内のフォームはどれも同じように直接バッファーにタイプされて、そこで評価されるでしょう(実際ほとんどのコードはこの方法でテストされる)。多くの場合はそのフォームは関数定義と変数定義です。"

#. type: Plain text
#: original_texis/loading.texi:38
msgid "Emacs can also load compiled dynamic modules: shared libraries that provide additional functionality for use in Emacs Lisp programs, just like a package written in Emacs Lisp would.  When a dynamic module is loaded, Emacs calls a specially-named initialization function which the module needs to implement, and which exposes the additional functions and variables to Emacs Lisp programs."
msgstr "Emacsはコンパイルされたダイナミックモジュールも同様にロードできます。これはEmacs Lispプログラム内で、Emacs Lispで記述されたパッケージと同様に使用するための、追加機能を提供する共有ライブラリーです。ダイナミックモジュールのロード時に、Emacsはそのモジュールが実装する必要がある特殊な名前の初期化関数を呼び出して、Emacs Lispプログラムに追加の関数と変数を公開します。"

#. type: Plain text
#: original_texis/loading.texi:41
msgid "For on-demand loading of external libraries which are known in advance to be required by certain Emacs primitives, @pxref{Dynamic Libraries}."
msgstr "特定のEmacsプリミティブで必要となるとあらかじめ判明している外部ライブラリーのオンデマンドローディングについては、@ref{Dynamic Libraries}を参照してください。"

#. type: section
#: original_texis/loading.texi:55 original_texis/loading.texi:57
#: original_texis/loading.texi:58
#, no-wrap
msgid "How Programs Do Loading"
msgstr "How Programs Do Loading"

#. type: menuentry
#: original_texis/loading.texi:55
msgid "The @code{load} function and others."
msgstr "@code{load}関数、その他。"

#. type: section
#: original_texis/loading.texi:55 original_texis/loading.texi:220
#: original_texis/loading.texi:221
#, no-wrap
msgid "Load Suffixes"
msgstr "Load Suffixes"

#. type: menuentry
#: original_texis/loading.texi:55
msgid "Details about the suffixes that @code{load} tries."
msgstr "@code{load}が試みられるサフィックスについての詳細。"

#. type: section
#: original_texis/loading.texi:55 original_texis/loading.texi:272
#: original_texis/loading.texi:273
#, no-wrap
msgid "Library Search"
msgstr "Library Search"

#. type: menuentry
#: original_texis/loading.texi:55
msgid "Finding a library to load."
msgstr "ロードするライブラリーの検索。"

#. type: node
#: original_texis/loading.texi:55 original_texis/loading.texi:433
#, no-wrap
msgid "Loading Non-ASCII"
msgstr "Loading Non-ASCII"

#. type: menuentry
#: original_texis/loading.texi:55
msgid "Non-@acronym{ASCII} characters in Emacs Lisp files."
msgstr "Emacs Lispファイル内の非@acronym{ASCII}文字。"

#. type: section
#: original_texis/loading.texi:55 original_texis/loading.texi:459
#: original_texis/loading.texi:460
#, no-wrap
msgid "Autoload"
msgstr "Autoload"

#. type: menuentry
#: original_texis/loading.texi:55
msgid "Setting up a function to autoload."
msgstr "オートロードのための関数のセットアップ。"

#. type: section
#: original_texis/loading.texi:55 original_texis/loading.texi:702
#: original_texis/loading.texi:703
#, no-wrap
msgid "Repeated Loading"
msgstr "Repeated Loading"

#. type: menuentry
#: original_texis/loading.texi:55
msgid "Precautions about loading a file twice."
msgstr "ファイルを2度ロードする場合の配慮。"

#. type: node
#: original_texis/loading.texi:55 original_texis/loading.texi:756
#, no-wrap
msgid "Named Features"
msgstr "Named Features"

#. type: menuentry
#: original_texis/loading.texi:55
msgid "Loading a library if it isn't already loaded."
msgstr "まだロードされていないライブラリーのロード。"

#. type: node
#: original_texis/loading.texi:55 original_texis/loading.texi:923
#, no-wrap
msgid "Where Defined"
msgstr "Where Defined"

#. type: menuentry
#: original_texis/loading.texi:55
msgid "Finding which file defined a certain symbol."
msgstr "特定のシンボルがどのファイルで定義されているかの検索。"

#. type: section
#: original_texis/loading.texi:55 original_texis/loading.texi:988
#: original_texis/loading.texi:989
#, no-wrap
msgid "Unloading"
msgstr "Unloading"

#. type: menuentry
#: original_texis/loading.texi:55
msgid "How to unload a library that was loaded."
msgstr "ロードされたライブラリーをunloadする方法。"

#. type: section
#: original_texis/loading.texi:55 original_texis/loading.texi:1042
#: original_texis/loading.texi:1043
#, no-wrap
msgid "Hooks for Loading"
msgstr "Hooks for Loading"

#. type: menuentry
#: original_texis/loading.texi:55
msgid "Providing code to be run when particular libraries are loaded."
msgstr "特定のライブラリーがロードされたとき実行されるコードの提供。"

#. type: node
#: original_texis/loading.texi:55 original_texis/loading.texi:1099
#, no-wrap
msgid "Dynamic Modules"
msgstr "Dynamic Modules"

#. type: menuentry
#: original_texis/loading.texi:55
msgid "Modules provide additional Lisp primitives."
msgstr "追加のLispプリミティブを提供するモジュール。"

#. type: Plain text
#: original_texis/loading.texi:66
msgid "Emacs Lisp has several interfaces for loading.  For example, @code{autoload} creates a placeholder object for a function defined in a file; trying to call the autoloading function loads the file to get the function's real definition (@pxref{Autoload}).  @code{require} loads a file if it isn't already loaded (@pxref{Named Features}).  Ultimately, all these facilities call the @code{load} function to do the work."
msgstr "Emacs Lispにはロードのためのインターフェイスがいくつかあります。たとえば@code{autoload}はファイル内で定義された関数にたいしてプレースホルダーとなるオブジェクトを作成します。この関数はオートロードされる関数を呼び出すために、ファイルからその関数の実際の定義の取得を試みます(@ref{Autoload}を参照)。@code{require}はファイルがまだロードされていない場合にファイルをロードします(@ref{Named Features}を参照)。これらすべての関数は処理を行うために最終的に@code{load}を呼び出します。"

#. type: defun
#: original_texis/loading.texi:67
#, no-wrap
msgid "load filename &optional missing-ok nomessage nosuffix must-suffix"
msgstr "load filename &optional missing-ok nomessage nosuffix must-suffix"

#. type: defun
#: original_texis/loading.texi:70
msgid "This function finds and opens a file of Lisp code, evaluates all the forms in it, and closes the file."
msgstr "この関数はLispコードのファイルを見つけてオープンして、その中のすべてのフォームを評価してそのファイルをクローズする。"

#. type: defun
#: original_texis/loading.texi:85
msgid "To find the file, @code{load} first looks for a file named @file{@var{filename}.elc}, that is, for a file whose name is @var{filename} with the extension @samp{.elc} appended.  If such a file exists, it is loaded.  If there is no file by that name, then @code{load} looks for a file named @file{@var{filename}.el}.  If that file exists, it is loaded.  If Emacs was compiled with support for dynamic modules (@pxref{Dynamic Modules}), @code{load} next looks for a file named @file{@var{filename}.@var{ext}}, where @var{ext} is a system-dependent file-name extension of shared libraries.  Finally, if neither of those names is found, @code{load} looks for a file named @var{filename} with nothing appended, and loads it if it exists.  (The @code{load} function is not clever about looking at @var{filename}.  In the perverse case of a file named @file{foo.el.el}, evaluation of @code{(load \"foo.el\")} will indeed find it.)"
msgstr "@code{load}はまずファイルを見つけるために、@file{@var{filename}.elc}という名前、つまり@var{filename}に拡張子@samp{.elc}を足した名前のファイルを探す。このようなファイルが存在したらそれをロードする。Emacsがダイナミックモジュール(@ref{Dynamic Modules}を参照)のサポートつきでコンパイルされていれば、、次に@code{load}は@file{@var{filename}.@var{ext}}という名前のファイルを探す。ここで@var{ext}は共有ライブラリーのシステム依存のファイル名拡張子である。その名前のファイルが存在しなければ、@code{load}は@file{@var{filename}.el}という名前のファイルを探す。このファイルが存在したらそれをロードする。最後に、もしこれらの名前がいずれも見つからなければ、@code{load}は何も付け足さない@var{filename}という名前のファイルを探してそれが存在したらロードする(@code{load}関数に@var{filename}を認識する賢さはない。@file{foo.el.el}のような正しくない名前のファイルでも、@code{(load \"foo.el\")}を評価してそれを見つけてしまうだろう)。"

#. type: defun
#: original_texis/loading.texi:93
msgid "If Auto Compression mode is enabled, as it is by default, then if @code{load} can not find a file, it searches for a compressed version of the file before trying other file names.  It decompresses and loads it if it exists.  It looks for compressed versions by appending each of the suffixes in @code{jka-compr-load-suffixes} to the file name.  The value of this variable must be a list of strings.  Its standard value is @code{(\".gz\")}."
msgstr "Auto Compressionモードが有効(残念ながらデフォルトでは有効)なら、@code{load}は他のファイル名を試みる前に圧縮されたバージョンのファイル名を探すのでファイルを見つけることができない。圧縮されたファイルが存在したら、それを解凍してロードする。@code{load}はファイル名に@code{jka-compr-load-suffixes}内の各サフィックスを足して圧縮されたバージョンを探す。この変数の値は文字列のリストでなければならない。標準的な値は@code{(\".gz\")}。"

#. type: defun
#: original_texis/loading.texi:102
msgid "If the optional argument @var{nosuffix} is non-@code{nil}, then @code{load} does not try the suffixes @samp{.elc} and @samp{.el}.  In this case, you must specify the precise file name you want, except that, if Auto Compression mode is enabled, @code{load} will still use @code{jka-compr-load-suffixes} to find compressed versions.  By specifying the precise file name and using @code{t} for @var{nosuffix}, you can prevent file names like @file{foo.el.el} from being tried."
msgstr "オプション引数@var{nosuffix}が非@code{nil}なら、@code{load}はサフィックス@samp{.elc}と@samp{.el}のロードを試みない。この場合はロードしたいファイルの正確な名前を指定しなければならない。ただしAuto Compressionモードが有効なら@code{load}は圧縮されたバージョンを探すために、@code{jka-compr-load-suffixes}を使用する。正確なファイル名を指定して、@var{nosuffix}に@code{t}を使用することにより、@file{foo.el.el}のような名前のファイルにたいするロードの試みを抑止できる。"

#. type: defun
#: original_texis/loading.texi:108
msgid "If the optional argument @var{must-suffix} is non-@code{nil}, then @code{load} insists that the file name used must end in either @samp{.el} or @samp{.elc} (possibly extended with a compression suffix) or the shared-library extension, unless it contains an explicit directory name."
msgstr "オプション引数@var{must-suffix}が非@code{nil}の場合、ロードに使用されるファイルの名前に明示的にディレクトリー名が含まれていなければ、@code{load}はファイル名が@samp{.el}か@samp{.elc}、または共有ライブラリーの拡張子で終わること(もしかしたら圧縮による拡張子が付加されているかもしれない)を要求する。"

#. type: defun
#: original_texis/loading.texi:112
msgid "If the option @code{load-prefer-newer} is non-@code{nil}, then when searching suffixes, @code{load} selects whichever version of a file (@samp{.elc}, @samp{.el}, etc.)@: has been modified most recently."
msgstr "オプション@code{load-prefer-newer}が非@code{nil}なら、@code{load}はサフィックスを検索するとき、どんなファイル(@samp{.elc}、@samp{.el}等)であっても、もっとも最近変更されたファイルのバージョンを選択する。"

#. type: defun
#: original_texis/loading.texi:122
msgid "If @var{filename} is a relative file name, such as @file{foo} or @file{baz/foo.bar}, @code{load} searches for the file using the variable @code{load-path}.  It appends @var{filename} to each of the directories listed in @code{load-path}, and loads the first file it finds whose name matches.  The current default directory is tried only if it is specified in @code{load-path}, where @code{nil} stands for the default directory.  @code{load} tries all three possible suffixes in the first directory in @code{load-path}, then all three suffixes in the second directory, and so on.  @xref{Library Search}."
msgstr "@var{filename}が@file{foo}や@file{baz/foo.bar}のような相対ファイル名なら、@code{load}は変数@code{load-path}を使用してそのファイルを探す。これは@code{load-path}内にリストされた各ディレクトリーに@var{filename}を追加して、最初に見つかった名前のマッチするファイルをロードする。デフォルトディレクトリーを意味する@code{nil}が@code{load-path}で措定されたときだけ、カレントデフォルトディレクトリーを試みる。@code{load}は@code{load-path}内の最初のディレクトリーで利用可能な3つのサフィックスすべてを試行してから、2つ目のディレクトリーで3つのサフィックスすべてを試行する、...というようにファイルを探す。@ref{Library Search}を参照のこと。"

#. type: defun
#: original_texis/loading.texi:126
msgid "Whatever the name under which the file is eventually found, and the directory where Emacs found it, Emacs sets the value of the variable @code{load-file-name} to that file's name."
msgstr "最終的に見つかったファイル、およびEmacsがそのファイルを見つけたディレクトリーが何であれ、Emacsはそのファイル名を変数@code{load-file-name}の値にセットする。"

#. type: defun
#: original_texis/loading.texi:130
msgid "If you get a warning that @file{foo.elc} is older than @file{foo.el}, it means you should consider recompiling @file{foo.el}.  @xref{Byte Compilation}."
msgstr "@file{foo.elc}が@file{foo.el}より古いと警告されたら、それは@file{foo.el}のリコンパイルを考慮すべきことを意味する。@ref{Byte Compilation}を参照のこと。"

#. type: defun
#: original_texis/loading.texi:134
msgid "When loading a source file (not compiled), @code{load} performs character set translation just as Emacs would do when visiting the file.  @xref{Coding Systems}."
msgstr "(コンパイルされていない)ソースファイルをロードしたとき、Emacsがファイルをvisitしたときと同じように@code{load}は文字セットの変換を行う。@ref{Coding Systems}を参照のこと。"

#. type: cindex
#: original_texis/loading.texi:137
#, no-wrap
msgid "eager macro expansion"
msgstr "eager macro expansion"

#. type: defun
#: original_texis/loading.texi:153
msgid "When loading an uncompiled file, Emacs tries to expand any macros that the file contains (@pxref{Macros}).  We refer to this as @dfn{eager macro expansion}.  Doing this (rather than deferring the expansion until the relevant code runs) can significantly speed up the execution of uncompiled code.  Sometimes, this macro expansion cannot be done, owing to a cyclic dependency.  In the simplest example of this, the file you are loading refers to a macro defined in another file, and that file in turn requires the file you are loading.  This is generally harmless.  Emacs prints a warning (@samp{Eager macro-expansion skipped due to cycle@dots{}})  giving details of the problem, but it still loads the file, just leaving the macro unexpanded for now.  You may wish to restructure your code so that this does not happen.  Loading a compiled file does not cause macroexpansion, because this should already have happened during compilation.  @xref{Compiling Macros}."
msgstr "コンパイルされていないファイルをロードするとき、Emacsはそのファイルに含まれるすべてのマクロ(@ref{Macros}を参照)を展開する。わたしたちはこれを@dfn{eagerマクロ展開(eager macro expansion)}と呼んでいる。(関連するコードを実行するまで展開を延期しないで)これを行うことにより、コンパイルされていないコードの実行スピードが明らかに向上する。循環参照によりこのマクロ展開を行うことができないときもある。これの一番簡単な例は、ロードしようとしているファイルが他のファイルで定義されているマクロを参照しているが、そのファイルはロードしようとしているファイルを必要としている場合である。これは一般的には無害である。Emacsは問題の詳細を与えるために警告(@samp{Eager macro-expansion skipped due to cycle@dots{}})をプリントするが、単にその時点ではマクロを展開せずにそのファイルをロードする。あなたはこの問題が発生しないようにコードをリストラクチャーしたいと思うかもしれない。コンパイル済みファイルではマクロ展開はコンパイル時に行われるので、ロード時のマクロ展開は行われない。@ref{Compiling Macros}を参照のこと。"

#. type: defun
#: original_texis/loading.texi:157
msgid "Messages like @samp{Loading foo...} and @samp{Loading foo...done} appear in the echo area during loading unless @var{nomessage} is non-@code{nil}."
msgstr "@var{nomessage}が非@code{nil}でなければ、エコーエリアに@samp{Loading foo...}や@samp{Loading foo...done}のようなメッセージがロードの間に表示される。"

#. type: cindex
#: original_texis/loading.texi:158
#, no-wrap
msgid "load errors"
msgstr "load errors"

#. type: defun
#: original_texis/loading.texi:162
msgid "Any unhandled errors while loading a file terminate loading.  If the load was done for the sake of @code{autoload}, any function definitions made during the loading are undone."
msgstr "ファイルをロードする間のハンドルされないエラーはロードを終了させる。@code{autoload}のためのロードの場合、ロードの間に定義された任意の関数定義は元に戻される。"

#. type: kindex
#: original_texis/loading.texi:163
#, no-wrap
msgid "file-error"
msgstr "file-error"

#. type: defun
#: original_texis/loading.texi:168
msgid "If @code{load} can't find the file to load, then normally it signals the error @code{file-error} (with @samp{Cannot open load file @var{filename}}).  But if @var{missing-ok} is non-@code{nil}, then @code{load} just returns @code{nil}."
msgstr "@code{load}がロードするファイルを見つけられいと、通常は(@samp{Cannot open load file @var{filename}}メッセージとともに)エラー@code{file-error}がシグナルされる。しかし@var{missing-ok}が非@code{nil}なら、@code{load}は単に@code{nil}をリターンする。"

#. type: defun
#: original_texis/loading.texi:172
msgid "You can use the variable @code{load-read-function} to specify a function for @code{load} to use instead of @code{read} for reading expressions.  See below."
msgstr "式の読み取りにたいして@code{load}が@code{read}のかわりに使用する関数を指定するために、変数@code{load-read-function}を使用できる。以下を参照されたい。"

#. type: defun
#: original_texis/loading.texi:174
msgid "@code{load} returns @code{t} if the file loads successfully."
msgstr "ファイルが正常にロードされたら、@code{load}は@code{t}をリターンする。"

#. type: deffn
#: original_texis/loading.texi:176
#, no-wrap
msgid "Command load-file filename"
msgstr "Command load-file filename"

#. type: deffn
#: original_texis/loading.texi:183
msgid "This command loads the file @var{filename}.  If @var{filename} is a relative file name, then the current default directory is assumed.  This command does not use @code{load-path}, and does not append suffixes.  However, it does look for compressed versions (if Auto Compression Mode is enabled).  Use this command if you wish to specify precisely the file name to load."
msgstr "このコマンドはファイル@var{filename}をロードする。@var{filename}が相対ファイル名のなら、それはカレントデフォルトディレクトリーを指定したとみなされる。このコマンドは@code{load-path}を使用せず、サフィックスの追加もしない。しかし(Auto Compressionモードが有効なら)圧縮されたバージョンの検索を行う。ロードするファイル名を正確に指定したければ、このコマンドを使用すること。"

#. type: deffn
#: original_texis/loading.texi:185
#, no-wrap
msgid "Command load-library library"
msgstr "Command load-library library"

#. type: deffn
#: original_texis/loading.texi:189
msgid "This command loads the library named @var{library}.  It is equivalent to @code{load}, except for the way it reads its argument interactively.  @xref{Lisp Libraries,,,emacs, The GNU Emacs Manual}."
msgstr "このコマンドは@var{library}という名前のライブラリーをロードする。このコマンドは引数を読み取る方法がインタラクティブであることを除き@code{load}と同じ。@ref{Lisp Libraries,,,emacs, The GNU Emacs Manual}を参照のこと。"

#. type: defvar
#: original_texis/loading.texi:191
#, no-wrap
msgid "load-in-progress"
msgstr "load-in-progress"

#. type: defvar
#: original_texis/loading.texi:194
msgid "This variable is non-@code{nil} if Emacs is in the process of loading a file, and it is @code{nil} otherwise."
msgstr "この変数はEmacsがファイルをロード中なら非@code{nil}、それ以外は@code{nil}である。"

#. type: defvar
#: original_texis/loading.texi:196
#, no-wrap
msgid "load-file-name"
msgstr "load-file-name"

#. type: defvar
#: original_texis/loading.texi:200
msgid "When Emacs is in the process of loading a file, this variable's value is the name of that file, as Emacs found it during the search described earlier in this section."
msgstr "このセクションの最初に説明した検索でEmacsがファイルを見つけて、そのファイルをロード中のとき、この変数の値はそのファイルの名前である。"

#. type: defvar
#: original_texis/loading.texi:202
#, no-wrap
msgid "load-read-function"
msgstr "load-read-function"

#. type: anchor{#1}
#: original_texis/loading.texi:208
msgid "Definition of load-read-function"
msgstr "Definition of load-read-function"

#. type: defvar
#: original_texis/loading.texi:208
msgid "This variable specifies an alternate expression-reading function for @code{load} and @code{eval-region} to use instead of @code{read}.  The function should accept one argument, just as @code{read} does."
msgstr "この変数は@code{load}と@code{eval-region}が式を読み取るために、@code{read}のかわりに使用する関数を指定する。指定する関数は@code{read}と同様、引数が1つの関数であること。"

#. type: defvar
#: original_texis/loading.texi:211
msgid "By default, this variable's value is @code{read}.  @xref{Input Functions}."
msgstr "デフォルトではこの変数の値は@code{read}。@ref{Input Functions}を参照のこと。"

#. type: defvar
#: original_texis/loading.texi:215
msgid "Instead of using this variable, it is cleaner to use another, newer feature: to pass the function as the @var{read-function} argument to @code{eval-region}.  @xref{Definition of eval-region,, Eval}."
msgstr "この変数を使用するかわりに別の新たな方法を使用するほうが明確である。それは@code{eval-region}の@var{read-function}引数にその関数を渡す方法である。@ref{Definition of eval-region,, Eval}を参照のこと。"

#. type: Plain text
#: original_texis/loading.texi:219
msgid "For information about how @code{load} is used in building Emacs, see @ref{Building Emacs}."
msgstr "Emacsのビルドで@code{load}がどのように使用されているかについての情報は、@ref{Building Emacs}を参照のこと。"

#. type: Plain text
#: original_texis/loading.texi:224
msgid "We now describe some technical details about the exact suffixes that @code{load} tries."
msgstr "ここでは@code{load}が試行するサフィックスについて、技術的な詳細を説明します。"

#. type: defvar
#: original_texis/loading.texi:225
#, no-wrap
msgid "load-suffixes"
msgstr "load-suffixes"

#. type: defvar
#: original_texis/loading.texi:231
msgid "This is a list of suffixes indicating (compiled or source) Emacs Lisp files.  It should not include the empty string.  @code{load} uses these suffixes in order when it appends Lisp suffixes to the specified file name.  The standard value is @code{(\".elc\" \".el\")} which produces the behavior described in the previous section."
msgstr "これは(ソースまたはコンパイル済みの)Emacs Lispファイルを示すサフィックスのリストである。空の文字列が含まないこと。@code{load}は指定されたファイル名にLispファイルのサフィックスを追加するときに、これらのサフィックスを使用する。標準的な値は@code{(\".elc\" \".el\")}で、これは前のセクションで説明した振る舞いとなる。"

#. type: defvar
#: original_texis/loading.texi:233
#, no-wrap
msgid "load-file-rep-suffixes"
msgstr "load-file-rep-suffixes"

#. type: defvar
#: original_texis/loading.texi:238
msgid "This is a list of suffixes that indicate representations of the same file.  This list should normally start with the empty string.  When @code{load} searches for a file it appends the suffixes in this list, in order, to the file name, before searching for another file."
msgstr "これは同じファイルにたいして異なる表現を示すサフィックスのリストである。このリストは空の文字列から開始されること。@code{load}はファイルを検索するときは、他のファイルを検索する前にこのリストのサフィックスを順番にファイル名に追加する。"

#. type: defvar
#: original_texis/loading.texi:247
msgid "Enabling Auto Compression mode appends the suffixes in @code{jka-compr-load-suffixes} to this list and disabling Auto Compression mode removes them again.  The standard value of @code{load-file-rep-suffixes} if Auto Compression mode is disabled is @code{(\"\")}.  Given that the standard value of @code{jka-compr-load-suffixes} is @code{(\".gz\")}, the standard value of @code{load-file-rep-suffixes} if Auto Compression mode is enabled is @code{(\"\" \".gz\")}."
msgstr "Auto Compressionモードを有効にすることにより@code{jka-compr-load-suffixes}のサフィックスがこのリストに追加され、無効にすると再びリストから取り除かれる。@code{load-file-rep-suffixes}の標準的な値は、Auto Compressionモードが無効なら@code{(\"\")}。@code{jka-compr-load-suffixes}の標準的な値が@code{(\".gz\")}であることを考慮すると、Auto Compressionモードが有効な場合の@code{load-file-rep-suffixes}の標準的な値は@code{(\"\" \".gz\")}である。"

#. type: defun
#: original_texis/loading.texi:249
#, no-wrap
msgid "get-load-suffixes"
msgstr "get-load-suffixes"

#. type: defun
#: original_texis/loading.texi:258
msgid "This function returns the list of all suffixes that @code{load} should try, in order, when its @var{must-suffix} argument is non-@code{nil}.  This takes both @code{load-suffixes} and @code{load-file-rep-suffixes} into account.  If @code{load-suffixes}, @code{jka-compr-load-suffixes} and @code{load-file-rep-suffixes} all have their standard values, this function returns @code{(\".elc\" \".elc.gz\" \".el\" \".el.gz\")} if Auto Compression mode is enabled and @code{(\".elc\" \".el\")} if Auto Compression mode is disabled."
msgstr "この関数は@var{must-suffix}引数が非@code{nil}のときは、@code{load}が試みるべきすべてのサフィックスを順番にしたがったリストでリターンする。この関数は@code{load-suffixes}と@code{load-file-rep-suffixes}の両方を考慮する。@code{load-suffixes}、@code{jka-compr-load-suffixes}、@code{load-file-rep-suffixes}がすべて標準的な値の場合、この関数はAuto Compressionモードが有効なら@code{(\".elc\" \".elc.gz\" \".el\" \".el.gz\")}、無効なら@code{(\".elc\" \".el\")}をリターンする。"

#. type: Plain text
#: original_texis/loading.texi:265
msgid "To summarize, @code{load} normally first tries the suffixes in the value of @code{(get-load-suffixes)} and then those in @code{load-file-rep-suffixes}.  If @var{nosuffix} is non-@code{nil}, it skips the former group, and if @var{must-suffix} is non-@code{nil}, it skips the latter group."
msgstr "まとめると、@code{load}は通常まず@code{(get-load-suffixes)}の値のサフィックスを試み、次に@code{load-file-rep-suffixes}を試みる。@var{nosuffix}が非@code{nil}なら前者がスキップされ、@var{must-suffix}が非@code{nil}なら後者がスキップされる。"

#. type: defopt
#: original_texis/loading.texi:266
#, no-wrap
msgid "load-prefer-newer"
msgstr "load-prefer-newer"

#. type: defopt
#: original_texis/loading.texi:270
msgid "If this option is non-@code{nil}, then rather than stopping at the first suffix that exists, @code{load} tests them all, and uses whichever file is the newest."
msgstr "このオプションが非@code{nil}なら、ファイルが見つかった最初のサフィックスで停止せずに、@code{load}はすべてのサフィックスをテストして、一番新しいファイルを使用する。"

#. type: cindex
#: original_texis/loading.texi:274
#, no-wrap
msgid "library search"
msgstr "library search"

#. type: cindex
#: original_texis/loading.texi:275
#, no-wrap
msgid "find library"
msgstr "find library"

#. type: Plain text
#: original_texis/loading.texi:279
msgid "When Emacs loads a Lisp library, it searches for the library in a list of directories specified by the variable @code{load-path}."
msgstr "EmacsがLispライブラリーをロードするときは、変数@code{load-path}により指定されるディレクトリー内のライブラリーを検索します。"

#. type: defvar
#: original_texis/loading.texi:280
#, no-wrap
msgid "load-path"
msgstr "load-path"

#. type: defvar
#: original_texis/loading.texi:285
msgid "The value of this variable is a list of directories to search when loading files with @code{load}.  Each element is a string (which must be a directory name) or @code{nil} (which stands for the current working directory)."
msgstr "この変数の値は@code{load}でファイルをロードするときに検索するディレクトリーのリストである。リストの各要素は文字列(ディレクトリー名でなければなりません)、または@code{nil}(カレントワーキングディレクトリーを意味する)である。"

#. type: Plain text
#: original_texis/loading.texi:291
msgid "When Emacs starts up, it sets up the value of @code{load-path} in several steps.  First, it initializes @code{load-path} using default locations set when Emacs was compiled.  Normally, this is a directory something like"
msgstr "Emacsは起動時にいくつかのステップにより@code{load-path}の値をセットアップする。最初にEmacsがコンパイルされたときのデフォルトロケーションセット(default locations set)を使用して、@code{load-path}を初期化する。通常これは以下のようなディレクトリーである"

#. type: example
#: original_texis/loading.texi:294
#, no-wrap
msgid "\"/usr/local/share/emacs/@var{version}/lisp\"\n"
msgstr "\"/usr/local/share/emacs/@var{version}/lisp\"\n"

#. type: Plain text
#: original_texis/loading.texi:300
msgid "(In this and the following examples, replace @file{/usr/local} with the installation prefix appropriate for your Emacs.)  These directories contain the standard Lisp files that come with Emacs.  If Emacs cannot find them, it will not start correctly."
msgstr "(以降の例ではあなたがインストールしたEmacsのインストールプレフィクスに合うように@file{/usr/local}を置き換えること。) これらのディレクトリーには、Emacsとともにインストールされた標準的なLispファイルが含まれる。Emacsがこれらを見つけられなければ正常に起動しないだろう。"

#. type: Plain text
#: original_texis/loading.texi:310
msgid "If you run Emacs from the directory where it was built---that is, an executable that has not been formally installed---Emacs instead initializes @code{load-path} using the @file{lisp} directory in the directory containing the sources from which it was built.  If you built Emacs in a separate directory from the sources, it also adds the lisp directories from the build directory.  (In all cases, elements are represented as absolute file names.)"
msgstr "Emacsをビルドしたディレクトリーから起動した場合 −−− つまり正式にインストールされた実行形式ではないEmacsを起動した場合 ---　、Emacsはビルドされたディレクトリーのソースの@file{lisp}ディレクトリーを使用して@code{load-path}を初期化する。ソースとは別のディレクトリーでEmacsをビルドした場合は、ビルドしたディレクトリーの@file{lisp}ディレクトリーも追加する(いずれも要素は絶対ファイル名になる)。"

#. type: cindex
#: original_texis/loading.texi:311
#, no-wrap
msgid "site-lisp directories"
msgstr "site-lisp directories"

#. type: Plain text
#: original_texis/loading.texi:316
msgid "Unless you start Emacs with the @option{--no-site-lisp} option, it then adds two more @file{site-lisp} directories to the front of @code{load-path}.  These are intended for locally installed Lisp files, and are normally of the form:"
msgstr "@option{--no-site-lisp}オプションでEmacsを起動した場合を除き、@code{load-path}の先頭にさらに2つの@file{site-lisp}を追加する。これらはローカルにインストールされたLispファイルで、通常は:"

#. type: example
#: original_texis/loading.texi:319
#, no-wrap
msgid "\"/usr/local/share/emacs/@var{version}/site-lisp\"\n"
msgstr "\"/usr/local/share/emacs/@var{version}/site-lisp\"\n"

#. type: Plain text
#: original_texis/loading.texi:323
msgid "and"
msgstr "および"

#. type: example
#: original_texis/loading.texi:326
#, no-wrap
msgid "\"/usr/local/share/emacs/site-lisp\"\n"
msgstr "\"/usr/local/share/emacs/site-lisp\"\n"

#. type: Plain text
#: original_texis/loading.texi:335
msgid "The first one is for locally installed files for a specific Emacs version; the second is for locally installed files meant for use with all installed Emacs versions.  (If Emacs is running uninstalled, it also adds @file{site-lisp} directories from the source and build directories, if they exist.  Normally these directories do not contain @file{site-lisp} directories.)"
msgstr "の形式である。1つ目は特定のバージョンのEmacsにたいしてローカルにインストールされたものである。2つ目はインストールされたすべてのバージョンのEmacsが使用することを意図してローカルにインストールされたものである(インストールされたものでないEmacsが実行されると、もし存在すればソースディレクトリーとビルドディレクトリーの@file{site-lisp}ディレクトリーも追加される。これらのディレクトリーは通常は@file{site-lisp}ディレクトリーを含まない)。"

#. type: cindex
#: original_texis/loading.texi:336
#, no-wrap
msgid "@env{EMACSLOADPATH} environment variable"
msgstr "@env{EMACSLOADPATH} environment variable"

#. type: Plain text
#: original_texis/loading.texi:340
msgid "If the environment variable @env{EMACSLOADPATH} is set, it modifies the above initialization procedure.  Emacs initializes @code{load-path} based on the value of the environment variable."
msgstr "環境変数@env{EMACSLOADPATH}がセットされていたら、上述の初期化プロセスが変更される。Emacsはこの環境変数の値にもとづいて@code{load-path}を初期化する。"

#. type: Plain text
#: original_texis/loading.texi:344
msgid "The syntax of @env{EMACSLOADPATH} is the same as used for @code{PATH}; directory names are separated by @samp{:} (or @samp{;}, on some operating systems)."
msgstr "@env{EMACSLOADPATH}の構文は、@code{PATH}で使用される構文と同様である。ディレクトリー名は@samp{:}(オペレーティングシステムによっては@samp{;})で区切られる。"

#. type: Plain text
#: original_texis/loading.texi:350
msgid "Here is an example of how to set @env{EMACSLOADPATH} variable (from a @command{sh}-style shell):"
msgstr "以下は(@command{sh}スタイルのシェルから)@env{EMACSLOADPATH}変数をセットする例である:"

#. type: example
#: original_texis/loading.texi:353
#, no-wrap
msgid "export EMACSLOADPATH=/home/foo/.emacs.d/lisp:\n"
msgstr "export EMACSLOADPATH=/home/foo/.emacs.d/lisp:\n"

#. type: Plain text
#: original_texis/loading.texi:364
msgid "An empty element in the value of the environment variable, whether trailing (as in the above example), leading, or embedded, is replaced by the default value of @code{load-path} as determined by the standard initialization procedure.  If there are no such empty elements, then @env{EMACSLOADPATH} specifies the entire @code{load-path}.  You must include either an empty element, or the explicit path to the directory containing the standard Lisp files, else Emacs will not function.  (Another way to modify @code{load-path} is to use the @option{-L} command-line option when starting Emacs; see below.)"
msgstr "環境変数の値内の空の要素は、(上記例のような)末尾、先頭、中間のいずれにあるかに関わらず、標準の初期化処理により決定される@code{load-path}のデフォルト値に置き換えられる。そのような空要素が存在しなければ@env{EMACSLOADPATH}により@code{load-path}全体が指定される。空要素、または標準のLispファイルを含むディレクトリーへの明示的なパスのいずれかを含めなければならない。さもないとEmacsが関数を見つけられなくなる(@code{load-path}を変更する他の方法は、Emacs起動時にコマンドラインオプション@option{-L}を使用する方法である。以下参照)。"

#. type: Plain text
#: original_texis/loading.texi:374
msgid "For each directory in @code{load-path}, Emacs then checks to see if it contains a file @file{subdirs.el}, and if so, loads it.  The @file{subdirs.el} file is created when Emacs is built/installed, and contains code that causes Emacs to add any subdirectories of those directories to @code{load-path}.  Both immediate subdirectories and subdirectories multiple levels down are added.  But it excludes subdirectories whose names do not start with a letter or digit, and subdirectories named @file{RCS} or @file{CVS}, and subdirectories containing a file named @file{.nosearch}."
msgstr "@code{load-path}内の各ディレクトリーにたいして、Emacsはそのディレクトリーがファイル@file{subdirs.el}を含むか確認して、もしあればそれをロードする。@file{subdirs.el}ファイルは、@code{load-path}のディレクトリーにたいして任意のサブディレクトリーを追加するためのコードが含まれており、Emacsがビルド/インストールされたときに作成される。サブディレクトリーと複数階層下のレベルのサブディレクトリーの両方が直接追加される。ただし名前の最初が英数字でないディレクトリー、名前が@file{RCS}または@file{CVS}のディレクトリー、名前が@file{.nosearch}というファイルを含むディレクトリーは除外される。"

#. type: Plain text
#: original_texis/loading.texi:379
msgid "Next, Emacs adds any extra load directories that you specify using the @option{-L} command-line option (@pxref{Action Arguments,,,emacs, The GNU Emacs Manual}).  It also adds the directories where optional packages are installed, if any (@pxref{Packaging Basics})."
msgstr "次にEmacsはコマンドラインオプション@option{-L}(@ref{Action Arguments,,,emacs, The GNU Emacs Manual}を参照)で指定したロードディレクトリーを追加する。もしあればオプションパッケージ(@ref{Packaging Basics}を参照)がインストールされた場所も追加する。"

#. type: Plain text
#: original_texis/loading.texi:382
msgid "It is common to add code to one's init file (@pxref{Init File}) to add one or more directories to @code{load-path}.  For example:"
msgstr "initファイル(@ref{Init File}を参照)で@code{load-path}に1つ以上のディレクトリーを追加するコードを記述するのは一般的に行なわれている。たとえば:"

#. type: example
#: original_texis/loading.texi:385
#, no-wrap
msgid "(push \"~/.emacs.d/lisp\" load-path)\n"
msgstr "(push \"~/.emacs.d/lisp\" load-path)\n"

#. type: Plain text
#: original_texis/loading.texi:391
msgid "Dumping Emacs uses a special value of @code{load-path}.  If you use a @file{site-load.el} or @file{site-init.el} file to customize the dumped Emacs (@pxref{Building Emacs}), any changes to @code{load-path} that these files make will be lost after dumping."
msgstr "Emacsのダンプには@code{load-path}の特別な値を使用する。ダンプされたEmacsをカスタマイズするために@file{site-load.el}か@file{site-init.el}を使用する場合、これらのファイルが行った@code{load-path}にたいする変更はすべてダンプ後に失われる。"

#. type: deffn
#: original_texis/loading.texi:392
#, no-wrap
msgid "Command locate-library library &optional nosuffix path interactive-call"
msgstr "Command locate-library library &optional nosuffix path interactive-call"

#. type: deffn
#: original_texis/loading.texi:398
msgid "This command finds the precise file name for library @var{library}.  It searches for the library in the same way @code{load} does, and the argument @var{nosuffix} has the same meaning as in @code{load}: don't add suffixes @samp{.elc} or @samp{.el} to the specified name @var{library}."
msgstr "このコマンドはライブラリー@var{library}の正確なファイル名を探す。@code{load}と同じ方法でライブラリーを検索を行い、引数@var{nosuffix}も@code{load}の場合と同じ意味をもつ。@var{library}に指定する名前にはサフィックス@samp{.elc}または@samp{.el}を追加しないこと。"

#. type: deffn
#: original_texis/loading.texi:401
msgid "If the @var{path} is non-@code{nil}, that list of directories is used instead of @code{load-path}."
msgstr "@var{path}が非@code{nil}なら@code{load-path}のかわりにそのディレクトリーのリストが使用される。"

#. type: deffn
#: original_texis/loading.texi:406
msgid "When @code{locate-library} is called from a program, it returns the file name as a string.  When the user runs @code{locate-library} interactively, the argument @var{interactive-call} is @code{t}, and this tells @code{locate-library} to display the file name in the echo area."
msgstr "@code{locate-library}がプログラムから呼び出されたときはファイル名を文字列としてリターンする。ユーザーがインタラクティブに@code{locate-library}を実行したときは、引数@var{interactive-call}が@code{t}となり、これは@code{locate-library}にたいしてファイル名をエコーエリアに表示するよう指示する。"

#. type: cindex
#: original_texis/loading.texi:408
#, no-wrap
msgid "shadowed Lisp files"
msgstr "shadowed Lisp files"

#. type: deffn
#: original_texis/loading.texi:409
#, no-wrap
msgid "Command list-load-path-shadows &optional stringp"
msgstr "Command list-load-path-shadows &optional stringp"

#. type: deffn
#: original_texis/loading.texi:414
msgid "This command shows a list of @dfn{shadowed} Emacs Lisp files.  A shadowed file is one that will not normally be loaded, despite being in a directory on @code{load-path}, due to the existence of another similarly-named file in a directory earlier on @code{load-path}."
msgstr "このコマンドは@dfn{シャドー(shadowed)}されたEmacs Lispファイルを表示する。シャドーされたファイルとは、@code{load-path}のディレクトリーに存在するにも関わらず、@code{load-path}のディレクトリーリスト内で前の位置にある他のディレクトリーに同じ名前のファイルが存在するため、通常はロードされないファイルのことである。"

#. type: deffn
#: original_texis/loading.texi:416
msgid "For instance, suppose @code{load-path} is set to"
msgstr "たとえば以下のように@code{load-path}がセットされていたとする"

#. type: example
#: original_texis/loading.texi:419
#, no-wrap
msgid "  (\"/opt/emacs/site-lisp\" \"/usr/share/emacs/23.3/lisp\")\n"
msgstr "  (\"/opt/emacs/site-lisp\" \"/usr/share/emacs/23.3/lisp\")\n"

#. type: deffn
#: original_texis/loading.texi:426
msgid "and that both these directories contain a file named @file{foo.el}.  Then @code{(require 'foo)} never loads the file in the second directory.  Such a situation might indicate a problem in the way Emacs was installed."
msgstr "そして両方のディレクトリーに@file{foo.el}という名前のファイルがあるとする。この場合、@code{(require 'foo)}は決して2つ目のディレクトリーのファイルをロードしない。このような状況はEmacsがインストールされた方法に問題があることを示唆する。"

#. type: deffn
#: original_texis/loading.texi:431
msgid "When called from Lisp, this function prints a message listing the shadowed files, instead of displaying them in a buffer.  If the optional argument @code{stringp} is non-@code{nil}, it instead returns the shadowed files as a string."
msgstr "Lispから呼び出されたると、この関数はシャドーされたファイルリストをバッファー内に表示するかわりに、それのメッセージをプリントする。オプション引数@code{stringp}が非@code{nil}なら、かわりにシャドーされたファイルを文字列としてリターンする。"

#. type: section
#: original_texis/loading.texi:434
#, no-wrap
msgid "Loading Non-@acronym{ASCII} Characters"
msgstr "Loading Non-@acronym{ASCII} Characters"

#. type: cindex
#: original_texis/loading.texi:435
#, no-wrap
msgid "loading, and non-ASCII characters"
msgstr "loading, and non-ASCII characters"

#. type: cindex
#: original_texis/loading.texi:436
#, no-wrap
msgid "non-ASCII characters in loaded files"
msgstr "non-ASCII characters in loaded files"

#. type: Plain text
#: original_texis/loading.texi:448
msgid "When Emacs Lisp programs contain string constants with non-@acronym{ASCII} characters, these can be represented within Emacs either as unibyte strings or as multibyte strings (@pxref{Text Representations}).  Which representation is used depends on how the file is read into Emacs.  If it is read with decoding into multibyte representation, the text of the Lisp program will be multibyte text, and its string constants will be multibyte strings.  If a file containing Latin-1 characters (for example) is read without decoding, the text of the program will be unibyte text, and its string constants will be unibyte strings.  @xref{Coding Systems}."
msgstr "Emacs Lispプログラムが非@acronym{ASCII}文字の文字列定数を含むとき、Emacsはそれらをユニバイト文字列かマルチバイト文字列のいずれかで表現する場合があります。どちらの表現が使用されるかは、そのファイルがどのようにEmacsに読み込まれたかに依存します。マルチバイト表現へのデコーディングとともに読み込まれた場合、Lispプログラム内のテキストはマルチバイトのテキストとなり、ファイル内の文字列定数はマルチバイト文字列になります。(たとえば)Latin-1文字を含むファイルをデコーディングなしで読み込むと、そのプログラムのテキストはユニバイトのテキストとなり、ファイル内の文字列定数はユニバイト文字列になります。@ref{Coding Systems}を参照してください。"

#. type: Plain text
#: original_texis/loading.texi:458
msgid "In most Emacs Lisp programs, the fact that non-@acronym{ASCII} strings are multibyte strings should not be noticeable, since inserting them in unibyte buffers converts them to unibyte automatically.  However, if this does make a difference, you can force a particular Lisp file to be interpreted as unibyte by writing @samp{coding: raw-text} in a local variables section.  With that designator, the file will unconditionally be interpreted as unibyte.  This can matter when making keybindings to non-@acronym{ASCII} characters written as @code{?v@var{literal}}."
msgstr "マルチバイト文字列がユニバイトバッファーに挿入されるときは自動的にユニバイトに変換されるため、大部分のEmacs Lispプログラムにおいて、マルチバイト文字列が非@acronym{ASCII}文字列であるという事実を意識させないようにするべきです。しかしこれが行われことにより違いが生じる場合には、ローカル変数セクションに@samp{coding: raw-text}と記述することにより、特定のLispファイルを強制的にユニバイトとして解釈させることができます。この識別子により、そのファイルは無条件でユニバイトとして解釈されます。これは@code{?v@var{literal}}で記述された非@acronym{ASCII}文字にキーバインドするとき重要になります。"

#. type: cindex
#: original_texis/loading.texi:461
#, no-wrap
msgid "autoload"
msgstr "autoload"

#. type: Plain text
#: original_texis/loading.texi:470
msgid "The @dfn{autoload} facility lets you register the existence of a function or macro, but put off loading the file that defines it.  The first call to the function automatically loads the proper library, in order to install the real definition and other associated code, then runs the real definition as if it had been loaded all along.  Autoloading can also be triggered by looking up the documentation of the function or macro (@pxref{Documentation Basics})."
msgstr "@dfn{オートロード(autoload: 自動ロード)}の機能により、定義されているファイルをロードすることなく関数やマクロの存在を登録できます。関数の最初の呼び出しで、実際の定義とその他の関連するコードをインストールするために適切なライブラリーを自動的にロードして、すべてがすでにロードされていたかのように実際の定義を実行します。関数やマクロのドキュメントを参照することによってもオートロードが発生します(@ref{Documentation Basics}を参照)。"

#. type: Plain text
#: original_texis/loading.texi:480
msgid "There are two ways to set up an autoloaded function: by calling @code{autoload}, and by writing a ``magic'' comment in the source before the real definition.  @code{autoload} is the low-level primitive for autoloading; any Lisp program can call @code{autoload} at any time.  Magic comments are the most convenient way to make a function autoload, for packages installed along with Emacs.  These comments do nothing on their own, but they serve as a guide for the command @code{update-file-autoloads}, which constructs calls to @code{autoload} and arranges to execute them when Emacs is built."
msgstr "オートロードされた関数をセットアップするには2つの方法があります。それは@code{autoload}を呼び出す方法と、ソースの実際の定義の前に、``マジック''コメントを記述する方法です。@code{autoload}はオートロードのための低レベルのプリミティブです。任意のLispプログラムが、任意のタイミングで@code{autoload}を呼び出すことができます。Emacsとともにインストールされるパッケージにとって、マジックコメントは関数をオートロードできるようににするための一番便利な方法です。そのコメント自身は何も行いませんが、コマンド@code{update-file-autoloads}にたいするガイドの役目を果たします。このコマンドは@code{autoload}の呼び出しを構築して、Emacsビルド時に実行されるようにアレンジします。"

#. type: defun
#: original_texis/loading.texi:481
#, no-wrap
msgid "autoload function filename &optional docstring interactive type"
msgstr "autoload function filename &optional docstring interactive type"

#. type: defun
#: original_texis/loading.texi:485
msgid "This function defines the function (or macro) named @var{function} so as to load automatically from @var{filename}.  The string @var{filename} specifies the file to load to get the real definition of @var{function}."
msgstr "この関数は@var{filename}から自動的にロードされるように、@var{function}という名前の関数(かマクロ)を定義する。文字列@var{filename}には@var{function}の実際の定義を取得するファイルを指定する。"

#. type: defun
#: original_texis/loading.texi:491
msgid "If @var{filename} does not contain either a directory name, or the suffix @code{.el} or @code{.elc}, this function insists on adding one of these suffixes, and it will not load from a file whose name is just @var{filename} with no added suffix.  (The variable @code{load-suffixes} specifies the exact required suffixes.)"
msgstr "@var{filename}がディレクトリー名、またはサフィックス@code{.el}と@code{.elc}のいずれも含まなければ、この関数はこれらのサフィックスのいずれかを強制的に追加して、サフィックスがないただの@var{filename}という名前のファイルはロードしない(変数@code{load-suffixes}により要求される正確なサフィックスが指定される)。"

#. type: defun
#: original_texis/loading.texi:499
msgid "The argument @var{docstring} is the documentation string for the function.  Specifying the documentation string in the call to @code{autoload} makes it possible to look at the documentation without loading the function's real definition.  Normally, this should be identical to the documentation string in the function definition itself.  If it isn't, the function definition's documentation string takes effect when it is loaded."
msgstr "引数@var{docstring}はその関数のドキュメント文字列である。@code{autoload}の呼び出しでドキュメント文字列を指定することにより、その関数の実際の定義をロードせずにドキュメントを見ることが可能になる。この引数の値は通常は関数定義のドキュメント文字列と等しいこと。もし等しくなければ、その関数定義のドキュメント文字列がロード時に有効になる。"

#. type: defun
#: original_texis/loading.texi:506
msgid "If @var{interactive} is non-@code{nil}, that says @var{function} can be called interactively.  This lets completion in @kbd{M-x} work without loading @var{function}'s real definition.  The complete interactive specification is not given here; it's not needed unless the user actually calls @var{function}, and when that happens, it's time to load the real definition."
msgstr "@var{interactive}が非@code{nil}なら、その関数はインタラクティブに呼び出すことが可能になる。これにより@var{function}の実際の定義をロードせずに、@kbd{M-x}による補完が機能するようになる。ここでは完全なインタラクティブ仕様は与えられない。完全な仕様はユーザーが実際に@var{function}を呼び出すまで必要ない。ユーザーが実際に呼び出したときに、実際の定義がロードされる。"

#. type: defun
#: original_texis/loading.texi:512
msgid "You can autoload macros and keymaps as well as ordinary functions.  Specify @var{type} as @code{macro} if @var{function} is really a macro.  Specify @var{type} as @code{keymap} if @var{function} is really a keymap.  Various parts of Emacs need to know this information without loading the real definition."
msgstr "普通の関数と同様、マクロとキーマップをオートロードできる。@var{function}が実際にはマクロなら@var{type}に@code{macro}、キーマップのなら@var{type}に@code{keymap}を指定する。Emacsのさまざまな部分では、実際の定義をロードせずにこれらの情報を知ることが必要とされる。"

#. type: defun
#: original_texis/loading.texi:519
msgid "An autoloaded keymap loads automatically during key lookup when a prefix key's binding is the symbol @var{function}.  Autoloading does not occur for other kinds of access to the keymap.  In particular, it does not happen when a Lisp program gets the keymap from the value of a variable and calls @code{define-key}; not even if the variable name is the same symbol @var{function}."
msgstr "オートロードされたキーマップは、あるプレフィクスキーがシンボル@var{function}にバインドされているとき、キーを探す間に自動的にロードされる。そのキーマップにたいする他の類のアクセスではオートロードは発生しない。特にLispプログラムが変数の値からそのキーマップを取得して@code{define-key}を呼び出した場合には、たとえその変数の名前がシンボル@var{function}と同じであってもオートロードは発生しない。"

#. type: cindex
#: original_texis/loading.texi:520
#, no-wrap
msgid "function cell in autoload"
msgstr "function cell in autoload"

#. type: defun
#: original_texis/loading.texi:526
msgid "If @var{function} already has a non-void function definition that is not an autoload object, this function does nothing and returns @code{nil}.  Otherwise, it constructs an autoload object (@pxref{Autoload Type}), and stores it as the function definition for @var{function}.  The autoload object has this form:"
msgstr "@var{function}が非voidのオートロードされたオブジェクトではない関数定義をもつなら、その関数は何も行わずに@code{nil}をリターンする。それ以外ならオートロードされたオブジェクト(@ref{Autoload Type}を参照)を作成して、それを@var{function}にたいする関数定義として格納する。オートロードされたオブジェクトは以下の形式をもつ:"

#. type: example
#: original_texis/loading.texi:529
#, no-wrap
msgid "(autoload @var{filename} @var{docstring} @var{interactive} @var{type})\n"
msgstr "(autoload @var{filename} @var{docstring} @var{interactive} @var{type})\n"

#. type: defun
#: original_texis/loading.texi:532
msgid "For example,"
msgstr "たとえば、"

#. type: group
#: original_texis/loading.texi:537
#, no-wrap
msgid ""
"(symbol-function 'run-prolog)\n"
"     @result{} (autoload \"prolog\" 169681 t nil)\n"
msgstr ""
"(symbol-function 'run-prolog)\n"
"     @result{} (autoload \"prolog\" 169681 t nil)\n"

#. type: defun
#: original_texis/loading.texi:546
msgid "In this case, @code{\"prolog\"} is the name of the file to load, 169681 refers to the documentation string in the @file{emacs/etc/DOC} file (@pxref{Documentation Basics}), @code{t} means the function is interactive, and @code{nil} that it is not a macro or a keymap."
msgstr "このような場合、@code{\"prolog\"}はロードするファイルの名前、169681は@file{emacs/etc/DOC}ファイル(@ref{Documentation Basics}を参照)内のドキュメント文字列への参照で、@code{t}はその関数がインタラクティブであること、@code{nil}はそれがマクロやキーマップでないことを意味する。"

#. type: defun
#: original_texis/loading.texi:548
#, no-wrap
msgid "autoloadp object"
msgstr "autoloadp object"

#. type: defun
#: original_texis/loading.texi:552
msgid "This function returns non-@code{nil} if @var{object} is an autoload object.  For example, to check if @code{run-prolog} is defined as an autoloaded function, evaluate"
msgstr "この関数は@var{object}がオートロードされたオブジェクトなら非@code{nil}をリターンする。たとえば@code{run-prolog}がオートロードされたオブジェクトかチェックするには以下を評価する"

#. type: smallexample
#: original_texis/loading.texi:555
#, no-wrap
msgid "(autoloadp (symbol-function 'run-prolog))\n"
msgstr "(autoloadp (symbol-function 'run-prolog))\n"

#. type: cindex
#: original_texis/loading.texi:558
#, no-wrap
msgid "autoload errors"
msgstr "autoload errors"

#. type: Plain text
#: original_texis/loading.texi:568
msgid "The autoloaded file usually contains other definitions and may require or provide one or more features.  If the file is not completely loaded (due to an error in the evaluation of its contents), any function definitions or @code{provide} calls that occurred during the load are undone.  This is to ensure that the next attempt to call any function autoloading from this file will try again to load the file.  If not for this, then some of the functions in the file might be defined by the aborted load, but fail to work properly for the lack of certain subroutines not loaded successfully because they come later in the file."
msgstr "オートロードされたファイルは、通常は他の定義を含み1つ以上の機能を必要としたり、あるいは提供するかもしれません。(内容の評価でのエラーにより)そのファイルが完全にロードされていなければ、そのロードの間に行われた関数定義や@code{provide}の呼び出しはアンドゥされます。これはそのファイルからオートロードされる関数にたいして再度呼び出しを試みたときに、そのファイルを確実に再ロードさせるためです。こうしないと、そのファイル内のいくつかの関数はアボートしたロードにより定義されていて、それらはロードされない修正後のファイルで提供される正しいサブルーチンを欠くため、正しく機能しないからです。"

#. type: Plain text
#: original_texis/loading.texi:572
msgid "If the autoloaded file fails to define the desired Lisp function or macro, then an error is signaled with data @code{\"Autoloading failed to define function @var{function-name}\"}."
msgstr "オートロードされたファイルが意図したLisp関数またはマクロの定義に失敗すると、データ@code{\"Autoloading failed to define function @var{function-name}\"}とともにエラーがシグナルされます。"

#. type: findex
#: original_texis/loading.texi:573
#, no-wrap
msgid "update-file-autoloads"
msgstr "update-file-autoloads"

#. type: findex
#: original_texis/loading.texi:574
#, no-wrap
msgid "update-directory-autoloads"
msgstr "update-directory-autoloads"

#. type: cindex
#: original_texis/loading.texi:575
#, no-wrap
msgid "magic autoload comment"
msgstr "magic autoload comment"

#. type: anchor{#1}
#: original_texis/loading.texi:576 original_texis/loading.texi:589
#, no-wrap
msgid "autoload cookie"
msgstr "autoload cookie"

#. type: Plain text
#: original_texis/loading.texi:589
msgid "A magic autoload comment (often called an @dfn{autoload cookie})  consists of @samp{;;;###autoload}, on a line by itself, just before the real definition of the function in its autoloadable source file.  The command @kbd{M-x update-file-autoloads} writes a corresponding @code{autoload} call into @file{loaddefs.el}.  (The string that serves as the autoload cookie and the name of the file generated by @code{update-file-autoloads} can be changed from the above defaults, see below.)  Building Emacs loads @file{loaddefs.el} and thus calls @code{autoload}.  @kbd{M-x update-directory-autoloads} is even more powerful; it updates autoloads for all files in the current directory."
msgstr "オートロードのマジックコメント(@dfn{autoload cookie}とも呼ばれる)は、オートロード可能なソースファイル内の実際の定義の直前にある、@samp{;;;###autoload}だけの行から構成されます。コマンド@kbd{M-x update-file-autoloads}は、対応する@code{autoload}呼び出しを@file{loaddefs.el}内に書き込みます(autoload cookieとなる文字列と@code{update-file-autoloads}で生成されるファイルの名前は上述のデフォルトから変更可能です。以下参照)。Emacsのビルドでは@file{loaddefs.el}をロードするために@code{autoload}を呼び出します。@kbd{M-x update-directory-autoloads}はより強力です。このコマンドはカレントディレクトリー内のすべてのファイルにたいするオートロードを更新します。"

#. type: Plain text
#: original_texis/loading.texi:596
msgid "The same magic comment can copy any kind of form into @file{loaddefs.el}.  The form following the magic comment is copied verbatim, @emph{except} if it is one of the forms which the autoload facility handles specially (e.g., by conversion into an @code{autoload} call).  The forms which are not copied verbatim are the following:"
msgstr "このマジックコメントは任意の種類のフォームを@file{loaddefs.el}内にコピーできます。このマジックコメントに続くフォームはそのままコピーされます。しかしオートロード機能が特別に処理するフォームの場合は@emph{除外}されます(たとえば@code{autoload}内への変換)。以下はそのままコピーされないフォームです:"

#. type: item
#: original_texis/loading.texi:598
#, no-wrap
msgid "Definitions for function or function-like objects:"
msgstr "関数や関数風オブジェクトの定義:"

#. type: table
#: original_texis/loading.texi:603
msgid "@code{defun} and @code{defmacro}; also @code{cl-defun} and @code{cl-defmacro} (@pxref{Argument Lists,,,cl,Common Lisp Extensions}), and @code{define-overloadable-function} (see the commentary in @file{mode-local.el})."
msgstr "@code{defun}と@code{defmacro}。@code{cl-defun}と@code{cl-defmacro}(@ref{Argument Lists,,,cl,Common Lisp Extensions}を参照)、および@code{define-overloadable-function} (@file{mode-local.el}内のコメントを参照)も該当する。"

#. type: item
#: original_texis/loading.texi:604
#, no-wrap
msgid "Definitions for major or minor modes:"
msgstr "メジャーモードとマイナーモードの定義:"

#. type: table
#: original_texis/loading.texi:610
msgid "@code{define-minor-mode}, @code{define-globalized-minor-mode}, @code{define-generic-mode}, @code{define-derived-mode}, @code{easy-mmode-define-minor-mode}, @code{easy-mmode-define-global-mode}, @code{define-compilation-mode}, and @code{define-global-minor-mode}."
msgstr "@code{define-minor-mode}、@code{define-globalized-minor-mode}、@code{define-generic-mode}、@code{define-derived-mode}、@code{easy-mmode-define-minor-mode}、@code{easy-mmode-define-global-mode}、@code{define-compilation-mode}、@code{define-global-minor-mode}。"

#. type: item
#: original_texis/loading.texi:611
#, no-wrap
msgid "Other definition types:"
msgstr "その他のタイプの定義:"

#. type: table
#: original_texis/loading.texi:615
msgid "@code{defcustom}, @code{defgroup}, @code{defclass} (@pxref{Top,EIEIO,,eieio,EIEIO}), and @code{define-skeleton} (see the commentary in @file{skeleton.el})."
msgstr "@code{defcustom}、@code{defgroup}、@code{defclass} (@ref{Top,EIEIO,,eieio,EIEIO}を参照)、および@code{define-skeleton} (@file{skeleton.el}内のコメントを参照)。"

#. type: Plain text
#: original_texis/loading.texi:623
msgid "You can also use a magic comment to execute a form at build time @emph{without} executing it when the file itself is loaded.  To do this, write the form @emph{on the same line} as the magic comment.  Since it is in a comment, it does nothing when you load the source file; but @kbd{M-x update-file-autoloads} copies it to @file{loaddefs.el}, where it is executed while building Emacs."
msgstr "ビルド時にそのファイル自身をロードするときにフォームを@emph{実行しない}ようにするためにマジックコメントを使用することもできます。これを行なうにはマジックコメントと同じ行にフォームを記述します。これはコメントなのでソースファイルをロードするときには何も行いません。ただし@kbd{M-x update-file-autoloads}では、Emacsビルド時に実行されたものは@kbd{M-x update-file-autoloads}にコピーします。"

#. type: Plain text
#: original_texis/loading.texi:626
msgid "The following example shows how @code{doctor} is prepared for autoloading with a magic comment:"
msgstr "以下はマジックコメントによるオートロードのために@code{doctor}を準備する例です:"

#. type: example
#: original_texis/loading.texi:634
#, no-wrap
msgid ""
";;;###autoload\n"
"(defun doctor ()\n"
"  \"Switch to *doctor* buffer and start giving psychotherapy.\"\n"
"  (interactive)\n"
"  (switch-to-buffer \"*doctor*\")\n"
"  (doctor-mode))\n"
msgstr ""
";;;###autoload\n"
"(defun doctor ()\n"
"  \"Switch to *doctor* buffer and start giving psychotherapy.\"\n"
"  (interactive)\n"
"  (switch-to-buffer \"*doctor*\")\n"
"  (doctor-mode))\n"

#. type: Plain text
#: original_texis/loading.texi:638
msgid "Here's what that produces in @file{loaddefs.el}:"
msgstr "これにより以下が@file{loaddefs.el}内に書き込まれます:"

#. type: example
#: original_texis/loading.texi:642
#, no-wrap
msgid ""
"(autoload (quote doctor) \"doctor\" \"\\\n"
"Switch to *doctor* buffer and start giving psychotherapy.\n"
"\n"
msgstr ""
"(autoload (quote doctor) \"doctor\" \"\\\n"
"Switch to *doctor* buffer and start giving psychotherapy.\n"
"\n"

#. type: example
#: original_texis/loading.texi:644
#, no-wrap
msgid "\\(fn)\" t nil)\n"
msgstr "\\(fn)\" t nil)\n"

#. type: cindex
#: original_texis/loading.texi:647
#, no-wrap
msgid "@code{fn} in function's documentation string"
msgstr "@code{fn} in function's documentation string"

#. type: Plain text
#: original_texis/loading.texi:656
msgid "The backslash and newline immediately following the double-quote are a convention used only in the preloaded uncompiled Lisp files such as @file{loaddefs.el}; they tell @code{make-docfile} to put the documentation string in the @file{etc/DOC} file.  @xref{Building Emacs}.  See also the commentary in @file{lib-src/make-docfile.c}.  @samp{(fn)} in the usage part of the documentation string is replaced with the function's name when the various help functions (@pxref{Help Functions}) display it."
msgstr "ダブルクォートの直後のバックスラッシュと改行は、@file{loaddefs.el}のようなプリロードされた未コンパイルのLispファイルだけに使用される慣習です。これは@code{make-docfile}にたいして、ドキュメント文字列を@file{etc/DOC}ファイルに配置するよう指示します。@ref{Building Emacs}を参照してください。また@file{lib-src/make-docfile.c}内のコメントも参照してください。ドキュメント文字列の使い方(usage part)の中の@samp{(fn)}は、種々のヘルプ関数(@ref{Help Functions}を参照)が表示するときに、その関数の名前に置き換えられます。"

#. type: Plain text
#: original_texis/loading.texi:662
msgid "If you write a function definition with an unusual macro that is not one of the known and recognized function definition methods, use of an ordinary magic autoload comment would copy the whole definition into @code{loaddefs.el}.  That is not desirable.  You can put the desired @code{autoload} call into @code{loaddefs.el} instead by writing this:"
msgstr "関数定義手法として既知ではなく、認められてもいないような、通常とは異なるマクロにより関数定義を記述した場合、通常のオートロードのマジックコメントの使用によって定義全体が@code{loaddefs.el}内にコピーされるでしょう。これは期待した動作ではありません。かわりに以下を記述することにより、意図した@code{autoload}呼び出しを@code{loaddefs.el}内に配置することができます。"

#. type: example
#: original_texis/loading.texi:667
#, no-wrap
msgid ""
";;;###autoload (autoload 'foo \"myfile\")\n"
"(mydefunmacro foo\n"
"  ...)\n"
msgstr ""
";;;###autoload (autoload 'foo \"myfile\")\n"
"(mydefunmacro foo\n"
"  ...)\n"

#. type: Plain text
#: original_texis/loading.texi:673
msgid "You can use a non-default string as the autoload cookie and have the corresponding autoload calls written into a file whose name is different from the default @file{loaddefs.el}.  Emacs provides two variables to control this:"
msgstr "autoload cookieとしてデフォルト以外の文字列を使用して、デフォルトの@file{loaddefs.el}とは異なるファイル内に対応するオートロード呼び出しを記述できます。これを制御するためにEmacsは2つの変数を提供します:"

#. type: defvar
#: original_texis/loading.texi:674
#, no-wrap
msgid "generate-autoload-cookie"
msgstr "generate-autoload-cookie"

#. type: defvar
#: original_texis/loading.texi:679
msgid "The value of this variable should be a string whose syntax is a Lisp comment.  @kbd{M-x update-file-autoloads} copies the Lisp form that follows the cookie into the autoload file it generates.  The default value of this variable is @code{\";;;###autoload\"}."
msgstr "この変数の値はLispコメントの文法に準じた文字列である。@kbd{M-x update-file-autoloads}はそのcookieの後のLispフォームを、cookieが生成したオートロードファイル内にコピーします。この変数のデフォルト値は@code{\";;;###autoload\"}。"

#. type: defvar
#: original_texis/loading.texi:681
#, no-wrap
msgid "generated-autoload-file"
msgstr "generated-autoload-file"

#. type: defvar
#: original_texis/loading.texi:687
msgid "The value of this variable names an Emacs Lisp file where the autoload calls should go.  The default value is @file{loaddefs.el}, but you can override that, e.g., in the local variables section of a @file{.el} file (@pxref{File Local Variables}).  The autoload file is assumed to contain a trailer starting with a formfeed character."
msgstr "この変数の値は、オートロード呼び出しが書き込まれるEmacs Lispファイルを命名する。デフォルト値は@file{loaddefs.el}だが、(たとえば@file{.el}ファイル内のセクションLocal Variables))をオーバーライドできる。オートロードファイルは、フォームフィード文字で開始される終端を含んでいると仮定される。"

#. type: Plain text
#: original_texis/loading.texi:691
msgid "The following function may be used to explicitly load the library specified by an autoload object:"
msgstr "以下の関数はオートロードオブジェクトにより指定されたライブラリーを明示的にロードするために使用されるかもしれません:"

#. type: defun
#: original_texis/loading.texi:692
#, no-wrap
msgid "autoload-do-load autoload &optional name macro-only"
msgstr "autoload-do-load autoload &optional name macro-only"

#. type: defun
#: original_texis/loading.texi:700
msgid "This function performs the loading specified by @var{autoload}, which should be an autoload object.  The optional argument @var{name}, if non-@code{nil}, should be a symbol whose function value is @var{autoload}; in that case, the return value of this function is the symbol's new function value.  If the value of the optional argument @var{macro-only} is @code{macro}, this function avoids loading a function, only a macro."
msgstr "この関数はオートロードオブジェクト@var{autoload}により指定されたロードを処理する。オプション引数@var{name}に非@code{nil}を指定するなら、関数値が@var{autoload}となるシンボルを指定すること。この場合、この関数のリターン値がそのシンボルの新しい関数値になる。オプション引数@var{macro-only}の値が@code{macro}なら、この関数は関数ではなくマクロのロードだけを有効にする。"

#. type: cindex
#: original_texis/loading.texi:704
#, no-wrap
msgid "repeated loading"
msgstr "repeated loading"

#. type: Plain text
#: original_texis/loading.texi:710
msgid "You can load a given file more than once in an Emacs session.  For example, after you have rewritten and reinstalled a function definition by editing it in a buffer, you may wish to return to the original version; you can do this by reloading the file it came from."
msgstr "1つのEmacsセッション内でファイルを複数回ロードできます。たとえばバッファーで関数定義を編集して再インストールした後に元のバージョンに戻したいときがあるかもしれません。これは元のファイルをリロードすることにより行なうことができます。"

#. type: Plain text
#: original_texis/loading.texi:719
msgid "When you load or reload files, bear in mind that the @code{load} and @code{load-library} functions automatically load a byte-compiled file rather than a non-compiled file of similar name.  If you rewrite a file that you intend to save and reinstall, you need to byte-compile the new version; otherwise Emacs will load the older, byte-compiled file instead of your newer, non-compiled file! If that happens, the message displayed when loading the file includes, @samp{(compiled; note, source is newer)}, to remind you to recompile it."
msgstr "ファイルのロードやリロードを行う際、@code{load}と@code{load-library}関数は未コンパイルのファイルではなく、バイトコンパイルされた同名のファイルを自動的にロードすることに留意してください。ファイルを再記述して保存後に再インストールする場合には、新しいバージョンをバイトコンパイルする必要があります。さもないとEmacsは新しいソースではなく、古いバイトコンパイルされたファイルをロードしてしまうでしょう! この場合にはファイルロード時に表示されるメッセージに、そのファイルのリコンパイルを促す@samp{(compiled; note, source is newer)}というメッセージが含まれます。"

#. type: Plain text
#: original_texis/loading.texi:725
msgid "When writing the forms in a Lisp library file, keep in mind that the file might be loaded more than once.  For example, think about whether each variable should be reinitialized when you reload the library; @code{defvar} does not change the value if the variable is already initialized.  (@xref{Defining Variables}.)"
msgstr "Lispライブラリーファイル内にフォームを記述するときは、そのファイルが複数回ロードされるかもしれないことに留意してください。たとえば、そのライブラリーをリロードするときには、各変数が再初期化されるべきかどうか考慮してください。。変数がすでに初期化されていれば、@code{defvar}はその変数の値を変更しません(@ref{Defining Variables}を参照)。"

#. type: Plain text
#: original_texis/loading.texi:727
msgid "The simplest way to add an element to an alist is like this:"
msgstr "alistに要素を追加するもっともシンプルな方法は、以下のようなものでしょう:"

#. type: example
#: original_texis/loading.texi:730
#, no-wrap
msgid "(push '(leif-mode \" Leif\") minor-mode-alist)\n"
msgstr "(push '(leif-mode \" Leif\") minor-mode-alist)\n"

#. type: Plain text
#: original_texis/loading.texi:735
msgid "But this would add multiple elements if the library is reloaded.  To avoid the problem, use @code{add-to-list} (@pxref{List Variables}):"
msgstr "しかしこれはそのライブラリーがリロードされると、複数の要素を追加してしまうでしょう。この問題を避けるには@code{add-to-list}(@ref{List Variables}を参照)を使用します:"

#. type: example
#: original_texis/loading.texi:738
#, no-wrap
msgid "(add-to-list 'minor-mode-alist '(leif-mode \" Leif\"))\n"
msgstr "(add-to-list 'minor-mode-alist '(leif-mode \" Leif\"))\n"

#. type: Plain text
#: original_texis/loading.texi:745
msgid "Occasionally you will want to test explicitly whether a library has already been loaded.  If the library uses @code{provide} to provide a named feature, you can use @code{featurep} earlier in the file to test whether the @code{provide} call has been executed before (@pxref{Named Features}).  Alternatively, you could use something like this:"
msgstr "時にはライブラリーが既にロード済みか、明示的にテストしたいときがあるでしょう。そのライブラリーが@code{provide}を使用して名前付きフィーチャ(named feature)を提供していれば、@code{featurep}を使用して以前に@code{provide}が実行されているかテストすることができます。かわりに以下のようにすることもできます:"

#. type: example
#: original_texis/loading.texi:748
#, no-wrap
msgid ""
"(defvar foo-was-loaded nil)\n"
"\n"
msgstr ""
"(defvar foo-was-loaded nil)\n"
"\n"

#. type: example
#: original_texis/loading.texi:752
#, no-wrap
msgid ""
"(unless foo-was-loaded\n"
"  @var{execute-first-time-only}\n"
"  (setq foo-was-loaded t))\n"
msgstr ""
"(unless foo-was-loaded\n"
"  @var{execute-first-time-only}\n"
"  (setq foo-was-loaded t))\n"

#. type: section
#: original_texis/loading.texi:757
#, no-wrap
msgid "Features"
msgstr "Features"

#. type: defvar
#: original_texis/loading.texi:758 original_texis/loading.texi:916
#, no-wrap
msgid "features"
msgstr "features"

#. type: cindex
#: original_texis/loading.texi:759
#, no-wrap
msgid "requiring features"
msgstr "requiring features"

#. type: cindex
#: original_texis/loading.texi:760
#, no-wrap
msgid "providing features"
msgstr "providing features"

#. type: Plain text
#: original_texis/loading.texi:767
msgid "@code{provide} and @code{require} are an alternative to @code{autoload} for loading files automatically.  They work in terms of named @dfn{features}.  Autoloading is triggered by calling a specific function, but a feature is loaded the first time another program asks for it by name."
msgstr "@code{provide}と@code{require}は、@code{autoload}にかわってファイルを自動的にロードする関数です。これらは名前付きの@dfn{フィーチャ(feature: 機能)}という面で機能します。オートロードは特定の関数の呼び出しをトリガーにしますが、フィーチャは最初は他のプログラムが名前により問い合わせたときにロードされます。"

#. type: Plain text
#: original_texis/loading.texi:773
msgid "A feature name is a symbol that stands for a collection of functions, variables, etc.  The file that defines them should @dfn{provide} the feature.  Another program that uses them may ensure they are defined by @dfn{requiring} the feature.  This loads the file of definitions if it hasn't been loaded already."
msgstr "フィーチャ名とは関数や変数などのコレクションを表すシンボルです。これらを定義するファイルは、そのフィーチャを@dfn{プロバイド(provide: 提供)}するべきです。これらのフィーチャを使用する他のプログラムは、その機能を@dfn{リクワイア(require: 要求)}することによって、それらが定義されているか確認できるでしょう。これは定義がまだロードされていなければ、定義ファイルをロードします。"

#. type: cindex
#: original_texis/loading.texi:774
#, no-wrap
msgid "load error with require"
msgstr "load error with require"

#. type: Plain text
#: original_texis/loading.texi:781
msgid "To require the presence of a feature, call @code{require} with the feature name as argument.  @code{require} looks in the global variable @code{features} to see whether the desired feature has been provided already.  If not, it loads the feature from the appropriate file.  This file should call @code{provide} at the top level to add the feature to @code{features}; if it fails to do so, @code{require} signals an error."
msgstr "フィーチャをリクワイアするには、フィーチャ名を引数として@code{require}を呼び出します。@code{require}は意図する機能がすでにプロバイドされているか確認するために、グローバル変数@code{features}を調べます。もしプロバイドされていなければ、適切なファイルからそのフィーチャをロードします。このファイルはそのフィーチャを@code{features}に追加するために、トップレベルで@code{provide}を呼び出すべきです。これに失敗すると@code{require}はエラーをシグナルします。"

#. type: Plain text
#: original_texis/loading.texi:784
msgid "For example, in @file{idlwave.el}, the definition for @code{idlwave-complete-filename} includes the following code:"
msgstr "たとえば@file{idlwave.el}内の@code{idlwave-complete-filename}にたいする定義には以下のコードが含まれます:"

#. type: example
#: original_texis/loading.texi:793
#, no-wrap
msgid ""
"(defun idlwave-complete-filename ()\n"
"  \"Use the comint stuff to complete a file name.\"\n"
"   (require 'comint)\n"
"   (let* ((comint-file-name-chars \"~/A-Za-z0-9+@@:_.$#%=@{@}\\\\-\")\n"
"          (comint-completion-addsuffix nil)\n"
"          ...)\n"
"       (comint-dynamic-complete-filename)))\n"
msgstr ""
"(defun idlwave-complete-filename ()\n"
"  \"Use the comint stuff to complete a file name.\"\n"
"   (require 'comint)\n"
"   (let* ((comint-file-name-chars \"~/A-Za-z0-9+@@:_.$#%=@{@}\\\\-\")\n"
"          (comint-completion-addsuffix nil)\n"
"          ...)\n"
"       (comint-dynamic-complete-filename)))\n"

#. type: Plain text
#: original_texis/loading.texi:805
msgid "The expression @code{(require 'comint)} loads the file @file{comint.el} if it has not yet been loaded, ensuring that @code{comint-dynamic-complete-filename} is defined.  Features are normally named after the files that provide them, so that @code{require} need not be given the file name.  (Note that it is important that the @code{require} statement be outside the body of the @code{let}.  Loading a library while its variables are let-bound can have unintended consequences, namely the variables becoming unbound after the let exits.)"
msgstr "式@code{(require 'comint)}は@file{comint.el}がまだロードされていなければ、@code{comint-dynamic-complete-filename}が確実に定義されるようにそのファイルをロードします。フィーチャは通常はそれらを提供するファイルにしたがって命名されるため、@code{require}にファイル名を与える必要はありません(@code{require}命令文が@code{let}のbodyの外側にあるのが重要なことに注意。変数がletバインドされているライブラリーをロードすることにより、意図せぬ結果、つまりletをexitした後にその変数がアンバインドされる)。"

#. type: Plain text
#: original_texis/loading.texi:807
msgid "The @file{comint.el} file contains the following top-level expression:"
msgstr "@file{comint.el}には以下のトップレベル式が含まれます:"

#. type: example
#: original_texis/loading.texi:810
#, no-wrap
msgid "(provide 'comint)\n"
msgstr "(provide 'comint)\n"

#. type: Plain text
#: original_texis/loading.texi:816
msgid "This adds @code{comint} to the global @code{features} list, so that @code{(require 'comint)} will henceforth know that nothing needs to be done."
msgstr "これは@code{comint}をグローバルなリスト@code{features}に追加するので、@code{(require 'comint)}は今後何も行う必要がないことを知ることができます。"

#. type: cindex
#: original_texis/loading.texi:817
#, no-wrap
msgid "byte-compiling @code{require}"
msgstr "byte-compiling @code{require}"

#. type: Plain text
#: original_texis/loading.texi:824
msgid "When @code{require} is used at top level in a file, it takes effect when you byte-compile that file (@pxref{Byte Compilation}) as well as when you load it.  This is in case the required package contains macros that the byte compiler must know about.  It also avoids byte compiler warnings for functions and variables defined in the file loaded with @code{require}."
msgstr "ファイルのトップレベルで@code{require}が使用されたときは、それをロードしたときと同様、そのファイルをバイトコンパイル(@ref{Byte Compilation}を参照)するときにも効果が表れます。これはリクワイアされたパッケージがマクロを含んでいて、バイトコンパイラーがそれを知らなければならない場合です。これは@code{require}によりロードされるファイルで定義される関数と変数にへのバイトコンパイラーの警告も無効にします。"

#. type: Plain text
#: original_texis/loading.texi:830
msgid "Although top-level calls to @code{require} are evaluated during byte compilation, @code{provide} calls are not.  Therefore, you can ensure that a file of definitions is loaded before it is byte-compiled by including a @code{provide} followed by a @code{require} for the same feature, as in the following example."
msgstr "バイトコンパイルの間にトップレベルの@code{require}が評価されるとしても、@code{provide}呼び出しは評価されません。したがって以下の例のように@code{provide}の後に同じ機能にたいする@code{require}を含めることにより、バイトコンパイル前に定義しているファイルを確実にロードできます。"

#. type: group
#: original_texis/loading.texi:836
#, no-wrap
msgid ""
"(provide 'my-feature)  ; @r{Ignored by byte compiler,}\n"
"                       ;   @r{evaluated by @code{load}.}\n"
"(require 'my-feature)  ; @r{Evaluated by byte compiler.}\n"
msgstr ""
"(provide 'my-feature)  ; @r{バイトコンパイラーには無視され}\n"
"                       ;   @r{@code{load}には評価される}\n"
"(require 'my-feature)  ; @r{バイトコンパイラーにより評価される。}\n"

#. type: Plain text
#: original_texis/loading.texi:844
msgid "The compiler ignores the @code{provide}, then processes the @code{require} by loading the file in question.  Loading the file does execute the @code{provide} call, so the subsequent @code{require} call does nothing when the file is loaded."
msgstr "コンパイラーは@code{provide}を無視して、その後に対象のファイルをロードすることにより@code{require}が処理されます。ファイルのロードは@code{provide}呼び出しを実行するので、後続の@code{require}はファイルがロードされていれば何も行いません。"

#. type: defun
#: original_texis/loading.texi:845
#, no-wrap
msgid "provide feature &optional subfeatures"
msgstr "provide feature &optional subfeatures"

#. type: defun
#: original_texis/loading.texi:850
msgid "This function announces that @var{feature} is now loaded, or being loaded, into the current Emacs session.  This means that the facilities associated with @var{feature} are or will be available for other Lisp programs."
msgstr "この関数はカレントEmacsセッションに@var{feature}がロードされたこと、あるいはロードされつつあることをアナウンスする。これは@var{feature}に関連する機能が他のLispプログラムから利用可能できる、あるいは利用可能になることを意味する。"

#. type: defun
#: original_texis/loading.texi:856
msgid "The direct effect of calling @code{provide} is to add @var{feature} to the front of @code{features} if it is not already in that list and call any @code{eval-after-load} code waiting for it (@pxref{Hooks for Loading}).  The argument @var{feature} must be a symbol.  @code{provide} returns @var{feature}."
msgstr "@code{provide}呼び出にによる直接的な効果は、リスト@var{feature}内にまだ追加されていなければ@var{feature}の先頭にそれを追加して、それを必要としている@code{eval-after-load}コードを呼び出すことである(@ref{Hooks for Loading}を参照)。引数@var{feature}はシンボルでなければならない。@code{provide}は@var{feature}をリターンする。"

#. type: defun
#: original_texis/loading.texi:866
msgid "If provided, @var{subfeatures} should be a list of symbols indicating a set of specific subfeatures provided by this version of @var{feature}.  You can test the presence of a subfeature using @code{featurep}.  The idea of subfeatures is that you use them when a package (which is one @var{feature}) is complex enough to make it useful to give names to various parts or functionalities of the package, which might or might not be loaded, or might or might not be present in a given version.  @xref{Network Feature Testing}, for an example."
msgstr "@var{subfeatures}が与えられたら、それは@var{feature}の当該バージョンによりプロバイドされる特定のサブフィーチャのセットを示すシンボルのリストであること。@code{featurep}を使用して、サブフィーチャの存在をテストできる。そのパッケージがロードされるかどうか、あるいは与えられるバージョンで存在するかどうか不明であるようなあるパッケージ(1つの@var{feature})において、パッケージの種々の部分やパッケージ機能に命名することでそのパッケージを使いやすくするのが困難なほど複雑なときに使用するというのがサブフィーチャのアイデアである。@ref{Network Feature Testing}の例を参照されたい。"

#. type: example
#: original_texis/loading.texi:870
#, no-wrap
msgid ""
"features\n"
"     @result{} (bar bish)\n"
"\n"
msgstr ""
"features\n"
"     @result{} (bar bish)\n"
"\n"

#. type: example
#: original_texis/loading.texi:875
#, no-wrap
msgid ""
"(provide 'foo)\n"
"     @result{} foo\n"
"features\n"
"     @result{} (foo bar bish)\n"
msgstr ""
"(provide 'foo)\n"
"     @result{} foo\n"
"features\n"
"     @result{} (foo bar bish)\n"

#. type: defun
#: original_texis/loading.texi:881
msgid "When a file is loaded to satisfy an autoload, and it stops due to an error in the evaluation of its contents, any function definitions or @code{provide} calls that occurred during the load are undone.  @xref{Autoload}."
msgstr "オートロードによりあるファイルがロードされて、その内容の評価エラーによりストップしたときは、そのロードの間に発生した関数定義や@code{provide}呼び出しはアンドゥされる。@ref{Autoload}を参照のこと。"

#. type: defun
#: original_texis/loading.texi:883
#, no-wrap
msgid "require feature &optional filename noerror"
msgstr "require feature &optional filename noerror"

#. type: defun
#: original_texis/loading.texi:887
msgid "This function checks whether @var{feature} is present in the current Emacs session (using @code{(featurep @var{feature})}; see below).  The argument @var{feature} must be a symbol."
msgstr "この関数はカレントEmacsセッションにおいて、@var{feature}が存在するかどうかを(@code{(featurep @var{feature})}を使用する。以下参照)をチェックする。引数@var{feature}はシンボルでなければならない。"

#. type: defun
#: original_texis/loading.texi:896
msgid "If the feature is not present, then @code{require} loads @var{filename} with @code{load}.  If @var{filename} is not supplied, then the name of the symbol @var{feature} is used as the base file name to load.  However, in this case, @code{require} insists on finding @var{feature} with an added @samp{.el} or @samp{.elc} suffix (possibly extended with a compression suffix); a file whose name is just @var{feature} won't be used.  (The variable @code{load-suffixes} specifies the exact required Lisp suffixes.)"
msgstr "そのフィーチャが存在しなければ、@code{require}は@code{load}によって@var{filename}をロードする。@var{filename}が与えられなければ、シンボル@var{feature}の名前がロードするファイル名のベースとして使用される。しかしこの場合、@code{require}は@var{feature}を探すためにサフィックス@samp{.el}と@samp{.elc}の追加を強制する(圧縮ファイルのサフィックスに拡張されるかもしれない)。名前がただの@var{feature}というファイルは使用されない(変数@code{load-suffixes}は要求されるLispサフィックスを正確に指定する)。"

#. type: defun
#: original_texis/loading.texi:901
msgid "If @var{noerror} is non-@code{nil}, that suppresses errors from actual loading of the file.  In that case, @code{require} returns @code{nil} if loading the file fails.  Normally, @code{require} returns @var{feature}."
msgstr "@var{noerror}が非@code{nil}なら、ファイルの実際のロードにおけるエラーを抑止する。この場合はそのファイルのロードが失敗すると@code{require}は@code{nil}をリターンする。通常では@code{require}は@var{feature}をリターンする。"

#. type: defun
#: original_texis/loading.texi:905
msgid "If loading the file succeeds but does not provide @var{feature}, @code{require} signals an error, @samp{Required feature @var{feature} was not provided}."
msgstr "ファイルのロードは成功したが@var{feature}をプロバイドしていなければ、@code{require}は@samp{Required feature @var{feature} was not provided}のようにエラーをシグナルする。"

#. type: defun
#: original_texis/loading.texi:907
#, no-wrap
msgid "featurep feature &optional subfeature"
msgstr "featurep feature &optional subfeature"

#. type: defun
#: original_texis/loading.texi:914
msgid "This function returns @code{t} if @var{feature} has been provided in the current Emacs session (i.e., if @var{feature} is a member of @code{features}.)  If @var{subfeature} is non-@code{nil}, then the function returns @code{t} only if that subfeature is provided as well (i.e., if @var{subfeature} is a member of the @code{subfeature} property of the @var{feature} symbol.)"
msgstr "この関数はカレントEmacsセッションで@var{feature}がプロバイドされていれば(たとえば@var{feature}が@code{features}のメンバーなら)@code{t}をリターンする。@var{subfeature}が非@code{nil}なら、この関数はサブフィーチャも同様にプロバイドされているとき(たとえば@var{subfeature}がシンボル@var{feature}のプロパティ@code{subfeature}のメンバーのとき)だけ@code{t}をリターンする。"

#. type: defvar
#: original_texis/loading.texi:921
msgid "The value of this variable is a list of symbols that are the features loaded in the current Emacs session.  Each symbol was put in this list with a call to @code{provide}.  The order of the elements in the @code{features} list is not significant."
msgstr "この変数の値はシンボルのリストであり、そのシンボルはカレントEmacsセッションにロードされたフィーチャである。シンボルはそれぞれ@code{provide}を呼び出すことにより、このリストにputされたものである。リスト@code{features}内の要素の順番に意味はない。"

#. type: section
#: original_texis/loading.texi:924
#, no-wrap
msgid "Which File Defined a Certain Symbol"
msgstr "Which File Defined a Certain Symbol"

#. type: cindex
#: original_texis/loading.texi:925
#, no-wrap
msgid "symbol, where defined"
msgstr "symbol, where defined"

#. type: cindex
#: original_texis/loading.texi:926
#, no-wrap
msgid "where was a symbol defined"
msgstr "where was a symbol defined"

#. type: defun
#: original_texis/loading.texi:928
#, no-wrap
msgid "symbol-file symbol &optional type"
msgstr "symbol-file symbol &optional type"

#. type: defun
#: original_texis/loading.texi:934
msgid "This function returns the name of the file that defined @var{symbol}.  If @var{type} is @code{nil}, then any kind of definition is acceptable.  If @var{type} is @code{defun}, @code{defvar}, or @code{defface}, that specifies function definition, variable definition, or face definition only."
msgstr "この関数は@var{symbol}を定義しているファイルの名前をリターンする。@var{type}が@code{nil}なら、どのようなタイプの定義も受け入れる。@var{type}が@code{defun}なら関数定義、@code{defvar}は変数定義、@code{defface}はフェイス定義だけを指定する。"

#. type: defun
#: original_texis/loading.texi:939
msgid "The value is normally an absolute file name.  It can also be @code{nil}, if the definition is not associated with any file.  If @var{symbol} specifies an autoloaded function, the value can be a relative file name without extension."
msgstr "値は通常は絶対ファイル名である。定義がどのファイルにも関係しなければ@code{nil}になることもある。@var{symbol}がオートロード関数を指定するなら、値が拡張子なしの相対ファイル名になることもある。"

#. type: Plain text
#: original_texis/loading.texi:943
msgid "The basis for @code{symbol-file} is the data in the variable @code{load-history}."
msgstr "@code{symbol-file}は変数@code{load-history}の値にもとづく。"

#. type: defvar
#: original_texis/loading.texi:944
#, no-wrap
msgid "load-history"
msgstr "load-history"

#. type: defvar
#: original_texis/loading.texi:948
msgid "The value of this variable is an alist that associates the names of loaded library files with the names of the functions and variables they defined, as well as the features they provided or required."
msgstr "この変数の値はロードされたライブラリーファイルの名前を、それらが定義する関数と変数の名前、およびそれらがプロバイドまたはリクワイアするフィーチャに関連付けるalistである。"

#. type: defvar
#: original_texis/loading.texi:953
msgid "Each element in this alist describes one loaded library (including libraries that are preloaded at startup).  It is a list whose @sc{car} is the absolute file name of the library (a string).  The rest of the list elements have these forms:"
msgstr "このalist内の各要素は、1つのロード済みライブラリー(スタートアップ時にプリロードされたライブラリーを含む)を記述する。要素は@sc{car}がライブラリーの絶対ファイル名(文字列)であるようなリストである。残りのリスト要素は以下の形式をもつ:"

#. type: var{#1}
#: original_texis/loading.texi:955
#, no-wrap
msgid "var"
msgstr "var"

#. type: table
#: original_texis/loading.texi:957
msgid "The symbol @var{var} was defined as a variable."
msgstr "シンボル@var{var}が変数として定義された。"

#. type: item
#: original_texis/loading.texi:957
#, no-wrap
msgid "(defun . @var{fun})"
msgstr "(defun . @var{fun})"

#. type: table
#: original_texis/loading.texi:959
msgid "The function @var{fun} was defined."
msgstr "関数@var{fun}が定義された。"

#. type: item
#: original_texis/loading.texi:959
#, no-wrap
msgid "(t . @var{fun})"
msgstr "(t . @var{fun})"

#. type: table
#: original_texis/loading.texi:964
msgid "The function @var{fun} was previously an autoload before this library redefined it as a function.  The following element is always @code{(defun . @var{fun})}, which represents defining @var{fun} as a function."
msgstr "関数@var{fun}はそのライブラリーが関数として再定義する前はオートロードとして定義されていた。後続の要素は常に@code{(defun . @var{fun})}であり、これは@var{fun}を関数として定義する。"

#. type: item
#: original_texis/loading.texi:964
#, no-wrap
msgid "(autoload . @var{fun})"
msgstr "(autoload . @var{fun})"

#. type: table
#: original_texis/loading.texi:966
msgid "The function @var{fun} was defined as an autoload."
msgstr "関数@var{fun}はオートロードとして定義された。"

#. type: item
#: original_texis/loading.texi:966
#, no-wrap
msgid "(defface . @var{face})"
msgstr "(defface . @var{face})"

#. type: table
#: original_texis/loading.texi:968
msgid "The face @var{face} was defined."
msgstr "フェイス@var{face}が定義された。"

#. type: item
#: original_texis/loading.texi:968
#, no-wrap
msgid "(require . @var{feature})"
msgstr "(require . @var{feature})"

#. type: table
#: original_texis/loading.texi:970
msgid "The feature @var{feature} was required."
msgstr "フィーチャ@var{feature}がリクワイアされた。"

#. type: item
#: original_texis/loading.texi:970
#, no-wrap
msgid "(provide . @var{feature})"
msgstr "(provide . @var{feature})"

#. type: table
#: original_texis/loading.texi:972
msgid "The feature @var{feature} was provided."
msgstr "フィーチャ@var{feature}がプロバイドされた。"

#. type: item
#: original_texis/loading.texi:972
#, no-wrap
msgid "(cl-defmethod @var{method} @var{specializers})"
msgstr "(cl-defmethod @var{method} @var{specializers})"

#. type: table
#: original_texis/loading.texi:975
msgid "The named @var{method} was defined by using @code{cl-defmethod}, with @var{specializers} as its specializers."
msgstr "@code{cl-defmethod}を使用してスペシャライザー@var{specializers}とともに@var{method}という名前が定義された。"

#. type: item
#: original_texis/loading.texi:975
#, no-wrap
msgid "(define-type . @var{type})"
msgstr "(define-type . @var{type})"

#. type: table
#: original_texis/loading.texi:977
msgid "The type @var{type} was defined."
msgstr "型@var{type}が定義された。"

#. type: defvar
#: original_texis/loading.texi:982
msgid "The value of @code{load-history} may have one element whose @sc{car} is @code{nil}.  This element describes definitions made with @code{eval-buffer} on a buffer that is not visiting a file."
msgstr "@code{load-history}の値には、@sc{car}が@code{nil}であるような要素が1つ含まれるかもしれない。この要素はファイルをvisitしていないバッファーで@code{eval-buffer}により作成された定義を記述する。"

#. type: Plain text
#: original_texis/loading.texi:987
msgid "The command @code{eval-region} updates @code{load-history}, but does so by adding the symbols defined to the element for the file being visited, rather than replacing that element.  @xref{Eval}."
msgstr "コマンド@code{eval-region}は@code{load-history}を更新しますが、要素を置き換えずに、visitされているファイルの要素にたいして定義されたシンボルを追加します。@ref{Eval}を参照してください。"

#. type: cindex
#: original_texis/loading.texi:990
#, no-wrap
msgid "unloading packages"
msgstr "unloading packages"

#. type: Plain text
#: original_texis/loading.texi:996
msgid "You can discard the functions and variables loaded by a library to reclaim memory for other Lisp objects.  To do this, use the function @code{unload-feature}:"
msgstr "他のLispオブジェクト用にメモリーを回収するために、ライブラリーによりロードされた関数や変数を破棄することができます。これを行うには関数@code{unload-feature}を使用します:"

#. type: deffn
#: original_texis/loading.texi:997
#, no-wrap
msgid "Command unload-feature feature &optional force"
msgstr "Command unload-feature feature &optional force"

#. type: deffn
#: original_texis/loading.texi:1004
msgid "This command unloads the library that provided feature @var{feature}.  It undefines all functions, macros, and variables defined in that library with @code{defun}, @code{defalias}, @code{defsubst}, @code{defmacro}, @code{defconst}, @code{defvar}, and @code{defcustom}.  It then restores any autoloads formerly associated with those symbols.  (Loading saves these in the @code{autoload} property of the symbol.)"
msgstr "このコマンドはフィーチャ@var{feature}をプロバイドしていたライブラリーをアンロードする。そのライブラリー内の@code{defun}、@code{defalias}、@code{defsubst}、@code{defmacro}、@code{defconst}、@code{defvar}、@code{defcustom}によって定義されたすべての関数、マクロ、変数は未定義になる。その後に、それらのシンボルにたいして事前に関連付けられていたオートロードをリストアする(ロードはシンボルの@code{autoload}プロパティにこれらを保存している)。"

#. type: deffn
#: original_texis/loading.texi:1013
msgid "Before restoring the previous definitions, @code{unload-feature} runs @code{remove-hook} to remove functions in the library from certain hooks.  These hooks include variables whose names end in @samp{-hook} (or the deprecated suffix @samp{-hooks}), plus those listed in @code{unload-feature-special-hooks}, as well as @code{auto-mode-alist}.  This is to prevent Emacs from ceasing to function because important hooks refer to functions that are no longer defined."
msgstr "以前の定義をリストアする前に、特定のフックからそのライブラリー内の関数を取り除くために、@code{unload-feature}は@code{remove-hook}を実行する。これらのフックには名前が@samp{-hook}(または廃止されたサフィックス@samp{-hooks})で終わる変数、加えて@code{unload-feature-special-hooks}、同様に@code{auto-mode-alist}にリストされた変数も含まれる。これは重要なフックがすでに定義されていない関数を参照をすることにより、Emacsの機能が停止することを防ぐためである。"

#. type: deffn
#: original_texis/loading.texi:1017
msgid "Standard unloading activities also undoes ELP profiling of functions in that library, unprovides any features provided by the library, and cancels timers held in variables defined by the library."
msgstr "標準的なアンロードアクティビティでは、そのライブラリー内の関数のELPプロファイリング、そのライブラリーによりプロバイドされたフィーチャ、そのライブラリーで定義された変数に保持されたタイマーを取り消す。"

#. type: vindex
#: original_texis/loading.texi:1018
#, no-wrap
msgid "@var{feature}-unload-function"
msgstr "@var{feature}-unload-function"

#. type: deffn
#: original_texis/loading.texi:1026
msgid "If these measures are not sufficient to prevent malfunction, a library can define an explicit unloader named @code{@var{feature}-unload-function}.  If that symbol is defined as a function, @code{unload-feature} calls it with no arguments before doing anything else.  It can do whatever is appropriate to unload the library.  If it returns @code{nil}, @code{unload-feature} proceeds to take the normal unload actions.  Otherwise it considers the job to be done."
msgstr "これらの基準が機能不全を防ぐのに十分でなければ、ライブラリーは@code{@var{feature}-unload-function}という名前の明示的なアンローダーを定義できる。そのシンボルが関数として定義されていたら、@code{unload-feature}は何かを行う前にまず引数なしでそれを呼び出す。これはライブラリーのアンロードのために適切なすべてのことを行うことができる。これが@code{nil}をリターンしたら、@code{unload-feature}は通常のアンロードアクションを処理する。それ以外ならアンロード処理は完了したとみなす。"

#. type: deffn
#: original_texis/loading.texi:1032
msgid "Ordinarily, @code{unload-feature} refuses to unload a library on which other loaded libraries depend.  (A library @var{a} depends on library @var{b} if @var{a} contains a @code{require} for @var{b}.)  If the optional argument @var{force} is non-@code{nil}, dependencies are ignored and you can unload any library."
msgstr "@code{unload-feature}は通常は他のライブラリーが依存するライブラリーのアンロードを拒絶する(ライブラリー@var{b}にたいする@code{require}がライブラリー@var{a}に含まれるなら、@var{a}は@var{b}に依存している)。オプション引数@var{force}が非@code{nil}なら依存関係は無視されて、どのようなライブラリーもアンロードできる。"

#. type: Plain text
#: original_texis/loading.texi:1036
msgid "The @code{unload-feature} function is written in Lisp; its actions are based on the variable @code{load-history}."
msgstr "@code{unload-feature}関数はLispで記述されており、その動作は変数@code{load-history}にもとづきます。"

#. type: defvar
#: original_texis/loading.texi:1037
#, no-wrap
msgid "unload-feature-special-hooks"
msgstr "unload-feature-special-hooks"

#. type: defvar
#: original_texis/loading.texi:1040
msgid "This variable holds a list of hooks to be scanned before unloading a library, to remove functions defined in the library."
msgstr "この変数はライブラリー内で定義された関数を取り除くために、ライブラリーをアンロードする前にスキャンするフックのリストを保持する。"

#. type: cindex
#: original_texis/loading.texi:1044
#, no-wrap
msgid "loading hooks"
msgstr "loading hooks"

#. type: cindex
#: original_texis/loading.texi:1045
#, no-wrap
msgid "hooks for loading"
msgstr "hooks for loading"

#. type: Plain text
#: original_texis/loading.texi:1049
msgid "You can ask for code to be executed each time Emacs loads a library, by using the variable @code{after-load-functions}:"
msgstr "変数@code{after-load-functions}を使用することにより、Emacsがライブラリーをロードするたびにコードを実行させることができます:"

#. type: defvar
#: original_texis/loading.texi:1050
#, no-wrap
msgid "after-load-functions"
msgstr "after-load-functions"

#. type: defvar
#: original_texis/loading.texi:1054
msgid "This abnormal hook is run after loading a file.  Each function in the hook is called with a single argument, the absolute filename of the file that was just loaded."
msgstr "このアブノーマルフック(abnormal hook)は、ファイルをロードした後に実行される。フック内の各関数は1つの引数(ロードされたファイルの絶対ファイル名)で呼び出される。"

#. type: Plain text
#: original_texis/loading.texi:1058
msgid "If you want code to be executed when a @emph{particular} library is loaded, use the macro @code{with-eval-after-load}:"
msgstr "@emph{特定}のライブラリーのロード後にコードを実行したければ、マクロ@code{with-eval-after-load}を使用します:"

#. type: defmac
#: original_texis/loading.texi:1059
#, no-wrap
msgid "with-eval-after-load library body@dots{}"
msgstr "with-eval-after-load library body@dots{}"

#. type: defmac
#: original_texis/loading.texi:1063
msgid "This macro arranges to evaluate @var{body} at the end of loading the file @var{library}, each time @var{library} is loaded.  If @var{library} is already loaded, it evaluates @var{body} right away."
msgstr "このマクロは@var{library}がロードされるたびに、ファイル@var{library}のロードの最後で@var{body}が評価されるよう準備する。@var{library}がすでにロード済みなら即座に@var{body}を評価する。"

#. type: defmac
#: original_texis/loading.texi:1066
msgid "You don't need to give a directory or extension in the file name @var{library}.  Normally, you just give a bare file name, like this:"
msgstr "ファイル名@var{library}にディレクトリーや拡張子を与える必要はない。通常は以下のようにファイル名だけを与える:"

#. type: example
#: original_texis/loading.texi:1069
#, no-wrap
msgid "(with-eval-after-load \"edebug\" (def-edebug-spec c-point t))\n"
msgstr "(with-eval-after-load \"edebug\" (def-edebug-spec c-point t))\n"

#. type: defmac
#: original_texis/loading.texi:1078
msgid "To restrict which files can trigger the evaluation, include a directory or an extension or both in @var{library}.  Only a file whose absolute true name (i.e., the name with all symbolic links chased out)  matches all the given name components will match.  In the following example, @file{my_inst.elc} or @file{my_inst.elc.gz} in some directory @code{..../foo/bar} will trigger the evaluation, but not @file{my_inst.el}:"
msgstr "どのファイルが評価をトリガーするか制限するには、ディレクトリーか拡張子、またはその両方を@var{library}に含める。実際のファイル名(シンボリックリンク名はすべて除外される)が、与えられた名前すべてにマッチするファイルだけがマッチとなる。以下の例ではどこかのディレクトリー@code{..../foo/bar}にある@file{my_inst.elc}や@file{my_inst.elc.gz}は評価をトリガーするが、@file{my_inst.el}は異なる。:"

#. type: example
#: original_texis/loading.texi:1081
#, no-wrap
msgid "(with-eval-after-load \"foo/bar/my_inst.elc\" @dots{})\n"
msgstr "(with-eval-after-load \"foo/bar/my_inst.elc\" @dots{})\n"

#. type: defmac
#: original_texis/loading.texi:1086
msgid "@var{library} can also be a feature (i.e., a symbol), in which case @var{body} is evaluated at the end of any file where @code{(provide @var{library})} is called."
msgstr "@var{library}はフィーチャ(たとえばシンボル)でもよく、その場合には@code{(provide @var{library})}を呼び出す任意のファイルの最後に@var{body}が評価される。"

#. type: defmac
#: original_texis/loading.texi:1089
msgid "An error in @var{body} does not undo the load, but does prevent execution of the rest of @var{body}."
msgstr "@var{body}内でのエラーはロードをアンドゥしないが、@var{body}の残りの実行を防げる。"

#. type: Plain text
#: original_texis/loading.texi:1098
msgid "Normally, well-designed Lisp programs should not use @code{with-eval-after-load}.  If you need to examine and set the variables defined in another library (those meant for outside use), you can do it immediately---there is no need to wait until the library is loaded.  If you need to call functions defined by that library, you should load the library, preferably with @code{require} (@pxref{Named Features})."
msgstr "上手く設計されたLispプログラムは、通常は@code{with-eval-after-load}を使用するべきではありません。(外部からの使用を意図した)他のライブラリーで定義された変数を調べたりセットする必要があるなら、それは即座に行うことができます −−− そのライブラリーがロードされるのを待つ必要はありまん。そのライブラリーで定義された関数を呼び出す必要があるならそのライブラリーをロードすべきであって、それには@code{require}(@ref{Named Features}を参照)が適しています。"

#. type: section
#: original_texis/loading.texi:1100
#, no-wrap
msgid "Emacs Dynamic Modules"
msgstr "Emacs Dynamic Modules"

#. type: cindex
#: original_texis/loading.texi:1101
#, no-wrap
msgid "dynamic modules"
msgstr "dynamic modules"

#. type: Plain text
#: original_texis/loading.texi:1108
msgid "A @dfn{dynamic Emacs module} is a shared library that provides additional functionality for use in Emacs Lisp programs, just like a package written in Emacs Lisp would."
msgstr "@dfn{ダイナミックEmacsミジュール(dynamic Emacs module)}とは、Emacs Lispで記述されたパッケージのように、Emacs Lispプログラムで使用するための追加機能を提供する共有ライブラリーです。"

#. type: Plain text
#: original_texis/loading.texi:1112
msgid "Functions that load Emacs Lisp packages can also load dynamic modules.  They recognize dynamic modules by looking at their file-name extension, a.k.a.@: ``suffix''.  This suffix is platform-dependent."
msgstr "Emacs Lispパッケージをロードする関数は、ダイナミックモジュールのロードもできます。これらの関数はファイル名の拡張子、いわゆる``サフィックス''を調べることによってダイナミックモジュールを認識します。"

#. type: defvar
#: original_texis/loading.texi:1113
#, no-wrap
msgid "module-file-suffix"
msgstr "module-file-suffix"

#. type: defvar
#: original_texis/loading.texi:1117
msgid "This variable holds the system-dependent value of the file-name extension of the module files.  Its value is @file{.so} on Posix hosts and @file{.dll} on MS-Windows."
msgstr "この変数はモジュールファイルのファイル名拡張子の、システム依存な値を保持する。Posixホストでは@file{.so}、MS-Windowsでは@file{.dll}。"

#. type: findex
#: original_texis/loading.texi:1119
#, no-wrap
msgid "emacs_module_init"
msgstr "emacs_module_init"

#. type: vindex
#: original_texis/loading.texi:1120
#, no-wrap
msgid "plugin_is_GPL_compatible"
msgstr "plugin_is_GPL_compatible"

#. type: Plain text
#: original_texis/loading.texi:1127
msgid "Every dynamic module should export a C-callable function named @code{emacs_module_init}, which Emacs will call as part of the call to @code{load} or @code{require} which loads the module.  It should also export a symbol named @code{plugin_is_GPL_compatible} to indicate that its code is released under the GPL or compatible license; Emacs will refuse to load modules that don't export such a symbol."
msgstr "すべてのダイナミックモジュールはCから呼び出し可能な@code{emacs_module_init}という名前の関数をエクスポートする必要があります。@code{load}か@code{require}でそのモジュールをロードする一部として、Emacsはその関数を呼び出します。モジュールのコードがGPLまたはGPL互換のライセンスの下にリリースされたことを示す、@code{plugin_is_GPL_compatible}という名前のシンボルもエクスポートしてください。Emacsはこのようなシンボルをエクスポートしないモジュールのロードを拒絶するでしょう。"

#. type: Plain text
#: original_texis/loading.texi:1131
msgid "If a module needs to call Emacs functions, it should do so through the API defined and documented in the header file @file{emacs-module.h} that is part of the Emacs distribution."
msgstr "モジュールがEmacs関数を呼び出す必要があるなら、Emacsディストリビューションに含まれるヘッダーファイル@file{emacs-module.h}で定義およびドキュメントされているAPIを通じてこれを行ってください。"

#. type: cindex
#: original_texis/loading.texi:1132
#, no-wrap
msgid "user-ptr object"
msgstr "user-ptr object"

#. type: Plain text
#: original_texis/loading.texi:1140
msgid "Modules can create @code{user-ptr} Lisp objects that embed pointers to C struct's defined by the module.  This is useful for keeping around complex data structures created by a module, to be passed back to the module's functions.  User-ptr objects can also have associated @dfn{finalizers} -- functions to be run when the object is GC'ed; this is useful for freeing any resources allocated for the underlying data structure, such as memory, open file descriptors, etc."
msgstr "モジュールは、そのモジールで定義されたC構造体にたいする埋め込みポインターである@code{user-ptr}Lispオブジェクトを作成できます。これはモジュールで作成されてそのモジュールの関数に渡される複雑なデータ構造を保持するために有用です。user-ptrオブジェクトはそれに関連付けられる@dfn{ファイナライザー(finalizers)}をもつこともできます。ファイナライザーとはオブジェクトがガーベージコレクションされたときに実行される関数のことです。"

#. type: defun
#: original_texis/loading.texi:1141
#, no-wrap
msgid "user-ptrp object"
msgstr "user-ptrp object"

#. type: defun
#: original_texis/loading.texi:1144
msgid "This function returns @code{t} if its argument is a @code{user-ptr} object."
msgstr "この関数は引数が@code{user-ptr}オブジェクトなら@code{t}をリターンする。"

#. type: Plain text
#: original_texis/loading.texi:1147
msgid "Loadable modules in Emacs are enabled by using the @kbd{--with-modules} option at configure time."
msgstr "Emacsのロード可能モジュールは、configure時にオプション@kbd{--with-modules}を使用することにより有効になります。"
