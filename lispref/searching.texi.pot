# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2024-04-18 06:15+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: original_texis/searching.texi:6 original_texis/searching.texi:7
#, no-wrap
msgid "Searching and Matching"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:8
#, no-wrap
msgid "searching"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:15
msgid ""
"GNU Emacs provides two ways to search through a buffer for specified text: "
"exact string searches and regular expression searches.  After a regular "
"expression search, you can examine the @dfn{match data} to determine which "
"text matched the whole regular expression or various portions of it."
msgstr ""

#. type: node
#: original_texis/searching.texi:26 original_texis/searching.texi:32
#, no-wrap
msgid "String Search"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:26
msgid "Search for an exact match."
msgstr ""

#. type: section
#: original_texis/searching.texi:26 original_texis/searching.texi:191
#: original_texis/searching.texi:192
#, no-wrap
msgid "Searching and Case"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:26
msgid "Case-independent or case-significant searching."
msgstr ""

#. type: section
#: original_texis/searching.texi:26 original_texis/searching.texi:234
#: original_texis/searching.texi:235
#, no-wrap
msgid "Regular Expressions"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:26
msgid "Describing classes of strings."
msgstr ""

#. type: node
#: original_texis/searching.texi:26 original_texis/searching.texi:1960
#, no-wrap
msgid "Regexp Search"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:26
msgid "Searching for a match for a regexp."
msgstr ""

#. type: node
#: original_texis/searching.texi:26 original_texis/searching.texi:2196
#, no-wrap
msgid "POSIX Regexps"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:26
msgid "Searching POSIX-style for the longest match."
msgstr ""

#. type: node
#: original_texis/searching.texi:26 original_texis/searching.texi:2241
#, no-wrap
msgid "Match Data"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:26
msgid "Finding out which part of the text matched, after a string or regexp search."
msgstr ""

#. type: section
#: original_texis/searching.texi:26 original_texis/searching.texi:2651
#: original_texis/searching.texi:2652
#, no-wrap
msgid "Search and Replace"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:26
msgid "Commands that loop, searching and replacing."
msgstr ""

#. type: node
#: original_texis/searching.texi:26 original_texis/searching.texi:2902
#, no-wrap
msgid "Standard Regexps"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:26
msgid "Useful regexps for finding sentences, pages,..."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:31
msgid ""
"The @samp{skip-chars@dots{}} functions also perform a kind of searching.  "
"@xref{Skipping Characters}.  To search for changes in character properties, "
"see @ref{Property Search}."
msgstr ""

#. type: section
#: original_texis/searching.texi:33
#, no-wrap
msgid "Searching for Strings"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:34
#, no-wrap
msgid "string search"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:42
msgid ""
"These are the primitive functions for searching through the text in a "
"buffer.  They are meant for use in programs, but you may call them "
"interactively.  If you do so, they prompt for the search string; the "
"arguments @var{limit} and @var{noerror} are @code{nil}, and @var{repeat} is "
"1.  For more details on interactive searching, @pxref{Search,, Searching and "
"Replacement, emacs, The GNU Emacs Manual}."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:46
msgid ""
"These search functions convert the search string to multibyte if the buffer "
"is multibyte; they convert the search string to unibyte if the buffer is "
"unibyte.  @xref{Text Representations}."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:47
#, no-wrap
msgid "Command search-forward string &optional limit noerror count"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:52
msgid ""
"This function searches forward from point for an exact match for "
"@var{string}.  If successful, it sets point to the end of the occurrence "
"found, and returns the new value of point.  If no match is found, the value "
"and side effects depend on @var{noerror} (see below)."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:56
msgid ""
"In the following example, point is initially at the beginning of the line.  "
"Then @code{(search-forward \"fox\")} moves point after the last letter of "
"@samp{fox}:"
msgstr ""

#. type: group
#: original_texis/searching.texi:62
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"@point{}The quick brown fox jumped over the lazy dog.\n"
"---------- Buffer: foo ----------\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:67
#, no-wrap
msgid ""
"(search-forward \"fox\")\n"
"     @result{} 20\n"
"\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:71
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"The quick brown fox@point{} jumped over the lazy dog.\n"
"---------- Buffer: foo ----------\n"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:78
msgid ""
"The argument @var{limit} specifies the bound to the search, and should be a "
"position in the current buffer.  No match extending after that position is "
"accepted.  If @var{limit} is omitted or @code{nil}, it defaults to the end "
"of the accessible portion of the buffer."
msgstr ""

#. type: kindex
#: original_texis/searching.texi:79
#, no-wrap
msgid "search-failed"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:88
msgid ""
"What happens when the search fails depends on the value of @var{noerror}.  "
"If @var{noerror} is @code{nil}, a @code{search-failed} error is signaled.  "
"If @var{noerror} is @code{t}, @code{search-forward} returns @code{nil} and "
"does nothing.  If @var{noerror} is neither @code{nil} nor @code{t}, then "
"@code{search-forward} moves point to the upper bound and returns @code{nil}."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:97 original_texis/searching.texi:2006
msgid ""
"The argument @var{noerror} only affects valid searches which fail to find a "
"match.  Invalid arguments cause errors regardless of @var{noerror}."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:106 original_texis/searching.texi:2015
msgid ""
"If @var{count} is a positive number @var{n}, the search is done @var{n} "
"times; each successive search starts at the end of the previous match.  If "
"all these successive searches succeed, the function call succeeds, moving "
"point and returning its new value.  Otherwise the function call fails, with "
"results depending on the value of @var{noerror}, as described above.  If "
"@var{count} is a negative number @minus{}@var{n}, the search is done @var{n} "
"times in the opposite (backward) direction."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:108
#, no-wrap
msgid "Command search-backward string &optional limit noerror count"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:113
msgid ""
"This function searches backward from point for @var{string}.  It is like "
"@code{search-forward}, except that it searches backwards rather than "
"forwards.  Backward searches leave point at the beginning of the match."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:115
#, no-wrap
msgid "Command word-search-forward string &optional limit noerror count"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:119
msgid ""
"This function searches forward from point for a word match for "
"@var{string}.  If it finds a match, it sets point to the end of the match "
"found, and returns the new value of point."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:126
msgid ""
"Word matching regards @var{string} as a sequence of words, disregarding "
"punctuation that separates them.  It searches the buffer for the same "
"sequence of words.  Each word must be distinct in the buffer (searching for "
"the word @samp{ball} does not match the word @samp{balls}), but the details "
"of punctuation and spacing are ignored (searching for @samp{ball boy} does "
"match @samp{ball.  Boy!})."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:129
msgid ""
"In this example, point is initially at the beginning of the buffer; the "
"search leaves it between the @samp{y} and the @samp{!}."
msgstr ""

#. type: group
#: original_texis/searching.texi:136
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"@point{}He said \"Please!  Find\n"
"the ball boy!\"\n"
"---------- Buffer: foo ----------\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:141
#, no-wrap
msgid ""
"(word-search-forward \"Please find the ball, boy.\")\n"
"     @result{} 39\n"
"\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:146
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"He said \"Please!  Find\n"
"the ball boy@point{}!\"\n"
"---------- Buffer: foo ----------\n"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:152
msgid ""
"If @var{limit} is non-@code{nil}, it must be a position in the current "
"buffer; it specifies the upper bound to the search.  The match found must "
"not extend after that position."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:158
msgid ""
"If @var{noerror} is @code{nil}, then @code{word-search-forward} signals an "
"error if the search fails.  If @var{noerror} is @code{t}, then it returns "
"@code{nil} instead of signaling an error.  If @var{noerror} is neither "
"@code{nil} nor @code{t}, it moves point to @var{limit} (or the end of the "
"accessible portion of the buffer) and returns @code{nil}."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:163
msgid ""
"If @var{count} is a positive number, it specifies how many successive "
"occurrences to search for.  Point is positioned at the end of the last "
"match.  If @var{count} is a negative number, the search is backward and "
"point is positioned at the beginning of the last match."
msgstr ""

#. type: findex
#: original_texis/searching.texi:164
#, no-wrap
msgid "word-search-regexp"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:168
msgid ""
"Internally, @code{word-search-forward} and related functions use the "
"function @code{word-search-regexp} to convert @var{string} to a regular "
"expression that ignores punctuation."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:170
#, no-wrap
msgid "Command word-search-forward-lax string &optional limit noerror count"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:176
msgid ""
"This command is identical to @code{word-search-forward}, except that the "
"beginning or the end of @var{string} need not match a word boundary, unless "
"@var{string} begins or ends in whitespace.  For instance, searching for "
"@samp{ball boy} matches @samp{ball boyee}, but does not match @samp{balls "
"boy}."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:178
#, no-wrap
msgid "Command word-search-backward string &optional limit noerror count"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:183
msgid ""
"This function searches backward from point for a word match to "
"@var{string}.  This function is just like @code{word-search-forward} except "
"that it searches backward and normally leaves point at the beginning of the "
"match."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:185
#, no-wrap
msgid "Command word-search-backward-lax string &optional limit noerror count"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:189
msgid ""
"This command is identical to @code{word-search-backward}, except that the "
"beginning or the end of @var{string} need not match a word boundary, unless "
"@var{string} begins or ends in whitespace."
msgstr ""

#. type: cindex
#: original_texis/searching.texi:193
#, no-wrap
msgid "searching and case"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:200
msgid ""
"By default, searches in Emacs ignore the case of the text they are searching "
"through; if you specify searching for @samp{FOO}, then @samp{Foo} or "
"@samp{foo} is also considered a match.  This applies to regular expressions, "
"too; thus, @samp{[aB]} would match @samp{a} or @samp{A} or @samp{b} or "
"@samp{B}."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:208
msgid ""
"If you do not want this feature, set the variable @code{case-fold-search} to "
"@code{nil}.  Then all letters must match exactly, including case.  This is a "
"buffer-local variable; altering the variable affects only the current "
"buffer.  (@xref{Intro to Buffer-Local}.)  Alternatively, you may change the "
"default value.  In Lisp code, you will more typically use @code{let} to bind "
"@code{case-fold-search} to the desired value."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:216
msgid ""
"Note that the user-level incremental search feature handles case "
"distinctions differently.  When the search string contains only lower case "
"letters, the search ignores case, but when the search string contains one or "
"more upper case letters, the search becomes case-sensitive.  But this has "
"nothing to do with the searching functions used in Lisp code.  "
"@xref{Incremental Search,,, emacs, The GNU Emacs Manual}."
msgstr ""

#. type: defopt
#: original_texis/searching.texi:217
#, no-wrap
msgid "case-fold-search"
msgstr ""

#. type: defopt
#: original_texis/searching.texi:221
msgid ""
"This buffer-local variable determines whether searches should ignore case.  "
"If the variable is @code{nil} they do not ignore case; otherwise (and by "
"default) they do ignore case."
msgstr ""

#. type: defopt
#: original_texis/searching.texi:223
#, no-wrap
msgid "case-replace"
msgstr ""

#. type: defopt
#: original_texis/searching.texi:229
msgid ""
"This variable determines whether the higher-level replacement functions "
"should preserve case.  If the variable is @code{nil}, that means to use the "
"replacement text verbatim.  A non-@code{nil} value means to convert the case "
"of the replacement text according to the text being replaced."
msgstr ""

#. type: defopt
#: original_texis/searching.texi:232
msgid ""
"This variable is used by passing it as an argument to the function "
"@code{replace-match}.  @xref{Replacing Match}."
msgstr ""

#. type: cindex
#: original_texis/searching.texi:236
#, no-wrap
msgid "regular expression"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:237
#, no-wrap
msgid "regexp"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:243
msgid ""
"A @dfn{regular expression}, or @dfn{regexp} for short, is a pattern that "
"denotes a (possibly infinite) set of strings.  Searching for matches for a "
"regexp is a very powerful operation.  This section explains how to write "
"regexps; the following section says how to search for them."
msgstr ""

#. type: findex
#: original_texis/searching.texi:244
#, no-wrap
msgid "re-builder"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:245
#, no-wrap
msgid "regular expressions, developing"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:253
msgid ""
"For interactive development of regular expressions, you can use the @kbd{M-x "
"re-builder} command.  It provides a convenient interface for creating "
"regular expressions, by giving immediate visual feedback in a separate "
"buffer.  As you edit the regexp, all its matches in the target buffer are "
"highlighted.  Each parenthesized sub-expression of the regexp is shown in a "
"distinct face, which makes it easier to verify even very complex regexps."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:258
msgid ""
"Note that by default Emacs search ignores case (@pxref{Searching and "
"Case}).  To enable case-sensitive regexp search and match, bind "
"@code{case-fold-search} to @code{nil} around the code you want to be "
"case-sensitive."
msgstr ""

#. type: node
#: original_texis/searching.texi:262 original_texis/searching.texi:269
#, no-wrap
msgid "Syntax of Regexps"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:262
msgid "Rules for writing regular expressions."
msgstr ""

#. type: node
#: original_texis/searching.texi:262 original_texis/searching.texi:919
#, no-wrap
msgid "Regexp Example"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:262
msgid "Illustrates regular expression syntax."
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:264
msgid "* Rx Notation:: An alternative, structured regexp notation."
msgstr ""

#. type: node
#: original_texis/searching.texi:267 original_texis/searching.texi:1766
#, no-wrap
msgid "Regexp Functions"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:267
msgid "Functions for operating on regular expressions."
msgstr ""

#. type: node
#: original_texis/searching.texi:267 original_texis/searching.texi:1893
#, no-wrap
msgid "Regexp Problems"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:267
msgid "Some problems and how they may be avoided."
msgstr ""

#. type: subsection
#: original_texis/searching.texi:270
#, no-wrap
msgid "Syntax of Regular Expressions"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:271 original_texis/searching.texi:1002
#, no-wrap
msgid "regexp syntax"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:272
#, no-wrap
msgid "syntax of regular expressions"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:285
msgid ""
"Regular expressions have a syntax in which a few characters are special "
"constructs and the rest are @dfn{ordinary}.  An ordinary character is a "
"simple regular expression that matches that character and nothing else.  The "
"special characters are @samp{.}, @samp{*}, @samp{+}, @samp{?}, @samp{[}, "
"@samp{^}, @samp{$}, and @samp{\\}; no new special characters will be defined "
"in the future.  The character @samp{]} is special if it ends a character "
"alternative (see later).  The character @samp{-} is special inside a "
"character alternative.  A @samp{[:} and balancing @samp{:]} enclose a "
"character class inside a character alternative.  Any other character "
"appearing in a regular expression is ordinary, unless a @samp{\\} precedes "
"it."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:291
msgid ""
"For example, @samp{f} is not a special character, so it is ordinary, and "
"therefore @samp{f} is a regular expression that matches the string @samp{f} "
"and no other string.  (It does @emph{not} match the string @samp{fg}, but it "
"does match a @emph{part} of that string.)  Likewise, @samp{o} is a regular "
"expression that matches only @samp{o}."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:296
msgid ""
"Any two regular expressions @var{a} and @var{b} can be concatenated.  The "
"result is a regular expression that matches a string if @var{a} matches some "
"amount of the beginning of that string and @var{b} matches the rest of the "
"string."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:301
msgid ""
"As a simple example, we can concatenate the regular expressions @samp{f} and "
"@samp{o} to get the regular expression @samp{fo}, which matches only the "
"string @samp{fo}.  Still trivial.  To do something more powerful, you need "
"to use one of the special regular expression constructs."
msgstr ""

#. type: node
#: original_texis/searching.texi:306 original_texis/searching.texi:308
#, no-wrap
msgid "Regexp Special"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:306
msgid "Special characters in regular expressions."
msgstr ""

#. type: node
#: original_texis/searching.texi:306 original_texis/searching.texi:578
#, no-wrap
msgid "Char Classes"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:306
msgid "Character classes used in regular expressions."
msgstr ""

#. type: node
#: original_texis/searching.texi:306 original_texis/searching.texi:665
#, no-wrap
msgid "Regexp Backslash"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:306
msgid "Backslash-sequences in regular expressions."
msgstr ""

#. type: subsubsection
#: original_texis/searching.texi:309
#, no-wrap
msgid "Special Characters in Regular Expressions"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:310
#, no-wrap
msgid "regexp, special characters in"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:314
msgid "Here is a list of the characters that are special in a regular expression."
msgstr ""

#. type: item
#: original_texis/searching.texi:317
#, no-wrap
msgid "@samp{.}@: @r{(Period)}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:318
#, no-wrap
msgid "@samp{.} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:323
msgid ""
"is a special character that matches any single character except a newline.  "
"Using concatenation, we can make regular expressions like @samp{a.b}, which "
"matches any three-character string that begins with @samp{a} and ends with "
"@samp{b}."
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:324
#, no-wrap
msgid "*"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:325
#, no-wrap
msgid "@samp{*} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:330
msgid ""
"is not a construct by itself; it is a postfix operator that means to match "
"the preceding regular expression repetitively as many times as possible.  "
"Thus, @samp{o*} matches any number of @samp{o}s (including no @samp{o}s)."
msgstr ""

#. type: table
#: original_texis/searching.texi:334
msgid ""
"@samp{*} always applies to the @emph{smallest} possible preceding "
"expression.  Thus, @samp{fo*} has a repeating @samp{o}, not a repeating "
"@samp{fo}.  It matches @samp{f}, @samp{fo}, @samp{foo}, and so on."
msgstr ""

#. type: cindex
#: original_texis/searching.texi:335
#, no-wrap
msgid "backtracking and regular expressions"
msgstr ""

#. type: table
#: original_texis/searching.texi:346
msgid ""
"The matcher processes a @samp{*} construct by matching, immediately, as many "
"repetitions as can be found.  Then it continues with the rest of the "
"pattern.  If that fails, backtracking occurs, discarding some of the matches "
"of the @samp{*}-modified construct in the hope that this will make it "
"possible to match the rest of the pattern.  For example, in matching "
"@samp{ca*ar} against the string @samp{caaar}, the @samp{a*} first tries to "
"match all three @samp{a}s; but the rest of the pattern is @samp{ar} and "
"there is only @samp{r} left to match, so this try fails.  The next "
"alternative is for @samp{a*} to match only two @samp{a}s.  With this choice, "
"the rest of the regexp matches successfully."
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:347
#, no-wrap
msgid "+"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:348
#, no-wrap
msgid "@samp{+} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:353
msgid ""
"is a postfix operator, similar to @samp{*} except that it must match the "
"preceding expression at least once.  So, for example, @samp{ca+r} matches "
"the strings @samp{car} and @samp{caaaar} but not the string @samp{cr}, "
"whereas @samp{ca*r} matches all three strings."
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:354
#, no-wrap
msgid "?"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:355
#, no-wrap
msgid "@samp{?} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:359
msgid ""
"is a postfix operator, similar to @samp{*} except that it must match the "
"preceding expression either once or not at all.  For example, @samp{ca?r} "
"matches @samp{car} or @samp{cr}; nothing else."
msgstr ""

#. type: anchor{#1}
#: original_texis/searching.texi:361
msgid "Non-greedy repetition"
msgstr ""

#. type: item
#: original_texis/searching.texi:361
#, no-wrap
msgid "@samp{*?}, @samp{+?}, @samp{??}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:362
#, no-wrap
msgid "non-greedy repetition characters in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:368
msgid ""
"are @dfn{non-greedy} variants of the operators @samp{*}, @samp{+} and "
"@samp{?}.  Where those operators match the largest possible substring "
"(consistent with matching the entire containing expression), the non-greedy "
"variants match the smallest possible substring (consistent with matching the "
"entire containing expression)."
msgstr ""

#. type: table
#: original_texis/searching.texi:374
msgid ""
"For example, the regular expression @samp{c[ad]*a} when applied to the "
"string @samp{cdaaada} matches the whole string; but the regular expression "
"@samp{c[ad]*?a}, applied to that same string, matches just @samp{cda}.  (The "
"smallest possible match here for @samp{[ad]*?} that permits the whole "
"expression to match is @samp{d}.)"
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:375
#, no-wrap
msgid "[ @dots{} ]"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:376
#, no-wrap
msgid "character alternative (in regexp)"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:377
#, no-wrap
msgid "@samp{[} in regexp"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:378
#, no-wrap
msgid "@samp{]} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:382
msgid ""
"is a @dfn{character alternative}, which begins with @samp{[} and is "
"terminated by @samp{]}.  In the simplest case, the characters between the "
"two brackets are what this character alternative can match."
msgstr ""

#. type: table
#: original_texis/searching.texi:387
msgid ""
"Thus, @samp{[ad]} matches either one @samp{a} or one @samp{d}, and "
"@samp{[ad]*} matches any string composed of just @samp{a}s and @samp{d}s "
"(including the empty string).  It follows that @samp{c[ad]*r} matches "
"@samp{cr}, @samp{car}, @samp{cdr}, @samp{caddaar}, etc."
msgstr ""

#. type: table
#: original_texis/searching.texi:396
msgid ""
"You can also include character ranges in a character alternative, by writing "
"the starting and ending characters with a @samp{-} between them.  Thus, "
"@samp{[a-z]} matches any lower-case @acronym{ASCII} letter.  Ranges may be "
"intermixed freely with individual characters, as in @samp{[a-z$%.]}, which "
"matches any lower case @acronym{ASCII} letter or @samp{$}, @samp{%} or "
"period.  However, the ending character of one range should not be the "
"starting point of another one; for example, @samp{[a-m-z]} should be "
"avoided."
msgstr ""

#. type: table
#: original_texis/searching.texi:404
msgid ""
"A character alternative can also specify named character classes "
"(@pxref{Char Classes}).  For example, @samp{[[:ascii:]]} matches any "
"@acronym{ASCII} character.  Using a character class is equivalent to "
"mentioning each of the characters in that class; but the latter is not "
"feasible in practice, since some classes include thousands of different "
"characters.  A character class should not appear as the lower or upper bound "
"of a range."
msgstr ""

#. type: table
#: original_texis/searching.texi:413
msgid ""
"The usual regexp special characters are not special inside a character "
"alternative.  A completely different set of characters is special: @samp{]}, "
"@samp{-} and @samp{^}.  To include @samp{]} in a character alternative, put "
"it at the beginning.  To include @samp{^}, put it anywhere but at the "
"beginning.  To include @samp{-}, put it at the end.  Thus, @samp{[]^-]} "
"matches all three of these special characters.  You cannot use @samp{\\} to "
"escape these three characters, since @samp{\\} is not special here."
msgstr ""

#. type: table
#: original_texis/searching.texi:417
msgid ""
"The following aspects of ranges are specific to Emacs, in that POSIX allows "
"but does not require this behavior and programs other than Emacs may behave "
"differently:"
msgstr ""

#. type: enumerate
#: original_texis/searching.texi:422
msgid ""
"If @code{case-fold-search} is non-@code{nil}, @samp{[a-z]} also matches "
"upper-case letters."
msgstr ""

#. type: enumerate
#: original_texis/searching.texi:428
msgid ""
"A range is not affected by the locale's collation sequence: it always "
"represents the set of characters with codepoints ranging between those of "
"its bounds, so that @samp{[a-z]} matches only ASCII letters, even outside "
"the C or POSIX locale."
msgstr ""

#. type: enumerate
#: original_texis/searching.texi:437
msgid ""
"If the lower bound of a range is greater than its upper bound, the range is "
"empty and represents no characters.  Thus, @samp{[z-a]} always fails to "
"match, and @samp{[^z-a]} matches any character, including newline.  However, "
"a reversed range should always be from the letter @samp{z} to the letter "
"@samp{a} to make it clear that it is not a typo; for example, @samp{[+-*/]} "
"should be avoided, because it matches only @samp{/} rather than the "
"likely-intended four characters."
msgstr ""

#. type: enumerate
#: original_texis/searching.texi:444
msgid ""
"If the end points of a range are raw 8-bit bytes (@pxref{Text "
"Representations}), or if the range start is ASCII and the end is a raw byte "
"(as in @samp{[a-\\377]}), the range will match only ASCII characters and raw "
"8-bit bytes, but not non-ASCII characters.  This feature is intended for "
"searching text in unibyte buffers and strings."
msgstr ""

#. type: table
#: original_texis/searching.texi:448
msgid ""
"Some kinds of character alternatives are not the best style even though they "
"have a well-defined meaning in Emacs.  They include:"
msgstr ""

#. type: enumerate
#: original_texis/searching.texi:458
msgid ""
"Although a range's bound can be almost any character, it is better style to "
"stay within natural sequences of ASCII letters and digits because most "
"people have not memorized character code tables.  For example, @samp{[.-9]} "
"is less clear than @samp{[./0-9]}, and @samp{[`-~]} is less clear than "
"@samp{[`a-z@{|@}~]}.  Unicode character escapes can help here; for example, "
"for most programmers @samp{[ก-ฺ฿-๛]} is less clear than "
"@samp{[\\u0E01-\\u0E3A\\u0E3F-\\u0E5B]}."
msgstr ""

#. type: enumerate
#: original_texis/searching.texi:463
msgid ""
"Although a character alternative can include duplicates, it is better style "
"to avoid them.  For example, @samp{[XYa-yYb-zX]} is less clear than "
"@samp{[XYa-z]}."
msgstr ""

#. type: enumerate
#: original_texis/searching.texi:469
msgid ""
"Although a range can denote just one, two, or three characters, it is "
"simpler to list the characters.  For example, @samp{[a-a0]} is less clear "
"than @samp{[a0]}, @samp{[i-j]} is less clear than @samp{[ij]}, and "
"@samp{[i-k]} is less clear than @samp{[ijk]}."
msgstr ""

#. type: enumerate
#: original_texis/searching.texi:476
msgid ""
"Although a @samp{-} can appear at the beginning of a character alternative "
"or as the upper bound of a range, it is better style to put @samp{-} by "
"itself at the end of a character alternative.  For example, although "
"@samp{[-a-z]} is valid, @samp{[a-z-]} is better style; and although "
"@samp{[*--]} is valid, @samp{[*+,-]} is clearer."
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:478
#, no-wrap
msgid "[^ @dots{} ]"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:479
#, no-wrap
msgid "@samp{^} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:484
msgid ""
"@samp{[^} begins a @dfn{complemented character alternative}.  This matches "
"any character except the ones specified.  Thus, @samp{[^a-z0-9A-Z]} matches "
"all characters @emph{except} ASCII letters and digits."
msgstr ""

#. type: table
#: original_texis/searching.texi:488
msgid ""
"@samp{^} is not special in a character alternative unless it is the first "
"character.  The character following the @samp{^} is treated as if it were "
"first (in other words, @samp{-} and @samp{]} are not special there)."
msgstr ""

#. type: table
#: original_texis/searching.texi:492
msgid ""
"A complemented character alternative can match a newline, unless newline is "
"mentioned as one of the characters not to match.  This is in contrast to the "
"handling of regexps in programs such as @code{grep}."
msgstr ""

#. type: table
#: original_texis/searching.texi:496
msgid ""
"You can specify named character classes, just like in character "
"alternatives.  For instance, @samp{[^[:ascii:]]} matches any "
"non-@acronym{ASCII} character.  @xref{Char Classes}."
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:497
#, no-wrap
msgid "^"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:498
#, no-wrap
msgid "beginning of line in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:504
msgid ""
"When matching a buffer, @samp{^} matches the empty string, but only at the "
"beginning of a line in the text being matched (or the beginning of the "
"accessible portion of the buffer).  Otherwise it fails to match anything.  "
"Thus, @samp{^foo} matches a @samp{foo} that occurs at the beginning of a "
"line."
msgstr ""

#. type: table
#: original_texis/searching.texi:507
msgid ""
"When matching a string instead of a buffer, @samp{^} matches at the "
"beginning of the string or after a newline character."
msgstr ""

#. type: table
#: original_texis/searching.texi:511
msgid ""
"For historical compatibility reasons, @samp{^} can be used only at the "
"beginning of the regular expression, or after @samp{\\(}, @samp{\\(?:} or "
"@samp{\\|}."
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:512
#, no-wrap
msgid "$"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:513
#, no-wrap
msgid "@samp{$} in regexp"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:514
#, no-wrap
msgid "end of line in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:518
msgid ""
"is similar to @samp{^} but matches only at the end of a line (or the end of "
"the accessible portion of the buffer).  Thus, @samp{x+$} matches a string of "
"one @samp{x} or more at the end of a line."
msgstr ""

#. type: table
#: original_texis/searching.texi:521
msgid ""
"When matching a string instead of a buffer, @samp{$} matches at the end of "
"the string or before a newline character."
msgstr ""

#. type: table
#: original_texis/searching.texi:524
msgid ""
"For historical compatibility reasons, @samp{$} can be used only at the end "
"of the regular expression, or before @samp{\\)} or @samp{\\|}."
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:525
#, no-wrap
msgid "\\"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:526
#, no-wrap
msgid "@samp{\\} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:529
msgid ""
"has two functions: it quotes the special characters (including @samp{\\}), "
"and it introduces additional special constructs."
msgstr ""

#. type: table
#: original_texis/searching.texi:533
msgid ""
"Because @samp{\\} quotes special characters, @samp{\\$} is a regular "
"expression that matches only @samp{$}, and @samp{\\[} is a regular "
"expression that matches only @samp{[}, and so on."
msgstr ""

#. type: table
#: original_texis/searching.texi:541
msgid ""
"Note that @samp{\\} also has special meaning in the read syntax of Lisp "
"strings (@pxref{String Type}), and must be quoted with @samp{\\}.  For "
"example, the regular expression that matches the @samp{\\} character is "
"@samp{\\\\}.  To write a Lisp string that contains the characters "
"@samp{\\\\}, Lisp syntax requires you to quote each @samp{\\} with another "
"@samp{\\}.  Therefore, the read syntax for a regular expression matching "
"@samp{\\} is @code{\"\\\\\\\\\"}."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:549
msgid ""
"@strong{Please note:} For historical compatibility, special characters are "
"treated as ordinary ones if they are in contexts where their special "
"meanings make no sense.  For example, @samp{*foo} treats @samp{*} as "
"ordinary since there is no preceding expression on which the @samp{*} can "
"act.  It is poor practice to depend on this behavior; quote the special "
"character anyway, regardless of where it appears."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:557
msgid ""
"As a @samp{\\} is not special inside a character alternative, it can never "
"remove the special meaning of @samp{-}, @samp{^} or @samp{]}.  You should "
"not quote these characters when they have no special meaning.  This would "
"not clarify anything, since backslashes can legitimately precede these "
"characters where they @emph{have} special meaning, as in @samp{[^\\]} "
"(@code{\"[^\\\\]\"} for Lisp string syntax), which matches any single "
"character except a backslash."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:567
msgid ""
"In practice, most @samp{]} that occur in regular expressions close a "
"character alternative and hence are special.  However, occasionally a "
"regular expression may try to match a complex pattern of literal @samp{[} "
"and @samp{]}.  In such situations, it sometimes may be necessary to "
"carefully parse the regexp from the start to determine which square brackets "
"enclose a character alternative.  For example, @samp{[^][]]} consists of the "
"complemented character alternative @samp{[^][]} (which matches any single "
"character that is not a square bracket), followed by a literal @samp{]}."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:577
msgid ""
"The exact rules are that at the beginning of a regexp, @samp{[} is special "
"and @samp{]} not.  This lasts until the first unquoted @samp{[}, after which "
"we are in a character alternative; @samp{[} is no longer special (except "
"when it starts a character class) but @samp{]} is special, unless it "
"immediately follows the special @samp{[} or that @samp{[} followed by a "
"@samp{^}.  This lasts until the next special @samp{]} that does not end a "
"character class.  This ends the character alternative and restores the "
"ordinary syntax of regular expressions; an unquoted @samp{[} is special "
"again and a @samp{]} not."
msgstr ""

#. type: subsubsection
#: original_texis/searching.texi:579
#, no-wrap
msgid "Character Classes"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:580
#, no-wrap
msgid "character classes in regexp"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:581
#, no-wrap
msgid "ascii character class, regexp"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:582
#, no-wrap
msgid "alnum character class, regexp"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:583
#, no-wrap
msgid "alpha character class, regexp"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:584
#, no-wrap
msgid "xdigit character class, regexp"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:593
msgid ""
"Below is a table of the classes you can use in a character alternative, and "
"what they mean.  Note that the @samp{[} and @samp{]} characters that enclose "
"the class name are part of the name, so a regular expression using these "
"classes needs one more pair of brackets.  For example, a regular expression "
"matching a sequence of one or more letters and digits would be "
"@samp{[[:alnum:]]+}, not @samp{[:alnum:]+}."
msgstr ""

#. type: item
#: original_texis/searching.texi:595
#, no-wrap
msgid "[:ascii:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:597
msgid "This matches any @acronym{ASCII} character (codes 0--127)."
msgstr ""

#. type: item
#: original_texis/searching.texi:597
#, no-wrap
msgid "[:alnum:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:602
msgid ""
"This matches any letter or digit.  For multibyte characters, it matches "
"characters whose Unicode @samp{general-category} property (@pxref{Character "
"Properties}) indicates they are alphabetic or decimal number characters."
msgstr ""

#. type: item
#: original_texis/searching.texi:602
#, no-wrap
msgid "[:alpha:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:607
msgid ""
"This matches any letter.  For multibyte characters, it matches characters "
"whose Unicode @samp{general-category} property (@pxref{Character "
"Properties}) indicates they are alphabetic characters."
msgstr ""

#. type: item
#: original_texis/searching.texi:607
#, no-wrap
msgid "[:blank:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:613
msgid ""
"This matches horizontal whitespace, as defined by Annex C of the Unicode "
"Technical Standard #18.  In particular, it matches spaces, tabs, and other "
"characters whose Unicode @samp{general-category} property (@pxref{Character "
"Properties}) indicates they are spacing separators."
msgstr ""

#. type: item
#: original_texis/searching.texi:613
#, no-wrap
msgid "[:cntrl:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:615
msgid "This matches any character whose code is in the range 0--31."
msgstr ""

#. type: item
#: original_texis/searching.texi:615
#, no-wrap
msgid "[:digit:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:618
msgid ""
"This matches @samp{0} through @samp{9}.  Thus, @samp{[-+[:digit:]]} matches "
"any digit, as well as @samp{+} and @samp{-}."
msgstr ""

#. type: item
#: original_texis/searching.texi:618
#, no-wrap
msgid "[:graph:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:624
msgid ""
"This matches graphic characters---everything except spaces, @acronym{ASCII} "
"and non-@acronym{ASCII} control characters, surrogates, and codepoints "
"unassigned by Unicode, as indicated by the Unicode @samp{general-category} "
"property (@pxref{Character Properties})."
msgstr ""

#. type: item
#: original_texis/searching.texi:624
#, no-wrap
msgid "[:lower:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:630
msgid ""
"This matches any lower-case letter, as determined by the current case table "
"(@pxref{Case Tables}).  If @code{case-fold-search} is non-@code{nil}, this "
"also matches any upper-case letter.  Note that a buffer can have its own "
"local case table different from the default one."
msgstr ""

#. type: item
#: original_texis/searching.texi:630
#, no-wrap
msgid "[:multibyte:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:632
msgid "This matches any multibyte character (@pxref{Text Representations})."
msgstr ""

#. type: item
#: original_texis/searching.texi:632
#, no-wrap
msgid "[:nonascii:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:634
msgid "This matches any non-@acronym{ASCII} character."
msgstr ""

#. type: item
#: original_texis/searching.texi:634
#, no-wrap
msgid "[:print:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:637
msgid ""
"This matches any printing character---either spaces or graphic characters "
"matched by @samp{[:graph:]}."
msgstr ""

#. type: item
#: original_texis/searching.texi:637
#, no-wrap
msgid "[:punct:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:642
msgid ""
"This matches any punctuation character.  (At present, for multibyte "
"characters, it matches anything that has non-word syntax, and thus its exact "
"definition can vary from one major mode to another, since the syntax of a "
"character depends on the major mode.)"
msgstr ""

#. type: item
#: original_texis/searching.texi:642
#, no-wrap
msgid "[:space:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:647
msgid ""
"This matches any character that has whitespace syntax (@pxref{Syntax Class "
"Table}).  Note that the syntax of a character, and thus which characters are "
"considered ``whitespace'', depends on the major mode."
msgstr ""

#. type: item
#: original_texis/searching.texi:647
#, no-wrap
msgid "[:unibyte:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:649
msgid "This matches any unibyte character (@pxref{Text Representations})."
msgstr ""

#. type: item
#: original_texis/searching.texi:649
#, no-wrap
msgid "[:upper:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:655
msgid ""
"This matches any upper-case letter, as determined by the current case table "
"(@pxref{Case Tables}).  If @code{case-fold-search} is non-@code{nil}, this "
"also matches any lower-case letter.  Note that a buffer can have its own "
"local case table different from the default one."
msgstr ""

#. type: item
#: original_texis/searching.texi:655
#, no-wrap
msgid "[:word:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:660
msgid ""
"This matches any character that has word syntax (@pxref{Syntax Class "
"Table}).  Note that the syntax of a character, and thus which characters are "
"considered ``word-constituent'', depends on the major mode."
msgstr ""

#. type: item
#: original_texis/searching.texi:660
#, no-wrap
msgid "[:xdigit:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:663
msgid ""
"This matches the hexadecimal digits: @samp{0} through @samp{9}, @samp{a} "
"through @samp{f} and @samp{A} through @samp{F}."
msgstr ""

#. type: subsubsection
#: original_texis/searching.texi:666
#, no-wrap
msgid "Backslash Constructs in Regular Expressions"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:667
#, no-wrap
msgid "backslash in regular expressions"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:673
msgid ""
"For the most part, @samp{\\} followed by any character matches only that "
"character.  However, there are several exceptions: certain sequences "
"starting with @samp{\\} that have special meanings.  Here is a table of the "
"special @samp{\\} constructs."
msgstr ""

#. type: item
#: original_texis/searching.texi:675
#, no-wrap
msgid "\\|"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:676
#, no-wrap
msgid "@samp{|} in regexp"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:677
#, no-wrap
msgid "regexp alternative"
msgstr ""

#. type: table
#: original_texis/searching.texi:682
msgid ""
"specifies an alternative.  Two regular expressions @var{a} and @var{b} with "
"@samp{\\|} in between form an expression that matches anything that either "
"@var{a} or @var{b} matches."
msgstr ""

#. type: table
#: original_texis/searching.texi:685
msgid ""
"Thus, @samp{foo\\|bar} matches either @samp{foo} or @samp{bar} but no other "
"string."
msgstr ""

#. type: table
#: original_texis/searching.texi:689
msgid ""
"@samp{\\|} applies to the largest possible surrounding expressions.  Only a "
"surrounding @samp{\\( @dots{} \\)} grouping can limit the grouping power of "
"@samp{\\|}."
msgstr ""

#. type: table
#: original_texis/searching.texi:693
msgid ""
"If you need full backtracking capability to handle multiple uses of "
"@samp{\\|}, use the POSIX regular expression functions (@pxref{POSIX "
"Regexps})."
msgstr ""

#. type: item
#: original_texis/searching.texi:694
#, no-wrap
msgid "\\@{@var{m}\\@}"
msgstr ""

#. type: table
#: original_texis/searching.texi:699
msgid ""
"is a postfix operator that repeats the previous pattern exactly @var{m} "
"times.  Thus, @samp{x\\@{5\\@}} matches the string @samp{xxxxx} and nothing "
"else.  @samp{c[ad]\\@{3\\@}r} matches string such as @samp{caaar}, "
"@samp{cdddr}, @samp{cadar}, and so on."
msgstr ""

#. type: item
#: original_texis/searching.texi:700
#, no-wrap
msgid "\\@{@var{m},@var{n}\\@}"
msgstr ""

#. type: table
#: original_texis/searching.texi:706
msgid ""
"is a more general postfix operator that specifies repetition with a minimum "
"of @var{m} repeats and a maximum of @var{n} repeats.  If @var{m} is omitted, "
"the minimum is 0; if @var{n} is omitted, there is no maximum.  For both "
"forms, @var{m} and @var{n}, if specified, may be no larger than"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:708
msgid "2**16 @minus{} 1"
msgstr ""

#. type: tex
#: original_texis/searching.texi:711
#, no-wrap
msgid "@math{2^{16}-1}\n"
msgstr ""

#. type: table
#: original_texis/searching.texi:713
msgid "."
msgstr ""

#. type: table
#: original_texis/searching.texi:720
msgid ""
"For example, @samp{c[ad]\\@{1,2\\@}r} matches the strings @samp{car}, "
"@samp{cdr}, @samp{caar}, @samp{cadr}, @samp{cdar}, and @samp{cddr}, and "
"nothing else.@* @samp{\\@{0,1\\@}} or @samp{\\@{,1\\@}} is equivalent to "
"@samp{?}.@* @samp{\\@{0,\\@}} or @samp{\\@{,\\@}} is equivalent to "
"@samp{*}.@* @samp{\\@{1,\\@}} is equivalent to @samp{+}."
msgstr ""

#. type: item
#: original_texis/searching.texi:721
#, no-wrap
msgid "\\( @dots{} \\)"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:722
#, no-wrap
msgid "@samp{(} in regexp"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:723
#, no-wrap
msgid "@samp{)} in regexp"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:724
#, no-wrap
msgid "regexp grouping"
msgstr ""

#. type: table
#: original_texis/searching.texi:726
msgid "is a grouping construct that serves three purposes:"
msgstr ""

#. type: enumerate
#: original_texis/searching.texi:732
msgid ""
"To enclose a set of @samp{\\|} alternatives for other operations.  Thus, the "
"regular expression @samp{\\(foo\\|bar\\)x} matches either @samp{foox} or "
"@samp{barx}."
msgstr ""

#. type: enumerate
#: original_texis/searching.texi:738
msgid ""
"To enclose a complicated expression for the postfix operators @samp{*}, "
"@samp{+} and @samp{?} to operate on.  Thus, @samp{ba\\(na\\)*} matches "
"@samp{ba}, @samp{bana}, @samp{banana}, @samp{bananana}, etc., with any "
"number (zero or more) of @samp{na} strings."
msgstr ""

#. type: enumerate
#: original_texis/searching.texi:742
msgid ""
"To record a matched substring for future reference with @samp{\\@var{digit}} "
"(see below)."
msgstr ""

#. type: table
#: original_texis/searching.texi:750
msgid ""
"This last application is not a consequence of the idea of a parenthetical "
"grouping; it is a separate feature that was assigned as a second meaning to "
"the same @samp{\\( @dots{} \\)} construct because, in practice, there was "
"usually no conflict between the two meanings.  But occasionally there is a "
"conflict, and that led to the introduction of shy groups."
msgstr ""

#. type: item
#: original_texis/searching.texi:751
#, no-wrap
msgid "\\(?: @dots{} \\)"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:752
#, no-wrap
msgid "shy groups"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:753
#, no-wrap
msgid "non-capturing group"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:754
#, no-wrap
msgid "unnumbered group"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:755
#, no-wrap
msgid "@samp{(?:} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:763
msgid ""
"is the @dfn{shy group} construct.  A shy group serves the first two purposes "
"of an ordinary group (controlling the nesting of other operators), but it "
"does not get a number, so you cannot refer back to its value with "
"@samp{\\@var{digit}}.  Shy groups are particularly useful for "
"mechanically-constructed regular expressions, because they can be added "
"automatically without altering the numbering of ordinary, non-shy groups."
msgstr ""

#. type: table
#: original_texis/searching.texi:766
msgid "Shy groups are also called @dfn{non-capturing} or @dfn{unnumbered groups}."
msgstr ""

#. type: item
#: original_texis/searching.texi:767
#, no-wrap
msgid "\\(?@var{num}: @dots{} \\)"
msgstr ""

#. type: table
#: original_texis/searching.texi:776
msgid ""
"is the @dfn{explicitly numbered group} construct.  Normal groups get their "
"number implicitly, based on their position, which can be inconvenient.  This "
"construct allows you to force a particular group number.  There is no "
"particular restriction on the numbering, e.g., you can have several groups "
"with the same number in which case the last one to match (i.e., the "
"rightmost match) will win.  Implicitly numbered groups always get the "
"smallest integer larger than the one of any previous group."
msgstr ""

#. type: item
#: original_texis/searching.texi:777
#, no-wrap
msgid "\\@var{digit}"
msgstr ""

#. type: table
#: original_texis/searching.texi:780
msgid ""
"matches the same text that matched the @var{digit}th occurrence of a "
"grouping (@samp{\\( @dots{} \\)}) construct."
msgstr ""

#. type: table
#: original_texis/searching.texi:785
msgid ""
"In other words, after the end of a group, the matcher remembers the "
"beginning and end of the text matched by that group.  Later on in the "
"regular expression you can use @samp{\\} followed by @var{digit} to match "
"that same text, whatever it may have been."
msgstr ""

#. type: table
#: original_texis/searching.texi:792
msgid ""
"The strings matching the first nine grouping constructs appearing in the "
"entire regular expression passed to a search or matching function are "
"assigned numbers 1 through 9 in the order that the open parentheses appear "
"in the regular expression.  So you can use @samp{\\1} through @samp{\\9} to "
"refer to the text matched by the corresponding grouping constructs."
msgstr ""

#. type: table
#: original_texis/searching.texi:797
msgid ""
"For example, @samp{\\(.*\\)\\1} matches any newline-free string that is "
"composed of two identical halves.  The @samp{\\(.*\\)} matches the first "
"half, which may be anything, but the @samp{\\1} that follows must match the "
"same exact text."
msgstr ""

#. type: table
#: original_texis/searching.texi:801
msgid ""
"If a @samp{\\( @dots{} \\)} construct matches more than once (which can "
"happen, for instance, if it is followed by @samp{*}), only the last match is "
"recorded."
msgstr ""

#. type: table
#: original_texis/searching.texi:811
msgid ""
"If a particular grouping construct in the regular expression was never "
"matched---for instance, if it appears inside of an alternative that wasn't "
"used, or inside of a repetition that repeated zero times---then the "
"corresponding @samp{\\@var{digit}} construct never matches anything.  To use "
"an artificial example, @samp{\\(foo\\(b*\\)\\|lose\\)\\2} cannot match "
"@samp{lose}: the second alternative inside the larger group matches it, but "
"then @samp{\\2} is undefined and can't match anything.  But it can match "
"@samp{foobb}, because the first alternative matches @samp{foob} and "
"@samp{\\2} matches @samp{b}."
msgstr ""

#. type: item
#: original_texis/searching.texi:812
#, no-wrap
msgid "\\w"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:813
#, no-wrap
msgid "@samp{\\w} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:816
msgid ""
"matches any word-constituent character.  The editor syntax table determines "
"which characters these are.  @xref{Syntax Tables}."
msgstr ""

#. type: item
#: original_texis/searching.texi:817
#, no-wrap
msgid "\\W"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:818
#, no-wrap
msgid "@samp{\\W} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:820
msgid "matches any character that is not a word constituent."
msgstr ""

#. type: item
#: original_texis/searching.texi:821
#, no-wrap
msgid "\\s@var{code}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:822
#, no-wrap
msgid "@samp{\\s} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:829
msgid ""
"matches any character whose syntax is @var{code}.  Here @var{code} is a "
"character that represents a syntax code: thus, @samp{w} for word "
"constituent, @samp{-} for whitespace, @samp{(} for open parenthesis, etc.  "
"To represent whitespace syntax, use either @samp{-} or a space character.  "
"@xref{Syntax Class Table}, for a list of syntax codes and the characters "
"that stand for them."
msgstr ""

#. type: item
#: original_texis/searching.texi:830
#, no-wrap
msgid "\\S@var{code}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:831
#, no-wrap
msgid "@samp{\\S} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:833
msgid "matches any character whose syntax is not @var{code}."
msgstr ""

#. type: cindex
#: original_texis/searching.texi:834
#, no-wrap
msgid "category, regexp search for"
msgstr ""

#. type: item
#: original_texis/searching.texi:835
#, no-wrap
msgid "\\c@var{code}"
msgstr ""

#. type: table
#: original_texis/searching.texi:844
msgid ""
"matches any character whose category is @var{code}.  Here @var{code} is a "
"character that represents a category: for example, in the standard category "
"table, @samp{c} stands for Chinese characters and @samp{g} stands for Greek "
"characters.  You can see the list of all the currently defined categories "
"with @w{@kbd{M-x describe-categories @key{RET}}}.  You can also define your "
"own categories in addition to the standard ones using the "
"@code{define-category} function (@pxref{Categories})."
msgstr ""

#. type: item
#: original_texis/searching.texi:845
#, no-wrap
msgid "\\C@var{code}"
msgstr ""

#. type: table
#: original_texis/searching.texi:847
msgid "matches any character whose category is not @var{code}."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:854
msgid ""
"The following regular expression constructs match the empty string---that "
"is, they don't consume any characters---but whether they match depends on "
"the context.  For all, the beginning and end of the accessible portion of "
"the buffer are treated as if they were the actual beginning and end of the "
"buffer."
msgstr ""

#. type: item
#: original_texis/searching.texi:856
#, no-wrap
msgid "\\`"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:857
#, no-wrap
msgid "@samp{\\`} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:860
msgid ""
"matches the empty string, but only at the beginning of the buffer or string "
"being matched against."
msgstr ""

#. type: item
#: original_texis/searching.texi:861
#, no-wrap
msgid "\\'"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:862
#, no-wrap
msgid "@samp{\\'} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:865
msgid ""
"matches the empty string, but only at the end of the buffer or string being "
"matched against."
msgstr ""

#. type: item
#: original_texis/searching.texi:866
#, no-wrap
msgid "\\="
msgstr ""

#. type: cindex
#: original_texis/searching.texi:867
#, no-wrap
msgid "@samp{\\=} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:870
msgid ""
"matches the empty string, but only at point.  (This construct is not defined "
"when matching against a string.)"
msgstr ""

#. type: item
#: original_texis/searching.texi:871
#, no-wrap
msgid "\\b"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:872
#, no-wrap
msgid "@samp{\\b} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:877
msgid ""
"matches the empty string, but only at the beginning or end of a word.  Thus, "
"@samp{\\bfoo\\b} matches any occurrence of @samp{foo} as a separate word.  "
"@samp{\\bballs?\\b} matches @samp{ball} or @samp{balls} as a separate word."
msgstr ""

#. type: table
#: original_texis/searching.texi:880
msgid ""
"@samp{\\b} matches at the beginning or end of the buffer (or string)  "
"regardless of what text appears next to it."
msgstr ""

#. type: item
#: original_texis/searching.texi:881
#, no-wrap
msgid "\\B"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:882
#, no-wrap
msgid "@samp{\\B} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:885
msgid ""
"matches the empty string, but @emph{not} at the beginning or end of a word, "
"nor at the beginning or end of the buffer (or string)."
msgstr ""

#. type: item
#: original_texis/searching.texi:886
#, no-wrap
msgid "\\<"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:887
#, no-wrap
msgid "@samp{\\<} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:891
msgid ""
"matches the empty string, but only at the beginning of a word.  @samp{\\<} "
"matches at the beginning of the buffer (or string) only if a "
"word-constituent character follows."
msgstr ""

#. type: item
#: original_texis/searching.texi:892
#, no-wrap
msgid "\\>"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:893
#, no-wrap
msgid "@samp{\\>} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:897
msgid ""
"matches the empty string, but only at the end of a word.  @samp{\\>} matches "
"at the end of the buffer (or string) only if the contents end with a "
"word-constituent character."
msgstr ""

#. type: item
#: original_texis/searching.texi:898
#, no-wrap
msgid "\\_<"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:899
#, no-wrap
msgid "@samp{\\_<} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:904
msgid ""
"matches the empty string, but only at the beginning of a symbol.  A symbol "
"is a sequence of one or more word or symbol constituent characters.  "
"@samp{\\_<} matches at the beginning of the buffer (or string) only if a "
"symbol-constituent character follows."
msgstr ""

#. type: item
#: original_texis/searching.texi:905
#, no-wrap
msgid "\\_>"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:906
#, no-wrap
msgid "@samp{\\_>} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:910
msgid ""
"matches the empty string, but only at the end of a symbol.  @samp{\\_>} "
"matches at the end of the buffer (or string) only if the contents end with a "
"symbol-constituent character."
msgstr ""

#. type: kindex
#: original_texis/searching.texi:912
#, no-wrap
msgid "invalid-regexp"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:918
msgid ""
"Not every string is a valid regular expression.  For example, a string that "
"ends inside a character alternative without a terminating @samp{]} is "
"invalid, and so is a string that ends with a single @samp{\\}.  If an "
"invalid regular expression is passed to any of the search functions, an "
"@code{invalid-regexp} error is signaled."
msgstr ""

#. type: subsection
#: original_texis/searching.texi:920
#, no-wrap
msgid "Complex Regexp Example"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:927
msgid ""
"Here is a complicated regexp which was formerly used by Emacs to recognize "
"the end of a sentence together with any whitespace that follows.  (Nowadays "
"Emacs uses a similar but more complex default regexp constructed by the "
"function @code{sentence-end}.  @xref{Standard Regexps}.)"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:934
msgid ""
"Below, we show first the regexp as a string in Lisp syntax (to distinguish "
"spaces from tab characters), and then the result of evaluating it.  The "
"string constant begins and ends with a double-quote.  @samp{\\\"} stands for "
"a double-quote as part of the string, @samp{\\\\} for a backslash as part of "
"the string, @samp{\\t} for a tab and @samp{\\n} for a newline."
msgstr ""

#. type: group
#: original_texis/searching.texi:940
#, no-wrap
msgid ""
"\"[.?!][]\\\"')@}]*\\\\($\\\\| $\\\\|\\t\\\\|@ @ \\\\)[ \\t\\n]*\"\n"
"     @result{} \"[.?!][]\\\"')@}]*\\\\($\\\\| $\\\\|  \\\\|@ @ \\\\)[\n"
"]*\"\n"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:945
msgid "In the output, tab and newline appear as themselves."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:948
msgid ""
"This regular expression contains four parts in succession and can be "
"deciphered as follows:"
msgstr ""

#. type: item
#: original_texis/searching.texi:950
#, no-wrap
msgid "[.?!]"
msgstr ""

#. type: table
#: original_texis/searching.texi:957
msgid ""
"The first part of the pattern is a character alternative that matches any "
"one of three characters: period, question mark, and exclamation mark.  The "
"match must begin with one of these three characters.  (This is one point "
"where the new default regexp used by Emacs differs from the old.  The new "
"value also allows some non-@acronym{ASCII} characters that end a sentence "
"without any following whitespace.)"
msgstr ""

#. type: item
#: original_texis/searching.texi:958
#, no-wrap
msgid "[]\\\"')@}]*"
msgstr ""

#. type: table
#: original_texis/searching.texi:965
msgid ""
"The second part of the pattern matches any closing braces and quotation "
"marks, zero or more of them, that may follow the period, question mark or "
"exclamation mark.  The @code{\\\"} is Lisp syntax for a double-quote in a "
"string.  The @samp{*} at the end indicates that the immediately preceding "
"regular expression (a character alternative, in this case) may be repeated "
"zero or more times."
msgstr ""

#. type: item
#: original_texis/searching.texi:966
#, no-wrap
msgid "\\\\($\\\\|@ $\\\\|\\t\\\\|@ @ \\\\)"
msgstr ""

#. type: table
#: original_texis/searching.texi:973
msgid ""
"The third part of the pattern matches the whitespace that follows the end of "
"a sentence: the end of a line (optionally with a space), or a tab, or two "
"spaces.  The double backslashes mark the parentheses and vertical bars as "
"regular expression syntax; the parentheses delimit a group and the vertical "
"bars separate alternatives.  The dollar sign is used to match the end of a "
"line."
msgstr ""

#. type: item
#: original_texis/searching.texi:974
#, no-wrap
msgid "[ \\t\\n]*"
msgstr ""

#. type: table
#: original_texis/searching.texi:977
msgid ""
"Finally, the last part of the pattern matches any additional whitespace "
"beyond the minimum needed to end a sentence."
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:981
msgid "In the @code{rx} notation (@pxref{Rx Notation}), the regexp could be written"
msgstr ""

#. type: group
#: original_texis/searching.texi:991
#, no-wrap
msgid ""
"(rx (any \".?!\")                    ; Punctuation ending sentence.\n"
"    (zero-or-more (any \"\\\"')]@}\"))  ; Closing quotes or brackets.\n"
"    (or line-end\n"
"        (seq \" \" line-end)\n"
"        \"\\t\"\n"
"        \"  \")                      ; Two spaces.\n"
"    (zero-or-more (any \"\\t\\n \")))  ; Optional extra whitespace.\n"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:996
msgid ""
"Since @code{rx} regexps are just S-expressions, they can be formatted and "
"commented as such."
msgstr ""

#. type: node
#: original_texis/searching.texi:999
#, no-wrap
msgid "Rx Notation"
msgstr ""

#. type: subsection
#: original_texis/searching.texi:1000
#, no-wrap
msgid "The @code{rx} Structured Regexp Notation"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1001
#, no-wrap
msgid "rx"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1012
msgid ""
"As an alternative to the string-based syntax, Emacs provides the structured "
"@code{rx} notation based on Lisp S-expressions.  This notation is usually "
"easier to read, write and maintain than regexp strings, and can be indented "
"and commented freely.  It requires a conversion into string form since that "
"is what regexp functions expect, but that conversion typically takes place "
"during byte-compilation rather than when the Lisp code using the regexp is "
"run."
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1017
msgid ""
"Here is an @code{rx} regexp@footnote{It could be written much simpler with "
"non-greedy operators (how?), but that would make the example less "
"interesting.} that matches a block comment in the C programming language:"
msgstr ""

#. type: group
#: original_texis/searching.texi:1027
#, no-wrap
msgid ""
"(rx \"/*\"                          ; Initial /*\n"
"    (zero-or-more\n"
"     (or (not (any \"*\"))          ;  Either non-*,\n"
"         (seq \"*\"                 ;  or * followed by\n"
"              (not (any \"/\")))))  ;  non-/\n"
"    (one-or-more \"*\")             ; At least one star,\n"
"    \"/\")                          ; and the final /\n"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1032
msgid "or, using shorter synonyms and written more compactly,"
msgstr ""

#. type: group
#: original_texis/searching.texi:1039
#, no-wrap
msgid ""
"(rx \"/*\"\n"
"    (* (| (not \"*\")\n"
"          (: \"*\" (not \"/\"))))\n"
"    (+ \"*\") \"/\")\n"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1044
msgid "In conventional string syntax, it would be written"
msgstr ""

#. type: example
#: original_texis/searching.texi:1047
#, no-wrap
msgid "\"/\\\\*\\\\(?:[^*]\\\\|\\\\*[^/]\\\\)*\\\\*+/\"\n"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1053
msgid ""
"The @code{rx} notation is mainly useful in Lisp code; it cannot be used in "
"most interactive situations where a regexp is requested, such as when "
"running @code{query-replace-regexp} or in variable customization."
msgstr ""

#. type: node
#: original_texis/searching.texi:1058 original_texis/searching.texi:1060
#, no-wrap
msgid "Rx Constructs"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:1058
msgid "Constructs valid in rx forms."
msgstr ""

#. type: node
#: original_texis/searching.texi:1058 original_texis/searching.texi:1552
#, no-wrap
msgid "Rx Functions"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:1058
msgid "Functions and macros that use rx forms."
msgstr ""

#. type: node
#: original_texis/searching.texi:1058 original_texis/searching.texi:1593
#, no-wrap
msgid "Extending Rx"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:1058
msgid "How to define your own rx forms."
msgstr ""

#. type: subsubsection
#: original_texis/searching.texi:1061
#, no-wrap
msgid "Constructs in @code{rx} regexps"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1068
msgid ""
"The various forms in @code{rx} regexps are described below.  The shorthand "
"@var{rx} represents any @code{rx} form.  @var{rx}@dots{} means zero or more "
"@code{rx} forms and, unless stated otherwise, matches these forms in "
"sequence as if wrapped in a @code{(seq @dots{})} subform."
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1073
msgid ""
"These are all valid arguments to the @code{rx} macro.  All forms are defined "
"by their described semantics; the corresponding string regexps are provided "
"for ease of understanding only.  @var{A}, @var{B}, @dots{} denote (suitably "
"bracketed) string regexp subexpressions therein."
msgstr ""

#. type: subsubheading
#: original_texis/searching.texi:1074
#, no-wrap
msgid "Literals"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1077
#, no-wrap
msgid "\"some-string\""
msgstr ""

#. type: table
#: original_texis/searching.texi:1080
msgid ""
"Match the string @samp{some-string} literally.  There are no characters with "
"special meaning, unlike in string regexps."
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1081
#, no-wrap
msgid "?C"
msgstr ""

#. type: table
#: original_texis/searching.texi:1083
msgid "Match the character @samp{C} literally."
msgstr ""

#. type: subsubheading
#: original_texis/searching.texi:1085
#, no-wrap
msgid "Sequence and alternative"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1088
#, no-wrap
msgid "(seq @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1089
#, no-wrap
msgid "@code{seq} in rx"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1090
#, no-wrap
msgid "(sequence @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1091
#, no-wrap
msgid "@code{sequence} in rx"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1092
#, no-wrap
msgid "(: @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1093
#, no-wrap
msgid "@code{:} in rx"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1094
#, no-wrap
msgid "(and @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1095
#, no-wrap
msgid "@code{and} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1100
msgid ""
"Match the @var{rx}s in sequence.  Without arguments, the expression matches "
"the empty string.@* Corresponding string regexp: "
"@samp{@var{A}@var{B}@dots{}} (subexpressions in sequence)."
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1101
#, no-wrap
msgid "(or @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1102
#, no-wrap
msgid "@code{or} in rx"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1103
#, no-wrap
msgid "(| @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1104
#, no-wrap
msgid "@code{|} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1112
msgid ""
"Match exactly one of the @var{rx}s.  If all arguments are strings, "
"characters, or @code{or} forms so constrained, the longest possible match "
"will always be used.  Otherwise, either the longest match or the first (in "
"left-to-right order) will be used.  Without arguments, the expression will "
"not match anything at all.@* Corresponding string regexp: "
"@samp{@var{A}\\|@var{B}\\|@dots{}}."
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1113
#, no-wrap
msgid "unmatchable"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1114
#, no-wrap
msgid "@code{unmatchable} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1117
msgid "Refuse any match.  Equivalent to @code{(or)}.  @xref{regexp-unmatchable}."
msgstr ""

#. type: subsubheading
#: original_texis/searching.texi:1119
#, no-wrap
msgid "Repetition"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1124
msgid ""
"Normally, repetition forms are greedy, in that they attempt to match as many "
"times as possible.  Some forms are non-greedy; they try to match as few "
"times as possible (@pxref{Non-greedy repetition})."
msgstr ""

#. type: item
#: original_texis/searching.texi:1126
#, no-wrap
msgid "(zero-or-more @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1127
#, no-wrap
msgid "@code{zero-or-more} in rx"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:1128
#, no-wrap
msgid "(0+ @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1129
#, no-wrap
msgid "@code{0+} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1133
msgid ""
"Match the @var{rx}s zero or more times.  Greedy by default.@* Corresponding "
"string regexp: @samp{@var{A}*} (greedy), @samp{@var{A}*?} (non-greedy)"
msgstr ""

#. type: item
#: original_texis/searching.texi:1134
#, no-wrap
msgid "(one-or-more @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1135
#, no-wrap
msgid "@code{one-or-more} in rx"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:1136
#, no-wrap
msgid "(1+ @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1137
#, no-wrap
msgid "@code{1+} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1141
msgid ""
"Match the @var{rx}s one or more times.  Greedy by default.@* Corresponding "
"string regexp: @samp{@var{A}+} (greedy), @samp{@var{A}+?} (non-greedy)"
msgstr ""

#. type: item
#: original_texis/searching.texi:1142
#, no-wrap
msgid "(zero-or-one @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1143
#, no-wrap
msgid "@code{zero-or-one} in rx"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:1144
#, no-wrap
msgid "(optional @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1145
#, no-wrap
msgid "@code{optional} in rx"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:1146
#, no-wrap
msgid "(opt @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1147
#, no-wrap
msgid "@code{opt} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1151
msgid ""
"Match the @var{rx}s once or an empty string.  Greedy by default.@* "
"Corresponding string regexp: @samp{@var{A}?} (greedy), @samp{@var{A}??} "
"(non-greedy)."
msgstr ""

#. type: item
#: original_texis/searching.texi:1152
#, no-wrap
msgid "(* @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1153
#, no-wrap
msgid "@code{*} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1156
msgid ""
"Match the @var{rx}s zero or more times.  Greedy.@* Corresponding string "
"regexp: @samp{@var{A}*}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1157
#, no-wrap
msgid "(+ @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1158
#, no-wrap
msgid "@code{+} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1161
msgid ""
"Match the @var{rx}s one or more times.  Greedy.@* Corresponding string "
"regexp: @samp{@var{A}+}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1162
#, no-wrap
msgid "(? @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1163
#, no-wrap
msgid "@code{?} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1166
msgid ""
"Match the @var{rx}s once or an empty string.  Greedy.@* Corresponding string "
"regexp: @samp{@var{A}?}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1167
#, no-wrap
msgid "(*? @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1168
#, no-wrap
msgid "@code{*?} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1171
msgid ""
"Match the @var{rx}s zero or more times.  Non-greedy.@* Corresponding string "
"regexp: @samp{@var{A}*?}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1172
#, no-wrap
msgid "(+? @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1173
#, no-wrap
msgid "@code{+?} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1176
msgid ""
"Match the @var{rx}s one or more times.  Non-greedy.@* Corresponding string "
"regexp: @samp{@var{A}+?}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1177
#, no-wrap
msgid "(?? @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1178
#, no-wrap
msgid "@code{??} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1181
msgid ""
"Match the @var{rx}s or an empty string.  Non-greedy.@* Corresponding string "
"regexp: @samp{@var{A}??}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1182
#, no-wrap
msgid "(= @var{n} @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1183
#, no-wrap
msgid "@code{=} in rx"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:1184
#, no-wrap
msgid "(repeat @var{n} @var{rx})"
msgstr ""

#. type: table
#: original_texis/searching.texi:1187
msgid ""
"Match the @var{rx}s exactly @var{n} times.@* Corresponding string regexp: "
"@samp{@var{A}\\@{@var{n}\\@}}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1188
#, no-wrap
msgid "(>= @var{n} @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1189
#, no-wrap
msgid "@code{>=} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1192
msgid ""
"Match the @var{rx}s @var{n} or more times.  Greedy.@* Corresponding string "
"regexp: @samp{@var{A}\\@{@var{n},\\@}}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1193
#, no-wrap
msgid "(** @var{n} @var{m} @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1194
#, no-wrap
msgid "@code{**} in rx"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:1195
#, no-wrap
msgid "(repeat @var{n} @var{m} @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1196
#, no-wrap
msgid "@code{repeat} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1199
msgid ""
"Match the @var{rx}s at least @var{n} but no more than @var{m} times.  "
"Greedy.@* Corresponding string regexp: @samp{@var{A}\\@{@var{n},@var{m}\\@}}"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1204
msgid ""
"The greediness of some repetition forms can be controlled using the "
"following constructs.  However, it is usually better to use the explicit "
"non-greedy forms above when such matching is required."
msgstr ""

#. type: item
#: original_texis/searching.texi:1206
#, no-wrap
msgid "(minimal-match @var{rx})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1207
#, no-wrap
msgid "@code{minimal-match} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1211
msgid ""
"Match @var{rx}, with @code{zero-or-more}, @code{0+}, @code{one-or-more}, "
"@code{1+}, @code{zero-or-one}, @code{opt} and @code{optional} using "
"non-greedy matching."
msgstr ""

#. type: item
#: original_texis/searching.texi:1212
#, no-wrap
msgid "(maximal-match @var{rx})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1213
#, no-wrap
msgid "@code{maximal-match} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1217
msgid ""
"Match @var{rx}, with @code{zero-or-more}, @code{0+}, @code{one-or-more}, "
"@code{1+}, @code{zero-or-one}, @code{opt} and @code{optional} using greedy "
"matching.  This is the default."
msgstr ""

#. type: subsubheading
#: original_texis/searching.texi:1219
#, no-wrap
msgid "Matching single characters"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1222
#, no-wrap
msgid "(any @var{set}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1223
#, no-wrap
msgid "@code{any} in rx"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1224
#, no-wrap
msgid "(char @var{set}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1225
#, no-wrap
msgid "@code{char} in rx"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1226
#, no-wrap
msgid "(in @var{set}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1227
#, no-wrap
msgid "@code{in} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1228 original_texis/searching.texi:1271
#, no-wrap
msgid "character class in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1234
msgid ""
"Match a single character from one of the @var{set}s.  Each @var{set} is a "
"character, a string representing the set of its characters, a range or a "
"character class (see below).  A range is either a hyphen-separated string "
"like @code{\"A-Z\"}, or a cons of characters like @code{(?A . ?Z)}."
msgstr ""

#. type: table
#: original_texis/searching.texi:1239
msgid ""
"Note that hyphen (@code{-}) is special in strings in this construct, since "
"it acts as a range separator.  To include a hyphen, add it as a separate "
"character or single-character string.@* Corresponding string regexp: "
"@samp{[@dots{}]}"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1240
#, no-wrap
msgid "(not @var{charspec})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1241
#, no-wrap
msgid "@code{not} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1250
msgid ""
"Match a character not included in @var{charspec}.  @var{charspec} can be a "
"character, a single-character string, an @code{any}, @code{not}, @code{or}, "
"@code{intersection}, @code{syntax} or @code{category} form, or a character "
"class.  If @var{charspec} is an @code{or} form, its arguments have the same "
"restrictions as those of @code{intersection}; see below.@* Corresponding "
"string regexp: @samp{[^@dots{}]}, @samp{\\S@var{code}}, @samp{\\C@var{code}}"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1251
#, no-wrap
msgid "(intersection @var{charset}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1252
#, no-wrap
msgid "@code{intersection} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1257
msgid ""
"Match a character included in all of the @var{charset}s.  Each @var{charset} "
"can be a character, a single-character string, an @code{any} form without "
"character classes, or an @code{intersection}, @code{or} or @code{not} form "
"whose arguments are also @var{charset}s."
msgstr ""

#. type: item
#: original_texis/searching.texi:1258
#, no-wrap
msgid "@code{not-newline}, @code{nonl}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1259
#, no-wrap
msgid "@code{not-newline} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1260
#, no-wrap
msgid "@code{nonl} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1263
msgid ""
"Match any character except a newline.@* Corresponding string regexp: "
"@samp{.} (dot)"
msgstr ""

#. type: item
#: original_texis/searching.texi:1264
#, no-wrap
msgid "@code{anychar}, @code{anything}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1265
#, no-wrap
msgid "@code{anychar} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1266
#, no-wrap
msgid "@code{anything} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1269
msgid ""
"Match any character.@* Corresponding string regexp: @samp{.\\|\\n} (for "
"example)"
msgstr ""

#. type: item
#: original_texis/searching.texi:1270
#, no-wrap
msgid "character class"
msgstr ""

#. type: table
#: original_texis/searching.texi:1273
msgid "Match a character from a named character class:"
msgstr ""

#. type: item
#: original_texis/searching.texi:1275
#, no-wrap
msgid "@code{alpha}, @code{alphabetic}, @code{letter}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1279
msgid ""
"Match alphabetic characters.  More precisely, match characters whose Unicode "
"@samp{general-category} property indicates that they are alphabetic."
msgstr ""

#. type: item
#: original_texis/searching.texi:1280
#, no-wrap
msgid "@code{alnum}, @code{alphanumeric}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1284
msgid ""
"Match alphabetic characters and digits.  More precisely, match characters "
"whose Unicode @samp{general-category} property indicates that they are "
"alphabetic or decimal digits."
msgstr ""

#. type: item
#: original_texis/searching.texi:1285
#, no-wrap
msgid "@code{digit}, @code{numeric}, @code{num}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1287
msgid "Match the digits @samp{0}--@samp{9}."
msgstr ""

#. type: item
#: original_texis/searching.texi:1288
#, no-wrap
msgid "@code{xdigit}, @code{hex-digit}, @code{hex}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1291
msgid ""
"Match the hexadecimal digits @samp{0}--@samp{9}, @samp{A}--@samp{F} and "
"@samp{a}--@samp{f}."
msgstr ""

#. type: item
#: original_texis/searching.texi:1292
#, no-wrap
msgid "@code{cntrl}, @code{control}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1294
msgid "Match any character whose code is in the range 0--31."
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1295
#, no-wrap
msgid "blank"
msgstr ""

#. type: table
#: original_texis/searching.texi:1299
msgid ""
"Match horizontal whitespace.  More precisely, match characters whose Unicode "
"@samp{general-category} property indicates that they are spacing separators."
msgstr ""

#. type: item
#: original_texis/searching.texi:1300
#, no-wrap
msgid "@code{space}, @code{whitespace}, @code{white}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1303
msgid "Match any character that has whitespace syntax (@pxref{Syntax Class Table})."
msgstr ""

#. type: item
#: original_texis/searching.texi:1304
#, no-wrap
msgid "@code{lower}, @code{lower-case}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1308
msgid ""
"Match anything lower-case, as determined by the current case table.  If "
"@code{case-fold-search} is non-@code{nil}, this also matches any upper-case "
"letter."
msgstr ""

#. type: item
#: original_texis/searching.texi:1309
#, no-wrap
msgid "@code{upper}, @code{upper-case}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1313
msgid ""
"Match anything upper-case, as determined by the current case table.  If "
"@code{case-fold-search} is non-@code{nil}, this also matches any lower-case "
"letter."
msgstr ""

#. type: item
#: original_texis/searching.texi:1314
#, no-wrap
msgid "@code{graph}, @code{graphic}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1319
msgid ""
"Match any character except whitespace, @acronym{ASCII} and "
"non-@acronym{ASCII} control characters, surrogates, and codepoints "
"unassigned by Unicode, as indicated by the Unicode @samp{general-category} "
"property."
msgstr ""

#. type: item
#: original_texis/searching.texi:1320
#, no-wrap
msgid "@code{print}, @code{printing}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1322
msgid "Match whitespace or a character matched by @code{graph}."
msgstr ""

#. type: item
#: original_texis/searching.texi:1323
#, no-wrap
msgid "@code{punct}, @code{punctuation}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1326
msgid ""
"Match any punctuation character.  (At present, for multibyte characters, "
"anything that has non-word syntax.)"
msgstr ""

#. type: item
#: original_texis/searching.texi:1327
#, no-wrap
msgid "@code{word}, @code{wordchar}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1329
msgid "Match any character that has word syntax (@pxref{Syntax Class Table})."
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1330
#, no-wrap
msgid "ascii"
msgstr ""

#. type: table
#: original_texis/searching.texi:1332
msgid "Match any @acronym{ASCII} character (codes 0--127)."
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1333
#, no-wrap
msgid "nonascii"
msgstr ""

#. type: table
#: original_texis/searching.texi:1335
msgid "Match any non-@acronym{ASCII} character (but not raw bytes)."
msgstr ""

#. type: table
#: original_texis/searching.texi:1338
msgid "Corresponding string regexp: @samp{[[:@var{class}:]]}"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1339
#, no-wrap
msgid "(syntax @var{syntax})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1340
#, no-wrap
msgid "@code{syntax} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1343
msgid ""
"Match a character with syntax @var{syntax}, being one of the following "
"names:"
msgstr ""

#. type: multitable
#: original_texis/searching.texi:1346
msgid "@headitem Syntax name"
msgstr ""

#. type: multitable
#: original_texis/searching.texi:1346
msgid "Syntax character"
msgstr ""

#. type: item
#: original_texis/searching.texi:1346
#, no-wrap
msgid "@code{whitespace}        @tab @code{-}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1347
#, no-wrap
msgid "@code{punctuation}       @tab @code{.}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1348
#, no-wrap
msgid "@code{word}              @tab @code{w}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1349
#, no-wrap
msgid "@code{symbol}            @tab @code{_}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1350
#, no-wrap
msgid "@code{open-parenthesis}  @tab @code{(}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1351
#, no-wrap
msgid "@code{close-parenthesis} @tab @code{)}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1352
#, no-wrap
msgid "@code{expression-prefix} @tab @code{'}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1353
#, no-wrap
msgid "@code{string-quote}      @tab @code{\"}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1354
#, no-wrap
msgid "@code{paired-delimiter}  @tab @code{$}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1355
#, no-wrap
msgid "@code{escape}            @tab @code{\\}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1356
#, no-wrap
msgid "@code{character-quote}   @tab @code{/}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1357
#, no-wrap
msgid "@code{comment-start}     @tab @code{<}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1358
#, no-wrap
msgid "@code{comment-end}       @tab @code{>}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1359
#, no-wrap
msgid "@code{string-delimiter}  @tab @code{|}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1360
#, no-wrap
msgid "@code{comment-delimiter} @tab @code{!}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1368
msgid ""
"For details, @pxref{Syntax Class Table}.  Please note that @code{(syntax "
"punctuation)} is @emph{not} equivalent to the character class "
"@code{punctuation}.@* Corresponding string regexp: @samp{\\s@var{char}} "
"where @var{char} is the syntax character."
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1369
#, no-wrap
msgid "(category @var{category})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1370
#, no-wrap
msgid "@code{category} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1373
msgid ""
"Match a character in category @var{category}, which is either one of the "
"names below or its category character."
msgstr ""

#. type: multitable
#: original_texis/searching.texi:1376
msgid "@headitem Category name"
msgstr ""

#. type: multitable
#: original_texis/searching.texi:1376
msgid "Category character"
msgstr ""

#. type: item
#: original_texis/searching.texi:1376
#, no-wrap
msgid "@code{space-for-indent}                 @tab space"
msgstr ""

#. type: item
#: original_texis/searching.texi:1377
#, no-wrap
msgid "@code{base}                             @tab @code{.}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1378
#, no-wrap
msgid "@code{consonant}                        @tab @code{0}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1379
#, no-wrap
msgid "@code{base-vowel}                       @tab @code{1}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1380
#, no-wrap
msgid "@code{upper-diacritical-mark}           @tab @code{2}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1381
#, no-wrap
msgid "@code{lower-diacritical-mark}           @tab @code{3}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1382
#, no-wrap
msgid "@code{tone-mark}                        @tab @code{4}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1383
#, no-wrap
msgid "@code{symbol}                           @tab @code{5}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1384
#, no-wrap
msgid "@code{digit}                            @tab @code{6}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1385
#, no-wrap
msgid "@code{vowel-modifying-diacritical-mark} @tab @code{7}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1386
#, no-wrap
msgid "@code{vowel-sign}                       @tab @code{8}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1387
#, no-wrap
msgid "@code{semivowel-lower}                  @tab @code{9}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1388
#, no-wrap
msgid "@code{not-at-end-of-line}               @tab @code{<}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1389
#, no-wrap
msgid "@code{not-at-beginning-of-line}         @tab @code{>}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1390
#, no-wrap
msgid "@code{alpha-numeric-two-byte}           @tab @code{A}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1391
#, no-wrap
msgid "@code{chinese-two-byte}                 @tab @code{C}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1392
#, no-wrap
msgid "@code{greek-two-byte}                   @tab @code{G}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1393
#, no-wrap
msgid "@code{japanese-hiragana-two-byte}       @tab @code{H}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1394
#, no-wrap
msgid "@code{indian-two-byte}                  @tab @code{I}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1395
#, no-wrap
msgid "@code{japanese-katakana-two-byte}       @tab @code{K}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1396
#, no-wrap
msgid "@code{strong-left-to-right}             @tab @code{L}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1397
#, no-wrap
msgid "@code{korean-hangul-two-byte}           @tab @code{N}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1398
#, no-wrap
msgid "@code{strong-right-to-left}             @tab @code{R}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1399
#, no-wrap
msgid "@code{cyrillic-two-byte}                @tab @code{Y}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1400
#, no-wrap
msgid "@code{combining-diacritic}              @tab @code{^}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1401
#, no-wrap
msgid "@code{ascii}                            @tab @code{a}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1402
#, no-wrap
msgid "@code{arabic}                           @tab @code{b}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1403
#, no-wrap
msgid "@code{chinese}                          @tab @code{c}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1404
#, no-wrap
msgid "@code{ethiopic}                         @tab @code{e}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1405
#, no-wrap
msgid "@code{greek}                            @tab @code{g}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1406
#, no-wrap
msgid "@code{korean}                           @tab @code{h}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1407
#, no-wrap
msgid "@code{indian}                           @tab @code{i}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1408
#, no-wrap
msgid "@code{japanese}                         @tab @code{j}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1409
#, no-wrap
msgid "@code{japanese-katakana}                @tab @code{k}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1410
#, no-wrap
msgid "@code{latin}                            @tab @code{l}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1411
#, no-wrap
msgid "@code{lao}                              @tab @code{o}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1412
#, no-wrap
msgid "@code{tibetan}                          @tab @code{q}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1413
#, no-wrap
msgid "@code{japanese-roman}                   @tab @code{r}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1414
#, no-wrap
msgid "@code{thai}                             @tab @code{t}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1415
#, no-wrap
msgid "@code{vietnamese}                       @tab @code{v}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1416
#, no-wrap
msgid "@code{hebrew}                           @tab @code{w}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1417
#, no-wrap
msgid "@code{cyrillic}                         @tab @code{y}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1418
#, no-wrap
msgid "@code{can-break}                        @tab @code{|}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1426
msgid ""
"For more information about currently defined categories, run the command "
"@kbd{M-x describe-categories @key{RET}}.  For how to define new categories, "
"@pxref{Categories}.@* Corresponding string regexp: @samp{\\c@var{char}} "
"where @var{char} is the category character."
msgstr ""

#. type: subsubheading
#: original_texis/searching.texi:1428
#, no-wrap
msgid "Zero-width assertions"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1431
msgid "These all match the empty string, but only in specific places."
msgstr ""

#. type: item
#: original_texis/searching.texi:1433
#, no-wrap
msgid "@code{line-start}, @code{bol}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1434
#, no-wrap
msgid "@code{line-start} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1435
#, no-wrap
msgid "@code{bol} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1438
msgid "Match at the beginning of a line.@* Corresponding string regexp: @samp{^}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1439
#, no-wrap
msgid "@code{line-end}, @code{eol}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1440
#, no-wrap
msgid "@code{line-end} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1441
#, no-wrap
msgid "@code{eol} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1444
msgid "Match at the end of a line.@* Corresponding string regexp: @samp{$}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1445
#, no-wrap
msgid "@code{string-start}, @code{bos}, @code{buffer-start}, @code{bot}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1446
#, no-wrap
msgid "@code{string-start} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1447
#, no-wrap
msgid "@code{bos} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1448
#, no-wrap
msgid "@code{buffer-start} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1449
#, no-wrap
msgid "@code{bot} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1452
msgid ""
"Match at the start of the string or buffer being matched against.@* "
"Corresponding string regexp: @samp{\\`}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1453
#, no-wrap
msgid "@code{string-end}, @code{eos}, @code{buffer-end}, @code{eot}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1454
#, no-wrap
msgid "@code{string-end} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1455
#, no-wrap
msgid "@code{eos} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1456
#, no-wrap
msgid "@code{buffer-end} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1457
#, no-wrap
msgid "@code{eot} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1460
msgid ""
"Match at the end of the string or buffer being matched against.@* "
"Corresponding string regexp: @samp{\\'}"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1461
#, no-wrap
msgid "point"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1462
#, no-wrap
msgid "@code{point} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1465
msgid "Match at point.@* Corresponding string regexp: @samp{\\=}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1466
#, no-wrap
msgid "@code{word-start}, @code{bow}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1467
#, no-wrap
msgid "@code{word-start} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1468
#, no-wrap
msgid "@code{bow} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1471
msgid "Match at the beginning of a word.@* Corresponding string regexp: @samp{\\<}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1472
#, no-wrap
msgid "@code{word-end}, @code{eow}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1473
#, no-wrap
msgid "@code{word-end} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1474
#, no-wrap
msgid "@code{eow} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1477
msgid "Match at the end of a word.@* Corresponding string regexp: @samp{\\>}"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1478
#, no-wrap
msgid "word-boundary"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1479
#, no-wrap
msgid "@code{word-boundary} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1482
msgid ""
"Match at the beginning or end of a word.@* Corresponding string regexp: "
"@samp{\\b}"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1483
#, no-wrap
msgid "not-word-boundary"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1484
#, no-wrap
msgid "@code{not-word-boundary} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1487
msgid ""
"Match anywhere but at the beginning or end of a word.@* Corresponding string "
"regexp: @samp{\\B}"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1488
#, no-wrap
msgid "symbol-start"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1489
#, no-wrap
msgid "@code{symbol-start} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1492
msgid ""
"Match at the beginning of a symbol.@* Corresponding string regexp: "
"@samp{\\_<}"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1493
#, no-wrap
msgid "symbol-end"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1494
#, no-wrap
msgid "@code{symbol-end} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1497
msgid "Match at the end of a symbol.@* Corresponding string regexp: @samp{\\_>}"
msgstr ""

#. type: subsubheading
#: original_texis/searching.texi:1499
#, no-wrap
msgid "Capture groups"
msgstr ""

#. type: item
#: original_texis/searching.texi:1502
#, no-wrap
msgid "(group @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1503
#, no-wrap
msgid "@code{group} in rx"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:1504
#, no-wrap
msgid "(submatch @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1505
#, no-wrap
msgid "@code{submatch} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1511
msgid ""
"Match the @var{rx}s, making the matched text and position accessible in the "
"match data.  The first group in a regexp is numbered 1; subsequent groups "
"will be numbered one above the previously highest-numbered group in the "
"pattern so far.@* Corresponding string regexp: @samp{\\(@dots{}\\)}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1512
#, no-wrap
msgid "(group-n @var{n} @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1513
#, no-wrap
msgid "@code{group-n} in rx"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:1514
#, no-wrap
msgid "(submatch-n @var{n} @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1515
#, no-wrap
msgid "@code{submatch-n} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1519
msgid ""
"Like @code{group}, but explicitly assign the group number @var{n}.  @var{n} "
"must be positive.@* Corresponding string regexp: "
"@samp{\\(?@var{n}:@dots{}\\)}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1520
#, no-wrap
msgid "(backref @var{n})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1521
#, no-wrap
msgid "@code{backref} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1525
msgid ""
"Match the text previously matched by group number @var{n}.  @var{n} must be "
"in the range 1--9.@* Corresponding string regexp: @samp{\\@var{n}}"
msgstr ""

#. type: subsubheading
#: original_texis/searching.texi:1527
#, no-wrap
msgid "Dynamic inclusion"
msgstr ""

#. type: item
#: original_texis/searching.texi:1530
#, no-wrap
msgid "(literal @var{expr})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1531
#, no-wrap
msgid "@code{literal} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1535
msgid ""
"Match the literal string that is the result from evaluating the Lisp "
"expression @var{expr}.  The evaluation takes place at call time, in the "
"current lexical environment."
msgstr ""

#. type: item
#: original_texis/searching.texi:1536
#, no-wrap
msgid "(regexp @var{expr})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1537
#, no-wrap
msgid "@code{regexp} in rx"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:1538
#, no-wrap
msgid "(regex @var{expr})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1539
#, no-wrap
msgid "@code{regex} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1543
msgid ""
"Match the string regexp that is the result from evaluating the Lisp "
"expression @var{expr}.  The evaluation takes place at call time, in the "
"current lexical environment."
msgstr ""

#. type: item
#: original_texis/searching.texi:1544
#, no-wrap
msgid "(eval @var{expr})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1545
#, no-wrap
msgid "@code{eval} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1550
msgid ""
"Match the rx form that is the result from evaluating the Lisp expression "
"@var{expr}.  The evaluation takes place at macro-expansion time for "
"@code{rx}, at call time for @code{rx-to-string}, in the current global "
"environment."
msgstr ""

#. type: subsubsection
#: original_texis/searching.texi:1553
#, no-wrap
msgid "Functions and macros using @code{rx} regexps"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1555
#, no-wrap
msgid "rx rx-form@dots{}"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1560
msgid ""
"Translate the @var{rx-form}s to a string regexp, as if they were the body of "
"a @code{(seq @dots{})} form.  The @code{rx} macro expands to a string "
"constant, or, if @code{literal} or @code{regexp} forms are used, a Lisp "
"expression that evaluates to a string.  Example:"
msgstr ""

#. type: group
#: original_texis/searching.texi:1565
#, no-wrap
msgid ""
"(rx (+ alpha) \"=\" (+ digit))\n"
"  @result{} \"[[:alpha:]]+=[[:digit:]]+\"\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1569
#, no-wrap
msgid "rx-to-string rx-expr &optional no-group"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1575
msgid ""
"Translate @var{rx-expr} to a string regexp which is returned.  If "
"@var{no-group} is absent or @code{nil}, bracket the result in a "
"non-capturing group, @samp{\\(?:@dots{}\\)}, if necessary to ensure that a "
"postfix operator appended to it will apply to the whole expression.  "
"Example:"
msgstr ""

#. type: group
#: original_texis/searching.texi:1580
#, no-wrap
msgid ""
"(rx-to-string '(seq (+ alpha) \"=\" (+ digit)) t)\n"
"  @result{} \"[[:alpha:]]+=[[:digit:]]+\"\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1585
msgid ""
"Arguments to @code{literal} and @code{regexp} forms in @var{rx-expr} must be "
"string literals."
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1589
msgid ""
"The @code{pcase} macro can use @code{rx} expressions as patterns directly; "
"@pxref{rx in pcase}."
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1592
msgid ""
"For mechanisms to add user-defined extensions to the @code{rx} notation, "
"@pxref{Extending Rx}."
msgstr ""

#. type: subsubsection
#: original_texis/searching.texi:1594
#, no-wrap
msgid "Defining new @code{rx} forms"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1601
msgid ""
"The @code{rx} notation can be extended by defining new symbols and "
"parameterized forms in terms of other @code{rx} expressions.  This is handy "
"for sharing parts between several regexps, and for making complex ones "
"easier to build and understand by putting them together from smaller pieces."
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1607
msgid ""
"For example, you could define @code{name} to mean @code{(one-or-more "
"letter)}, and @code{(quoted @var{x})} to mean @code{(seq ?' @var{x} ?')} for "
"any @var{x}.  These forms could then be used in @code{rx} expressions like "
"any other: @code{(rx (quoted name))} would match a nonempty sequence of "
"letters inside single quotes."
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1610
msgid ""
"The Lisp macros below provide different ways of binding names to "
"definitions.  Common to all of them are the following rules:"
msgstr ""

#. type: itemize
#: original_texis/searching.texi:1615
msgid ""
"Built-in @code{rx} forms, like @code{digit} and @code{group}, cannot be "
"redefined."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:1620
msgid ""
"The definitions live in a name space of their own, separate from that of "
"Lisp variables.  There is thus no need to attach a suffix like "
"@code{-regexp} to names; they cannot collide with anything else."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:1625
msgid ""
"Definitions cannot refer to themselves recursively, directly or indirectly.  "
"If you find yourself needing this, you want a parser, not a regular "
"expression."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:1632
msgid ""
"Definitions are only ever expanded in calls to @code{rx} or "
"@code{rx-to-string}, not merely by their presence in definition macros.  "
"This means that the order of definitions doesn't matter, even when they "
"refer to each other, and that syntax errors only show up when they are used, "
"not when they are defined."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:1639
msgid ""
"User-defined forms are allowed wherever arbitrary @code{rx} expressions are "
"expected; for example, in the body of a @code{zero-or-one} form, but not "
"inside @code{any} or @code{category} forms.  They are also allowed inside "
"@code{not} and @code{intersection} forms."
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1641
#, no-wrap
msgid "rx-define name [arglist] rx-form"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1645
msgid ""
"Define @var{name} globally in all subsequent calls to @code{rx} and "
"@code{rx-to-string}.  If @var{arglist} is absent, then @var{name} is defined "
"as a plain symbol to be replaced with @var{rx-form}.  Example:"
msgstr ""

#. type: group
#: original_texis/searching.texi:1651
#, no-wrap
msgid ""
"(rx-define haskell-comment (seq \"--\" (zero-or-more nonl)))\n"
"(rx haskell-comment)\n"
"     @result{} \"--.*\"\n"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1659
msgid ""
"If @var{arglist} is present, it must be a list of zero or more argument "
"names, and @var{name} is then defined as a parameterized form.  When used in "
"an @code{rx} expression as @code{(@var{name} @var{arg}@dots{})}, each "
"@var{arg} will replace the corresponding argument name inside @var{rx-form}."
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1664
msgid ""
"@var{arglist} may end in @code{&rest} and one final argument name, denoting "
"a rest parameter.  The rest parameter will expand to all extra actual "
"argument values not matched by any other parameter in @var{arglist}, spliced "
"into @var{rx-form} where it occurs.  Example:"
msgstr ""

#. type: group
#: original_texis/searching.texi:1670
#, no-wrap
msgid ""
"(rx-define moan (x y &rest r) (seq x (one-or-more y) r \"!\"))\n"
"(rx (moan \"MOO\" \"A\" \"MEE\" \"OW\"))\n"
"     @result{} \"MOOA+MEEOW!\"\n"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1676
msgid ""
"Since the definition is global, it is recommended to give @var{name} a "
"package prefix to avoid name clashes with definitions elsewhere, as is usual "
"when naming non-local variables and functions."
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1680
msgid ""
"Forms defined this way only perform simple template substitution.  For "
"arbitrary computations, use them together with the @code{rx} forms "
"@code{eval}, @code{regexp} or @code{literal}.  Example:"
msgstr ""

#. type: group
#: original_texis/searching.texi:1692
#, no-wrap
msgid ""
"(defun n-tuple-rx (n element)\n"
"  `(seq \"<\"\n"
"        (group-n 1 ,element)\n"
"        ,@@(mapcar (lambda (i) `(seq ?, (group-n ,i ,element)))\n"
"                  (number-sequence 2 n))\n"
"        \">\"))\n"
"(rx-define n-tuple (n element) (eval (n-tuple-rx n 'element)))\n"
"(rx (n-tuple 3 (+ (in \"0-9\"))))\n"
"  @result{} "
"\"<\\\\(?1:[0-9]+\\\\),\\\\(?2:[0-9]+\\\\),\\\\(?3:[0-9]+\\\\)>\"\n"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1696
#, no-wrap
msgid "rx-let (bindings@dots{}) body@dots{}"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1699
msgid ""
"Make the @code{rx} definitions in @var{bindings} available locally for "
"@code{rx} macro invocations in @var{body}, which is then evaluated."
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1703
msgid ""
"Each element of @var{bindings} is on the form @w{@code{(@var{name} "
"[@var{arglist}] @var{rx-form})}}, where the parts have the same meaning as "
"in @code{rx-define} above.  Example:"
msgstr ""

#. type: group
#: original_texis/searching.texi:1710
#, no-wrap
msgid ""
"(rx-let ((comma-separated (item) (seq item (0+ \",\" item)))\n"
"         (number (1+ digit))\n"
"         (numbers (comma-separated number)))\n"
"  (re-search-forward (rx \"(\" numbers \")\")))\n"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1716
msgid ""
"The definitions are only available during the macro-expansion of @var{body}, "
"and are thus not present during execution of compiled code."
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1722
msgid ""
"@code{rx-let} can be used not only inside a function, but also at top level "
"to include global variable and function definitions that need to share a "
"common set of @code{rx} forms.  Since the names are local inside @var{body}, "
"there is no need for any package prefixes.  Example:"
msgstr ""

#. type: group
#: original_texis/searching.texi:1730
#, no-wrap
msgid ""
"(rx-let ((phone-number (seq (opt ?+) (1+ (any digit ?-)))))\n"
"  (defun find-next-phone-number ()\n"
"    (re-search-forward (rx phone-number)))\n"
"  (defun phone-number-p (string)\n"
"    (string-match-p (rx bos phone-number eos) string)))\n"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1736
msgid ""
"The scope of the @code{rx-let} bindings is lexical, which means that they "
"are not visible outside @var{body} itself, even in functions called from "
"@var{body}."
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1738
#, no-wrap
msgid "rx-let-eval bindings body@dots{}"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1742
msgid ""
"Evaluate @var{bindings} to a list of bindings as in @code{rx-let}, and "
"evaluate @var{body} with those bindings in effect for calls to "
"@code{rx-to-string}."
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1747
msgid ""
"This macro is similar to @code{rx-let}, except that the @var{bindings} "
"argument is evaluated (and thus needs to be quoted if it is a list literal), "
"and the definitions are substituted at run time, which is required for "
"@code{rx-to-string} to work.  Example:"
msgstr ""

#. type: group
#: original_texis/searching.texi:1755
#, no-wrap
msgid ""
"(rx-let-eval\n"
"    '((ponder (x) (seq \"Where have all the \" x \" gone?\")))\n"
"  (looking-at (rx-to-string\n"
"               '(ponder (or \"flowers\" \"young girls\"\n"
"                            \"left socks\")))))\n"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1762
msgid ""
"Another difference from @code{rx-let} is that the @var{bindings} are "
"dynamically scoped, and thus also available in functions called from "
"@var{body}. However, they are not visible inside functions defined in "
"@var{body}."
msgstr ""

#. type: subsection
#: original_texis/searching.texi:1767
#, no-wrap
msgid "Regular Expression Functions"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1770
msgid "These functions operate on regular expressions."
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1771
#, no-wrap
msgid "quote special characters in regexp"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1772
#, no-wrap
msgid "regexp-quote string"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1778
msgid ""
"This function returns a regular expression whose only exact match is "
"@var{string}.  Using this regular expression in @code{looking-at} will "
"succeed only if the next characters in the buffer are @var{string}; using it "
"in a search function will succeed if the text being searched contains "
"@var{string}.  @xref{Regexp Search}."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1781
msgid ""
"This allows you to request an exact string match or search when calling a "
"function that wants a regular expression."
msgstr ""

#. type: group
#: original_texis/searching.texi:1786
#, no-wrap
msgid ""
"(regexp-quote \"^The cat$\")\n"
"     @result{} \"\\\\^The cat\\\\$\"\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1793
msgid ""
"One use of @code{regexp-quote} is to combine an exact string match with "
"context described as a regular expression.  For example, this searches for "
"the string that is the value of @var{string}, surrounded by whitespace:"
msgstr ""

#. type: group
#: original_texis/searching.texi:1798
#, no-wrap
msgid ""
"(re-search-forward\n"
" (concat \"\\\\s-\" (regexp-quote string) \"\\\\s-\"))\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1803
msgid ""
"The returned string may be @var{string} itself if it does not contain any "
"special characters."
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1805
#, no-wrap
msgid "optimize regexp"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1806
#, no-wrap
msgid "regexp-opt strings &optional paren"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1815
msgid ""
"This function returns an efficient regular expression that will match any of "
"the strings in the list @var{strings}.  This is useful when you need to make "
"matching or searching as fast as possible---for example, for Font Lock "
"mode@footnote{Note that @code{regexp-opt} does not guarantee that its result "
"is absolutely the most efficient form possible.  A hand-tuned regular "
"expression can sometimes be slightly more efficient, but is almost never "
"worth the effort.}."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1818
msgid ""
"If @var{strings} is the empty list, the return value is a regexp that never "
"matches anything."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1820
msgid "The optional argument @var{paren} can be any of the following:"
msgstr ""

#. type: item
#: original_texis/searching.texi:1822
#, no-wrap
msgid "a string"
msgstr ""

#. type: table
#: original_texis/searching.texi:1826
msgid ""
"The resulting regexp is preceded by @var{paren} and followed by @samp{\\)}, "
"e.g. use @samp{\"\\\\(?1:\"} to produce an explicitly numbered group."
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1827
#, no-wrap
msgid "words"
msgstr ""

#. type: table
#: original_texis/searching.texi:1829
msgid "The resulting regexp is surrounded by @samp{\\<\\(} and @samp{\\)\\>}."
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1830
#, no-wrap
msgid "symbols"
msgstr ""

#. type: table
#: original_texis/searching.texi:1834
msgid ""
"The resulting regexp is surrounded by @samp{\\_<\\(} and @samp{\\)\\_>} "
"(this is often appropriate when matching programming-language keywords and "
"the like)."
msgstr ""

#. type: item
#: original_texis/searching.texi:1835
#, no-wrap
msgid "non-@code{nil}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1837
msgid "The resulting regexp is surrounded by @samp{\\(} and @samp{\\)}."
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1838 original_texis/searching.texi:1994
#, no-wrap
msgid "nil"
msgstr ""

#. type: table
#: original_texis/searching.texi:1842
msgid ""
"The resulting regexp is surrounded by @samp{\\(?:} and @samp{\\)}, if it is "
"necessary to ensure that a postfix operator appended to it will apply to the "
"whole expression."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1846
msgid ""
"The returned regexp is ordered in such a way that it will always match the "
"longest string possible."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1850
msgid ""
"Up to reordering, the resulting regexp of @code{regexp-opt} is equivalent to "
"but usually more efficient than that of a simplified version:"
msgstr ""

#. type: example
#: original_texis/searching.texi:1863
#, no-wrap
msgid ""
"(defun simplified-regexp-opt (strings &optional paren)\n"
" (let ((parens\n"
"        (cond\n"
"         ((stringp paren)       (cons paren \"\\\\)\"))\n"
"         ((eq paren 'words)    '(\"\\\\<\\\\(\" . \"\\\\)\\\\>\"))\n"
"         ((eq paren 'symbols) '(\"\\\\_<\\\\(\" . \"\\\\)\\\\_>\"))\n"
"         ((null paren)          '(\"\\\\(?:\" . \"\\\\)\"))\n"
"         (t                       '(\"\\\\(\" . \"\\\\)\")))))\n"
"   (concat (car parens)\n"
"           (mapconcat 'regexp-quote strings \"\\\\|\")\n"
"           (cdr parens))))\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1866
#, no-wrap
msgid "regexp-opt-depth regexp"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1870
msgid ""
"This function returns the total number of grouping constructs (parenthesized "
"expressions) in @var{regexp}.  This does not include shy groups "
"(@pxref{Regexp Backslash})."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1873
#, no-wrap
msgid "regexp-opt-charset chars"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1876
msgid ""
"This function returns a regular expression matching a character in the list "
"of characters @var{chars}."
msgstr ""

#. type: example
#: original_texis/searching.texi:1880
#, no-wrap
msgid ""
"(regexp-opt-charset '(?a ?b ?c ?d ?e))\n"
"     @result{} \"[a-e]\"\n"
msgstr ""

#. type: defvar
#: original_texis/searching.texi:1886
#, no-wrap
msgid "regexp-unmatchable"
msgstr ""

#. type: defvar
#: original_texis/searching.texi:1891
msgid ""
"This variable contains a regexp that is guaranteed not to match any string "
"at all.  It is particularly useful as default value for variables that may "
"be set to a pattern that actually matches something."
msgstr ""

#. type: subsection
#: original_texis/searching.texi:1894
#, no-wrap
msgid "Problems with Regular Expressions"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1895
#, no-wrap
msgid "regular expression problems"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1896
#, no-wrap
msgid "regexp stack overflow"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1897
#, no-wrap
msgid "stack overflow in regexp"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1904
msgid ""
"The Emacs regexp implementation, like many of its kind, is generally robust "
"but occasionally causes trouble in either of two ways: matching may run out "
"of internal stack space and signal an error, and it can take a long time to "
"complete.  The advice below will make these symptoms less likely and help "
"alleviate problems that do arise."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:1912
msgid ""
"Anchor regexps at the beginning of a line, string or buffer using zero-width "
"assertions (@samp{^} and @code{\\`}). This takes advantage of fast paths in "
"the implementation and can avoid futile matching attempts.  Other zero-width "
"assertions may also bring benefits by causing a match to fail early."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:1917
msgid ""
"Avoid or-patterns in favor of character alternatives: write @samp{[ab]} "
"instead of @samp{a\\|b}.  Recall that @samp{\\s-} and @samp{\\sw} are "
"equivalent to @samp{[[:space:]]} and @samp{[[:word:]]}, respectively."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:1924
msgid ""
"Since the last branch of an or-pattern does not add a backtrack point on the "
"stack, consider putting the most likely matched pattern last.  For example, "
"@samp{^\\(?:a\\|.b\\)*c} will run out of stack if trying to match a very "
"long string of @samp{a}s, but the equivalent @samp{^\\(?:.b\\|a\\)*c} will "
"not."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:1927
msgid ""
"(It is a trade-off: successfully matched or-patterns run faster with the "
"most frequently matched pattern first.)"
msgstr ""

#. type: itemize
#: original_texis/searching.texi:1935
msgid ""
"Try to ensure that any part of the text can only match in a single way.  For "
"example, @samp{a*a*} will match the same set of strings as @samp{a*}, but "
"the former can do so in many ways and will therefore cause slow backtracking "
"if the match fails later on.  Make or-pattern branches mutually exclusive if "
"possible, so that matching will not go far into more than one branch before "
"failing."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:1941
msgid ""
"Be especially careful with nested repetitions: they can easily result in "
"very slow matching in the presence of ambiguities.  For example, "
"@samp{\\(?:a*b*\\)+c} will take a long time attempting to match even a "
"moderately long string of @samp{a}s before failing.  The equivalent "
"@samp{\\(?:a\\|b\\)*c} is much faster, and @samp{[ab]*c} better still."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:1946
msgid ""
"Don't use capturing groups unless they are really needed; that is, use "
"@samp{\\(?:@dots{}\\)} instead of @samp{\\(@dots{}\\)} for bracketing "
"purposes."
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1952
msgid ""
"Consider using @code{rx} (@pxref{Rx Notation}); it can optimize some "
"or-patterns automatically and will never introduce capturing groups unless "
"explicitly requested."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1959
msgid ""
"If you run into regexp stack overflow despite following the above advice, "
"don't be afraid of performing the matching in multiple function calls, each "
"using a simpler regexp where backtracking can more easily be contained."
msgstr ""

#. type: section
#: original_texis/searching.texi:1961
#, no-wrap
msgid "Regular Expression Searching"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1962
#, no-wrap
msgid "regular expression searching"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1963
#, no-wrap
msgid "regexp searching"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1964
#, no-wrap
msgid "searching for regexp"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1972
msgid ""
"In GNU Emacs, you can search for the next match for a regular expression "
"(@pxref{Syntax of Regexps}) either incrementally or not.  For incremental "
"search commands, see @ref{Regexp Search, , Regular Expression Search, emacs, "
"The GNU Emacs Manual}.  Here we describe only the search functions useful in "
"programs.  The principal one is @code{re-search-forward}."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1976
msgid ""
"These search functions convert the regular expression to multibyte if the "
"buffer is multibyte; they convert the regular expression to unibyte if the "
"buffer is unibyte.  @xref{Text Representations}."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:1977
#, no-wrap
msgid "Command re-search-forward regexp &optional limit noerror count"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:1983
msgid ""
"This function searches forward in the current buffer for a string of text "
"that is matched by the regular expression @var{regexp}.  The function skips "
"over any amount of text that is not matched by @var{regexp}, and leaves "
"point at the end of the first match found.  It returns the new value of "
"point."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:1989
msgid ""
"If @var{limit} is non-@code{nil}, it must be a position in the current "
"buffer.  It specifies the upper bound to the search.  No match extending "
"after that position is accepted.  If @var{limit} is omitted or @code{nil}, "
"it defaults to the end of the accessible portion of the buffer."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:1992
msgid ""
"What @code{re-search-forward} does when the search fails depends on the "
"value of @var{noerror}:"
msgstr ""

#. type: table
#: original_texis/searching.texi:1996
msgid "Signal a @code{search-failed} error."
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1996
#, no-wrap
msgid "t"
msgstr ""

#. type: table
#: original_texis/searching.texi:1998
msgid "Do nothing and return @code{nil}."
msgstr ""

#. type: item
#: original_texis/searching.texi:1998
#, no-wrap
msgid "anything else"
msgstr ""

#. type: table
#: original_texis/searching.texi:2001
msgid ""
"Move point to @var{limit} (or the end of the accessible portion of the "
"buffer) and return @code{nil}."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:2019
msgid ""
"In the following example, point is initially before the @samp{T}.  "
"Evaluating the search call moves point to the end of that line (between the "
"@samp{t} of @samp{hat} and the newline)."
msgstr ""

#. type: group
#: original_texis/searching.texi:2026
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"I read \"@point{}The cat in the hat\n"
"comes back\" twice.\n"
"---------- Buffer: foo ----------\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:2031
#, no-wrap
msgid ""
"(re-search-forward \"[a-z]+\" nil t 5)\n"
"     @result{} 27\n"
"\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:2036
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"I read \"The cat in the hat@point{}\n"
"comes back\" twice.\n"
"---------- Buffer: foo ----------\n"
msgstr ""

#. type: anchor{#1}
#: original_texis/searching.texi:2042
msgid "re-search-backward"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:2042
#, no-wrap
msgid "Command re-search-backward regexp &optional limit noerror count"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:2046
msgid ""
"This function searches backward in the current buffer for a string of text "
"that is matched by the regular expression @var{regexp}, leaving point at the "
"beginning of the first text found."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:2056
msgid ""
"This function is analogous to @code{re-search-forward}, but they are not "
"simple mirror images.  @code{re-search-forward} finds the match whose "
"beginning is as close as possible to the starting point.  If "
"@code{re-search-backward} were a perfect mirror image, it would find the "
"match whose end is as close as possible.  However, in fact it finds the "
"match whose beginning is as close as possible (and yet ends before the "
"starting point).  The reason for this is that matching a regular expression "
"at a given spot always works from beginning to end, and starts at a "
"specified beginning position."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:2060
msgid ""
"A true mirror-image of @code{re-search-forward} would require a special "
"feature for matching regular expressions from end to beginning.  It's not "
"worth the trouble of implementing that."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2062
#, no-wrap
msgid "string-match regexp string &optional start inhibit-modify"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2067
msgid ""
"This function returns the index of the start of the first match for the "
"regular expression @var{regexp} in @var{string}, or @code{nil} if there is "
"no match.  If @var{start} is non-@code{nil}, the search starts at that index "
"in @var{string}."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2069
msgid "For example,"
msgstr ""

#. type: group
#: original_texis/searching.texi:2075
#, no-wrap
msgid ""
"(string-match\n"
" \"quick\" \"The quick brown fox jumped quickly.\")\n"
"     @result{} 4\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:2080 original_texis/searching.texi:2097
#, no-wrap
msgid ""
"(string-match\n"
" \"quick\" \"The quick brown fox jumped quickly.\" 8)\n"
"     @result{} 27\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2086
msgid ""
"The index of the first character of the string is 0, the index of the second "
"character is 1, and so on."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2091
msgid ""
"By default, if this function finds a match, the index of the first character "
"beyond the match is available as @code{(match-end 0)}.  @xref{Match Data}.  "
"If @var{inhibit-modify} is non-@code{nil}, the match data isn't modified."
msgstr ""

#. type: group
#: original_texis/searching.texi:2102
#, no-wrap
msgid ""
"(match-end 0)\n"
"     @result{} 32\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2106
#, no-wrap
msgid "string-match-p regexp string &optional start"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2109
msgid ""
"This predicate function does what @code{string-match} does, but it avoids "
"modifying the match data."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2111
#, no-wrap
msgid "looking-at regexp &optional inhibit-modify"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2117
msgid ""
"This function determines whether the text in the current buffer directly "
"following point matches the regular expression @var{regexp}.  ``Directly "
"following'' means precisely that: the search is ``anchored'' and it can "
"succeed only starting with the first character following point.  The result "
"is @code{t} if so, @code{nil} otherwise."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2123
msgid ""
"This function does not move point, but it does update the match data (if "
"@var{inhibit-modify} is @code{nil} or missing, which is the default).  "
"@xref{Match Data}.  As a convenience, instead of using the "
"@var{inhibit-modify} argument, you can use @code{looking-at-p}, described "
"below."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2126
msgid ""
"In this example, point is located directly before the @samp{T}.  If it were "
"anywhere else, the result would be @code{nil}."
msgstr ""

#. type: group
#: original_texis/searching.texi:2133 original_texis/searching.texi:2158
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"I read \"@point{}The cat in the hat\n"
"comes back\" twice.\n"
"---------- Buffer: foo ----------\n"
"\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:2136
#, no-wrap
msgid ""
"(looking-at \"The cat in the hat$\")\n"
"     @result{} t\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2140
#, no-wrap
msgid "looking-back regexp limit &optional greedy"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2143
msgid ""
"This function returns @code{t} if @var{regexp} matches the text immediately "
"before point (i.e., ending at point), and @code{nil} otherwise."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2151
msgid ""
"Because regular expression matching works only going forward, this is "
"implemented by searching backwards from point for a match that ends at "
"point.  That can be quite slow if it has to search a long distance.  You can "
"bound the time required by specifying a non-@code{nil} value for "
"@var{limit}, which says not to search before @var{limit}.  In this case, the "
"match that is found must begin at or after @var{limit}.  Here's an example:"
msgstr ""

#. type: group
#: original_texis/searching.texi:2163
#, no-wrap
msgid ""
"(looking-back \"read \\\"\" 3)\n"
"     @result{} t\n"
"(looking-back \"read \\\"\" 4)\n"
"     @result{} nil\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2171
msgid ""
"If @var{greedy} is non-@code{nil}, this function extends the match backwards "
"as far as possible, stopping when a single additional previous character "
"cannot be part of a match for @var{regexp}.  When the match is extended, its "
"starting position is allowed to occur before @var{limit}."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2176
msgid ""
"As a general recommendation, try to avoid using @code{looking-back} wherever "
"possible, since it is slow.  For this reason, there are no plans to add a "
"@code{looking-back-p} function."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2178
#, no-wrap
msgid "looking-at-p regexp"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2181
msgid ""
"This predicate function works like @code{looking-at}, but without updating "
"the match data."
msgstr ""

#. type: defvar
#: original_texis/searching.texi:2183
#, no-wrap
msgid "search-spaces-regexp"
msgstr ""

#. type: defvar
#: original_texis/searching.texi:2190
msgid ""
"If this variable is non-@code{nil}, it should be a regular expression that "
"says how to search for whitespace.  In that case, any group of spaces in a "
"regular expression being searched for stands for use of this regular "
"expression.  However, spaces inside of constructs such as @samp{[@dots{}]} "
"and @samp{*}, @samp{+}, @samp{?} are not affected by "
"@code{search-spaces-regexp}."
msgstr ""

#. type: defvar
#: original_texis/searching.texi:2194
msgid ""
"Since this variable affects all regular expression search and match "
"constructs, you should bind it temporarily for as small as possible a part "
"of the code."
msgstr ""

#. type: section
#: original_texis/searching.texi:2197
#, no-wrap
msgid "POSIX Regular Expression Searching"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:2199
#, no-wrap
msgid "backtracking and POSIX regular expressions"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2204
msgid ""
"The usual regular expression functions do backtracking when necessary to "
"handle the @samp{\\|} and repetition constructs, but they continue this only "
"until they find @emph{some} match.  Then they succeed and report the first "
"match found."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2211
msgid ""
"This section describes alternative search functions which perform the full "
"backtracking specified by the POSIX standard for regular expression "
"matching.  They continue backtracking until they have tried all "
"possibilities and found all matches, so they can report the longest match, "
"as required by POSIX@.  This is much slower, so use these functions only "
"when you really need the longest match."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2216
msgid ""
"The POSIX search and match functions do not properly support the non-greedy "
"repetition operators (@pxref{Regexp Special, non-greedy}).  This is because "
"POSIX backtracking conflicts with the semantics of non-greedy repetition."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:2217
#, no-wrap
msgid "Command posix-search-forward regexp &optional limit noerror count"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:2221
msgid ""
"This is like @code{re-search-forward} except that it performs the full "
"backtracking specified by the POSIX standard for regular expression "
"matching."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:2223
#, no-wrap
msgid "Command posix-search-backward regexp &optional limit noerror count"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:2227
msgid ""
"This is like @code{re-search-backward} except that it performs the full "
"backtracking specified by the POSIX standard for regular expression "
"matching."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2229
#, no-wrap
msgid "posix-looking-at regexp &optional inhibit-modify"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2233
msgid ""
"This is like @code{looking-at} except that it performs the full backtracking "
"specified by the POSIX standard for regular expression matching."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2235
#, no-wrap
msgid "posix-string-match regexp string &optional start inhibit-modify"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2239
msgid ""
"This is like @code{string-match} except that it performs the full "
"backtracking specified by the POSIX standard for regular expression "
"matching."
msgstr ""

#. type: section
#: original_texis/searching.texi:2242
#, no-wrap
msgid "The Match Data"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:2243
#, no-wrap
msgid "match data"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2250
msgid ""
"Emacs keeps track of the start and end positions of the segments of text "
"found during a search; this is called the @dfn{match data}.  Thanks to the "
"match data, you can search for a complex pattern, such as a date in a mail "
"message, and then extract parts of the match under control of the pattern."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2256
msgid ""
"Because the match data normally describe the most recent search only, you "
"must be careful not to do another search inadvertently between the search "
"you wish to refer back to and the use of the match data.  If you can't avoid "
"another intervening search, you must save and restore the match data around "
"it, to prevent it from being overwritten."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2262
msgid ""
"Notice that all functions are allowed to overwrite the match data unless "
"they're explicitly documented not to do so.  A consequence is that functions "
"that are run implicitly in the background (@pxref{Timers}, and @ref{Idle "
"Timers}) should likely save and restore the match data explicitly."
msgstr ""

#. type: node
#: original_texis/searching.texi:2269 original_texis/searching.texi:2271
#, no-wrap
msgid "Replacing Match"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:2269
msgid "Replacing a substring that was matched."
msgstr ""

#. type: node
#: original_texis/searching.texi:2269 original_texis/searching.texi:2355
#, no-wrap
msgid "Simple Match Data"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:2269
msgid ""
"Accessing single items of match data, such as where a particular "
"subexpression started."
msgstr ""

#. type: node
#: original_texis/searching.texi:2269 original_texis/searching.texi:2501
#, no-wrap
msgid "Entire Match Data"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:2269
msgid "Accessing the entire match data at once, as a list."
msgstr ""

#. type: node
#: original_texis/searching.texi:2269 original_texis/searching.texi:2583
#, no-wrap
msgid "Saving Match Data"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:2269
msgid "Saving and restoring the match data."
msgstr ""

#. type: subsection
#: original_texis/searching.texi:2272
#, no-wrap
msgid "Replacing the Text that Matched"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:2273
#, no-wrap
msgid "replace matched text"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2277
msgid ""
"This function replaces all or part of the text matched by the last search.  "
"It works by means of the match data."
msgstr ""

#. type: cindex
#: original_texis/searching.texi:2278
#, no-wrap
msgid "case in replacements"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2279
#, no-wrap
msgid "replace-match replacement &optional fixedcase literal string subexp"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2281
msgid "This function performs a replacement operation on a buffer or string."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2288
msgid ""
"If you did the last search in a buffer, you should omit the @var{string} "
"argument or specify @code{nil} for it, and make sure that the current buffer "
"is the one in which you performed the last search.  Then this function edits "
"the buffer, replacing the matched text with @var{replacement}.  It leaves "
"point at the end of the replacement text."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2292
msgid ""
"If you performed the last search on a string, pass the same string as "
"@var{string}.  Then this function returns a new string, in which the matched "
"text is replaced by @var{replacement}."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2302
msgid ""
"If @var{fixedcase} is non-@code{nil}, then @code{replace-match} uses the "
"replacement text without case conversion; otherwise, it converts the "
"replacement text depending upon the capitalization of the text to be "
"replaced.  If the original text is all upper case, this converts the "
"replacement text to upper case.  If all words of the original text are "
"capitalized, this capitalizes all the words of the replacement text.  If all "
"the words are one-letter and they are all upper case, they are treated as "
"capitalized words rather than all-upper-case words."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2308
msgid ""
"If @var{literal} is non-@code{nil}, then @var{replacement} is inserted "
"exactly as it is, the only alterations being case changes as needed.  If it "
"is @code{nil} (the default), then the character @samp{\\} is treated "
"specially.  If a @samp{\\} appears in @var{replacement}, then it must be "
"part of one of the following sequences:"
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:2310
#, no-wrap
msgid "\\&"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:2311
#, no-wrap
msgid "@samp{&} in replacement"
msgstr ""

#. type: table
#: original_texis/searching.texi:2313
msgid "This stands for the entire text being replaced."
msgstr ""

#. type: item
#: original_texis/searching.texi:2314
#, no-wrap
msgid "@samp{\\@var{n}}, where @var{n} is a digit"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:2315
#, no-wrap
msgid "@samp{\\@var{n}} in replacement"
msgstr ""

#. type: table
#: original_texis/searching.texi:2320
msgid ""
"This stands for the text that matched the @var{n}th subexpression in the "
"original regexp.  Subexpressions are those expressions grouped inside "
"@samp{\\(@dots{}\\)}.  If the @var{n}th subexpression never matched, an "
"empty string is substituted."
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:2321
#, no-wrap
msgid "\\\\"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:2322
#, no-wrap
msgid "@samp{\\} in replacement"
msgstr ""

#. type: table
#: original_texis/searching.texi:2324
msgid "This stands for a single @samp{\\} in the replacement text."
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:2325
#, no-wrap
msgid "\\?"
msgstr ""

#. type: table
#: original_texis/searching.texi:2329
msgid ""
"This stands for itself (for compatibility with @code{replace-regexp} and "
"related commands; @pxref{Regexp Replace,,, emacs, The GNU Emacs Manual})."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2333
msgid "Any other character following @samp{\\} signals an error."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2337
msgid ""
"The substitutions performed by @samp{\\&} and @samp{\\@var{n}} occur after "
"case conversion, if any.  Therefore, the strings they substitute are never "
"case-converted."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2343
msgid ""
"If @var{subexp} is non-@code{nil}, that says to replace just subexpression "
"number @var{subexp} of the regexp that was matched, not the entire match.  "
"For example, after matching @samp{foo \\(ba*r\\)}, calling "
"@code{replace-match} with 1 as @var{subexp} means to replace just the text "
"that matched @samp{\\(ba*r\\)}."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2345
#, no-wrap
msgid ""
"match-substitute-replacement replacement &optional fixedcase literal string "
"subexp"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2353
msgid ""
"This function returns the text that would be inserted into the buffer by "
"@code{replace-match}, but without modifying the buffer.  It is useful if you "
"want to present the user with actual replacement result, with constructs "
"like @samp{\\@var{n}} or @samp{\\&} substituted with matched groups.  "
"Arguments @var{replacement} and optional @var{fixedcase}, @var{literal}, "
"@var{string} and @var{subexp} have the same meaning as for "
"@code{replace-match}."
msgstr ""

#. type: subsection
#: original_texis/searching.texi:2356
#, no-wrap
msgid "Simple Match Data Access"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2360
msgid ""
"This section explains how to use the match data to find out what was matched "
"by the last search or match operation, if it succeeded."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2366
msgid ""
"You can ask about the entire matching text, or about a particular "
"parenthetical subexpression of a regular expression.  The @var{count} "
"argument in the functions below specifies which.  If @var{count} is zero, "
"you are asking about the entire match.  If @var{count} is positive, it "
"specifies which subexpression you want."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2374
msgid ""
"Recall that the subexpressions of a regular expression are those expressions "
"grouped with escaped parentheses, @samp{\\(@dots{}\\)}.  The @var{count}th "
"subexpression is found by counting occurrences of @samp{\\(} from the "
"beginning of the whole regular expression.  The first subexpression is "
"numbered 1, the second 2, and so on.  Only regular expressions can have "
"subexpressions---after a simple string search, the only information "
"available is about the entire match."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2382
msgid ""
"Every successful search sets the match data.  Therefore, you should query "
"the match data immediately after searching, before calling any other "
"function that might perform another search.  Alternatively, you may save and "
"restore the match data (@pxref{Saving Match Data}) around the call to "
"functions that could perform another search.  Or use the functions that "
"explicitly do not modify the match data; e.g., @code{string-match-p}."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2389
msgid ""
"A search which fails may or may not alter the match data.  In the current "
"implementation, it does not, but we may change it in the future.  Don't try "
"to rely on the value of the match data after a failing search."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2390
#, no-wrap
msgid "match-string count &optional in-string"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2395
msgid ""
"This function returns, as a string, the text matched in the last search or "
"match operation.  It returns the entire text if @var{count} is zero, or just "
"the portion corresponding to the @var{count}th parenthetical subexpression, "
"if @var{count} is positive."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2403
msgid ""
"If the last such operation was done against a string with "
"@code{string-match}, then you should pass the same string as the argument "
"@var{in-string}.  After a buffer search or match, you should omit "
"@var{in-string} or pass @code{nil} for it; but you should make sure that the "
"current buffer when you call @code{match-string} is the one in which you did "
"the searching or matching.  Failure to follow this advice will lead to "
"incorrect results."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2407
msgid ""
"The value is @code{nil} if @var{count} is out of range, or for a "
"subexpression inside a @samp{\\|} alternative that wasn't used or a "
"repetition that repeated zero times."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2409
#, no-wrap
msgid "match-string-no-properties count &optional in-string"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2412
msgid ""
"This function is like @code{match-string} except that the result has no text "
"properties."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2414
#, no-wrap
msgid "match-beginning count"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2418
msgid ""
"If the last regular expression search found a match, this function returns "
"the position of the start of the matching text or of a subexpression of it."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2423
msgid ""
"If @var{count} is zero, then the value is the position of the start of the "
"entire match.  Otherwise, @var{count} specifies a subexpression in the "
"regular expression, and the value of the function is the starting position "
"of the match for that subexpression."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2426
msgid ""
"The value is @code{nil} for a subexpression inside a @samp{\\|} alternative "
"that wasn't used or a repetition that repeated zero times."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2428
#, no-wrap
msgid "match-end count"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2432
msgid ""
"This function is like @code{match-beginning} except that it returns the "
"position of the end of the match, rather than the position of the beginning."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2436
msgid ""
"Here is an example of using the match data, with a comment showing the "
"positions within the text:"
msgstr ""

#. type: group
#: original_texis/searching.texi:2443
#, no-wrap
msgid ""
"(string-match \"\\\\(qu\\\\)\\\\(ick\\\\)\"\n"
"              \"The quick fox jumped quickly.\")\n"
"              ;0123456789\n"
"     @result{} 4\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:2452
#, no-wrap
msgid ""
"(match-string 0 \"The quick fox jumped quickly.\")\n"
"     @result{} \"quick\"\n"
"(match-string 1 \"The quick fox jumped quickly.\")\n"
"     @result{} \"qu\"\n"
"(match-string 2 \"The quick fox jumped quickly.\")\n"
"     @result{} \"ick\"\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:2457
#, no-wrap
msgid ""
"(match-beginning 1)       ; @r{The beginning of the match}\n"
"     @result{} 4                 ;   @r{with @samp{qu} is at index 4.}\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:2462
#, no-wrap
msgid ""
"(match-beginning 2)       ; @r{The beginning of the match}\n"
"     @result{} 6                 ;   @r{with @samp{ick} is at index 6.}\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:2467
#, no-wrap
msgid ""
"(match-end 1)             ; @r{The end of the match}\n"
"     @result{} 6                 ;   @r{with @samp{qu} is at index 6.}\n"
"\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:2470
#, no-wrap
msgid ""
"(match-end 2)             ; @r{The end of the match}\n"
"     @result{} 9                 ;   @r{with @samp{ick} is at index 9.}\n"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2478
msgid ""
"Here is another example.  Point is initially located at the beginning of the "
"line.  Searching moves point to between the space and the word @samp{in}.  "
"The beginning of the entire match is at the 9th character of the buffer "
"(@samp{T}), and the beginning of the match for the first subexpression is at "
"the 13th character (@samp{c})."
msgstr ""

#. type: group
#: original_texis/searching.texi:2486
#, no-wrap
msgid ""
"(list\n"
"  (re-search-forward \"The \\\\(cat \\\\)\")\n"
"  (match-beginning 0)\n"
"  (match-beginning 1))\n"
"    @result{} (17 9 13)\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:2494
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"I read \"The cat @point{}in the hat comes back\" twice.\n"
"        ^   ^\n"
"        9  13\n"
"---------- Buffer: foo ----------\n"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2500
msgid ""
"(In this case, the index returned is a buffer position; the first character "
"of the buffer counts as 1.)"
msgstr ""

#. type: subsection
#: original_texis/searching.texi:2502
#, no-wrap
msgid "Accessing the Entire Match Data"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2506
msgid ""
"The functions @code{match-data} and @code{set-match-data} read or write the "
"entire match data, all at once."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2507
#, no-wrap
msgid "match-data &optional integers reuse reseat"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2515
msgid ""
"This function returns a list of positions (markers or integers) that record "
"all the information on the text that the last search matched.  Element zero "
"is the position of the beginning of the match for the whole expression; "
"element one is the position of the end of the match for the expression.  The "
"next two elements are the positions of the beginning and end of the match "
"for the first subexpression, and so on.  In general, element"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:2517
msgid "number 2@var{n}"
msgstr ""

#. type: tex
#: original_texis/searching.texi:2520
#, no-wrap
msgid "number {\\mathsurround=0pt $2n$}\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2523
msgid "corresponds to @code{(match-beginning @var{n})}; and element"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:2525
msgid "number 2@var{n} + 1"
msgstr ""

#. type: tex
#: original_texis/searching.texi:2528
#, no-wrap
msgid "number {\\mathsurround=0pt $2n+1$}\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2530
msgid "corresponds to @code{(match-end @var{n})}."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2538
msgid ""
"Normally all the elements are markers or @code{nil}, but if @var{integers} "
"is non-@code{nil}, that means to use integers instead of markers.  (In that "
"case, the buffer itself is appended as an additional element at the end of "
"the list, to facilitate complete restoration of the match data.)  If the "
"last match was done on a string with @code{string-match}, then integers are "
"always used, since markers can't point into a string."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2547
msgid ""
"If @var{reuse} is non-@code{nil}, it should be a list.  In that case, "
"@code{match-data} stores the match data in @var{reuse}.  That is, "
"@var{reuse} is destructively modified.  @var{reuse} does not need to have "
"the right length.  If it is not long enough to contain the match data, it is "
"extended.  If it is too long, the length of @var{reuse} stays the same, but "
"the elements that were not used are set to @code{nil}.  The purpose of this "
"feature is to reduce the need for garbage collection."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2550
msgid ""
"If @var{reseat} is non-@code{nil}, all markers on the @var{reuse} list are "
"reseated to point to nowhere."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2554
msgid ""
"As always, there must be no possibility of intervening searches between the "
"call to a search function and the call to @code{match-data} that is intended "
"to access the match data for that search."
msgstr ""

#. type: group
#: original_texis/searching.texi:2562
#, no-wrap
msgid ""
"(match-data)\n"
"     @result{}  (#<marker at 9 in foo>\n"
"          #<marker at 17 in foo>\n"
"          #<marker at 13 in foo>\n"
"          #<marker at 17 in foo>)\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2566
#, no-wrap
msgid "set-match-data match-list &optional reseat"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2571
msgid ""
"This function sets the match data from the elements of @var{match-list}, "
"which should be a list that was the value of a previous call to "
"@code{match-data}.  (More precisely, anything that has the same format will "
"work.)"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2574
msgid ""
"If @var{match-list} refers to a buffer that doesn't exist, you don't get an "
"error; that sets the match data in a meaningless but harmless way."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2577
msgid ""
"If @var{reseat} is non-@code{nil}, all markers on the @var{match-list} list "
"are reseated to point to nowhere."
msgstr ""

#. type: findex
#: original_texis/searching.texi:2579
#, no-wrap
msgid "store-match-data"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2581
msgid "@code{store-match-data} is a semi-obsolete alias for @code{set-match-data}."
msgstr ""

#. type: subsection
#: original_texis/searching.texi:2584
#, no-wrap
msgid "Saving and Restoring the Match Data"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2590
msgid ""
"When you call a function that may search, you may need to save and restore "
"the match data around that call, if you want to preserve the match data from "
"an earlier search for later use.  Here is an example that shows the problem "
"that arises if you fail to save the match data:"
msgstr ""

#. type: group
#: original_texis/searching.texi:2598
#, no-wrap
msgid ""
"(re-search-forward \"The \\\\(cat \\\\)\")\n"
"     @result{} 48\n"
"(foo)                   ; @r{@code{foo} does more searching.}\n"
"(match-end 0)\n"
"     @result{} 61              ; @r{Unexpected result---not 48!}\n"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2602
msgid "You can save and restore the match data with @code{save-match-data}:"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:2603
#, no-wrap
msgid "save-match-data body@dots{}"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:2607
msgid ""
"This macro executes @var{body}, saving and restoring the match data around "
"it.  The return value is the value of the last form in @var{body}."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2612
msgid ""
"You could use @code{set-match-data} together with @code{match-data} to "
"imitate the effect of the special form @code{save-match-data}.  Here is how:"
msgstr ""

#. type: group
#: original_texis/searching.texi:2619
#, no-wrap
msgid ""
"(let ((data (match-data)))\n"
"  (unwind-protect\n"
"      @dots{}   ; @r{Ok to change the original match data.}\n"
"    (set-match-data data)))\n"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2625
msgid ""
"Emacs automatically saves and restores the match data when it runs process "
"filter functions (@pxref{Filter Functions}) and process sentinels "
"(@pxref{Sentinels})."
msgstr ""

#. type: group
#: original_texis/searching.texi:2638
#, no-wrap
msgid ""
"(defun restore-match-data (data)\n"
"  \"Restore the match data DATA unless the buffer is missing.\"\n"
"  (catch 'foo\n"
"    (let ((d data))\n"
msgstr ""

#. type: smallexample
#: original_texis/searching.texi:2642
#, no-wrap
msgid ""
"      (while d\n"
"        (and (car d)\n"
"             (null (marker-buffer (car d)))\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:2647
#, no-wrap
msgid ""
"             ;; @file{match-data} @r{buffer is deleted.}\n"
"             (throw 'foo nil))\n"
"        (setq d (cdr d)))\n"
"      (set-match-data data))))\n"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:2653
#, no-wrap
msgid "replacement after search"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:2654
#, no-wrap
msgid "searching and replacing"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2659
msgid ""
"If you want to find all matches for a regexp in part of the buffer and "
"replace them, the most flexible way is to write an explicit loop using "
"@code{re-search-forward} and @code{replace-match}, like this:"
msgstr ""

#. type: example
#: original_texis/searching.texi:2663
#, no-wrap
msgid ""
"(while (re-search-forward \"foo[ \\t]+bar\" nil t)\n"
"  (replace-match \"foobar\"))\n"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2668
msgid ""
"@xref{Replacing Match,, Replacing the Text that Matched}, for a description "
"of @code{replace-match}."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2671
msgid ""
"It may be more convenient to limit the replacements to a specific region.  "
"The function @code{replace-regexp-in-region} does that."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2672
#, no-wrap
msgid "replace-regexp-in-region regexp replacement &optional start end"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2683
msgid ""
"This function replaces all the occurrences of @var{regexp} with "
"@var{replacement} in the region of buffer text between @var{start} and "
"@var{end}; @var{start} defaults to position of point, and @var{end} defaults "
"to the last accessible position of the buffer.  The search for @var{regexp} "
"is case-sensitive, and @var{replacement} is inserted without changing its "
"letter-case.  The @var{replacement} string can use the same special elements "
"starting with @samp{\\} as @code{replace-match} does.  The function returns "
"the number of replaced occurrences, or @code{nil} if @var{regexp} is not "
"found.  The function preserves the position of point."
msgstr ""

#. type: example
#: original_texis/searching.texi:2686
#, no-wrap
msgid "(replace-regexp-in-region \"foo[ \\t]+bar\" \"foobar\")\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2689
#, no-wrap
msgid "replace-string-in-region string replacement &optional start end"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2693
msgid ""
"This function works similarly to @code{replace-regexp-in-region}, but "
"searches for, and replaces, literal @var{string}s instead of regular "
"expressions."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2696
msgid "Emacs also has special functions for replacing matches in a string."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2697
#, no-wrap
msgid ""
"replace-regexp-in-string regexp rep string &optional fixedcase literal "
"subexp start"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2705
msgid ""
"This function copies @var{string} and searches it for matches for "
"@var{regexp}, and replaces them with @var{rep}.  It returns the modified "
"copy.  If @var{start} is non-@code{nil}, the search for matches starts at "
"that index in @var{string}, and the returned value does not include the "
"first @var{start} characters of @var{string}.  To get the whole transformed "
"string, concatenate the first @var{start} characters of @var{string} with "
"the return value."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2709
msgid ""
"This function uses @code{replace-match} to do the replacement, and it passes "
"the optional arguments @var{fixedcase}, @var{literal} and @var{subexp} along "
"to @code{replace-match}."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2716
msgid ""
"Instead of a string, @var{rep} can be a function.  In that case, "
"@code{replace-regexp-in-string} calls @var{rep} for each match, passing the "
"text of the match as its sole argument.  It collects the value @var{rep} "
"returns and passes that to @code{replace-match} as the replacement string.  "
"The match data at this point are the result of matching @var{regexp} against "
"a substring of @var{string}."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2718
#, no-wrap
msgid "string-replace from-string to-string in-string"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2723
msgid ""
"This function replaces all occurrences of @var{from-string} with "
"@var{to-string} in @var{in-string} and returns the result.  It may return "
"one of its arguments unchanged, a constant string or a new string.  Case is "
"significant, and text properties are ignored."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2727
msgid ""
"If you want to write a command along the lines of @code{query-replace}, you "
"can use @code{perform-replace} to do the work."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2728
#, no-wrap
msgid ""
"perform-replace from-string replacements query-flag regexp-flag "
"delimited-flag &optional repeat-count map start end backward "
"region-noncontiguous-p"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2736
msgid ""
"This function is the guts of @code{query-replace} and related commands.  It "
"searches for occurrences of @var{from-string} in the text between positions "
"@var{start} and @var{end} and replaces some or all of them.  If @var{start} "
"is @code{nil} (or omitted), point is used instead, and the end of the "
"buffer's accessible portion is used for @var{end}.  (If the optional "
"argument @var{backward} is non-@code{nil}, the search starts at @var{end} "
"and goes backward.)"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2739
msgid ""
"If @var{query-flag} is @code{nil}, it replaces all occurrences; otherwise, "
"it asks the user what to do about each one."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2744
msgid ""
"If @var{regexp-flag} is non-@code{nil}, then @var{from-string} is considered "
"a regular expression; otherwise, it must match literally.  If "
"@var{delimited-flag} is non-@code{nil}, then only replacements surrounded by "
"word boundaries are considered."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2748
msgid ""
"The argument @var{replacements} specifies what to replace occurrences with.  "
"If it is a string, that string is used.  It can also be a list of strings, "
"to be used in cyclic order."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2753
msgid ""
"If @var{replacements} is a cons cell, @w{@code{(@var{function} "
". @var{data})}}, this means to call @var{function} after each match to get "
"the replacement text.  This function is called with two arguments: "
"@var{data}, and the number of replacements already made."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2757
msgid ""
"If @var{repeat-count} is non-@code{nil}, it should be an integer.  Then it "
"specifies how many times to use each of the strings in the "
"@var{replacements} list before advancing cyclically to the next one."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2761
msgid ""
"If @var{from-string} contains upper-case letters, then "
"@code{perform-replace} binds @code{case-fold-search} to @code{nil}, and it "
"uses the @var{replacements} without altering their case."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2766
msgid ""
"Normally, the keymap @code{query-replace-map} defines the possible user "
"responses for queries.  The argument @var{map}, if non-@code{nil}, specifies "
"a keymap to use instead of @code{query-replace-map}."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2771
msgid ""
"Non-@code{nil} @var{region-noncontiguous-p} means that the region between "
"@var{start} and @var{end} is composed of noncontiguous pieces.  The most "
"common example of this is a rectangular region, where the pieces are "
"separated by newline characters."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2778
msgid ""
"This function uses one of two functions to search for the next occurrence of "
"@var{from-string}.  These functions are specified by the values of two "
"variables: @code{replace-re-search-function} and "
"@code{replace-search-function}.  The former is called when the argument "
"@var{regexp-flag} is non-@code{nil}, the latter when it is @code{nil}."
msgstr ""

#. type: defvar
#: original_texis/searching.texi:2780
#, no-wrap
msgid "query-replace-map"
msgstr ""

#. type: defvar
#: original_texis/searching.texi:2785
msgid ""
"This variable holds a special keymap that defines the valid user responses "
"for @code{perform-replace} and the commands that use it, as well as "
"@code{y-or-n-p} and @code{map-y-or-n-p}.  This map is unusual in two ways:"
msgstr ""

#. type: itemize
#: original_texis/searching.texi:2790
msgid ""
"The key bindings are not commands, just symbols that are meaningful to the "
"functions that use this map."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:2796
msgid ""
"Prefix keys are not supported; each key binding must be for a single-event "
"key sequence.  This is because the functions don't use "
"@code{read-key-sequence} to get the input; instead, they read a single event "
"and look it up ``by hand''."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2802
msgid ""
"Here are the meaningful bindings for @code{query-replace-map}.  Several of "
"them are meaningful only for @code{query-replace} and friends."
msgstr ""

#. type: item
#: original_texis/searching.texi:2804
#, no-wrap
msgid "act"
msgstr ""

#. type: table
#: original_texis/searching.texi:2806
msgid "Do take the action being considered---in other words, ``yes''."
msgstr ""

#. type: item
#: original_texis/searching.texi:2807
#, no-wrap
msgid "skip"
msgstr ""

#. type: table
#: original_texis/searching.texi:2809
msgid "Do not take action for this question---in other words, ``no''."
msgstr ""

#. type: item
#: original_texis/searching.texi:2810
#, no-wrap
msgid "exit"
msgstr ""

#. type: table
#: original_texis/searching.texi:2813
msgid ""
"Answer this question ``no'', and give up on the entire series of questions, "
"assuming that the answers will be ``no''."
msgstr ""

#. type: item
#: original_texis/searching.texi:2814
#, no-wrap
msgid "exit-prefix"
msgstr ""

#. type: table
#: original_texis/searching.texi:2817
msgid ""
"Like @code{exit}, but add the key that was pressed to "
"@code{unread-command-events} (@pxref{Event Input Misc})."
msgstr ""

#. type: item
#: original_texis/searching.texi:2818
#, no-wrap
msgid "act-and-exit"
msgstr ""

#. type: table
#: original_texis/searching.texi:2821
msgid ""
"Answer this question ``yes'', and give up on the entire series of questions, "
"assuming that subsequent answers will be ``no''."
msgstr ""

#. type: item
#: original_texis/searching.texi:2822
#, no-wrap
msgid "act-and-show"
msgstr ""

#. type: table
#: original_texis/searching.texi:2825
msgid ""
"Answer this question ``yes'', but show the results---don't advance yet to "
"the next question."
msgstr ""

#. type: item
#: original_texis/searching.texi:2826
#, no-wrap
msgid "automatic"
msgstr ""

#. type: table
#: original_texis/searching.texi:2829
msgid ""
"Answer this question and all subsequent questions in the series with "
"``yes'', without further user interaction."
msgstr ""

#. type: item
#: original_texis/searching.texi:2830
#, no-wrap
msgid "backup"
msgstr ""

#. type: table
#: original_texis/searching.texi:2832
msgid "Move back to the previous place that a question was asked about."
msgstr ""

#. type: item
#: original_texis/searching.texi:2833
#, no-wrap
msgid "undo"
msgstr ""

#. type: table
#: original_texis/searching.texi:2836
msgid ""
"Undo last replacement and move back to the place where that replacement was "
"performed."
msgstr ""

#. type: item
#: original_texis/searching.texi:2837
#, no-wrap
msgid "undo-all"
msgstr ""

#. type: table
#: original_texis/searching.texi:2840
msgid ""
"Undo all replacements and move back to the place where the first replacement "
"was performed."
msgstr ""

#. type: item
#: original_texis/searching.texi:2841
#, no-wrap
msgid "edit"
msgstr ""

#. type: table
#: original_texis/searching.texi:2844
msgid ""
"Enter a recursive edit to deal with this question---instead of any other "
"action that would normally be taken."
msgstr ""

#. type: item
#: original_texis/searching.texi:2845
#, no-wrap
msgid "edit-replacement"
msgstr ""

#. type: table
#: original_texis/searching.texi:2847
msgid "Edit the replacement for this question in the minibuffer."
msgstr ""

#. type: item
#: original_texis/searching.texi:2848
#, no-wrap
msgid "delete-and-edit"
msgstr ""

#. type: table
#: original_texis/searching.texi:2851
msgid "Delete the text being considered, then enter a recursive edit to replace it."
msgstr ""

#. type: item
#: original_texis/searching.texi:2852
#, no-wrap
msgid "recenter"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:2853
#, no-wrap
msgid "scroll-up"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:2854
#, no-wrap
msgid "scroll-down"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:2855
#, no-wrap
msgid "scroll-other-window"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:2856
#, no-wrap
msgid "scroll-other-window-down"
msgstr ""

#. type: table
#: original_texis/searching.texi:2860
msgid ""
"Perform the specified window scroll operation, then ask the same question "
"again.  Only @code{y-or-n-p} and related functions use this answer."
msgstr ""

#. type: item
#: original_texis/searching.texi:2861
#, no-wrap
msgid "quit"
msgstr ""

#. type: table
#: original_texis/searching.texi:2864
msgid ""
"Perform a quit right away.  Only @code{y-or-n-p} and related functions use "
"this answer."
msgstr ""

#. type: item
#: original_texis/searching.texi:2865
#, no-wrap
msgid "help"
msgstr ""

#. type: table
#: original_texis/searching.texi:2867
msgid "Display some help, then ask again."
msgstr ""

#. type: defvar
#: original_texis/searching.texi:2869
#, no-wrap
msgid "multi-query-replace-map"
msgstr ""

#. type: defvar
#: original_texis/searching.texi:2873
msgid ""
"This variable holds a keymap that extends @code{query-replace-map} by "
"providing additional key bindings that are useful in multi-buffer "
"replacements.  The additional bindings are:"
msgstr ""

#. type: item
#: original_texis/searching.texi:2875
#, no-wrap
msgid "automatic-all"
msgstr ""

#. type: table
#: original_texis/searching.texi:2878
msgid ""
"Answer this question and all subsequent questions in the series with "
"``yes'', without further user interaction, for all remaining buffers."
msgstr ""

#. type: item
#: original_texis/searching.texi:2879
#, no-wrap
msgid "exit-current"
msgstr ""

#. type: table
#: original_texis/searching.texi:2883
msgid ""
"Answer this question ``no'', and give up on the entire series of questions "
"for the current buffer.  Continue to the next buffer in the sequence."
msgstr ""

#. type: defvar
#: original_texis/searching.texi:2886
#, no-wrap
msgid "replace-search-function"
msgstr ""

#. type: defvar
#: original_texis/searching.texi:2892
msgid ""
"This variable specifies a function that @code{perform-replace} calls to "
"search for the next string to replace.  Its default value is "
"@code{search-forward}.  Any other value should name a function of 3 "
"arguments: the first 3 arguments of @code{search-forward} (@pxref{String "
"Search})."
msgstr ""

#. type: defvar
#: original_texis/searching.texi:2894
#, no-wrap
msgid "replace-re-search-function"
msgstr ""

#. type: defvar
#: original_texis/searching.texi:2900
msgid ""
"This variable specifies a function that @code{perform-replace} calls to "
"search for the next regexp to replace.  Its default value is "
"@code{re-search-forward}.  Any other value should name a function of 3 "
"arguments: the first 3 arguments of @code{re-search-forward} (@pxref{Regexp "
"Search})."
msgstr ""

#. type: section
#: original_texis/searching.texi:2903
#, no-wrap
msgid "Standard Regular Expressions Used in Editing"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:2904
#, no-wrap
msgid "regexps used standardly in editing"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:2905
#, no-wrap
msgid "standard regexps used in editing"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2909
msgid ""
"This section describes some variables that hold regular expressions used for "
"certain purposes in editing:"
msgstr ""

#. type: defopt
#: original_texis/searching.texi:2910
#, no-wrap
msgid "page-delimiter"
msgstr ""

#. type: defopt
#: original_texis/searching.texi:2915
msgid ""
"This is the regular expression describing line-beginnings that separate "
"pages.  The default value is @code{\"^\\014\"} (i.e., @code{\"^^L\"} or "
"@code{\"^\\C-l\"}); this matches a line that starts with a formfeed "
"character."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2925
msgid ""
"The following two regular expressions should @emph{not} assume the match "
"always starts at the beginning of a line; they should not use @samp{^} to "
"anchor the match.  Most often, the paragraph commands do check for a match "
"only at the beginning of a line, which means that @samp{^} would be "
"superfluous.  When there is a nonzero left margin, they accept matches that "
"start after the left margin.  In that case, a @samp{^} would be incorrect.  "
"However, a @samp{^} is harmless in modes where a left margin is never used."
msgstr ""

#. type: defopt
#: original_texis/searching.texi:2926
#, no-wrap
msgid "paragraph-separate"
msgstr ""

#. type: defopt
#: original_texis/searching.texi:2932
msgid ""
"This is the regular expression for recognizing the beginning of a line that "
"separates paragraphs.  (If you change this, you may have to change "
"@code{paragraph-start} also.)  The default value is @w{@code{\"[@ "
"\\t\\f]*$\"}}, which matches a line that consists entirely of spaces, tabs, "
"and form feeds (after its left margin)."
msgstr ""

#. type: defopt
#: original_texis/searching.texi:2934
#, no-wrap
msgid "paragraph-start"
msgstr ""

#. type: defopt
#: original_texis/searching.texi:2939
msgid ""
"This is the regular expression for recognizing the beginning of a line that "
"starts @emph{or} separates paragraphs.  The default value is "
"@w{@code{\"\\f\\\\|[ \\t]*$\"}}, which matches a line containing only "
"whitespace or starting with a form feed (after its left margin)."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2941 original_texis/searching.texi:2952
#, no-wrap
msgid "sentence-end"
msgstr ""

#. type: defopt
#: original_texis/searching.texi:2945
msgid ""
"If non-@code{nil}, the value should be a regular expression describing the "
"end of a sentence, including the whitespace following the sentence.  (All "
"paragraph boundaries also end sentences, regardless.)"
msgstr ""

#. type: defopt
#: original_texis/searching.texi:2950
msgid ""
"If the value is @code{nil}, as it is by default, then the function "
"@code{sentence-end} constructs the regexp.  That is why you should always "
"call the function @code{sentence-end} to obtain the regexp to be used to "
"recognize the end of a sentence."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2959
msgid ""
"This function returns the value of the variable @code{sentence-end}, if "
"non-@code{nil}.  Otherwise it returns a default value based on the values of "
"the variables @code{sentence-end-double-space} (@pxref{Definition of "
"sentence-end-double-space}), @code{sentence-end-without-period}, and "
"@code{sentence-end-without-space}."
msgstr ""
