# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2024-08-24 20:09+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: original_texis/searching.texi:6 original_texis/searching.texi:7
#, no-wrap
msgid "Searching and Matching"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:8
#, no-wrap
msgid "searching"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:15
msgid ""
"GNU Emacs provides two ways to search through a buffer for specified text: "
"exact string searches and regular expression searches.  After a regular "
"expression search, you can examine the @dfn{match data} to determine which "
"text matched the whole regular expression or various portions of it."
msgstr ""

#. type: node
#: original_texis/searching.texi:27 original_texis/searching.texi:33
#, no-wrap
msgid "String Search"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:27
msgid "Search for an exact match."
msgstr ""

#. type: section
#: original_texis/searching.texi:27 original_texis/searching.texi:192
#: original_texis/searching.texi:193
#, no-wrap
msgid "Searching and Case"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:27
msgid "Case-independent or case-significant searching."
msgstr ""

#. type: section
#: original_texis/searching.texi:27 original_texis/searching.texi:235
#: original_texis/searching.texi:236
#, no-wrap
msgid "Regular Expressions"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:27
msgid "Describing classes of strings."
msgstr ""

#. type: node
#: original_texis/searching.texi:27 original_texis/searching.texi:1986
#, no-wrap
msgid "Regexp Search"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:27
msgid "Searching for a match for a regexp."
msgstr ""

#. type: node
#: original_texis/searching.texi:27 original_texis/searching.texi:2226
#, no-wrap
msgid "Longest Match"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:27
msgid "Searching for the longest match."
msgstr ""

#. type: node
#: original_texis/searching.texi:27 original_texis/searching.texi:2273
#, no-wrap
msgid "Match Data"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:27
msgid "Finding out which part of the text matched, after a string or regexp search."
msgstr ""

#. type: section
#: original_texis/searching.texi:27 original_texis/searching.texi:2683
#: original_texis/searching.texi:2684
#, no-wrap
msgid "Search and Replace"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:27
msgid "Commands that loop, searching and replacing."
msgstr ""

#. type: node
#: original_texis/searching.texi:27 original_texis/searching.texi:2934
#, no-wrap
msgid "Standard Regexps"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:27
msgid "Useful regexps for finding sentences, pages,..."
msgstr ""

#. type: node
#: original_texis/searching.texi:27 original_texis/searching.texi:2993
#, no-wrap
msgid "POSIX Regexps"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:27
msgid "Emacs regexps vs POSIX regexps."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:32
msgid ""
"The @samp{skip-chars@dots{}} functions also perform a kind of searching.  "
"@xref{Skipping Characters}.  To search for changes in character properties, "
"see @ref{Property Search}."
msgstr ""

#. type: section
#: original_texis/searching.texi:34
#, no-wrap
msgid "Searching for Strings"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:35
#, no-wrap
msgid "string search"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:43
msgid ""
"These are the primitive functions for searching through the text in a "
"buffer.  They are meant for use in programs, but you may call them "
"interactively.  If you do so, they prompt for the search string; the "
"arguments @var{limit} and @var{noerror} are @code{nil}, and @var{repeat} is "
"1.  For more details on interactive searching, @pxref{Search,, Searching and "
"Replacement, emacs, The GNU Emacs Manual}."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:47
msgid ""
"These search functions convert the search string to multibyte if the buffer "
"is multibyte; they convert the search string to unibyte if the buffer is "
"unibyte.  @xref{Text Representations}."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:48
#, no-wrap
msgid "Command search-forward string &optional limit noerror count"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:53
msgid ""
"This function searches forward from point for an exact match for "
"@var{string}.  If successful, it sets point to the end of the occurrence "
"found, and returns the new value of point.  If no match is found, the value "
"and side effects depend on @var{noerror} (see below)."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:57
msgid ""
"In the following example, point is initially at the beginning of the line.  "
"Then @code{(search-forward \"fox\")} moves point after the last letter of "
"@samp{fox}:"
msgstr ""

#. type: group
#: original_texis/searching.texi:63
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"@point{}The quick brown fox jumped over the lazy dog.\n"
"---------- Buffer: foo ----------\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:68
#, no-wrap
msgid ""
"(search-forward \"fox\")\n"
"     @result{} 20\n"
"\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:72
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"The quick brown fox@point{} jumped over the lazy dog.\n"
"---------- Buffer: foo ----------\n"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:79
msgid ""
"The argument @var{limit} specifies the bound to the search, and should be a "
"position in the current buffer.  No match extending after that position is "
"accepted.  If @var{limit} is omitted or @code{nil}, it defaults to the end "
"of the accessible portion of the buffer."
msgstr ""

#. type: kindex
#: original_texis/searching.texi:80
#, no-wrap
msgid "search-failed"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:89
msgid ""
"What happens when the search fails depends on the value of @var{noerror}.  "
"If @var{noerror} is @code{nil}, a @code{search-failed} error is signaled.  "
"If @var{noerror} is @code{t}, @code{search-forward} returns @code{nil} and "
"does nothing.  If @var{noerror} is neither @code{nil} nor @code{t}, then "
"@code{search-forward} moves point to the upper bound and returns @code{nil}."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:98 original_texis/searching.texi:2032
msgid ""
"The argument @var{noerror} only affects valid searches which fail to find a "
"match.  Invalid arguments cause errors regardless of @var{noerror}."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:107 original_texis/searching.texi:2041
msgid ""
"If @var{count} is a positive number @var{n}, the search is done @var{n} "
"times; each successive search starts at the end of the previous match.  If "
"all these successive searches succeed, the function call succeeds, moving "
"point and returning its new value.  Otherwise the function call fails, with "
"results depending on the value of @var{noerror}, as described above.  If "
"@var{count} is a negative number @minus{}@var{n}, the search is done @var{n} "
"times in the opposite (backward) direction."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:109
#, no-wrap
msgid "Command search-backward string &optional limit noerror count"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:114
msgid ""
"This function searches backward from point for @var{string}.  It is like "
"@code{search-forward}, except that it searches backwards rather than "
"forwards.  Backward searches leave point at the beginning of the match."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:116
#, no-wrap
msgid "Command word-search-forward string &optional limit noerror count"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:120
msgid ""
"This function searches forward from point for a word match for "
"@var{string}.  If it finds a match, it sets point to the end of the match "
"found, and returns the new value of point."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:127
msgid ""
"Word matching regards @var{string} as a sequence of words, disregarding "
"punctuation that separates them.  It searches the buffer for the same "
"sequence of words.  Each word must be distinct in the buffer (searching for "
"the word @samp{ball} does not match the word @samp{balls}), but the details "
"of punctuation and spacing are ignored (searching for @samp{ball boy} does "
"match @samp{ball.  Boy!})."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:130
msgid ""
"In this example, point is initially at the beginning of the buffer; the "
"search leaves it between the @samp{y} and the @samp{!}."
msgstr ""

#. type: group
#: original_texis/searching.texi:137
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"@point{}He said \"Please!  Find\n"
"the ball boy!\"\n"
"---------- Buffer: foo ----------\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:142
#, no-wrap
msgid ""
"(word-search-forward \"Please find the ball, boy.\")\n"
"     @result{} 39\n"
"\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:147
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"He said \"Please!  Find\n"
"the ball boy@point{}!\"\n"
"---------- Buffer: foo ----------\n"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:153
msgid ""
"If @var{limit} is non-@code{nil}, it must be a position in the current "
"buffer; it specifies the upper bound to the search.  The match found must "
"not extend after that position."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:159
msgid ""
"If @var{noerror} is @code{nil}, then @code{word-search-forward} signals an "
"error if the search fails.  If @var{noerror} is @code{t}, then it returns "
"@code{nil} instead of signaling an error.  If @var{noerror} is neither "
"@code{nil} nor @code{t}, it moves point to @var{limit} (or the end of the "
"accessible portion of the buffer) and returns @code{nil}."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:164
msgid ""
"If @var{count} is a positive number, it specifies how many successive "
"occurrences to search for.  Point is positioned at the end of the last "
"match.  If @var{count} is a negative number, the search is backward and "
"point is positioned at the beginning of the last match."
msgstr ""

#. type: findex
#: original_texis/searching.texi:165
#, no-wrap
msgid "word-search-regexp"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:169
msgid ""
"Internally, @code{word-search-forward} and related functions use the "
"function @code{word-search-regexp} to convert @var{string} to a regular "
"expression that ignores punctuation."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:171
#, no-wrap
msgid "Command word-search-forward-lax string &optional limit noerror count"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:177
msgid ""
"This command is identical to @code{word-search-forward}, except that the "
"beginning or the end of @var{string} need not match a word boundary, unless "
"@var{string} begins or ends in whitespace.  For instance, searching for "
"@samp{ball boy} matches @samp{ball boyee}, but does not match @samp{balls "
"boy}."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:179
#, no-wrap
msgid "Command word-search-backward string &optional limit noerror count"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:184
msgid ""
"This function searches backward from point for a word match to "
"@var{string}.  This function is just like @code{word-search-forward} except "
"that it searches backward and normally leaves point at the beginning of the "
"match."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:186
#, no-wrap
msgid "Command word-search-backward-lax string &optional limit noerror count"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:190
msgid ""
"This command is identical to @code{word-search-backward}, except that the "
"beginning or the end of @var{string} need not match a word boundary, unless "
"@var{string} begins or ends in whitespace."
msgstr ""

#. type: cindex
#: original_texis/searching.texi:194
#, no-wrap
msgid "searching and case"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:201
msgid ""
"By default, searches in Emacs ignore the case of the text they are searching "
"through; if you specify searching for @samp{FOO}, then @samp{Foo} or "
"@samp{foo} is also considered a match.  This applies to regular expressions, "
"too; thus, @samp{[aB]} would match @samp{a} or @samp{A} or @samp{b} or "
"@samp{B}."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:209
msgid ""
"If you do not want this feature, set the variable @code{case-fold-search} to "
"@code{nil}.  Then all letters must match exactly, including case.  This is a "
"buffer-local variable; altering the variable affects only the current "
"buffer.  (@xref{Intro to Buffer-Local}.)  Alternatively, you may change the "
"default value.  In Lisp code, you will more typically use @code{let} to bind "
"@code{case-fold-search} to the desired value."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:217
msgid ""
"Note that the user-level incremental search feature handles case "
"distinctions differently.  When the search string contains only lower case "
"letters, the search ignores case, but when the search string contains one or "
"more upper case letters, the search becomes case-sensitive.  But this has "
"nothing to do with the searching functions used in Lisp code.  "
"@xref{Incremental Search,,, emacs, The GNU Emacs Manual}."
msgstr ""

#. type: defopt
#: original_texis/searching.texi:218
#, no-wrap
msgid "case-fold-search"
msgstr ""

#. type: defopt
#: original_texis/searching.texi:222
msgid ""
"This buffer-local variable determines whether searches should ignore case.  "
"If the variable is @code{nil} they do not ignore case; otherwise (and by "
"default) they do ignore case."
msgstr ""

#. type: defopt
#: original_texis/searching.texi:224
#, no-wrap
msgid "case-replace"
msgstr ""

#. type: defopt
#: original_texis/searching.texi:230
msgid ""
"This variable determines whether the higher-level replacement functions "
"should preserve case.  If the variable is @code{nil}, that means to use the "
"replacement text verbatim.  A non-@code{nil} value means to convert the case "
"of the replacement text according to the text being replaced."
msgstr ""

#. type: defopt
#: original_texis/searching.texi:233
msgid ""
"This variable is used by passing it as an argument to the function "
"@code{replace-match}.  @xref{Replacing Match}."
msgstr ""

#. type: cindex
#: original_texis/searching.texi:237
#, no-wrap
msgid "regular expression"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:238
#, no-wrap
msgid "regexp"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:244
msgid ""
"A @dfn{regular expression}, or @dfn{regexp} for short, is a pattern that "
"denotes a (possibly infinite) set of strings.  Searching for matches for a "
"regexp is a very powerful operation.  This section explains how to write "
"regexps; the following section says how to search for them."
msgstr ""

#. type: findex
#: original_texis/searching.texi:245
#, no-wrap
msgid "re-builder"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:246
#, no-wrap
msgid "regular expressions, developing"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:254
msgid ""
"For interactive development of regular expressions, you can use the @kbd{M-x "
"re-builder} command.  It provides a convenient interface for creating "
"regular expressions, by giving immediate visual feedback in a separate "
"buffer.  As you edit the regexp, all its matches in the target buffer are "
"highlighted.  Each parenthesized sub-expression of the regexp is shown in a "
"distinct face, which makes it easier to verify even very complex regexps."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:259
msgid ""
"Note that by default Emacs search ignores case (@pxref{Searching and "
"Case}).  To enable case-sensitive regexp search and match, bind "
"@code{case-fold-search} to @code{nil} around the code you want to be "
"case-sensitive."
msgstr ""

#. type: node
#: original_texis/searching.texi:263 original_texis/searching.texi:270
#, no-wrap
msgid "Syntax of Regexps"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:263
msgid "Rules for writing regular expressions."
msgstr ""

#. type: node
#: original_texis/searching.texi:263 original_texis/searching.texi:930
#, no-wrap
msgid "Regexp Example"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:263
msgid "Illustrates regular expression syntax."
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:265
msgid "* Rx Notation:: An alternative, structured regexp notation."
msgstr ""

#. type: node
#: original_texis/searching.texi:268 original_texis/searching.texi:1780
#, no-wrap
msgid "Regexp Functions"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:268
msgid "Functions for operating on regular expressions."
msgstr ""

#. type: node
#: original_texis/searching.texi:268 original_texis/searching.texi:1907
#, no-wrap
msgid "Regexp Problems"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:268
msgid "Some problems and how they may be avoided."
msgstr ""

#. type: subsection
#: original_texis/searching.texi:271
#, no-wrap
msgid "Syntax of Regular Expressions"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:272 original_texis/searching.texi:1013
#, no-wrap
msgid "regexp syntax"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:273
#, no-wrap
msgid "syntax of regular expressions"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:286
msgid ""
"Regular expressions have a syntax in which a few characters are special "
"constructs and the rest are @dfn{ordinary}.  An ordinary character is a "
"simple regular expression that matches that character and nothing else.  The "
"special characters are @samp{.}, @samp{*}, @samp{+}, @samp{?}, @samp{[}, "
"@samp{^}, @samp{$}, and @samp{\\}; no new special characters will be defined "
"in the future.  The character @samp{]} is special if it ends a bracket "
"expression (see later).  The character @samp{-} is special inside a bracket "
"expression.  A @samp{[:} and balancing @samp{:]} enclose a character class "
"inside a bracket expression.  Any other character appearing in a regular "
"expression is ordinary, unless a @samp{\\} precedes it."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:292
msgid ""
"For example, @samp{f} is not a special character, so it is ordinary, and "
"therefore @samp{f} is a regular expression that matches the string @samp{f} "
"and no other string.  (It does @emph{not} match the string @samp{fg}, but it "
"does match a @emph{part} of that string.)  Likewise, @samp{o} is a regular "
"expression that matches only @samp{o}."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:297
msgid ""
"Any two regular expressions @var{a} and @var{b} can be concatenated.  The "
"result is a regular expression that matches a string if @var{a} matches some "
"amount of the beginning of that string and @var{b} matches the rest of the "
"string."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:302
msgid ""
"As a simple example, we can concatenate the regular expressions @samp{f} and "
"@samp{o} to get the regular expression @samp{fo}, which matches only the "
"string @samp{fo}.  Still trivial.  To do something more powerful, you need "
"to use one of the special regular expression constructs."
msgstr ""

#. type: node
#: original_texis/searching.texi:307 original_texis/searching.texi:309
#, no-wrap
msgid "Regexp Special"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:307
msgid "Special characters in regular expressions."
msgstr ""

#. type: node
#: original_texis/searching.texi:307 original_texis/searching.texi:585
#, no-wrap
msgid "Char Classes"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:307
msgid "Character classes used in regular expressions."
msgstr ""

#. type: node
#: original_texis/searching.texi:307 original_texis/searching.texi:676
#, no-wrap
msgid "Regexp Backslash"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:307
msgid "Backslash-sequences in regular expressions."
msgstr ""

#. type: subsubsection
#: original_texis/searching.texi:310
#, no-wrap
msgid "Special Characters in Regular Expressions"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:311
#, no-wrap
msgid "regexp, special characters in"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:315
msgid "Here is a list of the characters that are special in a regular expression."
msgstr ""

#. type: item
#: original_texis/searching.texi:318
#, no-wrap
msgid "@samp{.}@: @r{(Period)}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:319
#, no-wrap
msgid "@samp{.} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:324
msgid ""
"is a special character that matches any single character except a newline.  "
"Using concatenation, we can make regular expressions like @samp{a.b}, which "
"matches any three-character string that begins with @samp{a} and ends with "
"@samp{b}."
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:325
#, no-wrap
msgid "*"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:326
#, no-wrap
msgid "@samp{*} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:331
msgid ""
"is not a construct by itself; it is a postfix operator that means to match "
"the preceding regular expression repetitively as many times as possible.  "
"Thus, @samp{o*} matches any number of @samp{o}s (including no @samp{o}s)."
msgstr ""

#. type: table
#: original_texis/searching.texi:335
msgid ""
"@samp{*} always applies to the @emph{smallest} possible preceding "
"expression.  Thus, @samp{fo*} has a repeating @samp{o}, not a repeating "
"@samp{fo}.  It matches @samp{f}, @samp{fo}, @samp{foo}, and so on."
msgstr ""

#. type: cindex
#: original_texis/searching.texi:336
#, no-wrap
msgid "backtracking and regular expressions"
msgstr ""

#. type: table
#: original_texis/searching.texi:347
msgid ""
"The matcher processes a @samp{*} construct by matching, immediately, as many "
"repetitions as can be found.  Then it continues with the rest of the "
"pattern.  If that fails, backtracking occurs, discarding some of the matches "
"of the @samp{*}-modified construct in the hope that this will make it "
"possible to match the rest of the pattern.  For example, in matching "
"@samp{ca*ar} against the string @samp{caaar}, the @samp{a*} first tries to "
"match all three @samp{a}s; but the rest of the pattern is @samp{ar} and "
"there is only @samp{r} left to match, so this try fails.  The next "
"alternative is for @samp{a*} to match only two @samp{a}s.  With this choice, "
"the rest of the regexp matches successfully."
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:348
#, no-wrap
msgid "+"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:349
#, no-wrap
msgid "@samp{+} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:354
msgid ""
"is a postfix operator, similar to @samp{*} except that it must match the "
"preceding expression at least once.  So, for example, @samp{ca+r} matches "
"the strings @samp{car} and @samp{caaaar} but not the string @samp{cr}, "
"whereas @samp{ca*r} matches all three strings."
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:355
#, no-wrap
msgid "?"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:356
#, no-wrap
msgid "@samp{?} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:360
msgid ""
"is a postfix operator, similar to @samp{*} except that it must match the "
"preceding expression either once or not at all.  For example, @samp{ca?r} "
"matches @samp{car} or @samp{cr}; nothing else."
msgstr ""

#. type: anchor{#1}
#: original_texis/searching.texi:362
msgid "Non-greedy repetition"
msgstr ""

#. type: item
#: original_texis/searching.texi:362
#, no-wrap
msgid "@samp{*?}, @samp{+?}, @samp{??}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:363
#, no-wrap
msgid "non-greedy repetition characters in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:369
msgid ""
"are @dfn{non-greedy} variants of the operators @samp{*}, @samp{+} and "
"@samp{?}.  Where those operators match the largest possible substring "
"(consistent with matching the entire containing expression), the non-greedy "
"variants match the smallest possible substring (consistent with matching the "
"entire containing expression)."
msgstr ""

#. type: table
#: original_texis/searching.texi:375
msgid ""
"For example, the regular expression @samp{c[ad]*a} when applied to the "
"string @samp{cdaaada} matches the whole string; but the regular expression "
"@samp{c[ad]*?a}, applied to that same string, matches just @samp{cda}.  (The "
"smallest possible match here for @samp{[ad]*?} that permits the whole "
"expression to match is @samp{d}.)"
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:376
#, no-wrap
msgid "[ @dots{} ]"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:377
#, no-wrap
msgid "bracket expression (in regexp)"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:378
#, no-wrap
msgid "character alternative (in regexp)"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:379
#, no-wrap
msgid "@samp{[} in regexp"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:380
#, no-wrap
msgid "@samp{]} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:385
msgid ""
"is a @dfn{bracket expression} (a.k.a.@: @dfn{character alternative}), which "
"begins with @samp{[} and is terminated by @samp{]}.  In the simplest case, "
"the characters between the two brackets are what this bracket expression can "
"match."
msgstr ""

#. type: table
#: original_texis/searching.texi:390
msgid ""
"Thus, @samp{[ad]} matches either one @samp{a} or one @samp{d}, and "
"@samp{[ad]*} matches any string composed of just @samp{a}s and @samp{d}s "
"(including the empty string).  It follows that @samp{c[ad]*r} matches "
"@samp{cr}, @samp{car}, @samp{cdr}, @samp{caddaar}, etc."
msgstr ""

#. type: table
#: original_texis/searching.texi:399
msgid ""
"You can also include character ranges in a bracket expression, by writing "
"the starting and ending characters with a @samp{-} between them.  Thus, "
"@samp{[a-z]} matches any lower-case @acronym{ASCII} letter.  Ranges may be "
"intermixed freely with individual characters, as in @samp{[a-z$%.]}, which "
"matches any lower case @acronym{ASCII} letter or @samp{$}, @samp{%} or "
"period.  However, the ending character of one range should not be the "
"starting point of another one; for example, @samp{[a-m-z]} should be "
"avoided."
msgstr ""

#. type: table
#: original_texis/searching.texi:407
msgid ""
"A bracket expression can also specify named character classes (@pxref{Char "
"Classes}).  For example, @samp{[[:ascii:]]} matches any @acronym{ASCII} "
"character.  Using a character class is equivalent to mentioning each of the "
"characters in that class; but the latter is not feasible in practice, since "
"some classes include thousands of different characters.  A character class "
"should not appear as the lower or upper bound of a range."
msgstr ""

#. type: table
#: original_texis/searching.texi:416
msgid ""
"The usual regexp special characters are not special inside a bracket "
"expression.  A completely different set of characters is special: @samp{]}, "
"@samp{-} and @samp{^}.  To include @samp{]} in a bracket expression, put it "
"at the beginning.  To include @samp{^}, put it anywhere but at the "
"beginning.  To include @samp{-}, put it at the end.  Thus, @samp{[]^-]} "
"matches all three of these special characters.  You cannot use @samp{\\} to "
"escape these three characters, since @samp{\\} is not special here."
msgstr ""

#. type: table
#: original_texis/searching.texi:420
msgid ""
"The following aspects of ranges are specific to Emacs, in that POSIX allows "
"but does not require this behavior and programs other than Emacs may behave "
"differently:"
msgstr ""

#. type: enumerate
#: original_texis/searching.texi:425
msgid ""
"If @code{case-fold-search} is non-@code{nil}, @samp{[a-z]} also matches "
"upper-case letters."
msgstr ""

#. type: enumerate
#: original_texis/searching.texi:431
msgid ""
"A range is not affected by the locale's collation sequence: it always "
"represents the set of characters with codepoints ranging between those of "
"its bounds, so that @samp{[a-z]} matches only ASCII letters, even outside "
"the C or POSIX locale."
msgstr ""

#. type: enumerate
#: original_texis/searching.texi:440
msgid ""
"If the lower bound of a range is greater than its upper bound, the range is "
"empty and represents no characters.  Thus, @samp{[z-a]} always fails to "
"match, and @samp{[^z-a]} matches any character, including newline.  However, "
"a reversed range should always be from the letter @samp{z} to the letter "
"@samp{a} to make it clear that it is not a typo; for example, @samp{[+-*/]} "
"should be avoided, because it matches only @samp{/} rather than the "
"likely-intended four characters."
msgstr ""

#. type: enumerate
#: original_texis/searching.texi:447
msgid ""
"If the end points of a range are raw 8-bit bytes (@pxref{Text "
"Representations}), or if the range start is ASCII and the end is a raw byte "
"(as in @samp{[a-\\377]}), the range will match only ASCII characters and raw "
"8-bit bytes, but not non-ASCII characters.  This feature is intended for "
"searching text in unibyte buffers and strings."
msgstr ""

#. type: table
#: original_texis/searching.texi:451
msgid ""
"Some kinds of bracket expressions are not the best style even though they "
"have a well-defined meaning in Emacs.  They include:"
msgstr ""

#. type: enumerate
#: original_texis/searching.texi:461
msgid ""
"Although a range's bound can be almost any character, it is better style to "
"stay within natural sequences of ASCII letters and digits because most "
"people have not memorized character code tables.  For example, @samp{[.-9]} "
"is less clear than @samp{[./0-9]}, and @samp{[`-~]} is less clear than "
"@samp{[`a-z@{|@}~]}.  Unicode character escapes can help here; for example, "
"for most programmers @samp{[ก-ฺ฿-๛]} is less clear than "
"@samp{[\\u0E01-\\u0E3A\\u0E3F-\\u0E5B]}."
msgstr ""

#. type: enumerate
#: original_texis/searching.texi:466
msgid ""
"Although a bracket expression can include duplicates, it is better style to "
"avoid them.  For example, @samp{[XYa-yYb-zX]} is less clear than "
"@samp{[XYa-z]}."
msgstr ""

#. type: enumerate
#: original_texis/searching.texi:472
msgid ""
"Although a range can denote just one, two, or three characters, it is "
"simpler to list the characters.  For example, @samp{[a-a0]} is less clear "
"than @samp{[a0]}, @samp{[i-j]} is less clear than @samp{[ij]}, and "
"@samp{[i-k]} is less clear than @samp{[ijk]}."
msgstr ""

#. type: enumerate
#: original_texis/searching.texi:479
msgid ""
"Although a @samp{-} can appear at the beginning of a bracket expression or "
"as the upper bound of a range, it is better style to put @samp{-} by itself "
"at the end of a bracket expression.  For example, although @samp{[-a-z]} is "
"valid, @samp{[a-z-]} is better style; and although @samp{[*--]} is valid, "
"@samp{[*+,-]} is clearer."
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:481
#, no-wrap
msgid "[^ @dots{} ]"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:482
#, no-wrap
msgid "@samp{^} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:487
msgid ""
"@samp{[^} begins a @dfn{complemented bracket expression}, or "
"@dfn{complemented character alternative}.  This matches any character except "
"the ones specified.  Thus, @samp{[^a-z0-9A-Z]} matches all characters "
"@emph{except} ASCII letters and digits."
msgstr ""

#. type: table
#: original_texis/searching.texi:491
msgid ""
"@samp{^} is not special in a bracket expression unless it is the first "
"character.  The character following the @samp{^} is treated as if it were "
"first (in other words, @samp{-} and @samp{]} are not special there)."
msgstr ""

#. type: table
#: original_texis/searching.texi:495
msgid ""
"A complemented bracket expression can match a newline, unless newline is "
"mentioned as one of the characters not to match.  This is in contrast to the "
"handling of regexps in programs such as @code{grep}."
msgstr ""

#. type: table
#: original_texis/searching.texi:499
msgid ""
"You can specify named character classes, just like in bracket expressions.  "
"For instance, @samp{[^[:ascii:]]} matches any non-@acronym{ASCII} "
"character.  @xref{Char Classes}."
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:500
#, no-wrap
msgid "^"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:501
#, no-wrap
msgid "beginning of line in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:507
msgid ""
"When matching a buffer, @samp{^} matches the empty string, but only at the "
"beginning of a line in the text being matched (or the beginning of the "
"accessible portion of the buffer).  Otherwise it fails to match anything.  "
"Thus, @samp{^foo} matches a @samp{foo} that occurs at the beginning of a "
"line."
msgstr ""

#. type: table
#: original_texis/searching.texi:510
msgid ""
"When matching a string instead of a buffer, @samp{^} matches at the "
"beginning of the string or after a newline character."
msgstr ""

#. type: table
#: original_texis/searching.texi:515
msgid ""
"For historical compatibility, @samp{^} is special only at the beginning of "
"the regular expression, or after @samp{\\(}, @samp{\\(?:} or @samp{\\|}.  "
"Although @samp{^} is an ordinary character in other contexts, it is good "
"practice to use @samp{\\^} even then."
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:516
#, no-wrap
msgid "$"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:517
#, no-wrap
msgid "@samp{$} in regexp"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:518
#, no-wrap
msgid "end of line in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:522
msgid ""
"is similar to @samp{^} but matches only at the end of a line (or the end of "
"the accessible portion of the buffer).  Thus, @samp{x+$} matches a string of "
"one @samp{x} or more at the end of a line."
msgstr ""

#. type: table
#: original_texis/searching.texi:525
msgid ""
"When matching a string instead of a buffer, @samp{$} matches at the end of "
"the string or before a newline character."
msgstr ""

#. type: table
#: original_texis/searching.texi:530
msgid ""
"For historical compatibility, @samp{$} is special only at the end of the "
"regular expression, or before @samp{\\)} or @samp{\\|}.  Although @samp{$} "
"is an ordinary character in other contexts, it is good practice to use "
"@samp{\\$} even then."
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:531
#, no-wrap
msgid "\\"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:532
#, no-wrap
msgid "@samp{\\} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:535
msgid ""
"has two functions: it quotes the special characters (including @samp{\\}), "
"and it introduces additional special constructs."
msgstr ""

#. type: table
#: original_texis/searching.texi:539
msgid ""
"Because @samp{\\} quotes special characters, @samp{\\$} is a regular "
"expression that matches only @samp{$}, and @samp{\\[} is a regular "
"expression that matches only @samp{[}, and so on."
msgstr ""

#. type: table
#: original_texis/searching.texi:547
msgid ""
"Note that @samp{\\} also has special meaning in the read syntax of Lisp "
"strings (@pxref{String Type}), and must be quoted with @samp{\\}.  For "
"example, the regular expression that matches the @samp{\\} character is "
"@samp{\\\\}.  To write a Lisp string that contains the characters "
"@samp{\\\\}, Lisp syntax requires you to quote each @samp{\\} with another "
"@samp{\\}.  Therefore, the read syntax for a regular expression matching "
"@samp{\\} is @code{\"\\\\\\\\\"}."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:556
msgid ""
"For historical compatibility, a repetition operator is treated as ordinary "
"if it appears at the start of a regular expression or after @samp{^}, "
"@samp{\\`}, @samp{\\(}, @samp{\\(?:} or @samp{\\|}.  For example, "
"@samp{*foo} is treated as @samp{\\*foo}, and @samp{two\\|^\\@{2\\@}} is "
"treated as @samp{two\\|^@{2@}}.  It is poor practice to depend on this "
"behavior; use proper backslash escaping anyway, regardless of where the "
"repetition operator appears."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:564
msgid ""
"As a @samp{\\} is not special inside a bracket expression, it can never "
"remove the special meaning of @samp{-}, @samp{^} or @samp{]}.  You should "
"not quote these characters when they have no special meaning.  This would "
"not clarify anything, since backslashes can legitimately precede these "
"characters where they @emph{have} special meaning, as in @samp{[^\\]} "
"(@code{\"[^\\\\]\"} for Lisp string syntax), which matches any single "
"character except a backslash."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:574
msgid ""
"In practice, most @samp{]} that occur in regular expressions close a bracket "
"expression and hence are special.  However, occasionally a regular "
"expression may try to match a complex pattern of literal @samp{[} and "
"@samp{]}.  In such situations, it sometimes may be necessary to carefully "
"parse the regexp from the start to determine which square brackets enclose a "
"bracket expression.  For example, @samp{[^][]]} consists of the complemented "
"bracket expression @samp{[^][]} (which matches any single character that is "
"not a square bracket), followed by a literal @samp{]}."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:584
msgid ""
"The exact rules are that at the beginning of a regexp, @samp{[} is special "
"and @samp{]} not.  This lasts until the first unquoted @samp{[}, after which "
"we are in a bracket expression; @samp{[} is no longer special (except when "
"it starts a character class) but @samp{]} is special, unless it immediately "
"follows the special @samp{[} or that @samp{[} followed by a @samp{^}.  This "
"lasts until the next special @samp{]} that does not end a character class.  "
"This ends the bracket expression and restores the ordinary syntax of regular "
"expressions; an unquoted @samp{[} is special again and a @samp{]} not."
msgstr ""

#. type: subsubsection
#: original_texis/searching.texi:586
#, no-wrap
msgid "Character Classes"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:587
#, no-wrap
msgid "character classes in regexp"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:588
#, no-wrap
msgid "ascii character class, regexp"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:589
#, no-wrap
msgid "alnum character class, regexp"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:590
#, no-wrap
msgid "alpha character class, regexp"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:591
#, no-wrap
msgid "xdigit character class, regexp"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:600
msgid ""
"Below is a table of the classes you can use in a bracket expression "
"(@pxref{Regexp Special, bracket expression}), and what they mean.  Note that "
"the @samp{[} and @samp{]} characters that enclose the class name are part of "
"the name, so a regular expression using these classes needs one more pair of "
"brackets.  For example, a regular expression matching a sequence of one or "
"more letters and digits would be @samp{[[:alnum:]]+}, not @samp{[:alnum:]+}."
msgstr ""

#. type: item
#: original_texis/searching.texi:602
#, no-wrap
msgid "[:ascii:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:604
msgid "This matches any @acronym{ASCII} character (codes 0--127)."
msgstr ""

#. type: item
#: original_texis/searching.texi:604
#, no-wrap
msgid "[:alnum:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:609
msgid ""
"This matches any letter or digit.  For multibyte characters, it matches "
"characters whose Unicode @samp{general-category} property (@pxref{Character "
"Properties}) indicates they are alphabetic or decimal number characters."
msgstr ""

#. type: item
#: original_texis/searching.texi:609
#, no-wrap
msgid "[:alpha:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:614
msgid ""
"This matches any letter.  For multibyte characters, it matches characters "
"whose Unicode @samp{general-category} property (@pxref{Character "
"Properties}) indicates they are alphabetic characters."
msgstr ""

#. type: item
#: original_texis/searching.texi:614
#, no-wrap
msgid "[:blank:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:620
msgid ""
"This matches horizontal whitespace, as defined by Annex C of the Unicode "
"Technical Standard #18.  In particular, it matches spaces, tabs, and other "
"characters whose Unicode @samp{general-category} property (@pxref{Character "
"Properties}) indicates they are spacing separators."
msgstr ""

#. type: item
#: original_texis/searching.texi:620
#, no-wrap
msgid "[:cntrl:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:622
msgid "This matches any character whose code is in the range 0--31."
msgstr ""

#. type: item
#: original_texis/searching.texi:622
#, no-wrap
msgid "[:digit:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:625
msgid ""
"This matches @samp{0} through @samp{9}.  Thus, @samp{[-+[:digit:]]} matches "
"any digit, as well as @samp{+} and @samp{-}."
msgstr ""

#. type: item
#: original_texis/searching.texi:625
#, no-wrap
msgid "[:graph:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:631
msgid ""
"This matches graphic characters---everything except spaces, @acronym{ASCII} "
"and non-@acronym{ASCII} control characters, surrogates, and codepoints "
"unassigned by Unicode, as indicated by the Unicode @samp{general-category} "
"property (@pxref{Character Properties})."
msgstr ""

#. type: item
#: original_texis/searching.texi:631
#, no-wrap
msgid "[:lower:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:637
msgid ""
"This matches any lower-case letter, as determined by the current case table "
"(@pxref{Case Tables}).  If @code{case-fold-search} is non-@code{nil}, this "
"also matches any upper-case letter.  Note that a buffer can have its own "
"local case table different from the default one."
msgstr ""

#. type: item
#: original_texis/searching.texi:637
#, no-wrap
msgid "[:multibyte:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:639
msgid "This matches any multibyte character (@pxref{Text Representations})."
msgstr ""

#. type: item
#: original_texis/searching.texi:639
#, no-wrap
msgid "[:nonascii:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:641
msgid "This matches any non-@acronym{ASCII} character."
msgstr ""

#. type: item
#: original_texis/searching.texi:641
#, no-wrap
msgid "[:print:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:644
msgid ""
"This matches any printing character---either spaces or graphic characters "
"matched by @samp{[:graph:]}."
msgstr ""

#. type: item
#: original_texis/searching.texi:644
#, no-wrap
msgid "[:punct:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:649
msgid ""
"This matches any punctuation character.  (At present, for multibyte "
"characters, it matches anything that has non-word syntax, and thus its exact "
"definition can vary from one major mode to another, since the syntax of a "
"character depends on the major mode.)"
msgstr ""

#. type: item
#: original_texis/searching.texi:649
#, no-wrap
msgid "[:space:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:654
msgid ""
"This matches any character that has whitespace syntax (@pxref{Syntax Class "
"Table}).  Note that the syntax of a character, and thus which characters are "
"considered ``whitespace'', depends on the major mode."
msgstr ""

#. type: item
#: original_texis/searching.texi:654
#, no-wrap
msgid "[:unibyte:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:656
msgid "This matches any unibyte character (@pxref{Text Representations})."
msgstr ""

#. type: item
#: original_texis/searching.texi:656
#, no-wrap
msgid "[:upper:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:662
msgid ""
"This matches any upper-case letter, as determined by the current case table "
"(@pxref{Case Tables}).  If @code{case-fold-search} is non-@code{nil}, this "
"also matches any lower-case letter.  Note that a buffer can have its own "
"local case table different from the default one."
msgstr ""

#. type: item
#: original_texis/searching.texi:662
#, no-wrap
msgid "[:word:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:667
msgid ""
"This matches any character that has word syntax (@pxref{Syntax Class "
"Table}).  Note that the syntax of a character, and thus which characters are "
"considered ``word-constituent'', depends on the major mode."
msgstr ""

#. type: item
#: original_texis/searching.texi:667
#, no-wrap
msgid "[:xdigit:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:670
msgid ""
"This matches the hexadecimal digits: @samp{0} through @samp{9}, @samp{a} "
"through @samp{f} and @samp{A} through @samp{F}."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:675
msgid ""
"The classes @samp{[:space:]}, @samp{[:word:]} and @samp{[:punct:]} use the "
"syntax-table of the current buffer but not any overriding syntax text "
"properties (@pxref{Syntax Properties})."
msgstr ""

#. type: subsubsection
#: original_texis/searching.texi:677
#, no-wrap
msgid "Backslash Constructs in Regular Expressions"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:678
#, no-wrap
msgid "backslash in regular expressions"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:684
msgid ""
"For the most part, @samp{\\} followed by any character matches only that "
"character.  However, there are several exceptions: certain sequences "
"starting with @samp{\\} that have special meanings.  Here is a table of the "
"special @samp{\\} constructs."
msgstr ""

#. type: item
#: original_texis/searching.texi:686
#, no-wrap
msgid "\\|"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:687
#, no-wrap
msgid "@samp{|} in regexp"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:688
#, no-wrap
msgid "regexp alternative"
msgstr ""

#. type: table
#: original_texis/searching.texi:693
msgid ""
"specifies an alternative.  Two regular expressions @var{a} and @var{b} with "
"@samp{\\|} in between form an expression that matches anything that either "
"@var{a} or @var{b} matches."
msgstr ""

#. type: table
#: original_texis/searching.texi:696
msgid ""
"Thus, @samp{foo\\|bar} matches either @samp{foo} or @samp{bar} but no other "
"string."
msgstr ""

#. type: table
#: original_texis/searching.texi:700
msgid ""
"@samp{\\|} applies to the largest possible surrounding expressions.  Only a "
"surrounding @samp{\\( @dots{} \\)} grouping can limit the grouping power of "
"@samp{\\|}."
msgstr ""

#. type: table
#: original_texis/searching.texi:704
msgid ""
"If you need full backtracking capability to handle multiple uses of "
"@samp{\\|}, use the POSIX regular expression functions (@pxref{POSIX "
"Regexps})."
msgstr ""

#. type: item
#: original_texis/searching.texi:705
#, no-wrap
msgid "\\@{@var{m}\\@}"
msgstr ""

#. type: table
#: original_texis/searching.texi:710
msgid ""
"is a postfix operator that repeats the previous pattern exactly @var{m} "
"times.  Thus, @samp{x\\@{5\\@}} matches the string @samp{xxxxx} and nothing "
"else.  @samp{c[ad]\\@{3\\@}r} matches string such as @samp{caaar}, "
"@samp{cdddr}, @samp{cadar}, and so on."
msgstr ""

#. type: item
#: original_texis/searching.texi:711
#, no-wrap
msgid "\\@{@var{m},@var{n}\\@}"
msgstr ""

#. type: table
#: original_texis/searching.texi:717
msgid ""
"is a more general postfix operator that specifies repetition with a minimum "
"of @var{m} repeats and a maximum of @var{n} repeats.  If @var{m} is omitted, "
"the minimum is 0; if @var{n} is omitted, there is no maximum.  For both "
"forms, @var{m} and @var{n}, if specified, may be no larger than"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:719
msgid "2**16 @minus{} 1"
msgstr ""

#. type: tex
#: original_texis/searching.texi:722
#, no-wrap
msgid "@math{2^{16}-1}\n"
msgstr ""

#. type: table
#: original_texis/searching.texi:724
msgid "."
msgstr ""

#. type: table
#: original_texis/searching.texi:731
msgid ""
"For example, @samp{c[ad]\\@{1,2\\@}r} matches the strings @samp{car}, "
"@samp{cdr}, @samp{caar}, @samp{cadr}, @samp{cdar}, and @samp{cddr}, and "
"nothing else.@* @samp{\\@{0,1\\@}} or @samp{\\@{,1\\@}} is equivalent to "
"@samp{?}.@* @samp{\\@{0,\\@}} or @samp{\\@{,\\@}} is equivalent to "
"@samp{*}.@* @samp{\\@{1,\\@}} is equivalent to @samp{+}."
msgstr ""

#. type: item
#: original_texis/searching.texi:732
#, no-wrap
msgid "\\( @dots{} \\)"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:733
#, no-wrap
msgid "@samp{(} in regexp"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:734
#, no-wrap
msgid "@samp{)} in regexp"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:735
#, no-wrap
msgid "regexp grouping"
msgstr ""

#. type: table
#: original_texis/searching.texi:737
msgid "is a grouping construct that serves three purposes:"
msgstr ""

#. type: enumerate
#: original_texis/searching.texi:743
msgid ""
"To enclose a set of @samp{\\|} alternatives for other operations.  Thus, the "
"regular expression @samp{\\(foo\\|bar\\)x} matches either @samp{foox} or "
"@samp{barx}."
msgstr ""

#. type: enumerate
#: original_texis/searching.texi:749
msgid ""
"To enclose a complicated expression for the postfix operators @samp{*}, "
"@samp{+} and @samp{?} to operate on.  Thus, @samp{ba\\(na\\)*} matches "
"@samp{ba}, @samp{bana}, @samp{banana}, @samp{bananana}, etc., with any "
"number (zero or more) of @samp{na} strings."
msgstr ""

#. type: enumerate
#: original_texis/searching.texi:753
msgid ""
"To record a matched substring for future reference with @samp{\\@var{digit}} "
"(see below)."
msgstr ""

#. type: table
#: original_texis/searching.texi:761
msgid ""
"This last application is not a consequence of the idea of a parenthetical "
"grouping; it is a separate feature that was assigned as a second meaning to "
"the same @samp{\\( @dots{} \\)} construct because, in practice, there was "
"usually no conflict between the two meanings.  But occasionally there is a "
"conflict, and that led to the introduction of shy groups."
msgstr ""

#. type: item
#: original_texis/searching.texi:762
#, no-wrap
msgid "\\(?: @dots{} \\)"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:763
#, no-wrap
msgid "shy groups"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:764
#, no-wrap
msgid "non-capturing group"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:765
#, no-wrap
msgid "unnumbered group"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:766
#, no-wrap
msgid "@samp{(?:} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:774
msgid ""
"is the @dfn{shy group} construct.  A shy group serves the first two purposes "
"of an ordinary group (controlling the nesting of other operators), but it "
"does not get a number, so you cannot refer back to its value with "
"@samp{\\@var{digit}}.  Shy groups are particularly useful for "
"mechanically-constructed regular expressions, because they can be added "
"automatically without altering the numbering of ordinary, non-shy groups."
msgstr ""

#. type: table
#: original_texis/searching.texi:777
msgid "Shy groups are also called @dfn{non-capturing} or @dfn{unnumbered groups}."
msgstr ""

#. type: item
#: original_texis/searching.texi:778
#, no-wrap
msgid "\\(?@var{num}: @dots{} \\)"
msgstr ""

#. type: table
#: original_texis/searching.texi:787
msgid ""
"is the @dfn{explicitly numbered group} construct.  Normal groups get their "
"number implicitly, based on their position, which can be inconvenient.  This "
"construct allows you to force a particular group number.  There is no "
"particular restriction on the numbering, e.g., you can have several groups "
"with the same number in which case the last one to match (i.e., the "
"rightmost match) will win.  Implicitly numbered groups always get the "
"smallest integer larger than the one of any previous group."
msgstr ""

#. type: item
#: original_texis/searching.texi:788
#, no-wrap
msgid "\\@var{digit}"
msgstr ""

#. type: table
#: original_texis/searching.texi:791
msgid ""
"matches the same text that matched the @var{digit}th occurrence of a "
"grouping (@samp{\\( @dots{} \\)}) construct."
msgstr ""

#. type: table
#: original_texis/searching.texi:796
msgid ""
"In other words, after the end of a group, the matcher remembers the "
"beginning and end of the text matched by that group.  Later on in the "
"regular expression you can use @samp{\\} followed by @var{digit} to match "
"that same text, whatever it may have been."
msgstr ""

#. type: table
#: original_texis/searching.texi:803
msgid ""
"The strings matching the first nine grouping constructs appearing in the "
"entire regular expression passed to a search or matching function are "
"assigned numbers 1 through 9 in the order that the open parentheses appear "
"in the regular expression.  So you can use @samp{\\1} through @samp{\\9} to "
"refer to the text matched by the corresponding grouping constructs."
msgstr ""

#. type: table
#: original_texis/searching.texi:808
msgid ""
"For example, @samp{\\(.*\\)\\1} matches any newline-free string that is "
"composed of two identical halves.  The @samp{\\(.*\\)} matches the first "
"half, which may be anything, but the @samp{\\1} that follows must match the "
"same exact text."
msgstr ""

#. type: table
#: original_texis/searching.texi:812
msgid ""
"If a @samp{\\( @dots{} \\)} construct matches more than once (which can "
"happen, for instance, if it is followed by @samp{*}), only the last match is "
"recorded."
msgstr ""

#. type: table
#: original_texis/searching.texi:822
msgid ""
"If a particular grouping construct in the regular expression was never "
"matched---for instance, if it appears inside of an alternative that wasn't "
"used, or inside of a repetition that repeated zero times---then the "
"corresponding @samp{\\@var{digit}} construct never matches anything.  To use "
"an artificial example, @samp{\\(foo\\(b*\\)\\|lose\\)\\2} cannot match "
"@samp{lose}: the second alternative inside the larger group matches it, but "
"then @samp{\\2} is undefined and can't match anything.  But it can match "
"@samp{foobb}, because the first alternative matches @samp{foob} and "
"@samp{\\2} matches @samp{b}."
msgstr ""

#. type: item
#: original_texis/searching.texi:823
#, no-wrap
msgid "\\w"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:824
#, no-wrap
msgid "@samp{\\w} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:827
msgid ""
"matches any word-constituent character.  The editor syntax table determines "
"which characters these are.  @xref{Syntax Tables}."
msgstr ""

#. type: item
#: original_texis/searching.texi:828
#, no-wrap
msgid "\\W"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:829
#, no-wrap
msgid "@samp{\\W} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:831
msgid "matches any character that is not a word constituent."
msgstr ""

#. type: item
#: original_texis/searching.texi:832
#, no-wrap
msgid "\\s@var{code}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:833
#, no-wrap
msgid "@samp{\\s} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:840
msgid ""
"matches any character whose syntax is @var{code}.  Here @var{code} is a "
"character that represents a syntax code: thus, @samp{w} for word "
"constituent, @samp{-} for whitespace, @samp{(} for open parenthesis, etc.  "
"To represent whitespace syntax, use either @samp{-} or a space character.  "
"@xref{Syntax Class Table}, for a list of syntax codes and the characters "
"that stand for them."
msgstr ""

#. type: item
#: original_texis/searching.texi:841
#, no-wrap
msgid "\\S@var{code}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:842
#, no-wrap
msgid "@samp{\\S} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:844
msgid "matches any character whose syntax is not @var{code}."
msgstr ""

#. type: cindex
#: original_texis/searching.texi:845
#, no-wrap
msgid "category, regexp search for"
msgstr ""

#. type: item
#: original_texis/searching.texi:846
#, no-wrap
msgid "\\c@var{code}"
msgstr ""

#. type: table
#: original_texis/searching.texi:855
msgid ""
"matches any character whose category is @var{code}.  Here @var{code} is a "
"character that represents a category: for example, in the standard category "
"table, @samp{c} stands for Chinese characters and @samp{g} stands for Greek "
"characters.  You can see the list of all the currently defined categories "
"with @w{@kbd{M-x describe-categories @key{RET}}}.  You can also define your "
"own categories in addition to the standard ones using the "
"@code{define-category} function (@pxref{Categories})."
msgstr ""

#. type: item
#: original_texis/searching.texi:856
#, no-wrap
msgid "\\C@var{code}"
msgstr ""

#. type: table
#: original_texis/searching.texi:858
msgid "matches any character whose category is not @var{code}."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:865
msgid ""
"The following regular expression constructs match the empty string---that "
"is, they don't consume any characters---but whether they match depends on "
"the context.  For all, the beginning and end of the accessible portion of "
"the buffer are treated as if they were the actual beginning and end of the "
"buffer."
msgstr ""

#. type: item
#: original_texis/searching.texi:867
#, no-wrap
msgid "\\`"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:868
#, no-wrap
msgid "@samp{\\`} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:871
msgid ""
"matches the empty string, but only at the beginning of the buffer or string "
"being matched against."
msgstr ""

#. type: item
#: original_texis/searching.texi:872
#, no-wrap
msgid "\\'"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:873
#, no-wrap
msgid "@samp{\\'} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:876
msgid ""
"matches the empty string, but only at the end of the buffer or string being "
"matched against."
msgstr ""

#. type: item
#: original_texis/searching.texi:877
#, no-wrap
msgid "\\="
msgstr ""

#. type: cindex
#: original_texis/searching.texi:878
#, no-wrap
msgid "@samp{\\=} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:881
msgid ""
"matches the empty string, but only at point.  (This construct is not defined "
"when matching against a string.)"
msgstr ""

#. type: item
#: original_texis/searching.texi:882
#, no-wrap
msgid "\\b"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:883
#, no-wrap
msgid "@samp{\\b} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:888
msgid ""
"matches the empty string, but only at the beginning or end of a word.  Thus, "
"@samp{\\bfoo\\b} matches any occurrence of @samp{foo} as a separate word.  "
"@samp{\\bballs?\\b} matches @samp{ball} or @samp{balls} as a separate word."
msgstr ""

#. type: table
#: original_texis/searching.texi:891
msgid ""
"@samp{\\b} matches at the beginning or end of the buffer (or string)  "
"regardless of what text appears next to it."
msgstr ""

#. type: item
#: original_texis/searching.texi:892
#, no-wrap
msgid "\\B"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:893
#, no-wrap
msgid "@samp{\\B} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:896
msgid ""
"matches the empty string, but @emph{not} at the beginning or end of a word, "
"nor at the beginning or end of the buffer (or string)."
msgstr ""

#. type: item
#: original_texis/searching.texi:897
#, no-wrap
msgid "\\<"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:898
#, no-wrap
msgid "@samp{\\<} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:902
msgid ""
"matches the empty string, but only at the beginning of a word.  @samp{\\<} "
"matches at the beginning of the buffer (or string) only if a "
"word-constituent character follows."
msgstr ""

#. type: item
#: original_texis/searching.texi:903
#, no-wrap
msgid "\\>"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:904
#, no-wrap
msgid "@samp{\\>} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:908
msgid ""
"matches the empty string, but only at the end of a word.  @samp{\\>} matches "
"at the end of the buffer (or string) only if the contents end with a "
"word-constituent character."
msgstr ""

#. type: item
#: original_texis/searching.texi:909
#, no-wrap
msgid "\\_<"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:910
#, no-wrap
msgid "@samp{\\_<} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:915
msgid ""
"matches the empty string, but only at the beginning of a symbol.  A symbol "
"is a sequence of one or more word or symbol constituent characters.  "
"@samp{\\_<} matches at the beginning of the buffer (or string) only if a "
"symbol-constituent character follows."
msgstr ""

#. type: item
#: original_texis/searching.texi:916
#, no-wrap
msgid "\\_>"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:917
#, no-wrap
msgid "@samp{\\_>} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:921
msgid ""
"matches the empty string, but only at the end of a symbol.  @samp{\\_>} "
"matches at the end of the buffer (or string) only if the contents end with a "
"symbol-constituent character."
msgstr ""

#. type: kindex
#: original_texis/searching.texi:923
#, no-wrap
msgid "invalid-regexp"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:929
msgid ""
"Not every string is a valid regular expression.  For example, a string that "
"ends inside a bracket expression without a terminating @samp{]} is invalid, "
"and so is a string that ends with a single @samp{\\}.  If an invalid regular "
"expression is passed to any of the search functions, an "
"@code{invalid-regexp} error is signaled."
msgstr ""

#. type: subsection
#: original_texis/searching.texi:931
#, no-wrap
msgid "Complex Regexp Example"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:938
msgid ""
"Here is a complicated regexp which was formerly used by Emacs to recognize "
"the end of a sentence together with any whitespace that follows.  (Nowadays "
"Emacs uses a similar but more complex default regexp constructed by the "
"function @code{sentence-end}.  @xref{Standard Regexps}.)"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:945
msgid ""
"Below, we show first the regexp as a string in Lisp syntax (to distinguish "
"spaces from tab characters), and then the result of evaluating it.  The "
"string constant begins and ends with a double-quote.  @samp{\\\"} stands for "
"a double-quote as part of the string, @samp{\\\\} for a backslash as part of "
"the string, @samp{\\t} for a tab and @samp{\\n} for a newline."
msgstr ""

#. type: group
#: original_texis/searching.texi:951
#, no-wrap
msgid ""
"\"[.?!][]\\\"')@}]*\\\\($\\\\| $\\\\|\\t\\\\|@ @ \\\\)[ \\t\\n]*\"\n"
"     @result{} \"[.?!][]\\\"')@}]*\\\\($\\\\| $\\\\|  \\\\|@ @ \\\\)[\n"
"]*\"\n"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:956
msgid "In the output, tab and newline appear as themselves."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:959
msgid ""
"This regular expression contains four parts in succession and can be "
"deciphered as follows:"
msgstr ""

#. type: item
#: original_texis/searching.texi:961
#, no-wrap
msgid "[.?!]"
msgstr ""

#. type: table
#: original_texis/searching.texi:968
msgid ""
"The first part of the pattern is a bracket expression that matches any one "
"of three characters: period, question mark, and exclamation mark.  The match "
"must begin with one of these three characters.  (This is one point where the "
"new default regexp used by Emacs differs from the old.  The new value also "
"allows some non-@acronym{ASCII} characters that end a sentence without any "
"following whitespace.)"
msgstr ""

#. type: item
#: original_texis/searching.texi:969
#, no-wrap
msgid "[]\\\"')@}]*"
msgstr ""

#. type: table
#: original_texis/searching.texi:976
msgid ""
"The second part of the pattern matches any closing braces and quotation "
"marks, zero or more of them, that may follow the period, question mark or "
"exclamation mark.  The @code{\\\"} is Lisp syntax for a double-quote in a "
"string.  The @samp{*} at the end indicates that the immediately preceding "
"regular expression (a bracket expression, in this case) may be repeated zero "
"or more times."
msgstr ""

#. type: item
#: original_texis/searching.texi:977
#, no-wrap
msgid "\\\\($\\\\|@ $\\\\|\\t\\\\|@ @ \\\\)"
msgstr ""

#. type: table
#: original_texis/searching.texi:984
msgid ""
"The third part of the pattern matches the whitespace that follows the end of "
"a sentence: the end of a line (optionally with a space), or a tab, or two "
"spaces.  The double backslashes mark the parentheses and vertical bars as "
"regular expression syntax; the parentheses delimit a group and the vertical "
"bars separate alternatives.  The dollar sign is used to match the end of a "
"line."
msgstr ""

#. type: item
#: original_texis/searching.texi:985
#, no-wrap
msgid "[ \\t\\n]*"
msgstr ""

#. type: table
#: original_texis/searching.texi:988
msgid ""
"Finally, the last part of the pattern matches any additional whitespace "
"beyond the minimum needed to end a sentence."
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:992
msgid "In the @code{rx} notation (@pxref{Rx Notation}), the regexp could be written"
msgstr ""

#. type: group
#: original_texis/searching.texi:1002
#, no-wrap
msgid ""
"(rx (any \".?!\")                    ; Punctuation ending sentence.\n"
"    (zero-or-more (any \"\\\"')]@}\"))  ; Closing quotes or brackets.\n"
"    (or line-end\n"
"        (seq \" \" line-end)\n"
"        \"\\t\"\n"
"        \"  \")                      ; Two spaces.\n"
"    (zero-or-more (any \"\\t\\n \")))  ; Optional extra whitespace.\n"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1007
msgid ""
"Since @code{rx} regexps are just S-expressions, they can be formatted and "
"commented as such."
msgstr ""

#. type: node
#: original_texis/searching.texi:1010
#, no-wrap
msgid "Rx Notation"
msgstr ""

#. type: subsection
#: original_texis/searching.texi:1011
#, no-wrap
msgid "The @code{rx} Structured Regexp Notation"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1012
#, no-wrap
msgid "rx"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1023
msgid ""
"As an alternative to the string-based syntax, Emacs provides the structured "
"@code{rx} notation based on Lisp S-expressions.  This notation is usually "
"easier to read, write and maintain than regexp strings, and can be indented "
"and commented freely.  It requires a conversion into string form since that "
"is what regexp functions expect, but that conversion typically takes place "
"during byte-compilation rather than when the Lisp code using the regexp is "
"run."
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1028
msgid ""
"Here is an @code{rx} regexp@footnote{It could be written much simpler with "
"non-greedy operators (how?), but that would make the example less "
"interesting.} that matches a block comment in the C programming language:"
msgstr ""

#. type: group
#: original_texis/searching.texi:1038
#, no-wrap
msgid ""
"(rx \"/*\"                          ; Initial /*\n"
"    (zero-or-more\n"
"     (or (not (any \"*\"))          ;  Either non-*,\n"
"         (seq \"*\"                 ;  or * followed by\n"
"              (not (any \"/\")))))  ;  non-/\n"
"    (one-or-more \"*\")             ; At least one star,\n"
"    \"/\")                          ; and the final /\n"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1043
msgid "or, using shorter synonyms and written more compactly,"
msgstr ""

#. type: group
#: original_texis/searching.texi:1050
#, no-wrap
msgid ""
"(rx \"/*\"\n"
"    (* (| (not \"*\")\n"
"          (: \"*\" (not \"/\"))))\n"
"    (+ \"*\") \"/\")\n"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1055
msgid "In conventional string syntax, it would be written"
msgstr ""

#. type: example
#: original_texis/searching.texi:1058
#, no-wrap
msgid "\"/\\\\*\\\\(?:[^*]\\\\|\\\\*[^/]\\\\)*\\\\*+/\"\n"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1064
msgid ""
"The @code{rx} notation is mainly useful in Lisp code; it cannot be used in "
"most interactive situations where a regexp is requested, such as when "
"running @code{query-replace-regexp} or in variable customization."
msgstr ""

#. type: node
#: original_texis/searching.texi:1069 original_texis/searching.texi:1071
#, no-wrap
msgid "Rx Constructs"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:1069
msgid "Constructs valid in rx forms."
msgstr ""

#. type: node
#: original_texis/searching.texi:1069 original_texis/searching.texi:1566
#, no-wrap
msgid "Rx Functions"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:1069
msgid "Functions and macros that use rx forms."
msgstr ""

#. type: node
#: original_texis/searching.texi:1069 original_texis/searching.texi:1607
#, no-wrap
msgid "Extending Rx"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:1069
msgid "How to define your own rx forms."
msgstr ""

#. type: subsubsection
#: original_texis/searching.texi:1072
#, no-wrap
msgid "Constructs in @code{rx} regexps"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1079
msgid ""
"The various forms in @code{rx} regexps are described below.  The shorthand "
"@var{rx} represents any @code{rx} form.  @var{rx}@dots{} means zero or more "
"@code{rx} forms and, unless stated otherwise, matches these forms in "
"sequence as if wrapped in a @code{(seq @dots{})} subform."
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1084
msgid ""
"These are all valid arguments to the @code{rx} macro.  All forms are defined "
"by their described semantics; the corresponding string regexps are provided "
"for ease of understanding only.  @var{A}, @var{B}, @dots{} denote (suitably "
"bracketed) string regexp subexpressions therein."
msgstr ""

#. type: subsubheading
#: original_texis/searching.texi:1085
#, no-wrap
msgid "Literals"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1088
#, no-wrap
msgid "\"some-string\""
msgstr ""

#. type: table
#: original_texis/searching.texi:1091
msgid ""
"Match the string @samp{some-string} literally.  There are no characters with "
"special meaning, unlike in string regexps."
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1092
#, no-wrap
msgid "?C"
msgstr ""

#. type: table
#: original_texis/searching.texi:1094
msgid "Match the character @samp{C} literally."
msgstr ""

#. type: subsubheading
#: original_texis/searching.texi:1096
#, no-wrap
msgid "Sequence and alternative"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1099
#, no-wrap
msgid "(seq @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1100
#, no-wrap
msgid "@code{seq} in rx"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1101
#, no-wrap
msgid "(sequence @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1102
#, no-wrap
msgid "@code{sequence} in rx"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1103
#, no-wrap
msgid "(: @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1104
#, no-wrap
msgid "@code{:} in rx"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1105
#, no-wrap
msgid "(and @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1106
#, no-wrap
msgid "@code{and} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1111
msgid ""
"Match the @var{rx}s in sequence.  Without arguments, the expression matches "
"the empty string.@* Corresponding string regexp: "
"@samp{@var{A}@var{B}@dots{}} (subexpressions in sequence)."
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1112
#, no-wrap
msgid "(or @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1113
#, no-wrap
msgid "@code{or} in rx"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1114
#, no-wrap
msgid "(| @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1115
#, no-wrap
msgid "@code{|} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1123
msgid ""
"Match exactly one of the @var{rx}s.  If all arguments are strings, "
"characters, or @code{or} forms so constrained, the longest possible match "
"will always be used.  Otherwise, either the longest match or the first (in "
"left-to-right order) will be used.  Without arguments, the expression will "
"not match anything at all.@* Corresponding string regexp: "
"@samp{@var{A}\\|@var{B}\\|@dots{}}."
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1124
#, no-wrap
msgid "unmatchable"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1125
#, no-wrap
msgid "@code{unmatchable} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1128
msgid "Refuse any match.  Equivalent to @code{(or)}.  @xref{regexp-unmatchable}."
msgstr ""

#. type: subsubheading
#: original_texis/searching.texi:1130
#, no-wrap
msgid "Repetition"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1135
msgid ""
"Normally, repetition forms are greedy, in that they attempt to match as many "
"times as possible.  Some forms are non-greedy; they try to match as few "
"times as possible (@pxref{Non-greedy repetition})."
msgstr ""

#. type: item
#: original_texis/searching.texi:1137
#, no-wrap
msgid "(zero-or-more @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1138
#, no-wrap
msgid "@code{zero-or-more} in rx"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:1139
#, no-wrap
msgid "(0+ @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1140
#, no-wrap
msgid "@code{0+} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1144
msgid ""
"Match the @var{rx}s zero or more times.  Greedy by default.@* Corresponding "
"string regexp: @samp{@var{A}*} (greedy), @samp{@var{A}*?} (non-greedy)"
msgstr ""

#. type: item
#: original_texis/searching.texi:1145
#, no-wrap
msgid "(one-or-more @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1146
#, no-wrap
msgid "@code{one-or-more} in rx"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:1147
#, no-wrap
msgid "(1+ @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1148
#, no-wrap
msgid "@code{1+} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1152
msgid ""
"Match the @var{rx}s one or more times.  Greedy by default.@* Corresponding "
"string regexp: @samp{@var{A}+} (greedy), @samp{@var{A}+?} (non-greedy)"
msgstr ""

#. type: item
#: original_texis/searching.texi:1153
#, no-wrap
msgid "(zero-or-one @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1154
#, no-wrap
msgid "@code{zero-or-one} in rx"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:1155
#, no-wrap
msgid "(optional @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1156
#, no-wrap
msgid "@code{optional} in rx"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:1157
#, no-wrap
msgid "(opt @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1158
#, no-wrap
msgid "@code{opt} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1162
msgid ""
"Match the @var{rx}s once or an empty string.  Greedy by default.@* "
"Corresponding string regexp: @samp{@var{A}?} (greedy), @samp{@var{A}??} "
"(non-greedy)."
msgstr ""

#. type: item
#: original_texis/searching.texi:1163
#, no-wrap
msgid "(* @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1164
#, no-wrap
msgid "@code{*} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1167
msgid ""
"Match the @var{rx}s zero or more times.  Greedy.@* Corresponding string "
"regexp: @samp{@var{A}*}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1168
#, no-wrap
msgid "(+ @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1169
#, no-wrap
msgid "@code{+} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1172
msgid ""
"Match the @var{rx}s one or more times.  Greedy.@* Corresponding string "
"regexp: @samp{@var{A}+}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1173
#, no-wrap
msgid "(? @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1174
#, no-wrap
msgid "@code{?} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1177
msgid ""
"Match the @var{rx}s once or an empty string.  Greedy.@* Corresponding string "
"regexp: @samp{@var{A}?}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1178
#, no-wrap
msgid "(*? @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1179
#, no-wrap
msgid "@code{*?} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1182
msgid ""
"Match the @var{rx}s zero or more times.  Non-greedy.@* Corresponding string "
"regexp: @samp{@var{A}*?}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1183
#, no-wrap
msgid "(+? @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1184
#, no-wrap
msgid "@code{+?} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1187
msgid ""
"Match the @var{rx}s one or more times.  Non-greedy.@* Corresponding string "
"regexp: @samp{@var{A}+?}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1188
#, no-wrap
msgid "(?? @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1189
#, no-wrap
msgid "@code{??} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1192
msgid ""
"Match the @var{rx}s or an empty string.  Non-greedy.@* Corresponding string "
"regexp: @samp{@var{A}??}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1193
#, no-wrap
msgid "(= @var{n} @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1194
#, no-wrap
msgid "@code{=} in rx"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:1195
#, no-wrap
msgid "(repeat @var{n} @var{rx})"
msgstr ""

#. type: table
#: original_texis/searching.texi:1198
msgid ""
"Match the @var{rx}s exactly @var{n} times.@* Corresponding string regexp: "
"@samp{@var{A}\\@{@var{n}\\@}}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1199
#, no-wrap
msgid "(>= @var{n} @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1200
#, no-wrap
msgid "@code{>=} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1203
msgid ""
"Match the @var{rx}s @var{n} or more times.  Greedy.@* Corresponding string "
"regexp: @samp{@var{A}\\@{@var{n},\\@}}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1204
#, no-wrap
msgid "(** @var{n} @var{m} @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1205
#, no-wrap
msgid "@code{**} in rx"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:1206
#, no-wrap
msgid "(repeat @var{n} @var{m} @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1207
#, no-wrap
msgid "@code{repeat} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1210
msgid ""
"Match the @var{rx}s at least @var{n} but no more than @var{m} times.  "
"Greedy.@* Corresponding string regexp: @samp{@var{A}\\@{@var{n},@var{m}\\@}}"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1215
msgid ""
"The greediness of some repetition forms can be controlled using the "
"following constructs.  However, it is usually better to use the explicit "
"non-greedy forms above when such matching is required."
msgstr ""

#. type: item
#: original_texis/searching.texi:1217
#, no-wrap
msgid "(minimal-match @var{rx})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1218
#, no-wrap
msgid "@code{minimal-match} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1222
msgid ""
"Match @var{rx}, with @code{zero-or-more}, @code{0+}, @code{one-or-more}, "
"@code{1+}, @code{zero-or-one}, @code{opt} and @code{optional} using "
"non-greedy matching."
msgstr ""

#. type: item
#: original_texis/searching.texi:1223
#, no-wrap
msgid "(maximal-match @var{rx})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1224
#, no-wrap
msgid "@code{maximal-match} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1228
msgid ""
"Match @var{rx}, with @code{zero-or-more}, @code{0+}, @code{one-or-more}, "
"@code{1+}, @code{zero-or-one}, @code{opt} and @code{optional} using greedy "
"matching.  This is the default."
msgstr ""

#. type: subsubheading
#: original_texis/searching.texi:1230
#, no-wrap
msgid "Matching single characters"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1233
#, no-wrap
msgid "(any @var{set}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1234
#, no-wrap
msgid "@code{any} in rx"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1235
#, no-wrap
msgid "(char @var{set}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1236
#, no-wrap
msgid "@code{char} in rx"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1237
#, no-wrap
msgid "(in @var{set}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1238
#, no-wrap
msgid "@code{in} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1239 original_texis/searching.texi:1282
#, no-wrap
msgid "character class in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1245
msgid ""
"Match a single character from one of the @var{set}s.  Each @var{set} is a "
"character, a string representing the set of its characters, a range or a "
"character class (see below).  A range is either a hyphen-separated string "
"like @code{\"A-Z\"}, or a cons of characters like @code{(?A . ?Z)}."
msgstr ""

#. type: table
#: original_texis/searching.texi:1250
msgid ""
"Note that hyphen (@code{-}) is special in strings in this construct, since "
"it acts as a range separator.  To include a hyphen, add it as a separate "
"character or single-character string.@* Corresponding string regexp: "
"@samp{[@dots{}]}"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1251
#, no-wrap
msgid "(not @var{charspec})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1252
#, no-wrap
msgid "@code{not} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1261
msgid ""
"Match a character not included in @var{charspec}.  @var{charspec} can be a "
"character, a single-character string, an @code{any}, @code{not}, @code{or}, "
"@code{intersection}, @code{syntax} or @code{category} form, or a character "
"class.  If @var{charspec} is an @code{or} form, its arguments have the same "
"restrictions as those of @code{intersection}; see below.@* Corresponding "
"string regexp: @samp{[^@dots{}]}, @samp{\\S@var{code}}, @samp{\\C@var{code}}"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1262
#, no-wrap
msgid "(intersection @var{charset}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1263
#, no-wrap
msgid "@code{intersection} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1268
msgid ""
"Match a character included in all of the @var{charset}s.  Each @var{charset} "
"can be a character, a single-character string, an @code{any} form without "
"character classes, or an @code{intersection}, @code{or} or @code{not} form "
"whose arguments are also @var{charset}s."
msgstr ""

#. type: item
#: original_texis/searching.texi:1269
#, no-wrap
msgid "@code{not-newline}, @code{nonl}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1270
#, no-wrap
msgid "@code{not-newline} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1271
#, no-wrap
msgid "@code{nonl} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1274
msgid ""
"Match any character except a newline.@* Corresponding string regexp: "
"@samp{.} (dot)"
msgstr ""

#. type: item
#: original_texis/searching.texi:1275
#, no-wrap
msgid "@code{anychar}, @code{anything}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1276
#, no-wrap
msgid "@code{anychar} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1277
#, no-wrap
msgid "@code{anything} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1280
msgid ""
"Match any character.@* Corresponding string regexp: @samp{.\\|\\n} (for "
"example)"
msgstr ""

#. type: item
#: original_texis/searching.texi:1281
#, no-wrap
msgid "character class"
msgstr ""

#. type: table
#: original_texis/searching.texi:1284
msgid "Match a character from a named character class:"
msgstr ""

#. type: item
#: original_texis/searching.texi:1286
#, no-wrap
msgid "@code{alpha}, @code{alphabetic}, @code{letter}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1290
msgid ""
"Match alphabetic characters.  More precisely, match characters whose Unicode "
"@samp{general-category} property indicates that they are alphabetic."
msgstr ""

#. type: item
#: original_texis/searching.texi:1291
#, no-wrap
msgid "@code{alnum}, @code{alphanumeric}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1295
msgid ""
"Match alphabetic characters and digits.  More precisely, match characters "
"whose Unicode @samp{general-category} property indicates that they are "
"alphabetic or decimal digits."
msgstr ""

#. type: item
#: original_texis/searching.texi:1296
#, no-wrap
msgid "@code{digit}, @code{numeric}, @code{num}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1298
msgid "Match the digits @samp{0}--@samp{9}."
msgstr ""

#. type: item
#: original_texis/searching.texi:1299
#, no-wrap
msgid "@code{xdigit}, @code{hex-digit}, @code{hex}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1302
msgid ""
"Match the hexadecimal digits @samp{0}--@samp{9}, @samp{A}--@samp{F} and "
"@samp{a}--@samp{f}."
msgstr ""

#. type: item
#: original_texis/searching.texi:1303
#, no-wrap
msgid "@code{cntrl}, @code{control}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1305
msgid "Match any character whose code is in the range 0--31."
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1306
#, no-wrap
msgid "blank"
msgstr ""

#. type: table
#: original_texis/searching.texi:1310
msgid ""
"Match horizontal whitespace.  More precisely, match characters whose Unicode "
"@samp{general-category} property indicates that they are spacing separators."
msgstr ""

#. type: item
#: original_texis/searching.texi:1311
#, no-wrap
msgid "@code{space}, @code{whitespace}, @code{white}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1314
msgid "Match any character that has whitespace syntax (@pxref{Syntax Class Table})."
msgstr ""

#. type: item
#: original_texis/searching.texi:1315
#, no-wrap
msgid "@code{lower}, @code{lower-case}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1319
msgid ""
"Match anything lower-case, as determined by the current case table.  If "
"@code{case-fold-search} is non-@code{nil}, this also matches any upper-case "
"letter."
msgstr ""

#. type: item
#: original_texis/searching.texi:1320
#, no-wrap
msgid "@code{upper}, @code{upper-case}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1324
msgid ""
"Match anything upper-case, as determined by the current case table.  If "
"@code{case-fold-search} is non-@code{nil}, this also matches any lower-case "
"letter."
msgstr ""

#. type: item
#: original_texis/searching.texi:1325
#, no-wrap
msgid "@code{graph}, @code{graphic}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1330
msgid ""
"Match any character except whitespace, @acronym{ASCII} and "
"non-@acronym{ASCII} control characters, surrogates, and codepoints "
"unassigned by Unicode, as indicated by the Unicode @samp{general-category} "
"property."
msgstr ""

#. type: item
#: original_texis/searching.texi:1331
#, no-wrap
msgid "@code{print}, @code{printing}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1333
msgid "Match whitespace or a character matched by @code{graph}."
msgstr ""

#. type: item
#: original_texis/searching.texi:1334
#, no-wrap
msgid "@code{punct}, @code{punctuation}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1337
msgid ""
"Match any punctuation character.  (At present, for multibyte characters, "
"anything that has non-word syntax.)"
msgstr ""

#. type: item
#: original_texis/searching.texi:1338
#, no-wrap
msgid "@code{word}, @code{wordchar}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1340
msgid "Match any character that has word syntax (@pxref{Syntax Class Table})."
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1341
#, no-wrap
msgid "ascii"
msgstr ""

#. type: table
#: original_texis/searching.texi:1343
msgid "Match any @acronym{ASCII} character (codes 0--127)."
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1344
#, no-wrap
msgid "nonascii"
msgstr ""

#. type: table
#: original_texis/searching.texi:1346
msgid "Match any non-@acronym{ASCII} character (but not raw bytes)."
msgstr ""

#. type: table
#: original_texis/searching.texi:1352
msgid ""
"The classes @code{space}, @code{word} and @code{punct} use the syntax-table "
"of the current buffer but not any overriding syntax text properties "
"(@pxref{Syntax Properties}).@* Corresponding string regexp: "
"@samp{[[:@var{class}:]]}"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1353
#, no-wrap
msgid "(syntax @var{syntax})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1354
#, no-wrap
msgid "@code{syntax} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1357
msgid ""
"Match a character with syntax @var{syntax}, being one of the following "
"names:"
msgstr ""

#. type: multitable
#: original_texis/searching.texi:1360
msgid "@headitem Syntax name"
msgstr ""

#. type: multitable
#: original_texis/searching.texi:1360
msgid "Syntax character"
msgstr ""

#. type: item
#: original_texis/searching.texi:1360
#, no-wrap
msgid "@code{whitespace}        @tab @code{-}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1361
#, no-wrap
msgid "@code{punctuation}       @tab @code{.}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1362
#, no-wrap
msgid "@code{word}              @tab @code{w}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1363
#, no-wrap
msgid "@code{symbol}            @tab @code{_}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1364
#, no-wrap
msgid "@code{open-parenthesis}  @tab @code{(}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1365
#, no-wrap
msgid "@code{close-parenthesis} @tab @code{)}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1366
#, no-wrap
msgid "@code{expression-prefix} @tab @code{'}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1367
#, no-wrap
msgid "@code{string-quote}      @tab @code{\"}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1368
#, no-wrap
msgid "@code{paired-delimiter}  @tab @code{$}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1369
#, no-wrap
msgid "@code{escape}            @tab @code{\\}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1370
#, no-wrap
msgid "@code{character-quote}   @tab @code{/}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1371
#, no-wrap
msgid "@code{comment-start}     @tab @code{<}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1372
#, no-wrap
msgid "@code{comment-end}       @tab @code{>}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1373
#, no-wrap
msgid "@code{string-delimiter}  @tab @code{|}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1374
#, no-wrap
msgid "@code{comment-delimiter} @tab @code{!}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1382
msgid ""
"For details, @pxref{Syntax Class Table}.  Please note that @code{(syntax "
"punctuation)} is @emph{not} equivalent to the character class "
"@code{punctuation}.@* Corresponding string regexp: @samp{\\s@var{char}} "
"where @var{char} is the syntax character."
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1383
#, no-wrap
msgid "(category @var{category})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1384
#, no-wrap
msgid "@code{category} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1387
msgid ""
"Match a character in category @var{category}, which is either one of the "
"names below or its category character."
msgstr ""

#. type: multitable
#: original_texis/searching.texi:1390
msgid "@headitem Category name"
msgstr ""

#. type: multitable
#: original_texis/searching.texi:1390
msgid "Category character"
msgstr ""

#. type: item
#: original_texis/searching.texi:1390
#, no-wrap
msgid "@code{space-for-indent}                 @tab space"
msgstr ""

#. type: item
#: original_texis/searching.texi:1391
#, no-wrap
msgid "@code{base}                             @tab @code{.}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1392
#, no-wrap
msgid "@code{consonant}                        @tab @code{0}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1393
#, no-wrap
msgid "@code{base-vowel}                       @tab @code{1}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1394
#, no-wrap
msgid "@code{upper-diacritical-mark}           @tab @code{2}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1395
#, no-wrap
msgid "@code{lower-diacritical-mark}           @tab @code{3}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1396
#, no-wrap
msgid "@code{tone-mark}                        @tab @code{4}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1397
#, no-wrap
msgid "@code{symbol}                           @tab @code{5}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1398
#, no-wrap
msgid "@code{digit}                            @tab @code{6}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1399
#, no-wrap
msgid "@code{vowel-modifying-diacritical-mark} @tab @code{7}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1400
#, no-wrap
msgid "@code{vowel-sign}                       @tab @code{8}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1401
#, no-wrap
msgid "@code{semivowel-lower}                  @tab @code{9}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1402
#, no-wrap
msgid "@code{not-at-end-of-line}               @tab @code{<}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1403
#, no-wrap
msgid "@code{not-at-beginning-of-line}         @tab @code{>}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1404
#, no-wrap
msgid "@code{alpha-numeric-two-byte}           @tab @code{A}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1405
#, no-wrap
msgid "@code{chinese-two-byte}                 @tab @code{C}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1406
#, no-wrap
msgid "@code{greek-two-byte}                   @tab @code{G}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1407
#, no-wrap
msgid "@code{japanese-hiragana-two-byte}       @tab @code{H}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1408
#, no-wrap
msgid "@code{indian-two-byte}                  @tab @code{I}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1409
#, no-wrap
msgid "@code{japanese-katakana-two-byte}       @tab @code{K}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1410
#, no-wrap
msgid "@code{strong-left-to-right}             @tab @code{L}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1411
#, no-wrap
msgid "@code{korean-hangul-two-byte}           @tab @code{N}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1412
#, no-wrap
msgid "@code{strong-right-to-left}             @tab @code{R}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1413
#, no-wrap
msgid "@code{cyrillic-two-byte}                @tab @code{Y}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1414
#, no-wrap
msgid "@code{combining-diacritic}              @tab @code{^}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1415
#, no-wrap
msgid "@code{ascii}                            @tab @code{a}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1416
#, no-wrap
msgid "@code{arabic}                           @tab @code{b}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1417
#, no-wrap
msgid "@code{chinese}                          @tab @code{c}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1418
#, no-wrap
msgid "@code{ethiopic}                         @tab @code{e}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1419
#, no-wrap
msgid "@code{greek}                            @tab @code{g}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1420
#, no-wrap
msgid "@code{korean}                           @tab @code{h}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1421
#, no-wrap
msgid "@code{indian}                           @tab @code{i}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1422
#, no-wrap
msgid "@code{japanese}                         @tab @code{j}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1423
#, no-wrap
msgid "@code{japanese-katakana}                @tab @code{k}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1424
#, no-wrap
msgid "@code{latin}                            @tab @code{l}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1425
#, no-wrap
msgid "@code{lao}                              @tab @code{o}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1426
#, no-wrap
msgid "@code{tibetan}                          @tab @code{q}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1427
#, no-wrap
msgid "@code{japanese-roman}                   @tab @code{r}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1428
#, no-wrap
msgid "@code{thai}                             @tab @code{t}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1429
#, no-wrap
msgid "@code{vietnamese}                       @tab @code{v}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1430
#, no-wrap
msgid "@code{hebrew}                           @tab @code{w}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1431
#, no-wrap
msgid "@code{cyrillic}                         @tab @code{y}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1432
#, no-wrap
msgid "@code{can-break}                        @tab @code{|}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1440
msgid ""
"For more information about currently defined categories, run the command "
"@kbd{M-x describe-categories @key{RET}}.  For how to define new categories, "
"@pxref{Categories}.@* Corresponding string regexp: @samp{\\c@var{char}} "
"where @var{char} is the category character."
msgstr ""

#. type: subsubheading
#: original_texis/searching.texi:1442
#, no-wrap
msgid "Zero-width assertions"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1445
msgid "These all match the empty string, but only in specific places."
msgstr ""

#. type: item
#: original_texis/searching.texi:1447
#, no-wrap
msgid "@code{line-start}, @code{bol}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1448
#, no-wrap
msgid "@code{line-start} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1449
#, no-wrap
msgid "@code{bol} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1452
msgid "Match at the beginning of a line.@* Corresponding string regexp: @samp{^}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1453
#, no-wrap
msgid "@code{line-end}, @code{eol}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1454
#, no-wrap
msgid "@code{line-end} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1455
#, no-wrap
msgid "@code{eol} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1458
msgid "Match at the end of a line.@* Corresponding string regexp: @samp{$}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1459
#, no-wrap
msgid "@code{string-start}, @code{bos}, @code{buffer-start}, @code{bot}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1460
#, no-wrap
msgid "@code{string-start} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1461
#, no-wrap
msgid "@code{bos} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1462
#, no-wrap
msgid "@code{buffer-start} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1463
#, no-wrap
msgid "@code{bot} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1466
msgid ""
"Match at the start of the string or buffer being matched against.@* "
"Corresponding string regexp: @samp{\\`}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1467
#, no-wrap
msgid "@code{string-end}, @code{eos}, @code{buffer-end}, @code{eot}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1468
#, no-wrap
msgid "@code{string-end} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1469
#, no-wrap
msgid "@code{eos} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1470
#, no-wrap
msgid "@code{buffer-end} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1471
#, no-wrap
msgid "@code{eot} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1474
msgid ""
"Match at the end of the string or buffer being matched against.@* "
"Corresponding string regexp: @samp{\\'}"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1475
#, no-wrap
msgid "point"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1476
#, no-wrap
msgid "@code{point} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1479
msgid "Match at point.@* Corresponding string regexp: @samp{\\=}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1480
#, no-wrap
msgid "@code{word-start}, @code{bow}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1481
#, no-wrap
msgid "@code{word-start} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1482
#, no-wrap
msgid "@code{bow} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1485
msgid "Match at the beginning of a word.@* Corresponding string regexp: @samp{\\<}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1486
#, no-wrap
msgid "@code{word-end}, @code{eow}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1487
#, no-wrap
msgid "@code{word-end} in rx"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1488
#, no-wrap
msgid "@code{eow} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1491
msgid "Match at the end of a word.@* Corresponding string regexp: @samp{\\>}"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1492
#, no-wrap
msgid "word-boundary"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1493
#, no-wrap
msgid "@code{word-boundary} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1496
msgid ""
"Match at the beginning or end of a word.@* Corresponding string regexp: "
"@samp{\\b}"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1497
#, no-wrap
msgid "not-word-boundary"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1498
#, no-wrap
msgid "@code{not-word-boundary} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1501
msgid ""
"Match anywhere but at the beginning or end of a word.@* Corresponding string "
"regexp: @samp{\\B}"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1502
#, no-wrap
msgid "symbol-start"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1503
#, no-wrap
msgid "@code{symbol-start} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1506
msgid ""
"Match at the beginning of a symbol.@* Corresponding string regexp: "
"@samp{\\_<}"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1507
#, no-wrap
msgid "symbol-end"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1508
#, no-wrap
msgid "@code{symbol-end} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1511
msgid "Match at the end of a symbol.@* Corresponding string regexp: @samp{\\_>}"
msgstr ""

#. type: subsubheading
#: original_texis/searching.texi:1513
#, no-wrap
msgid "Capture groups"
msgstr ""

#. type: item
#: original_texis/searching.texi:1516
#, no-wrap
msgid "(group @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1517
#, no-wrap
msgid "@code{group} in rx"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:1518
#, no-wrap
msgid "(submatch @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1519
#, no-wrap
msgid "@code{submatch} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1525
msgid ""
"Match the @var{rx}s, making the matched text and position accessible in the "
"match data.  The first group in a regexp is numbered 1; subsequent groups "
"will be numbered one above the previously highest-numbered group in the "
"pattern so far.@* Corresponding string regexp: @samp{\\(@dots{}\\)}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1526
#, no-wrap
msgid "(group-n @var{n} @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1527
#, no-wrap
msgid "@code{group-n} in rx"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:1528
#, no-wrap
msgid "(submatch-n @var{n} @var{rx}@dots{})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1529
#, no-wrap
msgid "@code{submatch-n} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1533
msgid ""
"Like @code{group}, but explicitly assign the group number @var{n}.  @var{n} "
"must be positive.@* Corresponding string regexp: "
"@samp{\\(?@var{n}:@dots{}\\)}"
msgstr ""

#. type: item
#: original_texis/searching.texi:1534
#, no-wrap
msgid "(backref @var{n})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1535
#, no-wrap
msgid "@code{backref} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1539
msgid ""
"Match the text previously matched by group number @var{n}.  @var{n} must be "
"in the range 1--9.@* Corresponding string regexp: @samp{\\@var{n}}"
msgstr ""

#. type: subsubheading
#: original_texis/searching.texi:1541
#, no-wrap
msgid "Dynamic inclusion"
msgstr ""

#. type: item
#: original_texis/searching.texi:1544
#, no-wrap
msgid "(literal @var{expr})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1545
#, no-wrap
msgid "@code{literal} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1549
msgid ""
"Match the literal string that is the result from evaluating the Lisp "
"expression @var{expr}.  The evaluation takes place at call time, in the "
"current lexical environment."
msgstr ""

#. type: item
#: original_texis/searching.texi:1550
#, no-wrap
msgid "(regexp @var{expr})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1551
#, no-wrap
msgid "@code{regexp} in rx"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:1552
#, no-wrap
msgid "(regex @var{expr})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1553
#, no-wrap
msgid "@code{regex} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1557
msgid ""
"Match the string regexp that is the result from evaluating the Lisp "
"expression @var{expr}.  The evaluation takes place at call time, in the "
"current lexical environment."
msgstr ""

#. type: item
#: original_texis/searching.texi:1558
#, no-wrap
msgid "(eval @var{expr})"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1559
#, no-wrap
msgid "@code{eval} in rx"
msgstr ""

#. type: table
#: original_texis/searching.texi:1564
msgid ""
"Match the rx form that is the result from evaluating the Lisp expression "
"@var{expr}.  The evaluation takes place at macro-expansion time for "
"@code{rx}, at call time for @code{rx-to-string}, in the current global "
"environment."
msgstr ""

#. type: subsubsection
#: original_texis/searching.texi:1567
#, no-wrap
msgid "Functions and macros using @code{rx} regexps"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1569
#, no-wrap
msgid "rx rx-form@dots{}"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1574
msgid ""
"Translate the @var{rx-form}s to a string regexp, as if they were the body of "
"a @code{(seq @dots{})} form.  The @code{rx} macro expands to a string "
"constant, or, if @code{literal} or @code{regexp} forms are used, a Lisp "
"expression that evaluates to a string.  Example:"
msgstr ""

#. type: group
#: original_texis/searching.texi:1579
#, no-wrap
msgid ""
"(rx (+ alpha) \"=\" (+ digit))\n"
"  @result{} \"[[:alpha:]]+=[[:digit:]]+\"\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1583
#, no-wrap
msgid "rx-to-string rx-expr &optional no-group"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1589
msgid ""
"Translate @var{rx-expr} to a string regexp which is returned.  If "
"@var{no-group} is absent or @code{nil}, bracket the result in a "
"non-capturing group, @samp{\\(?:@dots{}\\)}, if necessary to ensure that a "
"postfix operator appended to it will apply to the whole expression.  "
"Example:"
msgstr ""

#. type: group
#: original_texis/searching.texi:1594
#, no-wrap
msgid ""
"(rx-to-string '(seq (+ alpha) \"=\" (+ digit)) t)\n"
"  @result{} \"[[:alpha:]]+=[[:digit:]]+\"\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1599
msgid ""
"Arguments to @code{literal} and @code{regexp} forms in @var{rx-expr} must be "
"string literals."
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1603
msgid ""
"The @code{pcase} macro can use @code{rx} expressions as patterns directly; "
"@pxref{rx in pcase}."
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1606
msgid ""
"For mechanisms to add user-defined extensions to the @code{rx} notation, "
"@pxref{Extending Rx}."
msgstr ""

#. type: subsubsection
#: original_texis/searching.texi:1608
#, no-wrap
msgid "Defining new @code{rx} forms"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1615
msgid ""
"The @code{rx} notation can be extended by defining new symbols and "
"parameterized forms in terms of other @code{rx} expressions.  This is handy "
"for sharing parts between several regexps, and for making complex ones "
"easier to build and understand by putting them together from smaller pieces."
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1621
msgid ""
"For example, you could define @code{name} to mean @code{(one-or-more "
"letter)}, and @code{(quoted @var{x})} to mean @code{(seq ?' @var{x} ?')} for "
"any @var{x}.  These forms could then be used in @code{rx} expressions like "
"any other: @code{(rx (quoted name))} would match a nonempty sequence of "
"letters inside single quotes."
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1624
msgid ""
"The Lisp macros below provide different ways of binding names to "
"definitions.  Common to all of them are the following rules:"
msgstr ""

#. type: itemize
#: original_texis/searching.texi:1629
msgid ""
"Built-in @code{rx} forms, like @code{digit} and @code{group}, cannot be "
"redefined."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:1634
msgid ""
"The definitions live in a name space of their own, separate from that of "
"Lisp variables.  There is thus no need to attach a suffix like "
"@code{-regexp} to names; they cannot collide with anything else."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:1639
msgid ""
"Definitions cannot refer to themselves recursively, directly or indirectly.  "
"If you find yourself needing this, you want a parser, not a regular "
"expression."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:1646
msgid ""
"Definitions are only ever expanded in calls to @code{rx} or "
"@code{rx-to-string}, not merely by their presence in definition macros.  "
"This means that the order of definitions doesn't matter, even when they "
"refer to each other, and that syntax errors only show up when they are used, "
"not when they are defined."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:1653
msgid ""
"User-defined forms are allowed wherever arbitrary @code{rx} expressions are "
"expected; for example, in the body of a @code{zero-or-one} form, but not "
"inside @code{any} or @code{category} forms.  They are also allowed inside "
"@code{not} and @code{intersection} forms."
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1655
#, no-wrap
msgid "rx-define name [arglist] rx-form"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1659
msgid ""
"Define @var{name} globally in all subsequent calls to @code{rx} and "
"@code{rx-to-string}.  If @var{arglist} is absent, then @var{name} is defined "
"as a plain symbol to be replaced with @var{rx-form}.  Example:"
msgstr ""

#. type: group
#: original_texis/searching.texi:1665
#, no-wrap
msgid ""
"(rx-define haskell-comment (seq \"--\" (zero-or-more nonl)))\n"
"(rx haskell-comment)\n"
"     @result{} \"--.*\"\n"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1673
msgid ""
"If @var{arglist} is present, it must be a list of zero or more argument "
"names, and @var{name} is then defined as a parameterized form.  When used in "
"an @code{rx} expression as @code{(@var{name} @var{arg}@dots{})}, each "
"@var{arg} will replace the corresponding argument name inside @var{rx-form}."
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1678
msgid ""
"@var{arglist} may end in @code{&rest} and one final argument name, denoting "
"a rest parameter.  The rest parameter will expand to all extra actual "
"argument values not matched by any other parameter in @var{arglist}, spliced "
"into @var{rx-form} where it occurs.  Example:"
msgstr ""

#. type: group
#: original_texis/searching.texi:1684
#, no-wrap
msgid ""
"(rx-define moan (x y &rest r) (seq x (one-or-more y) r \"!\"))\n"
"(rx (moan \"MOO\" \"A\" \"MEE\" \"OW\"))\n"
"     @result{} \"MOOA+MEEOW!\"\n"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1690
msgid ""
"Since the definition is global, it is recommended to give @var{name} a "
"package prefix to avoid name clashes with definitions elsewhere, as is usual "
"when naming non-local variables and functions."
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1694
msgid ""
"Forms defined this way only perform simple template substitution.  For "
"arbitrary computations, use them together with the @code{rx} forms "
"@code{eval}, @code{regexp} or @code{literal}.  Example:"
msgstr ""

#. type: group
#: original_texis/searching.texi:1706
#, no-wrap
msgid ""
"(defun n-tuple-rx (n element)\n"
"  `(seq \"<\"\n"
"        (group-n 1 ,element)\n"
"        ,@@(mapcar (lambda (i) `(seq ?, (group-n ,i ,element)))\n"
"                  (number-sequence 2 n))\n"
"        \">\"))\n"
"(rx-define n-tuple (n element) (eval (n-tuple-rx n 'element)))\n"
"(rx (n-tuple 3 (+ (in \"0-9\"))))\n"
"  @result{} "
"\"<\\\\(?1:[0-9]+\\\\),\\\\(?2:[0-9]+\\\\),\\\\(?3:[0-9]+\\\\)>\"\n"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1710
#, no-wrap
msgid "rx-let (bindings@dots{}) body@dots{}"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1713
msgid ""
"Make the @code{rx} definitions in @var{bindings} available locally for "
"@code{rx} macro invocations in @var{body}, which is then evaluated."
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1717
msgid ""
"Each element of @var{bindings} is on the form @w{@code{(@var{name} "
"[@var{arglist}] @var{rx-form})}}, where the parts have the same meaning as "
"in @code{rx-define} above.  Example:"
msgstr ""

#. type: group
#: original_texis/searching.texi:1724
#, no-wrap
msgid ""
"(rx-let ((comma-separated (item) (seq item (0+ \",\" item)))\n"
"         (number (1+ digit))\n"
"         (numbers (comma-separated number)))\n"
"  (re-search-forward (rx \"(\" numbers \")\")))\n"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1730
msgid ""
"The definitions are only available during the macro-expansion of @var{body}, "
"and are thus not present during execution of compiled code."
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1736
msgid ""
"@code{rx-let} can be used not only inside a function, but also at top level "
"to include global variable and function definitions that need to share a "
"common set of @code{rx} forms.  Since the names are local inside @var{body}, "
"there is no need for any package prefixes.  Example:"
msgstr ""

#. type: group
#: original_texis/searching.texi:1744
#, no-wrap
msgid ""
"(rx-let ((phone-number (seq (opt ?+) (1+ (any digit ?-)))))\n"
"  (defun find-next-phone-number ()\n"
"    (re-search-forward (rx phone-number)))\n"
"  (defun phone-number-p (string)\n"
"    (string-match-p (rx bos phone-number eos) string)))\n"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1750
msgid ""
"The scope of the @code{rx-let} bindings is lexical, which means that they "
"are not visible outside @var{body} itself, even in functions called from "
"@var{body}."
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1752
#, no-wrap
msgid "rx-let-eval bindings body@dots{}"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1756
msgid ""
"Evaluate @var{bindings} to a list of bindings as in @code{rx-let}, and "
"evaluate @var{body} with those bindings in effect for calls to "
"@code{rx-to-string}."
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1761
msgid ""
"This macro is similar to @code{rx-let}, except that the @var{bindings} "
"argument is evaluated (and thus needs to be quoted if it is a list literal), "
"and the definitions are substituted at run time, which is required for "
"@code{rx-to-string} to work.  Example:"
msgstr ""

#. type: group
#: original_texis/searching.texi:1769
#, no-wrap
msgid ""
"(rx-let-eval\n"
"    '((ponder (x) (seq \"Where have all the \" x \" gone?\")))\n"
"  (looking-at (rx-to-string\n"
"               '(ponder (or \"flowers\" \"young girls\"\n"
"                            \"left socks\")))))\n"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1776
msgid ""
"Another difference from @code{rx-let} is that the @var{bindings} are "
"dynamically scoped, and thus also available in functions called from "
"@var{body}.  However, they are not visible inside functions defined in "
"@var{body}."
msgstr ""

#. type: subsection
#: original_texis/searching.texi:1781
#, no-wrap
msgid "Regular Expression Functions"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1784
msgid "These functions operate on regular expressions."
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1785
#, no-wrap
msgid "quote special characters in regexp"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1786
#, no-wrap
msgid "regexp-quote string"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1792
msgid ""
"This function returns a regular expression whose only exact match is "
"@var{string}.  Using this regular expression in @code{looking-at} will "
"succeed only if the next characters in the buffer are @var{string}; using it "
"in a search function will succeed if the text being searched contains "
"@var{string}.  @xref{Regexp Search}."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1795
msgid ""
"This allows you to request an exact string match or search when calling a "
"function that wants a regular expression."
msgstr ""

#. type: group
#: original_texis/searching.texi:1800
#, no-wrap
msgid ""
"(regexp-quote \"^The cat$\")\n"
"     @result{} \"\\\\^The cat\\\\$\"\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1807
msgid ""
"One use of @code{regexp-quote} is to combine an exact string match with "
"context described as a regular expression.  For example, this searches for "
"the string that is the value of @var{string}, surrounded by whitespace:"
msgstr ""

#. type: group
#: original_texis/searching.texi:1812
#, no-wrap
msgid ""
"(re-search-forward\n"
" (concat \"\\\\s-\" (regexp-quote string) \"\\\\s-\"))\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1817
msgid ""
"The returned string may be @var{string} itself if it does not contain any "
"special characters."
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1819
#, no-wrap
msgid "optimize regexp"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1820
#, no-wrap
msgid "regexp-opt strings &optional paren"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1829
msgid ""
"This function returns an efficient regular expression that will match any of "
"the strings in the list @var{strings}.  This is useful when you need to make "
"matching or searching as fast as possible---for example, for Font Lock "
"mode@footnote{Note that @code{regexp-opt} does not guarantee that its result "
"is absolutely the most efficient form possible.  A hand-tuned regular "
"expression can sometimes be slightly more efficient, but is almost never "
"worth the effort.}."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1832
msgid ""
"If @var{strings} is the empty list, the return value is a regexp that never "
"matches anything."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1834
msgid "The optional argument @var{paren} can be any of the following:"
msgstr ""

#. type: item
#: original_texis/searching.texi:1836
#, no-wrap
msgid "a string"
msgstr ""

#. type: table
#: original_texis/searching.texi:1840
msgid ""
"The resulting regexp is preceded by @var{paren} and followed by @samp{\\)}, "
"e.g. use @samp{\"\\\\(?1:\"} to produce an explicitly numbered group."
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1841
#, no-wrap
msgid "words"
msgstr ""

#. type: table
#: original_texis/searching.texi:1843
msgid "The resulting regexp is surrounded by @samp{\\<\\(} and @samp{\\)\\>}."
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1844
#, no-wrap
msgid "symbols"
msgstr ""

#. type: table
#: original_texis/searching.texi:1848
msgid ""
"The resulting regexp is surrounded by @samp{\\_<\\(} and @samp{\\)\\_>} "
"(this is often appropriate when matching programming-language keywords and "
"the like)."
msgstr ""

#. type: item
#: original_texis/searching.texi:1849
#, no-wrap
msgid "non-@code{nil}"
msgstr ""

#. type: table
#: original_texis/searching.texi:1851
msgid "The resulting regexp is surrounded by @samp{\\(} and @samp{\\)}."
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1852 original_texis/searching.texi:2020
#, no-wrap
msgid "nil"
msgstr ""

#. type: table
#: original_texis/searching.texi:1856
msgid ""
"The resulting regexp is surrounded by @samp{\\(?:} and @samp{\\)}, if it is "
"necessary to ensure that a postfix operator appended to it will apply to the "
"whole expression."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1860
msgid ""
"The returned regexp is ordered in such a way that it will always match the "
"longest string possible."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1864
msgid ""
"Up to reordering, the resulting regexp of @code{regexp-opt} is equivalent to "
"but usually more efficient than that of a simplified version:"
msgstr ""

#. type: example
#: original_texis/searching.texi:1877
#, no-wrap
msgid ""
"(defun simplified-regexp-opt (strings &optional paren)\n"
" (let ((parens\n"
"        (cond\n"
"         ((stringp paren)       (cons paren \"\\\\)\"))\n"
"         ((eq paren 'words)    '(\"\\\\<\\\\(\" . \"\\\\)\\\\>\"))\n"
"         ((eq paren 'symbols) '(\"\\\\_<\\\\(\" . \"\\\\)\\\\_>\"))\n"
"         ((null paren)          '(\"\\\\(?:\" . \"\\\\)\"))\n"
"         (t                       '(\"\\\\(\" . \"\\\\)\")))))\n"
"   (concat (car parens)\n"
"           (mapconcat 'regexp-quote strings \"\\\\|\")\n"
"           (cdr parens))))\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1880
#, no-wrap
msgid "regexp-opt-depth regexp"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1884
msgid ""
"This function returns the total number of grouping constructs (parenthesized "
"expressions) in @var{regexp}.  This does not include shy groups "
"(@pxref{Regexp Backslash})."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1887
#, no-wrap
msgid "regexp-opt-charset chars"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1890
msgid ""
"This function returns a regular expression matching a character in the list "
"of characters @var{chars}."
msgstr ""

#. type: example
#: original_texis/searching.texi:1894
#, no-wrap
msgid ""
"(regexp-opt-charset '(?a ?b ?c ?d ?e))\n"
"     @result{} \"[a-e]\"\n"
msgstr ""

#. type: defvar
#: original_texis/searching.texi:1900
#, no-wrap
msgid "regexp-unmatchable"
msgstr ""

#. type: defvar
#: original_texis/searching.texi:1905
msgid ""
"This variable contains a regexp that is guaranteed not to match any string "
"at all.  It is particularly useful as default value for variables that may "
"be set to a pattern that actually matches something."
msgstr ""

#. type: subsection
#: original_texis/searching.texi:1908
#, no-wrap
msgid "Problems with Regular Expressions"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1909
#, no-wrap
msgid "regular expression problems"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1910
#, no-wrap
msgid "regexp stack overflow"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1911
#, no-wrap
msgid "stack overflow in regexp"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1918
msgid ""
"The Emacs regexp implementation, like many of its kind, is generally robust "
"but occasionally causes trouble in either of two ways: matching may run out "
"of internal stack space and signal an error, and it can take a long time to "
"complete.  The advice below will make these symptoms less likely and help "
"alleviate problems that do arise."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:1926
msgid ""
"Anchor regexps at the beginning of a line, string or buffer using zero-width "
"assertions (@samp{^} and @code{\\`}).  This takes advantage of fast paths in "
"the implementation and can avoid futile matching attempts.  Other zero-width "
"assertions may also bring benefits by causing a match to fail early."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:1932
msgid ""
"Avoid or-patterns in favor of bracket expressions: write @samp{[ab]} instead "
"of @samp{a\\|b}.  Recall that @samp{\\s-} and @samp{\\sw} are equivalent to "
"@samp{[[:space:]]} and @samp{[[:word:]]}, respectively, most of the time."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:1939
msgid ""
"Since the last branch of an or-pattern does not add a backtrack point on the "
"stack, consider putting the most likely matched pattern last.  For example, "
"@samp{^\\(?:a\\|.b\\)*c} will run out of stack if trying to match a very "
"long string of @samp{a}s, but the equivalent @samp{^\\(?:.b\\|a\\)*c} will "
"not."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:1942
msgid ""
"(It is a trade-off: successfully matched or-patterns run faster with the "
"most frequently matched pattern first.)"
msgstr ""

#. type: itemize
#: original_texis/searching.texi:1950
msgid ""
"Try to ensure that any part of the text can only match in a single way.  For "
"example, @samp{a*a*} will match the same set of strings as @samp{a*}, but "
"the former can do so in many ways and will therefore cause slow backtracking "
"if the match fails later on.  Make or-pattern branches mutually exclusive if "
"possible, so that matching will not go far into more than one branch before "
"failing."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:1956
msgid ""
"Be especially careful with nested repetitions: they can easily result in "
"very slow matching in the presence of ambiguities.  For example, "
"@samp{\\(?:a*b*\\)+c} will take a long time attempting to match even a "
"moderately long string of @samp{a}s before failing.  The equivalent "
"@samp{\\(?:a\\|b\\)*c} is much faster, and @samp{[ab]*c} better still."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:1961
msgid ""
"Don't use capturing groups unless they are really needed; that is, use "
"@samp{\\(?:@dots{}\\)} instead of @samp{\\(@dots{}\\)} for bracketing "
"purposes."
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1967
msgid ""
"Consider using @code{rx} (@pxref{Rx Notation}); it can optimize some "
"or-patterns automatically and will never introduce capturing groups unless "
"explicitly requested."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1974
msgid ""
"If you run into regexp stack overflow despite following the above advice, "
"don't be afraid of performing the matching in multiple function calls, each "
"using a simpler regexp where backtracking can more easily be contained."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1975
#, no-wrap
msgid "re--describe-compiled regexp &optional raw"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1981
msgid ""
"To help diagnose problems in your regexps or in the regexp engine itself, "
"this function returns a string describing the compiled form of "
"@var{regexp}.  To make sense of it, it can be necessary to read at least the "
"description of the @code{re_opcode_t} type in the @code{src/regex-emacs.c} "
"file in Emacs's source code."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1984
msgid ""
"It is currently able to give a meaningful description only if Emacs was "
"compiled with @code{--enable-checking}."
msgstr ""

#. type: section
#: original_texis/searching.texi:1987
#, no-wrap
msgid "Regular Expression Searching"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1988
#, no-wrap
msgid "regular expression searching"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1989
#, no-wrap
msgid "regexp searching"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1990
#, no-wrap
msgid "searching for regexp"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1998
msgid ""
"In GNU Emacs, you can search for the next match for a regular expression "
"(@pxref{Syntax of Regexps}) either incrementally or not.  For incremental "
"search commands, see @ref{Regexp Search, , Regular Expression Search, emacs, "
"The GNU Emacs Manual}.  Here we describe only the search functions useful in "
"programs.  The principal one is @code{re-search-forward}."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2002
msgid ""
"These search functions convert the regular expression to multibyte if the "
"buffer is multibyte; they convert the regular expression to unibyte if the "
"buffer is unibyte.  @xref{Text Representations}."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:2003
#, no-wrap
msgid "Command re-search-forward regexp &optional limit noerror count"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:2009
msgid ""
"This function searches forward in the current buffer for a string of text "
"that is matched by the regular expression @var{regexp}.  The function skips "
"over any amount of text that is not matched by @var{regexp}, and leaves "
"point at the end of the first match found.  It returns the new value of "
"point."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:2015
msgid ""
"If @var{limit} is non-@code{nil}, it must be a position in the current "
"buffer.  It specifies the upper bound to the search.  No match extending "
"after that position is accepted.  If @var{limit} is omitted or @code{nil}, "
"it defaults to the end of the accessible portion of the buffer."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:2018
msgid ""
"What @code{re-search-forward} does when the search fails depends on the "
"value of @var{noerror}:"
msgstr ""

#. type: table
#: original_texis/searching.texi:2022
msgid "Signal a @code{search-failed} error."
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:2022
#, no-wrap
msgid "t"
msgstr ""

#. type: table
#: original_texis/searching.texi:2024
msgid "Do nothing and return @code{nil}."
msgstr ""

#. type: item
#: original_texis/searching.texi:2024
#, no-wrap
msgid "anything else"
msgstr ""

#. type: table
#: original_texis/searching.texi:2027
msgid ""
"Move point to @var{limit} (or the end of the accessible portion of the "
"buffer) and return @code{nil}."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:2045
msgid ""
"In the following example, point is initially before the @samp{T}.  "
"Evaluating the search call moves point to the end of that line (between the "
"@samp{t} of @samp{hat} and the newline)."
msgstr ""

#. type: group
#: original_texis/searching.texi:2052
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"I read \"@point{}The cat in the hat\n"
"comes back\" twice.\n"
"---------- Buffer: foo ----------\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:2057
#, no-wrap
msgid ""
"(re-search-forward \"[a-z]+\" nil t 5)\n"
"     @result{} 27\n"
"\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:2062
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"I read \"The cat in the hat@point{}\n"
"comes back\" twice.\n"
"---------- Buffer: foo ----------\n"
msgstr ""

#. type: anchor{#1}
#: original_texis/searching.texi:2068
msgid "re-search-backward"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:2068
#, no-wrap
msgid "Command re-search-backward regexp &optional limit noerror count"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:2072
msgid ""
"This function searches backward in the current buffer for a string of text "
"that is matched by the regular expression @var{regexp}, leaving point at the "
"beginning of the first text found."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:2082
msgid ""
"This function is analogous to @code{re-search-forward}, but they are not "
"simple mirror images.  @code{re-search-forward} finds the match whose "
"beginning is as close as possible to the starting point.  If "
"@code{re-search-backward} were a perfect mirror image, it would find the "
"match whose end is as close as possible.  However, in fact it finds the "
"match whose beginning is as close as possible (and yet ends before the "
"starting point).  The reason for this is that matching a regular expression "
"at a given spot always works from beginning to end, and starts at a "
"specified beginning position."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:2086
msgid ""
"A true mirror-image of @code{re-search-forward} would require a special "
"feature for matching regular expressions from end to beginning.  It's not "
"worth the trouble of implementing that."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2088
#, no-wrap
msgid "string-match regexp string &optional start inhibit-modify"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2093
msgid ""
"This function returns the index of the start of the first match for the "
"regular expression @var{regexp} in @var{string}, or @code{nil} if there is "
"no match.  If @var{start} is non-@code{nil}, the search starts at that index "
"in @var{string}."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2095
msgid "For example,"
msgstr ""

#. type: group
#: original_texis/searching.texi:2101
#, no-wrap
msgid ""
"(string-match\n"
" \"quick\" \"The quick brown fox jumped quickly.\")\n"
"     @result{} 4\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:2106 original_texis/searching.texi:2123
#, no-wrap
msgid ""
"(string-match\n"
" \"quick\" \"The quick brown fox jumped quickly.\" 8)\n"
"     @result{} 27\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2112
msgid ""
"The index of the first character of the string is 0, the index of the second "
"character is 1, and so on."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2117
msgid ""
"By default, if this function finds a match, the index of the first character "
"beyond the match is available as @code{(match-end 0)}.  @xref{Match Data}.  "
"If @var{inhibit-modify} is non-@code{nil}, the match data isn't modified."
msgstr ""

#. type: group
#: original_texis/searching.texi:2128
#, no-wrap
msgid ""
"(match-end 0)\n"
"     @result{} 32\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2132
#, no-wrap
msgid "string-match-p regexp string &optional start"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2135
msgid ""
"This predicate function does what @code{string-match} does, but it avoids "
"modifying the match data."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2137
#, no-wrap
msgid "looking-at regexp &optional inhibit-modify"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2143
msgid ""
"This function determines whether the text in the current buffer directly "
"following point matches the regular expression @var{regexp}.  ``Directly "
"following'' means precisely that: the search is ``anchored'' and it can "
"succeed only starting with the first character following point.  The result "
"is @code{t} if so, @code{nil} otherwise."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2149
msgid ""
"This function does not move point, but it does update the match data (if "
"@var{inhibit-modify} is @code{nil} or missing, which is the default).  "
"@xref{Match Data}.  As a convenience, instead of using the "
"@var{inhibit-modify} argument, you can use @code{looking-at-p}, described "
"below."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2152
msgid ""
"In this example, point is located directly before the @samp{T}.  If it were "
"anywhere else, the result would be @code{nil}."
msgstr ""

#. type: group
#: original_texis/searching.texi:2159 original_texis/searching.texi:2184
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"I read \"@point{}The cat in the hat\n"
"comes back\" twice.\n"
"---------- Buffer: foo ----------\n"
"\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:2162
#, no-wrap
msgid ""
"(looking-at \"The cat in the hat$\")\n"
"     @result{} t\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2166
#, no-wrap
msgid "looking-back regexp limit &optional greedy"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2169
msgid ""
"This function returns @code{t} if @var{regexp} matches the text immediately "
"before point (i.e., ending at point), and @code{nil} otherwise."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2177
msgid ""
"Because regular expression matching works only going forward, this is "
"implemented by searching backwards from point for a match that ends at "
"point.  That can be quite slow if it has to search a long distance.  You can "
"bound the time required by specifying a non-@code{nil} value for "
"@var{limit}, which says not to search before @var{limit}.  In this case, the "
"match that is found must begin at or after @var{limit}.  Here's an example:"
msgstr ""

#. type: group
#: original_texis/searching.texi:2189
#, no-wrap
msgid ""
"(looking-back \"read \\\"\" 3)\n"
"     @result{} t\n"
"(looking-back \"read \\\"\" 4)\n"
"     @result{} nil\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2197
msgid ""
"If @var{greedy} is non-@code{nil}, this function extends the match backwards "
"as far as possible, stopping when a single additional previous character "
"cannot be part of a match for @var{regexp}.  When the match is extended, its "
"starting position is allowed to occur before @var{limit}."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2202
msgid ""
"As a general recommendation, try to avoid using @code{looking-back} wherever "
"possible, since it is slow.  For this reason, there are no plans to add a "
"@code{looking-back-p} function."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2204
#, no-wrap
msgid "looking-at-p regexp"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2207
msgid ""
"This predicate function works like @code{looking-at}, but without updating "
"the match data."
msgstr ""

#. type: defvar
#: original_texis/searching.texi:2209
#, no-wrap
msgid "search-spaces-regexp"
msgstr ""

#. type: defvar
#: original_texis/searching.texi:2216
msgid ""
"If this variable is non-@code{nil}, it should be a regular expression that "
"says how to search for whitespace.  In that case, any group of spaces in a "
"regular expression being searched for stands for use of this regular "
"expression.  However, spaces inside of constructs such as @samp{[@dots{}]} "
"and @samp{*}, @samp{+}, @samp{?} are not affected by "
"@code{search-spaces-regexp}."
msgstr ""

#. type: defvar
#: original_texis/searching.texi:2224
msgid ""
"Since this variable affects all regular expression search and match "
"constructs, you should bind it temporarily for as small as possible a part "
"of the code, and only where the Lisp code affected by the binding performs "
"searches whose regexp was produced from interactive user input.  In other "
"words, this variable should only be used to tell regexp search primitives "
"how to interpret whitespace typed by the user."
msgstr ""

#. type: section
#: original_texis/searching.texi:2227
#, no-wrap
msgid "Longest-match searching for regular expression matches"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:2229
#, no-wrap
msgid "backtracking and POSIX regular expressions"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2234
msgid ""
"The usual regular expression functions do backtracking when necessary to "
"handle the @samp{\\|} and repetition constructs, but they continue this only "
"until they find @emph{some} match.  Then they succeed and report the first "
"match found."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2241
msgid ""
"This section describes alternative search functions which perform the full "
"backtracking specified by the POSIX standard for regular expression "
"matching.  They continue backtracking until they have tried all "
"possibilities and found all matches, so they can report the longest match, "
"as required by POSIX@.  This is much slower, so use these functions only "
"when you really need the longest match."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2248
msgid ""
"Despite their names, the POSIX search and match functions use Emacs regular "
"expressions, not POSIX regular expressions.  @xref{POSIX Regexps}.  Also, "
"they do not properly support the non-greedy repetition operators "
"(@pxref{Regexp Special, non-greedy}).  This is because POSIX backtracking "
"conflicts with the semantics of non-greedy repetition."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:2249
#, no-wrap
msgid "Command posix-search-forward regexp &optional limit noerror count"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:2253
msgid ""
"This is like @code{re-search-forward} except that it performs the full "
"backtracking specified by the POSIX standard for regular expression "
"matching."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:2255
#, no-wrap
msgid "Command posix-search-backward regexp &optional limit noerror count"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:2259
msgid ""
"This is like @code{re-search-backward} except that it performs the full "
"backtracking specified by the POSIX standard for regular expression "
"matching."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2261
#, no-wrap
msgid "posix-looking-at regexp &optional inhibit-modify"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2265
msgid ""
"This is like @code{looking-at} except that it performs the full backtracking "
"specified by the POSIX standard for regular expression matching."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2267
#, no-wrap
msgid "posix-string-match regexp string &optional start inhibit-modify"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2271
msgid ""
"This is like @code{string-match} except that it performs the full "
"backtracking specified by the POSIX standard for regular expression "
"matching."
msgstr ""

#. type: section
#: original_texis/searching.texi:2274
#, no-wrap
msgid "The Match Data"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:2275
#, no-wrap
msgid "match data"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2282
msgid ""
"Emacs keeps track of the start and end positions of the segments of text "
"found during a search; this is called the @dfn{match data}.  Thanks to the "
"match data, you can search for a complex pattern, such as a date in a mail "
"message, and then extract parts of the match under control of the pattern."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2288
msgid ""
"Because the match data normally describe the most recent search only, you "
"must be careful not to do another search inadvertently between the search "
"you wish to refer back to and the use of the match data.  If you can't avoid "
"another intervening search, you must save and restore the match data around "
"it, to prevent it from being overwritten."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2294
msgid ""
"Notice that all functions are allowed to overwrite the match data unless "
"they're explicitly documented not to do so.  A consequence is that functions "
"that are run implicitly in the background (@pxref{Timers}, and @ref{Idle "
"Timers}) should likely save and restore the match data explicitly."
msgstr ""

#. type: node
#: original_texis/searching.texi:2301 original_texis/searching.texi:2303
#, no-wrap
msgid "Replacing Match"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:2301
msgid "Replacing a substring that was matched."
msgstr ""

#. type: node
#: original_texis/searching.texi:2301 original_texis/searching.texi:2387
#, no-wrap
msgid "Simple Match Data"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:2301
msgid ""
"Accessing single items of match data, such as where a particular "
"subexpression started."
msgstr ""

#. type: node
#: original_texis/searching.texi:2301 original_texis/searching.texi:2533
#, no-wrap
msgid "Entire Match Data"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:2301
msgid "Accessing the entire match data at once, as a list."
msgstr ""

#. type: node
#: original_texis/searching.texi:2301 original_texis/searching.texi:2615
#, no-wrap
msgid "Saving Match Data"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:2301
msgid "Saving and restoring the match data."
msgstr ""

#. type: subsection
#: original_texis/searching.texi:2304
#, no-wrap
msgid "Replacing the Text that Matched"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:2305
#, no-wrap
msgid "replace matched text"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2309
msgid ""
"This function replaces all or part of the text matched by the last search.  "
"It works by means of the match data."
msgstr ""

#. type: cindex
#: original_texis/searching.texi:2310
#, no-wrap
msgid "case in replacements"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2311
#, no-wrap
msgid "replace-match replacement &optional fixedcase literal string subexp"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2313
msgid "This function performs a replacement operation on a buffer or string."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2320
msgid ""
"If you did the last search in a buffer, you should omit the @var{string} "
"argument or specify @code{nil} for it, and make sure that the current buffer "
"is the one in which you performed the last search.  Then this function edits "
"the buffer, replacing the matched text with @var{replacement}.  It leaves "
"point at the end of the replacement text."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2324
msgid ""
"If you performed the last search on a string, pass the same string as "
"@var{string}.  Then this function returns a new string, in which the matched "
"text is replaced by @var{replacement}."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2334
msgid ""
"If @var{fixedcase} is non-@code{nil}, then @code{replace-match} uses the "
"replacement text without case conversion; otherwise, it converts the "
"replacement text depending upon the capitalization of the text to be "
"replaced.  If the original text is all upper case, this converts the "
"replacement text to upper case.  If all words of the original text are "
"capitalized, this capitalizes all the words of the replacement text.  If all "
"the words are one-letter and they are all upper case, they are treated as "
"capitalized words rather than all-upper-case words."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2340
msgid ""
"If @var{literal} is non-@code{nil}, then @var{replacement} is inserted "
"exactly as it is, the only alterations being case changes as needed.  If it "
"is @code{nil} (the default), then the character @samp{\\} is treated "
"specially.  If a @samp{\\} appears in @var{replacement}, then it must be "
"part of one of the following sequences:"
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:2342
#, no-wrap
msgid "\\&"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:2343
#, no-wrap
msgid "@samp{&} in replacement"
msgstr ""

#. type: table
#: original_texis/searching.texi:2345
msgid "This stands for the entire text being replaced."
msgstr ""

#. type: item
#: original_texis/searching.texi:2346
#, no-wrap
msgid "@samp{\\@var{n}}, where @var{n} is a digit"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:2347
#, no-wrap
msgid "@samp{\\@var{n}} in replacement"
msgstr ""

#. type: table
#: original_texis/searching.texi:2352
msgid ""
"This stands for the text that matched the @var{n}th subexpression in the "
"original regexp.  Subexpressions are those expressions grouped inside "
"@samp{\\(@dots{}\\)}.  If the @var{n}th subexpression never matched, an "
"empty string is substituted."
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:2353
#, no-wrap
msgid "\\\\"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:2354
#, no-wrap
msgid "@samp{\\} in replacement"
msgstr ""

#. type: table
#: original_texis/searching.texi:2356
msgid "This stands for a single @samp{\\} in the replacement text."
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:2357
#, no-wrap
msgid "\\?"
msgstr ""

#. type: table
#: original_texis/searching.texi:2361
msgid ""
"This stands for itself (for compatibility with @code{replace-regexp} and "
"related commands; @pxref{Regexp Replace,,, emacs, The GNU Emacs Manual})."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2365
msgid "Any other character following @samp{\\} signals an error."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2369
msgid ""
"The substitutions performed by @samp{\\&} and @samp{\\@var{n}} occur after "
"case conversion, if any.  Therefore, the strings they substitute are never "
"case-converted."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2375
msgid ""
"If @var{subexp} is non-@code{nil}, that says to replace just subexpression "
"number @var{subexp} of the regexp that was matched, not the entire match.  "
"For example, after matching @samp{foo \\(ba*r\\)}, calling "
"@code{replace-match} with 1 as @var{subexp} means to replace just the text "
"that matched @samp{\\(ba*r\\)}."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2377
#, no-wrap
msgid ""
"match-substitute-replacement replacement &optional fixedcase literal string "
"subexp"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2385
msgid ""
"This function returns the text that would be inserted into the buffer by "
"@code{replace-match}, but without modifying the buffer.  It is useful if you "
"want to present the user with actual replacement result, with constructs "
"like @samp{\\@var{n}} or @samp{\\&} substituted with matched groups.  "
"Arguments @var{replacement} and optional @var{fixedcase}, @var{literal}, "
"@var{string} and @var{subexp} have the same meaning as for "
"@code{replace-match}."
msgstr ""

#. type: subsection
#: original_texis/searching.texi:2388
#, no-wrap
msgid "Simple Match Data Access"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2392
msgid ""
"This section explains how to use the match data to find out what was matched "
"by the last search or match operation, if it succeeded."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2398
msgid ""
"You can ask about the entire matching text, or about a particular "
"parenthetical subexpression of a regular expression.  The @var{count} "
"argument in the functions below specifies which.  If @var{count} is zero, "
"you are asking about the entire match.  If @var{count} is positive, it "
"specifies which subexpression you want."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2406
msgid ""
"Recall that the subexpressions of a regular expression are those expressions "
"grouped with escaped parentheses, @samp{\\(@dots{}\\)}.  The @var{count}th "
"subexpression is found by counting occurrences of @samp{\\(} from the "
"beginning of the whole regular expression.  The first subexpression is "
"numbered 1, the second 2, and so on.  Only regular expressions can have "
"subexpressions---after a simple string search, the only information "
"available is about the entire match."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2414
msgid ""
"Every successful search sets the match data.  Therefore, you should query "
"the match data immediately after searching, before calling any other "
"function that might perform another search.  Alternatively, you may save and "
"restore the match data (@pxref{Saving Match Data}) around the call to "
"functions that could perform another search.  Or use the functions that "
"explicitly do not modify the match data; e.g., @code{string-match-p}."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2421
msgid ""
"A search which fails may or may not alter the match data.  In the current "
"implementation, it does not, but we may change it in the future.  Don't try "
"to rely on the value of the match data after a failing search."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2422
#, no-wrap
msgid "match-string count &optional in-string"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2427
msgid ""
"This function returns, as a string, the text matched in the last search or "
"match operation.  It returns the entire text if @var{count} is zero, or just "
"the portion corresponding to the @var{count}th parenthetical subexpression, "
"if @var{count} is positive."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2435
msgid ""
"If the last such operation was done against a string with "
"@code{string-match}, then you should pass the same string as the argument "
"@var{in-string}.  After a buffer search or match, you should omit "
"@var{in-string} or pass @code{nil} for it; but you should make sure that the "
"current buffer when you call @code{match-string} is the one in which you did "
"the searching or matching.  Failure to follow this advice will lead to "
"incorrect results."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2439
msgid ""
"The value is @code{nil} if @var{count} is out of range, or for a "
"subexpression inside a @samp{\\|} alternative that wasn't used or a "
"repetition that repeated zero times."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2441
#, no-wrap
msgid "match-string-no-properties count &optional in-string"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2444
msgid ""
"This function is like @code{match-string} except that the result has no text "
"properties."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2446
#, no-wrap
msgid "match-beginning count"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2450
msgid ""
"If the last regular expression search found a match, this function returns "
"the position of the start of the matching text or of a subexpression of it."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2455
msgid ""
"If @var{count} is zero, then the value is the position of the start of the "
"entire match.  Otherwise, @var{count} specifies a subexpression in the "
"regular expression, and the value of the function is the starting position "
"of the match for that subexpression."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2458
msgid ""
"The value is @code{nil} for a subexpression inside a @samp{\\|} alternative "
"that wasn't used or a repetition that repeated zero times."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2460
#, no-wrap
msgid "match-end count"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2464
msgid ""
"This function is like @code{match-beginning} except that it returns the "
"position of the end of the match, rather than the position of the beginning."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2468
msgid ""
"Here is an example of using the match data, with a comment showing the "
"positions within the text:"
msgstr ""

#. type: group
#: original_texis/searching.texi:2475
#, no-wrap
msgid ""
"(string-match \"\\\\(qu\\\\)\\\\(ick\\\\)\"\n"
"              \"The quick fox jumped quickly.\")\n"
"              ;0123456789\n"
"     @result{} 4\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:2484
#, no-wrap
msgid ""
"(match-string 0 \"The quick fox jumped quickly.\")\n"
"     @result{} \"quick\"\n"
"(match-string 1 \"The quick fox jumped quickly.\")\n"
"     @result{} \"qu\"\n"
"(match-string 2 \"The quick fox jumped quickly.\")\n"
"     @result{} \"ick\"\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:2489
#, no-wrap
msgid ""
"(match-beginning 1)       ; @r{The beginning of the match}\n"
"     @result{} 4                 ;   @r{with @samp{qu} is at index 4.}\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:2494
#, no-wrap
msgid ""
"(match-beginning 2)       ; @r{The beginning of the match}\n"
"     @result{} 6                 ;   @r{with @samp{ick} is at index 6.}\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:2499
#, no-wrap
msgid ""
"(match-end 1)             ; @r{The end of the match}\n"
"     @result{} 6                 ;   @r{with @samp{qu} is at index 6.}\n"
"\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:2502
#, no-wrap
msgid ""
"(match-end 2)             ; @r{The end of the match}\n"
"     @result{} 9                 ;   @r{with @samp{ick} is at index 9.}\n"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2510
msgid ""
"Here is another example.  Point is initially located at the beginning of the "
"line.  Searching moves point to between the space and the word @samp{in}.  "
"The beginning of the entire match is at the 9th character of the buffer "
"(@samp{T}), and the beginning of the match for the first subexpression is at "
"the 13th character (@samp{c})."
msgstr ""

#. type: group
#: original_texis/searching.texi:2518
#, no-wrap
msgid ""
"(list\n"
"  (re-search-forward \"The \\\\(cat \\\\)\")\n"
"  (match-beginning 0)\n"
"  (match-beginning 1))\n"
"    @result{} (17 9 13)\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:2526
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"I read \"The cat @point{}in the hat comes back\" twice.\n"
"        ^   ^\n"
"        9  13\n"
"---------- Buffer: foo ----------\n"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2532
msgid ""
"(In this case, the index returned is a buffer position; the first character "
"of the buffer counts as 1.)"
msgstr ""

#. type: subsection
#: original_texis/searching.texi:2534
#, no-wrap
msgid "Accessing the Entire Match Data"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2538
msgid ""
"The functions @code{match-data} and @code{set-match-data} read or write the "
"entire match data, all at once."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2539
#, no-wrap
msgid "match-data &optional integers reuse reseat"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2547
msgid ""
"This function returns a list of positions (markers or integers) that record "
"all the information on the text that the last search matched.  Element zero "
"is the position of the beginning of the match for the whole expression; "
"element one is the position of the end of the match for the expression.  The "
"next two elements are the positions of the beginning and end of the match "
"for the first subexpression, and so on.  In general, element"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:2549
msgid "number 2@var{n}"
msgstr ""

#. type: tex
#: original_texis/searching.texi:2552
#, no-wrap
msgid "number {\\mathsurround=0pt $2n$}\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2555
msgid "corresponds to @code{(match-beginning @var{n})}; and element"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:2557
msgid "number 2@var{n} + 1"
msgstr ""

#. type: tex
#: original_texis/searching.texi:2560
#, no-wrap
msgid "number {\\mathsurround=0pt $2n+1$}\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2562
msgid "corresponds to @code{(match-end @var{n})}."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2570
msgid ""
"Normally all the elements are markers or @code{nil}, but if @var{integers} "
"is non-@code{nil}, that means to use integers instead of markers.  (In that "
"case, the buffer itself is appended as an additional element at the end of "
"the list, to facilitate complete restoration of the match data.)  If the "
"last match was done on a string with @code{string-match}, then integers are "
"always used, since markers can't point into a string."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2579
msgid ""
"If @var{reuse} is non-@code{nil}, it should be a list.  In that case, "
"@code{match-data} stores the match data in @var{reuse}.  That is, "
"@var{reuse} is destructively modified.  @var{reuse} does not need to have "
"the right length.  If it is not long enough to contain the match data, it is "
"extended.  If it is too long, the length of @var{reuse} stays the same, but "
"the elements that were not used are set to @code{nil}.  The purpose of this "
"feature is to reduce the need for garbage collection."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2582
msgid ""
"If @var{reseat} is non-@code{nil}, all markers on the @var{reuse} list are "
"reseated to point to nowhere."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2586
msgid ""
"As always, there must be no possibility of intervening searches between the "
"call to a search function and the call to @code{match-data} that is intended "
"to access the match data for that search."
msgstr ""

#. type: group
#: original_texis/searching.texi:2594
#, no-wrap
msgid ""
"(match-data)\n"
"     @result{}  (#<marker at 9 in foo>\n"
"          #<marker at 17 in foo>\n"
"          #<marker at 13 in foo>\n"
"          #<marker at 17 in foo>)\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2598
#, no-wrap
msgid "set-match-data match-list &optional reseat"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2603
msgid ""
"This function sets the match data from the elements of @var{match-list}, "
"which should be a list that was the value of a previous call to "
"@code{match-data}.  (More precisely, anything that has the same format will "
"work.)"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2606
msgid ""
"If @var{match-list} refers to a buffer that doesn't exist, you don't get an "
"error; that sets the match data in a meaningless but harmless way."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2609
msgid ""
"If @var{reseat} is non-@code{nil}, all markers on the @var{match-list} list "
"are reseated to point to nowhere."
msgstr ""

#. type: findex
#: original_texis/searching.texi:2611
#, no-wrap
msgid "store-match-data"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2613
msgid "@code{store-match-data} is a semi-obsolete alias for @code{set-match-data}."
msgstr ""

#. type: subsection
#: original_texis/searching.texi:2616
#, no-wrap
msgid "Saving and Restoring the Match Data"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2622
msgid ""
"When you call a function that may search, you may need to save and restore "
"the match data around that call, if you want to preserve the match data from "
"an earlier search for later use.  Here is an example that shows the problem "
"that arises if you fail to save the match data:"
msgstr ""

#. type: group
#: original_texis/searching.texi:2630
#, no-wrap
msgid ""
"(re-search-forward \"The \\\\(cat \\\\)\")\n"
"     @result{} 48\n"
"(foo)                   ; @r{@code{foo} does more searching.}\n"
"(match-end 0)\n"
"     @result{} 61              ; @r{Unexpected result---not 48!}\n"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2634
msgid "You can save and restore the match data with @code{save-match-data}:"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:2635
#, no-wrap
msgid "save-match-data body@dots{}"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:2639
msgid ""
"This macro executes @var{body}, saving and restoring the match data around "
"it.  The return value is the value of the last form in @var{body}."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2644
msgid ""
"You could use @code{set-match-data} together with @code{match-data} to "
"imitate the effect of the special form @code{save-match-data}.  Here is how:"
msgstr ""

#. type: group
#: original_texis/searching.texi:2651
#, no-wrap
msgid ""
"(let ((data (match-data)))\n"
"  (unwind-protect\n"
"      @dots{}   ; @r{Ok to change the original match data.}\n"
"    (set-match-data data)))\n"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2657
msgid ""
"Emacs automatically saves and restores the match data when it runs process "
"filter functions (@pxref{Filter Functions}) and process sentinels "
"(@pxref{Sentinels})."
msgstr ""

#. type: group
#: original_texis/searching.texi:2670
#, no-wrap
msgid ""
"(defun restore-match-data (data)\n"
"  \"Restore the match data DATA unless the buffer is missing.\"\n"
"  (catch 'foo\n"
"    (let ((d data))\n"
msgstr ""

#. type: smallexample
#: original_texis/searching.texi:2674
#, no-wrap
msgid ""
"      (while d\n"
"        (and (car d)\n"
"             (null (marker-buffer (car d)))\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:2679
#, no-wrap
msgid ""
"             ;; @file{match-data} @r{buffer is deleted.}\n"
"             (throw 'foo nil))\n"
"        (setq d (cdr d)))\n"
"      (set-match-data data))))\n"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:2685
#, no-wrap
msgid "replacement after search"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:2686
#, no-wrap
msgid "searching and replacing"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2691
msgid ""
"If you want to find all matches for a regexp in part of the buffer and "
"replace them, the most flexible way is to write an explicit loop using "
"@code{re-search-forward} and @code{replace-match}, like this:"
msgstr ""

#. type: example
#: original_texis/searching.texi:2695
#, no-wrap
msgid ""
"(while (re-search-forward \"foo[ \\t]+bar\" nil t)\n"
"  (replace-match \"foobar\"))\n"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2700
msgid ""
"@xref{Replacing Match,, Replacing the Text that Matched}, for a description "
"of @code{replace-match}."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2703
msgid ""
"It may be more convenient to limit the replacements to a specific region.  "
"The function @code{replace-regexp-in-region} does that."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2704
#, no-wrap
msgid "replace-regexp-in-region regexp replacement &optional start end"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2715
msgid ""
"This function replaces all the occurrences of @var{regexp} with "
"@var{replacement} in the region of buffer text between @var{start} and "
"@var{end}; @var{start} defaults to position of point, and @var{end} defaults "
"to the last accessible position of the buffer.  The search for @var{regexp} "
"is case-sensitive, and @var{replacement} is inserted without changing its "
"letter-case.  The @var{replacement} string can use the same special elements "
"starting with @samp{\\} as @code{replace-match} does.  The function returns "
"the number of replaced occurrences, or @code{nil} if @var{regexp} is not "
"found.  The function preserves the position of point."
msgstr ""

#. type: example
#: original_texis/searching.texi:2718
#, no-wrap
msgid "(replace-regexp-in-region \"foo[ \\t]+bar\" \"foobar\")\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2721
#, no-wrap
msgid "replace-string-in-region string replacement &optional start end"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2725
msgid ""
"This function works similarly to @code{replace-regexp-in-region}, but "
"searches for, and replaces, literal @var{string}s instead of regular "
"expressions."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2728
msgid "Emacs also has special functions for replacing matches in a string."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2729
#, no-wrap
msgid ""
"replace-regexp-in-string regexp rep string &optional fixedcase literal "
"subexp start"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2737
msgid ""
"This function copies @var{string} and searches it for matches for "
"@var{regexp}, and replaces them with @var{rep}.  It returns the modified "
"copy.  If @var{start} is non-@code{nil}, the search for matches starts at "
"that index in @var{string}, and the returned value does not include the "
"first @var{start} characters of @var{string}.  To get the whole transformed "
"string, concatenate the first @var{start} characters of @var{string} with "
"the return value."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2741
msgid ""
"This function uses @code{replace-match} to do the replacement, and it passes "
"the optional arguments @var{fixedcase}, @var{literal} and @var{subexp} along "
"to @code{replace-match}."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2748
msgid ""
"Instead of a string, @var{rep} can be a function.  In that case, "
"@code{replace-regexp-in-string} calls @var{rep} for each match, passing the "
"text of the match as its sole argument.  It collects the value @var{rep} "
"returns and passes that to @code{replace-match} as the replacement string.  "
"The match data at this point are the result of matching @var{regexp} against "
"a substring of @var{string}."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2750
#, no-wrap
msgid "string-replace from-string to-string in-string"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2755
msgid ""
"This function replaces all occurrences of @var{from-string} with "
"@var{to-string} in @var{in-string} and returns the result.  It may return "
"one of its arguments unchanged, a constant string or a new string.  Case is "
"significant, and text properties are ignored."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2759
msgid ""
"If you want to write a command along the lines of @code{query-replace}, you "
"can use @code{perform-replace} to do the work."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2760
#, no-wrap
msgid ""
"perform-replace from-string replacements query-flag regexp-flag "
"delimited-flag &optional repeat-count map start end backward "
"region-noncontiguous-p"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2768
msgid ""
"This function is the guts of @code{query-replace} and related commands.  It "
"searches for occurrences of @var{from-string} in the text between positions "
"@var{start} and @var{end} and replaces some or all of them.  If @var{start} "
"is @code{nil} (or omitted), point is used instead, and the end of the "
"buffer's accessible portion is used for @var{end}.  (If the optional "
"argument @var{backward} is non-@code{nil}, the search starts at @var{end} "
"and goes backward.)"
msgstr ""

#. type: defun
#: original_texis/searching.texi:2771
msgid ""
"If @var{query-flag} is @code{nil}, it replaces all occurrences; otherwise, "
"it asks the user what to do about each one."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2776
msgid ""
"If @var{regexp-flag} is non-@code{nil}, then @var{from-string} is considered "
"a regular expression; otherwise, it must match literally.  If "
"@var{delimited-flag} is non-@code{nil}, then only replacements surrounded by "
"word boundaries are considered."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2780
msgid ""
"The argument @var{replacements} specifies what to replace occurrences with.  "
"If it is a string, that string is used.  It can also be a list of strings, "
"to be used in cyclic order."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2785
msgid ""
"If @var{replacements} is a cons cell, @w{@code{(@var{function} "
". @var{data})}}, this means to call @var{function} after each match to get "
"the replacement text.  This function is called with two arguments: "
"@var{data}, and the number of replacements already made."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2789
msgid ""
"If @var{repeat-count} is non-@code{nil}, it should be an integer.  Then it "
"specifies how many times to use each of the strings in the "
"@var{replacements} list before advancing cyclically to the next one."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2793
msgid ""
"If @var{from-string} contains upper-case letters, then "
"@code{perform-replace} binds @code{case-fold-search} to @code{nil}, and it "
"uses the @var{replacements} without altering their case."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2798
msgid ""
"Normally, the keymap @code{query-replace-map} defines the possible user "
"responses for queries.  The argument @var{map}, if non-@code{nil}, specifies "
"a keymap to use instead of @code{query-replace-map}."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2803
msgid ""
"Non-@code{nil} @var{region-noncontiguous-p} means that the region between "
"@var{start} and @var{end} is composed of noncontiguous pieces.  The most "
"common example of this is a rectangular region, where the pieces are "
"separated by newline characters."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2810
msgid ""
"This function uses one of two functions to search for the next occurrence of "
"@var{from-string}.  These functions are specified by the values of two "
"variables: @code{replace-re-search-function} and "
"@code{replace-search-function}.  The former is called when the argument "
"@var{regexp-flag} is non-@code{nil}, the latter when it is @code{nil}."
msgstr ""

#. type: defvar
#: original_texis/searching.texi:2812
#, no-wrap
msgid "query-replace-map"
msgstr ""

#. type: defvar
#: original_texis/searching.texi:2817
msgid ""
"This variable holds a special keymap that defines the valid user responses "
"for @code{perform-replace} and the commands that use it, as well as "
"@code{y-or-n-p} and @code{map-y-or-n-p}.  This map is unusual in two ways:"
msgstr ""

#. type: itemize
#: original_texis/searching.texi:2822
msgid ""
"The key bindings are not commands, just symbols that are meaningful to the "
"functions that use this map."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:2828
msgid ""
"Prefix keys are not supported; each key binding must be for a single-event "
"key sequence.  This is because the functions don't use "
"@code{read-key-sequence} to get the input; instead, they read a single event "
"and look it up ``by hand''."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2834
msgid ""
"Here are the meaningful bindings for @code{query-replace-map}.  Several of "
"them are meaningful only for @code{query-replace} and friends."
msgstr ""

#. type: item
#: original_texis/searching.texi:2836
#, no-wrap
msgid "act"
msgstr ""

#. type: table
#: original_texis/searching.texi:2838
msgid "Do take the action being considered---in other words, ``yes''."
msgstr ""

#. type: item
#: original_texis/searching.texi:2839
#, no-wrap
msgid "skip"
msgstr ""

#. type: table
#: original_texis/searching.texi:2841
msgid "Do not take action for this question---in other words, ``no''."
msgstr ""

#. type: item
#: original_texis/searching.texi:2842
#, no-wrap
msgid "exit"
msgstr ""

#. type: table
#: original_texis/searching.texi:2845
msgid ""
"Answer this question ``no'', and give up on the entire series of questions, "
"assuming that the answers will be ``no''."
msgstr ""

#. type: item
#: original_texis/searching.texi:2846
#, no-wrap
msgid "exit-prefix"
msgstr ""

#. type: table
#: original_texis/searching.texi:2849
msgid ""
"Like @code{exit}, but add the key that was pressed to "
"@code{unread-command-events} (@pxref{Event Input Misc})."
msgstr ""

#. type: item
#: original_texis/searching.texi:2850
#, no-wrap
msgid "act-and-exit"
msgstr ""

#. type: table
#: original_texis/searching.texi:2853
msgid ""
"Answer this question ``yes'', and give up on the entire series of questions, "
"assuming that subsequent answers will be ``no''."
msgstr ""

#. type: item
#: original_texis/searching.texi:2854
#, no-wrap
msgid "act-and-show"
msgstr ""

#. type: table
#: original_texis/searching.texi:2857
msgid ""
"Answer this question ``yes'', but show the results---don't advance yet to "
"the next question."
msgstr ""

#. type: item
#: original_texis/searching.texi:2858
#, no-wrap
msgid "automatic"
msgstr ""

#. type: table
#: original_texis/searching.texi:2861
msgid ""
"Answer this question and all subsequent questions in the series with "
"``yes'', without further user interaction."
msgstr ""

#. type: item
#: original_texis/searching.texi:2862
#, no-wrap
msgid "backup"
msgstr ""

#. type: table
#: original_texis/searching.texi:2864
msgid "Move back to the previous place that a question was asked about."
msgstr ""

#. type: item
#: original_texis/searching.texi:2865
#, no-wrap
msgid "undo"
msgstr ""

#. type: table
#: original_texis/searching.texi:2868
msgid ""
"Undo last replacement and move back to the place where that replacement was "
"performed."
msgstr ""

#. type: item
#: original_texis/searching.texi:2869
#, no-wrap
msgid "undo-all"
msgstr ""

#. type: table
#: original_texis/searching.texi:2872
msgid ""
"Undo all replacements and move back to the place where the first replacement "
"was performed."
msgstr ""

#. type: item
#: original_texis/searching.texi:2873
#, no-wrap
msgid "edit"
msgstr ""

#. type: table
#: original_texis/searching.texi:2876
msgid ""
"Enter a recursive edit to deal with this question---instead of any other "
"action that would normally be taken."
msgstr ""

#. type: item
#: original_texis/searching.texi:2877
#, no-wrap
msgid "edit-replacement"
msgstr ""

#. type: table
#: original_texis/searching.texi:2879
msgid "Edit the replacement for this question in the minibuffer."
msgstr ""

#. type: item
#: original_texis/searching.texi:2880
#, no-wrap
msgid "delete-and-edit"
msgstr ""

#. type: table
#: original_texis/searching.texi:2883
msgid "Delete the text being considered, then enter a recursive edit to replace it."
msgstr ""

#. type: item
#: original_texis/searching.texi:2884
#, no-wrap
msgid "recenter"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:2885
#, no-wrap
msgid "scroll-up"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:2886
#, no-wrap
msgid "scroll-down"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:2887
#, no-wrap
msgid "scroll-other-window"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:2888
#, no-wrap
msgid "scroll-other-window-down"
msgstr ""

#. type: table
#: original_texis/searching.texi:2892
msgid ""
"Perform the specified window scroll operation, then ask the same question "
"again.  Only @code{y-or-n-p} and related functions use this answer."
msgstr ""

#. type: item
#: original_texis/searching.texi:2893
#, no-wrap
msgid "quit"
msgstr ""

#. type: table
#: original_texis/searching.texi:2896
msgid ""
"Perform a quit right away.  Only @code{y-or-n-p} and related functions use "
"this answer."
msgstr ""

#. type: item
#: original_texis/searching.texi:2897
#, no-wrap
msgid "help"
msgstr ""

#. type: table
#: original_texis/searching.texi:2899
msgid "Display some help, then ask again."
msgstr ""

#. type: defvar
#: original_texis/searching.texi:2901
#, no-wrap
msgid "multi-query-replace-map"
msgstr ""

#. type: defvar
#: original_texis/searching.texi:2905
msgid ""
"This variable holds a keymap that extends @code{query-replace-map} by "
"providing additional key bindings that are useful in multi-buffer "
"replacements.  The additional bindings are:"
msgstr ""

#. type: item
#: original_texis/searching.texi:2907
#, no-wrap
msgid "automatic-all"
msgstr ""

#. type: table
#: original_texis/searching.texi:2910
msgid ""
"Answer this question and all subsequent questions in the series with "
"``yes'', without further user interaction, for all remaining buffers."
msgstr ""

#. type: item
#: original_texis/searching.texi:2911
#, no-wrap
msgid "exit-current"
msgstr ""

#. type: table
#: original_texis/searching.texi:2915
msgid ""
"Answer this question ``no'', and give up on the entire series of questions "
"for the current buffer.  Continue to the next buffer in the sequence."
msgstr ""

#. type: defvar
#: original_texis/searching.texi:2918
#, no-wrap
msgid "replace-search-function"
msgstr ""

#. type: defvar
#: original_texis/searching.texi:2924
msgid ""
"This variable specifies a function that @code{perform-replace} calls to "
"search for the next string to replace.  Its default value is "
"@code{search-forward}.  Any other value should name a function of 3 "
"arguments: the first 3 arguments of @code{search-forward} (@pxref{String "
"Search})."
msgstr ""

#. type: defvar
#: original_texis/searching.texi:2926
#, no-wrap
msgid "replace-re-search-function"
msgstr ""

#. type: defvar
#: original_texis/searching.texi:2932
msgid ""
"This variable specifies a function that @code{perform-replace} calls to "
"search for the next regexp to replace.  Its default value is "
"@code{re-search-forward}.  Any other value should name a function of 3 "
"arguments: the first 3 arguments of @code{re-search-forward} (@pxref{Regexp "
"Search})."
msgstr ""

#. type: section
#: original_texis/searching.texi:2935
#, no-wrap
msgid "Standard Regular Expressions Used in Editing"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:2936
#, no-wrap
msgid "regexps used standardly in editing"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:2937
#, no-wrap
msgid "standard regexps used in editing"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2941
msgid ""
"This section describes some variables that hold regular expressions used for "
"certain purposes in editing:"
msgstr ""

#. type: defopt
#: original_texis/searching.texi:2942
#, no-wrap
msgid "page-delimiter"
msgstr ""

#. type: defopt
#: original_texis/searching.texi:2947
msgid ""
"This is the regular expression describing line-beginnings that separate "
"pages.  The default value is @code{\"^\\014\"} (i.e., @code{\"^^L\"} or "
"@code{\"^\\C-l\"}); this matches a line that starts with a formfeed "
"character."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:2957
msgid ""
"The following two regular expressions should @emph{not} assume the match "
"always starts at the beginning of a line; they should not use @samp{^} to "
"anchor the match.  Most often, the paragraph commands do check for a match "
"only at the beginning of a line, which means that @samp{^} would be "
"superfluous.  When there is a nonzero left margin, they accept matches that "
"start after the left margin.  In that case, a @samp{^} would be incorrect.  "
"However, a @samp{^} is harmless in modes where a left margin is never used."
msgstr ""

#. type: defopt
#: original_texis/searching.texi:2958
#, no-wrap
msgid "paragraph-separate"
msgstr ""

#. type: defopt
#: original_texis/searching.texi:2964
msgid ""
"This is the regular expression for recognizing the beginning of a line that "
"separates paragraphs.  (If you change this, you may have to change "
"@code{paragraph-start} also.)  The default value is @w{@code{\"[@ "
"\\t\\f]*$\"}}, which matches a line that consists entirely of spaces, tabs, "
"and form feeds (after its left margin)."
msgstr ""

#. type: defopt
#: original_texis/searching.texi:2966
#, no-wrap
msgid "paragraph-start"
msgstr ""

#. type: defopt
#: original_texis/searching.texi:2971
msgid ""
"This is the regular expression for recognizing the beginning of a line that "
"starts @emph{or} separates paragraphs.  The default value is "
"@w{@code{\"\\f\\\\|[ \\t]*$\"}}, which matches a line containing only "
"whitespace or starting with a form feed (after its left margin)."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2973 original_texis/searching.texi:2984
#, no-wrap
msgid "sentence-end"
msgstr ""

#. type: defopt
#: original_texis/searching.texi:2977
msgid ""
"If non-@code{nil}, the value should be a regular expression describing the "
"end of a sentence, including the whitespace following the sentence.  (All "
"paragraph boundaries also end sentences, regardless.)"
msgstr ""

#. type: defopt
#: original_texis/searching.texi:2982
msgid ""
"If the value is @code{nil}, as it is by default, then the function "
"@code{sentence-end} constructs the regexp.  That is why you should always "
"call the function @code{sentence-end} to obtain the regexp to be used to "
"recognize the end of a sentence."
msgstr ""

#. type: defun
#: original_texis/searching.texi:2991
msgid ""
"This function returns the value of the variable @code{sentence-end}, if "
"non-@code{nil}.  Otherwise it returns a default value based on the values of "
"the variables @code{sentence-end-double-space} (@pxref{Definition of "
"sentence-end-double-space}), @code{sentence-end-without-period}, and "
"@code{sentence-end-without-space}."
msgstr ""

#. type: section
#: original_texis/searching.texi:2994
#, no-wrap
msgid "Emacs versus POSIX Regular Expressions"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:2995
#, no-wrap
msgid "POSIX regular expressions"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:3004
msgid ""
"Regular expression syntax varies significantly among computer programs.  "
"When writing Elisp code that generates regular expressions for use by other "
"programs, it is helpful to know how syntax variants differ.  To give a feel "
"for the variation, this section discusses how Emacs regular expressions "
"differ from two syntax variants standarded by POSIX: basic regular "
"expressions (BREs) and extended regular expressions (EREs).  Plain "
"@command{grep} uses BREs, and @samp{grep -E} uses EREs."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:3008
msgid ""
"Emacs regular expressions have a syntax closer to EREs than to BREs, with "
"some extensions.  Here is a summary of how POSIX BREs and EREs differ from "
"Emacs regular expressions."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:3020
msgid ""
"In POSIX BREs @samp{+} and @samp{?} are not special.  The only backslash "
"escape sequences are @samp{\\(@dots{}\\)}, @samp{\\@{@dots{}\\@}}, "
"@samp{\\1} through @samp{\\9}, along with the escaped special characters "
"@samp{\\$}, @samp{\\*}, @samp{\\.}, @samp{\\[}, @samp{\\\\}, and "
"@samp{\\^}.  Therefore @samp{\\(?:} acts like @samp{\\([?]:}.  POSIX does "
"not define how other BRE escapes behave; for example, GNU @command{grep} "
"treats @samp{\\|} like Emacs does, but does not support all the Emacs "
"escapes."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:3029
msgid ""
"In POSIX BREs, it is an implementation option whether @samp{^} is special "
"after @samp{\\(}; GNU @command{grep} treats it like Emacs does.  In POSIX "
"EREs, @samp{^} is always special outside of bracket expressions, which means "
"the ERE @samp{x^} never matches.  In Emacs regular expressions, @samp{^} is "
"special only at the beginning of the regular expression, or after "
"@samp{\\(}, @samp{\\(?:} or @samp{\\|}."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:3038
msgid ""
"In POSIX BREs, it is an implementation option whether @samp{$} is special "
"before @samp{\\)}; GNU @command{grep} treats it like Emacs does.  In POSIX "
"EREs, @samp{$} is always special outside of bracket expressions "
"(@pxref{Regexp Special, bracket expressions}), which means the ERE @samp{$x} "
"never matches.  In Emacs regular expressions, @samp{$} is special only at "
"the end of the regular expression, or before @samp{\\)} or @samp{\\|}."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:3050
msgid ""
"In POSIX EREs @samp{@{}, @samp{(} and @samp{|} are special, and @samp{)} is "
"special when matched with a preceding @samp{(}.  These special characters do "
"not use preceding backslashes; @samp{(?} produces undefined results.  The "
"only backslash escape sequences are the escaped special characters "
"@samp{\\$}, @samp{\\(}, @samp{\\)}, @samp{\\*}, @samp{\\+}, @samp{\\.}, "
"@samp{\\?}, @samp{\\[}, @samp{\\\\}, @samp{\\^}, @samp{\\@{} and "
"@samp{\\|}.  POSIX does not define how other ERE escapes behave; for "
"example, GNU @samp{grep -E} treats @samp{\\1} like Emacs does, but does not "
"support all the Emacs escapes."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:3057
msgid ""
"In POSIX BREs and EREs, undefined results are produced by repetition "
"operators at the start of a regular expression or subexpression (possibly "
"preceded by @samp{^}), except that the repetition operator @samp{*} has the "
"same behavior in BREs as in Emacs.  In Emacs, these operators are treated as "
"ordinary."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:3062
msgid ""
"In BREs and EREs, undefined results are produced by two repetition operators "
"in sequence.  In Emacs, these have well-defined behavior, e.g., @samp{a**} "
"is equivalent to @samp{a*}."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:3067
msgid ""
"In BREs and EREs, undefined results are produced by empty regular "
"expressions or subexpressions.  In Emacs these have well-defined behavior, "
"e.g., @samp{\\(\\)*} matches the empty string,"
msgstr ""

#. type: itemize
#: original_texis/searching.texi:3072
msgid ""
"In BREs and EREs, undefined results are produced for the named character "
"classes @samp{[:ascii:]}, @samp{[:multibyte:]}, @samp{[:nonascii:]}, "
"@samp{[:unibyte:]}, and @samp{[:word:]}."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:3077
msgid ""
"BREs and EREs can contain collating symbols and equivalence class "
"expressions within bracket expressions, e.g., @samp{[[.ch.]d[=a=]]}.  Emacs "
"regular expressions do not support this."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:3081
msgid ""
"BREs, EREs, and the strings they match cannot contain encoding errors or NUL "
"bytes.  In Emacs these constructs simply match themselves."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:3086
msgid ""
"BRE and ERE searching always finds the longest match.  Emacs searching by "
"default does not necessarily do so.  @xref{Longest Match}."
msgstr ""
