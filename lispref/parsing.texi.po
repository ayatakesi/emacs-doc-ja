# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-03-31 15:38+0900\n"
"PO-Revision-Date: 2023-03-31 15:59+0900\n"
"Last-Translator: ayatakesi <ayamokoji.takesi@gmail.com>\n"
"Language-Team: ja <https://emacs-jp.slack.com/>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: original_texis/parsing.texi:5 original_texis/parsing.texi:6
#, no-wrap
msgid "Parsing Program Source"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:8
#, no-wrap
msgid "syntax tree, from parsing program source"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:15
msgid "Emacs provides various ways to parse program source text and produce a @dfn{syntax tree}.  In a syntax tree, text is no longer considered a one-dimensional stream of characters, but a structured tree of nodes, where each node representing a piece of text.  Thus, a syntax tree can enable interesting features like precise fontification, indentation, navigation, structured editing, etc."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:19
msgid "Emacs has a simple facility for parsing balanced expressions (@pxref{Parsing Expressions}).  There is also the SMIE library for generic navigation and indentation (@pxref{SMIE})."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:25
msgid "In addition to those, Emacs also provides integration with @uref{https://tree-sitter.github.io/tree-sitter, the tree-sitter library}) if support for it was compiled in.  The tree-sitter library implements an incremental parser and has support from a wide range of programming languages."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:26
#, no-wrap
msgid "treesit-available-p"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:29
msgid "This function returns non-@code{nil} if tree-sitter features are available for the current Emacs session."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:40
msgid "To be able to parse the program source using the tree-sitter library and access the syntax tree of the program, a Lisp program needs to load a language definition library, and create a parser for that language and the current buffer.  After that, the Lisp program can query the parser about specific nodes of the syntax tree.  Then, it can access various kinds of information about each node, and search for nodes using a powerful pattern-matching syntax.  This chapter explains how to do all this, and also how a Lisp program can work with source files that mix multiple programming languages."
msgstr ""

#. type: node
#: original_texis/parsing.texi:50 original_texis/parsing.texi:52
#, no-wrap
msgid "Language Definitions"
msgstr ""

#. type: menuentry
#: original_texis/parsing.texi:50
msgid "Loading tree-sitter language definitions."
msgstr ""

#. type: node
#: original_texis/parsing.texi:50 original_texis/parsing.texi:381
#, no-wrap
msgid "Using Parser"
msgstr ""

#. type: menuentry
#: original_texis/parsing.texi:50
msgid "Introduction to parsers."
msgstr ""

#. type: section
#: original_texis/parsing.texi:50 original_texis/parsing.texi:524
#: original_texis/parsing.texi:525
#, no-wrap
msgid "Retrieving Nodes"
msgstr ""

#. type: menuentry
#: original_texis/parsing.texi:50
msgid "Retrieving nodes from a syntax tree."
msgstr ""

#. type: section
#: original_texis/parsing.texi:50 original_texis/parsing.texi:867
#: original_texis/parsing.texi:868
#, no-wrap
msgid "Accessing Node Information"
msgstr ""

#. type: menuentry
#: original_texis/parsing.texi:50
msgid "Accessing node information."
msgstr ""

#. type: node
#: original_texis/parsing.texi:50 original_texis/parsing.texi:995
#, no-wrap
msgid "Pattern Matching"
msgstr ""

#. type: menuentry
#: original_texis/parsing.texi:50
msgid "Pattern matching with query patterns."
msgstr ""

#. type: node
#: original_texis/parsing.texi:50 original_texis/parsing.texi:1393
#, no-wrap
msgid "Multiple Languages"
msgstr ""

#. type: menuentry
#: original_texis/parsing.texi:50
msgid "Parse text written in multiple languages."
msgstr ""

#. type: node
#: original_texis/parsing.texi:50 original_texis/parsing.texi:1656
#, no-wrap
msgid "Tree-sitter major modes"
msgstr ""

#. type: menuentry
#: original_texis/parsing.texi:50
msgid "Develop major modes using tree-sitter."
msgstr ""

#. type: node
#: original_texis/parsing.texi:50 original_texis/parsing.texi:1744
#, no-wrap
msgid "Tree-sitter C API"
msgstr ""

#. type: menuentry
#: original_texis/parsing.texi:50
msgid "Compare the C API and the ELisp API."
msgstr ""

#. type: section
#: original_texis/parsing.texi:53
#, no-wrap
msgid "Tree-sitter Language Definitions"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:54
#, no-wrap
msgid "language definitions, for tree-sitter"
msgstr ""

#. type: heading
#: original_texis/parsing.texi:56
#, no-wrap
msgid "Loading a language definition"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:57
#, no-wrap
msgid "loading language definition for tree-sitter"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:59
#, no-wrap
msgid "language argument, for tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:65
msgid "Tree-sitter relies on language definitions to parse text in that language.  In Emacs, a language definition is represented by a symbol.  For example, the C language definition is represented as the symbol @code{c}, and @code{c} can be passed to tree-sitter functions as the @var{language} argument."
msgstr ""

#. type: vindex
#: original_texis/parsing.texi:66
#, no-wrap
msgid "treesit-extra-load-path"
msgstr ""

#. type: vindex
#: original_texis/parsing.texi:67
#, no-wrap
msgid "treesit-load-language-error"
msgstr ""

#. type: vindex
#: original_texis/parsing.texi:68
#, no-wrap
msgid "treesit-load-suffixes"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:73
msgid "Tree-sitter language definitions are distributed as dynamic libraries.  In order to use a language definition in Emacs, you need to make sure that the dynamic library is installed on the system.  Emacs looks for language definitions in several places, in the following order:"
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:78
msgid "first, in the list of directories specified by the variable @code{treesit-extra-load-path};"
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:81
msgid "then, in the @file{tree-sitter} subdirectory of the directory specified by @code{user-emacs-directory} (@pxref{Init File});"
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:83
msgid "and finally, in the system's default locations for dynamic libraries."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:87
msgid "In each of these directories, Emacs looks for a file with file-name extensions specified by the variable @code{treesit-load-suffixes}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:91
msgid "If Emacs cannot find the library or has problems loading it, Emacs signals the @code{treesit-load-language-error} error.  The data of that signal could be one of the following:"
msgstr ""

#. type: item
#: original_texis/parsing.texi:93
#, no-wrap
msgid "(not-found @var{error-msg} @dots{})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:95
msgid "This means that Emacs could not find the language definition library."
msgstr ""

#. type: item
#: original_texis/parsing.texi:95
#, no-wrap
msgid "(symbol-error @var{error-msg})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:98
msgid "This means that Emacs could not find in the library the expected function that every language definition library should export."
msgstr ""

#. type: item
#: original_texis/parsing.texi:98
#, no-wrap
msgid "(version-mismatch @var{error-msg})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:101
msgid "This means that the version of language definition library is incompatible with that of the tree-sitter library."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:106
msgid "In all of these cases, @var{error-msg} might provide additional details about the failure."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:107
#, no-wrap
msgid "treesit-language-available-p language &optional detail"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:110
msgid "This function returns non-@code{nil} if the language definitions for @var{language} exist and can be loaded."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:115
msgid "If @var{detail} is non-@code{nil}, return @code{(t . nil)} when @var{language} is available, and @code{(nil . @var{data})} when it's unavailable.  @var{data} is the signal data of @code{treesit-load-language-error}."
msgstr ""

#. type: vindex
#: original_texis/parsing.texi:117
#, no-wrap
msgid "treesit-load-name-override-list"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:124
msgid "By convention, the file name of the dynamic library for @var{language} is @file{libtree-sitter-@var{language}.@var{ext}}, where @var{ext} is the system-specific extension for dynamic libraries.  Also by convention, the function provided by that library is named @code{tree_sitter_@var{language}}.  If a language definition library doesn't follow this convention, you should add an entry"
msgstr ""

#. type: example
#: original_texis/parsing.texi:127
#, no-wrap
msgid "(@var{language} @var{library-base-name} @var{function-name})\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:134
msgid "to the list in the variable @code{treesit-load-name-override-list}, where @var{library-base-name} is the basename of the dynamic library's file name, (usually, @file{libtree-sitter-@var{language}}), and @var{function-name} is the function provided by the library (usually, @code{tree_sitter_@var{language}}).  For example,"
msgstr ""

#. type: example
#: original_texis/parsing.texi:137
#, no-wrap
msgid "(cool-lang \"libtree-sitter-coool\" \"tree_sitter_cooool\")\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:142
msgid "for a language that considers itself too ``cool'' to abide by conventions."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:143
#, no-wrap
msgid "language-definition version, compatibility"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:144
#, no-wrap
msgid "treesit-language-version &optional min-compatible"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:154
msgid "This function returns the version of the language-definition Application Binary Interface (@acronym{ABI}) supported by the tree-sitter library.  By default, it returns the latest ABI version supported by the library, but if @var{min-compatible} is non-@code{nil}, it returns the oldest ABI version which the library still can support.  Language definition libraries must be built for ABI versions between the oldest and the latest versions supported by the tree-sitter library, otherwise the library will be unable to load them."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:156
#, no-wrap
msgid "Concrete syntax tree"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:157
#, no-wrap
msgid "syntax tree, concrete"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:162
msgid "A syntax tree is what a parser generates.  In a syntax tree, each node represents a piece of text, and is connected to each other by a parent-child relationship.  For example, if the source text is"
msgstr ""

#. type: example
#: original_texis/parsing.texi:165
#, no-wrap
msgid "1 + 2\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:169
msgid "its syntax tree could be"
msgstr ""

#. type: group
#: original_texis/parsing.texi:183
#, no-wrap
msgid ""
"                  +--------------+\n"
"                  | root \"1 + 2\" |\n"
"                  +--------------+\n"
"                         |\n"
"        +--------------------------------+\n"
"        |       expression \"1 + 2\"       |\n"
"        +--------------------------------+\n"
"           |             |            |\n"
"+------------+   +--------------+   +------------+\n"
"| number \"1\" |   | operator \"+\" |   | number \"2\" |\n"
"+------------+   +--------------+   +------------+\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:187
msgid "We can also represent it as an s-expression:"
msgstr ""

#. type: example
#: original_texis/parsing.texi:190
#, no-wrap
msgid "(root (expression (number) (operator) (number)))\n"
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:192
#, no-wrap
msgid "Node types"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:193
#, no-wrap
msgid "node types, in a syntax tree"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:195
#, no-wrap
msgid "type of node, tree-sitter"
msgstr ""

#. type: anchor{#1}
#: original_texis/parsing.texi:197
msgid "tree-sitter node type"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:197
#, no-wrap
msgid "named node, tree-sitter"
msgstr ""

#. type: anchor{#1}
#: original_texis/parsing.texi:199
msgid "tree-sitter named node"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:199
#, no-wrap
msgid "anonymous node, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:207
msgid "Names like @code{root}, @code{expression}, @code{number}, and @code{operator} specify the @dfn{type} of the nodes.  However, not all nodes in a syntax tree have a type.  Nodes that don't have a type are known as @dfn{anonymous nodes}, and nodes with a type are @dfn{named nodes}.  Anonymous nodes are tokens with fixed spellings, including punctuation characters like bracket @samp{]}, and keywords like @code{return}."
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:208
#, no-wrap
msgid "Field names"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:210
#, no-wrap
msgid "field name, tree-sitter"
msgstr ""

#. type: anchor{#1}
#: original_texis/parsing.texi:211 original_texis/parsing.texi:217
#, no-wrap
msgid "tree-sitter node field name"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:217
msgid "To make the syntax tree easier to analyze, many language definitions assign @dfn{field names} to child nodes.  For example, a @code{function_definition} node could have a @code{declarator} and a @code{body}:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:223
#, no-wrap
msgid ""
"(function_definition\n"
" declarator: (declaration)\n"
" body: (compound_statement))\n"
msgstr ""

#. type: heading
#: original_texis/parsing.texi:226
#, no-wrap
msgid "Exploring the syntax tree"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:227
#, no-wrap
msgid "explore tree-sitter syntax tree"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:228
#, no-wrap
msgid "inspection of tree-sitter parse tree nodes"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:235
msgid "To aid in understanding the syntax of a language and in debugging of Lisp program that use the syntax tree, Emacs provides an ``explore'' mode, which displays the syntax tree of the source in the current buffer in real time.  Emacs also comes with an ``inspect mode'', which displays information of the nodes at point in the mode-line."
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:236
#, no-wrap
msgid "Command treesit-explore-mode"
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:242
msgid "This mode pops up a window displaying the syntax tree of the source in the current buffer.  Selecting text in the source buffer highlights the corresponding nodes in the syntax tree display.  Clicking on nodes in the syntax tree highlights the corresponding text in the source buffer."
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:244
#, no-wrap
msgid "Command treesit-inspect-mode"
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:247
msgid "This minor mode displays on the mode-line the node that @emph{starts} at point.  For example, the mode-line can display"
msgstr ""

#. type: example
#: original_texis/parsing.texi:250
#, no-wrap
msgid "@var{parent} @var{field}: (@var{node} (@var{child} (@dots{})))\n"
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:257
msgid "where @var{node}, @var{child}, etc., are nodes which begin at point.  @var{parent} is the parent of @var{node}.  @var{node} is displayed in a bold typeface.  @var{field-name}s are field names of @var{node} and of @var{child}, etc."
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:261
msgid "If no node starts at point, i.e., point is in the middle of a node, then the mode line displays the earliest node that spans point, and its immediate parent."
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:264
msgid "This minor mode doesn't create parsers on its own.  It uses the first parser in @code{(treesit-parser-list)} (@pxref{Using Parser})."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:266
#, no-wrap
msgid "Reading the grammar definition"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:267
#, no-wrap
msgid "reading grammar definition, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:273
msgid "Authors of language definitions define the @dfn{grammar} of a programming language, which determines how a parser constructs a concrete syntax tree out of the program text.  In order to use the syntax tree effectively, you need to consult the @dfn{grammar file}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:279
msgid "The grammar file is usually @file{grammar.js} in a language definition's project repository.  The link to a language definition's home page can be found on @uref{https://tree-sitter.github.io/tree-sitter, tree-sitter's homepage}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:282
msgid "The grammar definition is written in JavaScript.  For example, the rule matching a @code{function_definition} node looks like"
msgstr ""

#. type: group
#: original_texis/parsing.texi:290
#, no-wrap
msgid ""
"function_definition: $ => seq(\n"
"  $.declaration_specifiers,\n"
"  field('declarator', $.declaration),\n"
"  field('body', $.compound_statement)\n"
")\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:300
msgid "The rules are represented by functions that take a single argument @var{$}, representing the whole grammar.  The function itself is constructed by other functions: the @code{seq} function puts together a sequence of children; the @code{field} function annotates a child with a field name.  If we write the above definition in the so-called @dfn{Backus-Naur Form} (@acronym{BNF}) syntax, it would look like"
msgstr ""

#. type: group
#: original_texis/parsing.texi:305
#, no-wrap
msgid ""
"function_definition :=\n"
"  <declaration_specifiers> <declaration> <compound_statement>\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:310
msgid "and the node returned by the parser would look like"
msgstr ""

#. type: group
#: original_texis/parsing.texi:317
#, no-wrap
msgid ""
"(function_definition\n"
"  (declaration_specifier)\n"
"  declarator: (declaration)\n"
"  body: (compound_statement))\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:322
msgid "Below is a list of functions that one can see in a grammar definition.  Each function takes other rules as arguments and returns a new rule."
msgstr ""

#. type: item
#: original_texis/parsing.texi:324
#, no-wrap
msgid "seq(@var{rule1}, @var{rule2}, @dots{})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:326
msgid "matches each rule one after another."
msgstr ""

#. type: item
#: original_texis/parsing.texi:326
#, no-wrap
msgid "choice(@var{rule1}, @var{rule2}, @dots{})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:328
msgid "matches one of the rules in its arguments."
msgstr ""

#. type: item
#: original_texis/parsing.texi:328
#, no-wrap
msgid "repeat(@var{rule})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:331
msgid "matches @var{rule} for @emph{zero or more} times.  This is like the @samp{*} operator in regular expressions."
msgstr ""

#. type: item
#: original_texis/parsing.texi:331
#, no-wrap
msgid "repeat1(@var{rule})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:334
msgid "matches @var{rule} for @emph{one or more} times.  This is like the @samp{+} operator in regular expressions."
msgstr ""

#. type: item
#: original_texis/parsing.texi:334
#, no-wrap
msgid "optional(@var{rule})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:337
msgid "matches @var{rule} for @emph{zero or one} time.  This is like the @samp{?} operator in regular expressions."
msgstr ""

#. type: item
#: original_texis/parsing.texi:337
#, no-wrap
msgid "field(@var{name}, @var{rule})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:339
msgid "assigns field name @var{name} to the child node matched by @var{rule}."
msgstr ""

#. type: item
#: original_texis/parsing.texi:339
#, no-wrap
msgid "alias(@var{rule}, @var{alias})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:342
msgid "makes nodes matched by @var{rule} appear as @var{alias} in the syntax tree generated by the parser.  For example,"
msgstr ""

#. type: example
#: original_texis/parsing.texi:345
#, no-wrap
msgid "alias(preprocessor_call_exp, call_expression)\n"
msgstr ""

#. type: table
#: original_texis/parsing.texi:350
msgid "makes any node matched by @code{preprocessor_call_exp} appear as @code{call_expression}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:354
msgid "Below are grammar functions of lesser importance for reading a language definition."
msgstr ""

#. type: item
#: original_texis/parsing.texi:356
#, no-wrap
msgid "token(@var{rule})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:361
msgid "marks @var{rule} to produce a single leaf node.  That is, instead of generating a parent node with individual child nodes under it, everything is combined into a single leaf node.  @xref{Retrieving Nodes}."
msgstr ""

#. type: item
#: original_texis/parsing.texi:361
#, no-wrap
msgid "token.immediate(@var{rule})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:365
msgid "Normally, grammar rules ignore preceding whitespace; this changes @var{rule} to match only when there is no preceding whitespaces."
msgstr ""

#. type: item
#: original_texis/parsing.texi:365
#, no-wrap
msgid "prec(@var{n}, @var{rule})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:367
msgid "gives @var{rule} the level-@var{n} precedence."
msgstr ""

#. type: item
#: original_texis/parsing.texi:367
#, no-wrap
msgid "prec.left([@var{n},] @var{rule})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:369
msgid "marks @var{rule} as left-associative, optionally with level @var{n}."
msgstr ""

#. type: item
#: original_texis/parsing.texi:369
#, no-wrap
msgid "prec.right([@var{n},] @var{rule})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:371
msgid "marks @var{rule} as right-associative, optionally with level @var{n}."
msgstr ""

#. type: item
#: original_texis/parsing.texi:371
#, no-wrap
msgid "prec.dynamic(@var{n}, @var{rule})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:374
msgid "this is like @code{prec}, but the precedence is applied at runtime instead."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:380
msgid "The documentation of the tree-sitter project has @uref{https://tree-sitter.github.io/tree-sitter/creating-parsers, more about writing a grammar}.  Read especially ``The Grammar DSL'' section."
msgstr ""

#. type: section
#: original_texis/parsing.texi:382
#, no-wrap
msgid "Using Tree-sitter Parser"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:383
#, no-wrap
msgid "tree-sitter parser, using"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:389
msgid "This section describes how to create and configure a tree-sitter parser.  In Emacs, each tree-sitter parser is associated with a buffer.  As the user edits the buffer, the associated parser and syntax tree are automatically kept up-to-date."
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:390
#, no-wrap
msgid "treesit-max-buffer-size"
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:394
msgid "This variable contains the maximum size of buffers in which tree-sitter can be activated.  Major modes should check this value when deciding whether to enable tree-sitter features."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:396
#, no-wrap
msgid "treesit-can-enable-p"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:400
msgid "This function checks whether the current buffer is suitable for activating tree-sitter features.  It basically checks @code{treesit-available-p} and @code{treesit-max-buffer-size}."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:402
#, no-wrap
msgid "creating tree-sitter parsers"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:403
#, no-wrap
msgid "tree-sitter parser, creating"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:404
#, no-wrap
msgid "treesit-parser-create language &optional buffer no-reuse"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:408
msgid "Create a parser for the specified @var{buffer} and @var{language} (@pxref{Language Definitions}).  If @var{buffer} is omitted or @code{nil}, it stands for the current buffer."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:412
msgid "By default, this function reuses a parser if one already exists for @var{language} in @var{buffer}, but if @var{no-reuse} is non-@code{nil}, this function always creates a new parser."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:415
msgid "Given a parser, we can query information about it."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:416
#, no-wrap
msgid "treesit-parser-buffer parser"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:418
msgid "This function returns the buffer associated with @var{parser}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:420
#, no-wrap
msgid "treesit-parser-language parser"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:422
msgid "This function returns the language used by @var{parser}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:424
#, no-wrap
msgid "treesit-parser-p object"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:427
msgid "This function checks if @var{object} is a tree-sitter parser, and returns non-@code{nil} if it is, and @code{nil} otherwise."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:435
msgid "There is no need to explicitly parse a buffer, because parsing is done automatically and lazily.  A parser only parses when a Lisp program queries for a node in its syntax tree.  Therefore, when a parser is first created, it doesn't parse the buffer; it waits until the Lisp program queries for a node for the first time.  Similarly, when some change is made in the buffer, a parser doesn't re-parse immediately."
msgstr ""

#. type: vindex
#: original_texis/parsing.texi:436
#, no-wrap
msgid "treesit-buffer-too-large"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:441
msgid "When a parser does parse, it checks for the size of the buffer.  Tree-sitter can only handle buffer no larger than about 4GB.  If the size exceeds that, Emacs signals the @code{treesit-buffer-too-large} error with signal data being the buffer size."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:446
msgid "Once a parser is created, Emacs automatically adds it to the internal parser list.  Every time a change is made to the buffer, Emacs updates parsers in this list so they can update their syntax tree incrementally."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:447
#, no-wrap
msgid "treesit-parser-list &optional buffer"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:451
msgid "This function returns the parser list of @var{buffer}.  If @var{buffer} is @code{nil} or omitted, it defaults to the current buffer."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:453
#, no-wrap
msgid "treesit-parser-delete parser"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:455
msgid "This function deletes @var{parser}."
msgstr ""

#. type: anchor{#1}
#: original_texis/parsing.texi:457 original_texis/parsing.texi:467
#, no-wrap
msgid "tree-sitter narrowing"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:467
msgid "Normally, a parser ``sees'' the whole buffer, but when the buffer is narrowed (@pxref{Narrowing}), the parser will only see the accessible portion of the buffer.  As far as the parser can tell, the hidden region was deleted.  When the buffer is later widened, the parser thinks text is inserted at the beginning and at the end.  Although parsers respect narrowing, modes should not use narrowing as a means to handle a multi-language buffer; instead, set the ranges in which the parser should operate.  @xref{Multiple Languages}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:472
msgid "Because a parser parses lazily, when the user or a Lisp program narrows the buffer, the parser is not affected immediately; as long as the mode doesn't query for a node while the buffer is narrowed, the parser is oblivious of the narrowing."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:473
#, no-wrap
msgid "tree-sitter parse string"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:474
#, no-wrap
msgid "parse string, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:478
msgid "Besides creating a parser for a buffer, a Lisp program can also parse a string.  Unlike a buffer, parsing a string is a one-off operation, and there is no way to update the result."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:479
#, no-wrap
msgid "treesit-parse-string string language"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:482
msgid "This function parses @var{string} using @var{language}, and returns the root node of the generated syntax tree."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:484
#, no-wrap
msgid "Be notified by changes to the parse tree"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:485
#, no-wrap
msgid "update callback, for tree-sitter parse-tree"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:486
#, no-wrap
msgid "after-change notifier, for tree-sitter parse-tree"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:487
#, no-wrap
msgid "tree-sitter parse-tree, update and after-change callback"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:488
#, no-wrap
msgid "notifiers, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:495
msgid "A Lisp program might want to be notified of text affected by incremental parsing.  For example, inserting a comment-closing token converts text before that token into a comment.  Even though the text is not directly edited, it is deemed to be ``changed'' nevertheless."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:503
msgid "Emacs lets a Lisp program to register callback functions (a.k.a.@: @dfn{notifiers}) for this kind of changes.  A notifier function takes two arguments: @var{ranges} and @var{parser}.  @var{ranges} is a list of cons cells of the form @w{@code{(@var{start} . @var{end})}}, where @var{start} and @var{end} mark the start and the end positions of a range.  @var{parser} is the parser issuing the notification."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:507
msgid "Every time a parser reparses a buffer, it compares the old and new parse-tree, computes the ranges in which nodes have changed, and passes the ranges to notifier functions."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:508
#, no-wrap
msgid "treesit-parser-add-notifier parser function"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:512
msgid "This function adds @var{function} to @var{parser}'s list of after-change notifier functions.  @var{function} must be a function symbol, not a lambda function (@pxref{Anonymous Functions})."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:514
#, no-wrap
msgid "treesit-parser-remove-notifier parser function"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:518
msgid "This function removes @var{function} from the list of @var{parser}'s after-change notifier functions.  @var{function} must be a function symbol, rather than a lambda function."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:520
#, no-wrap
msgid "treesit-parser-notifiers parser"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:522
msgid "This function returns the list of @var{parser}'s notifier functions."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:526
#, no-wrap
msgid "retrieve node, tree-sitter"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:527
#, no-wrap
msgid "tree-sitter, find node"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:528
#, no-wrap
msgid "get node, tree-sitter"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:530
#, no-wrap
msgid "terminology, for tree-sitter functions"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:533
msgid "Here's some terminology and conventions we use when documenting tree-sitter functions."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:539
msgid "We talk about a node being ``smaller'' or ``larger'', and ``lower'' or ``higher''.  A smaller and lower node is lower in the syntax tree and therefore spans a smaller portion of buffer text; a larger and higher node is higher up in the syntax tree, it contains many smaller nodes as its children, and therefore spans a larger portion of text."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:544
msgid "When a function cannot find a node, it returns @code{nil}.  For convenience, all functions that take a node as argument and return a node, also accept the node argument of @code{nil} and in that case just return @code{nil}."
msgstr ""

#. type: vindex
#: original_texis/parsing.texi:545
#, no-wrap
msgid "treesit-node-outdated"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:549
msgid "Nodes are not automatically updated when the associated buffer is modified, and there is no way to update a node once it is retrieved.  Using an outdated node signals the @code{treesit-node-outdated} error."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:550
#, no-wrap
msgid "Retrieving nodes from syntax tree"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:551
#, no-wrap
msgid "retrieving tree-sitter nodes"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:552
#, no-wrap
msgid "syntax tree, retrieving nodes"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:554
#, no-wrap
msgid "leaf node, of tree-sitter parse tree"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:555
#, no-wrap
msgid "tree-sitter parse tree, leaf node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:556
#, no-wrap
msgid "treesit-node-at pos &optional parser-or-lang named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:559
msgid "This function returns a @dfn{leaf} node at buffer position @var{pos}.  A leaf node is a node that doesn't have any child nodes."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:563
msgid "This function tries to return a node whose span covers @var{pos}: the node's beginning position is less or equal to @var{pos}, and the node's end position is greater or equal to @var{pos}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:567
msgid "If no leaf node's span covers @var{pos} (e.g., @var{pos} is in the whitespace between two leaf nodes), this function returns the first leaf node after @var{pos}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:570
msgid "Finally, if there is no leaf node after @var{pos}, return the first leaf node before @var{pos}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:577
msgid "When @var{parser-or-lang} is @code{nil} or omitted, this function uses the first parser in @code{(treesit-parser-list)} of the current buffer.  If @var{parser-or-lang} is a parser object, it uses that parser; if @var{parser-or-lang} is a language, it finds the first parser using that language in @code{(treesit-parser-list)}, and uses that."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:580
msgid "If this function cannot find a suitable node to return, it returns @code{nil}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:583
msgid "If @var{named} is non-@code{nil}, this function looks only for named nodes (@pxref{tree-sitter named node, named node})."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:585 original_texis/parsing.texi:1448
msgid "Example:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:591
#, no-wrap
msgid ""
";; Find the node at point in a C parser's syntax tree.\n"
"(treesit-node-at (point) 'c)\n"
"  @result{} #<treesit-node (primitive_type) in 23-27>\n"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:595
#, no-wrap
msgid "treesit-node-on beg end &optional parser-or-lang named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:600
msgid "This function returns the @emph{smallest} node that covers the region of buffer text between @var{beg} and @var{end}.  In other words, the start of the node is before or at @var{beg}, and the end of the node is at or after @var{end}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:606
msgid "@emph{Beware:} calling this function on an empty line that is not inside any top-level construct (function definition, etc.) most probably will give you the root node, because the root node is the smallest node that covers that empty line.  Most of the time, you want to use @code{treesit-node-at}, described above, instead."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:612
msgid "When @var{parser-or-lang} is @code{nil}, this function uses the first parser in @code{(treesit-parser-list)} of the current buffer.  If @var{parser-or-lang} is a parser object, it uses that parser; if @var{parser-or-lang} is a language, it finds the first parser using that language in @code{(treesit-parser-list)}, and uses that."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:615
msgid "If @var{named} is non-@code{nil}, this function looks for a named node only (@pxref{tree-sitter named node, named node})."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:617
#, no-wrap
msgid "treesit-parser-root-node parser"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:620
msgid "This function returns the root node of the syntax tree generated by @var{parser}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:622
#, no-wrap
msgid "treesit-buffer-root-node &optional language"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:627
msgid "This function finds the first parser that uses @var{language} in @code{(treesit-parser-list)} of the current buffer, and returns the root node generated by that parser.  If it cannot find an appropriate parser, it returns @code{nil}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:631
msgid "Given a node, a Lisp program can retrieve other nodes starting from it, or query for information about this node."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:632
#, no-wrap
msgid "Retrieving nodes from other nodes"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:633
#, no-wrap
msgid "syntax tree nodes, retrieving from other nodes"
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:635
#, no-wrap
msgid "By kinship"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:636
#, no-wrap
msgid "kinship, syntax tree nodes"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:637
#, no-wrap
msgid "nodes, by kinship"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:638
#, no-wrap
msgid "syntax tree nodes, by kinship"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:640
#, no-wrap
msgid "treesit-node-parent node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:642
msgid "This function returns the immediate parent of @var{node}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:644
#, no-wrap
msgid "treesit-node-child node n &optional named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:648
msgid "This function returns the @var{n}'th child of @var{node}.  If @var{named} is non-@code{nil}, it counts only named nodes (@pxref{tree-sitter named node, named node})."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:654
msgid "For example, in a node that represents a string @code{\"text\"}, there are three children nodes: the opening quote @code{\"}, the string text @code{text}, and the closing quote @code{\"}.  Among these nodes, the first child is the opening quote @code{\"}, and the first named child is the string text."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:657
msgid "This function returns @code{nil} if there is no @var{n}'th child.  @var{n} could be negative, e.g., @code{-1} represents the last child."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:659
#, no-wrap
msgid "treesit-node-children node &optional named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:662
msgid "This function returns all of @var{node}'s children as a list.  If @var{named} is non-@code{nil}, it retrieves only named nodes."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:664
#, no-wrap
msgid "treesit-next-sibling node &optional named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:667
msgid "This function finds the next sibling of @var{node}.  If @var{named} is non-@code{nil}, it finds the next named sibling."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:669
#, no-wrap
msgid "treesit-prev-sibling node &optional named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:672
msgid "This function finds the previous sibling of @var{node}.  If @var{named} is non-@code{nil}, it finds the previous named sibling."
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:674
#, no-wrap
msgid "By field name"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:675
#, no-wrap
msgid "nodes, by field name"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:676
#, no-wrap
msgid "syntax tree nodes, by field name"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:682
msgid "To make the syntax tree easier to analyze, many language definitions assign @dfn{field names} to child nodes (@pxref{tree-sitter node field name, field name}).  For example, a @code{function_definition} node could have a @code{declarator} node and a @code{body} node."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:683
#, no-wrap
msgid "treesit-child-by-field-name node field-name"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:686
msgid "This function finds the child of @var{node} whose field name is @var{field-name}, a string."
msgstr ""

#. type: group
#: original_texis/parsing.texi:692
#, no-wrap
msgid ""
";; Get the child that has \"body\" as its field name.\n"
"(treesit-child-by-field-name node \"body\")\n"
"  @result{} #<treesit-node (compound_statement) in 45-89>\n"
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:696
#, no-wrap
msgid "By position"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:697
#, no-wrap
msgid "nodes, by position"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:698
#, no-wrap
msgid "syntax tree nodes, by position"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:700
#, no-wrap
msgid "treesit-first-child-for-pos node pos &optional named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:707
msgid "This function finds the first child of @var{node} that extends beyond buffer position @var{pos}.  ``Extends beyond'' means the end of the child node is greater or equal to @var{pos}.  This function only looks for immediate children of @var{node}, and doesn't look in its grandchildren.  If @var{named} is non-@code{nil}, it looks for the first named child (@pxref{tree-sitter named node, named node})."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:709
#, no-wrap
msgid "treesit-node-descendant-for-range node beg end &optional named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:714
msgid "This function finds the @emph{smallest} descendant node of @var{node} that spans the region of text between positions @var{beg} and @var{end}.  It is similar to @code{treesit-node-at}.  If @var{named} is non-@code{nil}, it looks for smallest named child."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:716
#, no-wrap
msgid "Searching for node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:718
#, no-wrap
msgid "treesit-search-subtree node predicate &optional backward all limit"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:725
msgid "This function traverses the subtree of @var{node} (including @var{node} itself), looking for a node for which @var{predicate} returns non-@code{nil}.  @var{predicate} is a regexp that is matched against each node's type, or a predicate function that takes a node and returns non-@code{nil} if the node matches.  The function returns the first node that matches, or @code{nil} if none does."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:733
msgid "By default, this function only traverses named nodes, but if @var{all} is non-@code{nil}, it traverses all the nodes.  If @var{backward} is non-@code{nil}, it traverses backwards (i.e., it visits the last child first when traversing down the tree).  If @var{limit} is non-@code{nil}, it must be a number that limits the tree traversal to that many levels down the tree.  If @var{limit} is @code{nil}, it defaults to 1000."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:735
#, no-wrap
msgid "treesit-search-forward start predicate &optional backward all"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:741
msgid "Like @code{treesit-search-subtree}, this function also traverses the parse tree and matches each node with @var{predicate} (except for @var{start}), where @var{predicate} can be a regexp or a function.  For a tree like the below where @var{start} is marked S, this function traverses as numbered from 1 to 12:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:753
#, no-wrap
msgid ""
"              12\n"
"              |\n"
"     S--------3----------11\n"
"     |        |          |\n"
"o--o-+--o  1--+--2    6--+-----10\n"
"|  |                  |        |\n"
"o  o                +-+-+   +--+--+\n"
"                    |   |   |  |  |\n"
"                    4   5   7  8  9\n"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:758
msgid "Note that this function doesn't traverse the subtree of @var{start}, and it always traverse leaf nodes first, then upwards."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:763
msgid "Like @code{treesit-search-subtree}, this function only searches for named nodes by default, but if @var{all} is non-@code{nil}, it searches for all nodes.  If @var{backward} is non-@code{nil}, it searches backwards."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:768
msgid "While @code{treesit-search-subtree} traverses the subtree of a node, this function starts with node @var{start} and traverses every node that comes after it in the buffer position order, i.e., nodes with start positions greater than the end position of @var{start}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:774
msgid "In the tree shown above, @code{treesit-search-subtree} traverses node S (@var{start}) and nodes marked with @code{o}, where this function traverses the nodes marked with numbers.  This function is useful for answering questions like ``what is the first node after @var{start} in the buffer that satisfies some condition?''"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:776
#, no-wrap
msgid "treesit-search-forward-goto node predicate &optional start backward all"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:780
msgid "This function moves point to the start or end of the next node after @var{node} in the buffer that matches @var{predicate}.  If @var{start} is non-@code{nil}, stop at the beginning rather than the end of a node."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:784
msgid "This function guarantees that the matched node it returns makes progress in terms of buffer position: the start/end position of the returned node is always greater than that of @var{node}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:787
msgid "Arguments @var{predicate}, @var{backward} and @var{all} are the same as in @code{treesit-search-forward}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:789
#, no-wrap
msgid "treesit-induce-sparse-tree root predicate &optional process-fn limit"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:791
msgid "This function creates a sparse tree from @var{root}'s subtree."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:797
msgid "It takes the subtree under @var{root}, and combs it so only the nodes that match @var{predicate} are left.  Like previous functions, the @var{predicate} can be a regexp string that matches against each node's type, or a function that takes a node and return non-@code{nil} if it matches."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:801
msgid "For example, for a subtree on the left that consist of both numbers and letters, if @var{predicate} is ``letter only'', the returned tree is the one on the right."
msgstr ""

#. type: group
#: original_texis/parsing.texi:815
#, no-wrap
msgid ""
"    a                 a              a\n"
"    |                 |              |\n"
"+---+---+         +---+---+      +---+---+\n"
"|   |   |         |   |   |      |   |   |\n"
"b   1   2         b   |   |      b   c   d\n"
"    |   |     =>      |   |  =>      |\n"
"    c   +--+          c   +          e\n"
"    |   |  |          |   |\n"
" +--+   d  4       +--+   d\n"
" |  |              |\n"
" e  5              e\n"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:823
msgid "If @var{process-fn} is non-@code{nil}, instead of returning the matched nodes, this function passes each node to @var{process-fn} and uses the returned value instead.  If non-@code{nil}, @var{limit} is the number of levels to go down from @var{root}.  If @var{limit} is @code{nil}, it defaults to 1000."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:829
msgid "Each node in the returned tree looks like @w{@code{(@var{tree-sitter-node} . (@var{child} @dots{}))}}.  The @var{tree-sitter-node} of the root of this tree will be nil if @var{root} doesn't match @var{predicate}.  If no node matches @var{predicate}, the function returns @code{nil}."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:831
#, no-wrap
msgid "More convenience functions"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:833
#, no-wrap
msgid "treesit-filter-child node predicate &optional named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:836
msgid "This function finds immediate children of @var{node} that satisfy @var{predicate}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:841
msgid "The @var{predicate} function takes a node as the argument and should return non-@code{nil} to indicate that the node should be kept.  If @var{named} is non-@code{nil}, this function only examines the named nodes."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:843
#, no-wrap
msgid "treesit-parent-until node predicate"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:848
msgid "This function repeatedly finds the parents of @var{node}, and returns the parent that satisfies @var{predicate}, a function that takes a node as the argument.  If no parent satisfies @var{predicate}, this function returns @code{nil}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:850
#, no-wrap
msgid "treesit-parent-while node predicate"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:855
msgid "This function repeatedly finds the parent of @var{node}, and keeps doing so as long as the nodes satisfy @var{predicate}, a function that takes a node as the argument.  That is, this function returns the farthest parent that still satisfies @var{predicate}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:857
#, no-wrap
msgid "treesit-node-top-level node &optional type"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:862
msgid "This function returns the highest parent of @var{node} that has the same type as @var{node}.  If no such parent exists, it returns @code{nil}.  Therefore this function is also useful for testing whether @var{node} is top-level."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:865
msgid "If @var{type} is non-@code{nil}, this function matches each parent's type with @var{type} as a regexp, rather than using @var{node}'s type."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:869
#, no-wrap
msgid "information of node, syntax trees"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:870
#, no-wrap
msgid "syntax trees, node information"
msgstr ""

#. type: heading
#: original_texis/parsing.texi:872
#, no-wrap
msgid "Basic information of Node"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:876
msgid "Every node is associated with a parser, and that parser is associated with a buffer.  The following functions retrieve them."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:877
#, no-wrap
msgid "treesit-node-parser node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:879
msgid "This function returns @var{node}'s associated parser."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:881
#, no-wrap
msgid "treesit-node-buffer node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:883
msgid "This function returns @var{node}'s parser's associated buffer."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:885
#, no-wrap
msgid "treesit-node-language node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:887
msgid "This function returns @var{node}'s parser's associated language."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:891
msgid "Each node represents a portion of text in the buffer.  Functions below find relevant information about that text."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:892
#, no-wrap
msgid "treesit-node-start node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:894
msgid "Return the start position of @var{node}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:896
#, no-wrap
msgid "treesit-node-end node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:898
msgid "Return the end position of @var{node}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:900
#, no-wrap
msgid "treesit-node-text node &optional object"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:904
msgid "Return the buffer text that @var{node} represents, as a string.  (If @var{node} is retrieved from parsing a string, it will be the text from that string.)"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:906
#, no-wrap
msgid "predicates for syntax tree nodes"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:908
msgid "Here are some predicates on tree-sitter nodes:"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:909
#, no-wrap
msgid "treesit-node-p object"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:911
msgid "Checks if @var{object} is a tree-sitter syntax node."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:913
#, no-wrap
msgid "treesit-node-eq node1 node2"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:916
msgid "Checks if @var{node1} and @var{node2} are the same node in a syntax tree."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:918
#, no-wrap
msgid "Property information"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:924
msgid "In general, nodes in a concrete syntax tree fall into two categories: @dfn{named nodes} and @dfn{anonymous nodes}.  Whether a node is named or anonymous is determined by the language definition (@pxref{tree-sitter named node, named node})."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:925
#, no-wrap
msgid "tree-sitter missing node"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:926
#, no-wrap
msgid "missing node, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:933
msgid "Apart from being named or anonymous, a node can have other properties.  A node can be ``missing'': such nodes are inserted by the parser in order to recover from certain kinds of syntax errors, i.e., something should probably be there according to the grammar, but is not there.  This can happen during editing of the program source, when the source is not yet in its final form."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:934
#, no-wrap
msgid "tree-sitter extra node"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:935
#, no-wrap
msgid "extra node, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:938
msgid "A node can be ``extra'': such nodes represent things like comments, which can appear anywhere in the text."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:939
#, no-wrap
msgid "tree-sitter outdated node"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:940
#, no-wrap
msgid "outdated node, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:943
msgid "A node can be ``outdated'', if its parser has reparsed at least once after the node was created."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:944
#, no-wrap
msgid "tree-sitter node that has error"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:945
#, no-wrap
msgid "has error, tree-sitter node"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:949
msgid "A node ``has error'' if the text it spans contains a syntax error.  It can be that the node itself has an error, or one of its descendants has an error."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:950
#, no-wrap
msgid "treesit-node-check node property"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:954
msgid "This function checks if @var{node} has the specified @var{property}.  @var{property} can be @code{named}, @code{missing}, @code{extra}, @code{outdated}, or @code{has-error}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:956
#, no-wrap
msgid "treesit-node-type node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:962
msgid "Named nodes have ``types'' (@pxref{tree-sitter node type, node type}).  For example, a named node can be a @code{string_literal} node, where @code{string_literal} is its type.  The type of an anonymous node is just the text that the node represents; e.g., the type of a @samp{,} node 480is just @samp{,}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:964
msgid "This function returns @var{node}'s type as a string."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:966
#, no-wrap
msgid "Information as a child or parent"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:968
#, no-wrap
msgid "treesit-node-index node &optional named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:972
msgid "This function returns the index of @var{node} as a child node of its parent.  If @var{named} is non-@code{nil}, it only counts named nodes (@pxref{tree-sitter named node, named node})."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:974
#, no-wrap
msgid "treesit-node-field-name node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:978
msgid "A child of a parent node could have a field name (@pxref{tree-sitter node field name, field name}).  This function returns the field name of @var{node} as a child of its parent."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:980
#, no-wrap
msgid "treesit-node-field-name-for-child node n"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:984
msgid "This function returns the field name of the @var{n}'th child of @var{node}.  It returns @code{nil} if there is no @var{n}'th child, or the @var{n}'th child doesn't have a field name."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:987
msgid "Note that @var{n} counts both named and anonymous child.  And @var{n} could be negative, e.g., @code{-1} represents the last child."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:989
#, no-wrap
msgid "treesit-child-count node &optional named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:993
msgid "This function finds the number of children of @var{node}.  If @var{named} is non-@code{nil}, it only counts named children (@pxref{tree-sitter named node, named node})."
msgstr ""

#. type: section
#: original_texis/parsing.texi:996
#, no-wrap
msgid "Pattern Matching Tree-sitter Nodes"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:997
#, no-wrap
msgid "pattern matching with tree-sitter nodes"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:999
#, no-wrap
msgid "capturing, tree-sitter node"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1005
msgid "Tree-sitter lets Lisp programs match patterns using a small declarative language.  This pattern matching consists of two steps: first tree-sitter matches a @dfn{pattern} against nodes in the syntax tree, then it @dfn{captures} specific nodes that matched the pattern and returns the captured nodes."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1009
msgid "We describe first how to write the most basic query pattern and how to capture nodes in a pattern, then the pattern-matching function, and finally the more advanced pattern syntax."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:1010
#, no-wrap
msgid "Basic query syntax"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1012
#, no-wrap
msgid "tree-sitter query pattern syntax"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1013
#, no-wrap
msgid "pattern syntax, tree-sitter query"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1014
#, no-wrap
msgid "query, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1018
msgid "A @dfn{query} consists of multiple @dfn{patterns}.  Each pattern is an s-expression that matches a certain node in the syntax node.  A pattern has the form @w{@code{(@var{type} (@var{child}@dots{}))}}"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1021
msgid "For example, a pattern that matches a @code{binary_expression} node that contains @code{number_literal} child nodes would look like"
msgstr ""

#. type: example
#: original_texis/parsing.texi:1024
#, no-wrap
msgid "(binary_expression (number_literal))\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1029
msgid "To @dfn{capture} a node using the query pattern above, append @code{@@@var{capture-name}} after the node pattern you want to capture.  For example,"
msgstr ""

#. type: example
#: original_texis/parsing.texi:1032
#, no-wrap
msgid "(binary_expression (number_literal) @@number-in-exp)\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1038
msgid "captures @code{number_literal} nodes that are inside a @code{binary_expression} node with the capture name @code{number-in-exp}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1041
msgid "We can capture the @code{binary_expression} node as well, with, for example, the capture name @code{biexp}:"
msgstr ""

#. type: example
#: original_texis/parsing.texi:1045
#, no-wrap
msgid ""
"(binary_expression\n"
" (number_literal) @@number-in-exp) @@biexp\n"
msgstr ""

#. type: heading
#: original_texis/parsing.texi:1047
#, no-wrap
msgid "Query function"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1049
#, no-wrap
msgid "query functions, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1051
msgid "Now we can introduce the @dfn{query functions}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1052
#, no-wrap
msgid "treesit-query-capture node query &optional beg end node-only"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1058
msgid "This function matches patterns in @var{query} within @var{node}.  The argument @var{query} can be either a string, a s-expression, or a compiled query object.  For now, we focus on the string syntax; s-expression syntax and compiled query are described at the end of the section."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1063
msgid "The argument @var{node} can also be a parser or a language symbol.  A parser means using its root node, a language symbol means find or create a parser for that language in the current buffer, and use the root node."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1072
msgid "The function returns all the captured nodes in a list of the form @w{@code{(@var{capture_name} . @var{node})}}.  If @var{node-only} is non-@code{nil}, it returns the list of nodes instead.  By default the entire text of @var{node} is searched, but if @var{beg} and @var{end} are both non-@code{nil}, they specify the region of buffer text where this function should match nodes.  Any matching node whose span overlaps with the region between @var{beg} and @var{end} are captured, it doesn't have to be completely in the region."
msgstr ""

#. type: vindex
#: original_texis/parsing.texi:1073
#, no-wrap
msgid "treesit-query-error"
msgstr ""

#. type: findex
#: original_texis/parsing.texi:1074
#, no-wrap
msgid "treesit-query-validate"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1079 original_texis/parsing.texi:1373
msgid "This function raises the @code{treesit-query-error} error if @var{query} is malformed.  The signal data contains a description of the specific error.  You can use @code{treesit-query-validate} to validate and debug the query."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1083
msgid "For example, suppose @var{node}'s text is @code{1 + 2}, and @var{query} is"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1089
#, no-wrap
msgid ""
"(setq query\n"
"      \"(binary_expression\n"
"        (number_literal) @@number-in-exp) @@biexp\")\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1093
msgid "Matching that query would return"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1100
#, no-wrap
msgid ""
"(treesit-query-capture node query)\n"
"    @result{} ((biexp . @var{<node for \"1 + 2\">})\n"
"       (number-in-exp . @var{<node for \"1\">})\n"
"       (number-in-exp . @var{<node for \"2\">}))\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1105
msgid "As mentioned earlier, @var{query} could contain multiple patterns.  For example, it could have two top-level patterns:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1111
#, no-wrap
msgid ""
"(setq query\n"
"      \"(binary_expression) @@biexp\n"
"       (number_literal)  @@number @@biexp\")\n"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1114
#, no-wrap
msgid "treesit-query-string string query language"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1117
msgid "This function parses @var{string} with @var{language}, matches its root node with @var{query}, and returns the result."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:1119
#, no-wrap
msgid "More query syntax"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1124
msgid "Besides node type and capture, tree-sitter's pattern syntax can express anonymous node, field name, wildcard, quantification, grouping, alternation, anchor, and predicate."
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:1125
#, no-wrap
msgid "Anonymous node"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1129
msgid "An anonymous node is written verbatim, surrounded by quotes.  A pattern matching (and capturing) keyword @code{return} would be"
msgstr ""

#. type: example
#: original_texis/parsing.texi:1132
#, no-wrap
msgid "\"return\" @@keyword\n"
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:1134
#, no-wrap
msgid "Wild card"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1139
msgid "In a pattern, @samp{(_)} matches any named node, and @samp{_} matches any named and anonymous node.  For example, to capture any named child of a @code{binary_expression} node, the pattern would be"
msgstr ""

#. type: example
#: original_texis/parsing.texi:1142
#, no-wrap
msgid "(binary_expression (_) @@in_biexp)\n"
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:1144
#, no-wrap
msgid "Field name"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1149
msgid "It is possible to capture child nodes that have specific field names.  In the pattern below, @code{declarator} and @code{body} are field names, indicated by the colon following them."
msgstr ""

#. type: group
#: original_texis/parsing.texi:1155
#, no-wrap
msgid ""
"(function_definition\n"
"  declarator: (_) @@func-declarator\n"
"  body: (_) @@func-body)\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1160
msgid "It is also possible to capture a node that doesn't have a certain field, say, a @code{function_definition} without a @code{body} field."
msgstr ""

#. type: example
#: original_texis/parsing.texi:1163
#, no-wrap
msgid "(function_definition !body) @@func-no-body\n"
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:1165
#, no-wrap
msgid "Quantify node"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1167
#, no-wrap
msgid "quantify node, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1172
msgid "Tree-sitter recognizes quantification operators @samp{*}, @samp{+} and @samp{?}.  Their meanings are the same as in regular expressions: @samp{*} matches the preceding pattern zero or more times, @samp{+} matches one or more times, and @samp{?} matches zero or one time."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1175
msgid "For example, the following pattern matches @code{type_declaration} nodes that has @emph{zero or more} @code{long} keyword."
msgstr ""

#. type: example
#: original_texis/parsing.texi:1178
#, no-wrap
msgid "(type_declaration \"long\"*) @@long-type\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1182
msgid "The following pattern matches a type declaration that has zero or one @code{long} keyword:"
msgstr ""

#. type: example
#: original_texis/parsing.texi:1185
#, no-wrap
msgid "(type_declaration \"long\"?) @@long-type\n"
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:1187
#, no-wrap
msgid "Grouping"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1192
msgid "Similar to groups in regular expression, we can bundle patterns into groups and apply quantification operators to them.  For example, to express a comma separated list of identifiers, one could write"
msgstr ""

#. type: example
#: original_texis/parsing.texi:1195
#, no-wrap
msgid "(identifier) (\",\" (identifier))*\n"
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:1197
#, no-wrap
msgid "Alternation"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1203
msgid "Again, similar to regular expressions, we can express ``match anyone from this group of patterns'' in a pattern.  The syntax is a list of patterns enclosed in square brackets.  For example, to capture some keywords in C, the pattern would be"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1212
#, no-wrap
msgid ""
"[\n"
"  \"return\"\n"
"  \"break\"\n"
"  \"if\"\n"
"  \"else\"\n"
"] @@keyword\n"
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:1215
#, no-wrap
msgid "Anchor"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1222
msgid "The anchor operator @samp{.} can be used to enforce juxtaposition, i.e., to enforce two things to be directly next to each other.  The two ``things'' can be two nodes, or a child and the end of its parent.  For example, to capture the first child, the last child, or two adjacent children:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1227
#, no-wrap
msgid ""
";; Anchor the child with the end of its parent.\n"
"(compound_expression (_) @@last-child .)\n"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1232
#, no-wrap
msgid ""
";; Anchor the child with the beginning of its parent.\n"
"(compound_expression . (_) @@first-child)\n"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1240
#, no-wrap
msgid ""
";; Anchor two adjacent children.\n"
"(compound_expression\n"
" (_) @@prev-child\n"
" .\n"
" (_) @@next-child)\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1245
msgid "Note that the enforcement of juxtaposition ignores any anonymous nodes."
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:1246
#, no-wrap
msgid "Predicate"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1250
msgid "It is possible to add predicate constraints to a pattern.  For example, with the following pattern:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1257
#, no-wrap
msgid ""
"(\n"
" (array . (_) @@first (_) @@last .)\n"
" (#equal @@first @@last)\n"
")\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1265
msgid "tree-sitter only matches arrays where the first element equals to the last element.  To attach a predicate to a pattern, we need to group them together.  A predicate always starts with a @samp{#}.  Currently there are two predicates, @code{#equal} and @code{#match}."
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:1266
#, no-wrap
msgid "Predicate equal arg1 arg2"
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:1270
msgid "Matches if @var{arg1} equals to @var{arg2}.  Arguments can be either strings or capture names.  Capture names represent the text that the captured node spans in the buffer."
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:1272
#, no-wrap
msgid "Predicate match regexp capture-name"
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:1275
msgid "Matches if the text that @var{capture-name}'s node spans in the buffer matches regular expression @var{regexp}.  Matching is case-sensitive."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1280
msgid "Note that a predicate can only refer to capture names that appear in the same pattern.  Indeed, it makes little sense to refer to capture names in other patterns."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:1281
#, no-wrap
msgid "S-expression patterns"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1283
#, no-wrap
msgid "tree-sitter patterns as sexps"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1284
#, no-wrap
msgid "patterns, tree-sitter, in sexp form"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1288
msgid "Besides strings, Emacs provides a s-expression based syntax for tree-sitter patterns.  It largely resembles the string-based syntax.  For example, the following query"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1296
#, no-wrap
msgid ""
"(treesit-query-capture\n"
" node \"(addition_expression\n"
"        left: (_) @@left\n"
"        \\\"+\\\" @@plus-sign\n"
"        right: (_) @@right) @@addition\n"
"\n"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1298
#, no-wrap
msgid "        [\\\"return\\\" \\\"break\\\"] @@keyword\")\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1303
msgid "is equivalent to"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1311
#, no-wrap
msgid ""
"(treesit-query-capture\n"
" node '((addition_expression\n"
"         left: (_) @@left\n"
"         \"+\" @@plus-sign\n"
"         right: (_) @@right) @@addition\n"
"\n"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1313
#, no-wrap
msgid "         [\"return\" \"break\"] @@keyword))\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1318
msgid "Most patterns can be written directly as strange but nevertheless valid s-expressions.  Only a few of them needs modification:"
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1322
msgid "Anchor @samp{.} is written as @code{:anchor}."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1324
msgid "@samp{?} is written as @samp{:?}."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1326
msgid "@samp{*} is written as @samp{:*}."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1328
msgid "@samp{+} is written as @samp{:+}."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1331
msgid "@code{#equal} is written as @code{:equal}.  In general, predicates change their @samp{#} to @samp{:}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1334
msgid "For example,"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1341
#, no-wrap
msgid ""
"\"(\n"
"  (compound_expression . (_) @@first (_)* @@rest)\n"
"  (#match \\\"love\\\" @@first)\n"
"  )\"\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1346
msgid "is written in s-expression as"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1353
#, no-wrap
msgid ""
"'((\n"
"   (compound_expression :anchor (_) @@first (_) :* @@rest)\n"
"   (:match \"love\" @@first)\n"
"   ))\n"
msgstr ""

#. type: heading
#: original_texis/parsing.texi:1356
#, no-wrap
msgid "Compiling queries"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1358
#, no-wrap
msgid "compiling tree-sitter queries"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1359
#, no-wrap
msgid "queries, compiling"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1364
msgid "If a query is intended to be used repeatedly, especially in tight loops, it is important to compile that query, because a compiled query is much faster than an uncompiled one.  A compiled query can be used anywhere a query is accepted."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1365
#, no-wrap
msgid "treesit-query-compile language query"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1368
msgid "This function compiles @var{query} for @var{language} into a compiled query object and returns it."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1375
#, no-wrap
msgid "treesit-query-language query"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1377
msgid "This function return the language of @var{query}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1379
#, no-wrap
msgid "treesit-query-expand query"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1382
msgid "This function converts the s-expression @var{query} into the string format."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1384
#, no-wrap
msgid "treesit-pattern-expand pattern"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1387
msgid "This function converts the s-expression @var{pattern} into the string format."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1392
msgid "For more details, read the tree-sitter project's documentation about pattern-matching, which can be found at @uref{https://tree-sitter.github.io/tree-sitter/using-parsers#pattern-matching-with-queries}."
msgstr ""

#. type: section
#: original_texis/parsing.texi:1394
#, no-wrap
msgid "Parsing Text in Multiple Languages"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1395
#, no-wrap
msgid "multiple languages, parsing with tree-sitter"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1396
#, no-wrap
msgid "parsing multiple languages with tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1406
msgid "Sometimes, the source of a programming language could contain snippets of other languages; @acronym{HTML} + @acronym{CSS} + JavaScript is one example.  In that case, text segments written in different languages need to be assigned different parsers.  Traditionally, this is achieved by using narrowing.  While tree-sitter works with narrowing (@pxref{tree-sitter narrowing, narrowing}), the recommended way is instead to set regions of buffer text (i.e., ranges) in which a parser will operate.  This section describes functions for setting and getting ranges for a parser."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1416
msgid "Lisp programs should call @code{treesit-update-ranges} to make sure the ranges for each parser are correct before using parsers in a buffer, and call @code{treesit-language-at} to figure out the language responsible for the text at some position.  These two functions don't work by themselves, they need major modes to set @code{treesit-range-settings} and @code{treesit-language-at-point-function}, which do the actual work.  These functions and variables are explained in more detail towards the end of the section."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:1417
#, no-wrap
msgid "Getting and setting ranges"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1419
#, no-wrap
msgid "treesit-parser-set-included-ranges parser ranges"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1424
msgid "This function sets up @var{parser} to operate on @var{ranges}.  The @var{parser} will only read the text of the specified ranges.  Each range in @var{ranges} is a list of the form @w{@code{(@var{beg} . @var{end})}}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1427
msgid "The ranges in @var{ranges} must come in order and must not overlap.  That is, in pseudo code:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1435
#, no-wrap
msgid ""
"(cl-loop for idx from 1 to (1- (length ranges))\n"
"         for prev = (nth (1- idx) ranges)\n"
"         for next = (nth idx ranges)\n"
"         should (<= (car prev) (cdr prev)\n"
"                    (car next) (cdr next)))\n"
msgstr ""

#. type: vindex
#: original_texis/parsing.texi:1438
#, no-wrap
msgid "treesit-range-invalid"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1443
msgid "If @var{ranges} violates this constraint, or something else went wrong, this function signals the @code{treesit-range-invalid} error.  The signal data contains a specific error message and the ranges we are trying to set."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1446
msgid "This function can also be used for disabling ranges.  If @var{ranges} is @code{nil}, the parser is set to parse the whole buffer."
msgstr ""

#. type: group
#: original_texis/parsing.texi:1453
#, no-wrap
msgid ""
"(treesit-parser-set-included-ranges\n"
" parser '((1 . 9) (16 . 24) (24 . 25)))\n"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1457
#, no-wrap
msgid "treesit-parser-included-ranges parser"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1463
msgid "This function returns the ranges set for @var{parser}.  The return value is the same as the @var{ranges} argument of @code{treesit-parser-included-ranges}: a list of cons cells of the form @w{@code{(@var{beg} . @var{end})}}.  If @var{parser} doesn't have any ranges, the return value is @code{nil}."
msgstr ""

#. type: group
#: original_texis/parsing.texi:1468
#, no-wrap
msgid ""
"(treesit-parser-included-ranges parser)\n"
"    @result{} ((1 . 9) (16 . 24) (24 . 25))\n"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1472
#, no-wrap
msgid "treesit-query-range source query &optional beg end"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1477
msgid "This function matches @var{source} with @var{query} and returns the ranges of captured nodes.  The return value is a list of cons cells of the form @w{@code{(@var{beg} . @var{end})}}, where @var{beg} and @var{end} specify the beginning and the end of a region of text."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1483
msgid "For convenience, @var{source} can be a language symbol, a parser, or a node.  If it's a language symbol, this function matches in the root node of the first parser using that language; if a parser, this function matches in the root node of that parser; if a node, this function matches in that node."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1488
msgid "The argument @var{query} is the query used to capture nodes (@pxref{Pattern Matching}).  The capture names don't matter.  The arguments @var{beg} and @var{end}, if both non-@code{nil}, limit the range in which this function queries."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1491
msgid "Like other query functions, this function raises the @code{treesit-query-error} error if @var{query} is malformed."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:1493
#, no-wrap
msgid "Supporting multiple languages in Lisp programs"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1498
msgid "It should suffice for general Lisp programs to call the following two functions in order to support program sources that mixes multiple languages."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1499
#, no-wrap
msgid "treesit-update-ranges &optional beg end"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1505
msgid "This function updates ranges for parsers in the buffer.  It makes sure the parsers' ranges are set correctly between @var{beg} and @var{end}, according to @code{treesit-range-settings}.  If omitted, @var{beg} defaults to the beginning of the buffer, and @var{end} defaults to the end of the buffer."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1508
msgid "For example, fontification functions use this function before querying for nodes in a region."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1510
#, no-wrap
msgid "treesit-language-at pos"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1518
msgid "This function returns the language of the text at buffer position @var{pos}.  Under the hood it calls @code{treesit-language-at-point-function} and returns its return value.  If @code{treesit-language-at-point-function} is @code{nil}, this function returns the language of the first parser in the returned value of @code{treesit-parser-list}.  If there is no parser in the buffer, it returns @code{nil}."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:1520
#, no-wrap
msgid "Supporting multiple languages in major modes"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1522
#, no-wrap
msgid "host language, tree-sitter"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1523
#, no-wrap
msgid "tree-sitter host and embedded languages"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1524
#, no-wrap
msgid "embedded language, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1531
msgid "Normally, in a set of languages that can be mixed together, there is a @dfn{host language} and one or more @dfn{embedded languages}.  A Lisp program usually first parses the whole document with the host language's parser, retrieves some information, sets ranges for the embedded languages with that information, and then parses the embedded languages."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1539
msgid "Take a buffer containing @acronym{HTML}, @acronym{CSS} and JavaScript as an example.  A Lisp program will first parse the whole buffer with an @acronym{HTML} parser, then query the parser for @code{style_element} and @code{script_element} nodes, which correspond to @acronym{CSS} and JavaScript text, respectively.  Then it sets the range of the @acronym{CSS} and JavaScript parser to the ranges in which their corresponding nodes span."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1541
msgid "Given a simple @acronym{HTML} document:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1548
#, no-wrap
msgid ""
"<html>\n"
"  <script>1 + 2</script>\n"
"  <style>body @{ color: \"blue\"; @}</style>\n"
"</html>\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1554
msgid "a Lisp program will first parse with a @acronym{HTML} parser, then set ranges for @acronym{CSS} and JavaScript parsers:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1561
#, no-wrap
msgid ""
";; Create parsers.\n"
"(setq html (treesit-get-parser-create 'html))\n"
"(setq css (treesit-get-parser-create 'css))\n"
"(setq js (treesit-get-parser-create 'javascript))\n"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1570
#, no-wrap
msgid ""
";; Set CSS ranges.\n"
"(setq css-range\n"
"      (treesit-query-range\n"
"       'html\n"
"       \"(style_element (raw_text) @@capture)\"))\n"
"(treesit-parser-set-included-ranges css css-range)\n"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1579
#, no-wrap
msgid ""
";; Set JavaScript ranges.\n"
"(setq js-range\n"
"      (treesit-query-range\n"
"       'html\n"
"       \"(script_element (raw_text) @@capture)\"))\n"
"(treesit-parser-set-included-ranges js js-range)\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1589
msgid "Emacs automates this process in @code{treesit-update-ranges}.  A multi-language major mode should set @code{treesit-range-settings} so that @code{treesit-update-ranges} knows how to perform this process automatically.  Major modes should use the helper function @code{treesit-range-rules} to generate a value that can be assigned to @code{treesit-range-settings}.  The settings in the following example directly translate into operations shown above."
msgstr ""

#. type: group
#: original_texis/parsing.texi:1597
#, no-wrap
msgid ""
"(setq-local treesit-range-settings\n"
"            (treesit-range-rules\n"
"             :embed 'javascript\n"
"             :host 'html\n"
"             '((script_element (raw_text) @@capture))\n"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1603
#, no-wrap
msgid ""
"             :embed 'css\n"
"             :host 'html\n"
"             '((style_element (raw_text) @@capture))))\n"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1606
#, no-wrap
msgid "treesit-range-rules &rest query-specs"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1610
msgid "This function is used to set @var{treesit-range-settings}.  It takes care of compiling queries and other post-processing, and outputs a value that @var{treesit-range-settings} can have."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1615
msgid "It takes a series of @var{query-spec}s, where each @var{query-spec} is a @var{query} preceded by zero or more @var{keyword}/@var{value} pairs.  Each @var{query} is a tree-sitter query in either the string, s-expression or compiled form, or a function."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1620
msgid "If @var{query} is a tree-sitter query, it should be preceded by two @var{:keyword}/@var{value} pairs, where the @code{:embed} keyword specifies the embedded language, and the @code{:host} keyword specified the host language."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1626
msgid "@code{treesit-update-ranges} uses @var{query} to figure out how to set the ranges for parsers for the embedded language.  It queries @var{query} in a host language parser, computes the ranges in which the captured nodes span, and applies these ranges to embedded language parsers."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1633
msgid "If @var{query} is a function, it doesn't need any @var{:keyword} and @var{value} pair.  It should be a function that takes 2 arguments, @var{start} and @var{end}, and sets the ranges for parsers in the current buffer in the region between @var{start} and @var{end}.  It is fine for this function to set ranges in a larger region that encompasses the region between @var{start} and @var{end}."
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:1635
#, no-wrap
msgid "treesit-range-settings"
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:1641
msgid "This variable helps @code{treesit-update-ranges} in updating the ranges for parsers in the buffer.  It is a list of @var{setting}s where the exact format of a @var{setting} is considered internal.  You should use @code{treesit-range-rules} to generate a value that this variable can have."
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:1649
#, no-wrap
msgid "treesit-language-at-point-function"
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:1654
msgid "This variable's value should be a function that takes a single argument, @var{pos}, which is a buffer position, and returns the language of the buffer text at @var{pos}.  This variable is used by @code{treesit-language-at}."
msgstr ""

#. type: section
#: original_texis/parsing.texi:1657
#, no-wrap
msgid "Developing major modes with tree-sitter"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1658
#, no-wrap
msgid "major mode, developing with tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1662
msgid "This section covers some general guidelines on developing tree-sitter integration for a major mode."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1665
msgid "A major mode supporting tree-sitter features should roughly follow this pattern:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1681
#, no-wrap
msgid ""
"(define-derived-mode woomy-mode prog-mode \"Woomy\"\n"
"  \"A mode for Woomy programming language.\"\n"
"  ;; Shared setup.\n"
"  ...\n"
"  (cond\n"
"   ;; Tree-sitter setup.\n"
"   ((treesit-ready-p 'woomy-mode 'woomy)\n"
"    (setq-local treesit-variables ...)\n"
"    (treesit-major-mode-setup))\n"
"   ;; Non-tree-sitter setup.\n"
"   (t\n"
"    ...)))\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1686
msgid "First, the major mode should use @code{treesit-ready-p} to determine whether tree-sitter can be activated in this mode."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1687
#, no-wrap
msgid "treesit-ready-p mode language &optional quiet"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1693
msgid "This function checks for conditions for activating tree-sitter.  It checks whether Emacs was built with tree-sitter, whether the buffer's size is not too large for tree-sitter to handle it, and whether the language definition for @var{language} is available on the system (@pxref{Language Definitions})."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1697
msgid "This function emits a warning if tree-sitter cannot be activated.  If @var{quiet} is @code{message}, the warning is turned into a message; if @var{quiet} is @code{nil}, no warning or message is displayed."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1700
msgid "If all the necessary conditions are met, this function returns non-@code{nil}; otherwise it returns @code{nil}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1704
msgid "Next, the major mode should set up tree-sitter variables and call @code{treesit-major-mode-setup}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1705
#, no-wrap
msgid "treesit-major-mode-setup"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1707
msgid "This function activates some tree-sitter features for a major mode."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1709
msgid "Currently, it sets up the following features:"
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1713
msgid "If @code{treesit-font-lock-settings} is non-@code{nil}, it sets up fontification."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1716
msgid "If @code{treesit-simple-indent-rules} is non-@code{nil}, it sets up indentation."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1720
msgid "If @code{treesit-defun-type-regexp} is non-@code{nil}, it sets up navigation functions for @code{beginning-of-defun} and @code{end-of-defun}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1726
msgid "For more information of these built-in tree-sitter features, @pxref{Parser-based Font Lock}, @pxref{Parser-based Indentation}, and @pxref{List Motion}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1729
msgid "For supporting mixing of multiple languages in a major mode, @pxref{Multiple Languages}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1732
msgid "Setting the following local variables allows tree-sitter's indentation engine to correctly indent multi-line comments:"
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:1733
#, no-wrap
msgid "treesit-comment-start"
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:1737
msgid "This should be a regular expression matching an opening comment token.  For example, it should match @samp{//}, @samp{////}, @samp{/*}, @samp{/****}, etc., in C."
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:1739
#, no-wrap
msgid "treesit-comment-end"
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:1742
msgid "This should be a regular expression matching a closing comment token.  For example, it should match @samp{*/}, @samp{****/}, etc., in C."
msgstr ""

#. type: section
#: original_texis/parsing.texi:1745
#, no-wrap
msgid "Tree-sitter C API Correspondence"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1749
msgid "Emacs' tree-sitter integration doesn't expose every feature provided by tree-sitter's C API.  Missing features include:"
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1753
msgid "Creating a tree cursor and navigating the syntax tree with it."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1755
msgid "Setting timeout and cancellation flag for a parser."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1757
msgid "Setting the logger for a parser."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1759
msgid "Printing a @acronym{DOT} graph of the syntax tree to a file."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1762
msgid "Copying and modifying a syntax tree.  (Emacs doesn't expose a tree object.)"
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1764
msgid "Using (row, column) coordinates as position."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1767
msgid "Updating a node with changes.  (In Emacs, retrieve a new node instead of updating the existing one.)"
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1769
msgid "Querying statics of a language definition."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1773
msgid "In addition, Emacs makes some changes to the C API to make the API more convenient and idiomatic:"
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1778
msgid "Instead of using byte positions, the Emacs Lisp API uses character positions."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1780
msgid "Null nodes are converted to nil."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1786
msgid "Below is the correspondence between all C API functions and their ELisp counterparts.  Sometimes one ELisp function corresponds to multiple C functions, and many C functions don't have an ELisp counterpart."
msgstr ""

#. type: example
#: original_texis/parsing.texi:1888
#, no-wrap
msgid ""
"ts_parser_new                           treesit-parser-create\n"
"ts_parser_delete\n"
"ts_parser_set_language\n"
"ts_parser_language                      treesit-parser-language\n"
"ts_parser_set_included_ranges           treesit-parser-set-included-ranges\n"
"ts_parser_included_ranges               treesit-parser-included-ranges\n"
"ts_parser_parse\n"
"ts_parser_parse_string                  treesit-parse-string\n"
"ts_parser_parse_string_encoding\n"
"ts_parser_reset\n"
"ts_parser_set_timeout_micros\n"
"ts_parser_timeout_micros\n"
"ts_parser_set_cancellation_flag\n"
"ts_parser_cancellation_flag\n"
"ts_parser_set_logger\n"
"ts_parser_logger\n"
"ts_parser_print_dot_graphs\n"
"ts_tree_copy\n"
"ts_tree_delete\n"
"ts_tree_root_node\n"
"ts_tree_language\n"
"ts_tree_edit\n"
"ts_tree_get_changed_ranges\n"
"ts_tree_print_dot_graph\n"
"ts_node_type                            treesit-node-type\n"
"ts_node_symbol\n"
"ts_node_start_byte                      treesit-node-start\n"
"ts_node_start_point\n"
"ts_node_end_byte                        treesit-node-end\n"
"ts_node_end_point\n"
"ts_node_string                          treesit-node-string\n"
"ts_node_is_null\n"
"ts_node_is_named                        treesit-node-check\n"
"ts_node_is_missing                      treesit-node-check\n"
"ts_node_is_extra                        treesit-node-check\n"
"ts_node_has_changes\n"
"ts_node_has_error                       treesit-node-check\n"
"ts_node_parent                          treesit-node-parent\n"
"ts_node_child                           treesit-node-child\n"
"ts_node_field_name_for_child            treesit-node-field-name-for-child\n"
"ts_node_child_count                     treesit-node-child-count\n"
"ts_node_named_child                     treesit-node-child\n"
"ts_node_named_child_count               treesit-node-child-count\n"
"ts_node_child_by_field_name             treesit-node-by-field-name\n"
"ts_node_child_by_field_id\n"
"ts_node_next_sibling                    treesit-next-sibling\n"
"ts_node_prev_sibling                    treesit-prev-sibling\n"
"ts_node_next_named_sibling              treesit-next-sibling\n"
"ts_node_prev_named_sibling              treesit-prev-sibling\n"
"ts_node_first_child_for_byte            treesit-first-child-for-pos\n"
"ts_node_first_named_child_for_byte      treesit-first-child-for-pos\n"
"ts_node_descendant_for_byte_range       treesit-descendant-for-range\n"
"ts_node_descendant_for_point_range\n"
"ts_node_named_descendant_for_byte_range treesit-descendant-for-range\n"
"ts_node_named_descendant_for_point_range\n"
"ts_node_edit\n"
"ts_node_eq                              treesit-node-eq\n"
"ts_tree_cursor_new\n"
"ts_tree_cursor_delete\n"
"ts_tree_cursor_reset\n"
"ts_tree_cursor_current_node\n"
"ts_tree_cursor_current_field_name\n"
"ts_tree_cursor_current_field_id\n"
"ts_tree_cursor_goto_parent\n"
"ts_tree_cursor_goto_next_sibling\n"
"ts_tree_cursor_goto_first_child\n"
"ts_tree_cursor_goto_first_child_for_byte\n"
"ts_tree_cursor_goto_first_child_for_point\n"
"ts_tree_cursor_copy\n"
"ts_query_new\n"
"ts_query_delete\n"
"ts_query_pattern_count\n"
"ts_query_capture_count\n"
"ts_query_string_count\n"
"ts_query_start_byte_for_pattern\n"
"ts_query_predicates_for_pattern\n"
"ts_query_step_is_definite\n"
"ts_query_capture_name_for_id\n"
"ts_query_string_value_for_id\n"
"ts_query_disable_capture\n"
"ts_query_disable_pattern\n"
"ts_query_cursor_new\n"
"ts_query_cursor_delete\n"
"ts_query_cursor_exec                    treesit-query-capture\n"
"ts_query_cursor_did_exceed_match_limit\n"
"ts_query_cursor_match_limit\n"
"ts_query_cursor_set_match_limit\n"
"ts_query_cursor_set_byte_range\n"
"ts_query_cursor_set_point_range\n"
"ts_query_cursor_next_match\n"
"ts_query_cursor_remove_match\n"
"ts_query_cursor_next_capture\n"
"ts_language_symbol_count\n"
"ts_language_symbol_name\n"
"ts_language_symbol_for_name\n"
"ts_language_field_count\n"
"ts_language_field_name_for_id\n"
"ts_language_field_id_for_name\n"
"ts_language_symbol_type\n"
"ts_language_version\n"
msgstr ""
