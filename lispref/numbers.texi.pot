# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2024-05-02 15:32+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: original_texis/numbers.texi:6 original_texis/numbers.texi:7
#, no-wrap
msgid "Numbers"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:8
#, no-wrap
msgid "integers"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:9
#, no-wrap
msgid "numbers"
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:20
msgid ""
"GNU Emacs supports two numeric data types: @dfn{integers} and "
"@dfn{floating-point numbers}.  Integers are whole numbers such as @minus{}3, "
"0, 7, 13, and 511.  Floating-point numbers are numbers with fractional "
"parts, such as @minus{}4.5, 0.0, and 2.71828.  They can also be expressed in "
"exponential notation: @samp{1.5e2} is the same as @samp{150.0}; here, "
"@samp{e2} stands for ten to the second power, and that is multiplied by "
"1.5.  Integer computations are exact.  Floating-point computations often "
"involve rounding errors, as the numbers have a fixed amount of precision."
msgstr ""

#. type: section
#: original_texis/numbers.texi:32 original_texis/numbers.texi:34
#: original_texis/numbers.texi:35
#, no-wrap
msgid "Integer Basics"
msgstr ""

#. type: menuentry
#: original_texis/numbers.texi:32
msgid "Representation and range of integers."
msgstr ""

#. type: node
#: original_texis/numbers.texi:32 original_texis/numbers.texi:217
#, no-wrap
msgid "Float Basics"
msgstr ""

#. type: menuentry
#: original_texis/numbers.texi:32
msgid "Representation and range of floating point."
msgstr ""

#. type: node
#: original_texis/numbers.texi:32 original_texis/numbers.texi:354
#, no-wrap
msgid "Predicates on Numbers"
msgstr ""

#. type: menuentry
#: original_texis/numbers.texi:32
msgid "Testing for numbers."
msgstr ""

#. type: section
#: original_texis/numbers.texi:32 original_texis/numbers.texi:410
#: original_texis/numbers.texi:411
#, no-wrap
msgid "Comparison of Numbers"
msgstr ""

#. type: menuentry
#: original_texis/numbers.texi:32
msgid "Equality and inequality predicates."
msgstr ""

#. type: section
#: original_texis/numbers.texi:32 original_texis/numbers.texi:523
#: original_texis/numbers.texi:524
#, no-wrap
msgid "Numeric Conversions"
msgstr ""

#. type: menuentry
#: original_texis/numbers.texi:32
msgid "Converting float to integer and vice versa."
msgstr ""

#. type: section
#: original_texis/numbers.texi:32 original_texis/numbers.texi:618
#: original_texis/numbers.texi:619
#, no-wrap
msgid "Arithmetic Operations"
msgstr ""

#. type: menuentry
#: original_texis/numbers.texi:32
msgid "How to add, subtract, multiply and divide."
msgstr ""

#. type: section
#: original_texis/numbers.texi:32 original_texis/numbers.texi:845
#: original_texis/numbers.texi:846
#, no-wrap
msgid "Rounding Operations"
msgstr ""

#. type: menuentry
#: original_texis/numbers.texi:32
msgid "Explicitly rounding floating-point numbers."
msgstr ""

#. type: node
#: original_texis/numbers.texi:32 original_texis/numbers.texi:877
#, no-wrap
msgid "Bitwise Operations"
msgstr ""

#. type: menuentry
#: original_texis/numbers.texi:32
msgid "Logical and, or, not, shifting."
msgstr ""

#. type: node
#: original_texis/numbers.texi:32 original_texis/numbers.texi:1133
#, no-wrap
msgid "Math Functions"
msgstr ""

#. type: menuentry
#: original_texis/numbers.texi:32
msgid "Trig, exponential and logarithmic functions."
msgstr ""

#. type: section
#: original_texis/numbers.texi:32 original_texis/numbers.texi:1237
#: original_texis/numbers.texi:1238
#, no-wrap
msgid "Random Numbers"
msgstr ""

#. type: menuentry
#: original_texis/numbers.texi:32
msgid "Obtaining random integers, predictable or not."
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:40
msgid ""
"The Lisp reader reads an integer as a nonempty sequence of decimal digits "
"with optional initial sign and optional final period."
msgstr ""

#. type: example
#: original_texis/numbers.texi:48
#, no-wrap
msgid ""
" 1               ; @r{The integer 1.}\n"
" 1.              ; @r{The integer 1.}\n"
"+1               ; @r{Also the integer 1.}\n"
"-1               ; @r{The integer @minus{}1.}\n"
" 0               ; @r{The integer 0.}\n"
"-0               ; @r{The integer 0.}\n"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:50
#, no-wrap
msgid "integers in specific radix"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:51
#, no-wrap
msgid "radix for reading an integer"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:52
#, no-wrap
msgid "base for reading an integer"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:53
#, no-wrap
msgid "hex numbers"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:54
#, no-wrap
msgid "octal numbers"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:55
#, no-wrap
msgid "reading numbers in hex, octal, and binary"
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:67
msgid ""
"The syntax for integers in bases other than 10 consists of @samp{#} followed "
"by a radix indication followed by one or more digits.  The radix indications "
"are @samp{b} for binary, @samp{o} for octal, @samp{x} for hex, and "
"@samp{@var{radix}r} for radix @var{radix}.  Thus, @samp{#b@var{integer}} "
"reads @var{integer} in binary, and @samp{#@var{radix}r@var{integer}} reads "
"@var{integer} in radix @var{radix}.  Allowed values of @var{radix} run from "
"2 to 36, and allowed digits are the first @var{radix} characters taken from "
"@samp{0}--@samp{9}, @samp{A}--@samp{Z}.  Letter case is ignored and there is "
"no initial sign or final period.  For example:"
msgstr ""

#. type: example
#: original_texis/numbers.texi:73
#, no-wrap
msgid ""
"#b101100 @result{} 44\n"
"#o54 @result{} 44\n"
"#x2c @result{} 44\n"
"#24r1k @result{} 44\n"
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:78
msgid ""
"To understand how various functions work on integers, especially the bitwise "
"operators (@pxref{Bitwise Operations}), it is often helpful to view the "
"numbers in their binary form."
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:80
msgid "In binary, the decimal integer 5 looks like this:"
msgstr ""

#. type: example
#: original_texis/numbers.texi:83
#, no-wrap
msgid "@dots{}000101\n"
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:89
msgid ""
"(The ellipsis @samp{@dots{}} stands for a conceptually infinite number of "
"bits that match the leading bit; here, an infinite number of 0 bits.  Later "
"examples also use this @samp{@dots{}} notation.)"
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:91
msgid "The integer @minus{}1 looks like this:"
msgstr ""

#. type: example
#: original_texis/numbers.texi:94
#, no-wrap
msgid "@dots{}111111\n"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:97
#, no-wrap
msgid "two's complement"
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:100
msgid ""
"@minus{}1 is represented as all ones.  (This is called @dfn{two's "
"complement} notation.)"
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:104
msgid ""
"Subtracting 4 from @minus{}1 returns the negative integer @minus{}5.  In "
"binary, the decimal integer 4 is 100.  Consequently, @minus{}5 looks like "
"this:"
msgstr ""

#. type: example
#: original_texis/numbers.texi:107
#, no-wrap
msgid "@dots{}111011\n"
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:114
msgid ""
"Many of the functions described in this chapter accept markers for arguments "
"in place of numbers.  (@xref{Markers}.)  Since the actual arguments to such "
"functions may be either numbers or markers, we often give these arguments "
"the name @var{number-or-marker}.  When the argument value is a marker, its "
"position value is used and its buffer is ignored."
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:118
msgid ""
"In Emacs Lisp, text characters are represented by integers.  Any integer "
"between zero and the value of @code{(max-char)}, inclusive, is considered to "
"be valid as a character.  @xref{Character Codes}."
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:129
msgid ""
"Integers in Emacs Lisp are not limited to the machine word size.  Under the "
"hood, though, there are two kinds of integers: smaller ones, called "
"@dfn{fixnums}, and larger ones, called @dfn{bignums}.  Although Emacs Lisp "
"code ordinarily should not depend on whether an integer is a fixnum or a "
"bignum, older Emacs versions support only fixnums, some functions in Emacs "
"still accept only fixnums, and older Emacs Lisp code may have trouble when "
"given bignums.  For example, while older Emacs Lisp code could safely "
"compare integers for numeric equality with @code{eq}, the presence of "
"bignums means that equality predicates like @code{eql} and @code{=} should "
"now be used to compare integers."
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:137
msgid ""
"The range of values for bignums is limited by the amount of main memory, by "
"machine characteristics such as the size of the word used to represent a "
"bignum's exponent, and by the @code{integer-width} variable.  These limits "
"are typically much more generous than the limits for fixnums.  A bignum is "
"never numerically equal to a fixnum; Emacs always represents an integer in "
"fixnum range as a fixnum, not a bignum."
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:140
msgid ""
"The range of values for a fixnum depends on the machine.  The minimum range "
"is @minus{}536,870,912 to 536,870,911 (30 bits; i.e.,"
msgstr ""

#. type: ifnottex
#: original_texis/numbers.texi:142 original_texis/numbers.texi:183
msgid "@minus{}2**29"
msgstr ""

#. type: tex
#: original_texis/numbers.texi:145 original_texis/numbers.texi:186
#, no-wrap
msgid "@math{-2^{29}}\n"
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:147
msgid "to"
msgstr ""

#. type: ifnottex
#: original_texis/numbers.texi:149
msgid "2**29 @minus{} 1),"
msgstr ""

#. type: tex
#: original_texis/numbers.texi:152
#, no-wrap
msgid "@math{2^{29}-1}),\n"
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:154
msgid "but many machines provide a wider range."
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:155
#, no-wrap
msgid "largest fixnum"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:156
#, no-wrap
msgid "maximum fixnum"
msgstr ""

#. type: defvar
#: original_texis/numbers.texi:157
#, no-wrap
msgid "most-positive-fixnum"
msgstr ""

#. type: defvar
#: original_texis/numbers.texi:160
msgid ""
"The value of this variable is the greatest ``small'' integer that Emacs Lisp "
"can handle.  Typical values are"
msgstr ""

#. type: ifnottex
#: original_texis/numbers.texi:162
msgid "2**29 @minus{} 1"
msgstr ""

#. type: tex
#: original_texis/numbers.texi:165
#, no-wrap
msgid "@math{2^{29}-1}\n"
msgstr ""

#. type: defvar
#: original_texis/numbers.texi:167 original_texis/numbers.texi:188
msgid "on 32-bit and"
msgstr ""

#. type: ifnottex
#: original_texis/numbers.texi:169
msgid "2**61 @minus{} 1"
msgstr ""

#. type: tex
#: original_texis/numbers.texi:172
#, no-wrap
msgid "@math{2^{61}-1}\n"
msgstr ""

#. type: defvar
#: original_texis/numbers.texi:174 original_texis/numbers.texi:195
msgid "on 64-bit platforms."
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:176
#, no-wrap
msgid "smallest fixnum"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:177
#, no-wrap
msgid "minimum fixnum"
msgstr ""

#. type: defvar
#: original_texis/numbers.texi:178
#, no-wrap
msgid "most-negative-fixnum"
msgstr ""

#. type: defvar
#: original_texis/numbers.texi:181
msgid ""
"The value of this variable is the numerically least ``small'' integer that "
"Emacs Lisp can handle.  It is negative.  Typical values are"
msgstr ""

#. type: ifnottex
#: original_texis/numbers.texi:190
msgid "@minus{}2**61"
msgstr ""

#. type: tex
#: original_texis/numbers.texi:193
#, no-wrap
msgid "@math{-2^{61}}\n"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:197
#, no-wrap
msgid "bignum range"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:198
#, no-wrap
msgid "integer range"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:199
#, no-wrap
msgid "number of bignum bits, limit on"
msgstr ""

#. type: defvar
#: original_texis/numbers.texi:200
#, no-wrap
msgid "integer-width"
msgstr ""

#. type: defvar
#: original_texis/numbers.texi:204
msgid ""
"The value of this variable is a nonnegative integer that controls whether "
"Emacs signals a range error when a large integer would be calculated.  "
"Integers with absolute values less than"
msgstr ""

#. type: ifnottex
#: original_texis/numbers.texi:206
msgid "2**@var{n},"
msgstr ""

#. type: tex
#: original_texis/numbers.texi:209
#, no-wrap
msgid "@math{2^{n}},\n"
msgstr ""

#. type: defvar
#: original_texis/numbers.texi:215
msgid ""
"where @var{n} is this variable's value, do not signal a range error.  "
"Attempts to create larger integers typically signal a range error, although "
"there might be no signal if a larger integer can be created cheaply.  "
"Setting this variable to a large number can be costly if a computation "
"creates huge integers."
msgstr ""

#. type: section
#: original_texis/numbers.texi:218
#, no-wrap
msgid "Floating-Point Basics"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:220
#, no-wrap
msgid "@acronym{IEEE} floating point"
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:233
msgid ""
"Floating-point numbers are useful for representing numbers that are not "
"integral.  The range of floating-point numbers is the same as the range of "
"the C data type @code{double} on the machine you are using.  On almost all "
"computers supported by Emacs, this is @acronym{IEEE} binary64 floating point "
"format, which is standardized by "
"@url{https://standards.ieee.org/standard/754-2019.html,,IEEE Std 754-2019} "
"and is discussed further in David Goldberg's paper "
"``@url{https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html, What "
"Every Computer Scientist Should Know About Floating-Point Arithmetic}''.  On "
"modern platforms, floating-point operations follow the IEEE-754 standard "
"closely; however, results are not always rounded correctly on some systems, "
"notably 32-bit x86."
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:241
msgid ""
"On some old computer systems, Emacs may not use IEEE floating-point.  We "
"know of one such system on which Emacs runs correctly, but does not follow "
"IEEE-754: the VAX running NetBSD using GCC 10.4.0, where the VAX "
"@samp{D_Floating} format is used instead.  IBM System/370-derived mainframes "
"and their XL/C compiler are also capable of utilizing a hexadecimal floating "
"point format, but Emacs has not yet been built in such a configuration."
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:251
msgid ""
"The read syntax for floating-point numbers requires either a decimal point, "
"an exponent, or both.  Optional signs (@samp{+} or @samp{-})  precede the "
"number and its exponent.  For example, @samp{1500.0}, @samp{+15e2}, "
"@samp{15.0e+2}, @samp{+1500000e-3}, and @samp{.15e4} are five ways of "
"writing a floating-point number whose value is 1500.  They are all "
"equivalent.  Like Common Lisp, Emacs Lisp requires at least one digit after "
"a decimal point in a floating-point number that does not have an exponent; "
"@samp{1500.} is an integer, not a floating-point number."
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:257
msgid ""
"Emacs Lisp treats @code{-0.0} as numerically equal to ordinary zero with "
"respect to numeric comparisons like @code{=}.  This follows the "
"@acronym{IEEE} floating-point standard, which says @code{-0.0} and "
"@code{0.0} are numerically equal even though other operations can "
"distinguish them."
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:258
#, no-wrap
msgid "positive infinity"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:259
#, no-wrap
msgid "negative infinity"
msgstr ""

#. type: item
#: original_texis/numbers.texi:260 original_texis/numbers.texi:289
#, no-wrap
msgid "infinity"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:261
#, no-wrap
msgid "NaN"
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:272
msgid ""
"The @acronym{IEEE} floating-point standard supports positive infinity and "
"negative infinity as floating-point values.  It also provides for a class of "
"values called NaN, or ``not a number''; numerical functions return such "
"values in cases where there is no correct answer.  For example, @code{(/ 0.0 "
"0.0)} returns a NaN@.  A NaN is never numerically equal to any value, not "
"even to itself.  NaNs carry a sign and a significand, and non-numeric "
"functions treat two NaNs as equal when their signs and significands agree.  "
"Significands of NaNs are machine-dependent, as are the digits in their "
"string representation."
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:276
msgid ""
"NaNs are not available on systems which do not use IEEE floating-point "
"arithmetic; if the read syntax for a NaN is used on a VAX, for example, the "
"reader signals an error."
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:285
msgid ""
"When NaNs and signed zeros are involved, non-numeric functions like "
"@code{eql}, @code{equal}, @code{sxhash-eql}, @code{sxhash-equal} and "
"@code{gethash} determine whether values are indistinguishable, not whether "
"they are numerically equal.  For example, when @var{x} and @var{y} are the "
"same NaN, @code{(equal x y)} returns @code{t} whereas @code{(= x y)} uses "
"numeric comparison and returns @code{nil}; conversely, @code{(equal 0.0 "
"-0.0)} returns @code{nil} whereas @code{(= 0.0 -0.0)} returns @code{t}."
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:287
msgid "Here are read syntaxes for these special floating-point values:"
msgstr ""

#. type: table
#: original_texis/numbers.texi:291
msgid "@samp{1.0e+INF} and @samp{-1.0e+INF}"
msgstr ""

#. type: item
#: original_texis/numbers.texi:291
#, no-wrap
msgid "not-a-number"
msgstr ""

#. type: table
#: original_texis/numbers.texi:293
msgid "@samp{0.0e+NaN} and @samp{-0.0e+NaN}"
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:297
msgid "The following functions are specialized for handling floating-point numbers:"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:298
#, no-wrap
msgid "isnan x"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:301
msgid ""
"This predicate returns @code{t} if its floating-point argument is a NaN, "
"@code{nil} otherwise."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:303
#, no-wrap
msgid "frexp x"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:307
msgid ""
"This function returns a cons cell @code{(@var{s} . @var{e})}, where @var{s} "
"and @var{e} are respectively the significand and exponent of the "
"floating-point number @var{x}."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:310
msgid ""
"If @var{x} is finite, then @var{s} is a floating-point number between 0.5 "
"(inclusive) and 1.0 (exclusive), @var{e} is an integer, and"
msgstr ""

#. type: ifnottex
#: original_texis/numbers.texi:312
msgid "@var{x} = @var{s} * 2**@var{e}."
msgstr ""

#. type: tex
#: original_texis/numbers.texi:315
#, no-wrap
msgid "@math{x = s 2^e}.\n"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:319
msgid ""
"If @var{x} is zero or infinity, then @var{s} is the same as @var{x}.  If "
"@var{x} is a NaN, then @var{s} is also a NaN@.  If @var{x} is zero, then "
"@var{e} is 0."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:321
#, no-wrap
msgid "ldexp s e"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:324
msgid ""
"Given a numeric significand @var{s} and an integer exponent @var{e}, this "
"function returns the floating point number"
msgstr ""

#. type: ifnottex
#: original_texis/numbers.texi:326
msgid "@var{s} * 2**@var{e}."
msgstr ""

#. type: tex
#: original_texis/numbers.texi:329
#, no-wrap
msgid "@math{s 2^e}.\n"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:332
#, no-wrap
msgid "copysign x1 x2"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:335
msgid ""
"This function copies the sign of @var{x2} to the value of @var{x1}, and "
"returns the result.  @var{x1} and @var{x2} must be floating point."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:337
#, no-wrap
msgid "logb x"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:343
msgid ""
"This function returns the binary exponent of @var{x}.  More precisely, if "
"@var{x} is finite and nonzero, the value is the logarithm base 2 of "
"@math{|x|}, rounded down to an integer.  If @var{x} is zero or infinite, the "
"value is infinity; if @var{x} is a NaN, the value is a NaN."
msgstr ""

#. type: example
#: original_texis/numbers.texi:351
#, no-wrap
msgid ""
"(logb 10)\n"
"     @result{} 3\n"
"(logb 10.0e20)\n"
"     @result{} 69\n"
"(logb 0)\n"
"     @result{} -1.0e+INF\n"
msgstr ""

#. type: section
#: original_texis/numbers.texi:355
#, no-wrap
msgid "Type Predicates for Numbers"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:356
#, no-wrap
msgid "predicates for numbers"
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:364
msgid ""
"The functions in this section test for numbers, or for a specific type of "
"number.  The functions @code{integerp} and @code{floatp} can take any type "
"of Lisp object as argument (they would not be of much use otherwise), but "
"the @code{zerop} predicate requires a number as its argument.  See also "
"@code{integer-or-marker-p} and @code{number-or-marker-p}, in @ref{Predicates "
"on Markers}."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:365
#, no-wrap
msgid "bignump object"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:369
msgid ""
"This predicate tests whether its argument is a large integer, and returns "
"@code{t} if so, @code{nil} otherwise.  Unlike small integers, large integers "
"can be @code{=} or @code{eql} even if they are not @code{eq}."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:371
#, no-wrap
msgid "fixnump object"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:375
msgid ""
"This predicate tests whether its argument is a small integer, and returns "
"@code{t} if so, @code{nil} otherwise.  Small integers can be compared with "
"@code{eq}."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:377
#, no-wrap
msgid "floatp object"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:380
msgid ""
"This predicate tests whether its argument is floating point and returns "
"@code{t} if so, @code{nil} otherwise."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:382
#, no-wrap
msgid "integerp object"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:385
msgid ""
"This predicate tests whether its argument is an integer, and returns "
"@code{t} if so, @code{nil} otherwise."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:387
#, no-wrap
msgid "numberp object"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:390
msgid ""
"This predicate tests whether its argument is a number (either integer or "
"floating point), and returns @code{t} if so, @code{nil} otherwise."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:392
#, no-wrap
msgid "natnump object"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:393
#, no-wrap
msgid "natural numbers"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:398
msgid ""
"This predicate (whose name comes from the phrase ``natural number'')  tests "
"to see whether its argument is a nonnegative integer, and returns @code{t} "
"if so, @code{nil} otherwise.  0 is considered non-negative."
msgstr ""

#. type: findex
#: original_texis/numbers.texi:399
#, no-wrap
msgid "wholenump"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:401
msgid "@code{wholenump} is a synonym for @code{natnump}."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:403
#, no-wrap
msgid "zerop number"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:406
msgid ""
"This predicate tests whether its argument is zero, and returns @code{t} if "
"so, @code{nil} otherwise.  The argument must be a number."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:408
msgid "@code{(zerop x)} is equivalent to @code{(= x 0)}."
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:412
#, no-wrap
msgid "number comparison"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:413
#, no-wrap
msgid "comparing numbers"
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:425
msgid ""
"To test numbers for numerical equality, you should normally use @code{=} "
"instead of non-numeric comparison predicates like @code{eq}, @code{eql} and "
"@code{equal}.  Distinct floating-point and large integer objects can be "
"numerically equal.  If you use @code{eq} to compare them, you test whether "
"they are the same @emph{object}; if you use @code{eql} or @code{equal}, you "
"test whether their values are @emph{indistinguishable}.  In contrast, "
"@code{=} uses numeric comparison, and sometimes returns @code{t} when a "
"non-numeric comparison would return @code{nil} and vice versa.  @xref{Float "
"Basics}."
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:434
msgid ""
"In Emacs Lisp, if two fixnums are numerically equal, they are the same Lisp "
"object.  That is, @code{eq} is equivalent to @code{=} on fixnums.  It is "
"sometimes convenient to use @code{eq} for comparing an unknown value with a "
"fixnum, because @code{eq} does not report an error if the unknown value is "
"not a number---it accepts arguments of any type.  By contrast, @code{=} "
"signals an error if the arguments are not numbers or markers.  However, it "
"is better programming practice to use @code{=} if you can, even for "
"comparing integers."
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:440
msgid ""
"Sometimes it is useful to compare numbers with @code{eql} or @code{equal}, "
"which treat two numbers as equal if they have the same data type (both "
"integers, or both floating point) and the same value.  By contrast, @code{=} "
"can treat an integer and a floating-point number as equal.  @xref{Equality "
"Predicates}."
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:445
msgid ""
"There is another wrinkle: because floating-point arithmetic is not exact, it "
"is often a bad idea to check for equality of floating-point values.  Usually "
"it is better to test for approximate equality.  Here's a function to do "
"this:"
msgstr ""

#. type: example
#: original_texis/numbers.texi:453
#, no-wrap
msgid ""
"(defvar fuzz-factor 1.0e-6)\n"
"(defun approx-equal (x y)\n"
"  (or (= x y)\n"
"      (< (/ (abs (- x y))\n"
"            (max (abs x) (abs y)))\n"
"         fuzz-factor)))\n"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:455
#, no-wrap
msgid "= number-or-marker &rest number-or-markers"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:458
msgid ""
"This function tests whether all its arguments are numerically equal, and "
"returns @code{t} if so, @code{nil} otherwise."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:460
#, no-wrap
msgid "eql value1 value2"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:470
msgid ""
"This function acts like @code{eq} except when both arguments are numbers.  "
"It compares numbers by type and numeric value, so that @code{(eql 1.0 1)} "
"returns @code{nil}, but @code{(eql 1.0 1.0)} and @code{(eql 1 1)} both "
"return @code{t}.  This can be used to compare large integers as well as "
"small ones.  Floating-point values with the same sign, exponent and fraction "
"are @code{eql}.  This differs from numeric comparison: @code{(eql 0.0 -0.0)} "
"returns @code{nil} and @code{(eql 0.0e+NaN 0.0e+NaN)} returns @code{t}, "
"whereas @code{=} does the opposite."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:472
#, no-wrap
msgid "/= number-or-marker1 number-or-marker2"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:475
msgid ""
"This function tests whether its arguments are numerically equal, and returns "
"@code{t} if they are not, and @code{nil} if they are."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:477
#, no-wrap
msgid "<  number-or-marker &rest number-or-markers"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:480
msgid ""
"This function tests whether each argument is strictly less than the "
"following argument.  It returns @code{t} if so, @code{nil} otherwise."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:482
#, no-wrap
msgid "<= number-or-marker &rest number-or-markers"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:485
msgid ""
"This function tests whether each argument is less than or equal to the "
"following argument.  It returns @code{t} if so, @code{nil} otherwise."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:487
#, no-wrap
msgid "> number-or-marker &rest number-or-markers"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:490
msgid ""
"This function tests whether each argument is strictly greater than the "
"following argument.  It returns @code{t} if so, @code{nil} otherwise."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:492
#, no-wrap
msgid ">= number-or-marker &rest number-or-markers"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:495
msgid ""
"This function tests whether each argument is greater than or equal to the "
"following argument.  It returns @code{t} if so, @code{nil} otherwise."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:497
#, no-wrap
msgid "max number-or-marker &rest numbers-or-markers"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:499
msgid "This function returns the largest of its arguments."
msgstr ""

#. type: example
#: original_texis/numbers.texi:507
#, no-wrap
msgid ""
"(max 20)\n"
"     @result{} 20\n"
"(max 1 2.5)\n"
"     @result{} 2.5\n"
"(max 1 3 2.5)\n"
"     @result{} 3\n"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:510
#, no-wrap
msgid "min number-or-marker &rest numbers-or-markers"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:512
msgid "This function returns the smallest of its arguments."
msgstr ""

#. type: example
#: original_texis/numbers.texi:516
#, no-wrap
msgid ""
"(min -4 1)\n"
"     @result{} -4\n"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:519
#, no-wrap
msgid "abs number"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:521
msgid "This function returns the absolute value of @var{number}."
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:525
#, no-wrap
msgid "rounding in conversions"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:526
#, no-wrap
msgid "number conversions"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:527
#, no-wrap
msgid "converting numbers"
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:530
msgid "To convert an integer to floating point, use the function @code{float}."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:531
#, no-wrap
msgid "float number"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:535
msgid ""
"This returns @var{number} converted to floating point.  If @var{number} is "
"already floating point, @code{float} returns it unchanged."
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:547
msgid ""
"There are four functions to convert floating-point numbers to integers; they "
"differ in how they round.  All accept an argument @var{number} and an "
"optional argument @var{divisor}.  Both arguments may be integers or "
"floating-point numbers.  @var{divisor} may also be @code{nil}.  If "
"@var{divisor} is @code{nil} or omitted, these functions convert @var{number} "
"to an integer, or return it unchanged if it already is an integer.  If "
"@var{divisor} is non-@code{nil}, they divide @var{number} by @var{divisor} "
"and convert the result to an integer.  If @var{divisor} is zero (whether "
"integer or floating point), Emacs signals an @code{arith-error} error."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:548
#, no-wrap
msgid "truncate number &optional divisor"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:551
msgid "This returns @var{number}, converted to an integer by rounding towards zero."
msgstr ""

#. type: example
#: original_texis/numbers.texi:561
#, no-wrap
msgid ""
"(truncate 1.2)\n"
"     @result{} 1\n"
"(truncate 1.7)\n"
"     @result{} 1\n"
"(truncate -1.2)\n"
"     @result{} -1\n"
"(truncate -1.7)\n"
"     @result{} -1\n"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:564
#, no-wrap
msgid "floor number &optional divisor"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:567
msgid ""
"This returns @var{number}, converted to an integer by rounding downward "
"(towards negative infinity)."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:570
msgid ""
"If @var{divisor} is specified, this uses the kind of division operation that "
"corresponds to @code{mod}, rounding downward."
msgstr ""

#. type: example
#: original_texis/numbers.texi:582
#, no-wrap
msgid ""
"(floor 1.2)\n"
"     @result{} 1\n"
"(floor 1.7)\n"
"     @result{} 1\n"
"(floor -1.2)\n"
"     @result{} -2\n"
"(floor -1.7)\n"
"     @result{} -2\n"
"(floor 5.99 3)\n"
"     @result{} 1\n"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:585
#, no-wrap
msgid "ceiling number &optional divisor"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:588
msgid ""
"This returns @var{number}, converted to an integer by rounding upward "
"(towards positive infinity)."
msgstr ""

#. type: example
#: original_texis/numbers.texi:598
#, no-wrap
msgid ""
"(ceiling 1.2)\n"
"     @result{} 2\n"
"(ceiling 1.7)\n"
"     @result{} 2\n"
"(ceiling -1.2)\n"
"     @result{} -1\n"
"(ceiling -1.7)\n"
"     @result{} -1\n"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:601
#, no-wrap
msgid "round number &optional divisor"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:605
msgid ""
"This returns @var{number}, converted to an integer by rounding towards the "
"nearest integer.  Rounding a value equidistant between two integers returns "
"the even integer."
msgstr ""

#. type: example
#: original_texis/numbers.texi:615
#, no-wrap
msgid ""
"(round 1.2)\n"
"     @result{} 1\n"
"(round 1.7)\n"
"     @result{} 2\n"
"(round -1.2)\n"
"     @result{} -1\n"
"(round -1.7)\n"
"     @result{} -2\n"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:620
#, no-wrap
msgid "arithmetic operations"
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:628
msgid ""
"Emacs Lisp provides the traditional four arithmetic operations (addition, "
"subtraction, multiplication, and division), as well as remainder and modulus "
"functions, and functions to add or subtract 1.  Except for @code{%}, each of "
"these functions accepts both integer and floating-point arguments, and "
"returns a floating-point number if any argument is floating point."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:629
#, no-wrap
msgid "1+ number-or-marker"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:632
msgid "This function returns @var{number-or-marker} plus 1.  For example,"
msgstr ""

#. type: example
#: original_texis/numbers.texi:638
#, no-wrap
msgid ""
"(setq foo 4)\n"
"     @result{} 4\n"
"(1+ foo)\n"
"     @result{} 5\n"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:642
msgid ""
"This function is not analogous to the C operator @code{++}---it does not "
"increment a variable.  It just computes a sum.  Thus, if we continue,"
msgstr ""

#. type: example
#: original_texis/numbers.texi:646
#, no-wrap
msgid ""
"foo\n"
"     @result{} 4\n"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:650
msgid "If you want to increment the variable, you must use @code{setq}, like this:"
msgstr ""

#. type: example
#: original_texis/numbers.texi:654
#, no-wrap
msgid ""
"(setq foo (1+ foo))\n"
"     @result{} 5\n"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:657
#, no-wrap
msgid "1- number-or-marker"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:659
msgid "This function returns @var{number-or-marker} minus 1."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:661
#, no-wrap
msgid "+ &rest numbers-or-markers"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:664
msgid ""
"This function adds its arguments together.  When given no arguments, "
"@code{+} returns 0."
msgstr ""

#. type: example
#: original_texis/numbers.texi:672
#, no-wrap
msgid ""
"(+)\n"
"     @result{} 0\n"
"(+ 1)\n"
"     @result{} 1\n"
"(+ 1 2 3 4)\n"
"     @result{} 10\n"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:675
#, no-wrap
msgid "- &optional number-or-marker &rest more-numbers-or-markers"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:681
msgid ""
"The @code{-} function serves two purposes: negation and subtraction.  When "
"@code{-} has a single argument, the value is the negative of the argument.  "
"When there are multiple arguments, @code{-} subtracts each of the "
"@var{more-numbers-or-markers} from @var{number-or-marker}, cumulatively.  If "
"there are no arguments, the result is 0."
msgstr ""

#. type: example
#: original_texis/numbers.texi:689
#, no-wrap
msgid ""
"(- 10 1 2 3 4)\n"
"     @result{} 0\n"
"(- 10)\n"
"     @result{} -10\n"
"(-)\n"
"     @result{} 0\n"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:692
#, no-wrap
msgid "* &rest numbers-or-markers"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:695
msgid ""
"This function multiplies its arguments together, and returns the product.  "
"When given no arguments, @code{*} returns 1."
msgstr ""

#. type: example
#: original_texis/numbers.texi:703
#, no-wrap
msgid ""
"(*)\n"
"     @result{} 1\n"
"(* 1)\n"
"     @result{} 1\n"
"(* 1 2 3 4)\n"
"     @result{} 24\n"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:706
#, no-wrap
msgid "/ number &rest divisors"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:712
msgid ""
"With one or more @var{divisors}, this function divides @var{number} by each "
"divisor in @var{divisors} in turn, and returns the quotient.  With no "
"@var{divisors}, this function returns 1/@var{number}, i.e., the "
"multiplicative inverse of @var{number}.  Each argument may be a number or a "
"marker."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:715
msgid ""
"If all the arguments are integers, the result is an integer, obtained by "
"rounding the quotient towards zero after each division."
msgstr ""

#. type: group
#: original_texis/numbers.texi:720
#, no-wrap
msgid ""
"(/ 6 2)\n"
"     @result{} 3\n"
msgstr ""

#. type: group
#: original_texis/numbers.texi:724
#, no-wrap
msgid ""
"(/ 5 2)\n"
"     @result{} 2\n"
msgstr ""

#. type: group
#: original_texis/numbers.texi:728
#, no-wrap
msgid ""
"(/ 5.0 2)\n"
"     @result{} 2.5\n"
msgstr ""

#. type: group
#: original_texis/numbers.texi:732
#, no-wrap
msgid ""
"(/ 5 2.0)\n"
"     @result{} 2.5\n"
msgstr ""

#. type: group
#: original_texis/numbers.texi:736
#, no-wrap
msgid ""
"(/ 5.0 2.0)\n"
"     @result{} 2.5\n"
msgstr ""

#. type: group
#: original_texis/numbers.texi:740
#, no-wrap
msgid ""
"(/ 4.0)\n"
"     @result{} 0.25\n"
msgstr ""

#. type: group
#: original_texis/numbers.texi:744
#, no-wrap
msgid ""
"(/ 4)\n"
"     @result{} 0\n"
msgstr ""

#. type: group
#: original_texis/numbers.texi:748
#, no-wrap
msgid ""
"(/ 25 3 2)\n"
"     @result{} 4\n"
msgstr ""

#. type: group
#: original_texis/numbers.texi:752
#, no-wrap
msgid ""
"(/ -17 6)\n"
"     @result{} -2\n"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:755
#, no-wrap
msgid "@code{arith-error} in division"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:761
msgid ""
"If you divide an integer by the integer 0, Emacs signals an "
"@code{arith-error} error (@pxref{Errors}).  On systems using IEEE-754 "
"floating-point, floating-point division of a nonzero number by zero yields "
"either positive or negative infinity (@pxref{Float Basics}); otherwise, an "
"@code{arith-error} is signaled as usual."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:763
#, no-wrap
msgid "% dividend divisor"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:764
#, no-wrap
msgid "remainder"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:767
msgid ""
"This function returns the integer remainder after division of @var{dividend} "
"by @var{divisor}.  The arguments must be integers or markers."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:769
msgid "For any two integers @var{dividend} and @var{divisor},"
msgstr ""

#. type: group
#: original_texis/numbers.texi:774
#, no-wrap
msgid ""
"(+ (% @var{dividend} @var{divisor})\n"
"   (* (/ @var{dividend} @var{divisor}) @var{divisor}))\n"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:779
msgid "always equals @var{dividend} if @var{divisor} is nonzero."
msgstr ""

#. type: example
#: original_texis/numbers.texi:789
#, no-wrap
msgid ""
"(% 9 4)\n"
"     @result{} 1\n"
"(% -9 4)\n"
"     @result{} -1\n"
"(% 9 -4)\n"
"     @result{} 1\n"
"(% -9 -4)\n"
"     @result{} -1\n"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:792
#, no-wrap
msgid "mod dividend divisor"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:793
#, no-wrap
msgid "modulus"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:798
msgid ""
"This function returns the value of @var{dividend} modulo @var{divisor}; in "
"other words, the remainder after division of @var{dividend} by "
"@var{divisor}, but with the same sign as @var{divisor}.  The arguments must "
"be numbers or markers."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:802
msgid ""
"Unlike @code{%}, @code{mod} permits floating-point arguments; it rounds the "
"quotient downward (towards minus infinity) to an integer, and uses that "
"quotient to compute the remainder."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:805
msgid ""
"If @var{divisor} is zero, @code{mod} signals an @code{arith-error} error if "
"both arguments are integers, and returns a NaN otherwise."
msgstr ""

#. type: group
#: original_texis/numbers.texi:810
#, no-wrap
msgid ""
"(mod 9 4)\n"
"     @result{} 1\n"
msgstr ""

#. type: group
#: original_texis/numbers.texi:814
#, no-wrap
msgid ""
"(mod -9 4)\n"
"     @result{} 3\n"
msgstr ""

#. type: group
#: original_texis/numbers.texi:818
#, no-wrap
msgid ""
"(mod 9 -4)\n"
"     @result{} -3\n"
msgstr ""

#. type: group
#: original_texis/numbers.texi:822
#, no-wrap
msgid ""
"(mod -9 -4)\n"
"     @result{} -1\n"
msgstr ""

#. type: group
#: original_texis/numbers.texi:826
#, no-wrap
msgid ""
"(mod 5.5 2.5)\n"
"     @result{} .5\n"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:830
msgid "For any two numbers @var{dividend} and @var{divisor},"
msgstr ""

#. type: group
#: original_texis/numbers.texi:835
#, no-wrap
msgid ""
"(+ (mod @var{dividend} @var{divisor})\n"
"   (* (floor @var{dividend} @var{divisor}) @var{divisor}))\n"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:843
msgid ""
"always equals @var{dividend}, subject to rounding error if either argument "
"is floating point and to an @code{arith-error} if @var{dividend} is an "
"integer and @var{divisor} is 0.  For @code{floor}, see @ref{Numeric "
"Conversions}."
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:847
#, no-wrap
msgid "rounding without conversion"
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:855
msgid ""
"The functions @code{ffloor}, @code{fceiling}, @code{fround}, and "
"@code{ftruncate} take a floating-point argument and return a floating-point "
"result whose value is a nearby integer.  @code{ffloor} returns the nearest "
"integer below; @code{fceiling}, the nearest integer above; @code{ftruncate}, "
"the nearest integer in the direction towards zero; @code{fround}, the "
"nearest integer."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:856
#, no-wrap
msgid "ffloor float"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:859
msgid ""
"This function rounds @var{float} to the next lower integral value, and "
"returns that value as a floating-point number."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:861
#, no-wrap
msgid "fceiling float"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:864
msgid ""
"This function rounds @var{float} to the next higher integral value, and "
"returns that value as a floating-point number."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:866
#, no-wrap
msgid "ftruncate float"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:869
msgid ""
"This function rounds @var{float} towards zero to an integral value, and "
"returns that value as a floating-point number."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:871
#, no-wrap
msgid "fround float"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:875
msgid ""
"This function rounds @var{float} to the nearest integral value, and returns "
"that value as a floating-point number.  Rounding a value equidistant between "
"two integers returns the even integer."
msgstr ""

#. type: section
#: original_texis/numbers.texi:878
#, no-wrap
msgid "Bitwise Operations on Integers"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:879
#, no-wrap
msgid "bitwise arithmetic"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:880
#, no-wrap
msgid "logical arithmetic"
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:889
msgid ""
"In a computer, an integer is represented as a binary number, a sequence of "
"@dfn{bits} (digits which are either zero or one).  Conceptually the bit "
"sequence is infinite on the left, with the most-significant bits being all "
"zeros or all ones.  A bitwise operation acts on the individual bits of such "
"a sequence.  For example, @dfn{shifting} moves the whole sequence left or "
"right one or more places, reproducing the same pattern moved over."
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:891
msgid "The bitwise operations in Emacs Lisp apply only to integers."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:892
#, no-wrap
msgid "ash integer1 count"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:893
#, no-wrap
msgid "arithmetic shift"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:899
msgid ""
"@code{ash} (@dfn{arithmetic shift}) shifts the bits in @var{integer1} to the "
"left @var{count} places, or to the right if @var{count} is negative.  Left "
"shifts introduce zero bits on the right; right shifts discard the rightmost "
"bits.  Considered as an integer operation, @code{ash} multiplies "
"@var{integer1} by"
msgstr ""

#. type: ifnottex
#: original_texis/numbers.texi:901
msgid "2**@var{count},"
msgstr ""

#. type: tex
#: original_texis/numbers.texi:904
#, no-wrap
msgid "@math{2^{count}},\n"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:907
msgid ""
"and then converts the result to an integer by rounding downward, toward "
"minus infinity."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:914
msgid ""
"Here are examples of @code{ash}, shifting a pattern of bits one place to the "
"left and to the right.  These examples show only the low-order bits of the "
"binary pattern; leading bits all agree with the highest-order bit shown.  As "
"you can see, shifting left by one is equivalent to multiplying by two, "
"whereas shifting right by one is equivalent to dividing by two and then "
"rounding toward minus infinity."
msgstr ""

#. type: group
#: original_texis/numbers.texi:922
#, no-wrap
msgid ""
"(ash 7 1) @result{} 14\n"
";; @r{Decimal 7 becomes decimal 14.}\n"
"@dots{}000111\n"
"     @result{}\n"
"@dots{}001110\n"
msgstr ""

#. type: group
#: original_texis/numbers.texi:929
#, no-wrap
msgid ""
"(ash 7 -1) @result{} 3\n"
"@dots{}000111\n"
"     @result{}\n"
"@dots{}000011\n"
msgstr ""

#. type: group
#: original_texis/numbers.texi:936
#, no-wrap
msgid ""
"(ash -7 1) @result{} -14\n"
"@dots{}111001\n"
"     @result{}\n"
"@dots{}110010\n"
msgstr ""

#. type: group
#: original_texis/numbers.texi:943
#, no-wrap
msgid ""
"(ash -7 -1) @result{} -4\n"
"@dots{}111001\n"
"     @result{}\n"
"@dots{}111100\n"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:947
msgid "Here are examples of shifting left or right by two bits:"
msgstr ""

#. type: group
#: original_texis/numbers.texi:955
#, no-wrap
msgid ""
"                  ;  @r{       binary values}\n"
"(ash 5 2)         ;   5  =  @r{@dots{}000101}\n"
"     @result{} 20         ;      =  @r{@dots{}010100}\n"
"(ash -5 2)        ;  -5  =  @r{@dots{}111011}\n"
"     @result{} -20        ;      =  @r{@dots{}101100}\n"
msgstr ""

#. type: group
#: original_texis/numbers.texi:959
#, no-wrap
msgid ""
"(ash 5 -2)\n"
"     @result{} 1          ;      =  @r{@dots{}000001}\n"
msgstr ""

#. type: group
#: original_texis/numbers.texi:963
#, no-wrap
msgid ""
"(ash -5 -2)\n"
"     @result{} -2         ;      =  @r{@dots{}111110}\n"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:967
#, no-wrap
msgid "lsh integer1 count"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:968
#, no-wrap
msgid "logical shift"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:978
msgid ""
"@code{lsh}, which is an abbreviation for @dfn{logical shift}, shifts the "
"bits in @var{integer1} to the left @var{count} places, or to the right if "
"@var{count} is negative, bringing zeros into the vacated bits.  If "
"@var{count} is negative, then @var{integer1} must be either a fixnum or a "
"positive bignum, and @code{lsh} treats a negative fixnum as if it were "
"unsigned by subtracting twice @code{most-negative-fixnum} before shifting, "
"producing a nonnegative result.  This quirky behavior dates back to when "
"Emacs supported only fixnums; nowadays @code{ash} is a better choice."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:982
msgid ""
"As @code{lsh} behaves like @code{ash} except when @var{integer1} and "
"@var{count1} are both negative, the following examples focus on these "
"exceptional cases.  These examples assume 30-bit fixnums."
msgstr ""

#. type: group
#: original_texis/numbers.texi:990
#, no-wrap
msgid ""
"                 ; @r{     binary values}\n"
"(ash -7 -1)      ; -7 = @r{@dots{}111111111111111111111111111001}\n"
"     @result{} -4        ;    = @r{@dots{}111111111111111111111111111100}\n"
"(lsh -7 -1)\n"
"     @result{} 536870908 ;    = @r{@dots{}011111111111111111111111111100}\n"
msgstr ""

#. type: group
#: original_texis/numbers.texi:996
#, no-wrap
msgid ""
"(ash -5 -2)      ; -5 = @r{@dots{}111111111111111111111111111011}\n"
"     @result{} -2        ;    = @r{@dots{}111111111111111111111111111110}\n"
"(lsh -5 -2)\n"
"     @result{} 268435454 ;    = @r{@dots{}001111111111111111111111111110}\n"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1000
#, no-wrap
msgid "logand &rest ints-or-markers"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1004
msgid ""
"This function returns the bitwise AND of the arguments: the @var{n}th bit is "
"1 in the result if, and only if, the @var{n}th bit is 1 in all the "
"arguments."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1011
msgid ""
"For example, using 4-bit binary numbers, the bitwise AND of 13 and 12 is 12: "
"1101 combined with 1100 produces 1100.  In both the binary numbers, the "
"leftmost two bits are both 1 so the leftmost two bits of the returned value "
"are both 1.  However, for the rightmost two bits, each is 0 in at least one "
"of the arguments, so the rightmost two bits of the returned value are both "
"0."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1014
msgid "Therefore,"
msgstr ""

#. type: group
#: original_texis/numbers.texi:1019
#, no-wrap
msgid ""
"(logand 13 12)\n"
"     @result{} 12\n"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1026
msgid ""
"If @code{logand} is not passed any argument, it returns a value of "
"@minus{}1.  This number is an identity element for @code{logand} because its "
"binary representation consists entirely of ones.  If @code{logand} is passed "
"just one argument, it returns that argument."
msgstr ""

#. type: group
#: original_texis/numbers.texi:1030 original_texis/numbers.texi:1060
#: original_texis/numbers.texi:1085
#, no-wrap
msgid ""
"                   ; @r{       binary values}\n"
"\n"
msgstr ""

#. type: group
#: original_texis/numbers.texi:1034
#, no-wrap
msgid ""
"(logand 14 13)     ; 14  =  @r{@dots{}001110}\n"
"                   ; 13  =  @r{@dots{}001101}\n"
"     @result{} 12         ; 12  =  @r{@dots{}001100}\n"
msgstr ""

#. type: group
#: original_texis/numbers.texi:1041
#, no-wrap
msgid ""
"(logand 14 13 4)   ; 14  =  @r{@dots{}001110}\n"
"                   ; 13  =  @r{@dots{}001101}\n"
"                   ;  4  =  @r{@dots{}000100}\n"
"     @result{} 4          ;  4  =  @r{@dots{}000100}\n"
msgstr ""

#. type: group
#: original_texis/numbers.texi:1046
#, no-wrap
msgid ""
"(logand)\n"
"     @result{} -1         ; -1  =  @r{@dots{}111111}\n"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1050
#, no-wrap
msgid "logior &rest ints-or-markers"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1056
msgid ""
"This function returns the bitwise inclusive OR of its arguments: the "
"@var{n}th bit is 1 in the result if, and only if, the @var{n}th bit is 1 in "
"at least one of the arguments.  If there are no arguments, the result is 0, "
"which is an identity element for this operation.  If @code{logior} is passed "
"just one argument, it returns that argument."
msgstr ""

#. type: group
#: original_texis/numbers.texi:1064
#, no-wrap
msgid ""
"(logior 12 5)      ; 12  =  @r{@dots{}001100}\n"
"                   ;  5  =  @r{@dots{}000101}\n"
"     @result{} 13         ; 13  =  @r{@dots{}001101}\n"
msgstr ""

#. type: group
#: original_texis/numbers.texi:1071
#, no-wrap
msgid ""
"(logior 12 5 7)    ; 12  =  @r{@dots{}001100}\n"
"                   ;  5  =  @r{@dots{}000101}\n"
"                   ;  7  =  @r{@dots{}000111}\n"
"     @result{} 15         ; 15  =  @r{@dots{}001111}\n"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1075
#, no-wrap
msgid "logxor &rest ints-or-markers"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1081
msgid ""
"This function returns the bitwise exclusive OR of its arguments: the "
"@var{n}th bit is 1 in the result if, and only if, the @var{n}th bit is 1 in "
"an odd number of the arguments.  If there are no arguments, the result is 0, "
"which is an identity element for this operation.  If @code{logxor} is passed "
"just one argument, it returns that argument."
msgstr ""

#. type: group
#: original_texis/numbers.texi:1089
#, no-wrap
msgid ""
"(logxor 12 5)      ; 12  =  @r{@dots{}001100}\n"
"                   ;  5  =  @r{@dots{}000101}\n"
"     @result{} 9          ;  9  =  @r{@dots{}001001}\n"
msgstr ""

#. type: group
#: original_texis/numbers.texi:1096
#, no-wrap
msgid ""
"(logxor 12 5 7)    ; 12  =  @r{@dots{}001100}\n"
"                   ;  5  =  @r{@dots{}000101}\n"
"                   ;  7  =  @r{@dots{}000111}\n"
"     @result{} 14         ; 14  =  @r{@dots{}001110}\n"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1100
#, no-wrap
msgid "lognot integer"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1105
msgid ""
"This function returns the bitwise complement of its argument: the @var{n}th "
"bit is one in the result if, and only if, the @var{n}th bit is zero in "
"@var{integer}, and vice-versa.  The result equals @minus{}1 @minus{} "
"@var{integer}."
msgstr ""

#. type: example
#: original_texis/numbers.texi:1112
#, no-wrap
msgid ""
"(lognot 5)\n"
"     @result{} -6\n"
";;  5  =  @r{@dots{}000101}\n"
";; @r{becomes}\n"
";; -6  =  @r{@dots{}111010}\n"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:1115
#, no-wrap
msgid "popcount"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:1116
#, no-wrap
msgid "Hamming weight"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:1117
#, no-wrap
msgid "counting set bits"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1118
#, no-wrap
msgid "logcount integer"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1124
msgid ""
"This function returns the @dfn{Hamming weight} of @var{integer}: the number "
"of ones in the binary representation of @var{integer}.  If @var{integer} is "
"negative, it returns the number of zero bits in its two's complement binary "
"representation.  The result is always nonnegative."
msgstr ""

#. type: example
#: original_texis/numbers.texi:1130
#, no-wrap
msgid ""
"(logcount 43)     ;  43 = @r{@dots{}000101011}\n"
"     @result{} 4\n"
"(logcount -43)    ; -43 = @r{@dots{}111010101}\n"
"     @result{} 3\n"
msgstr ""

#. type: section
#: original_texis/numbers.texi:1134
#, no-wrap
msgid "Standard Mathematical Functions"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:1135
#, no-wrap
msgid "transcendental functions"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:1136
#, no-wrap
msgid "mathematical functions"
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:1137
#, no-wrap
msgid "floating-point functions"
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:1141
msgid ""
"These mathematical functions allow integers as well as floating-point "
"numbers as arguments."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1142
#, no-wrap
msgid "sin arg"
msgstr ""

#. type: defunx
#: original_texis/numbers.texi:1143
#, no-wrap
msgid "cos arg"
msgstr ""

#. type: defunx
#: original_texis/numbers.texi:1144
#, no-wrap
msgid "tan arg"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1147
msgid ""
"These are the basic trigonometric functions, with argument @var{arg} "
"measured in radians."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1149
#, no-wrap
msgid "asin arg"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1151
msgid "The value of @code{(asin @var{arg})} is a number between"
msgstr ""

#. type: ifnottex
#: original_texis/numbers.texi:1153 original_texis/numbers.texi:1184
msgid "@minus{}pi/2"
msgstr ""

#. type: tex
#: original_texis/numbers.texi:1156 original_texis/numbers.texi:1187
#, no-wrap
msgid "@math{-\\pi/2}\n"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1158 original_texis/numbers.texi:1189
msgid "and"
msgstr ""

#. type: ifnottex
#: original_texis/numbers.texi:1160 original_texis/numbers.texi:1191
msgid "pi/2"
msgstr ""

#. type: tex
#: original_texis/numbers.texi:1163 original_texis/numbers.texi:1194
#, no-wrap
msgid "@math{\\pi/2}\n"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1166
msgid ""
"(inclusive) whose sine is @var{arg}.  If @var{arg} is out of range (outside "
"[@minus{}1, 1]), @code{asin} returns a NaN."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1168
#, no-wrap
msgid "acos arg"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1170
msgid "The value of @code{(acos @var{arg})} is a number between 0 and"
msgstr ""

#. type: ifnottex
#: original_texis/numbers.texi:1172
msgid "pi"
msgstr ""

#. type: tex
#: original_texis/numbers.texi:1175
#, no-wrap
msgid "@math{\\pi}\n"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1178
msgid ""
"(inclusive) whose cosine is @var{arg}.  If @var{arg} is out of range "
"(outside [@minus{}1, 1]), @code{acos} returns a NaN."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1180
#, no-wrap
msgid "atan y &optional x"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1182
msgid "The value of @code{(atan @var{y})} is a number between"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1199
msgid ""
"(exclusive) whose tangent is @var{y}.  If the optional second argument "
"@var{x} is given, the value of @code{(atan y x)} is the angle in radians "
"between the vector @code{[@var{x}, @var{y}]} and the @code{X} axis."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1201
#, no-wrap
msgid "exp arg"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1204
msgid ""
"This is the exponential function; it returns @math{e} to the power "
"@var{arg}."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1206
#, no-wrap
msgid "log arg &optional base"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1211
msgid ""
"This function returns the logarithm of @var{arg}, with base @var{base}.  If "
"you don't specify @var{base}, the natural base @math{e} is used.  If "
"@var{arg} or @var{base} is negative, @code{log} returns a NaN."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1213
#, no-wrap
msgid "expt x y"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1219
msgid ""
"This function returns @var{x} raised to power @var{y}.  If both arguments "
"are integers and @var{y} is nonnegative, the result is an integer; in this "
"case, overflow signals an error, so watch out.  If @var{x} is a finite "
"negative number and @var{y} is a finite non-integer, @code{expt} returns a "
"NaN."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1221
#, no-wrap
msgid "sqrt arg"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1224
msgid ""
"This returns the square root of @var{arg}.  If @var{arg} is finite and less "
"than zero, @code{sqrt} returns a NaN."
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:1228
msgid "In addition, Emacs defines the following common mathematical constants:"
msgstr ""

#. type: defvar
#: original_texis/numbers.texi:1229
#, no-wrap
msgid "float-e"
msgstr ""

#. type: defvar
#: original_texis/numbers.texi:1231
msgid "The mathematical constant @math{e} (2.71828@dots{})."
msgstr ""

#. type: defvar
#: original_texis/numbers.texi:1233
#, no-wrap
msgid "float-pi"
msgstr ""

#. type: defvar
#: original_texis/numbers.texi:1235
msgid "The mathematical constant @math{pi} (3.14159@dots{})."
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:1239
#, no-wrap
msgid "random numbers"
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:1247
msgid ""
"A deterministic computer program cannot generate true random numbers.  For "
"most purposes, @dfn{pseudo-random numbers} suffice.  A series of "
"pseudo-random numbers is generated in a deterministic fashion.  The numbers "
"are not truly random, but they have certain properties that mimic a random "
"series.  For example, all possible values occur equally often in a "
"pseudo-random series."
msgstr ""

#. type: cindex
#: original_texis/numbers.texi:1248
#, no-wrap
msgid "seed, for random number generation"
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:1257
msgid ""
"Pseudo-random numbers are generated from a @dfn{seed value}.  Starting from "
"any given seed, the @code{random} function always generates the same "
"sequence of numbers.  By default, Emacs initializes the random seed at "
"startup, in such a way that the sequence of values of @code{random} (with "
"overwhelming likelihood) differs in each Emacs run.  The random seed is "
"typically initialized from system entropy; however, on obsolescent platforms "
"lacking entropy pools, the seed is taken from less-random volatile data such "
"as the current time."
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:1265
msgid ""
"Sometimes you want the random number sequence to be repeatable.  For "
"example, when debugging a program whose behavior depends on the random "
"number sequence, it is helpful to get the same behavior in each program "
"run.  To make the sequence repeat, execute @code{(random \"\")}.  This sets "
"the seed to a constant value for your particular Emacs executable (though it "
"may differ for other Emacs builds).  You can use other strings to choose "
"various seed values."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1266
#, no-wrap
msgid "random &optional limit"
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1269
msgid ""
"This function returns a pseudo-random integer.  Repeated calls return a "
"series of pseudo-random integers."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1274
msgid ""
"If @var{limit} is a positive integer, the value is chosen to be nonnegative "
"and less than @var{limit}.  Otherwise, the value might be any fixnum, i.e., "
"any integer from @code{most-negative-fixnum} through "
"@code{most-positive-fixnum} (@pxref{Integer Basics})."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1278
msgid ""
"If @var{limit} is a string, it means to choose a new seed based on the "
"string's contents.  This causes later calls to @code{random} to return a "
"reproducible sequence of results."
msgstr ""

#. type: defun
#: original_texis/numbers.texi:1282
msgid ""
"If @var{limit} is @code{t}, it means to choose a new seed as if Emacs were "
"restarting.  This causes later calls to @code{random} to return an "
"unpredictable sequence of results."
msgstr ""

#. type: Plain text
#: original_texis/numbers.texi:1287
msgid ""
"If you need a random nonce for cryptographic purposes, using @code{random} "
"is typically not the best approach, for several reasons:"
msgstr ""

#. type: itemize
#: original_texis/numbers.texi:1293
msgid ""
"Although you can use @code{(random t)} to consult system entropy, doing so "
"can adversely affect other parts of your program that benefit from "
"reproducible results."
msgstr ""

#. type: itemize
#: original_texis/numbers.texi:1297
msgid ""
"The system-dependent pseudo-random number generator (PRNG) used by "
"@code{random} is not necessarily suitable for cryptography."
msgstr ""

#. type: itemize
#: original_texis/numbers.texi:1302
msgid ""
"A call to @code{(random t)} does not give direct access to system entropy; "
"the entropy is passed through the system-dependent PRNG, thus possibly "
"biasing the results."
msgstr ""

#. type: itemize
#: original_texis/numbers.texi:1307
msgid ""
"On typical platforms the random seed contains only 32 bits, which is "
"typically narrower than an Emacs fixnum, and is not nearly enough for "
"cryptographic purposes."
msgstr ""

#. type: itemize
#: original_texis/numbers.texi:1312
msgid ""
"A @code{(random t)} call leaves information about the nonce scattered about "
"Emacs's internal state, increasing the size of the internal attack surface."
msgstr ""

#. type: itemize
#: original_texis/numbers.texi:1316
msgid ""
"On obsolescent platforms lacking entropy pools, @code{(random t)} is seeded "
"from a cryptographically weak source."
msgstr ""
