# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Emacs 26.1\n"
"POT-Creation-Date: 2020-03-08 09:40+0900\n"
"PO-Revision-Date: 2020-03-15 05:37+0900\n"
"Last-Translator: Takeshi Ayanokoji <takeshi.ayanokoji@gmail.com>\n"
"Language-Team: Japanese <takeshi.ayanokoji@gmail.com>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: original_texis/control.texi:6 original_texis/control.texi:7
#, no-wrap
msgid "Control Structures"
msgstr "Control Structures"

#. type: cindex
#: original_texis/control.texi:8
#, no-wrap
msgid "special forms for control structures"
msgstr "special forms for control structures"

#. type: cindex
#: original_texis/control.texi:9
#, no-wrap
msgid "control structures"
msgstr "control structures"

#. type: Plain text
#: original_texis/control.texi:16
msgid "A Lisp program consists of a set of @dfn{expressions}, or @dfn{forms} (@pxref{Forms}).  We control the order of execution of these forms by enclosing them in @dfn{control structures}.  Control structures are special forms which control when, whether, or how many times to execute the forms they contain."
msgstr "Lispプログラムは一連の@dfn{式}、あるいは@dfn{フォーム} (@ref{Forms}を参照)により形成されます。これらのフォームの実行順は@dfn{制御構造(control structures)}で囲むことによって制御します。制御構造とはその制御構造が含むフォームをいつ、どのような条件で、何回実行するかを制御するスペシャルフォームです。"

#. type: cindex
#: original_texis/control.texi:17
#, no-wrap
msgid "textual order"
msgstr "textual order"

#. type: Plain text
#: original_texis/control.texi:26
msgid "The simplest order of execution is sequential execution: first form @var{a}, then form @var{b}, and so on.  This is what happens when you write several forms in succession in the body of a function, or at top level in a file of Lisp code---the forms are executed in the order written.  We call this @dfn{textual order}.  For example, if a function body consists of two forms @var{a} and @var{b}, evaluation of the function evaluates first @var{a} and then @var{b}.  The result of evaluating @var{b} becomes the value of the function."
msgstr "もっとも単純な実行順は1番目は@var{a}、2番目は@var{b}、...というシーケンシャル実行(sequential execution: 順番に実行)です。これは関数のbody内の連続する複数のフォームや、Lispコードのファイル内のトップレベルを記述したときに発生します --- つまりフォームは記述した順に実行されます。わたしたちはこれを@dfn{テキスト順(textual order)}と呼びます。たとえば関数のbodyが2つのフォーム@var{a}と@var{b}から構成される場合、関数の評価は最初に@var{a}、次に@var{b}を評価します。@var{b}を評価した結果がその関数の値となります。"

#. type: Plain text
#: original_texis/control.texi:29
msgid "Explicit control structures make possible an order of execution other than sequential."
msgstr "明示的に制御構造を使用することにより、非シーケンシャルな順番での実行が可能になります。"

#. type: Plain text
#: original_texis/control.texi:36
msgid "Emacs Lisp provides several kinds of control structure, including other varieties of sequencing, conditionals, iteration, and (controlled)  jumps---all discussed below.  The built-in control structures are special forms since their subforms are not necessarily evaluated or not evaluated sequentially.  You can use macros to define your own control structure constructs (@pxref{Macros})."
msgstr "Emacs Lispは他の様々な順序づけ、条件、繰り返し、(制御された)ジャンプを含む複数の種類の制御構造を提供しており、以下ではそれらのすべてを記述します。ビルトインの制御構造は制御構造のサブフォームが評価される必要がなかったり、順番に評価される必要がないのでスペシャルフォームです。独自の制御構造を構築するためにマクロを使用することができます(@ref{Macros}を参照)。"

#. type: section
#: original_texis/control.texi:44 original_texis/control.texi:46
#: original_texis/control.texi:47
#, no-wrap
msgid "Sequencing"
msgstr "Sequencing"

#. type: menuentry
#: original_texis/control.texi:44
msgid "Evaluation in textual order."
msgstr "テキスト順の評価。"

#. type: section
#: original_texis/control.texi:44 original_texis/control.texi:145
#: original_texis/control.texi:146
#, no-wrap
msgid "Conditionals"
msgstr "Conditionals"

#. type: menuentry
#: original_texis/control.texi:44
msgid "@code{if}, @code{cond}, @code{when}, @code{unless}."
msgstr "@code{if}、@code{cond}、@code{when}、@code{unless}。"

#. type: node
#: original_texis/control.texi:44 original_texis/control.texi:499
#, no-wrap
msgid "Combining Conditions"
msgstr "Combining Conditions"

#. type: menuentry
#: original_texis/control.texi:44
msgid "@code{and}, @code{or}, @code{not}."
msgstr "@code{and}、@code{or}、@code{not}。"

#. type: section
#: original_texis/control.texi:44 original_texis/control.texi:624
#: original_texis/control.texi:625
#, no-wrap
msgid "Iteration"
msgstr "Iteration"

#. type: menuentry
#: original_texis/control.texi:44
msgid "@code{while} loops."
msgstr "@code{while}ループ。"

#. type: section
#: original_texis/control.texi:44 original_texis/control.texi:714
#: original_texis/control.texi:715
#, no-wrap
msgid "Generators"
msgstr "Generators"

#. type: menuentry
#: original_texis/control.texi:44
msgid "Generic sequences and coroutines."
msgstr "汎用のシーケンスとコルーチン。"

#. type: section
#: original_texis/control.texi:44 original_texis/control.texi:832
#: original_texis/control.texi:833
#, no-wrap
msgid "Nonlocal Exits"
msgstr "Nonlocal Exits"

#. type: menuentry
#: original_texis/control.texi:44
msgid "Jumping out of a sequence."
msgstr "シーケンスの外へのジャンプ。"

#. type: cindex
#: original_texis/control.texi:48
#, no-wrap
msgid "sequencing"
msgstr "sequencing"

#. type: cindex
#: original_texis/control.texi:49
#, no-wrap
msgid "sequential execution"
msgstr "sequential execution"

#. type: Plain text
#: original_texis/control.texi:56
msgid "Evaluating forms in the order they appear is the most common way control passes from one form to another.  In some contexts, such as in a function body, this happens automatically.  Elsewhere you must use a control structure construct to do this: @code{progn}, the simplest control construct of Lisp."
msgstr "フォームを出現順に評価するのは、あるフォームから別のフォームに制御を渡すもっとも一般的な制御です。関数のbodyのようなコンテキストにおいては自動的にこれが行なわれます。他の場所ではこれを行なうために制御構造を使用しなければなりません。Lispで一単純な制御構造は@code{progn}です。"

#. type: Plain text
#: original_texis/control.texi:58
msgid "A @code{progn} special form looks like this:"
msgstr "スペシャルフォーム@code{progn}は以下のようなものです:"

#. type: group
#: original_texis/control.texi:62
#, no-wrap
msgid "(progn @var{a} @var{b} @var{c} @dots{})\n"
msgstr "(progn @var{a} @var{b} @var{c} @dots{})\n"

#. type: Plain text
#: original_texis/control.texi:70
msgid "and it says to execute the forms @var{a}, @var{b}, @var{c}, and so on, in that order.  These forms are called the @dfn{body} of the @code{progn} form.  The value of the last form in the body becomes the value of the entire @code{progn}.  @code{(progn)} returns @code{nil}."
msgstr "これは順番に@var{a}、@var{b}、@var{c}、...を実行するよう指定します。これらは@code{progn}フォームの@dfn{body}と呼ばれます。body内の最後のフォームの値が@code{progn}全体の値になります。@code{(progn)}は@code{nil}をリターンします。"

#. type: cindex
#: original_texis/control.texi:71
#, no-wrap
msgid "implicit @code{progn}"
msgstr "implicit @code{progn}"

#. type: Plain text
#: original_texis/control.texi:82
msgid "In the early days of Lisp, @code{progn} was the only way to execute two or more forms in succession and use the value of the last of them.  But programmers found they often needed to use a @code{progn} in the body of a function, where (at that time) only one form was allowed.  So the body of a function was made into an implicit @code{progn}: several forms are allowed just as in the body of an actual @code{progn}.  Many other control structures likewise contain an implicit @code{progn}.  As a result, @code{progn} is not used as much as it was many years ago.  It is needed now most often inside an @code{unwind-protect}, @code{and}, @code{or}, or in the @var{then}-part of an @code{if}."
msgstr "初期のLispでは@code{progn}は、連続で複数のフォームを実行して最後のフォームの値を使用する唯一の方法でした。しかしプログラマーは関数のbodyの、(その時点では)1つのフォームだけが許される場所で@code{progn}を使用する必要が多いことに気づきました。そのため関数のbodyを暗黙の@code{progn}にして、@code{progn}のbodyのように複数のフォームを記述できるようにしました。他の多くの制御構造も暗黙の@code{progn}を同様に含みます。結果として昔ほど@code{progn}は多用されなくなりました。現在では@code{progn}が必要になるのは@code{unwind-protect}、@code{and}、@code{or}、または@code{if}の@var{then}パートの中であることがほとんどです。"

#. type: defspec
#: original_texis/control.texi:83
#, no-wrap
msgid "progn forms@dots{}"
msgstr "progn forms@dots{}"

#. type: defspec
#: original_texis/control.texi:86
msgid "This special form evaluates all of the @var{forms}, in textual order, returning the result of the final form."
msgstr "このスペシャルフォームは@var{forms}のすべてをテキスト順に評価してフォームの結果をリターンする。"

#. type: group
#: original_texis/control.texi:96
#, no-wrap
msgid ""
"(progn (print \"The first form\")\n"
"       (print \"The second form\")\n"
"       (print \"The third form\"))\n"
"     @print{} \"The first form\"\n"
"     @print{} \"The second form\"\n"
"     @print{} \"The third form\"\n"
"@result{} \"The third form\"\n"
msgstr ""
"(progn (print \"The first form\")\n"
"       (print \"The second form\")\n"
"       (print \"The third form\"))\n"
"     @print{} \"The first form\"\n"
"     @print{} \"The second form\"\n"
"     @print{} \"The third form\"\n"
"@result{} \"The third form\"\n"

#. type: Plain text
#: original_texis/control.texi:102
msgid "Two other constructs likewise evaluate a series of forms but return different values:"
msgstr "他の2つの構文は一連のフォームを同様に評価しますが、異なる値をリターンします:"

#. type: defspec
#: original_texis/control.texi:103
#, no-wrap
msgid "prog1 form1 forms@dots{}"
msgstr "prog1 form1 forms@dots{}"

#. type: defspec
#: original_texis/control.texi:106
msgid "This special form evaluates @var{form1} and all of the @var{forms}, in textual order, returning the result of @var{form1}."
msgstr "このスペシャルフォームは@var{form1}と@var{forms}のすべてをテキスト順に評価して@var{form1}の結果をリターンする。"

#. type: group
#: original_texis/control.texi:116
#, no-wrap
msgid ""
"(prog1 (print \"The first form\")\n"
"       (print \"The second form\")\n"
"       (print \"The third form\"))\n"
"     @print{} \"The first form\"\n"
"     @print{} \"The second form\"\n"
"     @print{} \"The third form\"\n"
"@result{} \"The first form\"\n"
msgstr ""
"(prog1 (print \"The first form\")\n"
"       (print \"The second form\")\n"
"       (print \"The third form\"))\n"
"     @print{} \"The first form\"\n"
"     @print{} \"The second form\"\n"
"     @print{} \"The third form\"\n"
"@result{} \"The first form\"\n"

#. type: defspec
#: original_texis/control.texi:121
msgid "Here is a way to remove the first element from a list in the variable @code{x}, then return the value of that former element:"
msgstr "以下の例は変数@code{x}のリストから1番目の要素を削除して、削除した1番目の要素の値をリターンする:"

#. type: example
#: original_texis/control.texi:124
#, no-wrap
msgid "(prog1 (car x) (setq x (cdr x)))\n"
msgstr "(prog1 (car x) (setq x (cdr x)))\n"

#. type: defspec
#: original_texis/control.texi:127
#, no-wrap
msgid "prog2 form1 form2 forms@dots{}"
msgstr "prog2 form1 form2 forms@dots{}"

#. type: defspec
#: original_texis/control.texi:131
msgid "This special form evaluates @var{form1}, @var{form2}, and all of the following @var{forms}, in textual order, returning the result of @var{form2}."
msgstr "このスペシャルフォームは@var{form1}、@var{form2}、その後の@var{forms}のすべてをテキスト順で評価して@var{form2}の結果をリターンする。"

#. type: group
#: original_texis/control.texi:141
#, no-wrap
msgid ""
"(prog2 (print \"The first form\")\n"
"       (print \"The second form\")\n"
"       (print \"The third form\"))\n"
"     @print{} \"The first form\"\n"
"     @print{} \"The second form\"\n"
"     @print{} \"The third form\"\n"
"@result{} \"The second form\"\n"
msgstr ""
"(prog2 (print \"The first form\")\n"
"       (print \"The second form\")\n"
"       (print \"The third form\"))\n"
"     @print{} \"The first form\"\n"
"     @print{} \"The second form\"\n"
"     @print{} \"The third form\"\n"
"@result{} \"The second form\"\n"

#. type: cindex
#: original_texis/control.texi:147
#, no-wrap
msgid "conditional evaluation"
msgstr "conditional evaluation"

#. type: Plain text
#: original_texis/control.texi:153
msgid "Conditional control structures choose among alternatives.  Emacs Lisp has four conditional forms: @code{if}, which is much the same as in other languages; @code{when} and @code{unless}, which are variants of @code{if}; and @code{cond}, which is a generalized case statement."
msgstr "条件による制御構造は選択肢の中から選択を行ないます。Emacs Lispには4つの条件フォームをもちます。@code{if}は他の言語のものとほとんど同じです。@code{when}と@code{unless}は@code{if}の変種です。@code{cond}は一般化されたcase命令です。"

#. type: defspec
#: original_texis/control.texi:154
#, no-wrap
msgid "if condition then-form else-forms@dots{}"
msgstr "if condition then-form else-forms@dots{}"

#. type: defspec
#: original_texis/control.texi:161
msgid "@code{if} chooses between the @var{then-form} and the @var{else-forms} based on the value of @var{condition}.  If the evaluated @var{condition} is non-@code{nil}, @var{then-form} is evaluated and the result returned.  Otherwise, the @var{else-forms} are evaluated in textual order, and the value of the last one is returned.  (The @var{else} part of @code{if} is an example of an implicit @code{progn}.  @xref{Sequencing}.)"
msgstr "@code{if}は@var{condition}の値にもとづき@var{then-form}と@var{else-forms}を選択する。評価された@var{condition}が非@code{nil}なら@var{then-form}が評価されて結果がリターンされる。それ以外なら@var{else-forms}がテキスト順に評価されて最後のフォームの値がリターンされる(@code{if}の@var{else}パートは暗黙の@code{progn}の例である。@ref{Sequencing}を参照)。"

#. type: defspec
#: original_texis/control.texi:164
msgid "If @var{condition} has the value @code{nil}, and no @var{else-forms} are given, @code{if} returns @code{nil}."
msgstr "@var{condition}の値が@code{nil}で@var{else-forms}が与えられなければ、@code{if}は@code{nil}をリターンする。"

#. type: defspec
#: original_texis/control.texi:168
msgid "@code{if} is a special form because the branch that is not selected is never evaluated---it is ignored.  Thus, in this example, @code{true} is not printed because @code{print} is never called:"
msgstr "選択されなかったブランチは決して評価されない --- 無視される --- ので、@code{if}はスペシャルフォームである。したがって以下の例では@code{print}が呼び出されることはないので@code{true}はプリントされない。"

#. type: group
#: original_texis/control.texi:175
#, no-wrap
msgid ""
"(if nil\n"
"    (print 'true)\n"
"  'very-false)\n"
"@result{} very-false\n"
msgstr ""
"(if nil\n"
"    (print 'true)\n"
"  'very-false)\n"
"@result{} very-false\n"

#. type: defmac
#: original_texis/control.texi:179
#, no-wrap
msgid "when condition then-forms@dots{}"
msgstr "when condition then-forms@dots{}"

#. type: defmac
#: original_texis/control.texi:182
msgid "This is a variant of @code{if} where there are no @var{else-forms}, and possibly several @var{then-forms}.  In particular,"
msgstr "これは@var{else-forms}がなく、複数の@var{then-forms}が可能な@code{if}の変種である。特に、"

#. type: example
#: original_texis/control.texi:185
#, no-wrap
msgid "(when @var{condition} @var{a} @var{b} @var{c})\n"
msgstr "(when @var{condition} @var{a} @var{b} @var{c})\n"

#. type: defmac
#: original_texis/control.texi:189 original_texis/control.texi:204
msgid "is entirely equivalent to"
msgstr "は以下と完全に等価である"

#. type: example
#: original_texis/control.texi:192
#, no-wrap
msgid "(if @var{condition} (progn @var{a} @var{b} @var{c}) nil)\n"
msgstr "(if @var{condition} (progn @var{a} @var{b} @var{c}) nil)\n"

#. type: defmac
#: original_texis/control.texi:195
#, no-wrap
msgid "unless condition forms@dots{}"
msgstr "unless condition forms@dots{}"

#. type: defmac
#: original_texis/control.texi:197
msgid "This is a variant of @code{if} where there is no @var{then-form}:"
msgstr "これは@var{then-form}がない@code{if}の変種です:"

#. type: example
#: original_texis/control.texi:200
#, no-wrap
msgid "(unless @var{condition} @var{a} @var{b} @var{c})\n"
msgstr "(unless @var{condition} @var{a} @var{b} @var{c})\n"

#. type: example
#: original_texis/control.texi:208
#, no-wrap
msgid ""
"(if @var{condition} nil\n"
"   @var{a} @var{b} @var{c})\n"
msgstr ""
"(if @var{condition} nil\n"
"   @var{a} @var{b} @var{c})\n"

#. type: defspec
#: original_texis/control.texi:211
#, no-wrap
msgid "cond clause@dots{}"
msgstr "cond clause@dots{}"

#. type: defspec
#: original_texis/control.texi:216
msgid "@code{cond} chooses among an arbitrary number of alternatives.  Each @var{clause} in the @code{cond} must be a list.  The @sc{car} of this list is the @var{condition}; the remaining elements, if any, the @var{body-forms}.  Thus, a clause looks like this:"
msgstr "@code{cond}は任意個数の選択肢から選択を行なう。@code{cond}内の各@var{clause}はリストでなければならない。このリストの@sc{car}は@var{condition}で、(もしあれば)残りの要素は@var{body-forms}となる。したがってclauseは以下のようになる:"

#. type: example
#: original_texis/control.texi:219
#, no-wrap
msgid "(@var{condition} @var{body-forms}@dots{})\n"
msgstr "(@var{condition} @var{body-forms}@dots{})\n"

#. type: defspec
#: original_texis/control.texi:226
msgid "@code{cond} tries the clauses in textual order, by evaluating the @var{condition} of each clause.  If the value of @var{condition} is non-@code{nil}, the clause succeeds; then @code{cond} evaluates its @var{body-forms}, and returns the value of the last of @var{body-forms}.  Any remaining clauses are ignored."
msgstr "@code{cond}は各clauseの@var{condition}を評価することにより、テキスト順でclauseを試みる。@var{condition}の値が非@code{nil}ならそのclauseは成り立つ。その後に@code{cond}はそのclauseの@var{body-forms}を評価して、@var{body-forms}の最後の値をリターンする。残りのclauseは無視される。"

#. type: defspec
#: original_texis/control.texi:229
msgid "If the value of @var{condition} is @code{nil}, the clause fails, so the @code{cond} moves on to the following clause, trying its @var{condition}."
msgstr "@var{condition}の値が@code{nil}ならそのclauseは失敗して、@code{cond}は次のclauseに移動してそれの@var{condition}を試みる。"

#. type: defspec
#: original_texis/control.texi:231
msgid "A clause may also look like this:"
msgstr "clauseは以下のようにも見えるかもしれない:"

#. type: example
#: original_texis/control.texi:234
#, no-wrap
msgid "(@var{condition})\n"
msgstr "(@var{condition})\n"

#. type: defspec
#: original_texis/control.texi:239
msgid "Then, if @var{condition} is non-@code{nil} when tested, the @code{cond} form returns the value of @var{condition}."
msgstr "@var{condition}がテストされたときに非@code{nil}なら、@code{cond}フォームは@var{condition}の値をリターンする。"

#. type: defspec
#: original_texis/control.texi:242
msgid "If every @var{condition} evaluates to @code{nil}, so that every clause fails, @code{cond} returns @code{nil}."
msgstr "すべての@var{condition}が@code{nil}に評価された場合 --- つまりすべてのclauseが不成立なら、@code{cond}は@code{nil}をリターンする。"

#. type: defspec
#: original_texis/control.texi:246
msgid "The following example has four clauses, which test for the cases where the value of @code{x} is a number, string, buffer and symbol, respectively:"
msgstr "以下の例は@code{x}の値が数字、文字列、バッファー、シンボルなのかをテストする4つのclauseをもつ:"

#. type: group
#: original_texis/control.texi:255
#, no-wrap
msgid ""
"(cond ((numberp x) x)\n"
"      ((stringp x) x)\n"
"      ((bufferp x)\n"
"       (setq temporary-hack x) ; @r{multiple body-forms}\n"
"       (buffer-name x))        ; @r{in one clause}\n"
"      ((symbolp x) (symbol-value x)))\n"
msgstr ""
"(cond ((numberp x) x)\n"
"      ((stringp x) x)\n"
"      ((bufferp x)\n"
"       (setq temporary-hack x) ; @r{1つのclauseに}\n"
"       (buffer-name x))        ; @r{複数bodyフォーム}\n"
"      ((symbolp x) (symbol-value x)))\n"

#. type: defspec
#: original_texis/control.texi:264
msgid "Often we want to execute the last clause whenever none of the previous clauses was successful.  To do this, we use @code{t} as the @var{condition} of the last clause, like this: @code{(t @var{body-forms})}.  The form @code{t} evaluates to @code{t}, which is never @code{nil}, so this clause never fails, provided the @code{cond} gets to it at all.  For example:"
msgstr "前のclauseが不成立のとき最後の条項を実行したいときがよくある。これを行なうには@code{(t @var{body-forms})}のように、@var{condition}の最後のclauseに@code{t}を使用する。フォーム@code{t}は@code{t}に評価され決して@code{nil}にならないので、このclauseが不成立になることはなく最終的に@code{cond}はこのclauseに到達する。たとえば:"

#. type: group
#: original_texis/control.texi:271
#, no-wrap
msgid ""
"(setq a 5)\n"
"(cond ((eq a 'hack) 'foo)\n"
"      (t \"default\"))\n"
"@result{} \"default\"\n"
msgstr ""
"(setq a 5)\n"
"(cond ((eq a 'hack) 'foo)\n"
"      (t \"default\"))\n"
"@result{} \"default\"\n"

#. type: defspec
#: original_texis/control.texi:277
msgid "This @code{cond} expression returns @code{foo} if the value of @code{a} is @code{hack}, and returns the string @code{\"default\"} otherwise."
msgstr "この@code{cond}式は@code{a}の値が@code{hack}なら@code{foo}、それ以外は文字列@code{\"default\"}をリターンする。"

#. type: Plain text
#: original_texis/control.texi:282
msgid "Any conditional construct can be expressed with @code{cond} or with @code{if}.  Therefore, the choice between them is a matter of style.  For example:"
msgstr "すべての条件構文は@code{cond}か@code{if}のいずれかで表すことができます。したがってどちらを選択するかはスタイルの問題になります。たとえば:"

#. type: group
#: original_texis/control.texi:288
#, no-wrap
msgid ""
"(if @var{a} @var{b} @var{c})\n"
"@equiv{}\n"
"(cond (@var{a} @var{b}) (t @var{c}))\n"
msgstr ""
"(if @var{a} @var{b} @var{c})\n"
"@equiv{}\n"
"(cond (@var{a} @var{b}) (t @var{c}))\n"

#. type: subsection
#: original_texis/control.texi:293 original_texis/control.texi:295
#: original_texis/control.texi:296
#, no-wrap
msgid "Pattern matching case statement"
msgstr "Pattern matching case statement"

#. type: cindex
#: original_texis/control.texi:297
#, no-wrap
msgid "pcase"
msgstr "pcase"

#. type: cindex
#: original_texis/control.texi:298
#, no-wrap
msgid "pattern matching"
msgstr "pattern matching"

#. type: Plain text
#: original_texis/control.texi:310
msgid "The @code{cond} form lets you choose between alternatives using predicate conditions that compare values of expressions against specific values known and written in advance.  However, sometimes it is useful to select alternatives based on more general conditions that distinguish between broad classes of values.  The @code{pcase} macro allows you to choose between alternatives based on matching the value of an expression against a series of patterns.  A pattern can be a literal value (for comparisons to literal values you'd use @code{cond}), or it can be a more general description of the expected structure of the expression's value."
msgstr "@code{cond}フォームにより、あらかじめ記述された既知の特定の値と式の値を比較する述語条件を使用して選択肢を選択できます。しかし広範な値クラス間を区別する、より一般的な条件にもとづいて選択肢を選択するのが有用なこともあります。@code{pcase}マクロにより、一連のパターンにたいする式の値のマッチングにもとづいて選択肢を選択できます。パターンにはリテラル値(@code{cond}で使用した比較用のリテラル値)や、予想される式の値のより一般的な構造記述を使用できます。"

#. type: defmac
#: original_texis/control.texi:311
#, no-wrap
msgid "pcase expression &rest clauses"
msgstr "pcase expression &rest clauses"

#. type: defmac
#: original_texis/control.texi:322
msgid "Evaluate @var{expression} and choose among an arbitrary number of alternatives based on the value of @var{expression}.  The possible alternatives are specified by @var{clauses}, each of which must be a list of the form @code{(@var{pattern} @var{body-forms}@dots{})}.  @code{pcase} tries to match the value of @var{expression} to the @var{pattern} of each clause, in textual order.  If the value matches, the clause succeeds; @code{pcase} then evaluates its @var{body-forms}, and returns the value of the last of @var{body-forms}.  Any remaining @var{clauses} are ignored.  If no clauses match, then the @code{pcase} form evaluates to @code{nil}."
msgstr "@var{expression}を評価して@var{expression}の値にもとづいて任意の個数の選択肢から選択を行う。可能な選択肢は@var{clauses}で指定する。それらは@code{(@var{pattern} @var{body-forms}@dots{})}という形式のリストでなければならない。@code{pcase}は@var{expression}の値と各clauseの@var{pattern}にたいしてテキスト順でマッチを試みる。値がマッチしたらそのclauseは成功となり@code{pcase}はその@code{pcase}clauseの@var{body-forms}を評価して、@var{body-forms}の最後の値をリターンする。@var{clauses}の残りはすべて無視される。マッチがなければ@code{pcase}フォームは@code{nil}に評価される。"

#. type: defmac
#: original_texis/control.texi:327
msgid "The @var{pattern} part of a clause can be of one of two types: @dfn{QPattern}, a pattern quoted with a backquote; or a @dfn{UPattern}, which is not quoted.  UPatterns are simpler, so we describe them first."
msgstr "@var{pattern}パートはバッククォートでクォートされた@dfn{QPattern}と、クォートされていない@dfn{UPattern}のいずれかで指定できる。UPatternsのほうが単純なのでそれから説明する。"

#. type: defmac
#: original_texis/control.texi:331
msgid "Note: In the description of the patterns below, we use ``the value being matched'' to refer to the value of the @var{expression} that is the first argument of @code{pcase}."
msgstr "注意: 以下のパターンの記述では@code{pcase}の1つ目の引数となる@var{expression}の値を参照するために、``マッチされる値''という言葉を使用している。"

#. type: defmac
#: original_texis/control.texi:333
msgid "A UPattern can have the following forms:"
msgstr "UPatternには以下の形式を指定できる:"

#. type: item
#: original_texis/control.texi:336
#, no-wrap
msgid "'@var{val}"
msgstr "'@var{val}"

#. type: table
#: original_texis/control.texi:338
msgid "Matches if the value being matched is @code{equal} to @var{val}."
msgstr "マッチされる値が@var{val}と@code{equal}ならマッチ。"

#. type: var{#1}
#: original_texis/control.texi:338 original_texis/control.texi:434
#, no-wrap
msgid "atom"
msgstr "atom"

#. type: table
#: original_texis/control.texi:343
msgid "Matches any @var{atom}, which can be a keyword, a number, or a string.  (These are self-quoting, so this kind of UPattern is actually a shorthand for @code{'@var{atom}}.)  Note that a string or a float matches any string or float with the same contents/value."
msgstr "任意の@var{atom} (キーワード、数字、文字列)にマッチする(これらは自己クォートされるのでこの種のUPatternは実際には@code{'@var{atom}}の略記である)。文字列(浮動小数点数)は同じ内容(値)の任意の文字列(浮動小数点数)とマッチすることに注意。"

#. type: item
#: original_texis/control.texi:343
#, no-wrap
msgid "_"
msgstr "_"

#. type: table
#: original_texis/control.texi:345
msgid "Matches any value.  This is known as @dfn{don't care} or @dfn{wildcard}."
msgstr "任意の値にマッチする。これは@dfn{don't care}や@dfn{wildcard}として知られる。"

#. type: var{#1}
#: original_texis/control.texi:345
#, no-wrap
msgid "symbol"
msgstr "symbol"

#. type: table
#: original_texis/control.texi:349
msgid "Matches any value, and additionally let-binds @var{symbol} to the value it matched, so that you can later refer to it, either in the @var{body-forms} or also later in the pattern."
msgstr "任意の値にマッチする。さらにマッチした値を@var{symbol}にletバインドするので、@var{body-forms}や後続のパターンからそれを参照することができる。"

#. type: item
#: original_texis/control.texi:349
#, no-wrap
msgid "(pred @var{predfun})"
msgstr "(pred @var{predfun})"

#. type: table
#: original_texis/control.texi:353
msgid "Matches if the predicate function @var{predfun} returns non-@code{nil} when called with the value being matched as its argument.  @var{predfun} can be one of the possible forms described below."
msgstr "マッチされる値を引数として述語関数@var{predfun}を呼び出して、非@code{nil}をリターンしたらマッチ。@var{predfun}は後述するフォームのいずれかを指定できる。"

#. type: item
#: original_texis/control.texi:353
#, no-wrap
msgid "(guard @var{boolean-expression})"
msgstr "(guard @var{boolean-expression})"

#. type: table
#: original_texis/control.texi:361
msgid "Matches if @var{boolean-expression} evaluates to non-@code{nil}.  This allows you to include in a UPattern boolean conditions that refer to symbols bound to values (including the value being matched) by previous UPatterns.  Typically used inside an @code{and} UPattern, see below.  For example, @w{@code{(and x (guard (< x 10)))}} is a pattern which matches any number smaller than 10 and let-binds the variable @code{x} to that number."
msgstr "@var{boolean-expression}が非@code{nil}に評価されたらマッチ。これにより以前のUPatternで、値(マッチされる値を含む)にバインドされたシンボルを参照するブール条件をUPatternに含めることができる。典型的にはUPattern @code{and}内で使用される(以下参照)。たとえば@w{@code{(and x (guard (< x 10)))}}は10より小さい任意の数にマッチして、その数を変数@code{x}にletバインドする。"

#. type: item
#: original_texis/control.texi:361
#, no-wrap
msgid "(let @var{upattern} @var{expression})"
msgstr "(let @var{upattern} @var{expression})"

#. type: table
#: original_texis/control.texi:369
msgid "Matches if the specified @var{expression} matches the specified @var{upattern}.  This allows matching a pattern against the value of an @emph{arbitrary} expression, not just the expression that is the first argument to @code{pcase}.  (It is called @code{let} because @var{upattern} can bind symbols to values using the @var{symbol} UPattern.  For example: @w{@code{((or `(key . ,val) (let val 5)) val)}}.)"
msgstr "指定された@var{expression}が指定された@var{upattern}にマッチしたらマッチ。これにより@code{pcase}の1つ目の引数だけでなく、@emph{任意}の式の値にパターンをマッチできる(@var{upattern}はUPattern @var{symbol}を使用してシンボルを値にバインドできるので@code{let}と呼ばれる。たとえば@w{@code{((or `(key . ,val) (let val 5)) val)}})。"

#. type: item
#: original_texis/control.texi:369
#, no-wrap
msgid "(app @var{function} @var{upattern})"
msgstr "(app @var{function} @var{upattern})"

#. type: table
#: original_texis/control.texi:375
msgid "Matches if @var{function} applied to the value being matched returns a value that matches @var{upattern}.  This is like the @code{pred} UPattern, except that it tests the result against @var{upattern}, rather than against a boolean truth value.  The @var{function} call can use one of the forms described below."
msgstr ""
"値に@var{function}を適用してリターンされた値が@var{upattern}にマッチすればマッチ。\n"
"Matches if  applied to the value being matched returns a value that matches .\n"
"これはUPatternの@code{pred}と似ているが、これは結果を真偽値ではなく@var{upattern}にたいしてテストする点が異なる。@var{function}呼び出しは後述のいずれかのフォームを使用できる。"

#. type: item
#: original_texis/control.texi:375
#, no-wrap
msgid "(or @var{upattern1} @var{upattern2}@dots{})"
msgstr "(or @var{upattern1} @var{upattern2}@dots{})"

#. type: table
#: original_texis/control.texi:380
msgid "Matches if one the argument UPatterns matches.  As soon as the first matching UPattern is found, the rest are not tested.  For this reason, if any of the UPatterns let-bind symbols to the matched value, they should all bind the same symbols."
msgstr "引数のUPatternのいずれかがマッチしたらマッチ。マッチする最初のUPatternが見つかったら残りはテストされない。この理由により、マッチされる値にシンボルをletバインドするすべてのUPatternは同じシンボルをバインドすること。"

#. type: item
#: original_texis/control.texi:380
#, no-wrap
msgid "(and @var{upattern1} @var{upattern2}@dots{})"
msgstr "(and @var{upattern1} @var{upattern2}@dots{})"

#. type: table
#: original_texis/control.texi:382
msgid "Matches if all the argument UPatterns match."
msgstr "引数のUPatternすべてがマッチしたらマッチ。"

#. type: defmac
#: original_texis/control.texi:386
msgid "The function calls used in the @code{pred} and @code{app} UPatterns can have one of the following forms:"
msgstr "@code{pred}と@code{app}のUPatternで使用される関数呼び出しは、以下のいずれかのフォームをもつことができる:"

#. type: item
#: original_texis/control.texi:388
#, no-wrap
msgid "function symbol, like @code{integerp}"
msgstr "@code{integerp}のような関数シンボル"

#. type: table
#: original_texis/control.texi:391
msgid "In this case, the named function is applied to the value being matched."
msgstr "この場合には、その名前つき関数がマッチされる値に適用される。"

#. type: item
#: original_texis/control.texi:391
#, no-wrap
msgid "lambda-function @code{(lambda (@var{arg}) @var{body})}"
msgstr "ラムダ関数 @code{(lambda (@var{arg}) @var{body})}"

#. type: table
#: original_texis/control.texi:394
msgid "In this case, the lambda-function is called with one argument, the value being matched."
msgstr "この場合には、そのラムダ関数がマッチされる値を単一の引数として呼び出される。"

#. type: code{#1}
#: original_texis/control.texi:394
#, no-wrap
msgid "(@var{func} @var{args}@dots{})"
msgstr "(@var{func} @var{args}@dots{})"

#. type: table
#: original_texis/control.texi:398
msgid "This is a function call with @var{n} specified arguments; the function is called with these @var{n} arguments and an additional @var{n}+1-th argument that is the value being matched."
msgstr "これは指定された@var{n}個の引数で呼び出される関数である。関数はこれら@var{n}個の引数と、マッチされる値である@var{n}+1番目の引数を追加して呼び出される。"

#. type: defmac
#: original_texis/control.texi:401
msgid "Here's an illustrative example of using UPatterns:"
msgstr "以下はUPatternを使用した説明用の例です:"

#. type: example
#: original_texis/control.texi:411
#, no-wrap
msgid ""
"(pcase (get-return-code x)\n"
"  ('success       (message \"Done!\"))\n"
"  ('would-block   (message \"Sorry, can't do it now\"))\n"
"  ('read-only     (message \"The shmliblick is read-only\"))\n"
"  ('access-denied (message \"You do not have the needed rights\"))\n"
"  (code           (message \"Unknown return code %S\" code)))\n"
msgstr ""
"(pcase (get-return-code x)\n"
"  ('success       (message \"Done!\"))\n"
"  ('would-block   (message \"Sorry, can't do it now\"))\n"
"  ('read-only     (message \"The shmliblick is read-only\"))\n"
"  ('access-denied (message \"You do not have the needed rights\"))\n"
"  (code           (message \"Unknown return code %S\" code)))\n"

#. type: defmac
#: original_texis/control.texi:420
msgid "In addition, you can use backquoted patterns that are more powerful.  They allow matching the value of the @var{expression} that is the first argument of @code{pcase} against specifications of its @emph{structure}.  For example, you can specify that the value must be a list of 2 elements whose first element is a specific string and the second element is any value with a backquoted pattern like @code{`(\"first\" ,second-elem)}."
msgstr "加えてより協力なバッククォートされたパターンを使用できます。これらを使用すれば@code{pcase}の1つ目の引数の式の値を、その@emph{構造(structure)}の仕様とマッチさせることができます。たとえば1つ目の要素が特定の文字列で、2つ目の要素が@code{`(\"first\" ,second-elem)}のようなバッククォートされた任意の値であるような2要素のリストを、値として強制指定することができます。"

#. type: defmac
#: original_texis/control.texi:423
msgid "Backquoted patterns have the form @code{`@var{qpattern}} where @var{qpattern} can have the following forms:"
msgstr "バッククォートされたパターンは@code{`@var{qpattern}}という形式をもち、@var{qpattern}は以下の形式をもつことができます:"

#. type: item
#: original_texis/control.texi:425
#, no-wrap
msgid "(@var{qpattern1} . @var{qpattern2})"
msgstr "(@var{qpattern1} . @var{qpattern2})"

#. type: table
#: original_texis/control.texi:430
msgid "Matches if the value being matched is a cons cell whose @code{car} matches @var{qpattern1} and whose @code{cdr} matches @var{qpattern2}.  This readily generalizes to backquoted lists as in @w{@code{(@var{qpattern1} @var{qpattern2} @dots{})}}."
msgstr "マッチされる値が、@code{car}が@var{qpattern1}、@code{cdr}が@var{qpattern2}にマッチするようなコンスセルならマッチ。これは@w{@code{(@var{qpattern1} @var{qpattern2} @dots{})}}のように、容易にバッククォートされたリストに一般化できる。"

#. type: item
#: original_texis/control.texi:430
#, no-wrap
msgid "[@var{qpattern1} @var{qpattern2} @dots{} @var{qpatternm}]"
msgstr "[@var{qpattern1} @var{qpattern2} @dots{} @var{qpatternm}]"

#. type: table
#: original_texis/control.texi:434
msgid "Matches if the value being matched is a vector of length @var{m} whose @code{0}..@code{(@var{m}-1)}th elements match @var{qpattern1}, @var{qpattern2} @dots{} @var{qpatternm}, respectively."
msgstr "マッチされる値が、長さ@var{m}で@code{0}から@code{(@var{m}-1)}番目の要素がそれぞれ@var{qpattern1}、@var{qpattern2}、@dots{}、@var{qpatternm}にマッチするようなベクターならマッチ。"

#. type: table
#: original_texis/control.texi:437
msgid "Matches if corresponding element of the value being matched is @code{equal} to the specified @var{atom}."
msgstr "マッチされる値の対応する要素が指定された@var{atom}と@code{equal}ならマッチ。"

#. type: item
#: original_texis/control.texi:437
#, no-wrap
msgid ",@var{upattern}"
msgstr ",@var{upattern}"

#. type: table
#: original_texis/control.texi:440
msgid "Matches if the corresponding element of the value being matched matches the specified @var{upattern}."
msgstr "マッチされる値の対応する要素が指定された@var{upattern}とマッチすればマッチ。"

#. type: defmac
#: original_texis/control.texi:448
msgid "Note that uses of QPatterns can be expressed using only UPatterns, as QPatterns are implemented on top of UPatterns using @code{pcase-defmacro}, described below.  However, using QPatterns will in many cases lead to a more readable code."
msgstr "QPatternは後述の@code{pcase-defmacro}を使用してUPatternのトップレベルで実装されているので、QPatternの使用はUPatternを使用することでのみ表現可能なことに注意。とはいえQPatternの使用により、多くの場合コードの可読性は向上するだろう。"

#. type: Plain text
#: original_texis/control.texi:454
msgid "Here is an example of using @code{pcase} to implement a simple interpreter for a little expression language (note that this example requires lexical binding, @pxref{Lexical Binding}):"
msgstr "以下は@code{pcase}を使用して、小さな式言語用のシンプルなインタープリターを実装する例です(この例にはレキシカルバインディングが必要なことに注意。)@ref{Lexical Binding}を参照のこと):"

#. type: example
#: original_texis/control.texi:465
#, no-wrap
msgid ""
"(defun evaluate (exp env)\n"
"  (pcase exp\n"
"    (`(add ,x ,y)       (+ (evaluate x env) (evaluate y env)))\n"
"    (`(call ,fun ,arg)  (funcall (evaluate fun env) (evaluate arg env)))\n"
"    (`(fn ,arg ,body)   (lambda (val)\n"
"                          (evaluate body (cons (cons arg val) env))))\n"
"    ((pred numberp)     exp)\n"
"    ((pred symbolp)     (cdr (assq exp env)))\n"
"    (_                  (error \"Unknown expression %S\" exp))))\n"
msgstr ""
"(defun evaluate (exp env)\n"
"  (pcase exp\n"
"    (`(add ,x ,y)       (+ (evaluate x env) (evaluate y env)))\n"
"    (`(call ,fun ,arg)  (funcall (evaluate fun env) (evaluate arg env)))\n"
"    (`(fn ,arg ,body)   (lambda (val)\n"
"                          (evaluate body (cons (cons arg val) env))))\n"
"    ((pred numberp)     exp)\n"
"    ((pred symbolp)     (cdr (assq exp env)))\n"
"    (_                  (error \"Unknown expression %S\" exp))))\n"

#. type: Plain text
#: original_texis/control.texi:477
msgid "Here @code{`(add ,x ,y)} is a pattern that checks that @code{exp} is a three-element list starting with the literal symbol @code{add}, then extracts the second and third elements and binds them to the variables @code{x} and @code{y}.  Then it evaluates @code{x} and @code{y} and adds the results.  The @code{call} and @code{fn} patterns similarly implement two flavors of function calls.  @code{(pred numberp)} is a pattern that simply checks that @code{exp} is a number and if so, evaluates it.  @code{(pred symbolp)} matches symbols, and returns their association.  Finally, @code{_} is the catch-all pattern that matches anything, so it's suitable for reporting syntax errors."
msgstr "ここで@code{`(add ,x ,y)}は、@code{exp}がリテラルシンボル@code{add}で始まる3要素のリストであることをチェックしてから、2つ目と3つ目の要素を抽出して変数@code{x}と@code{y}にバインドするパターンです。それから@code{x}と@code{y}を評価して結果を加算します。同様に@code{call}と@code{fn}のパターンは、関数呼び出しに相当するものを2つ実装します。@code{(pred numberp)}は@code{exp}が数であるかをチェックして、もしそうならそれを評価します。@code{(pred symbolp)}はシンボルにマッチして、その連想をリターンします。最後に@code{_}はすべてにマッチするcatch-allパターンなので、構文エラーの報告に適しています。"

#. type: Plain text
#: original_texis/control.texi:480
msgid "Here are some sample programs in this small language, including their evaluation results:"
msgstr "以下は評価した結果を含む、この小さな言語のサンプルプログラムの例です:"

#. type: example
#: original_texis/control.texi:486
#, no-wrap
msgid ""
"(evaluate '(add 1 2) nil)                 ;=> 3\n"
"(evaluate '(add x y) '((x . 1) (y . 2)))  ;=> 3\n"
"(evaluate '(call (fn x (add 1 x)) 2) nil) ;=> 3\n"
"(evaluate '(sub 1 2) nil)                 ;=> error\n"
msgstr ""
"(evaluate '(add 1 2) nil)                 ;=> 3\n"
"(evaluate '(add x y) '((x . 1) (y . 2)))  ;=> 3\n"
"(evaluate '(call (fn x (add 1 x)) 2) nil) ;=> 3\n"
"(evaluate '(sub 1 2) nil)                 ;=> error\n"

#. type: Plain text
#: original_texis/control.texi:490
msgid "Additional UPatterns can be defined using the @code{pcase-defmacro} macro."
msgstr "@code{pcase-defmacro}を使用することにより追加のUPatternを定義できます。"

#. type: defmac
#: original_texis/control.texi:491
#, no-wrap
msgid "pcase-defmacro name args &rest body"
msgstr "pcase-defmacro name args &rest body"

#. type: defmac
#: original_texis/control.texi:497
msgid "Define a new kind of UPattern for @code{pcase}.  The new UPattern will be invoked as @code{(@var{name} @var{actual-args})}.  The @var{body} should describe how to rewrite the UPattern @var{name} into some other UPattern.  The rewriting will be the result of evaluating @var{body} in an environment where @var{args} are bound to @var{actual-args}."
msgstr "@code{pcase}にたいして新たな種類のUPatternを定義する。新たなUPatternは@code{(@var{name} @var{actual-args})}のように呼び出されるだろう。@var{body}には、UPattern @var{name}を他の何らかのUPatternに書き換える方法を記述すること。@var{args}が@var{actual-args}にバインドされる環境で@var{body}を評価した結果がこの書き換えとなる。"

#. type: section
#: original_texis/control.texi:500
#, no-wrap
msgid "Constructs for Combining Conditions"
msgstr "Constructs for Combining Conditions"

#. type: cindex
#: original_texis/control.texi:501
#, no-wrap
msgid "combining conditions"
msgstr "combining conditions"

#. type: Plain text
#: original_texis/control.texi:507
msgid "This section describes three constructs that are often used together with @code{if} and @code{cond} to express complicated conditions.  The constructs @code{and} and @code{or} can also be used individually as kinds of multiple conditional constructs."
msgstr "このセクションでは複雑な条件を表現するために@code{if}や@code{cond}とともによく使用される3つの構文を説明します。@code{and}と@code{or}の構文は、ある種の複数条件の構文として個別に使用することもできます。"

#. type: defun
#: original_texis/control.texi:508
#, no-wrap
msgid "not condition"
msgstr "not condition"

#. type: defun
#: original_texis/control.texi:513
msgid "This function tests for the falsehood of @var{condition}.  It returns @code{t} if @var{condition} is @code{nil}, and @code{nil} otherwise.  The function @code{not} is identical to @code{null}, and we recommend using the name @code{null} if you are testing for an empty list."
msgstr "この関数は@var{condition}が偽であることをテストする。この関数は@var{condition}が@code{nil}なら@code{t}、それ以外は@code{nil}をリターンする。関数@code{not}は@code{null}と等価であり、空のリストをテストする場合は@code{null}の使用を推奨する。"

#. type: defspec
#: original_texis/control.texi:515
#, no-wrap
msgid "and conditions@dots{}"
msgstr "and conditions@dots{}"

#. type: defspec
#: original_texis/control.texi:519
msgid "The @code{and} special form tests whether all the @var{conditions} are true.  It works by evaluating the @var{conditions} one by one in the order written."
msgstr "スペシャルフォーム@code{and}は、すべての@var{conditions}が真かどうかをテストする。この関数は@var{conditions}を記述順に1つずつ評価することにより機能する。"

#. type: defspec
#: original_texis/control.texi:524
msgid "If any of the @var{conditions} evaluates to @code{nil}, then the result of the @code{and} must be @code{nil} regardless of the remaining @var{conditions}; so @code{and} returns @code{nil} right away, ignoring the remaining @var{conditions}."
msgstr "ある@var{conditions}が@code{nil}に評価されると、残りの@var{conditions}に関係なく、@code{and}は@code{nil}をリターンしなければならない。この場合@code{and}は即座に@code{nil}をリターンして、残りの@var{conditions}は無視される。"

#. type: defspec
#: original_texis/control.texi:530
msgid "If all the @var{conditions} turn out non-@code{nil}, then the value of the last of them becomes the value of the @code{and} form.  Just @code{(and)}, with no @var{conditions}, returns @code{t}, appropriate because all the @var{conditions} turned out non-@code{nil}.  (Think about it; which one did not?)"
msgstr "すべての@var{conditions}が非@code{nil}なら、それらの最後の値が@code{and}フォームの値になる。@var{conditions}がない単独の@code{(and)}は@code{t}をリターンする。なぜならすべての@var{conditions}が非@code{nil}となるので、これは適切である(考えてみてみよ、非@code{nil}でない@var{conditions}はどれか?)。"

#. type: defspec
#: original_texis/control.texi:535
msgid "Here is an example.  The first condition returns the integer 1, which is not @code{nil}.  Similarly, the second condition returns the integer 2, which is not @code{nil}.  The third condition is @code{nil}, so the remaining condition is never evaluated."
msgstr "以下に例を示す。1番目の条件は整数1をリターンし、これは@code{nil}ではまい。同様に2番目の条件は整数2をリターンし、これも@code{nil}ではない。3番目の条件は@code{nil}なので、のこりの条件が評価されることは決してない。"

#. type: group
#: original_texis/control.texi:542
#, no-wrap
msgid ""
"(and (print 1) (print 2) nil (print 3))\n"
"     @print{} 1\n"
"     @print{} 2\n"
"@result{} nil\n"
msgstr ""
"(and (print 1) (print 2) nil (print 3))\n"
"     @print{} 1\n"
"     @print{} 2\n"
"@result{} nil\n"

#. type: defspec
#: original_texis/control.texi:546
msgid "Here is a more realistic example of using @code{and}:"
msgstr "以下は@code{and}を使用した、より現実的な例である:"

#. type: group
#: original_texis/control.texi:551
#, no-wrap
msgid ""
"(if (and (consp foo) (eq (car foo) 'x))\n"
"    (message \"foo is a list starting with x\"))\n"
msgstr ""
"(if (and (consp foo) (eq (car foo) 'x))\n"
"    (message \"foo is a list starting with x\"))\n"

#. type: defspec
#: original_texis/control.texi:557
msgid "Note that @code{(car foo)} is not executed if @code{(consp foo)} returns @code{nil}, thus avoiding an error."
msgstr "@code{(consp foo)}が@code{nil}をリターンすると、@code{(car foo)}は実行されないのでエラーにならないことに注意。"

#. type: defspec
#: original_texis/control.texi:560
msgid "@code{and} expressions can also be written using either @code{if} or @code{cond}.  Here's how:"
msgstr "@code{if}か@code{cond}のいずれかを使用して、@code{and}式を記述することもできる。以下にその方法を示す:"

#. type: group
#: original_texis/control.texi:568
#, no-wrap
msgid ""
"(and @var{arg1} @var{arg2} @var{arg3})\n"
"@equiv{}\n"
"(if @var{arg1} (if @var{arg2} @var{arg3}))\n"
"@equiv{}\n"
"(cond (@var{arg1} (cond (@var{arg2} @var{arg3}))))\n"
msgstr ""
"(and @var{arg1} @var{arg2} @var{arg3})\n"
"@equiv{}\n"
"(if @var{arg1} (if @var{arg2} @var{arg3}))\n"
"@equiv{}\n"
"(cond (@var{arg1} (cond (@var{arg2} @var{arg3}))))\n"

#. type: defspec
#: original_texis/control.texi:572
#, no-wrap
msgid "or conditions@dots{}"
msgstr "or conditions@dots{}"

#. type: defspec
#: original_texis/control.texi:576
msgid "The @code{or} special form tests whether at least one of the @var{conditions} is true.  It works by evaluating all the @var{conditions} one by one in the order written."
msgstr "スペシャルフォーム@code{or}は、少なくとも1つの@var{conditions}が真かどうかをテストする。この関数はすべての@var{conditions}を1つずつ、記述された順に評価することにより機能する。"

#. type: defspec
#: original_texis/control.texi:581
msgid "If any of the @var{conditions} evaluates to a non-@code{nil} value, then the result of the @code{or} must be non-@code{nil}; so @code{or} returns right away, ignoring the remaining @var{conditions}.  The value it returns is the non-@code{nil} value of the condition just evaluated."
msgstr "ある@var{conditions}が非@code{nil}値に評価されたら、@code{or}の結果は非@code{nil}でなければならない。この場合@code{or}は即座にリターンし、残りの@var{conditions}は無視される。この関数がリターンする値は、非@code{nil}値に評価された条件の値そのものである。"

#. type: defspec
#: original_texis/control.texi:587
msgid "If all the @var{conditions} turn out @code{nil}, then the @code{or} expression returns @code{nil}.  Just @code{(or)}, with no @var{conditions}, returns @code{nil}, appropriate because all the @var{conditions} turned out @code{nil}.  (Think about it; which one did not?)"
msgstr "すべての@var{conditions}が@code{nil}なら、@code{or}式は@code{nil}をリターンします。@var{conditions}のない単独の@code{(or)}は@code{nil}をリターンする。なぜならすべての@var{conditions}が@code{nil}になるのでこれは適切である(考えてみよ、@code{nil}でない@var{conditions}はどれか?)。"

#. type: defspec
#: original_texis/control.texi:590
msgid "For example, this expression tests whether @code{x} is either @code{nil} or the integer zero:"
msgstr "たとえば以下の式は、@code{x}が@code{nil}か整数0かどうかをテストする:"

#. type: example
#: original_texis/control.texi:593
#, no-wrap
msgid "(or (eq x nil) (eq x 0))\n"
msgstr "(or (eq x nil) (eq x 0))\n"

#. type: defspec
#: original_texis/control.texi:597
msgid "Like the @code{and} construct, @code{or} can be written in terms of @code{cond}.  For example:"
msgstr "@code{and}構文と同様に、@code{or}を@code{cond}に置き換えて記述することができる。たとえば:"

#. type: group
#: original_texis/control.texi:605
#, no-wrap
msgid ""
"(or @var{arg1} @var{arg2} @var{arg3})\n"
"@equiv{}\n"
"(cond (@var{arg1})\n"
"      (@var{arg2})\n"
"      (@var{arg3}))\n"
msgstr ""
"(or @var{arg1} @var{arg2} @var{arg3})\n"
"@equiv{}\n"
"(cond (@var{arg1})\n"
"      (@var{arg2})\n"
"      (@var{arg3}))\n"

#. type: defspec
#: original_texis/control.texi:609
msgid "You could almost write @code{or} in terms of @code{if}, but not quite:"
msgstr "ほとんどの場合は、@code{or}を@code{if}に置き換えて記述できるが完全ではない:"

#. type: group
#: original_texis/control.texi:615
#, no-wrap
msgid ""
"(if @var{arg1} @var{arg1}\n"
"  (if @var{arg2} @var{arg2}\n"
"    @var{arg3}))\n"
msgstr ""
"(if @var{arg1} @var{arg1}\n"
"  (if @var{arg2} @var{arg2}\n"
"    @var{arg3}))\n"

#. type: defspec
#: original_texis/control.texi:622
msgid "This is not completely equivalent because it can evaluate @var{arg1} or @var{arg2} twice.  By contrast, @code{(or @var{arg1} @var{arg2} @var{arg3})} never evaluates any argument more than once."
msgstr "これは完全に同一ではない。なぜなら@var{arg1}か@var{arg2}を2回評価するかもしれないからである。対照的に@code{(or @var{arg1} @var{arg2} @var{arg3})}が2回以上引数を評価することは決してない。"

#. type: cindex
#: original_texis/control.texi:626
#, no-wrap
msgid "iteration"
msgstr "iteration"

#. type: cindex
#: original_texis/control.texi:627
#, no-wrap
msgid "recursion"
msgstr "recursion"

#. type: Plain text
#: original_texis/control.texi:633
msgid "Iteration means executing part of a program repetitively.  For example, you might want to repeat some computation once for each element of a list, or once for each integer from 0 to @var{n}.  You can do this in Emacs Lisp with the special form @code{while}:"
msgstr "繰り返し(iteration)とは、プログラムの一部を繰り返し実行することを意味します。たとえばリストの各要素、または0から@var{n}の整数にたいして、繰り返し一度ずつ何らかの計算を行いたいとしましょう。Emacs Lispではスペシャルフォーム@code{while}でこれを行なうことができます:"

#. type: defspec
#: original_texis/control.texi:634
#, no-wrap
msgid "while condition forms@dots{}"
msgstr "while condition forms@dots{}"

#. type: defspec
#: original_texis/control.texi:640
msgid "@code{while} first evaluates @var{condition}.  If the result is non-@code{nil}, it evaluates @var{forms} in textual order.  Then it reevaluates @var{condition}, and if the result is non-@code{nil}, it evaluates @var{forms} again.  This process repeats until @var{condition} evaluates to @code{nil}."
msgstr "@code{while}は最初に@var{condition}を評価する。結果が非@code{nil}なら@var{forms}をテキスト順に評価する。その後に@var{condition}を再評価して結果が非@code{nil}なら、再度@var{forms}を評価する。この処理は@var{condition}が@code{nil}に評価されるまで繰り返される。"

#. type: defspec
#: original_texis/control.texi:644
msgid "There is no limit on the number of iterations that may occur.  The loop will continue until either @var{condition} evaluates to @code{nil} or until an error or @code{throw} jumps out of it (@pxref{Nonlocal Exits})."
msgstr "繰り返し回数に制限はない。このループは@var{condition}が@code{nil}に評価されるか、エラーになるか、または@code{throw}で抜け出す(@ref{Nonlocal Exits}を参照)まで継続される。"

#. type: defspec
#: original_texis/control.texi:646
msgid "The value of a @code{while} form is always @code{nil}."
msgstr "@code{while}フォームの値は常に@code{nil}である。"

#. type: group
#: original_texis/control.texi:651
#, no-wrap
msgid ""
"(setq num 0)\n"
"     @result{} 0\n"
msgstr ""
"(setq num 0)\n"
"     @result{} 0\n"

#. type: group
#: original_texis/control.texi:661
#, no-wrap
msgid ""
"(while (< num 4)\n"
"  (princ (format \"Iteration %d.\" num))\n"
"  (setq num (1+ num)))\n"
"     @print{} Iteration 0.\n"
"     @print{} Iteration 1.\n"
"     @print{} Iteration 2.\n"
"     @print{} Iteration 3.\n"
"     @result{} nil\n"
msgstr ""
"(while (< num 4)\n"
"  (princ (format \"Iteration %d.\" num))\n"
"  (setq num (1+ num)))\n"
"     @print{} Iteration 0.\n"
"     @print{} Iteration 1.\n"
"     @print{} Iteration 2.\n"
"     @print{} Iteration 3.\n"
"     @result{} nil\n"

#. type: defspec
#: original_texis/control.texi:668
msgid "To write a repeat-until loop, which will execute something on each iteration and then do the end-test, put the body followed by the end-test in a @code{progn} as the first argument of @code{while}, as shown here:"
msgstr "各繰り返しごとに何かを実行して、その後も終了テストを行なうrepeat-untilループを記述するには、以下のように@code{while}の1番目の引数としてbodyの後に終了テストを記述して、それを@code{progn}の中に配置する:"

#. type: group
#: original_texis/control.texi:674
#, no-wrap
msgid ""
"(while (progn\n"
"         (forward-line 1)\n"
"         (not (looking-at \"^$\"))))\n"
msgstr ""
"(while (progn\n"
"         (forward-line 1)\n"
"         (not (looking-at \"^$\"))))\n"

#. type: defspec
#: original_texis/control.texi:681
msgid "This moves forward one line and continues moving by lines until it reaches an empty line.  It is peculiar in that the @code{while} has no body, just the end test (which also does the real work of moving point)."
msgstr "これは1行前方に移動して、空行に達するまで行単位の移動を継続する。独特な点は@code{while}がbodyをもたず、終了テスト(これはポイント移動という実処理も行なう)だけを行うことである。"

#. type: Plain text
#: original_texis/control.texi:685
msgid "The @code{dolist} and @code{dotimes} macros provide convenient ways to write two common kinds of loops."
msgstr "マクロ@code{dolist}および@code{dotimes}は、2つの一般的な種類のループを記述する、便利な方法を提供します。"

#. type: defmac
#: original_texis/control.texi:686
#, no-wrap
msgid "dolist (var list [result]) body@dots{}"
msgstr "dolist (var list [result]) body@dots{}"

#. type: defmac
#: original_texis/control.texi:692
msgid "This construct executes @var{body} once for each element of @var{list}, binding the variable @var{var} locally to hold the current element.  Then it returns the value of evaluating @var{result}, or @code{nil} if @var{result} is omitted.  For example, here is how you could use @code{dolist} to define the @code{reverse} function:"
msgstr "この構文は@var{list}の各要素に一度@var{body}を実行して、カレント要素をローカルに保持するように、変数@var{var}にバインドする。その後に@var{result}を評価した値、@var{result}が省略された場合は@code{nil}をリターンする。たとえば以下は@code{reverse}関数を定義するために@code{dolist}を使用する方法の例である:"

#. type: example
#: original_texis/control.texi:698
#, no-wrap
msgid ""
"(defun reverse (list)\n"
"  (let (value)\n"
"    (dolist (elt list value)\n"
"      (setq value (cons elt value)))))\n"
msgstr ""
"(defun reverse (list)\n"
"  (let (value)\n"
"    (dolist (elt list value)\n"
"      (setq value (cons elt value)))))\n"

#. type: defmac
#: original_texis/control.texi:701
#, no-wrap
msgid "dotimes (var count [result]) body@dots{}"
msgstr "dotimes (var count [result]) body@dots{}"

#. type: defmac
#: original_texis/control.texi:707
msgid "This construct executes @var{body} once for each integer from 0 (inclusive) to @var{count} (exclusive), binding the variable @var{var} to the integer for the current iteration.  Then it returns the value of evaluating @var{result}, or @code{nil} if @var{result} is omitted.  Here is an example of using @code{dotimes} to do something 100 times:"
msgstr "この構文は0以上@var{count}未満の各整数にたいして、一度@var{body}を実行してから、繰り返しのカレント回数となる整数を変数@var{var}にバインドする。その後に@var{result}の値、@var{result}が省略された場合は@code{nil}をリターンする。以下は@code{dotimes}を使用して、何らかの処理を100回行なう例である:"

#. type: example
#: original_texis/control.texi:711
#, no-wrap
msgid ""
"(dotimes (i 100)\n"
"  (insert \"I will not obey absurd orders\\n\"))\n"
msgstr ""
"(dotimes (i 100)\n"
"  (insert \"I will not obey absurd orders\\n\"))\n"

#. type: cindex
#: original_texis/control.texi:716
#, no-wrap
msgid "generators"
msgstr "generators"

#. type: Plain text
#: original_texis/control.texi:721
msgid "A @dfn{generator} is a function that produces a potentially-infinite stream of values.  Each time the function produces a value, it suspends itself and waits for a caller to request the next value."
msgstr "@dfn{ジェネレーター(generator)}とは、潜在的に無限な値ストリームを生成する関数です。毎回その関数が値を生成するごとに、呼び出し側が次の値を要求するまで、自身をサスペンドします。"

#. type: defmac
#: original_texis/control.texi:722
#, no-wrap
msgid "iter-defun name args [doc] [declare] [interactive] body@dots{}"
msgstr "iter-defun name args [doc] [declare] [interactive] body@dots{}"

#. type: defmac
#: original_texis/control.texi:731
msgid "@code{iter-defun} defines a generator function.  A generator function has the same signature as a normal function, but works differently.  Instead of executing @var{body} when called, a generator function returns an iterator object.  That iterator runs @var{body} to generate values, emitting a value and pausing where @code{iter-yield} or @code{iter-yield-from} appears.  When @var{body} returns normally, @code{iter-next} signals @code{iter-end-of-sequence} with @var{body}'s result as its condition data."
msgstr "@code{iter-defun}はジェネレーター関数を定義する。ジェネレーター関数は通常の関数と同様のsignatureをもつが、異なるように機能する。ジェネレーター関数は呼び出し時に@var{body}を実行するのではなく、かわりにiteratorオブジェクトをリターンする。このiteratorは値を生成するために@var{body}を実行、値を発行すると@code{iter-yield}か@code{iter-yield-from}が出現するまで一時停止する。@var{body}が正常にリターンした際に、@code{iter-next}がコンディションデータとなる@var{body}の結果とともに、@code{iter-end-of-sequence}をシグナルする。"

#. type: defmac
#: original_texis/control.texi:735
msgid "Any kind of Lisp code is valid inside @var{body}, but @code{iter-yield} and @code{iter-yield-from} cannot appear inside @code{unwind-protect} forms."
msgstr "@var{body}内部では任意の種類のLispコードが有効だが、@code{iter-yield}と@code{iter-yield-from}は@code{unwind-protect}フォームの内部にあってはならない。"

#. type: defmac
#: original_texis/control.texi:738
#, no-wrap
msgid "iter-lambda args [doc] [interactive] body@dots{}"
msgstr "iter-lambda args [doc] [interactive] body@dots{}"

#. type: defmac
#: original_texis/control.texi:741
msgid "@code{iter-lambda} produces an unnamed generator function that works just like a generator function produced with @code{iter-defun}."
msgstr "@code{iter-lambda}は@code{iter-defun}で生成されたジェネレーター関数と同様な、無名のジェネレーター関数を生成する。"

#. type: defmac
#: original_texis/control.texi:743
#, no-wrap
msgid "iter-yield value"
msgstr "iter-yield value"

#. type: defmac
#: original_texis/control.texi:748
msgid "When it appears inside a generator function, @code{iter-yield} indicates that the current iterator should pause and return @var{value} from @code{iter-next}.  @code{iter-yield} evaluates to the @code{value} parameter of next call to @code{iter-next}."
msgstr "@code{iter-yield}がジェネレーター関数内部で出現した際には、カレントiteratorが一時停止して@code{iter-next}から@var{value}をリターンすることを示す。@code{iter-yield}は、次回@code{iter-next}呼び出しの@code{value}パラメーターへと評価される。"

#. type: defmac
#: original_texis/control.texi:750
#, no-wrap
msgid "iter-yield-from iterator"
msgstr "iter-yield-from iterator"

#. type: defmac
#: original_texis/control.texi:755
msgid "@code{iter-yield-from} yields all the values that @var{iterator} produces and evaluates to the value that @var{iterator}'s generator function returns normally.  While it has control, @var{iterator} receives values sent to the iterator using @code{iter-next}."
msgstr "@code{iter-yield-from}は@var{iterator}が生成するすべての値を生成して、その@var{iterator}のジェネレーター関数が通常リターンする値へと評価される。これが制御を得ている間、@var{iterator}は@code{iter-next}を使用して送信された値を受け取る。"

#. type: Plain text
#: original_texis/control.texi:763
msgid "To use a generator function, first call it normally, producing a @dfn{iterator} object.  An iterator is a specific instance of a generator.  Then use @code{iter-next} to retrieve values from this iterator.  When there are no more values to pull from an iterator, @code{iter-next} raises an @code{iter-end-of-sequence} condition with the iterator's final value."
msgstr "ジェネレーター関数を使用するには、まずそれを普通に呼び出して@dfn{iterator}オブジェクトを生成します。iteratorはジェネレーターの固有のインスタンスです。その後でこのiteratorから値を取得するために@code{iter-next}を使用します。iteratorから取得する値がなくなると、@code{iter-next}はそのiteratorの最終値とともに@code{iter-end-of-sequence}のコンディションをraisesします。"

#. type: Plain text
#: original_texis/control.texi:770
msgid "It's important to note that generator function bodies only execute inside calls to @code{iter-next}.  A call to a function defined with @code{iter-defun} produces an iterator; you must drive this iterator with @code{iter-next} for anything interesting to happen.  Each call to a generator function produces a @emph{different} iterator, each with its own state."
msgstr "ジェネレーター関数のbodyは、@code{iter-next}の呼び出しの内側でのみ実行されることに注意することが重要です。@code{iter-defun}で定義された関数の呼び出しはiteratorを生成します。何か興味があることが発生したら、@code{iter-next}でこのiteratorを制御しなければなりません。ジェネレーター関数の個々の呼び出しは、それぞれが独自に状態をもつ@emph{別個}のiteratorを生成します。"

#. type: defun
#: original_texis/control.texi:771
#, no-wrap
msgid "iter-next iterator value"
msgstr "iter-next iterator value"

#. type: defun
#: original_texis/control.texi:777
msgid "Retrieve the next value from @var{iterator}.  If there are no more values to be generated (because @var{iterator}'s generator function returned), @code{iter-next} signals the @code{iter-end-of-sequence} condition; the data value associated with this condition is the value with which @var{iterator}'s generator function returned."
msgstr "@var{iterator}から次の値を取得する。(@var{iterator}のジェネレーター関数がリターンしていて)生成される値が存在しない場合、@code{iter-next}はコンディション@code{iter-end-of-sequence}をシグナルする。このコンディションに関連付けられるデータ値は、@var{iterator}のジェネレーター関数がリターンした値である。"

#. type: defun
#: original_texis/control.texi:783
msgid "@var{value} is sent into the iterator and becomes the value to which @code{iter-yield} evaluates.  @var{value} is ignored for the first @code{iter-next} call to a given iterator, since at the start of @var{iterator}'s generator function, the generator function is not evaluating any @code{iter-yield} form."
msgstr "@var{value}はiteratorに送信されて、@code{iter-yield}を評価した値になる。@var{iterator}のジェネレーター関数の開始時には、ジェネレーター関数は@code{iter-yield}フォームを何も評価していないので、与えられたiteratorにたいする最初の@code{iter-next}呼び出しでは@var{value}は無視される。"

#. type: defun
#: original_texis/control.texi:785
#, no-wrap
msgid "iter-close iterator"
msgstr "iter-close iterator"

#. type: defun
#: original_texis/control.texi:792
msgid "If @var{iterator} is suspended inside an @code{unwind-protect}'s @code{bodyform} and becomes unreachable, Emacs will eventually run unwind handlers after a garbage collection pass.  (Note that @code{iter-yield} is illegal inside an @code{unwind-protect}'s @code{unwindforms}.)  To ensure that these handlers are run before then, use @code{iter-close}."
msgstr "@var{iterator}が@code{unwind-protect}の@code{bodyform}フォーム内でサスペンドされていたら、ガーベージコレクション処理後にEmacsが最終的にunwindハンドラーを実行する(@code{unwind-protect}の@code{unwindforms}内部では@code{iter-yield}は不当であることに注意)。その前に確実にこれらのハンドラーを実行するには、@code{iter-close}を使用すること。"

#. type: Plain text
#: original_texis/control.texi:796
msgid "Some convenience functions are provided to make working with iterators easier:"
msgstr "iteratorを簡単に連携できるように、便利な関数がいくつか提供されています:"

#. type: defmac
#: original_texis/control.texi:797
#, no-wrap
msgid "iter-do (var iterator) body @dots{}"
msgstr "iter-do (var iterator) body @dots{}"

#. type: defmac
#: original_texis/control.texi:800
msgid "Run @var{body} with @var{var} bound to each value that @var{iterator} produces."
msgstr "@var{iterator}が生成する各値を@var{var}にバインドしつつ@var{body}を実行する。"

#. type: Plain text
#: original_texis/control.texi:804
msgid "The Common Lisp loop facility also contains features for working with iterators.  See @xref{Loop Facility,,,cl,Common Lisp Extensions}."
msgstr "Common Lispのループ機能にもiteratorと連携する機能が含まれます。@ref{Loop Facility,,,cl,Common Lisp Extensions}を参照してください。"

#. type: Plain text
#: original_texis/control.texi:807
msgid "The following piece of code demonstrates some important principles of working with iterators."
msgstr "以下のコード片はiteratorとの連携における重要な原則を示すものです。"

#. type: example
#: original_texis/control.texi:814
#, no-wrap
msgid ""
"(require 'generator)\n"
"(iter-defun my-iter (x)\n"
"  (iter-yield (1+ (iter-yield (1+ x))))\n"
"   ;; Return normally\n"
"  -1)\n"
"\n"
msgstr ""
"(require 'generator)\n"
"(iter-defun my-iter (x)\n"
"  (iter-yield (1+ (iter-yield (1+ x))))\n"
"   ;; 普通にリターンする\n"
"  -1)\n"
"\n"

#. type: example
#: original_texis/control.texi:823
#, no-wrap
msgid ""
"(let* ((iter (my-iter 5))\n"
"       (iter2 (my-iter 0)))\n"
"  ;; Prints 6\n"
"  (print (iter-next iter))\n"
"  ;; Prints 9\n"
"  (print (iter-next iter 8))\n"
"  ;; Prints 1; iter and iter2 have distinct states\n"
"  (print (iter-next iter2 nil))\n"
"\n"
msgstr ""
"(let* ((iter (my-iter 5))\n"
"       (iter2 (my-iter 0)))\n"
"  ;; 6をプリント\n"
"  (print (iter-next iter))\n"
"  ;; 9をプリント\n"
"  (print (iter-next iter 8))\n"
"  ;; 1をプリント\n"
"  ;; iterとiterは異なる状態をもつ\n"
"  (print (iter-next iter2 nil))\n"
"\n"

#. type: example
#: original_texis/control.texi:830
#, no-wrap
msgid ""
"  ;; We expect the iter sequence to end now\n"
"  (condition-case x\n"
"      (iter-next iter)\n"
"    (iter-end-of-sequence\n"
"      ;; Prints -1, which my-iter returned normally\n"
"      (print (cdr x)))))\n"
msgstr ""
"  ;; ここでiterシーケンスの終了を待機\n"
"  (condition-case x\n"
"      (iter-next iter)\n"
"    (iter-end-of-sequence\n"
"      ;; my-iterが通常の方法でリターンした-1をプリント\n"
"      (print (cdr x)))))\n"

#. type: cindex
#: original_texis/control.texi:834
#, no-wrap
msgid "nonlocal exits"
msgstr "nonlocal exits"

#. type: Plain text
#: original_texis/control.texi:841
msgid "A @dfn{nonlocal exit} is a transfer of control from one point in a program to another remote point.  Nonlocal exits can occur in Emacs Lisp as a result of errors; you can also use them under explicit control.  Nonlocal exits unbind all variable bindings made by the constructs being exited."
msgstr "@dfn{非ローカル脱出(nonlocal exit)}とは、プログラム内のある位置から別の離れた位置へ制御を移します。Emacs Lispではエラーの結果として非ローカル脱出が発生することがあります。明示的な制御の下で非ローカル脱出を使用することもできます。非ローカル脱出は脱出しようとしている構文により作成された、すべての変数バインディングのバインドを解消します。"

#. type: node
#: original_texis/control.texi:847 original_texis/control.texi:849
#, no-wrap
msgid "Catch and Throw"
msgstr "Catch and Throw"

#. type: menuentry
#: original_texis/control.texi:847
msgid "Nonlocal exits for the program's own purposes."
msgstr "プログラム自身の目的による非ローカル脱出。"

#. type: node
#: original_texis/control.texi:847 original_texis/control.texi:948
#, no-wrap
msgid "Examples of Catch"
msgstr "Examples of Catch"

#. type: menuentry
#: original_texis/control.texi:847
msgid "Showing how such nonlocal exits can be written."
msgstr "このような非ローカル脱出が記述される方法。"

#. type: subsection
#: original_texis/control.texi:847 original_texis/control.texi:1023
#: original_texis/control.texi:1024
#, no-wrap
msgid "Errors"
msgstr "Errors"

#. type: menuentry
#: original_texis/control.texi:847
msgid "How errors are signaled and handled."
msgstr "エラーのシグナルと処理される方法。"

#. type: node
#: original_texis/control.texi:847 original_texis/control.texi:1587
#, no-wrap
msgid "Cleanups"
msgstr "Cleanups"

#. type: menuentry
#: original_texis/control.texi:847
msgid "Arranging to run a cleanup form if an error happens."
msgstr "エラーが発生した場合のクリーンアップフォーム実行のアレンジ。"

#. type: subsection
#: original_texis/control.texi:850
#, no-wrap
msgid "Explicit Nonlocal Exits: @code{catch} and @code{throw}"
msgstr "Explicit Nonlocal Exits: @code{catch} and @code{throw}"

#. type: Plain text
#: original_texis/control.texi:858
msgid "Most control constructs affect only the flow of control within the construct itself.  The function @code{throw} is the exception to this rule of normal program execution: it performs a nonlocal exit on request.  (There are other exceptions, but they are for error handling only.)  @code{throw} is used inside a @code{catch}, and jumps back to that @code{catch}.  For example:"
msgstr "ほとんどの制御構造は、その構文自身の内部の制御フローだけに影響します。関数@code{throw}は、この通常のプログラム実行でのルールの例外です。これはリクエストにより非ローカル脱出を行ないます(他にも例外はあるがそれらはエラー処理用のものだけ)。@code{throw}は@code{catch}の内部で使用され、@code{catch}に制御を戻します。たとえば:"

#. type: group
#: original_texis/control.texi:864
#, no-wrap
msgid ""
"(defun foo-outer ()\n"
"  (catch 'foo\n"
"    (foo-inner)))\n"
"\n"
msgstr ""
"(defun foo-outer ()\n"
"  (catch 'foo\n"
"    (foo-inner)))\n"
"\n"

#. type: group
#: original_texis/control.texi:870
#, no-wrap
msgid ""
"(defun foo-inner ()\n"
"  @dots{}\n"
"  (if x\n"
"      (throw 'foo t))\n"
"  @dots{})\n"
msgstr ""
"(defun foo-inner ()\n"
"  @dots{}\n"
"  (if x\n"
"      (throw 'foo t))\n"
"  @dots{})\n"

#. type: Plain text
#: original_texis/control.texi:878
msgid "The @code{throw} form, if executed, transfers control straight back to the corresponding @code{catch}, which returns immediately.  The code following the @code{throw} is not executed.  The second argument of @code{throw} is used as the return value of the @code{catch}."
msgstr "@code{throw}フォームが実行されると、対応する@code{catch}に制御を移して、@code{catch}は即座にリターンします。@code{throw}の後のコードは実行されません。@code{throw}の2番目の引数は@code{catch}のリターン値として使用されます。"

#. type: Plain text
#: original_texis/control.texi:887
msgid "The function @code{throw} finds the matching @code{catch} based on the first argument: it searches for a @code{catch} whose first argument is @code{eq} to the one specified in the @code{throw}.  If there is more than one applicable @code{catch}, the innermost one takes precedence.  Thus, in the above example, the @code{throw} specifies @code{foo}, and the @code{catch} in @code{foo-outer} specifies the same symbol, so that @code{catch} is the applicable one (assuming there is no other matching @code{catch} in between)."
msgstr "関数@code{throw}は1番目の引数にもとづいて、それにマッチする@code{catch}を探します。@code{throw}は1番目の引数が、@code{throw}で指定されたものと@code{eq}であるような@code{catch}を検索します。複数の該当する@code{catch}がある場合には、最内のものが優先されます。したがって上記の例では@code{throw}が@code{foo}を指定していて、@code{foo-outer}内の@code{catch}が同じシンボルを指定しているので、(この間に他のマッチする@code{catch}は存在しないと仮定するなら)その@code{catch}が該当します。"

#. type: Plain text
#: original_texis/control.texi:897
msgid "Executing @code{throw} exits all Lisp constructs up to the matching @code{catch}, including function calls.  When binding constructs such as @code{let} or function calls are exited in this way, the bindings are unbound, just as they are when these constructs exit normally (@pxref{Local Variables}).  Likewise, @code{throw} restores the buffer and position saved by @code{save-excursion} (@pxref{Excursions}), and the narrowing status saved by @code{save-restriction}.  It also runs any cleanups established with the @code{unwind-protect} special form when it exits that form (@pxref{Cleanups})."
msgstr "@code{throw}の実行により、マッチする@code{catch}までのすべてのLisp構文(関数呼び出しを含む)を脱出します。この方法により@code{let}や関数呼び出しのようなバインディング構文を脱出する場合には、これらの構文を正常にexitしたときのように、そのバインディングは解消されます(@ref{Local Variables}を参照)。同様に@code{throw}は@code{save-excursion}(@ref{Excursions}を参照)によって保存されたバッファーと位置を復元します。@code{throw}がスペシャルフォーム@code{unwind-protect}を脱出した場合には、@code{unwind-protect}により設定されたいくつかのクリーンアップも実行されます。"

#. type: Plain text
#: original_texis/control.texi:905
msgid "The @code{throw} need not appear lexically within the @code{catch} that it jumps to.  It can equally well be called from another function called within the @code{catch}.  As long as the @code{throw} takes place chronologically after entry to the @code{catch}, and chronologically before exit from it, it has access to that @code{catch}.  This is why @code{throw} can be used in commands such as @code{exit-recursive-edit} that throw back to the editor command loop (@pxref{Recursive Editing})."
msgstr "ジャンプ先となる@code{catch}内にレキシカル(局所的)である必要はありません。@code{throw}は@code{catch}内で呼び出された別の関数から、同じようにに呼び出すことができます。@code{throw}が行なわれたのが、時系列的に@code{catch}に入った後で、かつexitする前である限り、その@code{throw}は@code{catch}にアクセスできます。エディターのコマンドループから戻る@code{exit-recursive-edit}のようなコマンドで、@code{throw}が使用されるのはこれが理由です。"

#. type: cindex
#: original_texis/control.texi:906
#, no-wrap
msgid "CL note---only @code{throw} in Emacs"
msgstr "CL note---only @code{throw} in Emacs"

#. type: quotation
#: original_texis/control.texi:913
msgid "@b{Common Lisp note:} Most other versions of Lisp, including Common Lisp, have several ways of transferring control nonsequentially: @code{return}, @code{return-from}, and @code{go}, for example.  Emacs Lisp has only @code{throw}.  The @file{cl-lib} library provides versions of some of these.  @xref{Blocks and Exits,,,cl,Common Lisp Extensions}."
msgstr "@b{Common Lispに関する注意: }Common Lispを含む、他のほとんどのバージョンのLispは非シーケンシャルに制御を移すいくつかの方法 --- たとえば@code{return}、@code{return-from}、@code{go} --- をもつ。Emacs Lispは@code{throw}のみ。@file{cl-lib}ライブラリーはこれらのうちいくつかを提供する。@ref{Blocks and Exits,,,cl,Common Lisp Extensions}を参照のこと。"

#. type: defspec
#: original_texis/control.texi:915
#, no-wrap
msgid "catch tag body@dots{}"
msgstr "catch tag body@dots{}"

#. type: cindex
#: original_texis/control.texi:916
#, no-wrap
msgid "tag on run time stack"
msgstr "tag on run time stack"

#. type: defspec
#: original_texis/control.texi:921
msgid "@code{catch} establishes a return point for the @code{throw} function.  The return point is distinguished from other such return points by @var{tag}, which may be any Lisp object except @code{nil}.  The argument @var{tag} is evaluated normally before the return point is established."
msgstr "@code{catch}は@code{throw}関数にたいするリターン位置を確立する。リターン位置は@var{tag}により、この種の他のリターン位置と区別される。@var{tag}は@code{nil}以外の任意のLispオブジェクト。リターン位置が確立される前に、引数@var{tag}は通常どおり評価される。"

#. type: defspec
#: original_texis/control.texi:926
msgid "With the return point in effect, @code{catch} evaluates the forms of the @var{body} in textual order.  If the forms execute normally (without error or nonlocal exit) the value of the last body form is returned from the @code{catch}."
msgstr "リターン位置が効果をもつことにより、@code{catch}は@var{body}のフォームをテキスト順に評価する。フォームが(エラーや非ローカル脱出なしで)通常に実行されたなら、bodyの最後のフォームの値が@code{catch}からリターンされる。"

#. type: defspec
#: original_texis/control.texi:931
msgid "If a @code{throw} is executed during the execution of @var{body}, specifying the same value @var{tag}, the @code{catch} form exits immediately; the value it returns is whatever was specified as the second argument of @code{throw}."
msgstr "@var{body}の実行の間に@code{throw}が実行された場合、@var{tag}と同じ値を指定すると@code{catch}フォームは即座にexitする。リターンされる値は、それが何であれ@code{throw}の2番目の引数に指定された値である。"

#. type: defun
#: original_texis/control.texi:933
#, no-wrap
msgid "throw tag value"
msgstr "throw tag value"

#. type: defun
#: original_texis/control.texi:939
msgid "The purpose of @code{throw} is to return from a return point previously established with @code{catch}.  The argument @var{tag} is used to choose among the various existing return points; it must be @code{eq} to the value specified in the @code{catch}.  If multiple return points match @var{tag}, the innermost one is used."
msgstr "@code{throw}の目的は、以前に@code{catch}により確立されたリターン位置に戻ることである。引数@var{tag}は、既存のさまざまなリターン位置からリターン位置を選択するために使用される。複数のリターン位置が@var{tag}にマッチしたら、最内のものが使用される。"

#. type: defun
#: original_texis/control.texi:942
msgid "The argument @var{value} is used as the value to return from that @code{catch}."
msgstr "引数@var{value}は@code{catch}からリターンされる値として使用される。"

#. type: kindex
#: original_texis/control.texi:943
#, no-wrap
msgid "no-catch"
msgstr "no-catch"

#. type: defun
#: original_texis/control.texi:946
msgid "If no return point is in effect with tag @var{tag}, then a @code{no-catch} error is signaled with data @code{(@var{tag} @var{value})}."
msgstr "タグ@var{tag}のリターン位置が存在しなければ、データ@code{(@var{tag} @var{value})}とともに@code{no-catch}エラーがシグナルされます。"

#. type: subsection
#: original_texis/control.texi:949
#, no-wrap
msgid "Examples of @code{catch} and @code{throw}"
msgstr "Examples of @code{catch} and @code{throw}"

#. type: Plain text
#: original_texis/control.texi:955
msgid "One way to use @code{catch} and @code{throw} is to exit from a doubly nested loop.  (In most languages, this would be done with a @code{goto}.)  Here we compute @code{(foo @var{i} @var{j})} for @var{i} and @var{j} varying from 0 to 9:"
msgstr "2重にネストされたループから脱出する1つの方法は、@code{catch}と@code{throw}を使うことです(これはほとんどの言語では@code{goto}により行なわれるだろう)。ここでは@var{i}と@var{j}を0から9に変化させて、@code{(foo @var{i} @var{j})}を計算します:"

#. type: group
#: original_texis/control.texi:968
#, no-wrap
msgid ""
"(defun search-foo ()\n"
"  (catch 'loop\n"
"    (let ((i 0))\n"
"      (while (< i 10)\n"
"        (let ((j 0))\n"
"          (while (< j 10)\n"
"            (if (foo i j)\n"
"                (throw 'loop (list i j)))\n"
"            (setq j (1+ j))))\n"
"        (setq i (1+ i))))))\n"
msgstr ""
"(defun search-foo ()\n"
"  (catch 'loop\n"
"    (let ((i 0))\n"
"      (while (< i 10)\n"
"        (let ((j 0))\n"
"          (while (< j 10)\n"
"            (if (foo i j)\n"
"                (throw 'loop (list i j)))\n"
"            (setq j (1+ j))))\n"
"        (setq i (1+ i))))))\n"

#. type: Plain text
#: original_texis/control.texi:976
msgid "If @code{foo} ever returns non-@code{nil}, we stop immediately and return a list of @var{i} and @var{j}.  If @code{foo} always returns @code{nil}, the @code{catch} returns normally, and the value is @code{nil}, since that is the result of the @code{while}."
msgstr "@code{foo}が非@code{nil}をリターンしたら即座に処理を中止して、@var{i}と@var{j}のリストをリターンしています。@code{foo}が常に@code{nil}をリターンする場合には、@code{catch}は通常どおりリターンして、その値は@code{while}の結果である@code{nil}となります。"

#. type: Plain text
#: original_texis/control.texi:980
msgid "Here are two tricky examples, slightly different, showing two return points at once.  First, two return points with the same tag, @code{hack}:"
msgstr "以下では2つのリターン位置を一度に表す、微妙に異なるトリッキーな例を2つ示します。まず同じタグ@code{hack}にたいして2つのリターン位置があります:"

#. type: group
#: original_texis/control.texi:987
#, no-wrap
msgid ""
"(defun catch2 (tag)\n"
"  (catch tag\n"
"    (throw 'hack 'yes)))\n"
"@result{} catch2\n"
msgstr ""
"(defun catch2 (tag)\n"
"  (catch tag\n"
"    (throw 'hack 'yes)))\n"
"@result{} catch2\n"

#. type: group
#: original_texis/control.texi:995
#, no-wrap
msgid ""
"(catch 'hack\n"
"  (print (catch2 'hack))\n"
"  'no)\n"
"@print{} yes\n"
"@result{} no\n"
msgstr ""
"(catch 'hack\n"
"  (print (catch2 'hack))\n"
"  'no)\n"
"@print{} yes\n"
"@result{} no\n"

#. type: Plain text
#: original_texis/control.texi:1004
msgid "Since both return points have tags that match the @code{throw}, it goes to the inner one, the one established in @code{catch2}.  Therefore, @code{catch2} returns normally with value @code{yes}, and this value is printed.  Finally the second body form in the outer @code{catch}, which is @code{'no}, is evaluated and returned from the outer @code{catch}."
msgstr "どちらのリターン位置も@code{throw}にマッチするタグをもつので内側のもの、つまり@code{catch2}で確立されたcatchへgotoします。したがって@code{catch2}は通常どおり値@code{yes}をリターンして、その値がプリントされます。最後に外側の@code{catch}の2番目のbody、つまり@code{'no}が評価されて外側の@code{catch}からそれがリターンされます。"

#. type: Plain text
#: original_texis/control.texi:1006
msgid "Now let's change the argument given to @code{catch2}:"
msgstr "ここで@code{catch2}に与える引数を変更してみましょう:"

#. type: group
#: original_texis/control.texi:1013
#, no-wrap
msgid ""
"(catch 'hack\n"
"  (print (catch2 'quux))\n"
"  'no)\n"
"@result{} yes\n"
msgstr ""
"(catch 'hack\n"
"  (print (catch2 'quux))\n"
"  'no)\n"
"@result{} yes\n"

#. type: Plain text
#: original_texis/control.texi:1022
msgid "We still have two return points, but this time only the outer one has the tag @code{hack}; the inner one has the tag @code{quux} instead.  Therefore, @code{throw} makes the outer @code{catch} return the value @code{yes}.  The function @code{print} is never called, and the body-form @code{'no} is never evaluated."
msgstr "この場合も2つのリターン位置がありますが、今回は外側だけがタグ@code{hack}で、内側はかわりにタグ@code{quux}をもちます。したがって@code{throw}により、外側の@code{catch}が値@code{yes}をリターンします。関数@code{print}が呼び出されることはなくbodyのフォーム@code{'no}も決して評価されません。"

#. type: cindex
#: original_texis/control.texi:1025
#, no-wrap
msgid "errors"
msgstr "errors"

#. type: Plain text
#: original_texis/control.texi:1029
msgid "When Emacs Lisp attempts to evaluate a form that, for some reason, cannot be evaluated, it @dfn{signals} an @dfn{error}."
msgstr "Emacs Lispが何らかの理由で評価できないようなフォームの評価を試みると、@dfn{エラー(error)}が@dfn{シグナル(signal)}されます。"

#. type: Plain text
#: original_texis/control.texi:1034
msgid "When an error is signaled, Emacs's default reaction is to print an error message and terminate execution of the current command.  This is the right thing to do in most cases, such as if you type @kbd{C-f} at the end of the buffer."
msgstr "エラーがシグナルされるとエラーメッセージを表示して、カレントコマンドの実行を終了するのがEmacsデフォルトの反応です。たとえばバッファーの最後で@kbd{C-f}とタイプしたときのように、ほとんどの場合にはこれは正しい反応になります。"

#. type: Plain text
#: original_texis/control.texi:1044
msgid "In complicated programs, simple termination may not be what you want.  For example, the program may have made temporary changes in data structures, or created temporary buffers that should be deleted before the program is finished.  In such cases, you would use @code{unwind-protect} to establish @dfn{cleanup expressions} to be evaluated in case of error.  (@xref{Cleanups}.)  Occasionally, you may wish the program to continue execution despite an error in a subroutine.  In these cases, you would use @code{condition-case} to establish @dfn{error handlers} to recover control in case of error."
msgstr "複雑なプログラムでは単なる終了が望ましくない場合もあるでしょう。たとえばそのプログラムがータ構造に一時的に変更を行なっていたり、プログラム終了前に削除する必要がある一時バッファーを作成しているかもしれません。このような場合には、エラー時に評価される@dfn{クリーンアップ式(cleanup expressions)}を設定するために、@code{unwind-protect}を使用するでしょう(@ref{Cleanups}を参照)。サブルーチン内のエラーにもかかわらずに、プログラムの実行を継続したいときがあるかもしれません。このような場合には、エラー時のリカバリーを制御する@dfn{エラーハンドラー(error handlers)}を設定するために@code{condition-case}を使用するでしょう。"

#. type: Plain text
#: original_texis/control.texi:1048
msgid "Resist the temptation to use error handling to transfer control from one part of the program to another; use @code{catch} and @code{throw} instead.  @xref{Catch and Throw}."
msgstr "エラーハンドラーを使用せずにプログラムの一部から別の部分へ制御を移すためには、@code{catch}と@code{throw}を使用します。@ref{Catch and Throw}を参照してください。"

#. type: node
#: original_texis/control.texi:1054 original_texis/control.texi:1056
#, no-wrap
msgid "Signaling Errors"
msgstr "Signaling Errors"

#. type: menuentry
#: original_texis/control.texi:1054
msgid "How to report an error."
msgstr "エラーを報告する方法。"

#. type: node
#: original_texis/control.texi:1054 original_texis/control.texi:1181
#, no-wrap
msgid "Processing of Errors"
msgstr "Processing of Errors"

#. type: menuentry
#: original_texis/control.texi:1054
msgid "What Emacs does when you report an error."
msgstr "エラーを報告するときEmacsが何を行なうか。"

#. type: node
#: original_texis/control.texi:1054 original_texis/control.texi:1218
#, no-wrap
msgid "Handling Errors"
msgstr "Handling Errors"

#. type: menuentry
#: original_texis/control.texi:1054
msgid "How you can trap errors and continue execution."
msgstr "エラーをトラップして実行を継続する方法。"

#. type: node
#: original_texis/control.texi:1054 original_texis/control.texi:1489
#, no-wrap
msgid "Error Symbols"
msgstr "Error Symbols"

#. type: menuentry
#: original_texis/control.texi:1054
msgid "How errors are classified for trapping them."
msgstr "エラートラプのためにエラーをクラス分けする方法。"

#. type: subsubsection
#: original_texis/control.texi:1057
#, no-wrap
msgid "How to Signal an Error"
msgstr "How to Signal an Error"

#. type: cindex
#: original_texis/control.texi:1058
#, no-wrap
msgid "signaling errors"
msgstr "signaling errors"

#. type: Plain text
#: original_texis/control.texi:1065
msgid "@dfn{Signaling} an error means beginning error processing.  Error processing normally aborts all or part of the running program and returns to a point that is set up to handle the error (@pxref{Processing of Errors}).  Here we describe how to signal an error."
msgstr "エラーの@dfn{シグナリング(signaling)}とは、エラーの処理を開始することを意味します。エラー処理は通常は実行中のプログラムのすべて、または一部をアボート(abort)してエラーをハンドルするためにセットアップされた位置にリターンします。ここではエラーをシグナルする方法を記述します。"

#. type: Plain text
#: original_texis/control.texi:1071
msgid "Most errors are signaled automatically within Lisp primitives which you call for other purposes, such as if you try to take the @sc{car} of an integer or move forward a character at the end of the buffer.  You can also signal errors explicitly with the functions @code{error} and @code{signal}."
msgstr "ほとんどのエラーは、たとえば整数にたいして@sc{car}の取得を試みたり、バッファーの最後で1文字前方に移動したときなどのように、他の目的のために呼び出したLispプリミティブ関数の中で自動的にシグナルされます。関数@code{error}と@code{signal}で明示的にエラーをシグナルすることもできます。"

#. type: Plain text
#: original_texis/control.texi:1075
msgid "Quitting, which happens when the user types @kbd{C-g}, is not considered an error, but it is handled almost like an error.  @xref{Quitting}."
msgstr "ユーザーが@kbd{C-g}をタイプしたときに発生するquitはエラーとは判断されませんが、ほとんどはエラーと同様に扱われます。@ref{Quitting}を参照してください。"

#. type: Plain text
#: original_texis/control.texi:1081
msgid "Every error specifies an error message, one way or another.  The message should state what is wrong (``File does not exist''), not how things ought to be (``File must exist'').  The convention in Emacs Lisp is that error messages should start with a capital letter, but should not end with any sort of punctuation."
msgstr "すべてのエラーメッセージはそれぞれ、何らかのエラーメッセージを指定します。そのメッセージは何が悪いのか(``File does not exist'')、物事がどうしてそうあるべきではない(``File must exist'')かを示すべきです。Emacs Lispの慣習ではエラーメッセージは大文字で開始され、区切り文字で終わるべきではありません。"

#. type: defun
#: original_texis/control.texi:1082
#, no-wrap
msgid "error format-string &rest args"
msgstr "error format-string &rest args"

#. type: defun
#: original_texis/control.texi:1086
msgid "This function signals an error with an error message constructed by applying @code{format-message} (@pxref{Formatting Strings}) to @var{format-string} and @var{args}."
msgstr "この関数は@var{format-string}と@var{args}にたいして、@code{format-message} (@ref{Formatting Strings}を参照)を適用して構築されたエラーメッセージとともに、エラーをシグナルする。"

#. type: defun
#: original_texis/control.texi:1088
msgid "These examples show typical uses of @code{error}:"
msgstr "以下は@code{error}を使用する典型的な例である:"

#. type: group
#: original_texis/control.texi:1093
#, no-wrap
msgid ""
"(error \"That is an error -- try something else\")\n"
"     @error{} That is an error -- try something else\n"
msgstr ""
"(error \"That is an error -- try something else\")\n"
"     @error{} That is an error -- try something else\n"

#. type: group
#: original_texis/control.texi:1098
#, no-wrap
msgid ""
"(error \"Invalid name `%s'\" \"A%%B\")\n"
"     @error{} Invalid name ‘A%%B’\n"
msgstr ""
"(error \"Invalid name `%s'\" \"A%%B\")\n"
"     @error{} Invalid name ‘A%%B’\n"

#. type: defun
#: original_texis/control.texi:1104
msgid "@code{error} works by calling @code{signal} with two arguments: the error symbol @code{error}, and a list containing the string returned by @code{format-message}."
msgstr "2つの引数 --- エラーシンボル@code{error}と@code{format-message}がリターンするる文字列を含むリスト --- で@code{signal}を呼び出すことにより@code{error}は機能する。"

#. type: defun
#: original_texis/control.texi:1109
msgid "Typically grave accent and apostrophe in the format translate to matching curved quotes, e.g., @t{\"Missing `%s'\"} might result in @t{\"Missing ‘foo’\"}.  @xref{Text Quoting Style}, for how to influence or inhibit this translation."
msgstr "@t{\"Missing `%s'\"}が@t{\"Missing ‘foo’\"}となるように、通常はフォーマット内のgrave accentとapostropheはマッチするcurved quotesに変換される。この変換の効果や抑制については@ref{Text Quoting Style}を参照のこと。"

#. type: defun
#: original_texis/control.texi:1115
msgid "@strong{Warning:} If you want to use your own string as an error message verbatim, don't just write @code{(error @var{string})}.  If @var{string} @var{string} contains @samp{%}, @samp{`}, or @samp{'} it may be reformatted, with undesirable results.  Instead, use @code{(error \"%s\" @var{string})}."
msgstr "@strong{警告: }エラーメッセージとして固定の文字列を使用したい場合、単に@code{(error @var{string})}とは記述しないこと。もし@var{string}が@samp{%}、@samp{`}、@samp{'}を含んでいると、再フォーマットされて望む結果は得られないだろう。かわりに、@code{(error \"%s\" @var{string})}を使用すること。"

#. type: defun
#: original_texis/control.texi:1117
#, no-wrap
msgid "signal error-symbol data"
msgstr "signal error-symbol data"

#. type: anchor{#1}
#: original_texis/control.texi:1122
msgid "Definition of signal"
msgstr "Definition of signal"

#. type: defun
#: original_texis/control.texi:1122
msgid "This function signals an error named by @var{error-symbol}.  The argument @var{data} is a list of additional Lisp objects relevant to the circumstances of the error."
msgstr "この関数は@var{error-symbol}で命名されるエラーをシグナルする。引数@var{data}はエラー状況に関連する追加のLispオブジェクトのリスト。"

#. type: defun
#: original_texis/control.texi:1127
msgid "The argument @var{error-symbol} must be an @dfn{error symbol}---a symbol defined with @code{define-error}.  This is how Emacs Lisp classifies different sorts of errors.  @xref{Error Symbols}, for a description of error symbols, error conditions and condition names."
msgstr "引数@var{error-symbol}は@dfn{エラーシンボル(error symbol)} --- @code{define-error}で定義されたシンボル --- でなければならない。これはEmacs Lispが異なる種類のエラーをクラス分けする方法である。エラーシンボル(error symbol)、エラーコンディション(error condition)、コンディション名(condition name)の説明については@ref{Error Symbols}を参照のこと。"

#. type: defun
#: original_texis/control.texi:1135
msgid "If the error is not handled, the two arguments are used in printing the error message.  Normally, this error message is provided by the @code{error-message} property of @var{error-symbol}.  If @var{data} is non-@code{nil}, this is followed by a colon and a comma separated list of the unevaluated elements of @var{data}.  For @code{error}, the error message is the @sc{car} of @var{data} (that must be a string).  Subcategories of @code{file-error} are handled specially."
msgstr "エラーが処理されない場合には、エラーメッセージをプリントするために2つの引数が使用される。このエラーメッセージは通常、@var{error-symbol}の@code{error-message}プロパティーにより提供される。@var{data}が非@code{nil}なら、その後にコロンと@var{data}の未評価の要素をカンマで区切ったリストが続く。@code{error}にたいするエラーメッセージは@var{data}の@sc{car}である(文字列であること)。サブカテゴリー@code{file-error}は特別に処理される。"

#. type: defun
#: original_texis/control.texi:1140
msgid "The number and significance of the objects in @var{data} depends on @var{error-symbol}.  For example, with a @code{wrong-type-argument} error, there should be two objects in the list: a predicate that describes the type that was expected, and the object that failed to fit that type."
msgstr "@var{data}内のオブジェクトの数と意味は@var{error-symbol}に依存する。たとえば@code{wrong-type-argument}エラーではリスト内に2つのオブジェクト --- 期待する型を記述する述語とその型への適合に失敗したオブジェクト --- であること。"

#. type: defun
#: original_texis/control.texi:1145
msgid "Both @var{error-symbol} and @var{data} are available to any error handlers that handle the error: @code{condition-case} binds a local variable to a list of the form @code{(@var{error-symbol} .@: @var{data})} (@pxref{Handling Errors})."
msgstr "エラーを処理する任意のエラーハンドラーにたいして@var{error-symbol}と@var{data}の両方を利用できる。@code{condition-case}はローカル変数を@code{(@var{error-symbol} .@: @var{data})}というフォームでバインドする(@ref{Handling Errors}を参照)。"

#. type: defun
#: original_texis/control.texi:1148
msgid "The function @code{signal} never returns."
msgstr "関数@code{signal}は決してリターンしない。"

#. type: group
#: original_texis/control.texi:1153
#, no-wrap
msgid ""
"(signal 'wrong-number-of-arguments '(x y))\n"
"     @error{} Wrong number of arguments: x, y\n"
msgstr ""
"(signal 'wrong-number-of-arguments '(x y))\n"
"     @error{} Wrong number of arguments: x, y\n"

#. type: group
#: original_texis/control.texi:1158
#, no-wrap
msgid ""
"(signal 'no-such-error '(\"My unknown error condition\"))\n"
"     @error{} peculiar error: \"My unknown error condition\"\n"
msgstr ""
"(signal 'no-such-error '(\"My unknown error condition\"))\n"
"     @error{} peculiar error: \"My unknown error condition\"\n"

#. type: cindex
#: original_texis/control.texi:1162
#, no-wrap
msgid "user errors, signaling"
msgstr "user errors, signaling"

#. type: defun
#: original_texis/control.texi:1163
#, no-wrap
msgid "user-error format-string &rest args"
msgstr "user-error format-string &rest args"

#. type: defun
#: original_texis/control.texi:1173
msgid "This function behaves exactly like @code{error}, except that it uses the error symbol @code{user-error} rather than @code{error}.  As the name suggests, this is intended to report errors on the part of the user, rather than errors in the code itself.  For example, if you try to use the command @code{Info-history-back} (@kbd{l}) to move back beyond the start of your Info browsing history, Emacs signals a @code{user-error}.  Such errors do not cause entry to the debugger, even when @code{debug-on-error} is non-@code{nil}.  @xref{Error Debugging}."
msgstr "この関数は、@code{error}とまったく同じように振る舞うが、@code{error}ではなくエラーシンボル@code{user-error}を使用する。名前が示唆するように、このエラーはコード自身のエラーではなく、ユーザー側のエラーの報告を意図している。たとえばInfoの閲覧履歴の開始を超えて履歴を遡るためにコマンド@code{Info-history-back} (@kbd{l})を使用した場合、Emacsは@code{user-error}をシグナルする。このようなエラーでは、たとえ@code{debug-on-error}が非@code{nil}であっても、デバッガーへのエントリーは発生しない。@ref{Error Debugging}を参照のこと。"

#. type: cindex
#: original_texis/control.texi:1175
#, no-wrap
msgid "CL note---no continuable errors"
msgstr "CL note---no continuable errors"

#. type: quotation
#: original_texis/control.texi:1179
msgid "@b{Common Lisp note:} Emacs Lisp has nothing like the Common Lisp concept of continuable errors."
msgstr "@b{Common Lispに関する注意: }Emacs LispにはCommon Lispのような継続可能なエラーのような概念は存在しない。"

#. type: subsubsection
#: original_texis/control.texi:1182
#, no-wrap
msgid "How Emacs Processes Errors"
msgstr "How Emacs Processes Errors"

#. type: cindex
#: original_texis/control.texi:1183
#, no-wrap
msgid "processing of errors"
msgstr "processing of errors"

#. type: Plain text
#: original_texis/control.texi:1193
msgid "When an error is signaled, @code{signal} searches for an active @dfn{handler} for the error.  A handler is a sequence of Lisp expressions designated to be executed if an error happens in part of the Lisp program.  If the error has an applicable handler, the handler is executed, and control resumes following the handler.  The handler executes in the environment of the @code{condition-case} that established it; all functions called within that @code{condition-case} have already been exited, and the handler cannot return to them."
msgstr "エラーがシグナルされたとき、@code{signal}はそのエラーにたいするアクティブな@dfn{ハンドラー(handler)}を検索します。ハンドラーとは、Lispプログラムの一部でエラーが発生したときに実行するよう意図されたLisp式のシーケンスです。そのエラーが適切なハンドラーをもっていればそのハンドラーが実行され、そのハンドラーの後から実行が再開されます。ハンドラーはそのハンドラーが設定された@code{condition-case}の環境内で実行されます。@code{condition-case}内のすべての関数呼び出しはすでに終了しているので、ハンドラーがそれらにリターンすることはありません。"

#. type: Plain text
#: original_texis/control.texi:1200
msgid "If there is no applicable handler for the error, it terminates the current command and returns control to the editor command loop.  (The command loop has an implicit handler for all kinds of errors.)  The command loop's handler uses the error symbol and associated data to print an error message.  You can use the variable @code{command-error-function} to control how this is done:"
msgstr "そのエラーにたいする適切なハンドラーが存在しなければ、カレントコマンドを終了してエディターのコマンドループに制御をリターンします(コマンドループにはすべての種類のエラーにたいする暗黙のハンドラーがある)。コマンドループのハンドラーは、エラーメッセージをプリントするためにエラーシンボルと、それに関連付けられたデータを使用します。変数@code{command-error-function}を使用して、これが行なわれる方法を制御できます:"

#. type: defvar
#: original_texis/control.texi:1201
#, no-wrap
msgid "command-error-function"
msgstr "command-error-function"

#. type: defvar
#: original_texis/control.texi:1209
msgid "This variable, if non-@code{nil}, specifies a function to use to handle errors that return control to the Emacs command loop.  The function should take three arguments: @var{data}, a list of the same form that @code{condition-case} would bind to its variable; @var{context}, a string describing the situation in which the error occurred, or (more often) @code{nil}; and @var{caller}, the Lisp function which called the primitive that signaled the error."
msgstr "この変数が非@code{nil}なら、それはEmacsのコマンドループに制御をリターンしたエラーの処理に使用する関数を指定する。この関数は3つの引数を受け取る。1つ目の@var{data}は、@code{condition-case}が自身の変数にバインドするのと同じフォーム。2つ目の@var{context}はエラーが発生した状況を記述する文字列か、(大抵は)@code{nil}。3つ目の@var{caller}はエラーをシグナルしたプリミティブ関数を呼び出したLisp関数。"

#. type: cindex
#: original_texis/control.texi:1211
#, no-wrap
msgid "@code{debug-on-error} use"
msgstr "@code{debug-on-error} use"

#. type: Plain text
#: original_texis/control.texi:1217
msgid "An error that has no explicit handler may call the Lisp debugger.  The debugger is enabled if the variable @code{debug-on-error} (@pxref{Error Debugging}) is non-@code{nil}.  Unlike error handlers, the debugger runs in the environment of the error, so that you can examine values of variables precisely as they were at the time of the error."
msgstr "明示的なハンドラーがないエラーは、Lispデバッガーを呼び出すかもしれません。変数@code{debug-on-error} (@ref{Error Debugging}を参照)が非@code{nil}ならデバッガーが有効です。エラーハンドラーと異なり、デバッガーはそのエラーの環境内で実行されるので、エラー時の変数の値を正確に調べることができます。"

#. type: subsubsection
#: original_texis/control.texi:1219
#, no-wrap
msgid "Writing Code to Handle Errors"
msgstr "Writing Code to Handle Errors"

#. type: cindex
#: original_texis/control.texi:1220
#, no-wrap
msgid "error handler"
msgstr "error handler"

#. type: cindex
#: original_texis/control.texi:1221
#, no-wrap
msgid "handling errors"
msgstr "handling errors"

#. type: Plain text
#: original_texis/control.texi:1228
msgid "The usual effect of signaling an error is to terminate the command that is running and return immediately to the Emacs editor command loop.  You can arrange to trap errors occurring in a part of your program by establishing an error handler, with the special form @code{condition-case}.  A simple example looks like this:"
msgstr "エラーをシグナルすることによる通常の効果は、実行されていたコマンドを終了してEmacsエディターのコマンドループに即座にリターンすることです。スペシャルフォーム@code{condition-case}を使用してエラーハンドラーを設定することにより、プログラム内の一部で発生するエラーのをトラップを調整することができます。以下は単純な例です:"

#. type: group
#: original_texis/control.texi:1234
#, no-wrap
msgid ""
"(condition-case nil\n"
"    (delete-file filename)\n"
"  (error nil))\n"
msgstr ""
"(condition-case nil\n"
"    (delete-file filename)\n"
"  (error nil))\n"

#. type: Plain text
#: original_texis/control.texi:1241
msgid "This deletes the file named @var{filename}, catching any error and returning @code{nil} if an error occurs.  (You can use the macro @code{ignore-errors} for a simple case like this; see below.)"
msgstr "これは@var{filename}という名前のファイルを削除して、任意のエラーをcatch、エラーが発生した場合は@code{nil}をリターンします(このような単純なケースではマクロ@code{ignore-errors}を使用することもできる。以下を参照のこと)。"

#. type: Plain text
#: original_texis/control.texi:1247
msgid "The @code{condition-case} construct is often used to trap errors that are predictable, such as failure to open a file in a call to @code{insert-file-contents}.  It is also used to trap errors that are totally unpredictable, such as when the program evaluates an expression read from the user."
msgstr "@code{condition-case}構文は、@code{insert-file-contents}呼び出しによるファイルオープンの失敗のような、予想できるエラーをトラップするために多用されます。@code{condition-case}構文はユーザーから読み取った式を評価するプログラムのような、完全には予測できないエラーのトラップにも使用されます。"

#. type: Plain text
#: original_texis/control.texi:1258
msgid "The second argument of @code{condition-case} is called the @dfn{protected form}.  (In the example above, the protected form is a call to @code{delete-file}.)  The error handlers go into effect when this form begins execution and are deactivated when this form returns.  They remain in effect for all the intervening time.  In particular, they are in effect during the execution of functions called by this form, in their subroutines, and so on.  This is a good thing, since, strictly speaking, errors can be signaled only by Lisp primitives (including @code{signal} and @code{error}) called by the protected form, not by the protected form itself."
msgstr "@code{condition-case}の2番目の引数は@dfn{保護されたフォーム(protected form)}と呼ばれます(上記の例では保護されたフォームは@code{delete-file}の呼び出し)。このフォームの実行が開始されるとエラーハンドラーが効果をもち、このフォームがリターンすると不活性になります。その間のすべてにおいてエラーハンドラーは効果をもちます。特にこのフォームで呼び出された関数とそのサブルーチン等を実行する間、エラーハンドラーは効果をもちます。厳密にいうと保護されたフォーム自身ではなく、保護されたフォームから呼び出されたLispプリミティブ関数(@code{signal}と@code{error}を含む)だけがシグナルされるというのは、よいことと言えます。"

#. type: Plain text
#: original_texis/control.texi:1266
msgid "The arguments after the protected form are handlers.  Each handler lists one or more @dfn{condition names} (which are symbols) to specify which errors it will handle.  The error symbol specified when an error is signaled also defines a list of condition names.  A handler applies to an error if they have any condition names in common.  In the example above, there is one handler, and it specifies one condition name, @code{error}, which covers all errors."
msgstr "保護されたフォームの後の引数はハンドラーです。各ハンドラーはそれぞれ、どのエラーを処理するかを指定する1つ以上の@dfn{コンディション名}(シンボル)をリストします。エラーがシグナルされたとき、エラーシンボルはコンディション名のリストも定義します。エラーが共通のコンディション名をもつ場合、そのハンドラーがそのエラーに適用されます。上記の例では1つのハンドラーがあり、それはすべてのエラーをカバーするコンディション名@code{error}を指定しています。"

#. type: Plain text
#: original_texis/control.texi:1271
msgid "The search for an applicable handler checks all the established handlers starting with the most recently established one.  Thus, if two nested @code{condition-case} forms offer to handle the same error, the inner of the two gets to handle it."
msgstr "適切なハンドラーの検索は、もっとも最近に設定されたハンドラーから始まり、設定されたすべてのハンドラーをチェックします。したがってネストされた@code{condition-case}フォームに同じエラー処理がある場合には、内側のハンドラーがそれを処理します。"

#. type: Plain text
#: original_texis/control.texi:1275
msgid "If an error is handled by some @code{condition-case} form, this ordinarily prevents the debugger from being run, even if @code{debug-on-error} says this error should invoke the debugger."
msgstr "何らかの@code{condition-case}によりエラーが処理されると、@code{debug-on-error}でエラーによりデバッガーが呼び出されるようにしていても、通常はデバッガーの実行が抑制されます。"

#. type: Plain text
#: original_texis/control.texi:1281
msgid "If you want to be able to debug errors that are caught by a @code{condition-case}, set the variable @code{debug-on-signal} to a non-@code{nil} value.  You can also specify that a particular handler should let the debugger run first, by writing @code{debug} among the conditions, like this:"
msgstr "@code{condition-case}で補足されるようなエラーをデバッグできるようにしたいなら、変数@code{debug-on-signal}に非@code{nil}値をセットします。以下のようにコンディション内に@code{debug}を記述することにより、最初にデバッガーを実行するような特定のハンドラーを指定することもできます:"

#. type: group
#: original_texis/control.texi:1287
#, no-wrap
msgid ""
"(condition-case nil\n"
"    (delete-file filename)\n"
"  ((debug error) nil))\n"
msgstr ""
"(condition-case nil\n"
"    (delete-file filename)\n"
"  ((debug error) nil))\n"

#. type: Plain text
#: original_texis/control.texi:1295
msgid "The effect of @code{debug} here is only to prevent @code{condition-case} from suppressing the call to the debugger.  Any given error will invoke the debugger only if @code{debug-on-error} and the other usual filtering mechanisms say it should.  @xref{Error Debugging}."
msgstr "ここでの@code{debug}の効果は、デバッガー呼び出しを抑制する@code{condition-case}を防ぐことだけです。@code{debug-on-error}とその他のフィルタリングメカニズムがデバッガーを呼び出すように指定されているときだけ、エラーによりデバッガーが呼び出されます。@ref{Error Debugging}を参照してください。"

#. type: defmac
#: original_texis/control.texi:1296
#, no-wrap
msgid "condition-case-unless-debug var protected-form handlers@dots{}"
msgstr "condition-case-unless-debug var protected-form handlers@dots{}"

#. type: defmac
#: original_texis/control.texi:1301
msgid "The macro @code{condition-case-unless-debug} provides another way to handle debugging of such forms.  It behaves exactly like @code{condition-case}, unless the variable @code{debug-on-error} is non-@code{nil}, in which case it does not handle any errors at all."
msgstr "マクロ@code{condition-case-unless-debug}は、そのようなフォームのデバッギングを処理する、別の方法を提供する。このマクロは変数@code{debug-on-error}が@code{nil}、つまり任意のエラーを処理しないようなケース以外は、@code{condition-case}とまったく同様に振る舞う。"

#. type: Plain text
#: original_texis/control.texi:1309
msgid "Once Emacs decides that a certain handler handles the error, it returns control to that handler.  To do so, Emacs unbinds all variable bindings made by binding constructs that are being exited, and executes the cleanups of all @code{unwind-protect} forms that are being exited.  Once control arrives at the handler, the body of the handler executes normally."
msgstr "特定のハンドラーがそのエラーを処理するとEmacsが判断すると、Emacsは制御をそのハンドラーにreturnします。これを行うために、Emacsはそのとき脱出しつつあるバインディング構成により作成されたすべての変数のバインドを解き、そのとき脱出しつつあるすべての@code{unwind-protect}フォームを実行します。制御がそのハンドラーに達すると、そのハンドラーのbodyが通常どおり実行されます。"

#. type: Plain text
#: original_texis/control.texi:1316
msgid "After execution of the handler body, execution returns from the @code{condition-case} form.  Because the protected form is exited completely before execution of the handler, the handler cannot resume execution at the point of the error, nor can it examine variable bindings that were made within the protected form.  All it can do is clean up and proceed."
msgstr "そのハンドラーのbodyを実行した後、@code{condition-case}フォームから実行がreturnされます。保護されたフォームは、そのハンドラーの実行の前に完全にexitしているので、そのハンドラーはそのエラーの位置から実行を再開することはできず、その保護されたフォーム内で作られた変数のバインディングを調べることもできません。ハンドラーが行なえることは、クリーンアップと、処理を進行させることだけです。"

#. type: Plain text
#: original_texis/control.texi:1323
msgid "Error signaling and handling have some resemblance to @code{throw} and @code{catch} (@pxref{Catch and Throw}), but they are entirely separate facilities.  An error cannot be caught by a @code{catch}, and a @code{throw} cannot be handled by an error handler (though using @code{throw} when there is no suitable @code{catch} signals an error that can be handled)."
msgstr "エラーのシグナルとハンドルには@code{throw}と@code{catch} (@ref{Catch and Throw}を参照)に類似する点がいくつかありますが、これらは完全に別の機能です。エラーは@code{catch}でキャッチできず、@code{throw}をエラーハンドラーで処理することはできません(しかし対応する@code{catch}が存在しないときに@code{throw}を使用することによりシグナルされるエラーは処理できる)。"

#. type: defspec
#: original_texis/control.texi:1324
#, no-wrap
msgid "condition-case var protected-form handlers@dots{}"
msgstr "condition-case var protected-form handlers@dots{}"

#. type: defspec
#: original_texis/control.texi:1331
msgid "This special form establishes the error handlers @var{handlers} around the execution of @var{protected-form}.  If @var{protected-form} executes without error, the value it returns becomes the value of the @code{condition-case} form; in this case, the @code{condition-case} has no effect.  The @code{condition-case} form makes a difference when an error occurs during @var{protected-form}."
msgstr "このスペシャルフォームは@var{protected-form}の実行を囲い込むエラーハンドラー@var{handlers}を確立する。エラーなしで@var{protected-form}が実行されると、リターンされる値は@code{condition-case}フォームの値になる。この場合、@code{condition-case}は効果をもたない。@var{protected-form}の間にエラーが発生すると、@code{condition-case}フォームは違いを生じる。"

#. type: defspec
#: original_texis/control.texi:1338
msgid "Each of the @var{handlers} is a list of the form @code{(@var{conditions} @var{body}@dots{})}.  Here @var{conditions} is an error condition name to be handled, or a list of condition names (which can include @code{debug} to allow the debugger to run before the handler); @var{body} is one or more Lisp expressions to be executed when this handler handles an error.  Here are examples of handlers:"
msgstr "@var{handlers}はそれぞれ、@code{(@var{conditions} @var{body}@dots{})}というフォームのリストである。ここで@var{conditions}はハンドルされるエラーコンディション名、またはそのハンドラーの前にデバッガーを実行するためのコンディション名(@code{debug}を含む)。@var{body}はこのハンドラーがエラーを処理するときに実行される1つ以上のLisp式。"

#. type: group
#: original_texis/control.texi:1342
#, no-wrap
msgid ""
"(error nil)\n"
"\n"
msgstr ""
"(error nil)\n"
"\n"

#. type: group
#: original_texis/control.texi:1344
#, no-wrap
msgid ""
"(arith-error (message \"Division by zero\"))\n"
"\n"
msgstr ""
"(arith-error (message \"Division by zero\"))\n"
"\n"

#. type: group
#: original_texis/control.texi:1348
#, no-wrap
msgid ""
"((arith-error file-error)\n"
" (message\n"
"  \"Either division by zero or failure to open a file\"))\n"
msgstr ""
"((arith-error file-error)\n"
" (message\n"
"  \"Either division by zero or failure to open a file\"))\n"

#. type: defspec
#: original_texis/control.texi:1358
msgid "Each error that occurs has an @dfn{error symbol} that describes what kind of error it is, and which describes also a list of condition names (@pxref{Error Symbols}).  Emacs searches all the active @code{condition-case} forms for a handler that specifies one or more of these condition names; the innermost matching @code{condition-case} handles the error.  Within this @code{condition-case}, the first applicable handler handles the error."
msgstr "発生するエラーはそれぞれ、それが何の種類のエラーかを記述する@dfn{エラーシンボル(error symbol)}をもち、これはコンディション名のリストも記述する(@ref{Error Symbols}を参照)。Emacsは1つ以上のコンディション名を指定するハンドラーにたいして、すべてのアクティブな@code{condition-case}フォームを検索する。@code{condition-case}の最内のマッチがそのエラーを処理する。@code{condition-case}内では、最初に適合したハンドラーがそのエラーを処理する。"

#. type: defspec
#: original_texis/control.texi:1362
msgid "After executing the body of the handler, the @code{condition-case} returns normally, using the value of the last form in the handler body as the overall value."
msgstr "ハンドラーのbodyを実行した後、@code{condition-case}は通常どおりリターンして、ハンドラーのbodyの最後の値をハンドラー全体の値として使用する。"

#. type: cindex
#: original_texis/control.texi:1363
#, no-wrap
msgid "error description"
msgstr "error description"

#. type: defspec
#: original_texis/control.texi:1373
msgid "The argument @var{var} is a variable.  @code{condition-case} does not bind this variable when executing the @var{protected-form}, only when it handles an error.  At that time, it binds @var{var} locally to an @dfn{error description}, which is a list giving the particulars of the error.  The error description has the form @code{(@var{error-symbol} . @var{data})}.  The handler can refer to this list to decide what to do.  For example, if the error is for failure opening a file, the file name is the second element of @var{data}---the third element of the error description."
msgstr "引数@var{var}は変数である。@var{protected-form}を実行するとき、@code{condition-case}はこの変数をバインドせず、エラーを処理するときだけバインドする。その場合には、@var{var}を@dfn{エラー記述(error description)}にバインドする。これはエラーの詳細を与えるリストである。このエラー記述は@code{(@var{error-symbol} . @var{data})}というフォームをもつ。ハンドラーは何を行なうか決定するために、このリストを参照することができる。たとえばファイルオープンの失敗にたいするエラーなら、ファイル名が@var{data}(エラー記述の3番目の要素)の2番目の要素になる。"

#. type: defspec
#: original_texis/control.texi:1376
msgid "If @var{var} is @code{nil}, that means no variable is bound.  Then the error symbol and associated data are not available to the handler."
msgstr "@var{var}が@code{nil}なら、それはバインドされた変数がないことを意味する。この場合、エラーシンボルおよび関連するデータは、そのハンドラーでは利用できない。"

#. type: cindex
#: original_texis/control.texi:1377
#, no-wrap
msgid "rethrow a signal"
msgstr "rethrow a signal"

#. type: defspec
#: original_texis/control.texi:1381
msgid "Sometimes it is necessary to re-throw a signal caught by @code{condition-case}, for some outer-level handler to catch.  Here's how to do that:"
msgstr "より外側のレベルのハンドラーにcatchさせるために、@code{condition-case}によりcatchされたシグナルを再度throwする必要がある場合もある。以下はこれを行なう方法である:"

#. type: example
#: original_texis/control.texi:1384
#, no-wrap
msgid "  (signal (car err) (cdr err))\n"
msgstr "  (signal (car err) (cdr err))\n"

#. type: defspec
#: original_texis/control.texi:1390
msgid "where @code{err} is the error description variable, the first argument to @code{condition-case} whose error condition you want to re-throw.  @xref{Definition of signal}."
msgstr "ここで@code{err}はエラー記述変数(error description variable)で、@code{condition-case}の1番目の引数は、再throwしたいエラーコンディション。@ref{Definition of signal}を参照のこと。"

#. type: defun
#: original_texis/control.texi:1392
#, no-wrap
msgid "error-message-string error-descriptor"
msgstr "error-message-string error-descriptor"

#. type: defun
#: original_texis/control.texi:1396
msgid "This function returns the error message string for a given error descriptor.  It is useful if you want to handle an error by printing the usual error message for that error.  @xref{Definition of signal}."
msgstr "この関数は与えられたエラー記述子(error descriptor)にたいするエラーメッセージ文字列をリターンする。これはそのエラーにたいする通常のエラーメッセージをプリントすることにより、エラーを処理したい場合に有用。@ref{Definition of signal}を参照のこと。"

#. type: cindex
#: original_texis/control.texi:1398
#, no-wrap
msgid "@code{arith-error} example"
msgstr "@code{arith-error} example"

#. type: Plain text
#: original_texis/control.texi:1402
msgid "Here is an example of using @code{condition-case} to handle the error that results from dividing by zero.  The handler displays the error message (but without a beep), then returns a very large number."
msgstr "以下は0除算の結果によるエラーを処理するために、@code{condition-case}を使用する例です。このハンドラーは、(beepなしで)エラーメッセージを表示して、非常に大きい数をリターンします。"

#. type: group
#: original_texis/control.texi:1409
#, no-wrap
msgid ""
"(defun safe-divide (dividend divisor)\n"
"  (condition-case err\n"
"      ;; @r{Protected form.}\n"
"      (/ dividend divisor)\n"
msgstr ""
"(defun safe-divide (dividend divisor)\n"
"  (condition-case err\n"
"      ;; @r{保護されたフォーム}\n"
"      (/ dividend divisor)\n"

#. type: group
#: original_texis/control.texi:1417
#, no-wrap
msgid ""
"    ;; @r{The handler.}\n"
"    (arith-error                        ; @r{Condition.}\n"
"     ;; @r{Display the usual message for this error.}\n"
"     (message \"%s\" (error-message-string err))\n"
"     1000000)))\n"
"@result{} safe-divide\n"
msgstr ""
"    ;; @r{ハンドラー}\n"
"    (arith-error                        ; @r{コンディション}\n"
"     ;; @r{このエラーにたいする、通常のメッセージを表示する}\n"
"     (message \"%s\" (error-message-string err))\n"
"     1000000)))\n"
"@result{} safe-divide\n"

#. type: group
#: original_texis/control.texi:1423
#, no-wrap
msgid ""
"(safe-divide 5 0)\n"
"     @print{} Arithmetic error: (arith-error)\n"
"@result{} 1000000\n"
msgstr ""
"(safe-divide 5 0)\n"
"     @print{} Arithmetic error: (arith-error)\n"
"@result{} 1000000\n"

#. type: Plain text
#: original_texis/control.texi:1430
msgid "The handler specifies condition name @code{arith-error} so that it will handle only division-by-zero errors.  Other kinds of errors will not be handled (by this @code{condition-case}).  Thus:"
msgstr "このハンドラーはコンディション名@code{arith-error}を指定するので、division-by-zero(0除算)エラーだけを処理します。他の種類のエラーは(この@code{condition-case}によっては)、処理されません。したがって:"

#. type: group
#: original_texis/control.texi:1435
#, no-wrap
msgid ""
"(safe-divide nil 3)\n"
"     @error{} Wrong type argument: number-or-marker-p, nil\n"
msgstr ""
"(safe-divide nil 3)\n"
"     @error{} Wrong type argument: number-or-marker-p, nil\n"

#. type: Plain text
#: original_texis/control.texi:1440
msgid "Here is a @code{condition-case} that catches all kinds of errors, including those from @code{error}:"
msgstr "以下は@code{error}によるエラーを含む、すべての種類のエラーをcatchする@code{condition-case}です:"

#. type: group
#: original_texis/control.texi:1445
#, no-wrap
msgid ""
"(setq baz 34)\n"
"     @result{} 34\n"
msgstr ""
"(setq baz 34)\n"
"     @result{} 34\n"

#. type: group
#: original_texis/control.texi:1458
#, no-wrap
msgid ""
"(condition-case err\n"
"    (if (eq baz 35)\n"
"        t\n"
"      ;; @r{This is a call to the function @code{error}.}\n"
"      (error \"Rats!  The variable %s was %s, not 35\" 'baz baz))\n"
"  ;; @r{This is the handler; it is not a form.}\n"
"  (error (princ (format \"The error was: %s\" err))\n"
"         2))\n"
"@print{} The error was: (error \"Rats!  The variable baz was 34, not 35\")\n"
"@result{} 2\n"
msgstr ""
"(condition-case err\n"
"    (if (eq baz 35)\n"
"        t\n"
"      ;; @r{関数@code{error}の呼び出し}\n"
"      (error \"Rats!  The variable %s was %s, not 35\" 'baz baz))\n"
"  ;; @r{フォームではないハンドラー}\n"
"  (error (princ (format \"The error was: %s\" err))\n"
"         2))\n"
"@print{} The error was: (error \"Rats!  The variable baz was 34, not 35\")\n"
"@result{} 2\n"

#. type: defmac
#: original_texis/control.texi:1461
#, no-wrap
msgid "ignore-errors body@dots{}"
msgstr "ignore-errors body@dots{}"

#. type: defmac
#: original_texis/control.texi:1466
msgid "This construct executes @var{body}, ignoring any errors that occur during its execution.  If the execution is without error, @code{ignore-errors} returns the value of the last form in @var{body}; otherwise, it returns @code{nil}."
msgstr "この構文は、それの実行中に発生する任意のエラーを無視して@var{body}を実行する。その実行中にエラーがなければ、@code{ignore-errors}は@var{body}内の最後のフォームの値を、それ以外は@code{nil}をリターンする。"

#. type: defmac
#: original_texis/control.texi:1469
msgid "Here's the example at the beginning of this subsection rewritten using @code{ignore-errors}:"
msgstr "以下はこのセクションの最初の例を@code{ignore-errors}を使用して記述する例である:"

#. type: group
#: original_texis/control.texi:1474
#, no-wrap
msgid ""
"  (ignore-errors\n"
"   (delete-file filename))\n"
msgstr ""
"  (ignore-errors\n"
"   (delete-file filename))\n"

#. type: defmac
#: original_texis/control.texi:1478
#, no-wrap
msgid "with-demoted-errors format body@dots{}"
msgstr "with-demoted-errors format body@dots{}"

#. type: defmac
#: original_texis/control.texi:1487
msgid "This macro is like a milder version of @code{ignore-errors}.  Rather than suppressing errors altogether, it converts them into messages.  It uses the string @var{format} to format the message.  @var{format} should contain a single @samp{%}-sequence; e.g., @code{\"Error: %S\"}.  Use @code{with-demoted-errors} around code that is not expected to signal errors, but should be robust if one does occur.  Note that this macro uses @code{condition-case-unless-debug} rather than @code{condition-case}."
msgstr "このマクロはいわば@code{ignore-errors}の穏やかなバージョンである。これはエラーを完全に抑止するのではなく、エラーをメッセージに変換する。これはメッセージのフォーマットに、文字列@var{format}を使用する。@var{format}は@code{\"Error: %S\"}のように、単一の@samp{%}シーケンスを含むこと。エラーをシグナルするとは予測されないが、もし発生した場合は堅牢であるべきようなコードの周囲に@code{with-demoted-errors}を使用する。このマクロは@code{condition-case}ではなく、@code{condition-case-unless-debug}を使用することに注意。"

#. type: subsubsection
#: original_texis/control.texi:1490
#, no-wrap
msgid "Error Symbols and Condition Names"
msgstr "Error Symbols and Condition Names"

#. type: cindex
#: original_texis/control.texi:1491
#, no-wrap
msgid "error symbol"
msgstr "error symbol"

#. type: cindex
#: original_texis/control.texi:1492
#, no-wrap
msgid "error name"
msgstr "error name"

#. type: cindex
#: original_texis/control.texi:1493
#, no-wrap
msgid "condition name"
msgstr "condition name"

#. type: cindex
#: original_texis/control.texi:1494
#, no-wrap
msgid "user-defined error"
msgstr "user-defined error"

#. type: kindex
#: original_texis/control.texi:1495
#, no-wrap
msgid "error-conditions"
msgstr "error-conditions"

#. type: kindex
#: original_texis/control.texi:1496
#, no-wrap
msgid "define-error"
msgstr "define-error"

#. type: Plain text
#: original_texis/control.texi:1502
msgid "When you signal an error, you specify an @dfn{error symbol} to specify the kind of error you have in mind.  Each error has one and only one error symbol to categorize it.  This is the finest classification of errors defined by the Emacs Lisp language."
msgstr "エラーをシグナルするとき、想定するエラーの種類を指定するために@dfn{エラーシンボル(error symbol)}を指定します。エラーはそれぞれ、それをカテゴリー分けするために単一のエラーシンボルをもちます。これはEmacs Lisp言語で定義されるエラーを分類する、もっともよい方法です。"

#. type: Plain text
#: original_texis/control.texi:1512
msgid "These narrow classifications are grouped into a hierarchy of wider classes called @dfn{error conditions}, identified by @dfn{condition names}.  The narrowest such classes belong to the error symbols themselves: each error symbol is also a condition name.  There are also condition names for more extensive classes, up to the condition name @code{error} which takes in all kinds of errors (but not @code{quit}).  Thus, each error has one or more condition names: @code{error}, the error symbol if that is distinct from @code{error}, and perhaps some intermediate classifications."
msgstr "これらの狭義の分類は@dfn{エラー条件(error conditions)}と呼ばれる、より広義のクラス階層にグループ化され、それらは@dfn{コンディション名(condition names)}により識別されます。そのようなもっとも狭義なクラスは、エラーシンボル自体に属します。つまり各エラーシンボルは、コンディション名でもあるのです。すべての種類のエラー(@code{quit}を除く)を引き受けるコンディション名@code{error}に至る、より広義のクラスにたいするコンディション名も存在します。したがって各エラーは1つ以上のコンディション名をもちます。つまり@code{error}、@code{error}とは区別されるエラーシンボル、もしかしたらその中間に分類されるものかもしれません。"

#. type: defun
#: original_texis/control.texi:1513
#, no-wrap
msgid "define-error name message &optional parent"
msgstr "define-error name message &optional parent"

#. type: defun
#: original_texis/control.texi:1520
msgid "In order for a symbol to be an error symbol, it must be defined with @code{define-error} which takes a parent condition (defaults to @code{error}).  This parent defines the conditions that this kind of error belongs to.  The transitive set of parents always includes the error symbol itself, and the symbol @code{error}.  Because quitting is not considered an error, the set of parents of @code{quit} is just @code{(quit)}."
msgstr "シンボルをエラーシンボルとするために、シンボルは親コンディションを受け取る@code{define-error}で定義されなければならない。この親はその種のエラーが属するコンディションを定義する。親の推移的な集合は、常にそのエラーシンボルとシンボル@code{error}を含む。quitはエラーと判断されないので、@code{quit}の親の集合は単なる@code{(quit)}である。"

#. type: cindex
#: original_texis/control.texi:1522
#, no-wrap
msgid "peculiar error"
msgstr "peculiar error"

#. type: Plain text
#: original_texis/control.texi:1527
msgid "In addition to its parents, the error symbol has a @var{message} which is a string to be printed when that error is signaled but not handled.  If that message is not valid, the error message @samp{peculiar error} is used.  @xref{Definition of signal}."
msgstr "親のコンディションに加えてエラーシンボルは@var{メッセージ(message)}をもち、これは処理されないエラーがシグナルされたときプリントされる文字列です。そのメッセージが有効でなければ、エラーメッセージ@samp{peculiar error}が使用されます。@ref{Definition of signal}を参照してください。"

#. type: Plain text
#: original_texis/control.texi:1531
msgid "Internally, the set of parents is stored in the @code{error-conditions} property of the error symbol and the message is stored in the @code{error-message} property of the error symbol."
msgstr "内部的には親の集合はエラーシンボルの@code{error-conditions}プロパティーに格納され、メッセージはエラーシンボルの@code{error-message}プロパティーに格納されます。"

#. type: Plain text
#: original_texis/control.texi:1533
msgid "Here is how we define a new error symbol, @code{new-error}:"
msgstr "以下は新しいエラーシンボル@code{new-error}を定義する例です:"

#. type: group
#: original_texis/control.texi:1537
#, no-wrap
msgid "(define-error 'new-error \"A new error\" 'my-own-errors)\n"
msgstr "(define-error 'new-error \"A new error\" 'my-own-errors)\n"

#. type: Plain text
#: original_texis/control.texi:1545
msgid "This error has several condition names: @code{new-error}, the narrowest classification; @code{my-own-errors}, which we imagine is a wider classification; and all the conditions of @code{my-own-errors} which should include @code{error}, which is the widest of all."
msgstr "このエラーは複数のコンディション名 --- もっとも狭義の分類@code{new-error}、より広義の分類を想定する@code{my-own-errors}、および@code{my-own-errors}のコンディションすべてを含む@code{error}であり、これはすべての中でもっとも広義なものです。"

#. type: Plain text
#: original_texis/control.texi:1548
msgid "The error string should start with a capital letter but it should not end with a period.  This is for consistency with the rest of Emacs."
msgstr "エラー文字列は大文字で開始されるべきですが、ピリオドで終了すべきではありません。これはEmacsの他の部分との整合性のためです。"

#. type: Plain text
#: original_texis/control.texi:1552
msgid "Naturally, Emacs will never signal @code{new-error} on its own; only an explicit call to @code{signal} (@pxref{Definition of signal}) in your code can do this:"
msgstr "もちろんEmacs自身が@code{new-error}をシグナルすることはありません。あなたのコード内で明示的に@code{signal} (@ref{Definition of signal}を参照)を呼び出すことにより、これを行なうことができます。"

#. type: group
#: original_texis/control.texi:1557
#, no-wrap
msgid ""
"(signal 'new-error '(x y))\n"
"     @error{} A new error: x, y\n"
msgstr ""
"(signal 'new-error '(x y))\n"
"     @error{} A new error: x, y\n"

#. type: Plain text
#: original_texis/control.texi:1563
msgid "This error can be handled through any of its condition names.  This example handles @code{new-error} and any other errors in the class @code{my-own-errors}:"
msgstr "このエラーは、エラーの任意のコンディション名により処理することができます。以下の例は@code{new-error}とクラス@code{my-own-errors}内の他の任意のエラーを処理します:"

#. type: group
#: original_texis/control.texi:1569
#, no-wrap
msgid ""
"(condition-case foo\n"
"    (bar nil t)\n"
"  (my-own-errors nil))\n"
msgstr ""
"(condition-case foo\n"
"    (bar nil t)\n"
"  (my-own-errors nil))\n"

#. type: Plain text
#: original_texis/control.texi:1577
msgid "The significant way that errors are classified is by their condition names---the names used to match errors with handlers.  An error symbol serves only as a convenient way to specify the intended error message and list of condition names.  It would be cumbersome to give @code{signal} a list of condition names rather than one error symbol."
msgstr "エラーが分類される有効な方法はコンディション名による方法で、その名前はハンドラーのエラーのマッチに使用されます。エラーシンボルは意図されたエラーメッセージと、コンディション名のリストを指定する便利な方法であるという役割をもつだけです。1つのエラーシンボルではなく、コンディション名のリストを@code{signal}に与えるのは面倒でしょう。"

#. type: Plain text
#: original_texis/control.texi:1583
msgid "By contrast, using only error symbols without condition names would seriously decrease the power of @code{condition-case}.  Condition names make it possible to categorize errors at various levels of generality when you write an error handler.  Using error symbols alone would eliminate all but the narrowest level of classification."
msgstr "対照的にコンディション名を伴わずにエラーシンボルだけを使用すると、それは@code{condition-case}の効果を著しく減少させるでしょう。コンディション名はエラーハンドラーを記述するとき、一般性のさまざまなレベルにおいて、エラーをカテゴリー分けすることを可能にします。エラーシンボルを単独で使用することは、もっとも狭義なレベルの分類を除くすべてを捨ててしまうことです。"

#. type: Plain text
#: original_texis/control.texi:1586
msgid "@xref{Standard Errors}, for a list of the main error symbols and their conditions."
msgstr "主要なエラーシンボルとそれらのコンディションについては、@ref{Standard Errors}を参照してください。"

#. type: subsection
#: original_texis/control.texi:1588
#, no-wrap
msgid "Cleaning Up from Nonlocal Exits"
msgstr "Cleaning Up from Nonlocal Exits"

#. type: cindex
#: original_texis/control.texi:1589
#, no-wrap
msgid "nonlocal exits, cleaning up"
msgstr "nonlocal exits, cleaning up"

#. type: Plain text
#: original_texis/control.texi:1597
msgid "The @code{unwind-protect} construct is essential whenever you temporarily put a data structure in an inconsistent state; it permits you to make the data consistent again in the event of an error or throw.  (Another more specific cleanup construct that is used only for changes in buffer contents is the atomic change group; @ref{Atomic Changes}.)"
msgstr "@code{unwind-protect}構文は、データ構造を一時的に不整合な状態に置くときに重要です。これはエラーやthrouのイベントにより、再びデータを整合された状態にすることができます(バッファー内容の変更だけに使用される他のクリーンアップ構成はアトミックな変更グループである。@ref{Atomic Changes}を参照)。"

#. type: defspec
#: original_texis/control.texi:1598
#, no-wrap
msgid "unwind-protect body-form cleanup-forms@dots{}"
msgstr "unwind-protect body-form cleanup-forms@dots{}"

#. type: cindex
#: original_texis/control.texi:1599
#, no-wrap
msgid "cleanup forms"
msgstr "cleanup forms"

#. type: cindex
#: original_texis/control.texi:1600
#, no-wrap
msgid "protected forms"
msgstr "protected forms"

#. type: cindex
#: original_texis/control.texi:1601
#, no-wrap
msgid "error cleanup"
msgstr "error cleanup"

#. type: cindex
#: original_texis/control.texi:1602
#, no-wrap
msgid "unwinding"
msgstr "unwinding"

#. type: defspec
#: original_texis/control.texi:1609
msgid "@code{unwind-protect} executes @var{body-form} with a guarantee that the @var{cleanup-forms} will be evaluated if control leaves @var{body-form}, no matter how that happens.  @var{body-form} may complete normally, or execute a @code{throw} out of the @code{unwind-protect}, or cause an error; in all cases, the @var{cleanup-forms} will be evaluated."
msgstr "@code{unwind-protect}は制御が@var{body-form}を離れる場合に、@var{cleanup-forms}が評価されるという保証の下において、何が起こったかに関わらず@var{body-form}を実行する。@var{body-form}は通常どおり完了するかもしれず、@code{unwind-protect}の外側で@code{throw}の実行やエラーが発生するかもしれないが、@var{cleanup-forms}は評価される。"

#. type: defspec
#: original_texis/control.texi:1614
msgid "If @var{body-form} finishes normally, @code{unwind-protect} returns the value of @var{body-form}, after it evaluates the @var{cleanup-forms}.  If @var{body-form} does not finish, @code{unwind-protect} does not return any value in the normal sense."
msgstr "@var{body-form}が正常に終了したら、@code{unwind-protect}は@var{cleanup-forms}を評価した後に、@var{body-form}の値をリターンする。@var{body-form}が終了しなかったら、@code{unwind-protect}は通常の意味におけるような値はリターンしない。"

#. type: defspec
#: original_texis/control.texi:1621
msgid "Only @var{body-form} is protected by the @code{unwind-protect}.  If any of the @var{cleanup-forms} themselves exits nonlocally (via a @code{throw} or an error), @code{unwind-protect} is @emph{not} guaranteed to evaluate the rest of them.  If the failure of one of the @var{cleanup-forms} has the potential to cause trouble, then protect it with another @code{unwind-protect} around that form."
msgstr "@code{unwind-protect}で保護されるのは@var{body-form}だけである。@var{cleanup-forms}自体の任意のフォームが、(@code{throw}またはエラーにより)非ローカルにexitすると、@code{unwind-protect}は残りのフォームが評価されることを@emph{保証しない}。@var{cleanup-forms}の中の1つが失敗することが問題となるようなら、そのフォームの周囲に他の@code{unwind-protect}を配置して保護すること。"

#. type: defspec
#: original_texis/control.texi:1626
msgid "The number of currently active @code{unwind-protect} forms counts, together with the number of local variable bindings, against the limit @code{max-specpdl-size} (@pxref{Definition of max-specpdl-size,, Local Variables})."
msgstr "現在アクティブな@code{unwind-protect}フォーム数とローカルの変数バインディング数の和は、@code{max-specpdl-size} (@ref{Definition of max-specpdl-size,, Local Variables}を参照)により制限される。"

#. type: Plain text
#: original_texis/control.texi:1630
msgid "For example, here we make an invisible buffer for temporary use, and make sure to kill it before finishing:"
msgstr "たとえば以下は一時的な使用のために不可視のバッファーを作成して、終了する前に確実にそのバッファーをkillする例です:"

#. type: group
#: original_texis/control.texi:1638
#, no-wrap
msgid ""
"(let ((buffer (get-buffer-create \" *temp*\")))\n"
"  (with-current-buffer buffer\n"
"    (unwind-protect\n"
"        @var{body-form}\n"
"      (kill-buffer buffer))))\n"
msgstr ""
"(let ((buffer (get-buffer-create \" *temp*\")))\n"
"  (with-current-buffer buffer\n"
"    (unwind-protect\n"
"        @var{body-form}\n"
"      (kill-buffer buffer))))\n"

#. type: Plain text
#: original_texis/control.texi:1649
msgid "You might think that we could just as well write @code{(kill-buffer (current-buffer))} and dispense with the variable @code{buffer}.  However, the way shown above is safer, if @var{body-form} happens to get an error after switching to a different buffer! (Alternatively, you could write a @code{save-current-buffer} around @var{body-form}, to ensure that the temporary buffer becomes current again in time to kill it.)"
msgstr "@code{(kill-buffer (current-buffer))}のように記述して、変数@code{buffer}を使用せずに同様のことを行えると思うかもしれません。しかし上の例は、別のバッファーにスイッチしたときに@var{body-form}でエラーが発生した場合、より安全なのです(一時的なバッファーをkillするとき、そのバッファーがカレントとなることを確実にするために、かわりに@var{body-form}の周囲に@code{save-current-buffer}を記述することもできる)。"

#. type: Plain text
#: original_texis/control.texi:1654
msgid "Emacs includes a standard macro called @code{with-temp-buffer} which expands into more or less the code shown above (@pxref{Definition of with-temp-buffer,, Current Buffer}).  Several of the macros defined in this manual use @code{unwind-protect} in this way."
msgstr "Emacsには上のコードとおおよそ等しいコードに展開される、@code{with-temp-buffer}という標準マクロが含まれます(@ref{Definition of with-temp-buffer,, Current Buffer}を参照)。このマニュアル中で定義されるいくつかのマクロは、この方法で@code{unwind-protect}を使用します。"

#. type: findex
#: original_texis/control.texi:1655
#, no-wrap
msgid "ftp-login"
msgstr "ftp-login"

#. type: Plain text
#: original_texis/control.texi:1663
msgid "Here is an actual example derived from an FTP package.  It creates a process (@pxref{Processes}) to try to establish a connection to a remote machine.  As the function @code{ftp-login} is highly susceptible to numerous problems that the writer of the function cannot anticipate, it is protected with a form that guarantees deletion of the process in the event of failure.  Otherwise, Emacs might fill up with useless subprocesses."
msgstr "以下はFTPパッケージ由来の実例です。これはリモートマシンへの接続の確立を試みるために、プロセス(@ref{Processes}を参照)を作成しています。関数@code{ftp-login}は関数のライター(writer)が予想できないことによる多くの問題から非常に影響を受けるので、失敗イベントでプロセスの削除を保証するフォームで保護されています。そうしないとEmacsは無用なサブプロセスで一杯になってしまうでしょう。"

#. type: group
#: original_texis/control.texi:1674
#, no-wrap
msgid ""
"(let ((win nil))\n"
"  (unwind-protect\n"
"      (progn\n"
"        (setq process (ftp-setup-buffer host file))\n"
"        (if (setq win (ftp-login process host user password))\n"
"            (message \"Logged in\")\n"
"          (error \"Ftp login failed\")))\n"
"    (or win (and process (delete-process process)))))\n"
msgstr ""
"(let ((win nil))\n"
"  (unwind-protect\n"
"      (progn\n"
"        (setq process (ftp-setup-buffer host file))\n"
"        (if (setq win (ftp-login process host user password))\n"
"            (message \"Logged in\")\n"
"          (error \"Ftp login failed\")))\n"
"    (or win (and process (delete-process process)))))\n"

#. type: Plain text
#: original_texis/control.texi:1681
msgid "This example has a small bug: if the user types @kbd{C-g} to quit, and the quit happens immediately after the function @code{ftp-setup-buffer} returns but before the variable @code{process} is set, the process will not be killed.  There is no easy way to fix this bug, but at least it is very unlikely."
msgstr "この例には小さなバグがあります。ユーザーがquitするために@kbd{C-g}とタイプすると、関数@code{ftp-setup-buffer}のリターン後に即座にquitが発生しますが、それは変数@code{process}がセットされる前なので、そのプロセスはkillされないでしょう。このバグを簡単に訂正する方法はありませんが、少なくともこれは非常に稀なことだと言えます。"
