# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Emacs 26.1\n"
"POT-Creation-Date: 2020-06-14 22:38+0900\n"
"PO-Revision-Date: 2020-06-21 00:23+0900\n"
"Last-Translator: Takeshi Ayanokoji <takeshi.ayanokoji@gmail.com>\n"
"Language-Team: Japanese <takeshi.ayanokoji@gmail.com>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: original_texis/control.texi:6 original_texis/control.texi:7
#, no-wrap
msgid "Control Structures"
msgstr "Control Structures"

#. type: cindex
#: original_texis/control.texi:8
#, no-wrap
msgid "special forms for control structures"
msgstr "special forms for control structures"

#. type: cindex
#: original_texis/control.texi:9
#, no-wrap
msgid "forms for control structures"
msgstr "forms for control structures"

#. type: cindex
#: original_texis/control.texi:10
#, no-wrap
msgid "control structures"
msgstr "control structures"

#. type: Plain text
#: original_texis/control.texi:17
msgid "A Lisp program consists of a set of @dfn{expressions}, or @dfn{forms} (@pxref{Forms}).  We control the order of execution of these forms by enclosing them in @dfn{control structures}.  Control structures are special forms which control when, whether, or how many times to execute the forms they contain."
msgstr "Lispプログラムは一連の@dfn{式}、あるいは@dfn{フォーム} (@ref{Forms}を参照)により形成されます。これらのフォームの実行順は@dfn{制御構造(control structures)}で囲むことによって制御します。制御構造とはその制御構造が含むフォームをいつ、どのような条件で、何回実行するかを制御するスペシャルフォームです。"

#. type: cindex
#: original_texis/control.texi:18
#, no-wrap
msgid "textual order"
msgstr "textual order"

#. type: Plain text
#: original_texis/control.texi:27
msgid "The simplest order of execution is sequential execution: first form @var{a}, then form @var{b}, and so on.  This is what happens when you write several forms in succession in the body of a function, or at top level in a file of Lisp code---the forms are executed in the order written.  We call this @dfn{textual order}.  For example, if a function body consists of two forms @var{a} and @var{b}, evaluation of the function evaluates first @var{a} and then @var{b}.  The result of evaluating @var{b} becomes the value of the function."
msgstr "もっとも単純な実行順は1番目は@var{a}、2番目は@var{b}、...というシーケンシャル実行(sequential execution: 順番に実行)です。これは関数のbody内の連続する複数のフォームや、Lispコードのファイル内のトップレベルを記述したときに発生します --- つまりフォームは記述した順に実行されます。わたしたちはこれを@dfn{テキスト順(textual order)}と呼びます。たとえば関数のbodyが2つのフォーム@var{a}と@var{b}から構成される場合、関数の評価は最初に@var{a}、次に@var{b}を評価します。@var{b}を評価した結果がその関数の値となります。"

#. type: Plain text
#: original_texis/control.texi:30
msgid "Explicit control structures make possible an order of execution other than sequential."
msgstr "明示的に制御構造を使用することにより、非シーケンシャルな順番での実行が可能になります。"

#. type: Plain text
#: original_texis/control.texi:37
msgid "Emacs Lisp provides several kinds of control structure, including other varieties of sequencing, conditionals, iteration, and (controlled)  jumps---all discussed below.  The built-in control structures are special forms since their subforms are not necessarily evaluated or not evaluated sequentially.  You can use macros to define your own control structure constructs (@pxref{Macros})."
msgstr "Emacs Lispは他の様々な順序づけ、条件、繰り返し、(制御された)ジャンプを含む複数の種類の制御構造を提供しており、以下ではそれらのすべてを記述します。ビルトインの制御構造は制御構造のサブフォームが評価される必要がなかったり、順番に評価される必要がないのでスペシャルフォームです。独自の制御構造を構築するためにマクロを使用することができます(@ref{Macros}を参照)。"

#. type: section
#: original_texis/control.texi:46 original_texis/control.texi:48
#: original_texis/control.texi:49
#, no-wrap
msgid "Sequencing"
msgstr "Sequencing"

#. type: menuentry
#: original_texis/control.texi:46
msgid "Evaluation in textual order."
msgstr "テキスト順の評価。"

#. type: section
#: original_texis/control.texi:46 original_texis/control.texi:148
#: original_texis/control.texi:149
#, no-wrap
msgid "Conditionals"
msgstr "Conditionals"

#. type: menuentry
#: original_texis/control.texi:46
msgid "@code{if}, @code{cond}, @code{when}, @code{unless}."
msgstr "@code{if}、@code{cond}、@code{when}、@code{unless}。"

#. type: node
#: original_texis/control.texi:46 original_texis/control.texi:297
#, no-wrap
msgid "Combining Conditions"
msgstr "Combining Conditions"

#. type: menuentry
#: original_texis/control.texi:46
msgid "@code{and}, @code{or}, @code{not}."
msgstr "@code{and}、@code{or}、@code{not}。"

#. type: section
#: original_texis/control.texi:46 original_texis/control.texi:422
#: original_texis/control.texi:423
#, no-wrap
msgid "Pattern-Matching Conditional"
msgstr "Pattern-Matching Conditional"

#. type: menuentry
#: original_texis/control.texi:46
msgid "How to use @code{pcase} and friends."
msgstr "@code{pcase}類の使用方法。"

#. type: section
#: original_texis/control.texi:46 original_texis/control.texi:1275
#: original_texis/control.texi:1276
#, no-wrap
msgid "Iteration"
msgstr "Iteration"

#. type: menuentry
#: original_texis/control.texi:46
msgid "@code{while} loops."
msgstr "@code{while}ループ。"

#. type: section
#: original_texis/control.texi:46 original_texis/control.texi:1366
#: original_texis/control.texi:1367
#, no-wrap
msgid "Generators"
msgstr "Generators"

#. type: menuentry
#: original_texis/control.texi:46
msgid "Generic sequences and coroutines."
msgstr "汎用のシーケンスとコルーチン。"

#. type: section
#: original_texis/control.texi:46 original_texis/control.texi:1484
#: original_texis/control.texi:1485
#, no-wrap
msgid "Nonlocal Exits"
msgstr "Nonlocal Exits"

#. type: menuentry
#: original_texis/control.texi:46
msgid "Jumping out of a sequence."
msgstr "シーケンスの外へのジャンプ。"

#. type: cindex
#: original_texis/control.texi:50
#, no-wrap
msgid "sequencing"
msgstr "sequencing"

#. type: cindex
#: original_texis/control.texi:51
#, no-wrap
msgid "sequential execution"
msgstr "sequential execution"

#. type: cindex
#: original_texis/control.texi:52
#, no-wrap
msgid "forms for sequential execution"
msgstr "forms for sequential execution"

#. type: Plain text
#: original_texis/control.texi:59
msgid "Evaluating forms in the order they appear is the most common way control passes from one form to another.  In some contexts, such as in a function body, this happens automatically.  Elsewhere you must use a control structure construct to do this: @code{progn}, the simplest control construct of Lisp."
msgstr "フォームを出現順に評価するのは、あるフォームから別のフォームに制御を渡すもっとも一般的な制御です。関数のbodyのようなコンテキストにおいては自動的にこれが行なわれます。他の場所ではこれを行なうために制御構造を使用しなければなりません。Lispで一単純な制御構造は@code{progn}です。"

#. type: Plain text
#: original_texis/control.texi:61
msgid "A @code{progn} special form looks like this:"
msgstr "スペシャルフォーム@code{progn}は以下のようなものです:"

#. type: group
#: original_texis/control.texi:65
#, no-wrap
msgid "(progn @var{a} @var{b} @var{c} @dots{})\n"
msgstr "(progn @var{a} @var{b} @var{c} @dots{})\n"

#. type: Plain text
#: original_texis/control.texi:73
msgid "and it says to execute the forms @var{a}, @var{b}, @var{c}, and so on, in that order.  These forms are called the @dfn{body} of the @code{progn} form.  The value of the last form in the body becomes the value of the entire @code{progn}.  @code{(progn)} returns @code{nil}."
msgstr "これは順番に@var{a}、@var{b}、@var{c}、...を実行するよう指定します。これらは@code{progn}フォームの@dfn{body}と呼ばれます。body内の最後のフォームの値が@code{progn}全体の値になります。@code{(progn)}は@code{nil}をリターンします。"

#. type: cindex
#: original_texis/control.texi:74
#, no-wrap
msgid "implicit @code{progn}"
msgstr "implicit @code{progn}"

#. type: Plain text
#: original_texis/control.texi:85
msgid "In the early days of Lisp, @code{progn} was the only way to execute two or more forms in succession and use the value of the last of them.  But programmers found they often needed to use a @code{progn} in the body of a function, where (at that time) only one form was allowed.  So the body of a function was made into an implicit @code{progn}: several forms are allowed just as in the body of an actual @code{progn}.  Many other control structures likewise contain an implicit @code{progn}.  As a result, @code{progn} is not used as much as it was many years ago.  It is needed now most often inside an @code{unwind-protect}, @code{and}, @code{or}, or in the @var{then}-part of an @code{if}."
msgstr "初期のLispでは@code{progn}は、連続で複数のフォームを実行して最後のフォームの値を使用する唯一の方法でした。しかしプログラマーは関数のbodyの、(その時点では)1つのフォームだけが許される場所で@code{progn}を使用する必要が多いことに気づきました。そのため関数のbodyを暗黙の@code{progn}にして、@code{progn}のbodyのように複数のフォームを記述できるようにしました。他の多くの制御構造も暗黙の@code{progn}を同様に含みます。結果として昔ほど@code{progn}は多用されなくなりました。現在では@code{progn}が必要になるのは@code{unwind-protect}、@code{and}、@code{or}、または@code{if}の@var{then}パートの中であることがほとんどです。"

#. type: defspec
#: original_texis/control.texi:86
#, no-wrap
msgid "progn forms@dots{}"
msgstr "progn forms@dots{}"

#. type: defspec
#: original_texis/control.texi:89
msgid "This special form evaluates all of the @var{forms}, in textual order, returning the result of the final form."
msgstr "このスペシャルフォームは@var{forms}のすべてをテキスト順に評価してフォームの結果をリターンする。"

#. type: group
#: original_texis/control.texi:99
#, no-wrap
msgid ""
"(progn (print \"The first form\")\n"
"       (print \"The second form\")\n"
"       (print \"The third form\"))\n"
"     @print{} \"The first form\"\n"
"     @print{} \"The second form\"\n"
"     @print{} \"The third form\"\n"
"@result{} \"The third form\"\n"
msgstr ""
"(progn (print \"The first form\")\n"
"       (print \"The second form\")\n"
"       (print \"The third form\"))\n"
"     @print{} \"The first form\"\n"
"     @print{} \"The second form\"\n"
"     @print{} \"The third form\"\n"
"@result{} \"The third form\"\n"

#. type: Plain text
#: original_texis/control.texi:105
msgid "Two other constructs likewise evaluate a series of forms but return different values:"
msgstr "他の2つの構文は一連のフォームを同様に評価しますが、異なる値をリターンします:"

#. type: defspec
#: original_texis/control.texi:106
#, no-wrap
msgid "prog1 form1 forms@dots{}"
msgstr "prog1 form1 forms@dots{}"

#. type: defspec
#: original_texis/control.texi:109
msgid "This special form evaluates @var{form1} and all of the @var{forms}, in textual order, returning the result of @var{form1}."
msgstr "このスペシャルフォームは@var{form1}と@var{forms}のすべてをテキスト順に評価して@var{form1}の結果をリターンする。"

#. type: group
#: original_texis/control.texi:119
#, no-wrap
msgid ""
"(prog1 (print \"The first form\")\n"
"       (print \"The second form\")\n"
"       (print \"The third form\"))\n"
"     @print{} \"The first form\"\n"
"     @print{} \"The second form\"\n"
"     @print{} \"The third form\"\n"
"@result{} \"The first form\"\n"
msgstr ""
"(prog1 (print \"The first form\")\n"
"       (print \"The second form\")\n"
"       (print \"The third form\"))\n"
"     @print{} \"The first form\"\n"
"     @print{} \"The second form\"\n"
"     @print{} \"The third form\"\n"
"@result{} \"The first form\"\n"

#. type: defspec
#: original_texis/control.texi:124
msgid "Here is a way to remove the first element from a list in the variable @code{x}, then return the value of that former element:"
msgstr "以下の例は変数@code{x}のリストから1番目の要素を削除して、削除した1番目の要素の値をリターンする:"

#. type: example
#: original_texis/control.texi:127
#, no-wrap
msgid "(prog1 (car x) (setq x (cdr x)))\n"
msgstr "(prog1 (car x) (setq x (cdr x)))\n"

#. type: defspec
#: original_texis/control.texi:130
#, no-wrap
msgid "prog2 form1 form2 forms@dots{}"
msgstr "prog2 form1 form2 forms@dots{}"

#. type: defspec
#: original_texis/control.texi:134
msgid "This special form evaluates @var{form1}, @var{form2}, and all of the following @var{forms}, in textual order, returning the result of @var{form2}."
msgstr "このスペシャルフォームは@var{form1}、@var{form2}、その後の@var{forms}のすべてをテキスト順で評価して@var{form2}の結果をリターンする。"

#. type: group
#: original_texis/control.texi:144
#, no-wrap
msgid ""
"(prog2 (print \"The first form\")\n"
"       (print \"The second form\")\n"
"       (print \"The third form\"))\n"
"     @print{} \"The first form\"\n"
"     @print{} \"The second form\"\n"
"     @print{} \"The third form\"\n"
"@result{} \"The second form\"\n"
msgstr ""
"(prog2 (print \"The first form\")\n"
"       (print \"The second form\")\n"
"       (print \"The third form\"))\n"
"     @print{} \"The first form\"\n"
"     @print{} \"The second form\"\n"
"     @print{} \"The third form\"\n"
"@result{} \"The second form\"\n"

#. type: cindex
#: original_texis/control.texi:150
#, no-wrap
msgid "conditional evaluation"
msgstr "conditional evaluation"

#. type: cindex
#: original_texis/control.texi:151
#, no-wrap
msgid "forms, conditional"
msgstr "forms, conditional"

#. type: Plain text
#: original_texis/control.texi:159
msgid "Conditional control structures choose among alternatives.  Emacs Lisp has five conditional forms: @code{if}, which is much the same as in other languages; @code{when} and @code{unless}, which are variants of @code{if}; @code{cond}, which is a generalized case statement; and @code{pcase}, which is a generalization of @code{cond} (@pxref{Pattern-Matching Conditional})."
msgstr "条件による制御構造は候補の中から選択を行ないます。Emacs Lispは5つの条件フォームをもちます。@code{if}は他の言語のものとほとんど同じです。@code{when}と@code{unless}は@code{if}の変種です。@code{cond}は一般化されたcase命令です。@code{cond}を汎用化したものが@code{pcase}です(@ref{Pattern-Matching Conditional}を参照)。"

#. type: defspec
#: original_texis/control.texi:160
#, no-wrap
msgid "if condition then-form else-forms@dots{}"
msgstr "if condition then-form else-forms@dots{}"

#. type: defspec
#: original_texis/control.texi:167
msgid "@code{if} chooses between the @var{then-form} and the @var{else-forms} based on the value of @var{condition}.  If the evaluated @var{condition} is non-@code{nil}, @var{then-form} is evaluated and the result returned.  Otherwise, the @var{else-forms} are evaluated in textual order, and the value of the last one is returned.  (The @var{else} part of @code{if} is an example of an implicit @code{progn}.  @xref{Sequencing}.)"
msgstr "@code{if}は@var{condition}の値にもとづき@var{then-form}と@var{else-forms}を選択する。評価された@var{condition}が非@code{nil}なら@var{then-form}が評価されて結果がリターンされる。それ以外なら@var{else-forms}がテキスト順に評価されて最後のフォームの値がリターンされる(@code{if}の@var{else}パートは暗黙の@code{progn}の例である。@ref{Sequencing}を参照)。"

#. type: defspec
#: original_texis/control.texi:170
msgid "If @var{condition} has the value @code{nil}, and no @var{else-forms} are given, @code{if} returns @code{nil}."
msgstr "@var{condition}の値が@code{nil}で@var{else-forms}が与えられなければ、@code{if}は@code{nil}をリターンする。"

#. type: defspec
#: original_texis/control.texi:174
msgid "@code{if} is a special form because the branch that is not selected is never evaluated---it is ignored.  Thus, in this example, @code{true} is not printed because @code{print} is never called:"
msgstr "選択されなかったブランチは決して評価されない --- 無視される --- ので、@code{if}はスペシャルフォームである。したがって以下の例では@code{print}が呼び出されることはないので@code{true}はプリントされない。"

#. type: group
#: original_texis/control.texi:181
#, no-wrap
msgid ""
"(if nil\n"
"    (print 'true)\n"
"  'very-false)\n"
"@result{} very-false\n"
msgstr ""
"(if nil\n"
"    (print 'true)\n"
"  'very-false)\n"
"@result{} very-false\n"

#. type: defmac
#: original_texis/control.texi:185
#, no-wrap
msgid "when condition then-forms@dots{}"
msgstr "when condition then-forms@dots{}"

#. type: defmac
#: original_texis/control.texi:188
msgid "This is a variant of @code{if} where there are no @var{else-forms}, and possibly several @var{then-forms}.  In particular,"
msgstr "これは@var{else-forms}がなく、複数の@var{then-forms}が可能な@code{if}の変種である。特に、"

#. type: example
#: original_texis/control.texi:191
#, no-wrap
msgid "(when @var{condition} @var{a} @var{b} @var{c})\n"
msgstr "(when @var{condition} @var{a} @var{b} @var{c})\n"

#. type: defmac
#: original_texis/control.texi:195 original_texis/control.texi:210
msgid "is entirely equivalent to"
msgstr "は以下と完全に等価である"

#. type: example
#: original_texis/control.texi:198
#, no-wrap
msgid "(if @var{condition} (progn @var{a} @var{b} @var{c}) nil)\n"
msgstr "(if @var{condition} (progn @var{a} @var{b} @var{c}) nil)\n"

#. type: defmac
#: original_texis/control.texi:201
#, no-wrap
msgid "unless condition forms@dots{}"
msgstr "unless condition forms@dots{}"

#. type: defmac
#: original_texis/control.texi:203
msgid "This is a variant of @code{if} where there is no @var{then-form}:"
msgstr "これは@var{then-form}がない@code{if}の変種です:"

#. type: example
#: original_texis/control.texi:206
#, no-wrap
msgid "(unless @var{condition} @var{a} @var{b} @var{c})\n"
msgstr "(unless @var{condition} @var{a} @var{b} @var{c})\n"

#. type: example
#: original_texis/control.texi:214
#, no-wrap
msgid ""
"(if @var{condition} nil\n"
"   @var{a} @var{b} @var{c})\n"
msgstr ""
"(if @var{condition} nil\n"
"   @var{a} @var{b} @var{c})\n"

#. type: defspec
#: original_texis/control.texi:217
#, no-wrap
msgid "cond clause@dots{}"
msgstr "cond clause@dots{}"

#. type: defspec
#: original_texis/control.texi:222
msgid "@code{cond} chooses among an arbitrary number of alternatives.  Each @var{clause} in the @code{cond} must be a list.  The @sc{car} of this list is the @var{condition}; the remaining elements, if any, the @var{body-forms}.  Thus, a clause looks like this:"
msgstr "@code{cond}は任意個数の選択肢から選択を行なう。@code{cond}内の各@var{clause}はリストでなければならない。このリストの@sc{car}は@var{condition}で、(もしあれば)残りの要素は@var{body-forms}となる。したがってclauseは以下のようになる:"

#. type: example
#: original_texis/control.texi:225
#, no-wrap
msgid "(@var{condition} @var{body-forms}@dots{})\n"
msgstr "(@var{condition} @var{body-forms}@dots{})\n"

#. type: defspec
#: original_texis/control.texi:232
msgid "@code{cond} tries the clauses in textual order, by evaluating the @var{condition} of each clause.  If the value of @var{condition} is non-@code{nil}, the clause succeeds; then @code{cond} evaluates its @var{body-forms}, and returns the value of the last of @var{body-forms}.  Any remaining clauses are ignored."
msgstr "@code{cond}は各clauseの@var{condition}を評価することにより、テキスト順でclauseを試みる。@var{condition}の値が非@code{nil}ならそのclauseは成り立つ。その後に@code{cond}はそのclauseの@var{body-forms}を評価して、@var{body-forms}の最後の値をリターンする。残りのclauseは無視される。"

#. type: defspec
#: original_texis/control.texi:235
msgid "If the value of @var{condition} is @code{nil}, the clause fails, so the @code{cond} moves on to the following clause, trying its @var{condition}."
msgstr "@var{condition}の値が@code{nil}ならそのclauseは失敗して、@code{cond}は次のclauseに移動してそれの@var{condition}を試みる。"

#. type: defspec
#: original_texis/control.texi:237
msgid "A clause may also look like this:"
msgstr "clauseは以下のようにも見えるかもしれない:"

#. type: example
#: original_texis/control.texi:240
#, no-wrap
msgid "(@var{condition})\n"
msgstr "(@var{condition})\n"

#. type: defspec
#: original_texis/control.texi:245
msgid "Then, if @var{condition} is non-@code{nil} when tested, the @code{cond} form returns the value of @var{condition}."
msgstr "@var{condition}がテストされたときに非@code{nil}なら、@code{cond}フォームは@var{condition}の値をリターンする。"

#. type: defspec
#: original_texis/control.texi:248
msgid "If every @var{condition} evaluates to @code{nil}, so that every clause fails, @code{cond} returns @code{nil}."
msgstr "すべての@var{condition}が@code{nil}に評価された場合 --- つまりすべてのclauseが不成立なら、@code{cond}は@code{nil}をリターンする。"

#. type: defspec
#: original_texis/control.texi:252
msgid "The following example has four clauses, which test for the cases where the value of @code{x} is a number, string, buffer and symbol, respectively:"
msgstr "以下の例は@code{x}の値が数字、文字列、バッファー、シンボルなのかをテストする4つのclauseをもつ:"

#. type: group
#: original_texis/control.texi:261
#, no-wrap
msgid ""
"(cond ((numberp x) x)\n"
"      ((stringp x) x)\n"
"      ((bufferp x)\n"
"       (setq temporary-hack x) ; @r{multiple body-forms}\n"
"       (buffer-name x))        ; @r{in one clause}\n"
"      ((symbolp x) (symbol-value x)))\n"
msgstr ""
"(cond ((numberp x) x)\n"
"      ((stringp x) x)\n"
"      ((bufferp x)\n"
"       (setq temporary-hack x) ; @r{1つのclauseに}\n"
"       (buffer-name x))        ; @r{複数bodyフォーム}\n"
"      ((symbolp x) (symbol-value x)))\n"

#. type: defspec
#: original_texis/control.texi:270
msgid "Often we want to execute the last clause whenever none of the previous clauses was successful.  To do this, we use @code{t} as the @var{condition} of the last clause, like this: @code{(t @var{body-forms})}.  The form @code{t} evaluates to @code{t}, which is never @code{nil}, so this clause never fails, provided the @code{cond} gets to it at all.  For example:"
msgstr "前のclauseが不成立のとき最後の条項を実行したいときがよくある。これを行なうには@code{(t @var{body-forms})}のように、@var{condition}の最後のclauseに@code{t}を使用する。フォーム@code{t}は@code{t}に評価され決して@code{nil}にならないので、このclauseが不成立になることはなく最終的に@code{cond}はこのclauseに到達する。たとえば:"

#. type: group
#: original_texis/control.texi:277
#, no-wrap
msgid ""
"(setq a 5)\n"
"(cond ((eq a 'hack) 'foo)\n"
"      (t \"default\"))\n"
"@result{} \"default\"\n"
msgstr ""
"(setq a 5)\n"
"(cond ((eq a 'hack) 'foo)\n"
"      (t \"default\"))\n"
"@result{} \"default\"\n"

#. type: defspec
#: original_texis/control.texi:283
msgid "This @code{cond} expression returns @code{foo} if the value of @code{a} is @code{hack}, and returns the string @code{\"default\"} otherwise."
msgstr "この@code{cond}式は@code{a}の値が@code{hack}なら@code{foo}、それ以外は文字列@code{\"default\"}をリターンする。"

#. type: Plain text
#: original_texis/control.texi:288
msgid "Any conditional construct can be expressed with @code{cond} or with @code{if}.  Therefore, the choice between them is a matter of style.  For example:"
msgstr "すべての条件構文は@code{cond}か@code{if}のいずれかで表すことができます。したがってどちらを選択するかはスタイルの問題になります。たとえば:"

#. type: group
#: original_texis/control.texi:294
#, no-wrap
msgid ""
"(if @var{a} @var{b} @var{c})\n"
"@equiv{}\n"
"(cond (@var{a} @var{b}) (t @var{c}))\n"
msgstr ""
"(if @var{a} @var{b} @var{c})\n"
"@equiv{}\n"
"(cond (@var{a} @var{b}) (t @var{c}))\n"

#. type: section
#: original_texis/control.texi:298
#, no-wrap
msgid "Constructs for Combining Conditions"
msgstr "Constructs for Combining Conditions"

#. type: cindex
#: original_texis/control.texi:299
#, no-wrap
msgid "combining conditions"
msgstr "combining conditions"

#. type: Plain text
#: original_texis/control.texi:305
msgid "This section describes three constructs that are often used together with @code{if} and @code{cond} to express complicated conditions.  The constructs @code{and} and @code{or} can also be used individually as kinds of multiple conditional constructs."
msgstr "このセクションでは複雑な条件を表現するために@code{if}や@code{cond}とともによく使用される3つの構文を説明します。@code{and}と@code{or}の構文は、ある種の複数条件の構文として個別に使用することもできます。"

#. type: defun
#: original_texis/control.texi:306
#, no-wrap
msgid "not condition"
msgstr "not condition"

#. type: defun
#: original_texis/control.texi:311
msgid "This function tests for the falsehood of @var{condition}.  It returns @code{t} if @var{condition} is @code{nil}, and @code{nil} otherwise.  The function @code{not} is identical to @code{null}, and we recommend using the name @code{null} if you are testing for an empty list."
msgstr "この関数は@var{condition}が偽であることをテストする。この関数は@var{condition}が@code{nil}なら@code{t}、それ以外は@code{nil}をリターンする。関数@code{not}は@code{null}と等価であり、空のリストをテストする場合は@code{null}の使用を推奨する。"

#. type: defspec
#: original_texis/control.texi:313
#, no-wrap
msgid "and conditions@dots{}"
msgstr "and conditions@dots{}"

#. type: defspec
#: original_texis/control.texi:317
msgid "The @code{and} special form tests whether all the @var{conditions} are true.  It works by evaluating the @var{conditions} one by one in the order written."
msgstr "スペシャルフォーム@code{and}は、すべての@var{conditions}が真かどうかをテストする。この関数は@var{conditions}を記述順に1つずつ評価することにより機能する。"

#. type: defspec
#: original_texis/control.texi:322
msgid "If any of the @var{conditions} evaluates to @code{nil}, then the result of the @code{and} must be @code{nil} regardless of the remaining @var{conditions}; so @code{and} returns @code{nil} right away, ignoring the remaining @var{conditions}."
msgstr "ある@var{conditions}が@code{nil}に評価されると、残りの@var{conditions}に関係なく、@code{and}は@code{nil}をリターンしなければならない。この場合@code{and}は即座に@code{nil}をリターンして、残りの@var{conditions}は無視される。"

#. type: defspec
#: original_texis/control.texi:328
msgid "If all the @var{conditions} turn out non-@code{nil}, then the value of the last of them becomes the value of the @code{and} form.  Just @code{(and)}, with no @var{conditions}, returns @code{t}, appropriate because all the @var{conditions} turned out non-@code{nil}.  (Think about it; which one did not?)"
msgstr "すべての@var{conditions}が非@code{nil}なら、それらの最後の値が@code{and}フォームの値になる。@var{conditions}がない単独の@code{(and)}は@code{t}をリターンする。なぜならすべての@var{conditions}が非@code{nil}となるので、これは適切である(考えてみてみよ、非@code{nil}でない@var{conditions}はどれか?)。"

#. type: defspec
#: original_texis/control.texi:333
msgid "Here is an example.  The first condition returns the integer 1, which is not @code{nil}.  Similarly, the second condition returns the integer 2, which is not @code{nil}.  The third condition is @code{nil}, so the remaining condition is never evaluated."
msgstr "以下に例を示す。1番目の条件は整数1をリターンし、これは@code{nil}ではまい。同様に2番目の条件は整数2をリターンし、これも@code{nil}ではない。3番目の条件は@code{nil}なので、のこりの条件が評価されることは決してない。"

#. type: group
#: original_texis/control.texi:340
#, no-wrap
msgid ""
"(and (print 1) (print 2) nil (print 3))\n"
"     @print{} 1\n"
"     @print{} 2\n"
"@result{} nil\n"
msgstr ""
"(and (print 1) (print 2) nil (print 3))\n"
"     @print{} 1\n"
"     @print{} 2\n"
"@result{} nil\n"

#. type: defspec
#: original_texis/control.texi:344
msgid "Here is a more realistic example of using @code{and}:"
msgstr "以下は@code{and}を使用した、より現実的な例である:"

#. type: group
#: original_texis/control.texi:349
#, no-wrap
msgid ""
"(if (and (consp foo) (eq (car foo) 'x))\n"
"    (message \"foo is a list starting with x\"))\n"
msgstr ""
"(if (and (consp foo) (eq (car foo) 'x))\n"
"    (message \"foo is a list starting with x\"))\n"

#. type: defspec
#: original_texis/control.texi:355
msgid "Note that @code{(car foo)} is not executed if @code{(consp foo)} returns @code{nil}, thus avoiding an error."
msgstr "@code{(consp foo)}が@code{nil}をリターンすると、@code{(car foo)}は実行されないのでエラーにならないことに注意。"

#. type: defspec
#: original_texis/control.texi:358
msgid "@code{and} expressions can also be written using either @code{if} or @code{cond}.  Here's how:"
msgstr "@code{if}か@code{cond}のいずれかを使用して、@code{and}式を記述することもできる。以下にその方法を示す:"

#. type: group
#: original_texis/control.texi:366
#, no-wrap
msgid ""
"(and @var{arg1} @var{arg2} @var{arg3})\n"
"@equiv{}\n"
"(if @var{arg1} (if @var{arg2} @var{arg3}))\n"
"@equiv{}\n"
"(cond (@var{arg1} (cond (@var{arg2} @var{arg3}))))\n"
msgstr ""
"(and @var{arg1} @var{arg2} @var{arg3})\n"
"@equiv{}\n"
"(if @var{arg1} (if @var{arg2} @var{arg3}))\n"
"@equiv{}\n"
"(cond (@var{arg1} (cond (@var{arg2} @var{arg3}))))\n"

#. type: defspec
#: original_texis/control.texi:370
#, no-wrap
msgid "or conditions@dots{}"
msgstr "or conditions@dots{}"

#. type: defspec
#: original_texis/control.texi:374
msgid "The @code{or} special form tests whether at least one of the @var{conditions} is true.  It works by evaluating all the @var{conditions} one by one in the order written."
msgstr "スペシャルフォーム@code{or}は、少なくとも1つの@var{conditions}が真かどうかをテストする。この関数はすべての@var{conditions}を1つずつ、記述された順に評価することにより機能する。"

#. type: defspec
#: original_texis/control.texi:379
msgid "If any of the @var{conditions} evaluates to a non-@code{nil} value, then the result of the @code{or} must be non-@code{nil}; so @code{or} returns right away, ignoring the remaining @var{conditions}.  The value it returns is the non-@code{nil} value of the condition just evaluated."
msgstr "ある@var{conditions}が非@code{nil}値に評価されたら、@code{or}の結果は非@code{nil}でなければならない。この場合@code{or}は即座にリターンし、残りの@var{conditions}は無視される。この関数がリターンする値は、非@code{nil}値に評価された条件の値そのものである。"

#. type: defspec
#: original_texis/control.texi:385
msgid "If all the @var{conditions} turn out @code{nil}, then the @code{or} expression returns @code{nil}.  Just @code{(or)}, with no @var{conditions}, returns @code{nil}, appropriate because all the @var{conditions} turned out @code{nil}.  (Think about it; which one did not?)"
msgstr "すべての@var{conditions}が@code{nil}なら、@code{or}式は@code{nil}をリターンします。@var{conditions}のない単独の@code{(or)}は@code{nil}をリターンする。なぜならすべての@var{conditions}が@code{nil}になるのでこれは適切である(考えてみよ、@code{nil}でない@var{conditions}はどれか?)。"

#. type: defspec
#: original_texis/control.texi:388
msgid "For example, this expression tests whether @code{x} is either @code{nil} or the integer zero:"
msgstr "たとえば以下の式は、@code{x}が@code{nil}か整数0かどうかをテストする:"

#. type: example
#: original_texis/control.texi:391
#, no-wrap
msgid "(or (eq x nil) (eq x 0))\n"
msgstr "(or (eq x nil) (eq x 0))\n"

#. type: defspec
#: original_texis/control.texi:395
msgid "Like the @code{and} construct, @code{or} can be written in terms of @code{cond}.  For example:"
msgstr "@code{and}構文と同様に、@code{or}を@code{cond}に置き換えて記述することができる。たとえば:"

#. type: group
#: original_texis/control.texi:403
#, no-wrap
msgid ""
"(or @var{arg1} @var{arg2} @var{arg3})\n"
"@equiv{}\n"
"(cond (@var{arg1})\n"
"      (@var{arg2})\n"
"      (@var{arg3}))\n"
msgstr ""
"(or @var{arg1} @var{arg2} @var{arg3})\n"
"@equiv{}\n"
"(cond (@var{arg1})\n"
"      (@var{arg2})\n"
"      (@var{arg3}))\n"

#. type: defspec
#: original_texis/control.texi:407
msgid "You could almost write @code{or} in terms of @code{if}, but not quite:"
msgstr "ほとんどの場合は、@code{or}を@code{if}に置き換えて記述できるが完全ではない:"

#. type: group
#: original_texis/control.texi:413
#, no-wrap
msgid ""
"(if @var{arg1} @var{arg1}\n"
"  (if @var{arg2} @var{arg2}\n"
"    @var{arg3}))\n"
msgstr ""
"(if @var{arg1} @var{arg1}\n"
"  (if @var{arg2} @var{arg2}\n"
"    @var{arg3}))\n"

#. type: defspec
#: original_texis/control.texi:420
msgid "This is not completely equivalent because it can evaluate @var{arg1} or @var{arg2} twice.  By contrast, @code{(or @var{arg1} @var{arg2} @var{arg3})} never evaluates any argument more than once."
msgstr "これは完全に同一ではない。なぜなら@var{arg1}か@var{arg2}を2回評価するかもしれないからである。対照的に@code{(or @var{arg1} @var{arg2} @var{arg3})}が2回以上引数を評価することは決してない。"

#. type: cindex
#: original_texis/control.texi:424
#, no-wrap
msgid "pcase"
msgstr "pcase"

#. type: cindex
#: original_texis/control.texi:425
#, no-wrap
msgid "pattern matching, programming style"
msgstr "pattern matching, programming style"

#. type: Plain text
#: original_texis/control.texi:434
msgid "Aside from the four basic conditional forms, Emacs Lisp also has a pattern-matching conditional form, the @code{pcase} macro, a hybrid of @code{cond} and @code{cl-case} (@pxref{Conditionals,,,cl,Common Lisp Extensions})  that overcomes their limitations and introduces the @dfn{pattern matching programming style}.  The limitations that @code{pcase} overcomes are:"
msgstr "4つの基本的な条件フォームとは別に、Emacs Lispには@code{cond}と@code{cl-case} (@ref{Conditionals,,,cl,Common Lisp Extensions}を参照)の合成物とも言うべき、@code{pcase}マクロというパターンマッチングによる条件フォームがあります。これは@code{cond}と@code{cl-case}の制限を克服して、@dfn{パターンマッチングによるプログラミングスタイル(pattern matching programming style)}を導入するものです。その@code{pcase}が克服する制限とは:"

#. type: itemize
#: original_texis/control.texi:442
msgid "The @code{cond} form chooses among alternatives by evaluating the predicate @var{condition} of each of its clauses (@pxref{Conditionals}).  The primary limitation is that variables let-bound in @var{condition} are not available to the clause's @var{body-forms}."
msgstr "@code{cond}フォームはclauseそれぞれにたいして述語@var{condition}を評価して候補から選択を行う(@ref{Conditionals}を参照)。@var{condition}内でのletバインドされた変数がclauseの@var{body-forms}で利用できないのが主な制限。"

#. type: itemize
#: original_texis/control.texi:447
msgid "Another annoyance (more an inconvenience than a limitation)  is that when a series of @var{condition} predicates implement equality tests, there is a lot of repeated code.  (@code{cl-case} solves this inconvenience.)"
msgstr "もう1つの煩しい(制限というより不便な)点は一連の@var{condition}述語が等価なテストを実装する際にはコードが多数回繰り返されること(@code{cl-case}はこの不便さを解決している)。"

#. type: itemize
#: original_texis/control.texi:452
msgid "The @code{cl-case} macro chooses among alternatives by evaluating the equality of its first argument against a set of specific values."
msgstr "@code{cl-case}マクロは最初の引数と特定の値セットの等価性を評価することにより候補から選択を行う。"

#. type: itemize
#: original_texis/control.texi:454
msgid "Its limitations are two-fold:"
msgstr "制限は2つ:"

#. type: enumerate
#: original_texis/control.texi:458
msgid "The equality tests use @code{eql}."
msgstr "等価性のテストに@code{eql}を使用。"

#. type: enumerate
#: original_texis/control.texi:460
msgid "The values must be known and written in advance."
msgstr "値は既知でありあらかじめ記述されていなければならない。"

#. type: itemize
#: original_texis/control.texi:466
msgid "These render @code{cl-case} unsuitable for strings or compound data structures (e.g., lists or vectors).  (@code{cond} doesn't have these limitations, but it has others, see above.)"
msgstr "これらの制限は文字列や複合データ構造にたいして@code{cl-case}を不適格にする(このような制限は@code{cond}にはないが上述のように別の制限をもつ)。"

#. type: Plain text
#: original_texis/control.texi:476
msgid "Conceptually, the @code{pcase} macro borrows the first-arg focus of @code{cl-case} and the clause-processing flow of @code{cond}, replacing @var{condition} with a generalization of the equality test which is a variant of @dfn{pattern matching}, and adding facilities so that you can concisely express a clause's predicate, and arrange to share let-bindings between a clause's predicate and @var{body-forms}."
msgstr "@code{pcase}マクロは@dfn{パターンマッチング(pattern matching)}の変種であるような等価性テストを汎化したものによる@var{condition}の置き換え、clauseの述語を簡潔に表現できるような機能の追加、clauseの述語と@var{body-forms}の間でletバインディングを共有するようなアレンジにより、概念的には最初の引数のフォーカスでは@code{cl-case}、clauseの処理フローでは@code{cond}を借用しています。"

#. type: Plain text
#: original_texis/control.texi:481
msgid "The concise expression of a predicate is known as a @dfn{pattern}.  When the predicate, called on the value of the first arg, returns non-@code{nil}, we say that ``the pattern matches the value'' (or sometimes ``the value matches the pattern'')."
msgstr "この述語の簡潔な表現は@dfn{パターン(pattern)}として知られています。最初の引数の値にたいして呼び出される述語が非@code{nil}をリターンしたときには、``パターンが値にマッチした''といいます(``値がパターンにマッチした''ということもある)。"

#. type: menuentry
#: original_texis/control.texi:487
msgid "The @code{pcase} macro: pcase Macro"
msgstr "The @code{pcase} macro: pcase Macro"

#. type: menuentry
#: original_texis/control.texi:487
msgid "Includes examples and caveats."
msgstr "例と注意を含む。"

#. type: menuentry
#: original_texis/control.texi:487
msgid "Extending @code{pcase}: Extending pcase"
msgstr "Extending @code{pcase}: Extending pcase"

#. type: menuentry
#: original_texis/control.texi:487
msgid "Define new kinds of patterns."
msgstr "新種パターンの定義。"

#. type: menuentry
#: original_texis/control.texi:487
msgid "Backquote-Style Patterns: Backquote Patterns"
msgstr "Backquote-Style Patterns: Backquote Patterns"

#. type: menuentry
#: original_texis/control.texi:487
msgid "Structural patterns matching."
msgstr "構造的パターンマッチング。"

#. type: node
#: original_texis/control.texi:487 original_texis/control.texi:1176
#, no-wrap
msgid "Destructuring with pcase Patterns"
msgstr "Destructuring with pcase Patterns"

#. type: menuentry
#: original_texis/control.texi:487
msgid "Using pcase patterns to extract subfields."
msgstr "pcaseパターンによるサブフィールド抽出。"

#. type: node
#: original_texis/control.texi:489
#, no-wrap
msgid "pcase Macro"
msgstr "pcase Macro"

#. type: subsection
#: original_texis/control.texi:490
#, no-wrap
msgid "The @code{pcase} macro"
msgstr "The @code{pcase} macro"

#. type: Plain text
#: original_texis/control.texi:493
msgid "For background, @xref{Pattern-Matching Conditional}."
msgstr "背景は@ref{Pattern-Matching Conditional}を参照してください。"

#. type: defmac
#: original_texis/control.texi:494
#, no-wrap
msgid "pcase expression &rest clauses"
msgstr "pcase expression &rest clauses"

#. type: defmac
#: original_texis/control.texi:497
msgid "Each clause in @var{clauses} has the form: @w{@code{(@var{pattern} @var{body-forms}@dots{})}}."
msgstr "@var{clauses}内のclauseは@w{@code{(@var{pattern} @var{body-forms}@dots{})}}という形式をもつ。"

#. type: defmac
#: original_texis/control.texi:501
msgid "Evaluate @var{expression} to determine its value, @var{expval}.  Find the first clause in @var{clauses} whose @var{pattern} matches @var{expval} and pass control to that clause's @var{body-forms}."
msgstr "@var{expression}の値( @var{expval} )を決定するために評価する。@var{pattern}が@var{expval}にマッチするような最初のclauseを探して、そのclauseの@var{body-forms}に制御を渡す。"

#. type: defmac
#: original_texis/control.texi:505
msgid "If there is a match, the value of @code{pcase} is the value of the last of @var{body-forms} in the successful clause.  Otherwise, @code{pcase} evaluates to @code{nil}."
msgstr "マッチが存在すれば@code{pcase}の値はマッチが成功したclauseの@var{body-forms}の最後の値、それ以外なら@code{pcase}は@code{nil}に評価される。"

#. type: cindex
#: original_texis/control.texi:507
#, no-wrap
msgid "pcase pattern"
msgstr "pcase pattern"

#. type: Plain text
#: original_texis/control.texi:511
msgid "Each @var{pattern} has to be a @dfn{pcase pattern}, which can use either one of the core patterns defined below, or one of the patterns defined via @code{pcase-defmacro} (@pxref{Extending pcase})."
msgstr "各@var{pattern}は@dfn{pcaseパターン(pcase pattern)}である必要があります。これは以下に定義されるコアパターンのいずれか、または@code{pcase-defmacro} (@ref{Extending pcase}を参照)を通じて定義されるパターンの1つを使用できます。"

#. type: Plain text
#: original_texis/control.texi:516
msgid "The rest of this subsection describes different forms of core patterns, presents some examples, and concludes with important caveats on using the let-binding facility provided by some pattern forms.  A core pattern can have the following forms:"
msgstr "このサブセクションの残りの部分ではコアパターンの異なるフォームをいくつかの例を交えて説明して、いくつかのパターンフォームが提供するletバイディング機能を使用する上で重要な注意点で締めくくります。コアパターンは以下のフォームをもつことができます:"

#. type: item
#: original_texis/control.texi:519
#, no-wrap
msgid "_"
msgstr "_"

#. type: table
#: original_texis/control.texi:522
msgid "Matches any @var{expval}.  This is also known as @dfn{don't care} or @dfn{wildcard}."
msgstr "任意の@var{expval}にマッチ。これは@dfn{don't care}、あるいは@dfn{ワイルドカード(wildcard)}としても知られる。"

#. type: item
#: original_texis/control.texi:523
#, no-wrap
msgid "'@var{val}"
msgstr "'@var{val}"

#. type: table
#: original_texis/control.texi:526
msgid "Matches if @var{expval} equals @var{val}.  The comparison is done as if by @code{equal} (@pxref{Equality Predicates})."
msgstr "@var{expval}と@var{val}が等しければマッチ。比較は@code{equal}のように行われる(@ref{Equality Predicates}を参照)。"

#. type: var{#1}
#: original_texis/control.texi:527 original_texis/control.texi:1097
#, no-wrap
msgid "keyword"
msgstr "keyword"

#. type: var{#1}
#: original_texis/control.texi:528 original_texis/control.texi:1098
#, no-wrap
msgid "integer"
msgstr "integer"

#. type: var{#1}
#: original_texis/control.texi:529 original_texis/control.texi:1099
#, no-wrap
msgid "string"
msgstr "string"

#. type: table
#: original_texis/control.texi:533
msgid "Matches if @var{expval} equals the literal object.  This is a special case of @code{'@var{val}}, above, possible because literal objects of these types are self-quoting."
msgstr "@var{expval}がリテラルオブジェクトと等しければマッチ。これは上述の@code{'@var{val}}の特殊なケースであり、これらのタイプのリテラルオブジェクトが自己クォート(self-quoting)を行うために可能となる。"

#. type: var{#1}
#: original_texis/control.texi:534 original_texis/control.texi:1096
#, no-wrap
msgid "symbol"
msgstr "symbol"

#. type: table
#: original_texis/control.texi:538
msgid "Matches any @var{expval}, and additionally let-binds @var{symbol} to @var{expval}, such that this binding is available to @var{body-forms} (@pxref{Dynamic Binding})."
msgstr "任意の@var{expval}にマッチするとともに、追加で@var{symbol}を@var{expval}にletバインドする。このようなバインディングは@var{body-forms}内でも利用できる(@ref{Dynamic Binding}を参照)。"

#. type: table
#: original_texis/control.texi:543
msgid "If @var{symbol} is part of a sequencing pattern @var{seqpat} (e.g., by using @code{and}, below), the binding is also available to the portion of @var{seqpat} following the appearance of @var{symbol}.  This usage has some caveats, see @ref{pcase-symbol-caveats,,caveats}."
msgstr "@var{symbol}が(以下の@code{and}を使用することにより)シーケンスパターン@var{seqpat}の一部なら、@var{symbol}に後続する@var{seqpat}部分でもバインディングは利用可能。この使用法にはいくつかの注意点がある。@ref{pcase-symbol-caveats,,caveats}を参照のこと。"

#. type: table
#: original_texis/control.texi:548
msgid "Two symbols to avoid are @code{t}, which behaves like @code{_} (above) and is deprecated, and @code{nil}, which signals an error.  Likewise, it makes no sense to bind keyword symbols (@pxref{Constant Variables})."
msgstr "使用を避けるべき2つのシンボルは@code{_} (上述)と同様に振る舞う非推奨の@code{t}と@code{nil}(エラーをシグナルする)。同様にキーワードシンボルへのバインドは無意味(@ref{Constant Variables}を参照)。"

#. type: item
#: original_texis/control.texi:549
#, no-wrap
msgid "(pred @var{function})"
msgstr "(pred @var{function})"

#. type: table
#: original_texis/control.texi:553
msgid "Matches if the predicate @var{function} returns non-@code{nil} when called on @var{expval}.  the predicate @var{function} can have one of the following forms:"
msgstr "@var{expval}にたいして述語@var{function}が非@code{nil}をリターンしたらマッチ。述語@var{function}は以下のフォームのいずれかが可能:"

#. type: item
#: original_texis/control.texi:555
#, no-wrap
msgid "function name (a symbol)"
msgstr "関数名(シンボル)"

#. type: table
#: original_texis/control.texi:557
msgid "Call the named function with one argument, @var{expval}."
msgstr "@var{expval}を単一の引数として名前つきの関数を呼び出す。"

#. type: table
#: original_texis/control.texi:559
msgid "Example: @code{integerp}"
msgstr "例: @code{integerp}"

#. type: item
#: original_texis/control.texi:560
#, no-wrap
msgid "lambda expression"
msgstr "lambda式"

#. type: table
#: original_texis/control.texi:563
msgid "Call the anonymous function with one argument, @var{expval} (@pxref{Lambda Expressions})."
msgstr "@var{expval}を単一の引数として無名関数を呼び出す(@ref{Lambda Expressions}を参照)。"

#. type: table
#: original_texis/control.texi:565
msgid "Example: @code{(lambda (n) (= 42 n))}"
msgstr "例: @code{(lambda (n) (= 42 n))}"

#. type: item
#: original_texis/control.texi:566
#, no-wrap
msgid "function call with @var{n} args"
msgstr "@var{n}個の引数での関数呼び出し"

#. type: table
#: original_texis/control.texi:570
msgid "Call the function (the first element of the function call)  with @var{n} arguments (the other elements) and an additional @var{n}+1-th argument that is @var{expval}."
msgstr "関数(関数呼び出しの1つ目の要素)を@var{n}個の引数(残りの要素)、および@var{expval}を@var{n}+1番目の追加の引数としてで呼び出す。"

#. type: table
#: original_texis/control.texi:574
msgid "Example: @code{(= 42)}@* In this example, the function is @code{=}, @var{n} is one, and the actual function call becomes: @w{@code{(= 42 @var{expval})}}."
msgstr "例: @code{(= 42)}@* この例では関数が@code{=}、@var{n}が1であり、実際の関数呼び出しは@w{@code{(= 42 @var{expval})}}になる。"

#. type: item
#: original_texis/control.texi:576
#, no-wrap
msgid "(app @var{function} @var{pattern})"
msgstr "(app @var{function} @var{pattern})"

#. type: table
#: original_texis/control.texi:582
msgid "Matches if @var{function} called on @var{expval} returns a value that matches @var{pattern}.  @var{function} can take one of the forms described for @code{pred}, above.  Unlike @code{pred}, however, @code{app} tests the result against @var{pattern}, rather than against a boolean truth value."
msgstr "@var{expval}にたいして呼び出した@var{function}が@var{pattern}にマッチする値をリターンすればマッチ。@var{function}は上述の@code{pred}で説明したフォームのいずれかが可能。しかし@code{pred}とは異なり、@code{app}はブーリーンの真値ではなく@var{pattern}にたいして結果をテストする点が異なる。"

#. type: item
#: original_texis/control.texi:583
#, no-wrap
msgid "(guard @var{boolean-expression})"
msgstr "(guard @var{boolean-expression})"

#. type: table
#: original_texis/control.texi:585
msgid "Matches if @var{boolean-expression} evaluates to non-@code{nil}."
msgstr "@var{boolean-expression}が非@code{nil}に評価されればマッチ。"

#. type: item
#: original_texis/control.texi:586
#, no-wrap
msgid "(let @var{pattern} @var{expr})"
msgstr "(let @var{pattern} @var{expr})"

#. type: table
#: original_texis/control.texi:590
msgid "Evaluates @var{expr} to get @var{exprval} and matches if @var{exprval} matches @var{pattern}.  (It is called @code{let} because @var{pattern} can bind symbols to values using @var{symbol}.)"
msgstr "@var{exprval}を取得するために@var{expr}を評価して、@var{exprval}が@var{pattern}にマッチすればマッチ(@var{pattern}は@var{symbol}を使用することでシンボルに値をバインドできるので@code{let}と呼ばれる)。"

#. type: cindex
#: original_texis/control.texi:592
#, no-wrap
msgid "sequencing pattern"
msgstr "sequencing pattern"

#. type: Plain text
#: original_texis/control.texi:599
msgid "A @dfn{sequencing pattern} (also known as @var{seqpat}) is a pattern that processes its sub-pattern arguments in sequence.  There are two for @code{pcase}: @code{and} and @code{or}.  They behave in a similar manner to the special forms that share their name (@pxref{Combining Conditions}), but instead of processing values, they process sub-patterns."
msgstr "@var{seqpat}としても知られる@dfn{シーケンスパターン(sequencing pattern)}はサブパターンを順に処理するパターンです。@code{pcase}にたいしては@code{and}と@code{or}の2つが存在します。これらは同じ名前のスペシャルフォーム(@ref{Combining Conditions}を参照)と同様の方式で振る舞いますが、値ではなくサブパターンを処理します。"

#. type: item
#: original_texis/control.texi:601
#, no-wrap
msgid "(and @var{pattern1}@dots{})"
msgstr "(and @var{pattern1}@dots{})"

#. type: table
#: original_texis/control.texi:606
msgid "Attempts to match @var{pattern1}@dots{}, in order, until one of them fails to match.  In that case, @code{and} likewise fails to match, and the rest of the sub-patterns are not tested.  If all sub-patterns match, @code{and} matches."
msgstr "@var{pattern1}@dots{}のいずれかがマッチに失敗するまで順にマッチを試みる。この場合には@code{and}もマッチに失敗して、残りのサブパターンはテストしない。すべてのサブパターンがマッチすれば@code{and}はマッチする。"

#. type: item
#: original_texis/control.texi:607
#, no-wrap
msgid "(or @var{pattern1} @var{pattern2}@dots{})"
msgstr "(or @var{pattern1} @var{pattern2}@dots{})"

#. type: table
#: original_texis/control.texi:616
msgid "Attempts to match @var{pattern1}, @var{pattern2}, @dots{}, in order, until one of them succeeds.  In that case, @code{or} likewise matches, and the rest of the sub-patterns are not tested.  (Note that there must be at least two sub-patterns.  Simply @w{@code{(or @var{pattern1})}} signals error.)"
msgstr "@var{pattern1}、@var{pattern2}、@dots{}のいずれかがマッチに成功するまで順にマッチを試みる。この場合には@code{or}もマッチして、残りのサブパターンはテストしない(少なくともサブパターンが2つなければならにことに注意。単なる@w{@code{(or @var{pattern1})}}はエラーをシグナルする)。"

#. type: table
#: original_texis/control.texi:621
msgid "To present a consistent environment (@pxref{Intro Eval})  to @var{body-forms} (thus avoiding an evaluation error on match), if any of the sub-patterns let-binds a set of symbols, they @emph{must} all bind the same set of symbols."
msgstr "@var{body-forms}に一定の環境(@ref{Intro Eval}を参照)を与えるためには、シンボルセットをletバインドするサブパターンがある場合には、それらは同一のシンボルセットすべてを@emph{バインドしなければならない}。"

#. type: anchor{#1}
#: original_texis/control.texi:624
msgid "pcase-example-0"
msgstr "pcase-example-0"

#. type: subheading
#: original_texis/control.texi:624
#, no-wrap
msgid "Example: Advantage Over @code{cl-case}"
msgstr "例: @code{cl-case}にたいする利点"

#. type: Plain text
#: original_texis/control.texi:629
msgid "Here's an example that highlights some advantages @code{pcase} has over @code{cl-case} (@pxref{Conditionals,,,cl,Common Lisp Extensions})."
msgstr "以下は@code{cl-case} (@ref{Conditionals,,,cl,Common Lisp Extensions}を参照)にたいする@code{pcase}の利点のいくつかを強調する例です。"

#. type: group
#: original_texis/control.texi:636
#, no-wrap
msgid ""
"(pcase (get-return-code x)\n"
"  ;; string\n"
"  ((and (pred stringp) msg)\n"
"   (message \"%s\" msg))\n"
msgstr ""
"(pcase (get-return-code x)\n"
"  ;; 文字列\n"
"  ((and (pred stringp) msg)\n"
"   (message \"%s\" msg))\n"

#. type: group
#: original_texis/control.texi:643
#, no-wrap
msgid ""
"  ;; symbol\n"
"  ('success       (message \"Done!\"))\n"
"  ('would-block   (message \"Sorry, can't do it now\"))\n"
"  ('read-only     (message \"The shmliblick is read-only\"))\n"
"  ('access-denied (message \"You do not have the needed rights\"))\n"
msgstr ""
"  ;; シンボル\n"
"  ('success       (message \"完了!\"))\n"
"  ('would-block   (message \"残念、今は実行できない\"))\n"
"  ('read-only     (message \"shmliblickは読み取り専用\"))\n"
"  ('access-denied (message \"必要な権限がない\"))\n"

#. type: group
#: original_texis/control.texi:647
#, no-wrap
msgid ""
"  ;; default\n"
"  (code           (message \"Unknown return code %S\" code)))\n"
msgstr ""
"  ;; default\n"
"  (code           (message \"未知のリターンコード %S\" code)))\n"

#. type: Plain text
#: original_texis/control.texi:655
msgid "With @code{cl-case}, you would need to explicitly declare a local variable @code{code} to hold the return value of @code{get-return-code}.  Also @code{cl-case} is difficult to use with strings because it uses @code{eql} for comparison."
msgstr "@code{cl-case}では@code{get-return-code}のリターン値を保持するためにローカル変数@code{code}を宣言する必要があります。さらに@code{cl-case}は比較に@code{eql}を使用するので文字列の使用も難しくなります。"

#. type: anchor{#1}
#: original_texis/control.texi:657
msgid "pcase-example-1"
msgstr "pcase-example-1"

#. type: subheading
#: original_texis/control.texi:657
#, no-wrap
msgid "Example: Using @code{and}"
msgstr "例: @code{and}の使用"

#. type: Plain text
#: original_texis/control.texi:663
msgid "A common idiom is to write a pattern starting with @code{and}, with one or more @var{symbol} sub-patterns providing bindings to the sub-patterns that follow (as well as to the body forms).  For example, the following pattern matches single-digit integers."
msgstr "後続のサブパターン(と同様にbodyフォーム)にバインディングを提供する1つ以上の@var{symbol}サブパターンをもつ@code{and}で開始するのが、パターンを記述する際の一般的なイディオムです。たとえば以下のパターンは1桁の整数にマッチします。"

#. type: group
#: original_texis/control.texi:670
#, no-wrap
msgid ""
"(and\n"
"  (pred integerp)\n"
"  n                     ; @r{bind @code{n} to @var{expval}}\n"
"  (guard (<= -9 n 9)))\n"
msgstr ""
"(and\n"
"  (pred integerp)\n"
"  n                     ; @r{@code{n}に@var{expval}をバインド}\n"
"  (guard (<= -9 n 9)))\n"

#. type: Plain text
#: original_texis/control.texi:682
msgid "First, @code{pred} matches if @w{@code{(integerp @var{expval})}} evaluates to non-@code{nil}.  Next, @code{n} is a @var{symbol} pattern that matches anything and binds @code{n} to @var{expval}.  Lastly, @code{guard} matches if the boolean expression @w{@code{(<= -9 n 9)}} (note the reference to @code{n})  evaluates to non-@code{nil}.  If all these sub-patterns match, @code{and} matches."
msgstr "まず@code{pred}は@w{@code{(integerp @var{expval})}}が非@code{nil}に評価されればマッチになります。次に@code{n}はすべてにマッチする@var{symbol}パターンであり、@code{n}に@var{expval}がバインドされます。最後に@code{guard}はブーリーン式@w{@code{(<= -9 n 9)}}が非@code{nil}に評価されればマッチになります(@code{n}への参照に注意)。これらすべてのサブパターンがマッチすれば@code{and}がマッチになります。"

#. type: anchor{#1}
#: original_texis/control.texi:684
msgid "pcase-example-2"
msgstr "pcase-example-2"

#. type: subheading
#: original_texis/control.texi:684
#, no-wrap
msgid "Example: Reformulation with @code{pcase}"
msgstr "例: @code{pcase}による書き換え"

#. type: Plain text
#: original_texis/control.texi:694
msgid "Here is another example that shows how to reformulate a simple matching task from its traditional implementation (function @code{grok/traditional}) to one using @code{pcase} (function @code{grok/pcase}).  The docstring for both these functions is: ``If OBJ is a string of the form \"key:NUMBER\", return NUMBER (a string).  Otherwise, return the list (\"149\" default).'' First, the traditional implementation (@pxref{Regular Expressions}):"
msgstr "以下はシンプルなマッチングタスクを伝統的な実装(関数@code{grok/traditional}から、@code{pcase}を使用する実装(関数@code{grok/pcase})に書き換える別の例です。これらの関数のdocstringはいずれも``If OBJ is a string of the form \"key:NUMBER\", return NUMBER (a string). Otherwise, return the list (\"149\" default).''です。最初は伝統的な実装です(@ref{Regular Expressions}を参照):"

#. type: group
#: original_texis/control.texi:702
#, no-wrap
msgid ""
"(defun grok/traditional (obj)\n"
"  (if (and (stringp obj)\n"
"           (string-match \"^key:\\\\([[:digit:]]+\\\\)$\" obj))\n"
"      (match-string 1 obj)\n"
"    (list \"149\" 'default)))\n"
msgstr ""
"(defun grok/traditional (obj)\n"
"  (if (and (stringp obj)\n"
"           (string-match \"^key:\\\\([[:digit:]]+\\\\)$\" obj))\n"
"      (match-string 1 obj)\n"
"    (list \"149\" 'default)))\n"

#. type: group
#: original_texis/control.texi:708
#, no-wrap
msgid ""
"(grok/traditional \"key:0\")   @result{} \"0\"\n"
"(grok/traditional \"key:149\") @result{} \"149\"\n"
"(grok/traditional 'monolith) @result{} (\"149\" default)\n"
msgstr ""
"(grok/traditional \"key:0\")   @result{} \"0\"\n"
"(grok/traditional \"key:149\") @result{} \"149\"\n"
"(grok/traditional 'monolith) @result{} (\"149\" default)\n"

#. type: Plain text
#: original_texis/control.texi:714
msgid "The reformulation demonstrates @var{symbol} binding as well as @code{or}, @code{and}, @code{pred}, @code{app} and @code{let}."
msgstr "この書き換えでは@var{symbol}バインディング、および@code{or}、@code{and}、@code{pred}、@code{app}、@code{let}を実演します。"

#. type: group
#: original_texis/control.texi:728
#, no-wrap
msgid ""
"(defun grok/pcase (obj)\n"
"  (pcase obj\n"
"    ((or                                     ; @r{line 1}\n"
"      (and                                   ; @r{line 2}\n"
"       (pred stringp)                        ; @r{line 3}\n"
"       (pred (string-match                   ; @r{line 4}\n"
"              \"^key:\\\\([[:digit:]]+\\\\)$\"))   ; @r{line 5}\n"
"       (app (match-string 1)                 ; @r{line 6}\n"
"            val))                            ; @r{line 7}\n"
"      (let val (list \"149\" 'default)))       ; @r{line 8}\n"
"     val)))                                  ; @r{line 9}\n"
msgstr ""
"(defun grok/pcase (obj)\n"
"  (pcase obj\n"
"    ((or                                     ; @r{L1}\n"
"      (and                                   ; @r{L2}\n"
"       (pred stringp)                        ; @r{L3}\n"
"       (pred (string-match                   ; @r{L4}\n"
"              \"^key:\\\\([[:digit:]]+\\\\)$\"))   ; @r{L5}\n"
"       (app (match-string 1)                 ; @r{L6}\n"
"            val))                            ; @r{L7}\n"
"      (let val (list \"149\" 'default)))       ; @r{L8}\n"
"     val)))                                  ; @r{L9}\n"

#. type: group
#: original_texis/control.texi:734
#, no-wrap
msgid ""
"(grok/pcase \"key:0\")   @result{} \"0\"\n"
"(grok/pcase \"key:149\") @result{} \"149\"\n"
"(grok/pcase 'monolith) @result{} (\"149\" default)\n"
msgstr ""
"(grok/pcase \"key:0\")   @result{} \"0\"\n"
"(grok/pcase \"key:149\") @result{} \"149\"\n"
"(grok/pcase 'monolith) @result{} (\"149\" default)\n"

#. type: Plain text
#: original_texis/control.texi:743
msgid "The bulk of @code{grok/pcase} is a single clause of a @code{pcase} form, the pattern on lines 1-8, the (single) body form on line 9.  The pattern is @code{or}, which tries to match in turn its argument sub-patterns, first @code{and} (lines 2-7), then @code{let} (line 8), until one of them succeeds."
msgstr "@code{grok/pcase}は主に1つの@code{pcase}フォームのclause、L1からL8のパターン、L9の(1つの)フォームからなります。パターンは引数であるサブパターンにたいして順にマッチを試みる@code{or}です。これは最初に@code{and} (L2からL7)、次に@code{let} (L8)のように、いずれかが成功するまで順にマッチを試みます。"

#. type: Plain text
#: original_texis/control.texi:749
msgid "As in the previous example (@pxref{pcase-example-1,,Example 1}), @code{and} begins with a @code{pred} sub-pattern to ensure the following sub-patterns work with an object of the correct type (string, in this case).  If @w{@code{(stringp @var{expval})}} returns @code{nil}, @code{pred} fails, and thus @code{and} fails, too."
msgstr "前出の例(@ref{pcase-example-1,,Example 1}を参照)のように、@code{and}は以降のサブパターンが正しいタイプのオブジェクト(この場合は文字列)に作用することを保証するために@code{pred}サブパターンで始まります。@w{@code{(stringp @var{expval})}}が@code{nil}なら@code{pred}は失敗となり、したがって@code{and}も失敗となります。"

#. type: Plain text
#: original_texis/control.texi:755
msgid "The next @code{pred} (lines 4-5) evaluates @w{@code{(string-match RX @var{expval})}} and matches if the result is non-@code{nil}, which means that @var{expval} has the desired form: @code{key:NUMBER}.  Again, failing this, @code{pred} fails and @code{and}, too."
msgstr "次の@code{pred} (L4からL5)は@w{@code{(string-match RX @var{expval})}}を評価して結果が非@code{nil} ( @var{expval}が期待するフォーム@code{key:NUMBER}であることを意味する)ならマッチになります。これが失敗すると再び@code{pred}は失敗となり、したがって@code{and}も失敗となります。"

#. type: Plain text
#: original_texis/control.texi:762
msgid "Lastly (in this series of @code{and} sub-patterns), @code{app} evaluates @w{@code{(match-string 1 @var{expval})}} (line 6)  to get a temporary value @var{tmp} (i.e., the ``NUMBER'' substring)  and tries to match @var{tmp} against pattern @code{val} (line 7).  Since that is a @var{symbol} pattern, it matches unconditionally and additionally binds @code{val} to @var{tmp}."
msgstr "(@code{and}の一連のサブパターンでは)最後の@code{app}は一時的な値@var{tmp} (部分文字列 ``NUMBER'')を取得するために@w{@code{(match-string 1 @var{expval})}} (L6)を評価して、パターン@code{val} (L7)と@var{tmp}のマッチを試みます。これは@var{symbol}パターンなので無条件でマッチして、@code{val}に@var{tmp}を追加でバインドします。"

#. type: Plain text
#: original_texis/control.texi:767
msgid "Now that @code{app} has matched, all @code{and} sub-patterns have matched, and so @code{and} matches.  Likewise, once @code{and} has matched, @code{or} matches and does not proceed to try sub-pattern @code{let} (line 8)."
msgstr "ついに@code{app}がマッチしたので、@code{and}のすべてのサブパターンがマッチして、@code{and}がマッチとなります。同じように一度@code{and}がマッチすれば@code{or}がマッチするので、サブパターン@code{let} (L8)の処理が試みられることはありません。"

#. type: Plain text
#: original_texis/control.texi:773
msgid "Let's consider the situation where @code{obj} is not a string, or it is a string but has the wrong form.  In this case, one of the @code{pred} (lines 3-5) fails to match, thus @code{and} (line 2) fails to match, thus @code{or} (line 1) proceeds to try sub-pattern @code{let} (line 8)."
msgstr "@code{obj}が文字列以外、あるいは間違った形式の文字列の場合を考えてみましょう。この場合にはいずれかの@code{pred} (L3からL5)がマッチに失敗するので、@code{and} (L2)がマッチに失敗して、@code{or} (L1)がサブパターン@code{let} (L8)の処理を試みます。"

#. type: Plain text
#: original_texis/control.texi:780
msgid "First, @code{let} evaluates @w{@code{(list \"149\" 'default)}} to get @w{@code{(\"149\" default)}}, the @var{exprval}, and then tries to match @var{exprval} against pattern @code{val}.  Since that is a @var{symbol} pattern, it matches unconditionally and additionally binds @code{val} to @var{exprval}.  Now that @code{let} has matched, @code{or} matches."
msgstr "まず@code{let}は@w{@code{(\"149\" default)}}を取得するために@w{@code{(list \"149\" 'default)}}を評価して、それからパターン@code{val}にたいして@var{exprval}のマッチを試みます。これは@var{symbol}パターンなので無条件にマッチして、追加で@code{val}に@var{exprval}をバインドします。これで@code{let}がマッチしたので、@code{or}がマッチとなります。"

#. type: Plain text
#: original_texis/control.texi:789
msgid "Note how both @code{and} and @code{let} sub-patterns finish in the same way: by trying (always successfully) to match against the @var{symbol} pattern @code{val}, in the process binding @code{val}.  Thus, @code{or} always matches and control always passes to the body form (line 9).  Because that is the last body form in a successfully matched @code{pcase} clause, it is the value of @code{pcase} and likewise the return value of @code{grok/pcase} (@pxref{What Is a Function})."
msgstr "@code{and}と@code{let}のサブパターンはどちらも同じ方法、すなわち@code{val}をバインドする過程で@var{symbol}パターンの@code{val}に(常に成功する)マッチを試みることにより完了することに注意してください。したがって@code{or}は常にマッチして、常に制御をbodyフォーム(L9)に渡します。マッチが成功した@code{pcase}のclauseとしては最後のbodyなので、これは@code{pcase}の値となり、同様に@code{grok/pcase}のリターン値になります(@ref{What Is a Function}を参照)。"

#. type: anchor{#1}
#: original_texis/control.texi:791
msgid "pcase-symbol-caveats"
msgstr "pcase-symbol-caveats"

#. type: subheading
#: original_texis/control.texi:791
#, no-wrap
msgid "Caveats for @var{symbol} in Sequencing Patterns"
msgstr "シーケンスパターンにおける@var{symbol}の注意点"

#. type: Plain text
#: original_texis/control.texi:797
msgid "The preceding examples all use sequencing patterns which include the @var{symbol} sub-pattern in some way.  Here are some important details about that usage."
msgstr "前出の例のすべてでは、何らかの方法により@var{symbol}サブパターンが含まれるシーケンスパターンが使用されています。以下に使用法に関する重要な詳細をいくつか挙げます。"

#. type: item
#: original_texis/control.texi:799
#, no-wrap
msgid "When @var{symbol} occurs more than once in @var{seqpat},"
msgstr "@var{seqpat}内に@var{symbol}が複数回出現する場合には、"

#. type: enumerate
#: original_texis/control.texi:802
msgid "the second and subsequent occurrences do not expand to re-binding, but instead expand to an equality test using @code{eq}."
msgstr "2回目以降に出現してもリバインドには展開されないが、かわりに@code{eq}を使用した等価性テストに展開される。"

#. type: enumerate
#: original_texis/control.texi:809
msgid "The following example features a @code{pcase} form with two clauses and two @var{seqpat}, A and B.  Both A and B first check that @var{expval} is a pair (using @code{pred}), and then bind symbols to the @code{car} and @code{cdr} of @var{expval} (using one @code{app} each)."
msgstr "以下の例には2つのclauseと2つの@var{seqpat} (AとB)を使用している。AとBはいずれも最初に(@code{pred}を使用することにより)@var{expval}がペアであることをチェックして、それから(それぞれにたいして@code{app}を使用することにより) @var{expval}の@code{car}と@code{cdr}にシンボルをバインドする。"

#. type: enumerate
#: original_texis/control.texi:814
msgid "For A, because symbol @code{st} is mentioned twice, the second mention becomes an equality test using @code{eq}.  On the other hand, B uses two separate symbols, @code{s1} and @code{s2}, both of which become independent bindings."
msgstr "Aではシンボル@code{st}が2回記述されているので、2つ目の記述は@code{eq}を使用した等価性チェックになる。一方でBは@code{s1}と@code{s2}という別個のシンボルを使用するので、独立したバインディングになる。"

#. type: group
#: original_texis/control.texi:823
#, no-wrap
msgid ""
"(defun grok (object)\n"
"  (pcase object\n"
"    ((and (pred consp)        ; seqpat A\n"
"          (app car st)        ; first mention: st\n"
"          (app cdr st))       ; second mention: st\n"
"     (list 'eq st))\n"
msgstr ""
"(defun grok (object)\n"
"  (pcase object\n"
"    ((and (pred consp)        ; seqpat A\n"
"          (app car st)        ; st: 1回目\n"
"          (app cdr st))       ; st: 2回目\n"
"     (list 'eq st))\n"

#. type: group
#: original_texis/control.texi:829
#, no-wrap
msgid ""
"    ((and (pred consp)        ; seqpat B\n"
"          (app car s1)        ; first mention: s1\n"
"          (app cdr s2))       ; first mention: s2\n"
"     (list 'not-eq s1 s2))))\n"
msgstr ""
"    ((and (pred consp)        ; seqpat B\n"
"          (app car s1)        ; s1: 1回目\n"
"          (app cdr s2))       ; s2: 1回目\n"
"     (list 'not-eq s1 s2))))\n"

#. type: group
#: original_texis/control.texi:836
#, no-wrap
msgid ""
"(let ((s \"yow!\"))\n"
"  (grok (cons s s)))      @result{} (eq \"yow!\")\n"
"(grok (cons \"yo!\" \"yo!\")) @result{} (not-eq \"yo!\" \"yo!\")\n"
"(grok '(4 2))             @result{} (not-eq 4 (2))\n"
msgstr ""
"(let ((s \"yow!\"))\n"
"  (grok (cons s s)))      @result{} (eq \"yow!\")\n"
"(grok (cons \"yo!\" \"yo!\")) @result{} (not-eq \"yo!\" \"yo!\")\n"
"(grok '(4 2))             @result{} (not-eq 4 (2))\n"

#. type: item
#: original_texis/control.texi:839
#, no-wrap
msgid "Side-effecting code referencing @var{symbol} is undefined."
msgstr "@var{symbol}を参照するコードの副作用は未定義。"

#. type: enumerate
#: original_texis/control.texi:843
msgid "Avoid.  For example, here are two similar functions.  Both use @code{and}, @var{symbol} and @code{guard}:"
msgstr "無視する。たとえば以下2つの関数は類似している。いずれの関数も@code{and}、@var{symbol}、@code{guard}を使用する:"

#. type: group
#: original_texis/control.texi:850
#, no-wrap
msgid ""
"(defun square-double-digit-p/CLEAN (integer)\n"
"  (pcase (* integer integer)\n"
"    ((and n (guard (< 9 n 100))) (list 'yes n))\n"
"    (sorry (list 'no sorry))))\n"
"\n"
msgstr ""
"(defun square-double-digit-p/CLEAN (integer)\n"
"  (pcase (* integer integer)\n"
"    ((and n (guard (< 9 n 100))) (list 'yes n))\n"
"    (sorry (list 'no sorry))))\n"
"\n"

#. type: group
#: original_texis/control.texi:853
#, no-wrap
msgid ""
"(square-double-digit-p/CLEAN 9) @result{} (yes 81)\n"
"(square-double-digit-p/CLEAN 3) @result{} (no 9)\n"
msgstr ""
"(square-double-digit-p/CLEAN 9) @result{} (yes 81)\n"
"(square-double-digit-p/CLEAN 3) @result{} (no 9)\n"

#. type: group
#: original_texis/control.texi:860
#, no-wrap
msgid ""
"(defun square-double-digit-p/MAYBE (integer)\n"
"  (pcase (* integer integer)\n"
"    ((and n (guard (< 9 (incf n) 100))) (list 'yes n))\n"
"    (sorry (list 'no sorry))))\n"
"\n"
msgstr ""
"(defun square-double-digit-p/MAYBE (integer)\n"
"  (pcase (* integer integer)\n"
"    ((and n (guard (< 9 (incf n) 100))) (list 'yes n))\n"
"    (sorry (list 'no sorry))))\n"
"\n"

#. type: group
#: original_texis/control.texi:863
#, no-wrap
msgid ""
"(square-double-digit-p/MAYBE 9) @result{} (yes 81)\n"
"(square-double-digit-p/MAYBE 3) @result{} (yes 9)  ; @r{WRONG!}\n"
msgstr ""
"(square-double-digit-p/MAYBE 9) @result{} (yes 81)\n"
"(square-double-digit-p/MAYBE 3) @result{} (yes 9)  ; @r{WRONG!}\n"

#. type: enumerate
#: original_texis/control.texi:872
msgid "The difference is in @var{boolean-expression} in @code{guard}: @code{CLEAN} references @code{n} simply and directly, while @code{MAYBE} references @code{n} with a side-effect, in the expression @code{(incf n)}.  When @code{integer} is 3, here's what happens:"
msgstr "違いは@code{guard}内の@var{boolean-expression}である。@code{CLEAN}は単に直接@code{n}を参照するのにたいして、@code{MAYBE}は式@code{(incf n)}の中で副作用により@code{n}を参照している。@code{integer}の際には以下のようなことが発生している:"

#. type: item
#: original_texis/control.texi:874
#, no-wrap
msgid "The first @code{n} binds it to @var{expval},"
msgstr "最初の@code{n}は@var{expval}"

#. type: itemize
#: original_texis/control.texi:876
msgid "i.e., the result of evaluating @code{(* 3 3)}, or 9."
msgstr "(評価した結果である@code{(* 3 3)}、つまり9)にバインドされる。"

#. type: item
#: original_texis/control.texi:877
#, no-wrap
msgid "@var{boolean-expression} is evaluated:"
msgstr "@var{boolean-expression}が評価される:"

#. type: group
#: original_texis/control.texi:884
#, no-wrap
msgid ""
"start:   (< 9 (incf n)        100)\n"
"becomes: (< 9 (setq n (1+ n)) 100)\n"
"becomes: (< 9 (setq n (1+ 9)) 100)\n"
msgstr ""
"start:   (< 9 (incf n)        100)\n"
"becomes: (< 9 (setq n (1+ n)) 100)\n"
"becomes: (< 9 (setq n (1+ 9)) 100)\n"

#. type: group
#: original_texis/control.texi:891
#, no-wrap
msgid ""
"becomes: (< 9 (setq n 10)     100)\n"
"                                   ; @r{side-effect here!}\n"
"becomes: (< 9       n         100) ; @r{@code{n} now bound to 10}\n"
"becomes: (< 9      10         100)\n"
"becomes: t\n"
msgstr ""
"becomes: (< 9 (setq n 10)     100)\n"
"                                   ; @r{ここで副作用!}\n"
"becomes: (< 9       n         100) ; @r{@code{n}は10にバインドされている}\n"
"becomes: (< 9      10         100)\n"
"becomes: t\n"

#. type: item
#: original_texis/control.texi:894
#, no-wrap
msgid "Because the result of the evaluation is non-@code{nil},"
msgstr "結果は非@code{nil}なので"

#. type: itemize
#: original_texis/control.texi:897
msgid "@code{guard} matches, @code{and} matches, and control passes to that clause's body forms."
msgstr "@code{guard}がマッチして@code{and}がマッチとなり、制御はそのclauseのbodyフォームに渡される。"

#. type: enumerate
#: original_texis/control.texi:904
msgid "Aside from the mathematical incorrectness of asserting that 9 is a double-digit integer, there is another problem with @code{MAYBE}.  The body form references @code{n} once more, yet we do not see the updated value---10---at all.  What happened to it?"
msgstr "@code{MAYBE}には9が2桁の整数だと判定してしまう数学的な誤り以外にも問題がある。bodyフォームは@code{n}の更新された値(10)を確認せずに参照を複数回行う。するとどうなるか?"

#. type: enumerate
#: original_texis/control.texi:910
msgid "To sum up, it's best to avoid side-effecting references to @var{symbol} patterns entirely, not only in @var{boolean-expression} (in @code{guard}), but also in @var{expr} (in @code{let})  and @var{function} (in @code{pred} and @code{app})."
msgstr "要約すると( @code{guard}での) @var{boolean-expression}だけではなく( @code{let}での) @var{expr}、( @code{pred}と@code{app}での) @var{function}でも副作用をもつ@var{symbol}パターンにたいする参照は完全に避けることが最良である。"

#. type: item
#: original_texis/control.texi:911
#, no-wrap
msgid "On match, the clause's body forms can reference the set"
msgstr "マッチではclauseのbodyフォームはletバインドされたパターンのシンボルセットを参照できる。"

#. type: enumerate
#: original_texis/control.texi:917
msgid "of symbols the pattern let-binds.  When @var{seqpat} is @code{and}, this set is the union of all the symbols each of its sub-patterns let-binds.  This makes sense because, for @code{and} to match, all the sub-patterns must match."
msgstr "このシンボルセットは@var{seqpat}が@code{and}の際には、各サブパターンでletバインドされるすべてのシンボルそれぞれを結合したものになる。@code{and}のマッチではすべてのサブパターンがマッチしなければならないので、これには意味がある。"

#. type: enumerate
#: original_texis/control.texi:925
msgid "When @var{seqpat} is @code{or}, things are different: @code{or} matches at the first sub-pattern that matches; the rest of the sub-patterns are ignored.  It makes no sense for each sub-pattern to let-bind a different set of symbols because the body forms have no way to distinguish which sub-pattern matched and choose among the different sets.  For example, the following is invalid:"
msgstr "@var{seqpat}が@code{or}なら事情は異なる。@code{or}は最初にマッチしたサブパターンでマッチとなり、残りのサブパターンは無視される。bodyフォームにはどのサブパターンがマッチして異なるセットの中からどれが選択されたかを知る術はないので、各シンボルが異なるシンボルセットをletバインドすることに意味はない。たとえば以下は無効:"

#. type: group
#: original_texis/control.texi:933
#, no-wrap
msgid ""
"(pcase (read-number \"Enter an integer: \")\n"
"  ((or (and (pred evenp)\n"
"            e-num)      ; @r{bind @code{e-num} to @var{expval}}\n"
"       o-num)           ; @r{bind @code{o-num} to @var{expval}}\n"
"   (list e-num o-num)))\n"
msgstr ""
"(pcase (read-number \"Enter an integer: \")\n"
"  ((or (and (pred evenp)\n"
"            e-num)      ; @r{@code{e-num}に@var{expval}をバインド}\n"
"       o-num)           ; @r{@code{o-num}にを@var{expval}バインド}\n"
"   (list e-num o-num)))\n"

#. type: group
#: original_texis/control.texi:938
#, no-wrap
msgid ""
"Enter an integer: 42\n"
"@error{} Symbol’s value as variable is void: o-num\n"
msgstr ""
"Enter an integer: 42\n"
"@error{} Symbol’s value as variable is void: o-num\n"

#. type: group
#: original_texis/control.texi:942
#, no-wrap
msgid ""
"Enter an integer: 149\n"
"@error{} Symbol’s value as variable is void: e-num\n"
msgstr ""
"Enter an integer: 149\n"
"@error{} Symbol’s value as variable is void: e-num\n"

#. type: enumerate
#: original_texis/control.texi:950
msgid "Evaluating body form @w{@code{(list e-num o-num)}} signals error.  To distinguish between sub-patterns, you can use another symbol, identical in name in all sub-patterns but differing in value.  Reworking the above example:"
msgstr "bodyフォーム@w{@code{(list e-num o-num)}}の評価によりエラーがシグナルされる。サブパターンを区別するために、すべてのサブパターンごとに異なる値をもつ同一名のシンボルを使用できる。上記の例を書き換えると:"

#. type: group
#: original_texis/control.texi:959
#, no-wrap
msgid ""
"(pcase (read-number \"Enter an integer: \")\n"
"  ((and num                                ; @r{line 1}\n"
"        (or (and (pred evenp)              ; @r{line 2}\n"
"                 (let spin 'even))         ; @r{line 3}\n"
"            (let spin 'odd)))              ; @r{line 4}\n"
"   (list spin num)))                       ; @r{line 5}\n"
msgstr ""
"(pcase (read-number \"Enter an integer: \")\n"
"  ((and num                                ; @r{L1}\n"
"        (or (and (pred evenp)              ; @r{L2}\n"
"                 (let spin 'even))         ; @r{L3}\n"
"            (let spin 'odd)))              ; @r{L4}\n"
"   (list spin num)))                       ; @r{L5}\n"

#. type: group
#: original_texis/control.texi:964
#, no-wrap
msgid ""
"Enter an integer: 42\n"
"@result{} (even 42)\n"
msgstr ""
"Enter an integer: 42\n"
"@result{} (even 42)\n"

#. type: group
#: original_texis/control.texi:968
#, no-wrap
msgid ""
"Enter an integer: 149\n"
"@result{} (odd 149)\n"
msgstr ""
"Enter an integer: 149\n"
"@result{} (odd 149)\n"

#. type: enumerate
#: original_texis/control.texi:979
msgid "Line 1 ``factors out'' the @var{expval} binding with @code{and} and @var{symbol} (in this case, @code{num}).  On line 2, @code{or} begins in the same way as before, but instead of binding different symbols, uses @code{let} twice (lines 3-4) to bind the same symbol @code{spin} in both sub-patterns.  The value of @code{spin} distinguishes the sub-patterns.  The body form references both symbols (line 5)."
msgstr "L1では@var{expval}のバインディング(この場合は@code{num} )を@code{and}と@var{symbol}で``分解''している。L2では前と同じ方法で@code{or}は始まるが、異なるシンボルにバインドするかわりに、両方のサブパターン内で同一のシンボル@code{spin}に回バインドするために2回@code{let}を使用している(L3からL4)。@code{spin}の値によりサブパターンは区別される。そしてbodyフォームでは両方のシンボルを参照している(L5)。"

#. type: node
#: original_texis/control.texi:981
#, no-wrap
msgid "Extending pcase"
msgstr "Extending pcase"

#. type: subsection
#: original_texis/control.texi:982
#, no-wrap
msgid "Extending @code{pcase}"
msgstr "Extending @code{pcase}"

#. type: cindex
#: original_texis/control.texi:983
#, no-wrap
msgid "pcase, defining new kinds of patterns"
msgstr "pcase, defining new kinds of patterns"

#. type: Plain text
#: original_texis/control.texi:989
msgid "The @code{pcase} macro supports several kinds of patterns (@pxref{Pattern-Matching Conditional}).  You can add support for other kinds of patterns using the @code{pcase-defmacro} macro."
msgstr "@code{pcase}マクロは数種類のパターンをサポートします(@ref{Pattern-Matching Conditional}を参照)。@code{pcase-defmacro}を使用すれば違う種類のパターンにたいするサポートを追加できます。"

#. type: defmac
#: original_texis/control.texi:990
#, no-wrap
msgid "pcase-defmacro name args [doc] &rest body"
msgstr "pcase-defmacro name args [doc] &rest body"

#. type: defmac
#: original_texis/control.texi:997
msgid "Define a new kind of pattern for @code{pcase}, to be invoked as @w{@code{(@var{name} @var{actual-args})}}.  The @code{pcase} macro expands this into a function call that evaluates @var{body}, whose job it is to rewrite the invoked pattern into some other pattern, in an environment where @var{args} are bound to @var{actual-args}."
msgstr "@w{@code{(@var{name} @var{actual-args})}}のように呼び出すために新たな種類の@code{pcase}用のパターンを定義する。@code{pcase}マクロは@var{body}を評価する呼び出しへと展開する。このマクロの役割は@var{args}を@var{actual-args}にバインドした環境下において、呼び出されたパターンを別の何らかのパターンに書き換えることである。"

#. type: defmac
#: original_texis/control.texi:1003
msgid "Additionally, arrange to display @var{doc} along with the docstring of @code{pcase}.  By convention, @var{doc} should use @code{EXPVAL} to stand for the result of evaluating @var{expression} (first arg to @code{pcase})."
msgstr "さらに@code{pcase}のドキュメント文字列とともに@var{doc}が表示されるように計らう。@var{doc}では慣例により@var{expression}の評価結果を示すために@code{EXPVAL}を使用すること。"

#. type: Plain text
#: original_texis/control.texi:1012
msgid "Typically, @var{body} rewrites the invoked pattern to use more basic patterns.  Although all patterns eventually reduce to core patterns, @code{body} need not use core patterns straight away.  The following example defines two patterns, named @code{less-than} and @code{integer-less-than}."
msgstr "@var{body}は通常はより基本的なパターンを使用して呼び出されたパターンを書き換える。最終的にはすべてのパターンはコアパターンに絞り込まれるが、@code{body}がすぐにコアパターンを使用する必要はない。以下の例では@code{less-than}と@code{integer-less-than}という2つのパターンを定義している。"

#. type: group
#: original_texis/control.texi:1018
#, no-wrap
msgid ""
"(pcase-defmacro less-than (n)\n"
"  \"Matches if EXPVAL is a number less than N.\"\n"
"  `(pred (> ,n)))\n"
msgstr ""
"(pcase-defmacro less-than (n)\n"
"  \"Matches if EXPVAL is a number less than N.\"\n"
"  `(pred (> ,n)))\n"

#. type: group
#: original_texis/control.texi:1025
#, no-wrap
msgid ""
"(pcase-defmacro integer-less-than (n)\n"
"  \"Matches if EXPVAL is an integer less than N.\"\n"
"  `(and (pred integerp)\n"
"        (less-than ,n)))\n"
msgstr ""
"(pcase-defmacro integer-less-than (n)\n"
"  \"Matches if EXPVAL is an integer less than N.\"\n"
"  `(and (pred integerp)\n"
"        (less-than ,n)))\n"

#. type: Plain text
#: original_texis/control.texi:1037
msgid "Note that the docstrings mention @var{args} (in this case, only one: @code{n}) in the usual way, and also mention @code{EXPVAL} by convention.  The first rewrite (i.e., @var{body} for @code{less-than})  uses one core pattern: @code{pred}.  The second uses two core patterns: @code{and} and @code{pred}, as well as the newly-defined pattern @code{less-than}.  Both use a single backquote construct (@pxref{Backquote})."
msgstr "@var{args} (このケースでは@code{n}の1つだけ)に言及するdocstringは通常の方法、@code{EXPVAL}では慣例にもとづく方法であることに注意してください。1つ目の書き換え( @code{less-than}の@var{body} )では@code{pred}というコアパターンだけが使用されていて、2つ目では2つのコアパターン@code{and}と@code{pred}と新たに定義したパターン@code{less-than}が使用されています。そしていずれの書き換えにおいてもシングルバッククォート構文が使用されています(@ref{Backquote}を参照)。"

#. type: node
#: original_texis/control.texi:1038
#, no-wrap
msgid "Backquote Patterns"
msgstr "Backquote Patterns"

#. type: subsection
#: original_texis/control.texi:1039
#, no-wrap
msgid "Backquote-Style Patterns"
msgstr "Backquote-Style Patterns"

#. type: cindex
#: original_texis/control.texi:1040
#, no-wrap
msgid "backquote-style patterns"
msgstr "backquote-style patterns"

#. type: cindex
#: original_texis/control.texi:1041
#, no-wrap
msgid "matching, structural"
msgstr "matching, structural"

#. type: cindex
#: original_texis/control.texi:1042
#, no-wrap
msgid "structural matching"
msgstr "structural matching"

#. type: Plain text
#: original_texis/control.texi:1047
msgid "This subsection describes @dfn{backquote-style patterns}, a set of builtin patterns that eases structural matching.  For background, @pxref{Pattern-Matching Conditional}."
msgstr "このサブセクションでは構造化マッチングを容易にするビルトインパターン@dfn{バッククォートスタイルパターン(backquote-style patterns)}について説明します。背景については@ref{Pattern-Matching Conditional}を参照してください。"

#. type: Plain text
#: original_texis/control.texi:1051
msgid "Backquote-style patterns are a powerful set of @code{pcase} pattern extensions (created using @code{pcase-defmacro}) that make it easy to match @var{expval} against specifications of its @emph{structure}."
msgstr "バッククォートスタイルパターンは(@code{pcase-defmacro}を使用して作成された)強力な@code{pcase}パターン拡張であり、その@emph{構造(structure)}の仕様にたいする@var{expval}をマッチを容易にします。"

#. type: Plain text
#: original_texis/control.texi:1055
msgid "For example, to match @var{expval} that must be a list of two elements whose first element is a specific string and the second element is any value, you can write a core pattern:"
msgstr "たとえば1つ目の要素が特定の文字列、2つ目の要素が任意の値であるような2要素リストの@var{expval}にたいするマッチはコアパターンを使用して記述できます:"

#. type: group
#: original_texis/control.texi:1060
#, no-wrap
msgid ""
"(and (pred listp)\n"
"     ls\n"
msgstr ""
"(and (pred listp)\n"
"     ls\n"

#. type: group
#: original_texis/control.texi:1065
#, no-wrap
msgid ""
"     (guard (= 2 (length ls)))\n"
"     (guard (string= \"first\" (car ls)))\n"
"     (let second-elem (cadr ls)))\n"
msgstr ""
"     (guard (= 2 (length ls)))\n"
"     (guard (string= \"first\" (car ls)))\n"
"     (let second-elem (cadr ls)))\n"

#. type: Plain text
#: original_texis/control.texi:1070
msgid "or you can write the equivalent backquote-style pattern:"
msgstr "しかし等価なバッククォートスタイルパターンで記述することもできます:"

#. type: example
#: original_texis/control.texi:1073
#, no-wrap
msgid "`(\"first\" ,second-elem)\n"
msgstr "`(\"first\" ,second-elem)\n"

#. type: Plain text
#: original_texis/control.texi:1079
msgid "The backquote-style pattern is more concise, resembles the structure of @var{expval}, and avoids binding @code{ls}."
msgstr "バッククォートスタイルパターンはより簡潔かつ@var{expval}の構造と似ており、@code{ls}のバインドを要しません。"

#. type: Plain text
#: original_texis/control.texi:1082
msgid "A backquote-style pattern has the form @code{`@var{qpat}} where @var{qpat} can have the following forms:"
msgstr "バッククォートスタイルパターンは@code{`@var{qpat}}のような形式をもちます。ここで@var{qpat}は以下の形式をもつことができます:"

#. type: item
#: original_texis/control.texi:1085
#, no-wrap
msgid "(@var{qpat1} . @var{qpat2})"
msgstr "(@var{qpat1} . @var{qpat2})"

#. type: table
#: original_texis/control.texi:1090
msgid "Matches if @var{expval} is a cons cell whose @code{car} matches @var{qpat1} and whose @code{cdr} matches @var{qpat2}.  This readily generalizes to lists as in @w{@code{(@var{qpat1} @var{qpat2} @dots{})}}."
msgstr "@var{expval}が( @code{car}が@var{qpat1}、@code{cdr}が@var{qpat2}にマッチする)コンスセルならマッチ。@w{@code{(@var{qpat1} @var{qpat2} @dots{})}}のように容易に一般化できる。"

#. type: item
#: original_texis/control.texi:1091
#, no-wrap
msgid "[@var{qpat1} @var{qpat2} @dots{} @var{qpatm}]"
msgstr "[@var{qpat1} @var{qpat2} @dots{} @var{qpatm}]"

#. type: table
#: original_texis/control.texi:1095
msgid "Matches if @var{expval} is a vector of length @var{m} whose @code{0}..@code{(@var{m}-1)}th elements match @var{qpat1}, @var{qpat2} @dots{} @var{qpatm}, respectively."
msgstr "@var{expval}が長さ@var{m}の(@code{0}から@code{(@var{m}-1)}番目の要素が@var{qpat1}、@var{qpat2}、@dots{}、@var{qpatm}にマッチする)ベクターならマッチ。"

#. type: table
#: original_texis/control.texi:1104
msgid "Matches if the corresponding element of @var{expval} is @code{equal} to the specified literal object.  Note that, aside from @var{symbol}, this is the same set of self-quoting literal objects that are acceptable as a core pattern."
msgstr "@var{expval}の対応する要素が指定されたリテラルオブジェクトと@code{equal}ならマッチ。@var{symbol}を別にすると、これはコアパターンとして許容され得る自己クォートを行うリテラルオブジェクトと同一。"

#. type: item
#: original_texis/control.texi:1105
#, no-wrap
msgid ",@var{pattern}"
msgstr ",@var{pattern}"

#. type: table
#: original_texis/control.texi:1112
msgid "Matches if the corresponding element of @var{expval} matches @var{pattern}.  Note that @var{pattern} is any kind that @code{pcase} supports.  (In the example above, @code{second-elem} is a @var{symbol} core pattern; it therefore matches anything, and let-binds @code{second-elem}.)"
msgstr "@var{expval}の対応する要素が@var{pattern}にマッチすればマッチ。@var{pattern}は@code{pcase}がサポートするすべての種類のパターンであることに注意(上記の例では@code{second-elem}は@var{symbol}コアパターンであり、これはすべてにマッチして@code{second-elem}をletでバインドする)。"

#. type: Plain text
#: original_texis/control.texi:1119
msgid "The @dfn{corresponding element} is the portion of @var{expval} that is in the same structural position as the structural position of @var{qpat} in the backquote-style pattern.  (In the example above, the corresponding element of @code{second-elem} is the second element of @var{expval}.)"
msgstr "@dfn{対応する要素(corresponding element)}とはバッククォートスタイルパターン@var{qpat}にたいする構造的な位置に等しいような@var{expval}の構造的な位置部分のことです(上記の例では@code{second-elem}の対応する要素は@var{expval}の2つ目の要素)。"

#. type: Plain text
#: original_texis/control.texi:1125
msgid "Here is an example of using @code{pcase} to implement a simple interpreter for a little expression language (note that this requires lexical binding for the lambda expression in the @code{fn} clause to properly capture @code{body} and @code{arg} (@pxref{Lexical Binding}):"
msgstr "以下は小さな式言語用の単純なインタープリターの実装用に@code{pcase}を使用する例です(@code{body}と@code{arg}を正しくキャプチャーするには@code{fn}のclause内でlambda式にレキシカルバインディングが必要なことに注意):"

#. type: group
#: original_texis/control.texi:1132
#, no-wrap
msgid ""
"(defun evaluate (form env)\n"
"  (pcase form\n"
"    (`(add ,x ,y)       (+ (evaluate x env)\n"
"                           (evaluate y env)))\n"
msgstr ""
"(defun evaluate (form env)\n"
"  (pcase form\n"
"    (`(add ,x ,y)       (+ (evaluate x env)\n"
"                           (evaluate y env)))\n"

#. type: group
#: original_texis/control.texi:1139
#, no-wrap
msgid ""
"    (`(call ,fun ,arg)  (funcall (evaluate fun env)\n"
"                                 (evaluate arg env)))\n"
"    (`(fn ,arg ,body)   (lambda (val)\n"
"                          (evaluate body (cons (cons arg val)\n"
"                                               env))))\n"
msgstr ""
"    (`(call ,fun ,arg)  (funcall (evaluate fun env)\n"
"                                 (evaluate arg env)))\n"
"    (`(fn ,arg ,body)   (lambda (val)\n"
"                          (evaluate body (cons (cons arg val)\n"
"                                               env))))\n"

#. type: group
#: original_texis/control.texi:1144
#, no-wrap
msgid ""
"    ((pred numberp)     form)\n"
"    ((pred symbolp)     (cdr (assq form env)))\n"
"    (_                  (error \"Syntax error: %S\" form))))\n"
msgstr ""
"    ((pred numberp)     form)\n"
"    ((pred symbolp)     (cdr (assq form env)))\n"
"    (_                  (error \"Syntax error: %S\" form))))\n"

#. type: Plain text
#: original_texis/control.texi:1156
msgid "The first three clauses use backquote-style patterns.  @code{`(add ,x ,y)} is a pattern that checks that @code{form} is a three-element list starting with the literal symbol @code{add}, then extracts the second and third elements and binds them to symbols @code{x} and @code{y}, respectively.  The clause body evaluates @code{x} and @code{y} and adds the results.  Similarly, the @code{call} clause implements a function call, and the @code{fn} clause implements an anonymous function definition."
msgstr "最初の3つのclauseではバッククォートスタイルパターンが使用されています。@code{`(add ,x ,y)}は@code{form}がリテラルシンボル@code{add}から始まる3要素リストであることをチェックしてから2つ目と3つ目の要素を取り出してシンボル@code{x}と@code{y}にバインドします。clauseのbodyでは@code{x}と@code{y}を評価して結果を加算します。同じように@code{call} clauseは関数呼び出しを実装して、@code{fn} clauseは無名関数定義を実装します。"

#. type: Plain text
#: original_texis/control.texi:1165
msgid "The remaining clauses use core patterns.  @code{(pred numberp)} matches if @code{form} is a number.  On match, the body evaluates it.  @code{(pred symbolp)} matches if @code{form} is a symbol.  On match, the body looks up the symbol in @code{env} and returns its association.  Finally, @code{_} is the catch-all pattern that matches anything, so it's suitable for reporting syntax errors."
msgstr "残りのclauseではコアパターンが使用されています。@code{(pred numberp)}は@code{form}が数値ならマッチします。マッチした場合にはbodyがそれを評価します。@code{(pred symbolp)}は@code{form}がシンボルならマッチします。マッチした場合にはbodyは@code{env}内のシンボルを照合して、それの連想値をリターンします。最後の@code{_}はすべてにマッチするcatch-allパターンなので、構文エラーの報告に適しています。"

#. type: Plain text
#: original_texis/control.texi:1168
msgid "Here are some sample programs in this small language, including their evaluation results:"
msgstr "以下は評価した結果を含む、この小さな言語のサンプルプログラムの例です:"

#. type: example
#: original_texis/control.texi:1174
#, no-wrap
msgid ""
"(evaluate '(add 1 2) nil)                 @result{} 3\n"
"(evaluate '(add x y) '((x . 1) (y . 2)))  @result{} 3\n"
"(evaluate '(call (fn x (add 1 x)) 2) nil) @result{} 3\n"
"(evaluate '(sub 1 2) nil)                 @result{} error\n"
msgstr ""
"(evaluate '(add 1 2) nil)                 @result{} 3\n"
"(evaluate '(add x y) '((x . 1) (y . 2)))  @result{} 3\n"
"(evaluate '(call (fn x (add 1 x)) 2) nil) @result{} 3\n"
"(evaluate '(sub 1 2) nil)                 @result{} error\n"

#. type: subsection
#: original_texis/control.texi:1177
#, no-wrap
msgid "Destructuring with @code{pcase} Patterns"
msgstr "Destructuring with @code{pcase} Patterns"

#. type: cindex
#: original_texis/control.texi:1178
#, no-wrap
msgid "destructuring with pcase patterns"
msgstr "destructuring with pcase patterns"

#. type: Plain text
#: original_texis/control.texi:1184
msgid "Pcase patterns not only express a condition on the form of the objects they can match, but they can also extract sub-fields of those objects.  For example we can extract 2 elements from a list that is the value of the variable @code{my-list} with the following code:"
msgstr "pcaseのパターンはあるオブジェクトがマッチ可能なフォーム上の条件を表現するだけではなく、それらのオブジェクトのサブフィールドの抽出もできます。たとえば以下のコードにより、変数@code{my-list}の値であるリストから2つの要素を抽出できます:"

#. type: example
#: original_texis/control.texi:1188
#, no-wrap
msgid ""
"  (pcase my-list\n"
"    (`(add ,x ,y)  (message \"Contains %S and %S\" x y)))\n"
msgstr ""
"  (pcase my-list\n"
"    (`(add ,x ,y)  (message \"Contains %S and %S\" x y)))\n"

#. type: Plain text
#: original_texis/control.texi:1195
msgid "This will not only extract @code{x} and @code{y} but will additionally test that @code{my-list} is a list containing exactly 3 elements and whose first element is the symbol @code{add}.  If any of those tests fail, @code{pcase} will immediately return @code{nil} without calling @code{message}."
msgstr "これは@code{x}と@code{y}を抽出すだけではなく、加えて@code{my-list}が正確に3つの要素を含むリストであり、最初の要素がシンボル@code{add}かどうかをテストします。これらのテストのいずれかが失敗したら、@code{pcase}は@code{message}を呼び出さずに即座に@code{nil}をリターンします。"

#. type: Plain text
#: original_texis/control.texi:1202
msgid "Extraction of multiple values stored in an object is known as @dfn{destructuring}.  Using @code{pcase} patterns allows to perform @dfn{destructuring binding}, which is similar to a local binding (@pxref{Local Variables}), but gives values to multiple elements of a variable by extracting those values from an object of compatible structure."
msgstr "あるオブジェクトから格納された複数の値を抽出する処理は@dfn{分割(destructuring)}という処理としても知られています。@code{pcase}パターンの使用により@dfn{バインディングの分割(destructuring binding)}を処理することが可能になります。これはローカルバインディング(@ref{Local Variables}を参照)と似ていますが、互換性のあるオブジェクトから値を抽出することにより、変数の複数要素に値を与えることができます。"

#. type: Plain text
#: original_texis/control.texi:1208
msgid "The macros described in this section use @code{pcase} patterns to perform destructuring binding.  The condition of the object to be of compatible structure means that the object must match the pattern, because only then the object's subfields can be extracted.  For example:"
msgstr "このセクションで説明したマクロはバインディングを分割するために@code{pcase}パターンを使用しています。オブジェクト構造に互換性があるという条件は、そのオブジェクトがパターンにマッチしなければならないことを意味しています。なぜならマッチした場合のみオブジェクトのサブフィールドが抽出可能になるからです。たとえば:"

#. type: example
#: original_texis/control.texi:1212
#, no-wrap
msgid ""
"  (pcase-let ((`(add ,x ,y) my-list))\n"
"    (message \"Contains %S and %S\" x y))\n"
msgstr ""
"  (pcase-let ((`(add ,x ,y) my-list))\n"
"    (message \"Contains %S and %S\" x y))\n"

#. type: Plain text
#: original_texis/control.texi:1223
msgid "does the same as the previous example, except that it directly tries to extract @code{x} and @code{y} from @code{my-list} without first verifying if @code{my-list} is a list which has the right number of elements and has @code{add} as its first element.  The precise behavior when the object does not actually match the pattern is undefined, although the body will not be silently skipped: either an error is signaled or the body is run with some of the variables potentially bound to arbitrary values like @code{nil}."
msgstr "これは最初に@code{my-list}が正しい個数の要素をもつリストであり、かつ1つ目の要素が@code{add}か検証せずに、@code{my-list}から直接@code{x}と@code{y}の抽出を行う点を除いて前の例と同じことを行います。実際にオブジェクトがパターンにマッチしない場合には、たとえbodyが暗黙にスキップされることはないとしても、その振る舞いは未定義でありエラーがシグナルされるか、あるいはいくつかの変数が@code{nil}のような任意の値にバインドされた状況でbodyが実行されるかもしれません。"

#. type: Plain text
#: original_texis/control.texi:1227
msgid "The pcase patterns that are useful for destructuring bindings are generally those described in @ref{Backquote Patterns}, since they express a specification of the structure of objects that will match."
msgstr "バインディングの分割に有用なpcaseパターンとしては、マッチされるオブジェクト構造の仕様を表現する@ref{Backquote Patterns}で説明したパターンが一般的です。"

#. type: Plain text
#: original_texis/control.texi:1230
msgid "For an alternative facility for destructuring binding, see @ref{seq-let}."
msgstr "バインディングの分割にたいする代替え機能については@ref{seq-let}を参照してください。"

#. type: defmac
#: original_texis/control.texi:1231
#, no-wrap
msgid "pcase-let bindings body@dots{}"
msgstr "pcase-let bindings body@dots{}"

#. type: defmac
#: original_texis/control.texi:1234 original_texis/control.texi:1250
msgid "Perform destructuring binding of variables according to @var{bindings}, and then evaluate @var{body}."
msgstr "@var{bindings}に応じて変数のバインディング分割を行い、それから@var{body}を評価する。"

#. type: defmac
#: original_texis/control.texi:1238
msgid "@var{bindings} is a list of bindings of the form @w{@code{(@var{pattern} @var{exp})}}, where @var{exp} is an expression to evaluate and @var{pattern} is a @code{pcase} pattern."
msgstr "@var{bindings}は@w{@code{(@var{pattern} @var{exp})}}という形式のバインディングのリスト。ここで@var{exp}は評価する式、@var{pattern}は@code{pcase}パターン。"

#. type: defmac
#: original_texis/control.texi:1245
msgid "All @var{exp}s are evaluated first, after which they are matched against their respective @var{pattern}, introducing new variable bindings that can then be used inside @var{body}.  The variable bindings are produced by destructuring binding of elements of @var{pattern} to the values of the corresponding elements of the evaluated @var{exp}."
msgstr "@var{exp}はすべて最初に評価されて、その後で対応する@var{pattern}にマッチされて、@var{body}の内部で使用可能な変数バインディングが導入される。この変数バインディングは@var{pattern}の要素を、評価された@var{exp}の対応する要素の値に分割してのバインディングすることにより生成される。"

#. type: defmac
#: original_texis/control.texi:1247
#, no-wrap
msgid "pcase-let* bindings body@dots{}"
msgstr "pcase-let* bindings body@dots{}"

#. type: defmac
#: original_texis/control.texi:1256
msgid "@var{bindings} is a list of bindings of the form @code{(@var{pattern} @var{exp})}, where @var{exp} is an expression to evaluate and @var{pattern} is a @code{pcase} pattern.  The variable bindings are produced by destructuring binding of elements of @var{pattern} to the values of the corresponding elements of the evaluated @var{exp}."
msgstr "@var{bindings}は@code{(@var{pattern} @var{exp})}という形式のバインディングのリスト。ここで@var{exp}は評価する式、@var{pattern}は@code{pcase}パターン。この変数バインディングは@var{pattern}の要素を、評価された@var{exp}の対応する要素の値に分割してのバインディングすることにより生成される。"

#. type: defmac
#: original_texis/control.texi:1263
msgid "Unlike @code{pcase-let}, but similarly to @code{let*}, each @var{exp} is matched against its corresponding @var{pattern} before processing the next element of @var{bindings}, so the variable bindings introduced in each one of the @var{bindings} are available in the @var{exp}s of the @var{bindings} that follow it, additionally to being available in @var{body}."
msgstr "@code{pcase-let}とは異なり(しかし@code{let*}と同じように)、各@var{exp}は@var{bindings}の次要素の処理前に対応する@var{pattern}にたいしてマッチされるので、各@var{bindings}のいずれかによって導入される変数バインディングは@var{body}内で利用可能になるのに加えて、その後に続く@var{bindings}の@var{exp}内で利用可能になる。"

#. type: defmac
#: original_texis/control.texi:1265
#, no-wrap
msgid "pcase-dolist (pattern list) body@dots{}"
msgstr "pcase-dolist (pattern list) body@dots{}"

#. type: defmac
#: original_texis/control.texi:1272
msgid "Execute @var{body} once for each element of @var{list}, on each iteration performing a destructuring binding of variables in @var{pattern} to the values of the corresponding subfields of the element of @var{list}.  The bindings are performed as if by @code{pcase-let}.  When @var{pattern} is a simple variable, this ends up being equivalent to @code{dolist} (@pxref{Iteration})."
msgstr "繰り返しごとに@var{pattern}の変数を@var{list}の要素の対応するサブフィールドに分割バインディングしながら、@var{list}の各要素ごとに一度@var{body}を実行するこのバインディングは@code{pcase-let}の場合のように行われる。@var{pattern}が単なる変数なら@code{dolist}と等価(@ref{Iteration}を参照)。"

#. type: cindex
#: original_texis/control.texi:1277
#, no-wrap
msgid "iteration"
msgstr "iteration"

#. type: cindex
#: original_texis/control.texi:1278
#, no-wrap
msgid "recursion"
msgstr "recursion"

#. type: cindex
#: original_texis/control.texi:1279
#, no-wrap
msgid "forms, iteration"
msgstr "forms, iteration"

#. type: Plain text
#: original_texis/control.texi:1285
msgid "Iteration means executing part of a program repetitively.  For example, you might want to repeat some computation once for each element of a list, or once for each integer from 0 to @var{n}.  You can do this in Emacs Lisp with the special form @code{while}:"
msgstr "繰り返し(iteration)とは、プログラムの一部を繰り返し実行することを意味します。たとえばリストの各要素、または0から@var{n}の整数にたいして、繰り返し一度ずつ何らかの計算を行いたいとしましょう。Emacs Lispではスペシャルフォーム@code{while}でこれを行なうことができます:"

#. type: defspec
#: original_texis/control.texi:1286
#, no-wrap
msgid "while condition forms@dots{}"
msgstr "while condition forms@dots{}"

#. type: defspec
#: original_texis/control.texi:1292
msgid "@code{while} first evaluates @var{condition}.  If the result is non-@code{nil}, it evaluates @var{forms} in textual order.  Then it reevaluates @var{condition}, and if the result is non-@code{nil}, it evaluates @var{forms} again.  This process repeats until @var{condition} evaluates to @code{nil}."
msgstr "@code{while}は最初に@var{condition}を評価する。結果が非@code{nil}なら@var{forms}をテキスト順に評価する。その後に@var{condition}を再評価して結果が非@code{nil}なら、再度@var{forms}を評価する。この処理は@var{condition}が@code{nil}に評価されるまで繰り返される。"

#. type: defspec
#: original_texis/control.texi:1296
msgid "There is no limit on the number of iterations that may occur.  The loop will continue until either @var{condition} evaluates to @code{nil} or until an error or @code{throw} jumps out of it (@pxref{Nonlocal Exits})."
msgstr "繰り返し回数に制限はない。このループは@var{condition}が@code{nil}に評価されるか、エラーになるか、または@code{throw}で抜け出す(@ref{Nonlocal Exits}を参照)まで継続される。"

#. type: defspec
#: original_texis/control.texi:1298
msgid "The value of a @code{while} form is always @code{nil}."
msgstr "@code{while}フォームの値は常に@code{nil}である。"

#. type: group
#: original_texis/control.texi:1303
#, no-wrap
msgid ""
"(setq num 0)\n"
"     @result{} 0\n"
msgstr ""
"(setq num 0)\n"
"     @result{} 0\n"

#. type: group
#: original_texis/control.texi:1313
#, no-wrap
msgid ""
"(while (< num 4)\n"
"  (princ (format \"Iteration %d.\" num))\n"
"  (setq num (1+ num)))\n"
"     @print{} Iteration 0.\n"
"     @print{} Iteration 1.\n"
"     @print{} Iteration 2.\n"
"     @print{} Iteration 3.\n"
"     @result{} nil\n"
msgstr ""
"(while (< num 4)\n"
"  (princ (format \"Iteration %d.\" num))\n"
"  (setq num (1+ num)))\n"
"     @print{} Iteration 0.\n"
"     @print{} Iteration 1.\n"
"     @print{} Iteration 2.\n"
"     @print{} Iteration 3.\n"
"     @result{} nil\n"

#. type: defspec
#: original_texis/control.texi:1320
msgid "To write a repeat-until loop, which will execute something on each iteration and then do the end-test, put the body followed by the end-test in a @code{progn} as the first argument of @code{while}, as shown here:"
msgstr "各繰り返しごとに何かを実行して、その後も終了テストを行なうrepeat-untilループを記述するには、以下のように@code{while}の1番目の引数としてbodyの後に終了テストを記述して、それを@code{progn}の中に配置する:"

#. type: group
#: original_texis/control.texi:1326
#, no-wrap
msgid ""
"(while (progn\n"
"         (forward-line 1)\n"
"         (not (looking-at \"^$\"))))\n"
msgstr ""
"(while (progn\n"
"         (forward-line 1)\n"
"         (not (looking-at \"^$\"))))\n"

#. type: defspec
#: original_texis/control.texi:1333
msgid "This moves forward one line and continues moving by lines until it reaches an empty line.  It is peculiar in that the @code{while} has no body, just the end test (which also does the real work of moving point)."
msgstr "これは1行前方に移動して、空行に達するまで行単位の移動を継続する。独特な点は@code{while}がbodyをもたず、終了テスト(これはポイント移動という実処理も行なう)だけを行うことである。"

#. type: Plain text
#: original_texis/control.texi:1337
msgid "The @code{dolist} and @code{dotimes} macros provide convenient ways to write two common kinds of loops."
msgstr "マクロ@code{dolist}および@code{dotimes}は、2つの一般的な種類のループを記述する、便利な方法を提供します。"

#. type: defmac
#: original_texis/control.texi:1338
#, no-wrap
msgid "dolist (var list [result]) body@dots{}"
msgstr "dolist (var list [result]) body@dots{}"

#. type: defmac
#: original_texis/control.texi:1344
msgid "This construct executes @var{body} once for each element of @var{list}, binding the variable @var{var} locally to hold the current element.  Then it returns the value of evaluating @var{result}, or @code{nil} if @var{result} is omitted.  For example, here is how you could use @code{dolist} to define the @code{reverse} function:"
msgstr "この構文は@var{list}の各要素に一度@var{body}を実行して、カレント要素をローカルに保持するように、変数@var{var}にバインドする。その後に@var{result}を評価した値、@var{result}が省略された場合は@code{nil}をリターンする。たとえば以下は@code{reverse}関数を定義するために@code{dolist}を使用する方法の例である:"

#. type: example
#: original_texis/control.texi:1350
#, no-wrap
msgid ""
"(defun reverse (list)\n"
"  (let (value)\n"
"    (dolist (elt list value)\n"
"      (setq value (cons elt value)))))\n"
msgstr ""
"(defun reverse (list)\n"
"  (let (value)\n"
"    (dolist (elt list value)\n"
"      (setq value (cons elt value)))))\n"

#. type: defmac
#: original_texis/control.texi:1353
#, no-wrap
msgid "dotimes (var count [result]) body@dots{}"
msgstr "dotimes (var count [result]) body@dots{}"

#. type: defmac
#: original_texis/control.texi:1359
msgid "This construct executes @var{body} once for each integer from 0 (inclusive) to @var{count} (exclusive), binding the variable @var{var} to the integer for the current iteration.  Then it returns the value of evaluating @var{result}, or @code{nil} if @var{result} is omitted.  Here is an example of using @code{dotimes} to do something 100 times:"
msgstr "この構文は0以上@var{count}未満の各整数にたいして、一度@var{body}を実行してから、繰り返しのカレント回数となる整数を変数@var{var}にバインドする。その後に@var{result}の値、@var{result}が省略された場合は@code{nil}をリターンする。以下は@code{dotimes}を使用して、何らかの処理を100回行なう例である:"

#. type: example
#: original_texis/control.texi:1363
#, no-wrap
msgid ""
"(dotimes (i 100)\n"
"  (insert \"I will not obey absurd orders\\n\"))\n"
msgstr ""
"(dotimes (i 100)\n"
"  (insert \"I will not obey absurd orders\\n\"))\n"

#. type: cindex
#: original_texis/control.texi:1368
#, no-wrap
msgid "generators"
msgstr "generators"

#. type: Plain text
#: original_texis/control.texi:1373
msgid "A @dfn{generator} is a function that produces a potentially-infinite stream of values.  Each time the function produces a value, it suspends itself and waits for a caller to request the next value."
msgstr "@dfn{ジェネレーター(generator)}とは、潜在的に無限な値ストリームを生成する関数です。毎回その関数が値を生成するごとに、呼び出し側が次の値を要求するまで、自身をサスペンドします。"

#. type: defmac
#: original_texis/control.texi:1374
#, no-wrap
msgid "iter-defun name args [doc] [declare] [interactive] body@dots{}"
msgstr "iter-defun name args [doc] [declare] [interactive] body@dots{}"

#. type: defmac
#: original_texis/control.texi:1383
msgid "@code{iter-defun} defines a generator function.  A generator function has the same signature as a normal function, but works differently.  Instead of executing @var{body} when called, a generator function returns an iterator object.  That iterator runs @var{body} to generate values, emitting a value and pausing where @code{iter-yield} or @code{iter-yield-from} appears.  When @var{body} returns normally, @code{iter-next} signals @code{iter-end-of-sequence} with @var{body}'s result as its condition data."
msgstr "@code{iter-defun}はジェネレーター関数を定義する。ジェネレーター関数は通常の関数と同様のsignatureをもつが、異なるように機能する。ジェネレーター関数は呼び出し時に@var{body}を実行するのではなく、かわりにiteratorオブジェクトをリターンする。このiteratorは値を生成するために@var{body}を実行、値を発行すると@code{iter-yield}か@code{iter-yield-from}が出現するまで一時停止する。@var{body}が正常にリターンした際に、@code{iter-next}がコンディションデータとなる@var{body}の結果とともに、@code{iter-end-of-sequence}をシグナルする。"

#. type: defmac
#: original_texis/control.texi:1387
msgid "Any kind of Lisp code is valid inside @var{body}, but @code{iter-yield} and @code{iter-yield-from} cannot appear inside @code{unwind-protect} forms."
msgstr "@var{body}内部では任意の種類のLispコードが有効だが、@code{iter-yield}と@code{iter-yield-from}は@code{unwind-protect}フォームの内部にあってはならない。"

#. type: defmac
#: original_texis/control.texi:1390
#, no-wrap
msgid "iter-lambda args [doc] [interactive] body@dots{}"
msgstr "iter-lambda args [doc] [interactive] body@dots{}"

#. type: defmac
#: original_texis/control.texi:1393
msgid "@code{iter-lambda} produces an unnamed generator function that works just like a generator function produced with @code{iter-defun}."
msgstr "@code{iter-lambda}は@code{iter-defun}で生成されたジェネレーター関数と同様な、無名のジェネレーター関数を生成する。"

#. type: defmac
#: original_texis/control.texi:1395
#, no-wrap
msgid "iter-yield value"
msgstr "iter-yield value"

#. type: defmac
#: original_texis/control.texi:1400
msgid "When it appears inside a generator function, @code{iter-yield} indicates that the current iterator should pause and return @var{value} from @code{iter-next}.  @code{iter-yield} evaluates to the @code{value} parameter of next call to @code{iter-next}."
msgstr "@code{iter-yield}がジェネレーター関数内部で出現した際には、カレントiteratorが一時停止して@code{iter-next}から@var{value}をリターンすることを示す。@code{iter-yield}は、次回@code{iter-next}呼び出しの@code{value}パラメーターへと評価される。"

#. type: defmac
#: original_texis/control.texi:1402
#, no-wrap
msgid "iter-yield-from iterator"
msgstr "iter-yield-from iterator"

#. type: defmac
#: original_texis/control.texi:1407
msgid "@code{iter-yield-from} yields all the values that @var{iterator} produces and evaluates to the value that @var{iterator}'s generator function returns normally.  While it has control, @var{iterator} receives values sent to the iterator using @code{iter-next}."
msgstr "@code{iter-yield-from}は@var{iterator}が生成するすべての値を生成して、その@var{iterator}のジェネレーター関数が通常リターンする値へと評価される。これが制御を得ている間、@var{iterator}は@code{iter-next}を使用して送信された値を受け取る。"

#. type: Plain text
#: original_texis/control.texi:1415
msgid "To use a generator function, first call it normally, producing a @dfn{iterator} object.  An iterator is a specific instance of a generator.  Then use @code{iter-next} to retrieve values from this iterator.  When there are no more values to pull from an iterator, @code{iter-next} raises an @code{iter-end-of-sequence} condition with the iterator's final value."
msgstr "ジェネレーター関数を使用するには、まずそれを普通に呼び出して@dfn{iterator}オブジェクトを生成します。iteratorはジェネレーターの固有のインスタンスです。その後でこのiteratorから値を取得するために@code{iter-next}を使用します。iteratorから取得する値がなくなると、@code{iter-next}はそのiteratorの最終値とともに@code{iter-end-of-sequence}のコンディションをraisesします。"

#. type: Plain text
#: original_texis/control.texi:1422
msgid "It's important to note that generator function bodies only execute inside calls to @code{iter-next}.  A call to a function defined with @code{iter-defun} produces an iterator; you must drive this iterator with @code{iter-next} for anything interesting to happen.  Each call to a generator function produces a @emph{different} iterator, each with its own state."
msgstr "ジェネレーター関数のbodyは、@code{iter-next}の呼び出しの内側でのみ実行されることに注意することが重要です。@code{iter-defun}で定義された関数の呼び出しはiteratorを生成します。何か興味があることが発生したら、@code{iter-next}でこのiteratorを制御しなければなりません。ジェネレーター関数の個々の呼び出しは、それぞれが独自に状態をもつ@emph{別個}のiteratorを生成します。"

#. type: defun
#: original_texis/control.texi:1423
#, no-wrap
msgid "iter-next iterator value"
msgstr "iter-next iterator value"

#. type: defun
#: original_texis/control.texi:1429
msgid "Retrieve the next value from @var{iterator}.  If there are no more values to be generated (because @var{iterator}'s generator function returned), @code{iter-next} signals the @code{iter-end-of-sequence} condition; the data value associated with this condition is the value with which @var{iterator}'s generator function returned."
msgstr "@var{iterator}から次の値を取得する。(@var{iterator}のジェネレーター関数がリターンしていて)生成される値が存在しない場合、@code{iter-next}はコンディション@code{iter-end-of-sequence}をシグナルする。このコンディションに関連付けられるデータ値は、@var{iterator}のジェネレーター関数がリターンした値である。"

#. type: defun
#: original_texis/control.texi:1435
msgid "@var{value} is sent into the iterator and becomes the value to which @code{iter-yield} evaluates.  @var{value} is ignored for the first @code{iter-next} call to a given iterator, since at the start of @var{iterator}'s generator function, the generator function is not evaluating any @code{iter-yield} form."
msgstr "@var{value}はiteratorに送信されて、@code{iter-yield}を評価した値になる。@var{iterator}のジェネレーター関数の開始時には、ジェネレーター関数は@code{iter-yield}フォームを何も評価していないので、与えられたiteratorにたいする最初の@code{iter-next}呼び出しでは@var{value}は無視される。"

#. type: defun
#: original_texis/control.texi:1437
#, no-wrap
msgid "iter-close iterator"
msgstr "iter-close iterator"

#. type: defun
#: original_texis/control.texi:1444
msgid "If @var{iterator} is suspended inside an @code{unwind-protect}'s @code{bodyform} and becomes unreachable, Emacs will eventually run unwind handlers after a garbage collection pass.  (Note that @code{iter-yield} is illegal inside an @code{unwind-protect}'s @code{unwindforms}.)  To ensure that these handlers are run before then, use @code{iter-close}."
msgstr "@var{iterator}が@code{unwind-protect}の@code{bodyform}フォーム内でサスペンドされていたら、ガーベージコレクション処理後にEmacsが最終的にunwindハンドラーを実行する(@code{unwind-protect}の@code{unwindforms}内部では@code{iter-yield}は不当であることに注意)。その前に確実にこれらのハンドラーを実行するには、@code{iter-close}を使用すること。"

#. type: Plain text
#: original_texis/control.texi:1448
msgid "Some convenience functions are provided to make working with iterators easier:"
msgstr "iteratorを簡単に連携できるように、便利な関数がいくつか提供されています:"

#. type: defmac
#: original_texis/control.texi:1449
#, no-wrap
msgid "iter-do (var iterator) body @dots{}"
msgstr "iter-do (var iterator) body @dots{}"

#. type: defmac
#: original_texis/control.texi:1452
msgid "Run @var{body} with @var{var} bound to each value that @var{iterator} produces."
msgstr "@var{iterator}が生成する各値を@var{var}にバインドしつつ@var{body}を実行する。"

#. type: Plain text
#: original_texis/control.texi:1456
msgid "The Common Lisp loop facility also contains features for working with iterators.  See @xref{Loop Facility,,,cl,Common Lisp Extensions}."
msgstr "Common Lispのループ機能にもiteratorと連携する機能が含まれます。@ref{Loop Facility,,,cl,Common Lisp Extensions}を参照してください。"

#. type: Plain text
#: original_texis/control.texi:1459
msgid "The following piece of code demonstrates some important principles of working with iterators."
msgstr "以下のコード片はiteratorとの連携における重要な原則を示すものです。"

#. type: example
#: original_texis/control.texi:1466
#, no-wrap
msgid ""
"(require 'generator)\n"
"(iter-defun my-iter (x)\n"
"  (iter-yield (1+ (iter-yield (1+ x))))\n"
"   ;; Return normally\n"
"  -1)\n"
"\n"
msgstr ""
"(require 'generator)\n"
"(iter-defun my-iter (x)\n"
"  (iter-yield (1+ (iter-yield (1+ x))))\n"
"   ;; 普通にリターンする\n"
"  -1)\n"
"\n"

#. type: example
#: original_texis/control.texi:1475
#, no-wrap
msgid ""
"(let* ((iter (my-iter 5))\n"
"       (iter2 (my-iter 0)))\n"
"  ;; Prints 6\n"
"  (print (iter-next iter))\n"
"  ;; Prints 9\n"
"  (print (iter-next iter 8))\n"
"  ;; Prints 1; iter and iter2 have distinct states\n"
"  (print (iter-next iter2 nil))\n"
"\n"
msgstr ""
"(let* ((iter (my-iter 5))\n"
"       (iter2 (my-iter 0)))\n"
"  ;; 6をプリント\n"
"  (print (iter-next iter))\n"
"  ;; 9をプリント\n"
"  (print (iter-next iter 8))\n"
"  ;; 1をプリント\n"
"  ;; iterとiterは異なる状態をもつ\n"
"  (print (iter-next iter2 nil))\n"
"\n"

#. type: example
#: original_texis/control.texi:1482
#, no-wrap
msgid ""
"  ;; We expect the iter sequence to end now\n"
"  (condition-case x\n"
"      (iter-next iter)\n"
"    (iter-end-of-sequence\n"
"      ;; Prints -1, which my-iter returned normally\n"
"      (print (cdr x)))))\n"
msgstr ""
"  ;; ここでiterシーケンスの終了を待機\n"
"  (condition-case x\n"
"      (iter-next iter)\n"
"    (iter-end-of-sequence\n"
"      ;; my-iterが通常の方法でリターンした-1をプリント\n"
"      (print (cdr x)))))\n"

#. type: cindex
#: original_texis/control.texi:1486
#, no-wrap
msgid "nonlocal exits"
msgstr "nonlocal exits"

#. type: Plain text
#: original_texis/control.texi:1493
msgid "A @dfn{nonlocal exit} is a transfer of control from one point in a program to another remote point.  Nonlocal exits can occur in Emacs Lisp as a result of errors; you can also use them under explicit control.  Nonlocal exits unbind all variable bindings made by the constructs being exited."
msgstr "@dfn{非ローカル脱出(nonlocal exit)}とは、プログラム内のある位置から別の離れた位置へ制御を移します。Emacs Lispではエラーの結果として非ローカル脱出が発生することがあります。明示的な制御の下で非ローカル脱出を使用することもできます。非ローカル脱出は脱出しようとしている構文により作成された、すべての変数バインディングのバインドを解消します。"

#. type: node
#: original_texis/control.texi:1499 original_texis/control.texi:1501
#, no-wrap
msgid "Catch and Throw"
msgstr "Catch and Throw"

#. type: menuentry
#: original_texis/control.texi:1499
msgid "Nonlocal exits for the program's own purposes."
msgstr "プログラム自身の目的による非ローカル脱出。"

#. type: node
#: original_texis/control.texi:1499 original_texis/control.texi:1601
#, no-wrap
msgid "Examples of Catch"
msgstr "Examples of Catch"

#. type: menuentry
#: original_texis/control.texi:1499
msgid "Showing how such nonlocal exits can be written."
msgstr "このような非ローカル脱出が記述される方法。"

#. type: subsection
#: original_texis/control.texi:1499 original_texis/control.texi:1676
#: original_texis/control.texi:1677
#, no-wrap
msgid "Errors"
msgstr "Errors"

#. type: menuentry
#: original_texis/control.texi:1499
msgid "How errors are signaled and handled."
msgstr "エラーのシグナルと処理される方法。"

#. type: node
#: original_texis/control.texi:1499 original_texis/control.texi:2241
#, no-wrap
msgid "Cleanups"
msgstr "Cleanups"

#. type: menuentry
#: original_texis/control.texi:1499
msgid "Arranging to run a cleanup form if an error happens."
msgstr "エラーが発生した場合のクリーンアップフォーム実行のアレンジ。"

#. type: subsection
#: original_texis/control.texi:1502
#, no-wrap
msgid "Explicit Nonlocal Exits: @code{catch} and @code{throw}"
msgstr "Explicit Nonlocal Exits: @code{catch} and @code{throw}"

#. type: cindex
#: original_texis/control.texi:1503
#, no-wrap
msgid "forms for nonlocal exits"
msgstr "forms for nonlocal exits"

#. type: Plain text
#: original_texis/control.texi:1511
msgid "Most control constructs affect only the flow of control within the construct itself.  The function @code{throw} is the exception to this rule of normal program execution: it performs a nonlocal exit on request.  (There are other exceptions, but they are for error handling only.)  @code{throw} is used inside a @code{catch}, and jumps back to that @code{catch}.  For example:"
msgstr "ほとんどの制御構造は、その構文自身の内部の制御フローだけに影響します。関数@code{throw}は、この通常のプログラム実行でのルールの例外です。これはリクエストにより非ローカル脱出を行ないます(他にも例外はあるがそれらはエラー処理用のものだけ)。@code{throw}は@code{catch}の内部で使用され、@code{catch}に制御を戻します。たとえば:"

#. type: group
#: original_texis/control.texi:1517
#, no-wrap
msgid ""
"(defun foo-outer ()\n"
"  (catch 'foo\n"
"    (foo-inner)))\n"
"\n"
msgstr ""
"(defun foo-outer ()\n"
"  (catch 'foo\n"
"    (foo-inner)))\n"
"\n"

#. type: group
#: original_texis/control.texi:1523
#, no-wrap
msgid ""
"(defun foo-inner ()\n"
"  @dots{}\n"
"  (if x\n"
"      (throw 'foo t))\n"
"  @dots{})\n"
msgstr ""
"(defun foo-inner ()\n"
"  @dots{}\n"
"  (if x\n"
"      (throw 'foo t))\n"
"  @dots{})\n"

#. type: Plain text
#: original_texis/control.texi:1531
msgid "The @code{throw} form, if executed, transfers control straight back to the corresponding @code{catch}, which returns immediately.  The code following the @code{throw} is not executed.  The second argument of @code{throw} is used as the return value of the @code{catch}."
msgstr "@code{throw}フォームが実行されると、対応する@code{catch}に制御を移して、@code{catch}は即座にリターンします。@code{throw}の後のコードは実行されません。@code{throw}の2番目の引数は@code{catch}のリターン値として使用されます。"

#. type: Plain text
#: original_texis/control.texi:1540
msgid "The function @code{throw} finds the matching @code{catch} based on the first argument: it searches for a @code{catch} whose first argument is @code{eq} to the one specified in the @code{throw}.  If there is more than one applicable @code{catch}, the innermost one takes precedence.  Thus, in the above example, the @code{throw} specifies @code{foo}, and the @code{catch} in @code{foo-outer} specifies the same symbol, so that @code{catch} is the applicable one (assuming there is no other matching @code{catch} in between)."
msgstr "関数@code{throw}は1番目の引数にもとづいて、それにマッチする@code{catch}を探します。@code{throw}は1番目の引数が、@code{throw}で指定されたものと@code{eq}であるような@code{catch}を検索します。複数の該当する@code{catch}がある場合には、最内のものが優先されます。したがって上記の例では@code{throw}が@code{foo}を指定していて、@code{foo-outer}内の@code{catch}が同じシンボルを指定しているので、(この間に他のマッチする@code{catch}は存在しないと仮定するなら)その@code{catch}が該当します。"

#. type: Plain text
#: original_texis/control.texi:1550
msgid "Executing @code{throw} exits all Lisp constructs up to the matching @code{catch}, including function calls.  When binding constructs such as @code{let} or function calls are exited in this way, the bindings are unbound, just as they are when these constructs exit normally (@pxref{Local Variables}).  Likewise, @code{throw} restores the buffer and position saved by @code{save-excursion} (@pxref{Excursions}), and the narrowing status saved by @code{save-restriction}.  It also runs any cleanups established with the @code{unwind-protect} special form when it exits that form (@pxref{Cleanups})."
msgstr "@code{throw}の実行により、マッチする@code{catch}までのすべてのLisp構文(関数呼び出しを含む)を脱出します。この方法により@code{let}や関数呼び出しのようなバインディング構文を脱出する場合には、これらの構文を正常にexitしたときのように、そのバインディングは解消されます(@ref{Local Variables}を参照)。同様に@code{throw}は@code{save-excursion}(@ref{Excursions}を参照)によって保存されたバッファーと位置を復元します。@code{throw}がスペシャルフォーム@code{unwind-protect}を脱出した場合には、@code{unwind-protect}により設定されたいくつかのクリーンアップも実行されます。"

#. type: Plain text
#: original_texis/control.texi:1558
msgid "The @code{throw} need not appear lexically within the @code{catch} that it jumps to.  It can equally well be called from another function called within the @code{catch}.  As long as the @code{throw} takes place chronologically after entry to the @code{catch}, and chronologically before exit from it, it has access to that @code{catch}.  This is why @code{throw} can be used in commands such as @code{exit-recursive-edit} that throw back to the editor command loop (@pxref{Recursive Editing})."
msgstr "ジャンプ先となる@code{catch}内にレキシカル(局所的)である必要はありません。@code{throw}は@code{catch}内で呼び出された別の関数から、同じようにに呼び出すことができます。@code{throw}が行なわれたのが、時系列的に@code{catch}に入った後で、かつexitする前である限り、その@code{throw}は@code{catch}にアクセスできます。エディターのコマンドループから戻る@code{exit-recursive-edit}のようなコマンドで、@code{throw}が使用されるのはこれが理由です。"

#. type: cindex
#: original_texis/control.texi:1559
#, no-wrap
msgid "CL note---only @code{throw} in Emacs"
msgstr "CL note---only @code{throw} in Emacs"

#. type: quotation
#: original_texis/control.texi:1566
msgid "@b{Common Lisp note:} Most other versions of Lisp, including Common Lisp, have several ways of transferring control nonsequentially: @code{return}, @code{return-from}, and @code{go}, for example.  Emacs Lisp has only @code{throw}.  The @file{cl-lib} library provides versions of some of these.  @xref{Blocks and Exits,,,cl,Common Lisp Extensions}."
msgstr "@b{Common Lispに関する注意: }Common Lispを含む、他のほとんどのバージョンのLispは非シーケンシャルに制御を移すいくつかの方法 --- たとえば@code{return}、@code{return-from}、@code{go} --- をもつ。Emacs Lispは@code{throw}のみ。@file{cl-lib}ライブラリーはこれらのうちいくつかを提供する。@ref{Blocks and Exits,,,cl,Common Lisp Extensions}を参照のこと。"

#. type: defspec
#: original_texis/control.texi:1568
#, no-wrap
msgid "catch tag body@dots{}"
msgstr "catch tag body@dots{}"

#. type: cindex
#: original_texis/control.texi:1569
#, no-wrap
msgid "tag on run time stack"
msgstr "tag on run time stack"

#. type: defspec
#: original_texis/control.texi:1574
msgid "@code{catch} establishes a return point for the @code{throw} function.  The return point is distinguished from other such return points by @var{tag}, which may be any Lisp object except @code{nil}.  The argument @var{tag} is evaluated normally before the return point is established."
msgstr "@code{catch}は@code{throw}関数にたいするリターン位置を確立する。リターン位置は@var{tag}により、この種の他のリターン位置と区別される。@var{tag}は@code{nil}以外の任意のLispオブジェクト。リターン位置が確立される前に、引数@var{tag}は通常どおり評価される。"

#. type: defspec
#: original_texis/control.texi:1579
msgid "With the return point in effect, @code{catch} evaluates the forms of the @var{body} in textual order.  If the forms execute normally (without error or nonlocal exit) the value of the last body form is returned from the @code{catch}."
msgstr "リターン位置が効果をもつことにより、@code{catch}は@var{body}のフォームをテキスト順に評価する。フォームが(エラーや非ローカル脱出なしで)通常に実行されたなら、bodyの最後のフォームの値が@code{catch}からリターンされる。"

#. type: defspec
#: original_texis/control.texi:1584
msgid "If a @code{throw} is executed during the execution of @var{body}, specifying the same value @var{tag}, the @code{catch} form exits immediately; the value it returns is whatever was specified as the second argument of @code{throw}."
msgstr "@var{body}の実行の間に@code{throw}が実行された場合、@var{tag}と同じ値を指定すると@code{catch}フォームは即座にexitする。リターンされる値は、それが何であれ@code{throw}の2番目の引数に指定された値である。"

#. type: defun
#: original_texis/control.texi:1586
#, no-wrap
msgid "throw tag value"
msgstr "throw tag value"

#. type: defun
#: original_texis/control.texi:1592
msgid "The purpose of @code{throw} is to return from a return point previously established with @code{catch}.  The argument @var{tag} is used to choose among the various existing return points; it must be @code{eq} to the value specified in the @code{catch}.  If multiple return points match @var{tag}, the innermost one is used."
msgstr "@code{throw}の目的は、以前に@code{catch}により確立されたリターン位置に戻ることである。引数@var{tag}は、既存のさまざまなリターン位置からリターン位置を選択するために使用される。複数のリターン位置が@var{tag}にマッチしたら、最内のものが使用される。"

#. type: defun
#: original_texis/control.texi:1595
msgid "The argument @var{value} is used as the value to return from that @code{catch}."
msgstr "引数@var{value}は@code{catch}からリターンされる値として使用される。"

#. type: kindex
#: original_texis/control.texi:1596
#, no-wrap
msgid "no-catch"
msgstr "no-catch"

#. type: defun
#: original_texis/control.texi:1599
msgid "If no return point is in effect with tag @var{tag}, then a @code{no-catch} error is signaled with data @code{(@var{tag} @var{value})}."
msgstr "タグ@var{tag}のリターン位置が存在しなければ、データ@code{(@var{tag} @var{value})}とともに@code{no-catch}エラーがシグナルされます。"

#. type: subsection
#: original_texis/control.texi:1602
#, no-wrap
msgid "Examples of @code{catch} and @code{throw}"
msgstr "Examples of @code{catch} and @code{throw}"

#. type: Plain text
#: original_texis/control.texi:1608
msgid "One way to use @code{catch} and @code{throw} is to exit from a doubly nested loop.  (In most languages, this would be done with a @code{goto}.)  Here we compute @code{(foo @var{i} @var{j})} for @var{i} and @var{j} varying from 0 to 9:"
msgstr "2重にネストされたループから脱出する1つの方法は、@code{catch}と@code{throw}を使うことです(これはほとんどの言語では@code{goto}により行なわれるだろう)。ここでは@var{i}と@var{j}を0から9に変化させて、@code{(foo @var{i} @var{j})}を計算します:"

#. type: group
#: original_texis/control.texi:1621
#, no-wrap
msgid ""
"(defun search-foo ()\n"
"  (catch 'loop\n"
"    (let ((i 0))\n"
"      (while (< i 10)\n"
"        (let ((j 0))\n"
"          (while (< j 10)\n"
"            (if (foo i j)\n"
"                (throw 'loop (list i j)))\n"
"            (setq j (1+ j))))\n"
"        (setq i (1+ i))))))\n"
msgstr ""
"(defun search-foo ()\n"
"  (catch 'loop\n"
"    (let ((i 0))\n"
"      (while (< i 10)\n"
"        (let ((j 0))\n"
"          (while (< j 10)\n"
"            (if (foo i j)\n"
"                (throw 'loop (list i j)))\n"
"            (setq j (1+ j))))\n"
"        (setq i (1+ i))))))\n"

#. type: Plain text
#: original_texis/control.texi:1629
msgid "If @code{foo} ever returns non-@code{nil}, we stop immediately and return a list of @var{i} and @var{j}.  If @code{foo} always returns @code{nil}, the @code{catch} returns normally, and the value is @code{nil}, since that is the result of the @code{while}."
msgstr "@code{foo}が非@code{nil}をリターンしたら即座に処理を中止して、@var{i}と@var{j}のリストをリターンしています。@code{foo}が常に@code{nil}をリターンする場合には、@code{catch}は通常どおりリターンして、その値は@code{while}の結果である@code{nil}となります。"

#. type: Plain text
#: original_texis/control.texi:1633
msgid "Here are two tricky examples, slightly different, showing two return points at once.  First, two return points with the same tag, @code{hack}:"
msgstr "以下では2つのリターン位置を一度に表す、微妙に異なるトリッキーな例を2つ示します。まず同じタグ@code{hack}にたいして2つのリターン位置があります:"

#. type: group
#: original_texis/control.texi:1640
#, no-wrap
msgid ""
"(defun catch2 (tag)\n"
"  (catch tag\n"
"    (throw 'hack 'yes)))\n"
"@result{} catch2\n"
msgstr ""
"(defun catch2 (tag)\n"
"  (catch tag\n"
"    (throw 'hack 'yes)))\n"
"@result{} catch2\n"

#. type: group
#: original_texis/control.texi:1648
#, no-wrap
msgid ""
"(catch 'hack\n"
"  (print (catch2 'hack))\n"
"  'no)\n"
"@print{} yes\n"
"@result{} no\n"
msgstr ""
"(catch 'hack\n"
"  (print (catch2 'hack))\n"
"  'no)\n"
"@print{} yes\n"
"@result{} no\n"

#. type: Plain text
#: original_texis/control.texi:1657
msgid "Since both return points have tags that match the @code{throw}, it goes to the inner one, the one established in @code{catch2}.  Therefore, @code{catch2} returns normally with value @code{yes}, and this value is printed.  Finally the second body form in the outer @code{catch}, which is @code{'no}, is evaluated and returned from the outer @code{catch}."
msgstr "どちらのリターン位置も@code{throw}にマッチするタグをもつので内側のもの、つまり@code{catch2}で確立されたcatchへgotoします。したがって@code{catch2}は通常どおり値@code{yes}をリターンして、その値がプリントされます。最後に外側の@code{catch}の2番目のbody、つまり@code{'no}が評価されて外側の@code{catch}からそれがリターンされます。"

#. type: Plain text
#: original_texis/control.texi:1659
msgid "Now let's change the argument given to @code{catch2}:"
msgstr "ここで@code{catch2}に与える引数を変更してみましょう:"

#. type: group
#: original_texis/control.texi:1666
#, no-wrap
msgid ""
"(catch 'hack\n"
"  (print (catch2 'quux))\n"
"  'no)\n"
"@result{} yes\n"
msgstr ""
"(catch 'hack\n"
"  (print (catch2 'quux))\n"
"  'no)\n"
"@result{} yes\n"

#. type: Plain text
#: original_texis/control.texi:1675
msgid "We still have two return points, but this time only the outer one has the tag @code{hack}; the inner one has the tag @code{quux} instead.  Therefore, @code{throw} makes the outer @code{catch} return the value @code{yes}.  The function @code{print} is never called, and the body-form @code{'no} is never evaluated."
msgstr "この場合も2つのリターン位置がありますが、今回は外側だけがタグ@code{hack}で、内側はかわりにタグ@code{quux}をもちます。したがって@code{throw}により、外側の@code{catch}が値@code{yes}をリターンします。関数@code{print}が呼び出されることはなくbodyのフォーム@code{'no}も決して評価されません。"

#. type: cindex
#: original_texis/control.texi:1678
#, no-wrap
msgid "errors"
msgstr "errors"

#. type: Plain text
#: original_texis/control.texi:1682
msgid "When Emacs Lisp attempts to evaluate a form that, for some reason, cannot be evaluated, it @dfn{signals} an @dfn{error}."
msgstr "Emacs Lispが何らかの理由で評価できないようなフォームの評価を試みると、@dfn{エラー(error)}が@dfn{シグナル(signal)}されます。"

#. type: Plain text
#: original_texis/control.texi:1687
msgid "When an error is signaled, Emacs's default reaction is to print an error message and terminate execution of the current command.  This is the right thing to do in most cases, such as if you type @kbd{C-f} at the end of the buffer."
msgstr "エラーがシグナルされるとエラーメッセージを表示して、カレントコマンドの実行を終了するのがEmacsデフォルトの反応です。たとえばバッファーの最後で@kbd{C-f}とタイプしたときのように、ほとんどの場合にはこれは正しい反応になります。"

#. type: Plain text
#: original_texis/control.texi:1697
msgid "In complicated programs, simple termination may not be what you want.  For example, the program may have made temporary changes in data structures, or created temporary buffers that should be deleted before the program is finished.  In such cases, you would use @code{unwind-protect} to establish @dfn{cleanup expressions} to be evaluated in case of error.  (@xref{Cleanups}.)  Occasionally, you may wish the program to continue execution despite an error in a subroutine.  In these cases, you would use @code{condition-case} to establish @dfn{error handlers} to recover control in case of error."
msgstr "複雑なプログラムでは単なる終了が望ましくない場合もあるでしょう。たとえばそのプログラムがータ構造に一時的に変更を行なっていたり、プログラム終了前に削除する必要がある一時バッファーを作成しているかもしれません。このような場合には、エラー時に評価される@dfn{クリーンアップ式(cleanup expressions)}を設定するために、@code{unwind-protect}を使用するでしょう(@ref{Cleanups}を参照)。サブルーチン内のエラーにもかかわらずに、プログラムの実行を継続したいときがあるかもしれません。このような場合には、エラー時のリカバリーを制御する@dfn{エラーハンドラー(error handlers)}を設定するために@code{condition-case}を使用するでしょう。"

#. type: Plain text
#: original_texis/control.texi:1701
msgid "Resist the temptation to use error handling to transfer control from one part of the program to another; use @code{catch} and @code{throw} instead.  @xref{Catch and Throw}."
msgstr "エラーハンドラーを使用せずにプログラムの一部から別の部分へ制御を移すためには、@code{catch}と@code{throw}を使用します。@ref{Catch and Throw}を参照してください。"

#. type: node
#: original_texis/control.texi:1707 original_texis/control.texi:1709
#, no-wrap
msgid "Signaling Errors"
msgstr "Signaling Errors"

#. type: menuentry
#: original_texis/control.texi:1707
msgid "How to report an error."
msgstr "エラーを報告する方法。"

#. type: node
#: original_texis/control.texi:1707 original_texis/control.texi:1834
#, no-wrap
msgid "Processing of Errors"
msgstr "Processing of Errors"

#. type: menuentry
#: original_texis/control.texi:1707
msgid "What Emacs does when you report an error."
msgstr "エラーを報告するときEmacsが何を行なうか。"

#. type: node
#: original_texis/control.texi:1707 original_texis/control.texi:1871
#, no-wrap
msgid "Handling Errors"
msgstr "Handling Errors"

#. type: menuentry
#: original_texis/control.texi:1707
msgid "How you can trap errors and continue execution."
msgstr "エラーをトラップして実行を継続する方法。"

#. type: node
#: original_texis/control.texi:1707 original_texis/control.texi:2143
#, no-wrap
msgid "Error Symbols"
msgstr "Error Symbols"

#. type: menuentry
#: original_texis/control.texi:1707
msgid "How errors are classified for trapping them."
msgstr "エラートラプのためにエラーをクラス分けする方法。"

#. type: subsubsection
#: original_texis/control.texi:1710
#, no-wrap
msgid "How to Signal an Error"
msgstr "How to Signal an Error"

#. type: cindex
#: original_texis/control.texi:1711
#, no-wrap
msgid "signaling errors"
msgstr "signaling errors"

#. type: Plain text
#: original_texis/control.texi:1718
msgid "@dfn{Signaling} an error means beginning error processing.  Error processing normally aborts all or part of the running program and returns to a point that is set up to handle the error (@pxref{Processing of Errors}).  Here we describe how to signal an error."
msgstr "エラーの@dfn{シグナリング(signaling)}とは、エラーの処理を開始することを意味します。エラー処理は通常は実行中のプログラムのすべて、または一部をアボート(abort)してエラーをハンドルするためにセットアップされた位置にリターンします。ここではエラーをシグナルする方法を記述します。"

#. type: Plain text
#: original_texis/control.texi:1724
msgid "Most errors are signaled automatically within Lisp primitives which you call for other purposes, such as if you try to take the @sc{car} of an integer or move forward a character at the end of the buffer.  You can also signal errors explicitly with the functions @code{error} and @code{signal}."
msgstr "ほとんどのエラーは、たとえば整数にたいして@sc{car}の取得を試みたり、バッファーの最後で1文字前方に移動したときなどのように、他の目的のために呼び出したLispプリミティブ関数の中で自動的にシグナルされます。関数@code{error}と@code{signal}で明示的にエラーをシグナルすることもできます。"

#. type: Plain text
#: original_texis/control.texi:1728
msgid "Quitting, which happens when the user types @kbd{C-g}, is not considered an error, but it is handled almost like an error.  @xref{Quitting}."
msgstr "ユーザーが@kbd{C-g}をタイプしたときに発生するquitはエラーとは判断されませんが、ほとんどはエラーと同様に扱われます。@ref{Quitting}を参照してください。"

#. type: Plain text
#: original_texis/control.texi:1734
msgid "Every error specifies an error message, one way or another.  The message should state what is wrong (``File does not exist''), not how things ought to be (``File must exist'').  The convention in Emacs Lisp is that error messages should start with a capital letter, but should not end with any sort of punctuation."
msgstr "すべてのエラーメッセージはそれぞれ、何らかのエラーメッセージを指定します。そのメッセージは何が悪いのか(``File does not exist'')、物事がどうしてそうあるべきではない(``File must exist'')かを示すべきです。Emacs Lispの慣習ではエラーメッセージは大文字で開始され、区切り文字で終わるべきではありません。"

#. type: defun
#: original_texis/control.texi:1735
#, no-wrap
msgid "error format-string &rest args"
msgstr "error format-string &rest args"

#. type: defun
#: original_texis/control.texi:1739
msgid "This function signals an error with an error message constructed by applying @code{format-message} (@pxref{Formatting Strings}) to @var{format-string} and @var{args}."
msgstr "この関数は@var{format-string}と@var{args}にたいして、@code{format-message} (@ref{Formatting Strings}を参照)を適用して構築されたエラーメッセージとともに、エラーをシグナルする。"

#. type: defun
#: original_texis/control.texi:1741
msgid "These examples show typical uses of @code{error}:"
msgstr "以下は@code{error}を使用する典型的な例である:"

#. type: group
#: original_texis/control.texi:1746
#, no-wrap
msgid ""
"(error \"That is an error -- try something else\")\n"
"     @error{} That is an error -- try something else\n"
msgstr ""
"(error \"That is an error -- try something else\")\n"
"     @error{} That is an error -- try something else\n"

#. type: group
#: original_texis/control.texi:1751
#, no-wrap
msgid ""
"(error \"Invalid name `%s'\" \"A%%B\")\n"
"     @error{} Invalid name ‘A%%B’\n"
msgstr ""
"(error \"Invalid name `%s'\" \"A%%B\")\n"
"     @error{} Invalid name ‘A%%B’\n"

#. type: defun
#: original_texis/control.texi:1757
msgid "@code{error} works by calling @code{signal} with two arguments: the error symbol @code{error}, and a list containing the string returned by @code{format-message}."
msgstr "2つの引数 --- エラーシンボル@code{error}と@code{format-message}がリターンするる文字列を含むリスト --- で@code{signal}を呼び出すことにより@code{error}は機能する。"

#. type: defun
#: original_texis/control.texi:1762
msgid "Typically grave accent and apostrophe in the format translate to matching curved quotes, e.g., @t{\"Missing `%s'\"} might result in @t{\"Missing ‘foo’\"}.  @xref{Text Quoting Style}, for how to influence or inhibit this translation."
msgstr "@t{\"Missing `%s'\"}が@t{\"Missing ‘foo’\"}となるように、通常はフォーマット内のgrave accentとapostropheはマッチするcurved quotesに変換される。この変換の効果や抑制については@ref{Text Quoting Style}を参照のこと。"

#. type: defun
#: original_texis/control.texi:1768
msgid "@strong{Warning:} If you want to use your own string as an error message verbatim, don't just write @code{(error @var{string})}.  If @var{string} @var{string} contains @samp{%}, @samp{`}, or @samp{'} it may be reformatted, with undesirable results.  Instead, use @code{(error \"%s\" @var{string})}."
msgstr "@strong{警告: }エラーメッセージとして固定の文字列を使用したい場合、単に@code{(error @var{string})}とは記述しないこと。もし@var{string}が@samp{%}、@samp{`}、@samp{'}を含んでいると、再フォーマットされて望む結果は得られないだろう。かわりに、@code{(error \"%s\" @var{string})}を使用すること。"

#. type: defun
#: original_texis/control.texi:1770
#, no-wrap
msgid "signal error-symbol data"
msgstr "signal error-symbol data"

#. type: anchor{#1}
#: original_texis/control.texi:1775
msgid "Definition of signal"
msgstr "Definition of signal"

#. type: defun
#: original_texis/control.texi:1775
msgid "This function signals an error named by @var{error-symbol}.  The argument @var{data} is a list of additional Lisp objects relevant to the circumstances of the error."
msgstr "この関数は@var{error-symbol}で命名されるエラーをシグナルする。引数@var{data}はエラー状況に関連する追加のLispオブジェクトのリスト。"

#. type: defun
#: original_texis/control.texi:1780
msgid "The argument @var{error-symbol} must be an @dfn{error symbol}---a symbol defined with @code{define-error}.  This is how Emacs Lisp classifies different sorts of errors.  @xref{Error Symbols}, for a description of error symbols, error conditions and condition names."
msgstr "引数@var{error-symbol}は@dfn{エラーシンボル(error symbol)} --- @code{define-error}で定義されたシンボル --- でなければならない。これはEmacs Lispが異なる種類のエラーをクラス分けする方法である。エラーシンボル(error symbol)、エラーコンディション(error condition)、コンディション名(condition name)の説明については@ref{Error Symbols}を参照のこと。"

#. type: defun
#: original_texis/control.texi:1788
msgid "If the error is not handled, the two arguments are used in printing the error message.  Normally, this error message is provided by the @code{error-message} property of @var{error-symbol}.  If @var{data} is non-@code{nil}, this is followed by a colon and a comma separated list of the unevaluated elements of @var{data}.  For @code{error}, the error message is the @sc{car} of @var{data} (that must be a string).  Subcategories of @code{file-error} are handled specially."
msgstr "エラーが処理されない場合には、エラーメッセージをプリントするために2つの引数が使用される。このエラーメッセージは通常、@var{error-symbol}の@code{error-message}プロパティーにより提供される。@var{data}が非@code{nil}なら、その後にコロンと@var{data}の未評価の要素をカンマで区切ったリストが続く。@code{error}にたいするエラーメッセージは@var{data}の@sc{car}である(文字列であること)。サブカテゴリー@code{file-error}は特別に処理される。"

#. type: defun
#: original_texis/control.texi:1793
msgid "The number and significance of the objects in @var{data} depends on @var{error-symbol}.  For example, with a @code{wrong-type-argument} error, there should be two objects in the list: a predicate that describes the type that was expected, and the object that failed to fit that type."
msgstr "@var{data}内のオブジェクトの数と意味は@var{error-symbol}に依存する。たとえば@code{wrong-type-argument}エラーではリスト内に2つのオブジェクト --- 期待する型を記述する述語とその型への適合に失敗したオブジェクト --- であること。"

#. type: defun
#: original_texis/control.texi:1798
msgid "Both @var{error-symbol} and @var{data} are available to any error handlers that handle the error: @code{condition-case} binds a local variable to a list of the form @code{(@var{error-symbol} .@: @var{data})} (@pxref{Handling Errors})."
msgstr "エラーを処理する任意のエラーハンドラーにたいして@var{error-symbol}と@var{data}の両方を利用できる。@code{condition-case}はローカル変数を@code{(@var{error-symbol} .@: @var{data})}というフォームでバインドする(@ref{Handling Errors}を参照)。"

#. type: defun
#: original_texis/control.texi:1801
msgid "The function @code{signal} never returns."
msgstr "関数@code{signal}は決してリターンしない。"

#. type: group
#: original_texis/control.texi:1806
#, no-wrap
msgid ""
"(signal 'wrong-number-of-arguments '(x y))\n"
"     @error{} Wrong number of arguments: x, y\n"
msgstr ""
"(signal 'wrong-number-of-arguments '(x y))\n"
"     @error{} Wrong number of arguments: x, y\n"

#. type: group
#: original_texis/control.texi:1811
#, no-wrap
msgid ""
"(signal 'no-such-error '(\"My unknown error condition\"))\n"
"     @error{} peculiar error: \"My unknown error condition\"\n"
msgstr ""
"(signal 'no-such-error '(\"My unknown error condition\"))\n"
"     @error{} peculiar error: \"My unknown error condition\"\n"

#. type: cindex
#: original_texis/control.texi:1815
#, no-wrap
msgid "user errors, signaling"
msgstr "user errors, signaling"

#. type: defun
#: original_texis/control.texi:1816
#, no-wrap
msgid "user-error format-string &rest args"
msgstr "user-error format-string &rest args"

#. type: defun
#: original_texis/control.texi:1826
msgid "This function behaves exactly like @code{error}, except that it uses the error symbol @code{user-error} rather than @code{error}.  As the name suggests, this is intended to report errors on the part of the user, rather than errors in the code itself.  For example, if you try to use the command @code{Info-history-back} (@kbd{l}) to move back beyond the start of your Info browsing history, Emacs signals a @code{user-error}.  Such errors do not cause entry to the debugger, even when @code{debug-on-error} is non-@code{nil}.  @xref{Error Debugging}."
msgstr "この関数は、@code{error}とまったく同じように振る舞うが、@code{error}ではなくエラーシンボル@code{user-error}を使用する。名前が示唆するように、このエラーはコード自身のエラーではなく、ユーザー側のエラーの報告を意図している。たとえばInfoの閲覧履歴の開始を超えて履歴を遡るためにコマンド@code{Info-history-back} (@kbd{l})を使用した場合、Emacsは@code{user-error}をシグナルする。このようなエラーでは、たとえ@code{debug-on-error}が非@code{nil}であっても、デバッガーへのエントリーは発生しない。@ref{Error Debugging}を参照のこと。"

#. type: cindex
#: original_texis/control.texi:1828
#, no-wrap
msgid "CL note---no continuable errors"
msgstr "CL note---no continuable errors"

#. type: quotation
#: original_texis/control.texi:1832
msgid "@b{Common Lisp note:} Emacs Lisp has nothing like the Common Lisp concept of continuable errors."
msgstr "@b{Common Lispに関する注意: }Emacs LispにはCommon Lispのような継続可能なエラーのような概念は存在しない。"

#. type: subsubsection
#: original_texis/control.texi:1835
#, no-wrap
msgid "How Emacs Processes Errors"
msgstr "How Emacs Processes Errors"

#. type: cindex
#: original_texis/control.texi:1836
#, no-wrap
msgid "processing of errors"
msgstr "processing of errors"

#. type: Plain text
#: original_texis/control.texi:1846
msgid "When an error is signaled, @code{signal} searches for an active @dfn{handler} for the error.  A handler is a sequence of Lisp expressions designated to be executed if an error happens in part of the Lisp program.  If the error has an applicable handler, the handler is executed, and control resumes following the handler.  The handler executes in the environment of the @code{condition-case} that established it; all functions called within that @code{condition-case} have already been exited, and the handler cannot return to them."
msgstr "エラーがシグナルされたとき、@code{signal}はそのエラーにたいするアクティブな@dfn{ハンドラー(handler)}を検索します。ハンドラーとは、Lispプログラムの一部でエラーが発生したときに実行するよう意図されたLisp式のシーケンスです。そのエラーが適切なハンドラーをもっていればそのハンドラーが実行され、そのハンドラーの後から実行が再開されます。ハンドラーはそのハンドラーが設定された@code{condition-case}の環境内で実行されます。@code{condition-case}内のすべての関数呼び出しはすでに終了しているので、ハンドラーがそれらにリターンすることはありません。"

#. type: Plain text
#: original_texis/control.texi:1853
msgid "If there is no applicable handler for the error, it terminates the current command and returns control to the editor command loop.  (The command loop has an implicit handler for all kinds of errors.)  The command loop's handler uses the error symbol and associated data to print an error message.  You can use the variable @code{command-error-function} to control how this is done:"
msgstr "そのエラーにたいする適切なハンドラーが存在しなければ、カレントコマンドを終了してエディターのコマンドループに制御をリターンします(コマンドループにはすべての種類のエラーにたいする暗黙のハンドラーがある)。コマンドループのハンドラーは、エラーメッセージをプリントするためにエラーシンボルと、それに関連付けられたデータを使用します。変数@code{command-error-function}を使用して、これが行なわれる方法を制御できます:"

#. type: defvar
#: original_texis/control.texi:1854
#, no-wrap
msgid "command-error-function"
msgstr "command-error-function"

#. type: defvar
#: original_texis/control.texi:1862
msgid "This variable, if non-@code{nil}, specifies a function to use to handle errors that return control to the Emacs command loop.  The function should take three arguments: @var{data}, a list of the same form that @code{condition-case} would bind to its variable; @var{context}, a string describing the situation in which the error occurred, or (more often) @code{nil}; and @var{caller}, the Lisp function which called the primitive that signaled the error."
msgstr "この変数が非@code{nil}なら、それはEmacsのコマンドループに制御をリターンしたエラーの処理に使用する関数を指定する。この関数は3つの引数を受け取る。1つ目の@var{data}は、@code{condition-case}が自身の変数にバインドするのと同じフォーム。2つ目の@var{context}はエラーが発生した状況を記述する文字列か、(大抵は)@code{nil}。3つ目の@var{caller}はエラーをシグナルしたプリミティブ関数を呼び出したLisp関数。"

#. type: cindex
#: original_texis/control.texi:1864
#, no-wrap
msgid "@code{debug-on-error} use"
msgstr "@code{debug-on-error} use"

#. type: Plain text
#: original_texis/control.texi:1870
msgid "An error that has no explicit handler may call the Lisp debugger.  The debugger is enabled if the variable @code{debug-on-error} (@pxref{Error Debugging}) is non-@code{nil}.  Unlike error handlers, the debugger runs in the environment of the error, so that you can examine values of variables precisely as they were at the time of the error."
msgstr "明示的なハンドラーがないエラーは、Lispデバッガーを呼び出すかもしれません。変数@code{debug-on-error} (@ref{Error Debugging}を参照)が非@code{nil}ならデバッガーが有効です。エラーハンドラーと異なり、デバッガーはそのエラーの環境内で実行されるので、エラー時の変数の値を正確に調べることができます。"

#. type: subsubsection
#: original_texis/control.texi:1872
#, no-wrap
msgid "Writing Code to Handle Errors"
msgstr "Writing Code to Handle Errors"

#. type: cindex
#: original_texis/control.texi:1873
#, no-wrap
msgid "error handler"
msgstr "error handler"

#. type: cindex
#: original_texis/control.texi:1874
#, no-wrap
msgid "handling errors"
msgstr "handling errors"

#. type: cindex
#: original_texis/control.texi:1875
#, no-wrap
msgid "forms for handling errors"
msgstr "forms for handling errors"

#. type: Plain text
#: original_texis/control.texi:1882
msgid "The usual effect of signaling an error is to terminate the command that is running and return immediately to the Emacs editor command loop.  You can arrange to trap errors occurring in a part of your program by establishing an error handler, with the special form @code{condition-case}.  A simple example looks like this:"
msgstr "エラーをシグナルすることによる通常の効果は、実行されていたコマンドを終了してEmacsエディターのコマンドループに即座にリターンすることです。スペシャルフォーム@code{condition-case}を使用してエラーハンドラーを設定することにより、プログラム内の一部で発生するエラーのをトラップを調整することができます。以下は単純な例です:"

#. type: group
#: original_texis/control.texi:1888
#, no-wrap
msgid ""
"(condition-case nil\n"
"    (delete-file filename)\n"
"  (error nil))\n"
msgstr ""
"(condition-case nil\n"
"    (delete-file filename)\n"
"  (error nil))\n"

#. type: Plain text
#: original_texis/control.texi:1895
msgid "This deletes the file named @var{filename}, catching any error and returning @code{nil} if an error occurs.  (You can use the macro @code{ignore-errors} for a simple case like this; see below.)"
msgstr "これは@var{filename}という名前のファイルを削除して、任意のエラーをcatch、エラーが発生した場合は@code{nil}をリターンします(このような単純なケースではマクロ@code{ignore-errors}を使用することもできる。以下を参照のこと)。"

#. type: Plain text
#: original_texis/control.texi:1901
msgid "The @code{condition-case} construct is often used to trap errors that are predictable, such as failure to open a file in a call to @code{insert-file-contents}.  It is also used to trap errors that are totally unpredictable, such as when the program evaluates an expression read from the user."
msgstr "@code{condition-case}構文は、@code{insert-file-contents}呼び出しによるファイルオープンの失敗のような、予想できるエラーをトラップするために多用されます。@code{condition-case}構文はユーザーから読み取った式を評価するプログラムのような、完全には予測できないエラーのトラップにも使用されます。"

#. type: Plain text
#: original_texis/control.texi:1912
msgid "The second argument of @code{condition-case} is called the @dfn{protected form}.  (In the example above, the protected form is a call to @code{delete-file}.)  The error handlers go into effect when this form begins execution and are deactivated when this form returns.  They remain in effect for all the intervening time.  In particular, they are in effect during the execution of functions called by this form, in their subroutines, and so on.  This is a good thing, since, strictly speaking, errors can be signaled only by Lisp primitives (including @code{signal} and @code{error}) called by the protected form, not by the protected form itself."
msgstr "@code{condition-case}の2番目の引数は@dfn{保護されたフォーム(protected form)}と呼ばれます(上記の例では保護されたフォームは@code{delete-file}の呼び出し)。このフォームの実行が開始されるとエラーハンドラーが効果をもち、このフォームがリターンすると不活性になります。その間のすべてにおいてエラーハンドラーは効果をもちます。特にこのフォームで呼び出された関数とそのサブルーチン等を実行する間、エラーハンドラーは効果をもちます。厳密にいうと保護されたフォーム自身ではなく、保護されたフォームから呼び出されたLispプリミティブ関数(@code{signal}と@code{error}を含む)だけがシグナルされるというのは、よいことと言えます。"

#. type: Plain text
#: original_texis/control.texi:1920
msgid "The arguments after the protected form are handlers.  Each handler lists one or more @dfn{condition names} (which are symbols) to specify which errors it will handle.  The error symbol specified when an error is signaled also defines a list of condition names.  A handler applies to an error if they have any condition names in common.  In the example above, there is one handler, and it specifies one condition name, @code{error}, which covers all errors."
msgstr "保護されたフォームの後の引数はハンドラーです。各ハンドラーはそれぞれ、どのエラーを処理するかを指定する1つ以上の@dfn{コンディション名}(シンボル)をリストします。エラーがシグナルされたとき、エラーシンボルはコンディション名のリストも定義します。エラーが共通のコンディション名をもつ場合、そのハンドラーがそのエラーに適用されます。上記の例では1つのハンドラーがあり、それはすべてのエラーをカバーするコンディション名@code{error}を指定しています。"

#. type: Plain text
#: original_texis/control.texi:1925
msgid "The search for an applicable handler checks all the established handlers starting with the most recently established one.  Thus, if two nested @code{condition-case} forms offer to handle the same error, the inner of the two gets to handle it."
msgstr "適切なハンドラーの検索は、もっとも最近に設定されたハンドラーから始まり、設定されたすべてのハンドラーをチェックします。したがってネストされた@code{condition-case}フォームに同じエラー処理がある場合には、内側のハンドラーがそれを処理します。"

#. type: Plain text
#: original_texis/control.texi:1929
msgid "If an error is handled by some @code{condition-case} form, this ordinarily prevents the debugger from being run, even if @code{debug-on-error} says this error should invoke the debugger."
msgstr "何らかの@code{condition-case}によりエラーが処理されると、@code{debug-on-error}でエラーによりデバッガーが呼び出されるようにしていても、通常はデバッガーの実行が抑制されます。"

#. type: Plain text
#: original_texis/control.texi:1935
msgid "If you want to be able to debug errors that are caught by a @code{condition-case}, set the variable @code{debug-on-signal} to a non-@code{nil} value.  You can also specify that a particular handler should let the debugger run first, by writing @code{debug} among the conditions, like this:"
msgstr "@code{condition-case}で補足されるようなエラーをデバッグできるようにしたいなら、変数@code{debug-on-signal}に非@code{nil}値をセットします。以下のようにコンディション内に@code{debug}を記述することにより、最初にデバッガーを実行するような特定のハンドラーを指定することもできます:"

#. type: group
#: original_texis/control.texi:1941
#, no-wrap
msgid ""
"(condition-case nil\n"
"    (delete-file filename)\n"
"  ((debug error) nil))\n"
msgstr ""
"(condition-case nil\n"
"    (delete-file filename)\n"
"  ((debug error) nil))\n"

#. type: Plain text
#: original_texis/control.texi:1949
msgid "The effect of @code{debug} here is only to prevent @code{condition-case} from suppressing the call to the debugger.  Any given error will invoke the debugger only if @code{debug-on-error} and the other usual filtering mechanisms say it should.  @xref{Error Debugging}."
msgstr "ここでの@code{debug}の効果は、デバッガー呼び出しを抑制する@code{condition-case}を防ぐことだけです。@code{debug-on-error}とその他のフィルタリングメカニズムがデバッガーを呼び出すように指定されているときだけ、エラーによりデバッガーが呼び出されます。@ref{Error Debugging}を参照してください。"

#. type: defmac
#: original_texis/control.texi:1950
#, no-wrap
msgid "condition-case-unless-debug var protected-form handlers@dots{}"
msgstr "condition-case-unless-debug var protected-form handlers@dots{}"

#. type: defmac
#: original_texis/control.texi:1955
msgid "The macro @code{condition-case-unless-debug} provides another way to handle debugging of such forms.  It behaves exactly like @code{condition-case}, unless the variable @code{debug-on-error} is non-@code{nil}, in which case it does not handle any errors at all."
msgstr "マクロ@code{condition-case-unless-debug}は、そのようなフォームのデバッギングを処理する、別の方法を提供する。このマクロは変数@code{debug-on-error}が@code{nil}、つまり任意のエラーを処理しないようなケース以外は、@code{condition-case}とまったく同様に振る舞う。"

#. type: Plain text
#: original_texis/control.texi:1963
msgid "Once Emacs decides that a certain handler handles the error, it returns control to that handler.  To do so, Emacs unbinds all variable bindings made by binding constructs that are being exited, and executes the cleanups of all @code{unwind-protect} forms that are being exited.  Once control arrives at the handler, the body of the handler executes normally."
msgstr "特定のハンドラーがそのエラーを処理するとEmacsが判断すると、Emacsは制御をそのハンドラーにreturnします。これを行うために、Emacsはそのとき脱出しつつあるバインディング構成により作成されたすべての変数のバインドを解き、そのとき脱出しつつあるすべての@code{unwind-protect}フォームを実行します。制御がそのハンドラーに達すると、そのハンドラーのbodyが通常どおり実行されます。"

#. type: Plain text
#: original_texis/control.texi:1970
msgid "After execution of the handler body, execution returns from the @code{condition-case} form.  Because the protected form is exited completely before execution of the handler, the handler cannot resume execution at the point of the error, nor can it examine variable bindings that were made within the protected form.  All it can do is clean up and proceed."
msgstr "そのハンドラーのbodyを実行した後、@code{condition-case}フォームから実行がreturnされます。保護されたフォームは、そのハンドラーの実行の前に完全にexitしているので、そのハンドラーはそのエラーの位置から実行を再開することはできず、その保護されたフォーム内で作られた変数のバインディングを調べることもできません。ハンドラーが行なえることは、クリーンアップと、処理を進行させることだけです。"

#. type: Plain text
#: original_texis/control.texi:1977
msgid "Error signaling and handling have some resemblance to @code{throw} and @code{catch} (@pxref{Catch and Throw}), but they are entirely separate facilities.  An error cannot be caught by a @code{catch}, and a @code{throw} cannot be handled by an error handler (though using @code{throw} when there is no suitable @code{catch} signals an error that can be handled)."
msgstr "エラーのシグナルとハンドルには@code{throw}と@code{catch} (@ref{Catch and Throw}を参照)に類似する点がいくつかありますが、これらは完全に別の機能です。エラーは@code{catch}でキャッチできず、@code{throw}をエラーハンドラーで処理することはできません(しかし対応する@code{catch}が存在しないときに@code{throw}を使用することによりシグナルされるエラーは処理できる)。"

#. type: defspec
#: original_texis/control.texi:1978
#, no-wrap
msgid "condition-case var protected-form handlers@dots{}"
msgstr "condition-case var protected-form handlers@dots{}"

#. type: defspec
#: original_texis/control.texi:1985
msgid "This special form establishes the error handlers @var{handlers} around the execution of @var{protected-form}.  If @var{protected-form} executes without error, the value it returns becomes the value of the @code{condition-case} form; in this case, the @code{condition-case} has no effect.  The @code{condition-case} form makes a difference when an error occurs during @var{protected-form}."
msgstr "このスペシャルフォームは@var{protected-form}の実行を囲い込むエラーハンドラー@var{handlers}を確立する。エラーなしで@var{protected-form}が実行されると、リターンされる値は@code{condition-case}フォームの値になる。この場合、@code{condition-case}は効果をもたない。@var{protected-form}の間にエラーが発生すると、@code{condition-case}フォームは違いを生じる。"

#. type: defspec
#: original_texis/control.texi:1992
msgid "Each of the @var{handlers} is a list of the form @code{(@var{conditions} @var{body}@dots{})}.  Here @var{conditions} is an error condition name to be handled, or a list of condition names (which can include @code{debug} to allow the debugger to run before the handler); @var{body} is one or more Lisp expressions to be executed when this handler handles an error.  Here are examples of handlers:"
msgstr "@var{handlers}はそれぞれ、@code{(@var{conditions} @var{body}@dots{})}というフォームのリストである。ここで@var{conditions}はハンドルされるエラーコンディション名、またはそのハンドラーの前にデバッガーを実行するためのコンディション名(@code{debug}を含む)。@var{body}はこのハンドラーがエラーを処理するときに実行される1つ以上のLisp式。"

#. type: group
#: original_texis/control.texi:1996
#, no-wrap
msgid ""
"(error nil)\n"
"\n"
msgstr ""
"(error nil)\n"
"\n"

#. type: group
#: original_texis/control.texi:1998
#, no-wrap
msgid ""
"(arith-error (message \"Division by zero\"))\n"
"\n"
msgstr ""
"(arith-error (message \"Division by zero\"))\n"
"\n"

#. type: group
#: original_texis/control.texi:2002
#, no-wrap
msgid ""
"((arith-error file-error)\n"
" (message\n"
"  \"Either division by zero or failure to open a file\"))\n"
msgstr ""
"((arith-error file-error)\n"
" (message\n"
"  \"Either division by zero or failure to open a file\"))\n"

#. type: defspec
#: original_texis/control.texi:2012
msgid "Each error that occurs has an @dfn{error symbol} that describes what kind of error it is, and which describes also a list of condition names (@pxref{Error Symbols}).  Emacs searches all the active @code{condition-case} forms for a handler that specifies one or more of these condition names; the innermost matching @code{condition-case} handles the error.  Within this @code{condition-case}, the first applicable handler handles the error."
msgstr "発生するエラーはそれぞれ、それが何の種類のエラーかを記述する@dfn{エラーシンボル(error symbol)}をもち、これはコンディション名のリストも記述する(@ref{Error Symbols}を参照)。Emacsは1つ以上のコンディション名を指定するハンドラーにたいして、すべてのアクティブな@code{condition-case}フォームを検索する。@code{condition-case}の最内のマッチがそのエラーを処理する。@code{condition-case}内では、最初に適合したハンドラーがそのエラーを処理する。"

#. type: defspec
#: original_texis/control.texi:2016
msgid "After executing the body of the handler, the @code{condition-case} returns normally, using the value of the last form in the handler body as the overall value."
msgstr "ハンドラーのbodyを実行した後、@code{condition-case}は通常どおりリターンして、ハンドラーのbodyの最後の値をハンドラー全体の値として使用する。"

#. type: cindex
#: original_texis/control.texi:2017
#, no-wrap
msgid "error description"
msgstr "error description"

#. type: defspec
#: original_texis/control.texi:2027
msgid "The argument @var{var} is a variable.  @code{condition-case} does not bind this variable when executing the @var{protected-form}, only when it handles an error.  At that time, it binds @var{var} locally to an @dfn{error description}, which is a list giving the particulars of the error.  The error description has the form @code{(@var{error-symbol} . @var{data})}.  The handler can refer to this list to decide what to do.  For example, if the error is for failure opening a file, the file name is the second element of @var{data}---the third element of the error description."
msgstr "引数@var{var}は変数である。@var{protected-form}を実行するとき、@code{condition-case}はこの変数をバインドせず、エラーを処理するときだけバインドする。その場合には、@var{var}を@dfn{エラー記述(error description)}にバインドする。これはエラーの詳細を与えるリストである。このエラー記述は@code{(@var{error-symbol} . @var{data})}というフォームをもつ。ハンドラーは何を行なうか決定するために、このリストを参照することができる。たとえばファイルオープンの失敗にたいするエラーなら、ファイル名が@var{data}(エラー記述の3番目の要素)の2番目の要素になる。"

#. type: defspec
#: original_texis/control.texi:2030
msgid "If @var{var} is @code{nil}, that means no variable is bound.  Then the error symbol and associated data are not available to the handler."
msgstr "@var{var}が@code{nil}なら、それはバインドされた変数がないことを意味する。この場合、エラーシンボルおよび関連するデータは、そのハンドラーでは利用できない。"

#. type: cindex
#: original_texis/control.texi:2031
#, no-wrap
msgid "rethrow a signal"
msgstr "rethrow a signal"

#. type: defspec
#: original_texis/control.texi:2035
msgid "Sometimes it is necessary to re-throw a signal caught by @code{condition-case}, for some outer-level handler to catch.  Here's how to do that:"
msgstr "より外側のレベルのハンドラーにcatchさせるために、@code{condition-case}によりcatchされたシグナルを再度throwする必要がある場合もある。以下はこれを行なう方法である:"

#. type: example
#: original_texis/control.texi:2038
#, no-wrap
msgid "  (signal (car err) (cdr err))\n"
msgstr "  (signal (car err) (cdr err))\n"

#. type: defspec
#: original_texis/control.texi:2044
msgid "where @code{err} is the error description variable, the first argument to @code{condition-case} whose error condition you want to re-throw.  @xref{Definition of signal}."
msgstr "ここで@code{err}はエラー記述変数(error description variable)で、@code{condition-case}の1番目の引数は、再throwしたいエラーコンディション。@ref{Definition of signal}を参照のこと。"

#. type: defun
#: original_texis/control.texi:2046
#, no-wrap
msgid "error-message-string error-descriptor"
msgstr "error-message-string error-descriptor"

#. type: defun
#: original_texis/control.texi:2050
msgid "This function returns the error message string for a given error descriptor.  It is useful if you want to handle an error by printing the usual error message for that error.  @xref{Definition of signal}."
msgstr "この関数は与えられたエラー記述子(error descriptor)にたいするエラーメッセージ文字列をリターンする。これはそのエラーにたいする通常のエラーメッセージをプリントすることにより、エラーを処理したい場合に有用。@ref{Definition of signal}を参照のこと。"

#. type: cindex
#: original_texis/control.texi:2052
#, no-wrap
msgid "@code{arith-error} example"
msgstr "@code{arith-error} example"

#. type: Plain text
#: original_texis/control.texi:2056
msgid "Here is an example of using @code{condition-case} to handle the error that results from dividing by zero.  The handler displays the error message (but without a beep), then returns a very large number."
msgstr "以下は0除算の結果によるエラーを処理するために、@code{condition-case}を使用する例です。このハンドラーは、(beepなしで)エラーメッセージを表示して、非常に大きい数をリターンします。"

#. type: group
#: original_texis/control.texi:2063
#, no-wrap
msgid ""
"(defun safe-divide (dividend divisor)\n"
"  (condition-case err\n"
"      ;; @r{Protected form.}\n"
"      (/ dividend divisor)\n"
msgstr ""
"(defun safe-divide (dividend divisor)\n"
"  (condition-case err\n"
"      ;; @r{保護されたフォーム}\n"
"      (/ dividend divisor)\n"

#. type: group
#: original_texis/control.texi:2071
#, no-wrap
msgid ""
"    ;; @r{The handler.}\n"
"    (arith-error                        ; @r{Condition.}\n"
"     ;; @r{Display the usual message for this error.}\n"
"     (message \"%s\" (error-message-string err))\n"
"     1000000)))\n"
"@result{} safe-divide\n"
msgstr ""
"    ;; @r{ハンドラー}\n"
"    (arith-error                        ; @r{コンディション}\n"
"     ;; @r{このエラーにたいする、通常のメッセージを表示する}\n"
"     (message \"%s\" (error-message-string err))\n"
"     1000000)))\n"
"@result{} safe-divide\n"

#. type: group
#: original_texis/control.texi:2077
#, no-wrap
msgid ""
"(safe-divide 5 0)\n"
"     @print{} Arithmetic error: (arith-error)\n"
"@result{} 1000000\n"
msgstr ""
"(safe-divide 5 0)\n"
"     @print{} Arithmetic error: (arith-error)\n"
"@result{} 1000000\n"

#. type: Plain text
#: original_texis/control.texi:2084
msgid "The handler specifies condition name @code{arith-error} so that it will handle only division-by-zero errors.  Other kinds of errors will not be handled (by this @code{condition-case}).  Thus:"
msgstr "このハンドラーはコンディション名@code{arith-error}を指定するので、division-by-zero(0除算)エラーだけを処理します。他の種類のエラーは(この@code{condition-case}によっては)、処理されません。したがって:"

#. type: group
#: original_texis/control.texi:2089
#, no-wrap
msgid ""
"(safe-divide nil 3)\n"
"     @error{} Wrong type argument: number-or-marker-p, nil\n"
msgstr ""
"(safe-divide nil 3)\n"
"     @error{} Wrong type argument: number-or-marker-p, nil\n"

#. type: Plain text
#: original_texis/control.texi:2094
msgid "Here is a @code{condition-case} that catches all kinds of errors, including those from @code{error}:"
msgstr "以下は@code{error}によるエラーを含む、すべての種類のエラーをcatchする@code{condition-case}です:"

#. type: group
#: original_texis/control.texi:2099
#, no-wrap
msgid ""
"(setq baz 34)\n"
"     @result{} 34\n"
msgstr ""
"(setq baz 34)\n"
"     @result{} 34\n"

#. type: group
#: original_texis/control.texi:2112
#, no-wrap
msgid ""
"(condition-case err\n"
"    (if (eq baz 35)\n"
"        t\n"
"      ;; @r{This is a call to the function @code{error}.}\n"
"      (error \"Rats!  The variable %s was %s, not 35\" 'baz baz))\n"
"  ;; @r{This is the handler; it is not a form.}\n"
"  (error (princ (format \"The error was: %s\" err))\n"
"         2))\n"
"@print{} The error was: (error \"Rats!  The variable baz was 34, not 35\")\n"
"@result{} 2\n"
msgstr ""
"(condition-case err\n"
"    (if (eq baz 35)\n"
"        t\n"
"      ;; @r{関数@code{error}の呼び出し}\n"
"      (error \"Rats!  The variable %s was %s, not 35\" 'baz baz))\n"
"  ;; @r{フォームではないハンドラー}\n"
"  (error (princ (format \"The error was: %s\" err))\n"
"         2))\n"
"@print{} The error was: (error \"Rats!  The variable baz was 34, not 35\")\n"
"@result{} 2\n"

#. type: defmac
#: original_texis/control.texi:2115
#, no-wrap
msgid "ignore-errors body@dots{}"
msgstr "ignore-errors body@dots{}"

#. type: defmac
#: original_texis/control.texi:2120
msgid "This construct executes @var{body}, ignoring any errors that occur during its execution.  If the execution is without error, @code{ignore-errors} returns the value of the last form in @var{body}; otherwise, it returns @code{nil}."
msgstr "この構文は、それの実行中に発生する任意のエラーを無視して@var{body}を実行する。その実行中にエラーがなければ、@code{ignore-errors}は@var{body}内の最後のフォームの値を、それ以外は@code{nil}をリターンする。"

#. type: defmac
#: original_texis/control.texi:2123
msgid "Here's the example at the beginning of this subsection rewritten using @code{ignore-errors}:"
msgstr "以下はこのセクションの最初の例を@code{ignore-errors}を使用して記述する例である:"

#. type: group
#: original_texis/control.texi:2128
#, no-wrap
msgid ""
"  (ignore-errors\n"
"   (delete-file filename))\n"
msgstr ""
"  (ignore-errors\n"
"   (delete-file filename))\n"

#. type: defmac
#: original_texis/control.texi:2132
#, no-wrap
msgid "with-demoted-errors format body@dots{}"
msgstr "with-demoted-errors format body@dots{}"

#. type: defmac
#: original_texis/control.texi:2141
msgid "This macro is like a milder version of @code{ignore-errors}.  Rather than suppressing errors altogether, it converts them into messages.  It uses the string @var{format} to format the message.  @var{format} should contain a single @samp{%}-sequence; e.g., @code{\"Error: %S\"}.  Use @code{with-demoted-errors} around code that is not expected to signal errors, but should be robust if one does occur.  Note that this macro uses @code{condition-case-unless-debug} rather than @code{condition-case}."
msgstr "このマクロはいわば@code{ignore-errors}の穏やかなバージョンである。これはエラーを完全に抑止するのではなく、エラーをメッセージに変換する。これはメッセージのフォーマットに、文字列@var{format}を使用する。@var{format}は@code{\"Error: %S\"}のように、単一の@samp{%}シーケンスを含むこと。エラーをシグナルするとは予測されないが、もし発生した場合は堅牢であるべきようなコードの周囲に@code{with-demoted-errors}を使用する。このマクロは@code{condition-case}ではなく、@code{condition-case-unless-debug}を使用することに注意。"

#. type: subsubsection
#: original_texis/control.texi:2144
#, no-wrap
msgid "Error Symbols and Condition Names"
msgstr "Error Symbols and Condition Names"

#. type: cindex
#: original_texis/control.texi:2145
#, no-wrap
msgid "error symbol"
msgstr "error symbol"

#. type: cindex
#: original_texis/control.texi:2146
#, no-wrap
msgid "error name"
msgstr "error name"

#. type: cindex
#: original_texis/control.texi:2147
#, no-wrap
msgid "condition name"
msgstr "condition name"

#. type: cindex
#: original_texis/control.texi:2148
#, no-wrap
msgid "user-defined error"
msgstr "user-defined error"

#. type: kindex
#: original_texis/control.texi:2149
#, no-wrap
msgid "error-conditions"
msgstr "error-conditions"

#. type: kindex
#: original_texis/control.texi:2150
#, no-wrap
msgid "define-error"
msgstr "define-error"

#. type: Plain text
#: original_texis/control.texi:2156
msgid "When you signal an error, you specify an @dfn{error symbol} to specify the kind of error you have in mind.  Each error has one and only one error symbol to categorize it.  This is the finest classification of errors defined by the Emacs Lisp language."
msgstr "エラーをシグナルするとき、想定するエラーの種類を指定するために@dfn{エラーシンボル(error symbol)}を指定します。エラーはそれぞれ、それをカテゴリー分けするために単一のエラーシンボルをもちます。これはEmacs Lisp言語で定義されるエラーを分類する、もっともよい方法です。"

#. type: Plain text
#: original_texis/control.texi:2166
msgid "These narrow classifications are grouped into a hierarchy of wider classes called @dfn{error conditions}, identified by @dfn{condition names}.  The narrowest such classes belong to the error symbols themselves: each error symbol is also a condition name.  There are also condition names for more extensive classes, up to the condition name @code{error} which takes in all kinds of errors (but not @code{quit}).  Thus, each error has one or more condition names: @code{error}, the error symbol if that is distinct from @code{error}, and perhaps some intermediate classifications."
msgstr "これらの狭義の分類は@dfn{エラー条件(error conditions)}と呼ばれる、より広義のクラス階層にグループ化され、それらは@dfn{コンディション名(condition names)}により識別されます。そのようなもっとも狭義なクラスは、エラーシンボル自体に属します。つまり各エラーシンボルは、コンディション名でもあるのです。すべての種類のエラー(@code{quit}を除く)を引き受けるコンディション名@code{error}に至る、より広義のクラスにたいするコンディション名も存在します。したがって各エラーは1つ以上のコンディション名をもちます。つまり@code{error}、@code{error}とは区別されるエラーシンボル、もしかしたらその中間に分類されるものかもしれません。"

#. type: defun
#: original_texis/control.texi:2167
#, no-wrap
msgid "define-error name message &optional parent"
msgstr "define-error name message &optional parent"

#. type: defun
#: original_texis/control.texi:2174
msgid "In order for a symbol to be an error symbol, it must be defined with @code{define-error} which takes a parent condition (defaults to @code{error}).  This parent defines the conditions that this kind of error belongs to.  The transitive set of parents always includes the error symbol itself, and the symbol @code{error}.  Because quitting is not considered an error, the set of parents of @code{quit} is just @code{(quit)}."
msgstr "シンボルをエラーシンボルとするために、シンボルは親コンディションを受け取る@code{define-error}で定義されなければならない。この親はその種のエラーが属するコンディションを定義する。親の推移的な集合は、常にそのエラーシンボルとシンボル@code{error}を含む。quitはエラーと判断されないので、@code{quit}の親の集合は単なる@code{(quit)}である。"

#. type: cindex
#: original_texis/control.texi:2176
#, no-wrap
msgid "peculiar error"
msgstr "peculiar error"

#. type: Plain text
#: original_texis/control.texi:2181
msgid "In addition to its parents, the error symbol has a @var{message} which is a string to be printed when that error is signaled but not handled.  If that message is not valid, the error message @samp{peculiar error} is used.  @xref{Definition of signal}."
msgstr "親のコンディションに加えてエラーシンボルは@var{メッセージ(message)}をもち、これは処理されないエラーがシグナルされたときプリントされる文字列です。そのメッセージが有効でなければ、エラーメッセージ@samp{peculiar error}が使用されます。@ref{Definition of signal}を参照してください。"

#. type: Plain text
#: original_texis/control.texi:2185
msgid "Internally, the set of parents is stored in the @code{error-conditions} property of the error symbol and the message is stored in the @code{error-message} property of the error symbol."
msgstr "内部的には親の集合はエラーシンボルの@code{error-conditions}プロパティーに格納され、メッセージはエラーシンボルの@code{error-message}プロパティーに格納されます。"

#. type: Plain text
#: original_texis/control.texi:2187
msgid "Here is how we define a new error symbol, @code{new-error}:"
msgstr "以下は新しいエラーシンボル@code{new-error}を定義する例です:"

#. type: group
#: original_texis/control.texi:2191
#, no-wrap
msgid "(define-error 'new-error \"A new error\" 'my-own-errors)\n"
msgstr "(define-error 'new-error \"A new error\" 'my-own-errors)\n"

#. type: Plain text
#: original_texis/control.texi:2199
msgid "This error has several condition names: @code{new-error}, the narrowest classification; @code{my-own-errors}, which we imagine is a wider classification; and all the conditions of @code{my-own-errors} which should include @code{error}, which is the widest of all."
msgstr "このエラーは複数のコンディション名 --- もっとも狭義の分類@code{new-error}、より広義の分類を想定する@code{my-own-errors}、および@code{my-own-errors}のコンディションすべてを含む@code{error}であり、これはすべての中でもっとも広義なものです。"

#. type: Plain text
#: original_texis/control.texi:2202
msgid "The error string should start with a capital letter but it should not end with a period.  This is for consistency with the rest of Emacs."
msgstr "エラー文字列は大文字で開始されるべきですが、ピリオドで終了すべきではありません。これはEmacsの他の部分との整合性のためです。"

#. type: Plain text
#: original_texis/control.texi:2206
msgid "Naturally, Emacs will never signal @code{new-error} on its own; only an explicit call to @code{signal} (@pxref{Definition of signal}) in your code can do this:"
msgstr "もちろんEmacs自身が@code{new-error}をシグナルすることはありません。あなたのコード内で明示的に@code{signal} (@ref{Definition of signal}を参照)を呼び出すことにより、これを行なうことができます。"

#. type: group
#: original_texis/control.texi:2211
#, no-wrap
msgid ""
"(signal 'new-error '(x y))\n"
"     @error{} A new error: x, y\n"
msgstr ""
"(signal 'new-error '(x y))\n"
"     @error{} A new error: x, y\n"

#. type: Plain text
#: original_texis/control.texi:2217
msgid "This error can be handled through any of its condition names.  This example handles @code{new-error} and any other errors in the class @code{my-own-errors}:"
msgstr "このエラーは、エラーの任意のコンディション名により処理することができます。以下の例は@code{new-error}とクラス@code{my-own-errors}内の他の任意のエラーを処理します:"

#. type: group
#: original_texis/control.texi:2223
#, no-wrap
msgid ""
"(condition-case foo\n"
"    (bar nil t)\n"
"  (my-own-errors nil))\n"
msgstr ""
"(condition-case foo\n"
"    (bar nil t)\n"
"  (my-own-errors nil))\n"

#. type: Plain text
#: original_texis/control.texi:2231
msgid "The significant way that errors are classified is by their condition names---the names used to match errors with handlers.  An error symbol serves only as a convenient way to specify the intended error message and list of condition names.  It would be cumbersome to give @code{signal} a list of condition names rather than one error symbol."
msgstr "エラーが分類される有効な方法はコンディション名による方法で、その名前はハンドラーのエラーのマッチに使用されます。エラーシンボルは意図されたエラーメッセージと、コンディション名のリストを指定する便利な方法であるという役割をもつだけです。1つのエラーシンボルではなく、コンディション名のリストを@code{signal}に与えるのは面倒でしょう。"

#. type: Plain text
#: original_texis/control.texi:2237
msgid "By contrast, using only error symbols without condition names would seriously decrease the power of @code{condition-case}.  Condition names make it possible to categorize errors at various levels of generality when you write an error handler.  Using error symbols alone would eliminate all but the narrowest level of classification."
msgstr "対照的にコンディション名を伴わずにエラーシンボルだけを使用すると、それは@code{condition-case}の効果を著しく減少させるでしょう。コンディション名はエラーハンドラーを記述するとき、一般性のさまざまなレベルにおいて、エラーをカテゴリー分けすることを可能にします。エラーシンボルを単独で使用することは、もっとも狭義なレベルの分類を除くすべてを捨ててしまうことです。"

#. type: Plain text
#: original_texis/control.texi:2240
msgid "@xref{Standard Errors}, for a list of the main error symbols and their conditions."
msgstr "主要なエラーシンボルとそれらのコンディションについては、@ref{Standard Errors}を参照してください。"

#. type: subsection
#: original_texis/control.texi:2242
#, no-wrap
msgid "Cleaning Up from Nonlocal Exits"
msgstr "Cleaning Up from Nonlocal Exits"

#. type: cindex
#: original_texis/control.texi:2243
#, no-wrap
msgid "nonlocal exits, cleaning up"
msgstr "nonlocal exits, cleaning up"

#. type: cindex
#: original_texis/control.texi:2244
#, no-wrap
msgid "forms for cleanup"
msgstr "forms for cleanup"

#. type: Plain text
#: original_texis/control.texi:2252
msgid "The @code{unwind-protect} construct is essential whenever you temporarily put a data structure in an inconsistent state; it permits you to make the data consistent again in the event of an error or throw.  (Another more specific cleanup construct that is used only for changes in buffer contents is the atomic change group; @ref{Atomic Changes}.)"
msgstr "@code{unwind-protect}構文は、データ構造を一時的に不整合な状態に置くときに重要です。これはエラーやthrouのイベントにより、再びデータを整合された状態にすることができます(バッファー内容の変更だけに使用される他のクリーンアップ構成はアトミックな変更グループである。@ref{Atomic Changes}を参照)。"

#. type: defspec
#: original_texis/control.texi:2253
#, no-wrap
msgid "unwind-protect body-form cleanup-forms@dots{}"
msgstr "unwind-protect body-form cleanup-forms@dots{}"

#. type: cindex
#: original_texis/control.texi:2254
#, no-wrap
msgid "cleanup forms"
msgstr "cleanup forms"

#. type: cindex
#: original_texis/control.texi:2255
#, no-wrap
msgid "protected forms"
msgstr "protected forms"

#. type: cindex
#: original_texis/control.texi:2256
#, no-wrap
msgid "error cleanup"
msgstr "error cleanup"

#. type: cindex
#: original_texis/control.texi:2257
#, no-wrap
msgid "unwinding"
msgstr "unwinding"

#. type: defspec
#: original_texis/control.texi:2264
msgid "@code{unwind-protect} executes @var{body-form} with a guarantee that the @var{cleanup-forms} will be evaluated if control leaves @var{body-form}, no matter how that happens.  @var{body-form} may complete normally, or execute a @code{throw} out of the @code{unwind-protect}, or cause an error; in all cases, the @var{cleanup-forms} will be evaluated."
msgstr "@code{unwind-protect}は制御が@var{body-form}を離れる場合に、@var{cleanup-forms}が評価されるという保証の下において、何が起こったかに関わらず@var{body-form}を実行する。@var{body-form}は通常どおり完了するかもしれず、@code{unwind-protect}の外側で@code{throw}の実行やエラーが発生するかもしれないが、@var{cleanup-forms}は評価される。"

#. type: defspec
#: original_texis/control.texi:2269
msgid "If @var{body-form} finishes normally, @code{unwind-protect} returns the value of @var{body-form}, after it evaluates the @var{cleanup-forms}.  If @var{body-form} does not finish, @code{unwind-protect} does not return any value in the normal sense."
msgstr "@var{body-form}が正常に終了したら、@code{unwind-protect}は@var{cleanup-forms}を評価した後に、@var{body-form}の値をリターンする。@var{body-form}が終了しなかったら、@code{unwind-protect}は通常の意味におけるような値はリターンしない。"

#. type: defspec
#: original_texis/control.texi:2276
msgid "Only @var{body-form} is protected by the @code{unwind-protect}.  If any of the @var{cleanup-forms} themselves exits nonlocally (via a @code{throw} or an error), @code{unwind-protect} is @emph{not} guaranteed to evaluate the rest of them.  If the failure of one of the @var{cleanup-forms} has the potential to cause trouble, then protect it with another @code{unwind-protect} around that form."
msgstr "@code{unwind-protect}で保護されるのは@var{body-form}だけである。@var{cleanup-forms}自体の任意のフォームが、(@code{throw}またはエラーにより)非ローカルにexitすると、@code{unwind-protect}は残りのフォームが評価されることを@emph{保証しない}。@var{cleanup-forms}の中の1つが失敗することが問題となるようなら、そのフォームの周囲に他の@code{unwind-protect}を配置して保護すること。"

#. type: defspec
#: original_texis/control.texi:2281
msgid "The number of currently active @code{unwind-protect} forms counts, together with the number of local variable bindings, against the limit @code{max-specpdl-size} (@pxref{Definition of max-specpdl-size,, Local Variables})."
msgstr "現在アクティブな@code{unwind-protect}フォーム数とローカルの変数バインディング数の和は、@code{max-specpdl-size} (@ref{Definition of max-specpdl-size,, Local Variables}を参照)により制限される。"

#. type: Plain text
#: original_texis/control.texi:2285
msgid "For example, here we make an invisible buffer for temporary use, and make sure to kill it before finishing:"
msgstr "たとえば以下は一時的な使用のために不可視のバッファーを作成して、終了する前に確実にそのバッファーをkillする例です:"

#. type: group
#: original_texis/control.texi:2293
#, no-wrap
msgid ""
"(let ((buffer (get-buffer-create \" *temp*\")))\n"
"  (with-current-buffer buffer\n"
"    (unwind-protect\n"
"        @var{body-form}\n"
"      (kill-buffer buffer))))\n"
msgstr ""
"(let ((buffer (get-buffer-create \" *temp*\")))\n"
"  (with-current-buffer buffer\n"
"    (unwind-protect\n"
"        @var{body-form}\n"
"      (kill-buffer buffer))))\n"

#. type: Plain text
#: original_texis/control.texi:2304
msgid "You might think that we could just as well write @code{(kill-buffer (current-buffer))} and dispense with the variable @code{buffer}.  However, the way shown above is safer, if @var{body-form} happens to get an error after switching to a different buffer! (Alternatively, you could write a @code{save-current-buffer} around @var{body-form}, to ensure that the temporary buffer becomes current again in time to kill it.)"
msgstr "@code{(kill-buffer (current-buffer))}のように記述して、変数@code{buffer}を使用せずに同様のことを行えると思うかもしれません。しかし上の例は、別のバッファーにスイッチしたときに@var{body-form}でエラーが発生した場合、より安全なのです(一時的なバッファーをkillするとき、そのバッファーがカレントとなることを確実にするために、かわりに@var{body-form}の周囲に@code{save-current-buffer}を記述することもできる)。"

#. type: Plain text
#: original_texis/control.texi:2309
msgid "Emacs includes a standard macro called @code{with-temp-buffer} which expands into more or less the code shown above (@pxref{Definition of with-temp-buffer,, Current Buffer}).  Several of the macros defined in this manual use @code{unwind-protect} in this way."
msgstr "Emacsには上のコードとおおよそ等しいコードに展開される、@code{with-temp-buffer}という標準マクロが含まれます(@ref{Definition of with-temp-buffer,, Current Buffer}を参照)。このマニュアル中で定義されるいくつかのマクロは、この方法で@code{unwind-protect}を使用します。"

#. type: findex
#: original_texis/control.texi:2310
#, no-wrap
msgid "ftp-login"
msgstr "ftp-login"

#. type: Plain text
#: original_texis/control.texi:2318
msgid "Here is an actual example derived from an FTP package.  It creates a process (@pxref{Processes}) to try to establish a connection to a remote machine.  As the function @code{ftp-login} is highly susceptible to numerous problems that the writer of the function cannot anticipate, it is protected with a form that guarantees deletion of the process in the event of failure.  Otherwise, Emacs might fill up with useless subprocesses."
msgstr "以下はFTPパッケージ由来の実例です。これはリモートマシンへの接続の確立を試みるために、プロセス(@ref{Processes}を参照)を作成しています。関数@code{ftp-login}は関数のライター(writer)が予想できないことによる多くの問題から非常に影響を受けるので、失敗イベントでプロセスの削除を保証するフォームで保護されています。そうしないとEmacsは無用なサブプロセスで一杯になってしまうでしょう。"

#. type: group
#: original_texis/control.texi:2329
#, no-wrap
msgid ""
"(let ((win nil))\n"
"  (unwind-protect\n"
"      (progn\n"
"        (setq process (ftp-setup-buffer host file))\n"
"        (if (setq win (ftp-login process host user password))\n"
"            (message \"Logged in\")\n"
"          (error \"Ftp login failed\")))\n"
"    (or win (and process (delete-process process)))))\n"
msgstr ""
"(let ((win nil))\n"
"  (unwind-protect\n"
"      (progn\n"
"        (setq process (ftp-setup-buffer host file))\n"
"        (if (setq win (ftp-login process host user password))\n"
"            (message \"Logged in\")\n"
"          (error \"Ftp login failed\")))\n"
"    (or win (and process (delete-process process)))))\n"

#. type: Plain text
#: original_texis/control.texi:2336
msgid "This example has a small bug: if the user types @kbd{C-g} to quit, and the quit happens immediately after the function @code{ftp-setup-buffer} returns but before the variable @code{process} is set, the process will not be killed.  There is no easy way to fix this bug, but at least it is very unlikely."
msgstr "この例には小さなバグがあります。ユーザーがquitするために@kbd{C-g}とタイプすると、関数@code{ftp-setup-buffer}のリターン後に即座にquitが発生しますが、それは変数@code{process}がセットされる前なので、そのプロセスはkillされないでしょう。このバグを簡単に訂正する方法はありませんが、少なくともこれは非常に稀なことだと言えます。"
