@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*- mode: texinfo; coding: utf-8 -*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990--1995, 1998--1999, 2001--2021 Free Software
@c Foundation, Inc.
@c See the file elisp-ja.texi for copying conditions.
@node Lisp Data Types
@chapter Lispのデータ型
@cindex object
@cindex Lisp object
@cindex type
@cindex data type

  Lispの@dfn{オブジェクト(object)}とは、Lispプログラムから操作されるデータです。@dfn{型(type)}や@dfn{データ型(data
type)}とは、可能なオブジェクトの集合を意味します。

  すべてのオブジェクトは少なくとも1つの型に属します。同じ型のオブジェクトは同様な構造をもち、通常は同じコンテキストで使用されます。型を重複してもつことができ、オブジェクトは複数の型に属することができます。その結果として、あるオブジェクトが特定の型に属するかどうかを尋ねることはできますが、オブジェクトが@emph{その}型だけに属するかどうかは決定できません。

@cindex primitive type
  Emacsにはいくつかの基本オブジェクト型が組み込まれています。これらの型は他のすべての型を構成するもとであり、@dfn{プリミティブ型(primitive
types:
基本型)}と呼ばれます。すべてのオブジェクトはただ1つのプリミティブ型に属します。これらの型には@dfn{整数(integer)}、@dfn{浮動小数点数(float)}、@dfn{コンス(cons)}、@dfn{シンボル(symbol)}、@dfn{文字列(string)}、@dfn{ベクター(vector)}、@dfn{ハッシュテーブル(hash-table)}、@dfn{サブルーチン(subr)}、@dfn{バイトコード関数(byte-code
function)}、@dfn{レコード(record)}、および@dfn{buffer}のような編集に関連した特別な型が含まれます(@ref{Editing
Types}を参照)。

  プリミティブ型にはそれぞれ、オブジェクトがその型のメンバーかどうかのチェックを行なうために、それぞれ対応するLisp関数があります。

  他の多くの言語とは異なり、Lispのオブジェクトは@dfn{自己記述(self-typing)}的です。オブジェクトのプリミティブ型は、オブジェクト自体に暗に含まれます。たとえばオブジェクトがベクターなら、それを数字として扱うことはできません。Lispはベクターが数字でないことを知っているのです。

  多くの言語では、プログラマーは各変数にたいしてデータ型を宣言しなければならず、コンパイラーは型を知っていますが、データの中に型はありません。Emacs
Lispには、このような型宣言はありません。Lisp変数は任意の型の値をもつことができ、変数に保存した値と型を記憶します(実際には特定の型の値だけをもつことができる少数のEmacs
Lisp変数がある。@ref{Variables with Restricted Values}を参照されたい)。

  このチャプターでは、GNU Emacs Lispの各標準型の意味、プリント表現(printed representation)、入力構文(read
syntax)を説明します。これらのデータ型を使用する方法についての詳細は、以降のチャプターを参照してください。

@menu
* Printed Representation::   Lispオブジェクトがテキストとして表現される方法。
* Special Read Syntax::      すべての特殊なシーケンスの概要。
* Comments::                 コメントとコメント書式の慣例。
* Programming Types::        すべてのLispシステムに存在する型。
* Editing Types::            Emacs固有の型。
* Circular Objects::         循環構造にたいする入力構文。
* Type Predicates::          型に関連するテスト。
* Equality Predicates::      2つのオブジェクトが等しいかのテスト。
* Mutability::               変更されるべきではないオブジェクト。
@end menu

@node Printed Representation
@section プリント表現と読み取り構文
@cindex printed representation
@cindex read syntax

  オブジェクトのプリント表現(printed
representation)とは、オブジェクトにたいしてLispプリンター(関数@code{prin1})が生成する出力のフォーマットです。すべてのデータ型は一意なプリント表現をもちます。オブジェクトの@dfn{入力構文(read
syntax)}とは、オブジェクトにたいしてLispリーダー(関数@code{read})が受け取る入力のフォーマットです。これは一意である必要はありません。多くの種類のオブジェクトが複数の構文をもちます。@ref{Read
and Print}を参照してください。

@cindex hash notation
  ほとんどの場合、オブジェクトのプリント表現が、入力構文としても使用されます。しかしLispプログラム内の定数とすることに意味が無いいくつかの型には、入力構文がありません。これらのオブジェクトは@dfn{ハッシュ表記(hash
notation)}でプリントされ、@samp{#<}、説明的な文字列(典型的には型名にオブジェクトの名前を続けたもの)、@samp{>}で構成される文字列です。たとえば:

@example
(current-buffer)
     @result{} #<buffer objects-ja.texi>
@end example

@noindent
ハッシュ表記は読み取ることができないので、Lispリーダーは@samp{#<}に遭遇すると常にエラー@code{invalid-read-syntax}をシグナルします。
@kindex invalid-read-syntax

  他の言語では式はテキストであり、これ以外の形式はありません。Lispでは式は第一にまずLispオブジェクトであって、オブジェクトの入力構文であるテキストは副次的なものに過ぎません。たいていこの違いを強調する必要はありませんが、このことを心に留めておかないとたまに混乱することがあるでしょう。

  インタラクティブに式を評価するとき、Lispインタープリターは最初にそれのテキスト表現を読み取り、Lispオブジェクトを生成してからそのオブジェクトを評価します(@ref{Evaluation}を参照)。しかし評価と読み取りは別の処理です。読み取りによりテキストにより表現されたLispオブジェクトを読み取り、Lispオブジェクトがリターンされます。後でオブジェクトは評価されるかもしれないし、評価されないかもしれません。オブジェクトを読み取るための基本的な関数@code{read}の説明は、@ref{Input
Functions}を参照してください。

@node Special Read Syntax
@section 特別な読み取り構文
@cindex special read syntax

  Emacs Lispでは特別なハッシュ表記を通じて多くの特別なオブジェクトと構文を表します。

@table @samp
@item #<@dots{}>
入力構文がないオブジェクトはこのように表される(@ref{Printed Representation}を参照)。

@item ##
名前が空文字列であるようなインターン済みシンボルのプリント表現(@ref{Symbol Type}を参照)。

@item #'
@code{function}にたいするショートカット。@ref{Anonymous Functions}を参照のこと。

@item #:
名前が@var{foo}であるようなインターンされていないシンボルのプリント表現は@samp{#:@var{foo}} (@ref{Symbol
Type}を参照)。

@item #N
循環構造のプリント時には構造が自身をループバックすることを表すためにこの構文が使用される。ここで@samp{N}リストの開始カウント。

@lisp
(let ((a (list 1)))
  (setcdr a a))
=> (1 . #0)
@end lisp

@item #N=
@itemx #N#
@samp{#N=}はオブジェクト名、@samp{#N#}はそのオブジェクトを表すので、これらはコピーではなく同一オブジェクトになる(@ref{Circular
Objects}を参照)。

@item #xN
16進表現の@samp{N} (@samp{#x2a})。

@item #oN
8進表現の@samp{N} (@samp{#o52})。

@item #bN
2進表現の@samp{N} (@samp{#b101010})。

@item #(@dots{})
文字列のテキストプロパティ(@ref{Text Props and Strings}を参照)。

@item #^
文字テーブル(@ref{Char-Table Type}を参照)。

@item #s(hash-table @dots{})
ハッシュテーブル(@ref{Hash Table Type}を参照)。

@item ?C
文字(@ref{Basic Char Syntax}を参照)。

@item #$
バイトコンパイル済みファイルのカレントファイル名(@ref{Docs and Compilation}を参照)。これはEmacs
Lispソースファイルで使用するためのものではない。

@item #@@N
次の@samp{N}文字をスキップする(@ref{Comments}を参照)。バイトコンパイル済みファイル内で使用されるものであって、Emacs
Lispソースファイル内で使用するためのものではない。
@end table


@node Comments
@section コメント
@cindex comments
@cindex @samp{;} for commenting

  @dfn{コメント(comment)}はプログラム中に記述されたテキストであり、そのプログラムを読む人間ためだけに存在するものであって、プログラムの意味には何の影響ももちません。Lispではそれが文字列や文字定数にある場合をのぞき、エスケープされていないセミコロン(@samp{;})でコメントが開始されます。行の終端までがコメントになります。Lispリーダーはコメントを破棄します。コメントはLispシステム内でプログラムを表すLispオブジェクトの一部にはなりません。

  @samp{#@@@var{count}}構成は、次の@var{count}個の文字をスキップします。これはプログラムにより生成されたバイナリーデータを含むコメントにたいして有用です。Emacs
Lispバイトコンパイラーは出力ファイルにこれを使用します(@ref{Byte Compilation}を参照)。しかしソースファイル用ではありません。

  コメントのフォーマットにたいする慣例は、@ref{Comment Tips}を参照してください。

@node Programming Types
@section プログラミングの型
@cindex programming types

  Emacs
Lispには2種類の一般的な型があります。1つはLispプログラミングに関わるもので、もう1つは編集に関わるものです。前者はさまざまな形で多くのLisp実装に存在します。後者はEmacs
Lispに固有です。

@menu
* Integer Type::             小数部のない数字。
* Floating-Point Type::      広い範囲をもつ、小数部をもつ数字。
* Character Type::           文字、数字、コントロール文字にたいする表現。
* Symbol Type::              関数、変数、プロパティーリストを参照する、一意に識別される多目的オブジェクト。
* Sequence Type::            リストと配列はどちらもシーケンスに分類される。
* Cons Cell Type::           コンスセル、および(コンスセルにより作られる)リスト。
* Array Type::               配列には文字列とベクターが含まれる。
* String Type::              (効率的な)文字の配列。
* Vector Type::              1次元の配列。
* Char-Table Type::          文字によりインデックスされる1次元の疎な配列。
* Bool-Vector Type::         @code{t}と@code{nil}からなる1次元の配列。
* Hash Table Type::          非常に高速な参照用のテーブル。
* Function Type::            他の場所から呼び出せる実行可能なコード断片。
* Macro Type::               より基本的だが少し見栄えの悪い、式を他の式に展開する手法。
* Primitive Function Type::  Lispから呼び出せるCで記述された関数。
* Byte-Code Type::           Lispで記述されてコンパイルされた関数。
* Record Type::              プログラーが定義する合成オブジェクト型。
* Type Descriptors::         型に関する情報を保持するオブジェクト。
* Autoload Type::            頻繁に使用されない関数を自動的にロードするために使用される型。
* Finalizer Type::           オブジェクトが到達不能になった際に実行するコード。

@end menu

@node Integer Type
@subsection 整数型

  内部には@dfn{fixnums}と呼ばれる小さい整数、および@dfn{bignums}という大きい整数という2種類の整数が存在します。

  fixnumの値の範囲はマシンに依存します、最小のレンジは@minus{}536,870,912から536,870,911(30ビットでは
@ifnottex
@minus{}2**29
@end ifnottex
@tex
@math{-2^{29}}
@end tex
から
@ifnottex
2**29 @minus{} 1)
@end ifnottex
@tex
@math{2^{29}-1})
@end tex
しかし多くのマシンはより広い範囲を提供します。

  bignumは任意の精度をもつことができます。fixnumのオーバーフローする処理では、かわりにbignumをリターンされます。

  @code{eql}や@code{=}ですべての数値、fixnumなら@code{eq}で比較することができます。整数がfixnumかbignumをテストするには@code{most-negative-fixnum}と@code{most-positive-fixnum}で比較するか、便利な述語@code{fixnump}と@code{bignump}を任意のオブジェクトに使用できます。

  整数にたいする入力構文は、(10を基数とする)数字のシーケンスで、オプションで先頭に符号、最後にピリオドがつきます。Lispインタープリターにより生成されるプリント表現には、先頭の
@samp{+}や最後の@samp{.}はありません。

@example
@group
-1               ; @r{整数の@minus{}1}
1                ; @r{整数の1}
1.               ; @r{これも整数の1}
+1               ; @r{これも整数の1}
@end group
@end example

@noindent

  詳細は@ref{Numbers}を参照してください。

@node Floating-Point Type
@subsection 浮動小数点数型

  浮動小数点数は、コンピューターにおける科学表記に相当するものです。浮動小数点数を10の指数をともなう有理数として考えることができます。正確な有効桁数と可能な指数はマシン固有です。Emacsは値の保存にCデータ型の@code{double}を使用し、内部的には10の指数ではなく、2の指数として記録します。

  浮動小数点数のプリント表現には、(後に最低1つの数字をともなう)小数点と、指数のどちらか一方、または両方が必要です。たとえば@samp{1500.0}、@samp{+15e2}、@samp{15.0e+2}、@samp{+1500000e-3}、@samp{.15e4}は、いずれも浮動小数点数の1500を記述し、これらはすべて等価です。

  詳細は@ref{Numbers}を参照してください。

@node Character Type
@subsection 文字型
@cindex @acronym{ASCII} character codes

  Emacs
Lispでの@dfn{文字(character)}は、整数以外の何者でもありません。言い換えると、文字は文字コードで表現されます。たとえば文字@kbd{A}は、@w{整数の65}として表現されます。

  プログラムで文字を個別に使用するのは稀であり、文字のシーケンスとして構成される@emph{文字列(strings)}として扱われるのがより一般的です。@ref{String
Type}を参照してください。

  文字列やバッファーの中の文字は、現在のところ0から4194303の範囲 --- つまり22ビットに制限されています(@ref{Character
Codes}を参照)。0から127のコードは@acronym{ASCII}コードで、残りは非@acronym{ASCII}です(@ref{Non-ASCII
Characters}を参照)。キーボード入力を表す文字はコントロール(Control)、メタ(Meta)、シフト(Shift)などの修飾キーをエンコードするために、より広い範囲をもちます。

  文字から可読なテキスト記述を生成する、メッセージ用の特別な関数が存在します。@ref{Describing Characters}を参照してください。

@menu
* Basic Char Syntax::        標準的な文字の構文。
* General Escape Syntax::    文字をコードにより指定する方法。
* Ctl-Char Syntax::          コントロール文字の構文。
* Meta-Char Syntax::         メタ文字の構文。
* Other Char Bits::          ハイパー、スーパー、アルト文字の構文。
@end menu

@node Basic Char Syntax
@subsubsection 基本的な文字構文
@cindex read syntax for characters
@cindex printed representation for characters
@cindex syntax for characters
@cindex @samp{?} in character constant
@cindex question mark in character constant

  文字は実際には整数なので、文字のプリント表現は10進数です。文字にたいする入力構文も利用可能ですが、Lispプログラムでこの方法により文字を記述するのは、明解なプログラミングではありません。文字にたいしては、Emacs
Lispが提供する、特別な入力構文を@emph{常に}使用するべきです。これらの構文フォーマットはクエスチョンマークで開始されます。

  英数字にたいする通常の入力構文は、クエスチョンマークと、その後にその文字を記述します。したがって文字@kbd{A}は@samp{?A}、文字@kbd{B}は@samp{?B}、文字@kbd{a}は@samp{?a}となります。

  たとえば:

@example
?Q @result{} 81     ?q @result{} 113
@end example

  区切り文字(punctuation
characters)にも同じ構文を使用できますが、区切り文字がLispで特別な意味をもつ場合には@samp{\\}でクォートしなければなりません。たとえば@samp{?\\(}が開カッコを記述する方法であり、同様に文字が@samp{\}なら、@samp{?\\}のようにクォートするために2つ目の@samp{\}を使用しなければなりません。

@cindex whitespace
@cindex bell character
@cindex @samp{\a}
@cindex backspace
@cindex @samp{\b}
@cindex tab (ASCII character)
@cindex @samp{\t}
@cindex vertical tab
@cindex @samp{\v}
@cindex formfeed
@cindex @samp{\f}
@cindex newline
@cindex @samp{\n}
@cindex return (ASCII character)
@cindex @samp{\r}
@cindex escape (ASCII character)
@cindex @samp{\e}
@cindex space (ASCII character)
@cindex @samp{\s}
  Ctrl+g(control-g)、バックスペース(backspace)、タブ(tab)、改行(newline)、垂直タブ(vertical
tab)、フォームフィード(formfeed)、スペース(space)、キャリッジリターン(return)、デリート(del)、エスケープ(escape)はそれぞれ@samp{?\a}、@samp{?\b}、@samp{?\t}、@samp{?\n}、@samp{?\v}、@samp{?\f}、@samp{?\s}、@samp{?\r}、@samp{?\d}、@samp{?\e}と表すことができます(後にダッシュのついた@samp{?\s}は違う意味をもつ
--- これは後続の文字にたいしてスーパーによる修飾を適用する)。したがって、

@example
?\a @result{} 7                 ; @r{control-g、@kbd{C-g}}
?\b @result{} 8                 ; @r{バックスペース、@key{BS}、@kbd{C-h}}
?\t @result{} 9                 ; @r{タブ、@key{TAB}、@kbd{C-i}}
?\n @result{} 10                ; @r{改行、@kbd{C-j}}
?\v @result{} 11                ; @r{垂直タブ、@kbd{C-k}}
?\f @result{} 12                ; @r{フォームフィード文字、@kbd{C-l}}
?\r @result{} 13                ; @r{キャリッジリターン、@key{RET}、@kbd{C-m}}
?\e @result{} 27                ; @r{エスケープ文字、@key{ESC}、@kbd{C-[}}
?\s @result{} 32                ; @r{スペース文字、@key{SPC}}
?\\ @result{} 92                ; @r{バックスラッシュ文字、@kbd{\}}
?\d @result{} 127               ; @r{デリート文字、@key{DEL}}
@end example

@cindex escape sequence
  バックスラッシュがエスケープ文字の役割を果たすので、これらのバックスラッシュで始まるシーケンスは@dfn{エスケープシーケンス(escape
sequences)}とも呼ばれます。この用語法は文字@key{ESC}とは関係ありません。@samp{\s}は文字定数としての使用を意図しており、文字定数の内部では単にスペースを記述します。

  エスケープという特別な意味を与えずに、任意の文字の前にバックスラッシュの使用することは許されていて害もありません。したがって@samp{?\+}は@samp{?+}と等価です。ほとんどの文字の前にバックスラッシュを追加することに理由はありません。しかし文字@samp{()[]\;"}の前にはバックスラッシュを追加しなければならず、Lispコードを編集するEmacsコマンドが混乱するのを避けるために@samp{|'`#.,}の前にもバックスラッシュを追加するべきです。コードを読む人の混乱を避けるために、前に言及した@acronym{ASCII}文字と類似したUnicode文字の前にもバックスラッシュを追加する必要があります。これを奨励するために、@samp{‘}のような一般的には混乱を招くエスケープされていない文字をハイライトします。スペース、タブ、改行、フォームフィードのような空白文字の前にもバックスラッシュを追加できます。しかしタブやスペースspaceのような実際の空白文字のかわりに、@samp{\t}や@samp{\s}のような可読性のあるエスケープシーケンスを使用するほうが明解です(スペースを後にともなうバックスラッシュを記述する場合、後続のテキストと区別するために、文字定数の後に余分なスペースを記述すること)。

@node General Escape Syntax
@subsubsection 一般的なエスケープ構文

  特に重要なコントロール文字にたいする特別なエスケープシーケンスに加えて、Emacsは非@acronym{ASCII}テキスト文字の指定に使用できる、何種類かのエスケープ構文を提供します。

@enumerate
@item
@cindex @samp{\} in character constant
@cindex backslash in character constants
@cindex unicode character escape
もしあればUnicode名で文字を指定できる。@code{?\N@{@var{NAME}@}}は@var{NAME}という名前のUnicode文字を表す。したがって@samp{?\N@{LATIN
SMALL LETTER A WITH
GRAVE@}}は@code{?à}と等価でありUnicode文字のU+00E0を意味する。名前中のスペースを空白文字(改行)の非空のシーケンスにして複数行文字列の入力を簡略化できる。

@item
Unicode値で文字を指定できる。@code{?\N@{U+@var{X}@}}はUnicodeコードポイント@var{X}
(16進数値)を表す。また@code{?\u@var{xxxx}}と@code{?\U@var{xxxxxxxx}}はそれぞれコードポイント@var{xxxx}と@var{xxxxxxxx}を表す@var{x}は(1つの16進数字)。たとえば@code{?\N@{U+E0@}}、@code{?\u00e0}、@code{?\U000000E0}は@code{?à}と@samp{?\N@{LATIN
SMALL LETTER A WITH
GRAVE@}}に等しい。Unicode標準は@samp{U+@var{10ffff}}以下のコードポイントだけを定義するので、これより大きいコードポイントではEmacsはエラーをシグナルする。

@item
文字を16進の文字コードで指定できる。16進エスケープシーケンスはバックスラッシュ、@samp{x}、および16進の文字コードにより構成される。したがって@samp{?\x41}は文字@kbd{A}、@samp{?\x1}は文字@kbd{C-a}、@code{?\xe0}は文字@kbd{à}
(グレイブアクセントつきの@kbd{a})になる。任意の16進数を使用できるので、この方法で任意の文字を表すことができる。

@item
@cindex octal character code
8進の文字コードにより文字を指定できる。8進エスケープシーケンスは3桁までの8進数字をともなうバックスラッシュにより形成される。したがって@samp{?\101}は文字@kbd{A}、@samp{?\001}は文字@kbd{C-a}、@code{?\002}は文字@kbd{C-b}を表す。この方法で指定できるのは8進コード777までの文字のみ。

@end enumerate

  これらのエスケープシーケンスは文字列内でも使用されます。@ref{Non-ASCII in Strings}を参照してください。

@node Ctl-Char Syntax
@subsubsection コントロール文字構文

@cindex control characters
  他の入力構文を使用してコントロール文字を表すことができます。これは後にバックスラッシュ、カレット、対応する非コントロール文字(大文字か小文字)をともなうクエスチョンマークから構成されます。たとえば@samp{?\^I}と@samp{?\^i}はどちらも、値が9である文字@kbd{C-i}の有効な入力構文です。

  @samp{^}のかわりに@samp{C-}を使用することもできます。したがって@samp{?\C-i}は@samp{?\^I}や@samp{?\^i}と等価です。

@example
?\^I @result{} 9     ?\C-I @result{} 9
@end example

  文字列やバッファーの中では@acronym{ASCII}のコントロール文字だけが許されますが、キーボード入力にたいしては@samp{C-}により任意の文字をコントロール文字にすることができます。これらの非@acronym{ASCII}のコントロール文字にたいするコントロール文字には
@tex
非コントロール文字にたいするコードと同様に、@math{2^{26}}
@end tex
@ifnottex
非コントロール文字にたいするコードと同様に、2**26
@end ifnottex
ビットが含まれます。通常のテキスト端末には非@acronym{ASCII}コントロール文字を生成する方法がありませんが、Xやその他のウィンドウシステムを使用すれば簡単に生成することができます。

  歴史的な理由により、Emacsは@key{DEL}文字を@kbd{?}のコントロール文字として扱います:

@example
?\^? @result{} 127     ?\C-? @result{} 127
@end example

@noindent
結果として、Xでは有意な入力文字である@kbd{Control-?}文字を、@samp{\C-}を使用して表現することは今のところできません。さまざまなLispファイルがこの方法で@key{DEL}を参照するので、これを変更するのは簡単ではないのです。

  コントロール文字の表現はファイルや文字列内で見ることができますが、わたしたちは@samp{^}構文を推奨します。キーボード入力にたいするコントロール文字に好ましいのは、@samp{C-}構文です。どちらを使用するかはプログラムの意味に影響しませんが、プログラムを読む人の理解を助けるでしょう。

@node Meta-Char Syntax
@subsubsection メタ文字構文

@cindex meta characters
  @dfn{メタ文字(meta character)}とは、@key{META}修飾キーとともにタイプされた文字です。そのような文字を表す整数には
@tex
@math{2^{27}}
@end tex
@ifnottex
2**27
@end ifnottex
のビットがセットされています。基本的な文字コードの広い範囲を利用可能にするために、メタやその他の修飾にたいしては上位ビットを使用します。

  文字列では、メタ文字を示す@acronym{ASCII}文字に、
@tex
@math{2^{7}}
@end tex
@ifnottex
2**7
@end ifnottex
ビットが付加されます。したがって文字列に含めることができるメタ文字のコードは1から255の範囲となり、メタ文字は通常の@acronym{ASCII}文字のメタ修飾されたバージョンとなります。文字列内での@key{META}処理の詳細については、@ref{Strings
of Events}を参照してください。

  メタ文字の入力構文には@samp{\M-}を使用します。たとえば@samp{?\M-A}は@kbd{M-A}を意味します。8進文字コード(以下参照)や、@samp{\C-}、その他の文字にたいする他の構文とともに@samp{\M-}を使用できます。したがって、@kbd{M-A}は@samp{?\M-A}や@samp{?\M-\101}と記述できます。同様に@kbd{C-M-b}は@samp{?\M-\C-b}、@samp{?\C-\M-b}、@samp{?\M-\002}と記述することができます。

@node Other Char Bits
@subsubsection その他の文字修飾ビット

  グラフィック文字(graphic
character)のcaseは文字コードで示されます。たとえば@acronym{ASCII}では、文字@samp{a}と文字@samp{A}は区別されます。しかし@acronym{ASCII}にはコントロール文字が大文字なのか小文字なのかを表現する方法がありません。コントロール文字がタイプされたときシフトキーが使用されたかを示すために、Emacsは
@tex
@math{2^{25}}
@end tex
@ifnottex
2**25
@end ifnottex
のビットを使用します。この区別はX端末や、その他の特別な端末を使用しているときだけ可能です。通常のテキスト端末は、これらの違いを報告しません。シフトをあらわすビットのためのLisp構文は@samp{\S-}です。したがって@samp{?\C-\S-o}や@samp{?\C-\S-O}は、Shift+Ctrl+o文字を表します。

@cindex hyper characters
@cindex super characters
@cindex alt characters
  Xウィンドウシステムは文字にセットするために、他にも3つ@anchor{modifier bits}修飾ビット ---
@dfn{ハイパー(hyper)}、@dfn{スーパー(super)}、@dfn{アルト(alt)}を定義します。これらのビットにたいする構文は、@samp{\H-}、@samp{\s-}、@samp{\A-}です(これらのプレフィクスでは、caseは意味がある)。したがって@samp{?\H-\M-\A-x}は@kbd{Alt-Hyper-Meta-x}を表します(@samp{-}が後にない@samp{\s}はスペース文字を表すことに注意)。
@tex
数値としてはビット値@math{2^{22}}はアルト、@math{2^{23}}はスーパー、@math{2^{24}}はハイパーです。
@end tex
@ifnottex
数値としてはビット値2**22はアルト、2**23はスーパー、2**24はハイパーです。
@end ifnottex

@node Symbol Type
@subsection シンボル型

  GNU Emacs
Lispでの@dfn{シンボル(symbol)}とは、名前をもつオブジェクトです。シンボル名は、そのシンボルのプリント表現としての役割があります。Lispの通常の使用では、1つのobarray(@ref{Creating
Symbols}を参照)により、シンボル名は一意です --- 2つのシンボルが同じ名前をもつことはありません。

  シンボルは変数や関数名としての役割、プロパティーリストを保持する役割をもつことができます。データ構造内にそのようなシンボルが存在することが確実に認識できるように、他のすべてのLispオブジェクトから区別するためだけの役割をもつ場合もあります。与えられたコンテキストにおいて、通常はこれらのうちの1つの使用だけが意図されます。しかし3つすべての方法で、1つのシンボルを独立して使用することもできます。

  名前がコロン(@samp{:})で始まるシンボルは@dfn{キーワードシンボル(keyword
symbol)}と呼ばれます。これらのシンボルは自動的に定数として振る舞い、通常は未知のシンボルといくつかの特定の候補を比較することだけに使用されます。@ref{Constant
Variables}を参照してください。

@cindex @samp{\} in symbols
@cindex backslash in symbols
  シンボル名にはどんな文字でも含めることができます。ほとんどのシンボル名は英字、数字、@samp{-+=*/}などの区切り文字で記述されます。このような名前には特別な区切り文字は必要ありません。名前が数字のように見えない限り、名前にはどのような文字も使用できます(名前が数字のように見える場合は、名前の先頭に@samp{\}を記述して強制的にシンボルとして解釈させる)。文字@samp{_~!@@$%^&:<>@{@}?}はあまり使用されませんが、これらも特別な句読点文字を必要としません。他の文字も、バックスラッシュでエスケープすることにより、シンボル名に含めることができます。しかし文字列内でのバックスラッシュの使用とは対照的に、シンボル名でのバックスラッシュは、バックスラッシュの後の1文字をエスケープするだけです。たとえば文字列内では、@samp{\t}はタブ文字を表します。しかしシンボル名の中では、@samp{\t}は英字@samp{t}をクォートするに過ぎません。名前にタブ文字をもつシンボルを記述するには、(バックスラッシュを前置した)実際のタブを使用しなければなりません。しかし、そのようなことを行なうことは稀です。

@cindex CL note---case of letters
@quotation
@b{Common Lispに関する注意:}Common
Lispでは明示的にエスケープされない限り、小文字は常に大文字に``フォールド(folded)''される。Emacs
Lispでは大文字と小文字は区別される。
@end quotation

  以下はシンボル名の例です。4つ目の例の中の@samp{+}は、シンボルが数字として読み取られるのを防ぐためにエスケープされていることに注意してください。6つ目の例では、名前の残りの部分により数字としては不正なのでエスケープの必要はありません。

@example
@group
foo                 ; @r{@samp{foo}という名前のシンボル}
FOO                 ; @r{@samp{foo}とは別の、@samp{FOO}という名前のシンボル}
@end group
@group
1+                  ; @r{@samp{1+}という名前のシンボル}
                    ;   @r{(整数の@samp{+1}ではない)}
@end group
@group
\+1                 ; @r{@samp{+1}という名前のシンボル}
                    ;   @r{(判読しにくい名前)}
@end group
@group
@c the @'s in this next line use up three characters, hence the
@c apparent misalignment of the comment.
\(*\ 1\ 2\)         ; @r{@samp{(* 1 2)}という名前のシンボル(悪い名前)}
+-*/_~!@@$%^&=:<>@{@}  ; @r{@samp{+-*/_~!@@$%^&=:<>@{@}}という名前のシンボル}
                    ;   @r{これらの文字のエスケープは不要}
@end group
@end example

@cindex @samp{##} read syntax
@ifinfo
@c This uses "colon" instead of a literal ':' because Info cannot
@c cope with a ':' in a menu.
@cindex @samp{#@var{colon}} read syntax
@end ifinfo
@ifnotinfo
@cindex @samp{#:} read syntax
@end ifnotinfo
  シンボル名がプリント表現としての役割をもつというルールの例外として、@samp{##}があります。これは、名前が空文字列のinternされたシンボルのプリント表現です。さらに@samp{#:@var{foo}}は、internされていない@var{foo}という名前のシンボルにたいするプリント表現です(通常、Lispリーダーはすべてのシンボルをinternする。@ref{Creating
Symbols}を参照されたい)。

@node Sequence Type
@subsection シーケンス型

  @dfn{シーケンス(sequence)}とは、要素の順序セットを表現するLispオブジェクトです。Emacs Lispには2種類のシーケンス ---
@dfn{リスト(lists)}と@dfn{配列(arrays)}があります。

  リストはもっとも一般的に使用されるシーケンスです。リストは任意の型の要素を保持でき、要素の追加と削除により簡単に長さを変更できます。リストについては、次のサブセクションを参照してください。

  配列は固定長のシーケンスです。配列はさらに文字列(strings)、ベクター(vectors)、文字テーブル(char-tables)、ブールベクター(bool-vectors)に細分されます。ベクターは任意の型の要素を保持できますが、文字列の要素は文字でなければならず、ブールベクターの要素は@code{t}か@code{nil}でなければなりません。文字テーブルはベクターと似ていますが、有効な文字によりインデックスづけされる点が異なります。文字列内の文字は、バッファー内の文字のようにテキストプロパティーをもつことができます(@ref{Text
Properties}を参照)。しかしベクターはその要素が文字のときでも、テキストプロパティーをサポートしません。

  リスト、文字列、およびその他の配列型も、重要な類似点を共有します。たとえば、それらはすべて長さ@var{l}をもち、要素は0から@var{l}@minus{}1でインデックスづけされます。いくつかの関数はシーケンス関数と呼ばれ、これらは任意の種類のシーケンスを許容します。たとえば、関数@code{length}は、任意の種類のシーケンスの長さを報告します。@ref{Sequences
Arrays Vectors}を参照してください。

  シーケンスは読み取りにより常に新たに作成されるやめ、同じシーケンスを2回読み取るのは一般的に不可能です。シーケンスにたいする入力構文を2回読み取った場合には、内容が等しい2つのシーケンスを得ます。これには1つ例外があります。空リスト@code{()}は、常に同じオブジェクト@code{nil}を表します。

@node Cons Cell Type
@subsection コンスセルとリスト型
@cindex address field of register
@cindex decrement field of register
@cindex pointers

  @dfn{コンスセル(cons
cell)}は@sc{car}スロット、@sc{cdr}スロットと呼ばれる2つのスロットから構成されるオブジェクトです。それぞれのスロットはには、任意のLispオブジェクトを@dfn{保持}できます。そのとき@sc{car}スロットに保持されるオブジェクトが何であれ、わたしたちは``このコンスセルの@sc{car}''のような言い方をします。これは@sc{cdr}の場合も同様です。

@cindex list structure
  @dfn{リスト(list)}はコンスセルの連続するシリーズで、各コンスセルの@sc{cdr}スロットは次のコンスセル、または空リストを保持します。空リストは実際にはシンボル@code{nil}です。詳細については、@ref{Lists}を参照してください。ほとんどのコンスセルはリストの一部として使用されるので、わたしたちはコンスセルにより構成される任意の構造を、@dfn{リスト構造(list
structure)}という用語で参照します。

@cindex linked list
@quotation
Cプログラマーにたいする注意: Lispのリストはコンスセルにより構築される@dfn{リンクリスト(linked
list)}として機能する。Lispではポインターは暗黙的なので、コンスセルのスロットが値を``保持(hold)''するのか、それとも値を``指す(point)''のかは区別しない。
@end quotation

@cindex atoms
  コンスセルはLispの中核なので、コンスセルではないオブジェクトにたいする用語もあります。これらのオブジェクトは@dfn{アトム(atoms)}と呼ばれます。

@cindex parenthesis
@cindex @samp{(@dots{})} in lists
  リストにたいする入力構文とプリント表現は同じで左カッコ、任意の数の要素、右カコから構成されます。以下はリストの例です:

@example
(A 2 "A")            ; @r{3要素のリスト}
()                   ; @r{要素がないリスト(空リスト)}
nil                  ; @r{要素がないリスト(空リスト)}
("A ()")             ; @r{1要素のリスト: 文字列@code{"A ()"}}
(A ())               ; @r{2要素のリスト: @code{A}と空リスト}
(A nil)              ; @r{同上}
((A B C))            ; @r{1要素のリスト}
                     ;   @r{(この要素は、3要素のリスト)}
@end example

   読み取りではカッコの内側はリストの要素になります。つまりコンスセルは各要素から作成されます。コンスセルの@sc{car}スロットは要素を保持し、@sc{cdr}スロットはリスト内の次のコンスセル(このコンスセルはリスト内の次の要素をする)を参照します。最後のコンスセルの@sc{cdr}スロットは@code{nil}を保持するようにセットされます。

  @sc{car}や@sc{cdr}という名称はLispの歴史に由来します。オリジナルのLisp実装は@w{IBM
704}コンピューターで実行されていました。ワードを2つの部分、つまり``address''と呼ばれる部分と、``decrement''と呼ばれる部分に分割していて、その際@sc{car}はaddress部から内容を取り出す命令で、@sc{cdr}はdecrement部から内容を取り出す命令でした。これとは対照的に``cons
cells''は、これらを作成する関数@code{cons}から命名されました。この関数は関数の目的、すなわちセルを作る(construction of
cells)という目的から命名されました。

@menu
* Box Diagrams::             リストの図解。
* Dotted Pair Notation::     コンスセルの一般的な構文。
* Association List Type::    特別に構築されるリスト。
@end menu

@node Box Diagrams
@subsubsection ボックスダイアグラムによるリストの描写
@cindex box diagrams, for lists
@cindex diagrams, boxed, for lists

  コンスセルを表現するドミノのような1対のボックスによる図で、リストを説明することができます(Lispリーダーがこのような図を読み取ることはできない。人間とコンピューターが理解できるテキスト表記と異なり、ボックス図は人間だけが理解できる)。この図は3要素のリスト@code{(rose
violet buttercup)}を表したものです:

@example
@group
    --- ---      --- ---      --- ---
   |   |   |--> |   |   |--> |   |   |--> nil
    --- ---      --- ---      --- ---
     |            |            |
     |            |            |
      --> rose     --> violet   --> buttercup
@end group
@end example

  この図では、ボックスは任意のLispオブジェクトへの参照を保持できるスロットを表します。ボックスのペアーはコンスセルを表します。矢印はLispオブジェクト(アトム、または他のコンスセル)への参照を表します。

  この例では、1番目のボックスは1番目のコンスセルで、それの@sc{car}は@code{rose}(シンボル)を参照または保持します。2番目のボックスは1番目のコンスセルの@sc{cdr}を保持し、次のボックスペアすなわち2番目のコンスセルを参照します。2番目のコンスセルの@sc{car}は@code{violet}で、@sc{cdr}は3番目のコンスセルです。(最後の)3番目のコンスセルの@sc{cdr}は@code{nil}です。

  同じリスト@code{(rose violet buttercup)}を、違うやり方で描いた別の図で表してみましょう:

@smallexample
@group
 ---------------       ----------------       -------------------
| car   | cdr   |     | car    | cdr   |     | car       | cdr   |
| rose  |   o-------->| violet |   o-------->| buttercup |  nil  |
|       |       |     |        |       |     |           |       |
 ---------------       ----------------       -------------------
@end group
@end smallexample

@cindex @code{nil} as a list
@cindex empty list
  要素がないリストは@dfn{空リスト(empty
list)}で、これはシンボル@code{nil}と同じです。言い換えると@code{nil}はシンボルであり、かつリストでもあります。

  以下はリスト@code{(A ())}、または等価な@code{(A nil)}をボックスと矢印で描いたものです:

@example
@group
    --- ---      --- ---
   |   |   |--> |   |   |--> nil
    --- ---      --- ---
     |            |
     |            |
      --> A        --> nil
@end group
@end example

  以下はもっと複雑な例です。これは1番目の要素が2要素のリストであるような、3要素のリスト@code{((pine needles) oak
maple)}を表します:

@example
@group
    --- ---      --- ---      --- ---
   |   |   |--> |   |   |--> |   |   |--> nil
    --- ---      --- ---      --- ---
     |            |            |
     |            |            |
     |             --> oak      --> maple
     |
     |     --- ---      --- ---
      --> |   |   |--> |   |   |--> nil
           --- ---      --- ---
            |            |
            |            |
             --> pine     --> needles
@end group
@end example

  同じリストを2番目のボックス表記で表すと、以下のようになります:

@example
@group
 --------------       --------------       --------------
| car   | cdr  |     | car   | cdr  |     | car   | cdr  |
|   o   |   o------->| oak   |   o------->| maple |  nil |
|   |   |      |     |       |      |     |       |      |
 -- | ---------       --------------       --------------
    |
    |
    |        --------------       ----------------
    |       | car   | cdr  |     | car     | cdr  |
     ------>| pine  |   o------->| needles |  nil |
            |       |      |     |         |      |
             --------------       ----------------
@end group
@end example

@node Dotted Pair Notation
@subsubsection ドットペア表記
@cindex dotted pair notation
@cindex @samp{.} in lists

  @dfn{ドットペア表記(dotted pair
notation)}は、@sc{car}と@sc{cdr}が明示的に表されたコンスセルの一般的な構文です。この構文では@code{(@var{a}
.@:
@var{b})}が@sc{car}がオブジェクト@var{a}、@sc{cdr}がオブジェクト@var{b}という意味になります。@sc{cdr}がリストである必要がないので、ドットペア表記はより一般的なリスト構文です。しかしリスト構文が機能するような場合には、より扱いにくくなります。ドットペア表記では、リスト@samp{(1
2 3)}は@samp{(1 .  (2 . (3
.
nil)))}と記述されます。@code{nil}で終端されたリストにたいしては、どちらの表記法も使用できますが、リスト表記の方が通常は明解で便利です。リストをプリントする場合には、コンスセルの@sc{cdr}がリストでないときだけドットペア表記が使用されます。

  以下はボックスを使用してドットペア表記を表した例です。これはペア@code{(rose . violet)}を表します:

@example
@group
    --- ---
   |   |   |--> violet
    --- ---
     |
     |
      --> rose
@end group
@end example

  最後の@sc{cdr}が非@code{nil}のコンスセルのチェーンを表すので、ドットペア表記とリスト表記を組み合わせることができます。リストの最後の要素の後にドットを記述して、その後に最後のコンスセルの@sc{cdr}を記述します。たとえば@code{(rose
violet . buttercup)}は、@code{(rose . (violet
. buttercup))}と等価です。オブジェクトは以下のようになります:

@example
@group
    --- ---      --- ---
   |   |   |--> |   |   |--> buttercup
    --- ---      --- ---
     |            |
     |            |
      --> rose     --> violet
@end group
@end example

  構文@code{(rose .@: violet .@:
buttercup)}は無効です。なぜならこれは何も意味していないからです。何か意味があるとしても、@code{violet}のために@sc{cdr}がすでに使用されているコンスセルの@sc{cdr}に、@code{buttercup}を置くということになります。

  リスト@code{(rose violet)}は@code{(rose . (violet))}と等価であり、以下のようになります:

@example
@group
    --- ---      --- ---
   |   |   |--> |   |   |--> nil
    --- ---      --- ---
     |            |
     |            |
      --> rose     --> violet
@end group
@end example

  同様に3要素のリスト@code{(rose violet buttercup)}は、@code{(rose . (violet
. (buttercup)))}と等価です。
@ifnottex
これは以下のようになります:

@example
@group
    --- ---      --- ---      --- ---
   |   |   |--> |   |   |--> |   |   |--> nil
    --- ---      --- ---      --- ---
     |            |            |
     |            |            |
      --> rose     --> violet   --> buttercup
@end group
@end example
@end ifnottex

@node Association List Type
@subsubsection 連想リスト型

  @dfn{連想リスト(association
list)}または@dfn{alist}は、要素がコンスセルであるように特別に構成されたリストです。各要素においては、@sc{car}が@dfn{キー(key)}で、@sc{cdr}が@dfn{連想値(associated
value)}であると考えます(連想値が@sc{cdr}の@sc{car}に保存される場合もある)。リストの先頭への連想値の追加と削除は簡単なので、連想リストはスタック(stack)にしばしば使用されます。

  たとえば、

@example
(setq alist-of-colors
      '((rose . red) (lily . white) (buttercup . yellow)))
@end example

@noindent
これは変数@code{alist-of-colors}に3要素のalistをセットします。最初の要素では、@code{rose}がキーで@code{red}が値になります。

  alistとalist関数についての詳細な説明は@ref{Association
Lists}を参照してください。(多くのキーの操作をより高速に行なう)テーブルを照合する他の手段については@ref{Hash
Tables}を参照してください。

@node Array Type
@subsection 配列型

  @dfn{配列(array)}は、他のLispオブジェクトを保持または参照する任意の数のスロットから構成され、メモリーの連続ブロックに配列されます。配列の任意の要素へのアクセス時間は大体同じです。対照的にリストの要素にたいするアクセスは、リスト内でのその要素の位置に比例した時間を要します(リストの最後の要素にアクセスするにはリストの最初の要素にアクセスするより長い時間が必要)。

  Emacsは文字列(strings)、ベクター(vectors)、ブールベクター(bool-vectors)、文字テーブル(char-tables)という4種の配列を定義します。

  文字列は文字の配列であり、ベクターは任意のオブジェクトの配列です。ブールベクターは@code{t}か@code{nil}だけを保持できます。この種の配列はシステムアーキテクチャー制限と利用可能なメモリーにしたがったもっとも大きいfixnumまでの任意の長さをもつことができます。文字テーブルは、任意の有効な文字コードによりインデックスづけされる疎な配列であり、任意のオブジェクトを保持することができます。

  配列の最初の要素はインデックス0、2番目の要素はインデックス1、...となります。これは@dfn{0基準(zero-origin)}のインデックスづけと呼ばれます。たとえば、4要素の配列はインデックス0、1、2、3をもちます。利用できる最大のインデックス値は、配列の長さより1つ小さくなります。▼一度配列が作成されると、長さは固定されます。

  Emacs
Lispのすべての配列は、1次元です(他のほとんどのプログラミング言語は多次元配列をサポートするが、これらは必須ではない。ネストされた1次元配列により同じ効果を得ることが可能)。各種の配列は独自の入力構文をもちます。詳細は以降のセクションを参照してください。

  配列型はシーケンス型のサブセットであり文字列型、ベクター型、ブールベクター型、文字テーブル型が含まれます。

@node String Type
@subsection 文字列型

  @dfn{文字列(string)}とは文字の配列です。Emacsがテキストエディターであることから予想できるように、文字列はたとえばLispシンボルの名前、ユーザーへのメッセージ、バッファーから抽出されたテキストの表現など多くの目的のために使用されます。Lispの文字列は定数です。文字列を評価すると、それと同じ文字列がリターンされます。

  文字列を操作する関数については@ref{Strings and Characters}を参照してください。

@menu
* Syntax for Strings::       Lisp文字列を指定する方法。
* Non-ASCII in Strings::     文字列内の国際化文字。
* Nonprinting Characters::   文字列内の印刷不可能なリテラル文字。
* Text Props and Strings::   テキストプロパティーをもつ文字列。
@end menu

@node Syntax for Strings
@subsubsection 文字列の構文

@cindex @samp{"} in strings
@cindex double-quote in strings
@cindex @samp{\} in strings
@cindex backslash in strings
  文字列にたいする入力構文は@code{"like
this"}のようにダブルクォート、任意個数の文字、もう1つのダブルクォートから構成されます。文字列内にダブルクォートを含める場合は、それの前にバックスラッシュを記述します。したがって@code{"\""}は1つのダブルクォート文字だけを含む文字列です。同様にバックスラッシュを含める場合は、@code{"this
\\ is a single embedded backslash"}のように、それの前にもう1つのバックスラッシュを記述します。

@cindex newline in strings
  文字列にたいする入力構文では、改行(newline)は特別ではありません。ダブルクォートの間に改行を記述すれば、その改行は文字列内の文字となります。しかしエスケープされた改行
--- 前に@samp{\}をともなう改行 --- は文字列の一部とはなりません。同様にエスケープされたスペース@w{@samp{\ 
}}も無視されます。

@example
"It is useful to include newlines
in documentation strings,
but the newline is \
ignored if escaped."
     @result{} "It is useful to include newlines
in documentation strings,
but the newline is ignored if escaped."
@end example

@node Non-ASCII in Strings
@subsubsection 文字列内の非@acronym{ASCII}文字

  Emacdの文字列内の非@acronym{ASCII}文字にたいしては2つのテキスト表現 ---
マルチバイト(multibyte)とユニバイト(unibyte)があります(@ref{Text
Representations}を参照)。大まかに言うとユニバイト文字列にはraw(生)バイトが保存され、マルチバイト文字列には人間が読めるテキストが保存されます。ユニバイト文字列内の各文字はバイトであり、値は0から255となります。対照的にマルチバイト文字列内の各文字は、0から4194303の値をもつかもしれません(@ref{Character
Type}を参照)。いずれも127より上の文字は非@acronym{ASCII}です。

  文字をリテラルとして記述することにより、文字列に非@acronym{ASCII}文字を含めることができます。マルチバイトのバッファーや文字列、あるいはマルチバイトとしてvisitされたファイル等、マルチバイトのソースから文字列定数を読み込む場合、Emacsは非@acronym{ASCII}文字をマルチバイト文字として読み取り、その文字列を自動的にマルチバイト文字列にします。ユニバイトのソースから文字列定数を読み込む場合、Emacsは非@acronym{ASCII}文字をユニバイト文字として読み取り、その文字列をユニバイト文字列にします。

  マルチバイト文字列内にリテラルとして文字を記述するかわりに、エスケープシーケンスを使用して文字コードとして記述できます。エスケープシーケンスについての詳細は、@ref{General
Escape Syntax}を参照してください。

  文字列定数内でUnicodeスタイルのエスケープシーケンス@samp{\uNNNN}または@samp{\U00NNNNNN}を使用する場合、(たとえ@acronym{ASCII}文字であっても)Emacsは自動的に文字列をマルチバイトとみなします。

  文字列定数内で16進エスケープシーケンス(@samp{\x@var{n}})と8進エスケープシーケンス(@samp{\@var{n}})を使用することもできます。@strong{しかし注意してください:
}文字列定数が16進または8進のエスケープシーケンスを含み、それらのエスケープシーケンスすべてがユニバイト文字(256より小)を指定していて、その文字列内に他にリテラルの非@acronym{ASCII}文字またはUnicodeスタイルのエスケープシーケンスが存在しない場合、Emacsは自動的に文字列をユニバイト文字列とみなします。つまり文字列内のすべての非@acronym{ASCII}文字は8ビットのrawバイトとみなされます。

  16進および8進のエスケープシーケンスでは、エスケープされた文字コードに可変個の数字が含まれるかもしれないので、それに続く文字で16進および8進として有効ではない最初の文字は、そのエスケープシーケンスを終了させます。文字列内の次の文字が16進または8進として解釈できる文字の場合は、@w{@samp{\ 
}}(バックスラッシュとスペース)を記述して、エスケープシーケンスを終了できます。たとえば@w{@samp{\xe0\ }}はgrave
accentつきの@samp{a}という1文字を表します。文字列内の@w{@samp{\ 
}}はバックスラッシュ改行と同様です。これは文字列内の文字とはなりませんが、先行する16進エスケープを終了します。

@node Nonprinting Characters
@subsubsection 文字列内の非プリント文字

  リテラル文字と同様に、文字列定数内でバックスラッシュによるエスケープシーケンスを使用できます(ただし文字定数を開始するクエスチョンマークは使用しない)。たとえば非プリント文字のタブと@kbd{C-a}を含む文字列は、@code{"\t,
\C-a"}のように、それらの間にカンマとスペースを記述します。文字にたいする入力構文については@ref{Character
Type}を参照してください。

  しかしバックスラッシュによるエスケープシーケンスとともに記述できるすべての文字が、文字列内で有効というわけではありません。文字列が保持できるコントロール文字は@acronym{ASCII}コントロール文字だけです。@acronym{ASCII}コントロール文字では、文字列のcaseは区別されません。

  正確に言うと、文字列はメタ文字を保持できません。しかし文字列がキーシーケンスとして使用される場合には、文字列内でメタ修飾された@acronym{ASCII}文字を表現するための方法を提供する特別な慣習があります。文字列定数内でメタ文字を示すために@samp{\M-}構文を使用した場合、これは文字列内の文字の
@tex
@math{2^{7}}
@end tex
@ifnottex
2**7
@end ifnottex
のビットをセットします。その文字列が@code{define-key}または@code{lookup-key}で使用される場合、この数字コードは等価なメタ文字に変換されます。@ref{Character
Type}を参照してください。

  文字列はハイパー(hyper)、スーパー(super)、アルト(alt)で修飾された文字を保持できません。

@node Text Props and Strings
@subsubsection 文字列内のテキストプロパティ

@cindex @samp{#(} read syntax
@cindex text properties, read syntax
  文字列にはその文字自身に加えて、文字のプロパティーも保持することができます。これにより特別なことをしなくても、文字列とバッファーとの間でテキストをコピーするプログラムが、テキストプロパティーをコピーすることが可能になります。テキストプロパティーが何を意味するかについては@ref{Text
Properties}を参照してください。テキストプロパティーをもつ文字列は、特別な入力構文とプリント構文を使用します。

@example
#("@var{characters}" @var{property-data}...)
@end example

@noindent
ここで@var{property-data}は,3個でグループ化された0個以上の要素から構成されます:

@example
@var{beg} @var{end} @var{plist}
@end example

@noindent
要素@var{beg}および@var{end}は整数で、文字列内のインデックスの範囲を指定します。@var{plist}はその範囲にたいするプロパティーリストです。たとえば、

@example
#("foo bar" 0 3 (face bold) 3 4 nil 4 7 (face italic))
@end example

@noindent
これはテキスト内容が@samp{foo
bar}で、最初の3文字は@code{face}プロパティーに値@code{bold}をもち、最後の3文字は@code{face}プロパティーに値@code{italic}をもつことを表します(4番目の文字にはテキストプロパティーはないので、プロパティーリストは@code{nil}。実際には範囲の中の指定されていない文字はデフォルトではプロパティーをもたないので、範囲のプロパティーリストを@code{nil}と指定する必要ない)。

@node Vector Type
@subsection ベクター型

  @dfn{ベクター(vector)}は任意の型の要素からなる1次元の配列です。ベクター内の任意の要素へのアクセスに要す時間は一定です(リストの場合では要素へのアクセスに要す時間は、リストの先頭からその要素までの距離に比例する)。

  ベクターのプリント表現は左角カッコ(left square bracket)、要素、右角カッコ(right square
bracket)から構成されます。これは入力構文でもあります。数字や文字列と同様にベクターは評価において定数と判断されます。

@example
[1 "two" (three)]      ; @r{3要素のベクター}
     @result{} [1 "two" (three)]
@end example

  ベクターに作用する関数については@ref{Vectors}を参照してください。

@node Char-Table Type
@subsection 文字テーブル型

  @dfn{文字テーブル(char-table)}は任意の型の要素をもつ1次元の配列であり、文字コードによりインデックスづけされます。文字テーブルは、文字コードに情報を割り当てることを必要とする多くの処理を簡単にするための、特別な追加の機能をもちます
---
たとえば文字テーブルは継承する親、デフォルト値、特別な目的のために使用する余分なスロットをいくつかもつことができます。文字テーブルは文字セット全体にたいして1つの値を指定することもできます。

@cindex @samp{#^} read syntax
  文字テーブルのプリント表現はベクターと似ていますが、最初に余分な@samp{#^}があります@footnote{副文字テーブル(sub-char-tables)に使用される@samp{#^^}を目にすることがあるかもしれません。}。

  文字テーブルを操作する特別な関数については@ref{Char-Tables}を参照してください。文字テーブルの使用には以下が含まれます:

@itemize @bullet
@item
caseテーブル(@ref{Case Tables}を参照)。

@item
文字カテゴリーテーブル(@ref{Categories}を参照)。

@item
ディスプレーテーブル(@ref{Display Tables}を参照)。

@item
構文テーブル(@ref{Syntax Tables}を参照)。
@end itemize

@node Bool-Vector Type
@subsection ブールベクター型

  @dfn{ブールベクター(bool-vector)}は、要素が@code{t}か@code{nil}のいずれかでなければならない1次元の配列です。

  ブールベクターのプリント表現は文字列と似ていますが、後に長さを記述した@samp{#&}で始まります。これに続く文字列定数は、ビットマップとして実際に内容を指定するブールベクターです
---
文字列定数内のそれぞれの``文字''は8ビットを含み、これはブールベクターの次の8要素を指定します(1は@code{t}、0は@code{nil}です)。文字の最下位ビットブールベクターの最下位のインデックスに対応します。

@example
(make-bool-vector 3 t)
     @result{} #&3"^G"
(make-bool-vector 3 nil)
     @result{} #&3"^@@"
@end example

@noindent
@samp{C-g}の2進コードは111、@samp{C-@@}はコード0の文字なのでこの結果は理にかなっています。

  長さが8の倍数でなければプリント表現には余分な要素が表示されますが、これらの余分な要素に意味はありません。たとえば以下の例では、最初の3ビットだけが使用されるので2つのブールベクターは等価です:

@example
(equal #&3"\377" #&3"\007")
     @result{} t
@end example

@node Hash Table Type
@subsection ハッシュテーブル型

    ハッシュテーブルは非常に高速な照合テーブルの一種で、キーを対応する値にマップするalistと似ていますがより高速です。ハッシュテーブルのプリント表現では、以下のようにハッシュテーブルのプロパティーと内容を指定します:

@example
(make-hash-table)
     @result{} #s(hash-table size 65 test eql rehash-size 1.5
                             rehash-threshold 0.8125 data ())
@end example

@noindent
ハッシュテーブルについての詳細は@ref{Hash Tables}を参照してください。

@node Function Type
@subsection 関数型

  他のプログラミング言語の関数と同様、Lisp関数は実行可能なコードです。他の言語と異なり、Lispの関数はLispオブジェクトでもあります。Lispのコンパイルされていない関数はラムダ式
--- つまり1番目の要素がシンボル@code{lambda}であるリストです(@ref{Lambda Expressions}を参照)。

  ほとんどのプログラミング言語では名前のない関数はありません。Lispでは関数に本質的な名前はありません。名前がなくてもラムダ式を関数として呼び出すことができます。これを強調するために、わたしたちはこれを@dfn{無名関数(anonymous
function)}とも呼びます(@ref{Anonymous
Functions}を参照)。Lispの名前つき関数は関数セルに有効な関数がセットされた単なるシンボルです(@ref{Defining
Functions}を参照)。

  ほとんどの場合、関数はLispプログラム内のLisp式の名前が記述されたところで呼び出されます。しかし実行時に関数オブジェクトを構築または取得してから、プリミティブ関数@code{funcall}および@code{apply}により呼び出すことができます。@ref{Calling
Functions}を参照してください。

@node Macro Type
@subsection マクロ型

  @dfn{Lispマクロ(Lisp
macro)}はLisp言語を拡張するユーザー定義の構成です。これはオブジェクトとしてではなく関数のように表現されますが、引数の渡し方の意味が異なります。Lispマクロの形式はリストです。これは最初の要素が@code{macro}で、@sc{cdr}がLisp関数オブジェクト(@code{lambda}シンボルを含む)であるようなリストです。

  Lispマクロオブジェクトは通常、ビルトインの@code{defmacro}関数で定義されますが、@code{macro}で始まる任意のリストもEmacsにとってはマクロです。マクロを記述する方法の説明は@ref{Macros}を参照してください。

  @strong{警告}: Lispマクロとキーボードマクロ(@ref{Keyboard
Macros}を参照)は完全に別の物である。修飾なしで``マクロ''という単語を使用したときは、キーボードマクロではなくLispマクロのことを指す。

@node Primitive Function Type
@subsection プリミティブ関数型
@cindex primitive function

  @dfn{プリミティブ関数(primitive
function)}とは、Cプログラミング言語で記述されたLispから呼び出せる関数です。プリミティブ関数は@dfn{subrs}や@dfn{ビルトイン関数(built-in
functions)}とも呼ばれます(単語``subr''は``サブルーチン(subroutine)''が由来)。ほとんどのプリミティブ関数ハ、呼び出されたときニすべての引数を評価します。すべての引数を評価しないプリミティブ関数は@dfn{スペシャルフォーム(special
form)}と呼ばれます(@ref{Special Forms}を参照)。

  呼び出す側からすれば、その関数がプリミティブ関数かどうかは問題になりません。しかしプリミティブ関数をLispで記述された関数で再定義した場合に問題になります。理由はそのプリミティブ関数がCコードから直接呼び出されているかもしれないからです。Lispから再定義した関数を呼び出すと新しい定義を使用するでしょうが、Cコードから呼び出すとビルトインの定義が使用されるでしょう。したがって、@strong{プリミティブ関数の再定義はしないでください}。

  @dfn{関数(function)}という用語で、LispやCで記述されたすべてのEmacs関数を参照します。Lispで記述された関数についての情報は@ref{Function
Type}を参照してください。

  プリミティブ関数に入力構文はなく、サブルーチン名とともにハッシュ表記でプリントします。

@example
@group
(symbol-function 'car)          ; @r{そのシンボルの関数セルに}
                                ;     @r{アクセスする}
     @result{} #<subr car>
(subrp (symbol-function 'car))  ; @r{これはプリミティブ関数?}
     @result{} t                ;    @r{そのとおり}
@end group
@end example

@node Byte-Code Type
@subsection バイトコード関数型

@dfn{バイトコード関数オブジェクト(byte-code function
objects)}は、Lispコードをバイトコンパイルすることにより生成されます(@ref{Byte
Compilation}を参照)。バイトコード関数オブジェクトは、内部的にはベクターによく似ています。しかしバイトコード関数オブジェクトが関数呼び出しのように見える場合、評価プロセスによりこのデータ型は特別に処理されます。@ref{Byte-Code
Objects}を参照してください。

バイトコード関数オブジェクトのプリント表現と入力構文はベクターのものと似ていますが、開き角カッコ@samp{[}の前に@samp{#}があります。

@node Record Type
@subsection レコード型

  @dfn{レコード(record)}は@code{vector}と似ていますが、最初の要素は@code{type-of}でリターンされる型を保持するために使用されます。レコードの主要目的はプログラマーがEmacsのビルトインではない新たな型を作成することを可能にすることです。

  レコードに作用する関数については@ref{Records}を参照してください。

@node Type Descriptors
@subsection 型記述子

  @dfn{型記述子(type
descriptor)}は型に関する情報を保持する@code{record}です。レコードの1スロット目には型を命名するシンボルでなければならず、@code{type-of}は@code{record}オブジェクトの型をリターンするためにこれに依存しています。他の型記述子スロットをEmacsは使用しません。これらをLisp拡張が使用するのは自由です。

@code{cl-structure-class}のインスタンスはすべて型記述子の例です。

@node Autoload Type
@subsection autoload型

  @dfn{autoloadオブジェクト(autoload
object)}は、最初の要素がシンボル@code{autoload}のリストです。これはシンボルの関数定義として保存され、実際の定義にたいする代替としての役割をもちます。autoloadオブジェクトは、必要な時にロードされるLispコードファイルの中で実際の定義を見つけることができることを宣言します。これにはファイル名と、それに加えて実際の定義についての他のいくつかの情報が含まれます。

  ファイルのロード後、そのシンボルはautoloadオブジェクトではない新しい関数定義をもつはずです。新しい定義は、最初からそこにあったかのように呼び出されます。ユーザーの観点からは関数呼び出しは期待された動作、つまりロードされたファイル内の関数定義を使用します。

  autoloadオブジェクトは通常、シンボルの関数セルにオブジェクトを保存する関数@code{autoload}により作成されます。詳細は@ref{Autoload}を参照してください。

@node Finalizer Type
@subsection ファイナライザー型

  @dfn{ファイナライザーオブジェクト(finalizer
object)}は、オブジェクトがもはや必要なくなった後のLispコードのクリーンアップを助けます。ファイナライザーは、Lisp関数オブジェクトを保持します。ガーベージコレクションのオアス後にファイナライザーオブジェクトが到達不能になったとき、Emacsはそのファイナライザーに関連付けられた関数オブジェクトを呼び出します。ファイナライザーの到達可否の判定時、もしかしてファイナライザーオブジェクト自身が参照を離さないのではないかと心配することなくファイナライザーを使用できるように、Emacsはファイナラーオブジェト自身からの参照は勘定しません。

ファイナラーザー内でのエラーは@code{*Messages*}にプリントされます。その関数が失敗しても、Emacsは与えられたファイナライザーオブジェクトに関連付けられた関数を正確に1回実行します。

@defun make-finalizer function
@var{function}を実行するファイナライザーを作成する。@var{function}はガーベージコレクション後、リターンされたファイナライザーオブジェクトが到達不能になったときに実行される。そのファイナライザーオブジェクトがファイナライザーオブジェクトからの参照を通じてのみ到達可能なら、@var{function}の実行是非の判断時の目的にたいして、それは到達可能とみなされない。@var{function}はファイナライザーオブジェクトごとに1回実行される。
@end defun

@node Editing Types
@section 編集用の型
@cindex editing types

  前セクションの型は一般的なプログラミング目的のために使用され、これらの型のほとんどはLisp方言のほとんどで一般的です。Emacs
Lispは編集に関する目的のために、いくつかの追加のデータ型を提供します。

@menu
* Buffer Type::              編集のための基本オブジェクト。
* Marker Type::              バッファー内の位置。
* Window Type::              バッファーはウィンドウ内に表示される。
* Frame Type::               ウィンドウはフレームを細分化する。
* Terminal Type::            フレームを表示する端末デバイス。
* Window Configuration Type::  フレームが細分化された方法を記録する。
* Frame Configuration Type::  すべてのフレームの状態を記録する。
* Process Type::             背後のOS上で実行されるEmacsのサブプロセス。
* Thread Type::              Emacs Lispの実行スレッド。
* Mutex Type::               スレッド同期のための排他ロック。
* Condition Variable Type::  スレッド同期のための状態変数。
* Stream Type::              文字の受信と送信。
* Keymap Type::              どのキーストロークがどの関数を呼び出すか。
* Overlay Type::             オーバーレイが表示される方法。
* Font Type::                テキストを表示するフォント。
@end menu

@node Buffer Type
@subsection バッファー型

  @dfn{バッファー(buffer)}とは、編集されるテキストを保持するオブジェクトです(@ref{Buffers}を参照)。ほとんどのバッファーはディスクファイル(@ref{Files}を参照)の内容を保持するので編集できますが、他の目的のために使用されるものもいくつかあります。ほとんどのバッファーはユーザーにより閲覧されることも意図しているので、いつかはウィンドウ内(@ref{Windows}を参照)に表示されます。しかしバッファーはウィンドウに表示される必要はありません。バッファーはそれぞれ、@dfn{ポイント(point)}と呼ばれる位置指定をもちます(@ref{Positions}を参照)。ほとんどの編集コマンドは、カレントバッファー内のポイントに隣接する内容を処理します。常に1つのバッファーが@dfn{カレントバッファー(current
buffer)}です。

  バッファーの内容は文字列によく似ていますが、バッファーはEmacs
Lispの文字列と同じようには使用されず、利用可能な操作は異なります。文字列にテキストを挿入するためには部分文字列の結合が必要で、結果は完全に新しい文字列オブジェクトなのるのにたいして、バッファーでは既存のバッファーに効率的にテキストを挿入してバッファーの内容を変更できます。

  標準的なEmacs関数の多くは、カレントバッファー内の文字を操作したりテストするためのものです。このマニュアルはこれらの関数の説明のために、1つのチャプターを設けています(@ref{Text}を参照)。

  他のデータ構造のいくつかは、各バッファーに関連付けられています:

@itemize @bullet
@item
ローカル構文テーブル(@ref{Syntax Tables}を参照)。

@item
ローカルキーマップ(@ref{Keymaps}を参照)。

@item
バッファーローカルな変数バインディングのリスト(@ref{Buffer-Local Variables}を参照)。

@item
オーバーレイ(@ref{Overlays}を参照)。

@item
バッファー内のテキストにたいするテキストプロパティー(@ref{Text Properties}を参照)。
@end itemize

@noindent
ローカルキーマップと変数リストは、グローバルなバインディングや値を個別にオーバーライドするためのエントリーを含みます。これらは実際にプログラムを変更することなく、異なるバッファーでプログラムの振る舞いをカスタマイズするために使用されます。

  バッファーは@dfn{インダイレクト(indirect: 間接)} --- つまり他のバッファーとテキストを共有するがそれぞれ別に表示する ---
かもしれません。@ref{Indirect Buffers}を参照してください。

  バッファーに入力構文はありません。バッファーはバッファー名を含むハッシュ表記でプリントされます。

@example
@group
(current-buffer)
     @result{} #<buffer objects-ja.texi>
@end group
@end example

@node Marker Type
@subsection マーカー型

  @dfn{マーカー(marker)}は特定のバッファー内の位置を表します。したがってマーカーには2つの内容 --- 1つはバッファー、もう1つは位置
---
をもちます。バッファーのテキストの変更では、マーカーが常にバッファー内の同じ2つの文字の間に位置することを確実にするために、必要に応じて自動的に位置の値が再配置されます。

  マーカーは入力構文をもちません。マーカーはカレントの文字位置とそのバッファー名を与える、ハッシュ表記でプリントされます。

@example
@group
(point-marker)
     @result{} #<marker at 10779 in objects-ja.texi>
@end group
@end example

マーカーのテスト、作成、コピー、移動の方法についての情報は@ref{Markers}を参照してください。

@node Window Type
@subsection ウィンドウ型

  @dfn{ウィンドウ(window)}はEmacsがバッファーを表示するために使用する端末スクリーンの部分を記述します。すべてのウィンドウは関連付けられた1つのバッファーをもち、バッファーの内容はそのウィンドウに表示されます。それとは対照的に、あるバッファーは1つのウィンドウに表示されるか表示されないか、それとも複数のウィンドウに表示されるかもしれません。

  同時に複数のウィンドウが存在するかもしれませんが、常に1つのウィンドウが@dfn{選択されたウィンドウ(selected
window)}になります。Emacsがコマンドにたいして準備できているときは、(通常は)カーソルが表示されるウィンドウが選択されたウィンドウです。選択されたウィンドウは、通常はカレントバッファー(@ref{Current
Buffer}を参照)を表示しますがこれは必須ではありません。

  スクリーン上でウィンドウはフレームにグループ化されます。ウィンドウはそれぞれ、ただ1つのフレームだけに属します。@ref{Frame
Type}を参照してください。

  ウィンドウは入力構文をもちません。ウィンドウはウィンドウ番号と表示されているバッファー名を与える、ハッシュ表記でプリントされます。与えられたウィンドウに表示されるバッファーは頻繁に変更されるかもしれないので、一意にウィンドウを識別するためにウィンドウ番号が存在します。

@example
@group
(selected-window)
     @result{} #<window 1 on objects-ja.texi>
@end group
@end example

  ウィンドウに作用する関数の説明は@ref{Windows}を参照してください。

@node Frame Type
@subsection フレーム型

  @dfn{フレーム(frame)}とは１つ以上のEmacsウィンドウを含むスクリーン領域です。スクリーン領域を参照するためにEmacsが使用するLispオブジェクトを指す場合にも``フレーム''という用語を使用します。

  フレームは入力構文をもちません。フレームはフレームのタイトルとメモリー内のアドレス(フレームを一意に識別するのに有用)を与えるハッシュ表記でプリントされます。

@example
@group
(selected-frame)
     @result{} #<frame emacs@@psilocin.gnu.org 0xdac80>
@end group
@end example

  フレームに作用する関数の説明は@ref{Frames}を参照してください。

@node Terminal Type
@subsection 端末型
@cindex terminal type

  @dfn{端末(terminal)}は1つ以上のEmacsフレーム(@ref{Frame Type}を参照)を表示する能力があるデバイスです。

  端末は入力構文をもちません。端末はその端末の順序番号とTTYデバイスファイル名を与える、ハッシュ表記でプリントされます。

@example
@group
(get-device-terminal nil)
     @result{} #<terminal 1 on /dev/tty>
@end group
@end example

@c FIXME: add an xref to where terminal-related primitives are described.

@node Window Configuration Type
@subsection ウィンドウ構成型
@cindex window layout in a frame

  @dfn{ウィンドウ構成(window
configuration)}はフレーム内のウィンドウの位置とサイズ、内容についての情報を保持します。これにより後で同じウィンドウ配置を再作成できます。

  ウィンドウ構成は入力構文をもちません。ウィンドウ構成のプリント表現は@samp{#<window-configuration>}のようになります。ウィンドウ構成に関連するいくつかの関数の説明は@ref{Window
Configurations}を参照してください。

@node Frame Configuration Type
@subsection フレーム構成型
@cindex screen layout
@cindex window layout, all frames

  @dfn{フレーム構成(frame
configuration)}はすべてのフレーム内のウィンドウの位置とサイズ、内容についての情報を保持します。これは基本型ではありません ---
実際のところ、これは@sc{car}が@code{frame-configuration}で@sc{cdr}がalistであるようなリストです。それぞれのalist要素は、その要素の@sc{car}に示される1つのフレームを記述します。

  フレーム構成に関連するいくつかの関数の説明は@ref{Frame Configurations}を参照してください。

@node Process Type
@subsection プロセス型

  @dfn{プロセス(process)}という単語は、通常は実行中のプログラムを意味します。Emacs自身はこの種のプロセス内で実行されます。しかしEmacs
Lispでは、プロセスとはEmacsプロセスにより作成されたサブプロセスを表すLispオブジェクトです。シェル、GDB、ftp、コンパイラーなどのプログラムは、Emacsのサブプロセスとして実行されEmacsの能力を拡張します。さらに操作を行なうために、EmacsサブプロセスはEmacsからテキスト入力を受け取り、テキスト出力をEmacsにリターンします。Emacsがサブプロセスにシグナルを送ることもできます。

  プロセスオブジェクトは入力構文をもちません。プロセスオブジェクトはプロセス名を与えるハッシュ表記でプリントされます。

@example
@group
(process-list)
     @result{} (#<process shell>)
@end group
@end example

プロセスの作成、削除、プロセスに関する情報のリターン、入力やシグナルの送信、出力の受信を行なう関数についての情報は@ref{Processes}を参照してください。

@node Thread Type
@subsection スレッド型

  Emacsでの@dfn{スレッド(thread)}とはEmacs
Lispの実行スレッドとは別のスレッドを表します。これは自身のLispプログラムを実行して、自身のカレントバッファーを所有して、そのスレッドにロックされたサブプロセスをもつことができます(サブプロセスの出力を受け取ることができるのはそのスレッドのみ)。@ref{Threads}を参照してください。

  スレッドオブジェクトは入力構文をもちません。スレッドオブジェクトは(名前を与えられていれば)スレッド名を与えるハッシュ表記かメモリー内のアドレスでプリントされます。

@example
@group
(all-threads)
    @result{} (#<thread 0176fc40>)
@end group
@end example

@node Mutex Type
@subsection ミューテックス型

  @dfn{ミューテックス(mutex)}とはスレッド間で同期をとるためにスレッドが所有と非所有することができる排他ロックです。@ref{Mutexes}を参照してください。

  ミューテックスオブジェクトは入力構文をもちません。プロセスオブジェクトは(名前を与えられていれば)ミューテックス名を与えるハッシュ表記かメモリー内のアドレスでプリントされます。

@example
@group
(make-mutex "my-mutex")
    @result{} #<mutex my-mutex>
(make-mutex)
    @result{} #<mutex 01c7e4e0>
@end group
@end example

@node Condition Variable Type
@subsection 状態変数型

  @dfn{状態変数(condition
variable)}はミューテックスがサポートするよりも複雑な非同期スレッドのためのデバイスです。スレッドは別のスレッドが状態を通知したときに再開するように状態変数を待機することができます。

  状態変数オブジェクトは入力構文をもちません。プロセスオブジェクトは(名前が与えられていれば)状態変数の名前を与えるハッシュ表記かメモリー内のアドレスでプリントされます。

@example
@group
(make-condition-variable (make-mutex))
    @result{} #<condvar 01c45ae8>
@end group
@end example

@node Stream Type
@subsection ストリーム型

  @dfn{ストリーム(stream)}とは、文字のソースまたはシンクとして ---
つまり入力として文字を供給したり、出力として文字を受け入れるために使用できるオブジェクトです。多くの異なるタイプ ---
マーカー、バッファー、文字列、関数をこの方法で使用できます。ほとんどの場合、入力ストリーム(文字列ソース)はキーボード、バッファー、ファイルから文字を受け取り、出力ストリーム(文字シンク)は文字を@file{*Help*}バッファーのようなバッファーやエコーエリアに文字を送ります。

  オブジェクト@code{nil}は、他の意味に加えてストリームとして使用されることがあります。@code{nil}は変数@code{standard-input}や@code{standard-output}の値を表します。オブジェクト@code{t}も入力としてミニバッファー(@ref{Minibuffers}を参照)、出力としてエコーエリア(@ref{The
Echo Area}を参照)の使用を指定するストリームになります。

  ストリームは特別なプリント表現や入力構文をもたず、それが何であれそれらの基本型としてプリントされます。

  パース関数およびプリント関数を含む、ストリームに関連した関数の説明は@ref{Read and Print}を参照してください。

@node Keymap Type
@subsection キーマップ型

  @dfn{キーマップ(keymap)}はユーザーがタイプした文字をコマンドにマップします。このマップはユーザーのコマンド入力が実行される方法を制御します。キーマップは、実際には@sc{car}がシンボル@code{keymap}であるようなリストです。

  キーマップの作成、プレフィクスキーの処理、ローカルキーマップやグローバルキーマップ、キーバインドの変更についての情報は@ref{Keymaps}を参照してください。

@node Overlay Type
@subsection オーバーレイ型

  @dfn{オーバーレイ(overlay)}はバッファーの一部に適用するプロパティーを指定します。それぞれのオーバーレイはバッファーの指定された範囲に適用され、プロパティーリスト(プロパティー名と値が交互に記述された要素のリスト)を含みます。オーバーレイプロパティーは、バッファーの指定された一部を、一時的に異なるスタイルで表示するために使用されます。オーバーレイは入力構文をもたず、バッファー名と範囲の位置を与えるハッシュ表記でプリントされます。

  オーバーレイを作成したり使用する方法についての情報は@ref{Overlays}を参照してください。

@node Font Type
@subsection フォント型

  @dfn{font}はグラフィカルな端末上のテキストを表示する方法を指定します。実際には異なる3つのフォント型 ---
@dfn{フォントオブジェクト(font objects)}、@dfn{フォントスペック(font
specs)}、@dfn{フォントエンティティー(font entities)} ---
が存在します。これらは入力構文をもちません。これらのプリント構文は@samp{#<font-object>}、@samp{#<font-spec>}、@samp{#<font-entity>}のようになります。これらのLispオブジェクトの説明は@ref{Low-Level
Font}を参照してください。

@node Circular Objects
@section 循環オブジェクトの読み取り構文
@cindex circular structure, read syntax
@cindex shared structure, read syntax
@cindex @samp{#@var{n}=} read syntax
@cindex @samp{#@var{n}#} read syntax

  複雑なLispオブジェクトでの共有された構造や循環する構造を表すために、リーダー構成@samp{#@var{n}=}と@samp{#@var{n}#}を使用することができます。

  後でオブジェクトを参照するには、オブジェクトの前で@code{#@var{n}=}を使用します。その後で、他の場所にある同じオブジェクトを参照するために、@code{#@var{n}#}を使用することができます。ここで@var{n}は任意の整数です。たとえば以下は、1番目の要素が3番目の要素にも繰り替えされるリストを作成する方法です:

@example
(#1=(a) b #1#)
@end example

@noindent
これは、以下のような通常の構文とは異なります

@example
((a) b (a))
@end example

@noindent
これは1番目の要素と3番目の要素がそっくりなリストですが、これらは同じLispオブジェクトではありません。以下で違いを見ることができます:

@example
(prog1 nil
  (setq x '(#1=(a) b #1#)))
(eq (nth 0 x) (nth 2 x))
     @result{} t
(setq x '((a) b (a)))
(eq (nth 0 x) (nth 2 x))
     @result{} nil
@end example

  ``要素''として自身を含むような循環する構造を作成するために、同じ構文を使用できます。以下は例です:

@example
#1=(a #1#)
@end example

@noindent
これは2番目の要素がそのリスト自身であるリストを作成します。これが実際にうまくいくのか、以下で確認できます:

@example
(prog1 nil
  (setq x '#1=(a #1#)))
(eq x (cadr x))
     @result{} t
@end example

  変数@code{print-circle}を非@code{nil}値にバインドした場合、Lispプリンターは、循環および共有されるLispオブジェクトを記録するこの構文を生成することができます。@ref{Output
Variables}を参照してください。

@node Type Predicates
@section 型のための述語
@cindex type checking
@kindex wrong-type-argument

  関数が呼び出されたとき、Emacs
Lispインタープリター自身はその関数に渡された実際の引数の型チェックは行ないません。それが行なえないのは、Lispにおける関数の引数は他のプログラミング言語のようなデータ型宣言をもたないからです。したがって実際の引数が、その関数が使用できる型に属するかどうかをテストするのは、それぞれの関数に任されています。

  すべてのビルトイン関数は適切なときに実際の引数の型チェックを行い、引数の型が違う場合は@code{wrong-type-argument}エラーをシグナルします。たとえば以下は、@code{+}の引数に@code{+}が扱うことができない引数を渡したとき何が起こるかの例です:

@example
@group
(+ 2 'a)
     @error{} Wrong type argument: number-or-marker-p, a
@end group
@end example

@cindex type predicates
@cindex testing types
  異なる型にたいして異なる処理をプログラムに行なわせる場合は、明示的に型チェックを行なわなければなりません。オブジェクトの型をチェックするもっとも一般的な方法は@dfn{型述語(type
predicate)}関数の呼び出しです。Emacsはそれぞれの型にたいする型述語をもち、組み合わされた型にたいする述語もあります。

  型述語関数は1つの引数をとり、その引数が適切な型であれば@code{t}、そうでなければ@code{nil}をリターンします。述語関数にたいする一般的なLisp慣習にしたがい、ほとんどの型述語の名前は@samp{p}で終わります。

  以下はリストにたいしてチェックを行なう述語@code{listp}と、シンボルにたいしてチェックを行なう述語@code{symbolp}の例です。

@example
(defun add-on (x)
  (cond ((symbolp x)
         ;; XがシンボルならLISTにputする
         (setq list (cons x list)))
        ((listp x)
         ;; Xがリストならその要素をLISTに追加
         (setq list (append x list)))
        (t
         ;; シンボルとリストだけを処理する
         (error "Invalid argument %s in add-on" x))))
@end example

  以下のテーブルは事前定義された型述語(アルファベット順)と、さらに情報を得るためのリファレンスです。

@table @code
@item atom
@ref{List-related Predicates, atom}を参照のこと。

@item arrayp
@ref{Array Functions, arrayp}を参照のこと。

@item bignump
@ref{Predicates on Numbers, floatp}を参照のこと。

@item bool-vector-p
@ref{Bool-Vectors, bool-vector-p}を参照のこと。

@item booleanp
@ref{nil and t, booleanp}を参照のこと。

@item bufferp
@ref{Buffer Basics, bufferp}を参照のこと。

@item byte-code-function-p
@ref{Byte-Code Type, byte-code-function-p}を参照のこと。

@item case-table-p
@ref{Case Tables, case-table-p}を参照のこと。

@item char-or-string-p
@ref{Predicates for Strings, char-or-string-p}を参照のこと。

@item char-table-p
@ref{Char-Tables, char-table-p}を参照のこと。

@item commandp
@ref{Interactive Call, commandp}を参照のこと。

@item condition-variable-p
@ref{Condition Variables, condition-variable-p}を参照のこと。

@item consp
@ref{List-related Predicates, consp}を参照のこと。

@item custom-variable-p
@ref{Variable Definitions, custom-variable-p}を参照のこと。

@item fixnump
@ref{Predicates on Numbers, floatp}を参照のこと。

@item floatp
@ref{Predicates on Numbers, floatp}を参照のこと。

@item fontp
@ref{Low-Level Font}を参照のこと。

@item frame-configuration-p
@ref{Frame Configurations, frame-configuration-p}を参照のこと。

@item frame-live-p
@ref{Deleting Frames, frame-live-p}を参照のこと。

@item framep
@ref{Frames, framep}を参照のこと。

@item functionp
@ref{Functions, functionp}を参照のこと。

@item hash-table-p
@ref{Other Hash, hash-table-p}を参照のこと。

@item integer-or-marker-p
@ref{Predicates on Markers, integer-or-marker-p}を参照のこと。

@item integerp
@ref{Predicates on Numbers, integerp}を参照のこと。

@item keymapp
@ref{Creating Keymaps, keymapp}を参照のこと。

@item keywordp
@ref{Constant Variables}を参照のこと。

@item listp
@ref{List-related Predicates, listp}を参照のこと。

@item markerp
@ref{Predicates on Markers, markerp}を参照のこと。

@item mutexp
@ref{Mutexes, mutexp}を参照のこと。

@item nlistp
@ref{List-related Predicates, nlistp}を参照のこと。

@item number-or-marker-p
@ref{Predicates on Markers, number-or-marker-p}を参照のこと。

@item numberp
@ref{Predicates on Numbers, numberp}を参照のこと。

@item overlayp
@ref{Overlays, overlayp}を参照のこと。

@item processp
@ref{Processes, processp}を参照のこと。

@item recordp
@ref{Record Type, recordp}を参照のこと。

@item sequencep
@ref{Sequence Functions, sequencep}を参照のこと。

@item string-or-null-p
@ref{Predicates for Strings, string-or-null-p}を参照のこと。

@item stringp
@ref{Predicates for Strings, stringp}を参照のこと。

@item subrp
@ref{Function Cells, subrp}を参照のこと。

@item symbolp
@ref{Symbols, symbolp}を参照のこと。

@item syntax-table-p
@ref{Syntax Tables, syntax-table-p}を参照のこと。

@item threadp
@ref{Basic Thread Functions, threadp}を参照のこと。

@item vectorp
@ref{Vectors, vectorp}を参照のこと。

@item wholenump
@ref{Predicates on Numbers, wholenump}を参照のこと。

@item window-configuration-p
@ref{Window Configurations, window-configuration-p}を参照のこと。

@item window-live-p
@ref{Deleting Windows, window-live-p}を参照のこと。

@item windowp
@ref{Basic Windows, windowp}を参照のこと。
@end table

  あるオブジェクトがどの型かチェックするもっとも一般的な方法は、関数@code{type-of}の呼び出しです。オブジェクトは、ただ1つだけの基本型に属することを思い出してください。@code{type-of}は、それがどの型かを告げます(@ref{Lisp
Data
Types}を参照)。しかし@code{type-of}は基本型以外の型については何も知りません。ほとんどの場合では、@code{type-of}より型述語を使用するほうが便利でしょう。

@defun type-of object
この関数は@var{object}の基本型を名前とするシンボルをリターンする。リターン値はシンボル@code{bool-vector}、@code{buffer}、@code{char-table}、@code{compiled-function}、@code{condition-variable}、@code{cons}、@code{finalizer}、@code{float}、@code{font-entity}、@code{font-object}、@code{font-spec}、@code{frame}、@code{hash-table}、@code{integer}、@code{marker}、@code{mutex}、@code{overlay}、@code{process}、@code{string}、@code{subr}、@code{symbol}、@code{thread}、@code{vector}、@code{window}、@code{window-configuration}のいずれか。ただし@var{object}がレコードなら最初のスロットで指定された型をリターンする。@ref{Records}を参照のこと。

@example
(type-of 1)
     @result{} integer
@group
(type-of 'nil)
     @result{} symbol
(type-of '())    ; @r{@code{()}は@code{nil}}
     @result{} symbol
(type-of '(x))
     @result{} cons
(type-of (record 'foo))
     @result{} foo
@end group
@end example
@end defun

@node Equality Predicates
@section 同等性のための述語
@cindex equality

  ここでは2つのオブジェクトの同一性をテストする関数を説明します。(たとえば文字列などの)特定の型のオブジェクト同士で内容の同一性をテストするには、別の関数を使用します。これらの述語にたいしては、そのデータ型を説明する適切なチャプターを参照してください。

@defun eq object1 object2
この関数は@var{object1}と@var{object2}が同じオブジェクトなら@code{t}、それ以外は@code{nil}をリターンする。

@var{object1}と@var{object2}が同じ名前をもつシンボルなら、通常は同じオブジェクトだが例外もある。@ref{Creating
Symbols}を参照のこと。他の非数値型(リストやベクター、文字列などの)にたいしては、同じ内容(または要素)の2つの引数が両者@code{eq}である必要はない。これらが同じオブジェクトの場合だけ@code{eq}であり、その場合には一方の内容を変更するともう一方の内容にも同じ変更が反映される。

@var{object1}と@var{object2}異なるタイプや値をもつ数値なら同じオブジェクトではなく、@code{eq}は@code{nil}をリターンする。同じ値をもつfixnumなら同じオブジェクトであり、@code{eq}は@code{t}をリターンする。別個に計算されてたまたま同じ値をもち、かつ非fixnumタイプの同じ数値型なら、それらは同じかもしれないし違うかもしれず、Lispインタープリターが作成したオブジェクトが1つか2つかに依存して@code{eq}は@code{t}か@code{nil}をリターンする。

@example
@group
(eq 'foo 'foo)
     @result{} t
@end group

@group
(eq ?A ?A)
     @result{} t
@end group

@group
(eq 3.0 3.0)
     @result{} t @r{または} nil
;; @r{浮動小数にたいするeqではオブジェクト同じかもしれず違うかもしれない}
@end group

@group
(eq (make-string 3 ?A) (make-string 3 ?A))
     @result{} nil
@end group

@group
(eq "asdf" "asdf")
     @result{} t @r{または} nil
;; @r{文字列コンテンツにたいするeqではオブジェクト同じかもしれず違うかもしれない}
@end group

@group
(eq '(1 (2 (3))) '(1 (2 (3))))
     @result{} nil
@end group

@group
(setq foo '(1 (2 (3))))
     @result{} (1 (2 (3)))
(eq foo foo)
     @result{} t
(eq foo '(1 (2 (3))))
     @result{} nil
@end group

@group
(eq [(1 2) 3] [(1 2) 3])
     @result{} nil
@end group

@group
(eq (point-marker) (point-marker))
     @result{} nil
@end group
@end example

@noindent
@code{make-symbol}関数はinternされていないシンボルをリターンする。これはLisp式内でその名前を記述したシンボルとは区別される。同じ名前の異なるシンボルは@code{eq}ではない。@ref{Creating
Symbols}を参照のこと。

@example
@group
(eq (make-symbol "foo") 'foo)
     @result{} nil
@end group
@end example

@noindent
@cindex identical-contents objects, and byte-compiler
@cindex objects with identical contents, and byte-compiler
Emacs Lispバイトコンパイラーはリテラル文字列のような等価なリテラルオブジェクトを同一オブジェクトにたいする参照に落し込む(collapse
into)かもしれない。バイトコンパイルされたコードはそのようなオブジェクトを@code{eq}で比較するだろうが、そうでないコードは異なるという効果がある。したがってコードではオブジェクトのリテラルコンテンツが@code{eq}か否かではなく、以下に説明する@code{equal}のような関数でオブジェクトの関数を使用すること。同様にコードではリテラルオブジェクトを変更(たとえばリテラル文字列へのテキストプロパティのput)しないこと。バイトコンパイラーがそれらの落し込みを行っていたら、同一コンテンツをもつ別のリテラルオブジェクトに影響があるかもしれない。
@end defun

@defun equal object1 object2
この関数は@var{object1}と@var{object2}が同じ構成要素をもつなら@code{t}、それ以外は@code{nil}をリターンする。@code{eq}が引数が同じオブジェクトなのかテストするのにたいして、@code{equal}は同一でない引数の内部を調べて、それらの要素または内容が同一化をテストする。したがって2つのオブジェクトが@code{eq}ならばそれらは@code{equal}だが、その逆は常に真ではない。

@example
@group
(equal 'foo 'foo)
     @result{} t
@end group

@group
(equal 456 456)
     @result{} t
@end group

@group
(equal "asdf" "asdf")
     @result{} t
@end group
@group
(eq "asdf" "asdf")
     @result{} nil
@end group

@group
(equal '(1 (2 (3))) '(1 (2 (3))))
     @result{} t
@end group
@group
(eq '(1 (2 (3))) '(1 (2 (3))))
     @result{} nil
@end group

@group
(equal [(1 2) 3] [(1 2) 3])
     @result{} t
@end group
@group
(eq [(1 2) 3] [(1 2) 3])
     @result{} nil
@end group

@group
(equal (point-marker) (point-marker))
     @result{} t
@end group

@group
(eq (point-marker) (point-marker))
     @result{} nil
@end group
@end example

文字列の比較はcaseを区別するがテキストプロパティーは考慮しない --- これは文字列内の文字だけを比較する。@ref{Text
Properties}を参照のこと。テキストプロパティーも比較する場合には、@code{equal-including-properties}を使用すること。技術的な理由によりユニバイト文字列とマルチバイト文字列は、それらが同じ文字コードのシーケンスを含み、それらのコードがすべて0から127(@acronym{ASCII})の場合に限り@code{equal}となる(@ref{Text
Representations}を参照)。

@example
@group
(equal "asdf" "ASDF")
     @result{} nil
@end group
@end example

@code{equal}関数はオブジェクトが整数、文字列、マーカー、ベクター、ブールベクター、バイトコード関数オブジェクト、文字テーブル、レコード、フォントオブジェクトなら、それらのコンテンツを再帰的に比較する。その他のオブジェクトは、それらが@code{eq}の場合のみ@code{equal}とみなされる。たとえば個別の2つのバッファーは、たとえバッファーのテキスト的なコンテンツが同一であっても@code{equal}とみなされることはない。
@end defun

  @code{equal}では等価性は再帰的に定義されています。たとえば2つのコンスセル@var{x}と@var{y}を与えると、@code{(equal
@var{x} @var{y})}は、以下の式の両方が@code{t}をリターンする場合だけ@code{t}をリターンします:

@example
(equal (car @var{x}) (car @var{y}))
(equal (cdr @var{x}) (cdr @var{y}))
@end example

したがって循環リストの比較はエラーとなるような深い再帰を引き起こすかもしれず、@code{(equal a
b)}は@code{t}をリターンするにも関わらず@code{(equal b
a)}はエラーをシグナルするといった直感に反する結果となることがあります。

@defun equal-including-properties object1 object2
この関数はすべてのケースにおいて@code{equal}と同様に振る舞うが、2つの文字列が@code{equal}になるためには、それらが同じテキストプロパティーをもつ必要がある。

@example
@group
(equal "asdf" (propertize "asdf" 'asdf t))
     @result{} t
@end group
@group
(equal-including-properties "asdf"
                            (propertize "asdf" 'asdf t))
     @result{} nil
@end group
@end example
@end defun

@node Mutability
@section 可変性
@cindex mutable objects

  変更されるべきではないLispオブジェクトがいくつかあります。たとえばLisp式@code{"aaa"}では文字列を生成しますが、そのコンテンツを変更するべきではありません。いくつかのオブジェクトは変更できません。たとえばある数値を計算して新たな数値を作成できたとしても、Lispは既存の数値を変更する操作を提供しません。

  その他のLispオブジェクトは副作用をともなう破壊的な操作を通じて安全に値を変更可能な@dfn{mutable(可変)}オブジェクトです。たとえばマーカーを別のポイントを指すマーカーに移動することにより、既存のマーカーを変更することができます。

  数値は変更不可でマーカーはすべてmutableだとしても、mutableと非mutableのメンバーをもつタイプがいくつかあります。これらのタイプにはコンス、ベクター、文字列が含まれます。たとえば@code{"cons"}と@code{(symbol-name
'cons)}は変更するべきではない文字列を生成しますが、@code{(copy-sequence
"cons")}と@code{(make-string 3
?a)}は後から@code{aset}を呼び出すことを通じて変更可能なmutable文字列を生成します。

  mutableオブジェクトは評価される式の一部となったときにmutableであることを止めます。たとえば:

@example
(let* ((x (list 0.5))
       (y (eval (list 'quote x))))
  (setcar x 1.5) ;; プログラムはこれを行うべきではない
  y)
@end example

@noindent
作成時にリスト@code{(0.5)}がmutableでも、それは@code{eval}に与えられたので@code{setcar}を通じて変更するべきではありません。変更するべきではないオブジェクトが後からmutableになることは決してないので逆はあり得ません。

  変更するべきではないオブジェクトの変更をプログラムが試みた際の動作は未定義です。Lispインタープリターがエラーをシグナルするかもしれず、クラッシュしたり他の方法で予測不能な振る舞いを引き起こすかもしれません@footnote{これはCommon
LispやCのような言語が定数にたいして指定する挙動であり、プログラムによるimmutableオブジェクト変更の試みにエラーのシグナルを要求するJavaScriptやPythonのようなインタープリターとは異なる。理想的にはEmacs
Lispインタープリターは後者を目指して進化するであろう。}。

  プログラムの一部として類似した定数が出現する際には、既存の定数やそのコンポーネントの再利用によってLispが時間やスペースを節約できるかもしれません。たとえば@code{(eq
"abc"
"abc")}はインタープリターが文字列リテラル@code{"abc"}の1つのインスタンスを作成したら@code{t}、2つのインスタンスを作成したら@code{nil}をリターンします。したがってこの最適化使用の有無に関わらず機能するようにLispプログラムを記述する必要があります。
