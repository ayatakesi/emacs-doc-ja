@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990--1995, 1998--1999, 2001--2020 Free Software
@c Foundation, Inc.
@c See the file elisp-ja.texi for copying conditions.
@node Files
@chapter ファイル

  このチャプターでは検索、作成、閲覧、保存、その他ファイルとディレクトリーにたいして機能するEmacs
Lispの関数と変数について説明します。その他のいくつかのファイルに関する関数については@ref{Buffers}、バックアップとauto-save(自動保存)に関する関数については@ref{Backups
and Auto-Saving}で説明されています。

  ファイル関数の多くはファイル名であるような引数を1つ以上受け取ります。このファイル名は文字列です。これらの関数のほとんどは関数@code{expand-file-name}を使用してファイル名引数を展開するので、@file{~}は相対ファイル名(@file{../}と空文字列を含む)として正しく処理されます。@ref{File
Name Expansion}を参照してください。

  加えて特定の@dfn{magic}ファイル名は特別に扱われます。たとえばリモートファイル名が指定された際、Emacsは適切なプロトコルを通じてネットワーク越しにファイルにアクセスします。@ref{Remote
Files,, Remote Files, emacs, The GNU Emacs
Manual}を参照してください。この処理は非常に低レベルで行われるので、特に注記されたものを除いて、このチャプターで説明するすべての関数がファイル名引数としてmagicファイル名を受け入れると想定しても良いでしょう。詳細は@xref{Magic
File Names}を参照してください。

  ファイルI/O関数がLispエラーをシグナルする際、通常はコンディション@code{file-error}を使用します(@ref{Handling
Errors}を参照)。ほとんどの場合にはオペレーティングシステムからロケール@code{system-messages-locale}に応じたエラーメッセージが取得されて、コーディングシステム@code{locale-coding-system}を使用してデコードされます(@ref{Locales}を参照)。

@menu
* Visiting Files::           編集のためにEmacsバッファーにファイルを読み込む。
* Saving Buffers::           変更されたバッファーをファイルに書き戻す。
* Reading from Files::       ファイルをvisitせずにバッファーに読み込む。
* Writing to Files::         バッファーの一部から新たなファイルに書き込む。
* File Locks::               複数名による同時編集を防ぐためにファイルをlockまたはunlockする。
* Information about Files::  ファイルの存在、アクセス権、サイズのテスト。
* Changing Files::           ファイル名のリネームやパーミッションの変更など。
* Files and Storage::        電源喪失とメディアエラーへの対処
* File Names::               ファイル名の分解と展開。
* Contents of Directories::  ディレクトリーないのファイルリストの取得。
* Create/Delete Dirs::       ディレクトリーの作成と削除。
* Magic File Names::         特定のファイル名にたいする特別な処理。
* Format Conversion::        さまざまなファイルフォーマットへ/からの変換。
@end menu

@node Visiting Files
@section ファイルのvisit
@cindex finding files
@cindex visiting files

  ファイルのvisitとはファイルをバッファーに読み込むことを意味します。一度これを行うと、わたしたちはバッファーがファイルを@dfn{visit(訪問)}していると言い、ファイルのことをバッファーのvisitされたファイルと呼んでいます。

  ファイルとバッファーは2つの異なる事柄です。ファイルとは、(削除しない限り)コンピューター内に永続的に記録された情報です。一方バッファーとは編集セッションの終了(またはバッファーのkill)とともに消滅する、Emacs内部の情報です。あるバッファーがファイルをvistしているとき、バッファーにはファイルからコピーされた情報が含まれます。編集コマンドにより変更されるのはバッファー内のコピーです。バッファーへの変更によってファイルは変更されません。その変更を永続化するためにはバッファーを@dfn{保存(save)}しなければなりません。これは変更されたバッファーのコンテンツをファイルにコピーして書き戻すことを意味します。

  ファイルとバッファーは異なるにも関わらず、人はバッファーという意味でファイルを呼んだり、その逆を行うことが多々あります。実際のところ、``わたしはまもなく同じ名前のファイルに保存するためのバッファーを編集している''ではなく、``わたしはファイルを編集している''と言います。人間がこの違いを明確にする必要は通常はありません。しかしコンピュータープログラムで対処する際には、この違いを心に留めておくのが良いでしょう。

@menu
* Visiting Functions::       visit用の通常のインターフェイス関数。
* Subroutines of Visiting::  通常のvisit関数が使用する低レベルのサブルーチン。
@end menu

@node Visiting Functions
@subsection ファイルをvisitする関数
@cindex visiting files, functions for
@cindex how to visit files

  このセクションではファイルのvisitに通常使用される関数を説明します。歴史的な理由によりこれらの関数は@samp{visit-}ではなく、@samp{find-}で始まる名前をもちます。バッファーをvisitしているファイルの名前へのアクセスや、visitされたファイル名から既存のバッファーを見つける関数および変数については@ref{Buffer
File Name}を参照してください。

  ファイル内容を見たいものの変更したくない場合にはテンポラリーバッファー(temporary buffer:
一時的なバッファー)で@code{insert-file-contents}を使用例するのが、Lispプログラム内ではもっとも高速な方法です。時間を要するファイルのvisitは必要ありません。@ref{Reading
from Files}を参照してください。

@deffn Command find-file filename &optional wildcards
このコマンドはファイル@var{filename}をvisitしているバッファーを選択する。visitしている既存のバッファーがあればそのバッファー、なければバッファーを新たに作成してそのバッファーにファイルを読み込む。これはそのバッファーをリターンする。

技術的な詳細を除けば@code{find-file}関数のbodyは基本的には以下と等価:

@smallexample
(switch-to-buffer (find-file-noselect filename nil nil wildcards))
@end smallexample

@noindent
(@ref{Switching Buffers}の@code{switch-to-buffer}を参照されたい。)

@var{wildcards}が非@code{nil}
(interactiveに呼び出された場合は常に真)の場合、@code{find-file}は@var{filename}内のワイルドカード文字を展開してマッチするすべてのファイルをvisitする。

@code{find-file}がinteractiveに呼び出された際にはミニバッファー内で@var{filename}の入力を求める。
@end deffn

@deffn Command find-file-literally filename
このコマンドは@code{find-file}が行うように@var{filename}をvisitするが、フォーマット変換(@ref{Format
Conversion}を参照)、文字コード変換(@ref{Coding Systems}を参照)、EOL変換(@ref{Coding System
Basics, End of line
conversion}を参照)を何も行わない。ファイルをvisitしているバッファーはunibyteになり、ファイル名とは無関係にバッファーのメジャーモードはFundamentalモードになる。ファイル内で指定されたファイルローカル変数(@ref{File
Local
Variables}を参照)は無視され、自動的な解凍と@code{require-final-newline}によるファイル終端への改行追加(@ref{Saving
Buffers, require-final-newline}を参照)も無効になる。

Emacsがすでにリテラリー(literally:
文字通り、そのまま)でない方法で同じファイルをvisitしているバッファーをもつ場合には、Emacsはその同じファイルをリテラリーにvisitせず、単に既存のバッファーに切り替えることに注意。あるファイルのコンテンツにたいして確実にリテラリーにアクセスしたければテンポラリーバッファーを作成して、@code{insert-file-contents-literally}を使用してファイルのコンテンツを読み込むこと(@ref{Reading
from Files}を参照)。
@end deffn

@defun find-file-noselect filename &optional nowarn rawfile wildcards
これはファイルをvisitするすべての関数の要となる関数である。これはファイル@var{filename}をvisitしているバッファーをリターンする。望むならそのバッファーをカレントにしたり、あるウィンドウ内に表示することができるだろうがこの関数はそれを行わない。

関数は既存のバッファーがあればそれをリターンし、なければ新たにバッファーを作成してそれにファイルを読み込む。@code{find-file-noselect}が既存のバッファーを使用する際は、まずファイルがそのバッファーに最後にvisit、または保存したときから変更されていないことを検証する。ファイルが変更されていれば、この関数は変更されたファイルを再読み込みするかどうかをユーザーに尋ねる。ユーザーが@samp{yes}と応えたら、以前に行われたそのバッファー内での編集は失われる。

ファイルの読み込みはEOL変換、フォーマット変換(@ref{Format
Conversion}を参照)を含むファイルコンテンツのデコードを要する(@ref{Coding
Systems}を参照)。@var{wildcards}が非@code{nil}なら、@code{find-file-noselect}は@var{filename}内のワイルドカード文字を展開してマッチするすべてのファイルをvisitする。

この関数はオプション引数@var{nowarn}が@code{nil}なら、さまざまな特殊ケースにおいて警告メッセージ(warning
message)、および注意メッセージ(advisory
message)を表示する。たとえば関数がバッファーの作成を必要とし、かつ@var{filename}という名前のファイルが存在しなければ、エコーエリア内にメッセージ@samp{(New
file)}を表示してそのバッファーを空のままに留める。

@code{find-file-noselect}関数は、ファイルを読み込んだ後に通常は@code{after-find-file}を呼び出す(@ref{Subroutines
of
Visiting}を参照)。この関数はバッファーのメジャーモードのセット、ローカル変数のパース、正にvisitしたファイルより新しいauto-saveファイルが存在する場合にユーザーへの警告を行い、@code{find-file-hook}内の関数を実行することにより終了する。

オプション引数@var{rawfile}が非@code{nil}なら@code{after-find-file}は呼び出されず、失敗時に@code{find-file-not-found-functions}は呼び出されない。さらに非@code{nil}値の@var{rawfile}は、コーディングシステム変換とフォーマット変換を抑制する。

@code{find-file-noselect}関数は、通常はファイル@var{filename}をvisitしているバッファーをリターンする。しかしワイルドカードが実際に使用、展開された場合には、それらのファイルをvisitしているバッファーのリストをリターンする。

@example
@group
(find-file-noselect "/etc/fstab")
     @result{} #<buffer fstab>
@end group
@end example
@end defun

@deffn Command find-file-other-window filename &optional wildcards
このコマンドはファイル@var{filename}をvisitしているバッファーを選択するが、選択されたウィンドウではない他のウィンドウでこれを行う。これは別の既存ウィンドウを使用したり、ウィンドウを分割するかもしれない。@ref{Switching
Buffers}lを参照のこと。

このコマンドがinteractiveに呼び出された際は@var{filename}の入力を求める。
@end deffn

@deffn Command find-file-read-only filename &optional wildcards
このコマンドは@code{find-file}のようにファイル@var{filename}をvisitしているバッファーを選択するが、そのバッファーを読み取り専用(read-only)とマークする。関連する関数と変数については@ref{Read
Only Buffers}を参照のこと。

このコマンドがinteractiveに呼び出された際は@var{filename}の入力を求める。
@end deffn

@defopt find-file-wildcards
この変数が非@code{nil}なら、各種@code{find-file}コマンドはワイルドカード文字をチェックして、それらにマッチするすべてのファイルをvisitする(interactiveに呼び出されたときや@var{wildcards}引数が非@code{nil}のとき)。このオプションが@code{nil}なら、@code{find-file}コマンドはそれらの@var{wildcards}引数を無視してワイルドカード文字を特別に扱うことは決してない。
@end defopt

@defopt find-file-hook
この変数の値はファイルがvisitされた後に呼び出される関数のリスト。ファイルのローカル変数指定は、(もしあれば)このフックが実行される前に処理されるだろう。フック関数実行時はそのファイルをvisitしているバッファーがカレントになる。

この変数はノーマルフックである。@ref{Hooks}を参照のこと。
@end defopt

@defvar find-file-not-found-functions
この変数の値は@code{find-file}や@code{find-file-noselect}が存在しないファイル名を受け取った際に呼び出される関数のリスト。存在しないファイルを検知すると@code{find-file-noselect}は直ちにこれらの関数を呼び出す。これらのいずれかが非@code{nil}をリターンするまで、リスト順に関数を呼び出す。@code{buffer-file-name}はすでにセットアップ済みである。

関数の値が使用されること、および多くの場合いくつかの関数だけが呼び出されるので、これはノーマルフックではない。
@end defvar

@defvar find-file-literally
このバッファーローカル変数が非@code{nil}値にセットされると、@code{save-buffer}はあたかもそのバッファーがリテラリー、つまり何の変換も行わずにファイルをvisitしていたかのように振る舞う。コマンド@code{find-file-literally}はこの変数のローカル値をセットするが、その他の等価な関数およびコマンドも、たとえばファイル終端への改行の自動追加を避けるためにこれを同様に行うことができる。この変数は恒久的にローカルなのでメジャーモードの変更による影響を受けない。
@end defvar

@node Subroutines of Visiting
@subsection visitのためのサブルーチン

  @code{find-file-noselect}関数は、2つの重要なサブルーチン@code{create-file-buffer}と@code{after-find-file}を使用します。これらはユーザーのLispコードでも役に立つことがあります。このセクションではそれらの使い方について説明します。

@c FIXME This does not describe the default behavior, because
@c uniquify is enabled by default and advises this function.
@c This is confusing.  uniquify should be folded into the function proper.
@defun create-file-buffer filename
この関数は@var{filename}のvisitにたいして適切な名前のバッファーを作成してそれをリターンする。これは@var{filename}
(ディレクトリーを含まず)の名前がフリーならバッファー名にそれを使用し、フリーでなければ未使用の名前を取得するために@samp{<2>}のような文字列を付加する。@ref{Creating
Buffers}も参照のこと。@file{uniquify}ライブラリーはこの関数の結果に影響を与えることに注意。@ref{Uniquify,,,
emacs, The GNU Emacs Manual}を参照のこと。

@strong{注意されたい:}
@code{create-file-buffer}はファイルに新たなバッファーを@emph{関連付けない}。バッファーの選択もせず、さらにデフォルトのメジャーモードも使用しない。

@example
@group
(create-file-buffer "foo")
     @result{} #<buffer foo>
@end group
@group
(create-file-buffer "foo")
     @result{} #<buffer foo<2>>
@end group
@group
(create-file-buffer "foo")
     @result{} #<buffer foo<3>>
@end group
@end example

この関数は@code{find-file-noselect}により使用される。この関数自身は@code{generate-new-buffer}を使用する(@ref{Creating
Buffers}を参照)。
@end defun

@defun after-find-file &optional error warn noauto after-find-file-from-revert-buffer nomodes
この関数はバッファーのメジャーモードをセットして、ローカル変数をパースする(@ref{Auto Major
Mode}を参照)。これは@code{find-file-noselect}、およびデフォルトのリバート関数(@ref{Reverting}を参照)により呼び出される。

@cindex new file message
@cindex file open error
ファイルが存在しないという理由によりファイルの読み込みがエラーを受け取るがディレクトリーは存在するなら、呼び出し側は@var{error}にたいして非@code{nil}値を渡すこと。この場合、@code{after-find-file}は警告@samp{(New
file)}を発する。より深刻なエラーにたいしては、呼び出し側は通常は@code{after-find-file}を呼び出さないこと。

@var{warn}が非@code{nil}なら、もしauto-saveファイルが存在して、かつそれがvisitされているファイルより新しければ、この関数は警告を発する。

@var{noauto}が非@code{nil}なら、それはAuto-Saveモードを有効や無効にしないことを告げる。以前にAuto-Saveモードが有効なら有効のまま留まる。

@var{after-find-file-from-revert-buffer}が非@code{nil}なら、それはこの関数が@code{revert-buffer}から呼び出されたことを意味する。これに直接的な効果はないが、モード関数とフック関数の中には、この変数の値をチェックするものがいくつかある。

@var{nomodes}が非@code{nil}なら、それはバッファーのメジャーモードを変更せず、ファイル内のローカル変数指定を処理せず、@code{find-file-hook}を実行しないことを意味する。この機能はあるケースにおいて@code{revert-buffer}により使用される。

@code{after-find-file}はリスト@code{find-file-hook}内のすべての関数を最後に呼び出す。
@end defun

@node Saving Buffers
@section バッファーの保存
@cindex saving buffers

  Emacs内でファイルを編集する際には、実際にはそのファイルをvisitしているバッファーにたいして編集を行っています。つまりファイルのコンテンツをバッファーにコピーしてそのコピーを編集しています。そのバッファーを変更してもバッファーを@dfn{保存(save)}するまでファイルは変更されません。保存とはバッファーのコンテンツをファイルにコピーすることを意味します。ファイルをvisitしていないバッファーでも、バッファーローカルんｑ@code{write-contents-functions}の関数を使用することにより``saved(保存済み)''にすることができます。

@deffn Command save-buffer &optional backup-option
この関数はバッファーが最後にvisitされたときや保存されたときから変更されていれば、カレントバッファーのコンテンツをバッファーによってvisitされているファイルに保存、変更されていなければ何も行わない。

@code{save-buffer}はバックアップファイルの作成に責任を負う。@var{backup-option}は通常は@code{nil}であり、@code{save-buffer}はファイルのvisit以降、それが最初の保存の場合のみバックアップファイルを作成する。@var{backup-option}にたいする他の値は、別の条件によるバックアップファイル作成を要求する:

@itemize @bullet
@item
引数4は1つの@kbd{C-u}、引数64は3つの@kbd{C-u}を意味するので、@code{save-buffer}はバッファーの次回保存時にこのバージョンのファイルがバックアップされるようマークする。

@item
引数16は2つの@kbd{C-u}、引数64は3つの@kbd{C-u}を意味するので、@code{save-buffer}関数はそれを保存する前に前バージョンのファイルを無条件にバックアップする。

@item
引数0は無条件にバックアップファイルを何も@emph{作成しない}。
@end itemize
@end deffn

@deffn Command save-some-buffers &optional save-silently-p pred
@anchor{Definition of save-some-buffers}
このコマンドはファイルをvisitしている変更されたバッファーのいくつかを保存する。これは通常は各バッファーごとにユーザーに確認を求める。しかし@var{save-silently-p}が非@code{nil}なら、ユーザーに質問せずにファイルをvisitしているすべてのバッファーを保存する。

@vindex save-some-buffers-default-predicate
オプション引数@var{pred}は、どのバッファーで確認を求めるか(または@var{save-silently-p}が非@code{nil}ならどのバッファーで確認せずに保存するか)を制御する。

@var{pred}が@code{nil}なら、@var{pred}のかわりに@code{save-some-buffers-default-predicate}の値を使用することを意味する。その結果が@code{nil}ならファイルをvisitしているバッファーにたいしてのみ確認を求めることを意味する。@code{t}なら@code{buffer-offer-save}のバッファーローカル値が@code{nil}であるような非ファイルバッファー以外の特定のバッファーの保存も提案することを意味する(@ref{Killing
Buffers}を参照)。ユーザーが非ファイルバッファーの保存にたいして@samp{yes}と応えると保存に使用するファイル名の指定を求める。@code{save-buffers-kill-emacs}関数は@var{pred}にたいして値@code{t}を渡す。

述語が@code{t}と@code{nil}のいずれでもなければ引数なしの関数であること。その関数はバッファーの保存を提案するか否かを決定するためにバッファーごとに呼び出される。これが特定のバッファーで非@code{nil}値をリターンすればバッファー保存の提案を行うことを意味する。
@end deffn

@deffn Command write-file filename &optional confirm
@anchor{Definition of write-file}
この関数はカレントバッファーをファイル@var{filename}に書き込んで、バッファーがそのファイルをvisitしていることにして未変更とマークする。次に@var{filename}にもとづいてバッファー名をリネームする。バッファー名を一意にするため、必要なら@samp{<2>}のような文字列を付加する。処理のほとんどは@code{set-visited-file-name}
(@ref{Buffer File Name}を参照)、および@code{save-buffer}を呼び出すことにより行われる。

@var{confirm}が非@code{nil}なら、それは既存のファイルを上書きする前に確認を求めることを意味する。ユーザーがプレフィックス引数を与えなければinteractiveに確認が求められる。

@var{filename}がディレクトリー名(@ref{Directory
Names}を参照)、または既存のディレクトリーへのシンボリックリンクなら、@code{write-file}はディレクトリー@var{filename}内でvisitされているファイルの名前を使用する。そのバッファーがファイルをvisitしていなければ、かわりにバッファーの名前を使用する。
@end deffn

  バッファーの保存によりフックがいくつか実行されます。これによりフォーマット変換も処理されます(@ref{Format
Conversion}を参照)。以下で説明するこれらのフックはバッファーのテキストをファイルに書き込む@code{save-buffer}以外の他のプリミティブや関数、とりわけauto-saving
(@ref{Auto-Saving}を参照)では実行されないことに注意してください。

@defvar write-file-functions
この変数の値はvisitされているファイルをバッファーに書き出す前に呼び出される関数のリスト。それらのうちのいずれかが非@code{nil}をリターンしたら、そのファイルは書き込み済みだと判断されて残りの関数は呼び出されないし、ファイルを書き込むための通常のコードも実行されない。

@code{write-file-functions}内の関数が非@code{nil}をリターンしたら、(それが適切なら)その関数はファイルをバックアップする責任を負う。これを行うには以下のコードを実行する:

@example
(or buffer-backed-up (backup-buffer))
@end example

@code{backup-buffer}によりリターンされるファイルモードの値を保存して、(もし非@code{nil}なら)書き込むファイルのモードビットをセットしたいと思うかもしれない。これは正に@code{save-buffer}が通常行うことである。@ref{Making
Backups,, Making Backup Files}を参照のこと。

@code{write-file-functions}内のフック関数は、データのエンコード(が望ましければ)にも責任を負う。これらは適切なコーディングシステムと改行規則(@ref{Lisp
and Coding Systems}を参照)を選択してエンコード(@ref{Explicit
Encoding}を参照)を処理して、使用されていたコーディングシステム(@ref{Encoding and
I/O}を参照)を@code{last-coding-system-used}にセットしなければならない。

バッファー内でこのフックをローカルにセットすると、バッファーはそのファイル、またはバッファーのコンテンツを取得したファイルに類するものに関連付けられる。このようにして変数は恒久的にローカルとマークされるので、メジャーモードの変更がバッファーローカルな値を変更することはない。その一方で@code{set-visited-file-name}を呼び出すことによって変数はリセットされるだろう。これを望まなければ、かわりに@code{write-contents-functions}を使用したいと思うかもしれない。

たとえこれがノーマルフックでなくても、このリストを操作するために@code{add-hook}と@code{remove-hook}を使用することはできる。@ref{Hooks}を参照のこと。
@end defvar

@c Emacs 19 feature
@defvar write-contents-functions
これは正に@code{write-file-functions}と同様に機能するが、こちらはvisitしている特定のファイルやファイルの場所ではなくバッファーのコンテンツに関連するフックを意図しており、実際にはファイルをvisitしていないバッファーにたいして任意の保存処理を作成するために使用できる。そのようなフックは、この変数にたいするバッファーローカルなバインディングとして、通常はメジャーモードにより作成される。この変数はセットされた際には常に自動的にバッファーローカルになる。新たなメジャーモードへの切り替えは常にこの変数をリセットするが、@code{set-visited-file-name}の呼び出しではリセットされない。

このフック内の関数のいずれかが非@code{nil}をリターンすると、そのファイルはすでに書き込み済みとみなされて、残りの関数は呼び出されず@code{write-file-functions}内の関数も呼び出されない。

(スペシャルモードのバッファーのような)ファイルをvisitしていないバッファーを保存するためにこのフックを利用する際には、その関数が正常に保存することに失敗して@code{nil}値をリターンすると、@code{save-buffer}がユーザーにたいしてバッファーを保存するファイルの入力を求めることに留意。これが望ましくなければエラーのレイズによる関数の失敗を考慮されたい。
@end defvar

@defopt before-save-hook
このノーマルフックはvisitしているファイルにバッファーが保存される前に実行される。保存が通常の方法で行われるか、あるいは上述のフックのいずれかで行われたかは問題ではない。たとえば@file{copyright.el}プログラムは、ファイルの保存においてそれの著作権表示が今年であることを確認するためにこのフックを使用する。
@end defopt

@c Emacs 19 feature
@defopt after-save-hook
これはバッファーをvisitするファイルに保存後に実行されるノーマルフック。
@end defopt

@defopt file-precious-flag
この変数が非@code{nil}なら、@code{save-buffer}は保存ファイルがもつ名前のかわりに一時的な名前で新たなファイルに書き込み、エラーがないことが明確になった後にファイルを意図する名前にリネームすることによって保存中のI/Oエラーから防御する。この手順は無効なファイルが原因となるディスク容量逼迫のような問題を防ぐ。

副作用としてバックアップ作成にコピーが必要になる。@ref{Rename or
Copy}を参照のこと。しかし同時にこの高価なファイル保存によって保存したファイルと他のファイル名との間のすべてのハードリンクは切断される。

いくつかのモードは特定のバッファーにおいてこの変数に非@code{nil}のバッファーローカル値を与える。
@end defopt

@defopt require-final-newline
この変数はファイルが改行で@emph{終わらない}ように書き込まれるかどうかを決定する。変数の値が@code{t}なら、@code{save-buffer}はバッファーの終端に改行がなければ暗黙理に改行を追加する。値が@code{visit}なら、Emacsはファイルをvisitした直後に不足している改行を追加する。値が@code{visit-save}なら、Emacsはvisitと保存の両方のタイミングで不足している改行を追加する。その他の非@code{nil}値にたいしては、そのようなケースが生じるたびに改行を追加するかどうか@code{save-buffer}がユーザーに尋ねる。

変数の値が@code{nil}なら@code{save-buffer}は改行を追加しない。デフォルト値は@code{nil}だが、特定のバッファーでこれを@code{t}にセットするメジャーモードも少数存在する。
@end defopt

  @ref{Buffer File Name}の関数@code{set-visited-file-name}も参照されたい。

@node Reading from Files
@section ファイルからの読み込み
@cindex reading from files

  ファイルのコンテンツをバッファーにコピーするためには関数@code{insert-file-contents}を使用します(マークをセットするのでLispプログラム内でコマンド@code{insert-file}は使用してはならない)。

@defun insert-file-contents filename &optional visit beg end replace
この関数はファイル@var{filename}のコンテンツをカレントバッファーのポイントの後に挿入する。これは絶対ファイル名と挿入だれたデータの長さからなるリストをリターンする。@var{filename}が読み取り可能なファイルの名前でなければエラーがシグナルされる。

この関数は定義されたファイルフォーマットに照らしてファイルのコンテンツをチェックして、適切ならそのコンテンツの変換、およびリスト@code{after-insert-file-functions}内の関数の呼び出しも行う。@ref{Format
Conversion}を参照のこと。通常はリスト@code{after-insert-file-functions}内のいずれかの関数がEOL変換を含むファイルコンテンツのデコードに使用されるコーディングシステム(@ref{Coding
Systems}を参照)を判断する。しかしファイルにnullバイトが含まれる場合には、デフォルトではコード変換なしでvisitされる。@ref{Lisp
and Coding Systems, inhibit-null-byte-detection}を参照のこと。

@var{visit}が非@code{nil}なら、この関数は追加でそのバッファーを未変更とマークしてそのバッファーのさまざまなフィールドをセットアップして、バッファーがファイル@var{filename}をvisitしているようにする。これらのフィールドにはバッファーがvisitしたファイルの名前、最終保存したファイルのmodtimeが含まれる。これらの機能は@code{find-file-noselect}により使用されるものであり、恐らくあなた自身が使用するべきではない。

@var{beg}と@var{end}が非@code{nil}なら、それらはファイル挿入範囲を指定するバイトオフセット数値であること。この場合、@var{visit}は@code{nil}でなければならない。たとえば、

@example
(insert-file-contents filename nil 0 500)
@end example

@noindent
これはファイルの先頭500文字(バイト)を挿入する。

引数@var{replace}が非@code{nil}なら、それはバッファーのコンテンツ(実際にはアクセス可能な範囲)をファイルのコンテンツで置き換えることを意味する。これは単にバッファーのコンテンツを削除してファイル全体を挿入するより優れている。なぜなら、(1)マーカー位置を維持して、(2)undoリストに配置するデータも少ないからである。

@var{replace}と@var{visit}が@code{nil}なら、@code{insert-file-contents}で(FIFOやI/Oデバイスのような)スペシャルファイルの読み取りが可能。
@end defun

@defun insert-file-contents-literally filename &optional visit beg end replace
この関数は@code{insert-file-contents}のように機能するが、@code{after-insert-file-functions}を実行せずフォーマットのデコード、文字コード変換、自動解凍、...などを行わない点が異なる。
@end defun

他のプログラムがファイルを読めるように他プロセスにファイル名を渡したければ関数@code{file-local-copy}を使用します。@ref{Magic
File Names}を参照してください。

@node Writing to Files
@section ファイルへの書き込み
@cindex writing to files

  関数@code{append-to-file}と@code{write-region}を使用することによってディスク上のファイルにバッファーのコンテンツやバッファーの一部を直接書き込むことができます。visitされているファイルに書き込むためにこれらの関数を使用しないでください。これによってvisitにたいするメカニズムが混乱するかもしれません。

@deffn Command append-to-file start end filename
この関数はカレントバッファー内で@var{start}と@var{end}によるリージョンのコンテンツをファイル@var{filename}の終端に追加する。そのファイルが存在しなければ作成する。この関数は@code{nil}をリターンする。

@var{filename}の書き込みや作成ができなければエラーがシグナルされる。

Lispから呼び出した場合、この関数は以下と完全に等価:

@example
(write-region start end filename t)
@end example
@end deffn

@deffn Command write-region start end filename &optional append visit lockname mustbenew
この関数はカレントバッファー内の@var{start}と@var{end}で区切られたリージョンを@var{filename}で指定されたファイルに書き込む。

@var{start}が@code{nil}なら、このコマンドはバッファーのコンテンツ全体(アクセス可能な@emph{範囲だけではない})をファイルに書き込んで@var{end}は無視する。

@c Emacs 19 feature
@var{start}が文字列なら、@code{write-region}はバッファーのテキストではなくその文字列を追加する。その場合には@var{end}は無視される。

@var{append}が非@code{nil}なら、指定されたテキストが(もしあれば)既存のファイルコンテンツに追加される。@var{append}が数字なら@code{write-region}はファイル開始位置からそのバイトオフセットをseekしてデータをそこに書き込む。

@var{mustbenew}が非@code{nil}の場合には、@var{filename}が既存ファイルの名前なら@code{write-region}は確認を求める。@var{mustbenew}がシンボル@code{excl}なら、ファイルがすでに存在する場合には@code{write-region}は確認を求めるかわりにエラー@code{file-already-exists}をシグナルする。たとえ@code{write-region}が通常はシンボリックリンクをフォローして、もしシンボリックリンクが壊れていればpointed-toファイル(訳注:
ファイルへのハードリンクにたいするポインター)を作成するとしても、@var{mustbenew}が@code{excl}ならシンボリックリンクをフォローしない。

@var{mustbenew}が@code{excl}のときは、存在するファイルのテストに特別なシステム機能を使用する。少なくともローカルディスク上のファイルにたいしては、Emacsがファイルを作成する前にEmacsに通知せずに他のプログラムが同じ名前のファイルを作成することはありえない。

@var{visit}が@code{t}なら、Emacsはバッファーとファイルの関連付けを設定してそのバッファーがそのファイルをvictiする。またカレントバッファーにたいする最終ファイル変更日時に@var{filename}をセットして、そのバッファーを未変更としてマークする。この機能は@code{save-buffer}により使用されるが、おそらくあなた自身が使用するべきではないだろう。

@c Emacs 19 feature
@var{visit}が文字列なら、それはvisitするファイルの名前を指定する。この方法を使えば、そのバッファーが別のファイルをvisitしていると記録しつつ1つのファイル(@var{filename})にデータを書き込むことができる。引数@var{visit}はエコーエリアに使用される他にファイルのロックにも使用され、@var{visit}が@code{buffer-file-name}に格納される。この機能は@code{file-precious-flag}の実装に使用される。自分が何をしているか本当にわかっているのでなければこれを使用してはならない。

オプション引数@var{lockname}が非@code{nil}なら、それはロックとアンロックの目的に使用する@var{filename}と@var{visit}をオーバーライドするファイル名を指定する。

関数@code{write-region}は書き込むデータを@code{buffer-file-format}によって指定される適切なファイルフォーマットに変換しするとともに、リスト@code{write-region-annotate-functions}内の関数の呼び出しも行う。@ref{Format
Conversion}を参照のこと。

@code{write-region}は通常はエコーエリア内にメッセージ@samp{Wrote
@var{filename}}を表示する。@var{visit}が@code{t}、@code{nil}、文字列のいずれでもない場合、こまたはEmacsがbatchモード(@ref{Batch
Mode}を参照)で処理中ならこのメッセージは抑制される。この機能は内部的な目的のためにユーザーが知る必要がないファイルを使用したり、Emacsがbatchモードで処理中に有用である。
@end deffn

@defvar write-region-inhibit-fsync
この変数の値が@code{nil}なら@code{write-region}はファイル書き込み後にシステムコール@code{fsync}を使用する。これはたとえEmacsを低速化するとしても、電源喪失時のデータ損失リスクを軽減する。値が@code{t}ならEmacsは@code{fsync}を使用しない。デフォルト値はEmacsが対話的に実行されていれば@code{nil}、batchモードで実行時には@code{t}。@ref{Files
and Storage}を参照のこと。
@end defvar

@defmac with-temp-file file body@dots{}
@anchor{Definition of with-temp-file}
@code{with-temp-file}マクロは一時バッファー(temporary
buffer)をカレントバッファーとして@var{body}フォームを評価して、最後にそのバッファーのコンテンツを@var{file}に書き込む。これは終了時に一時バッファーをkillして、@code{with-temp-file}フォームの前にカレントだったバッファーをリストアする。その後に@var{body}内の最後のフォームの値をリターンする。

@code{throw}やエラーによる異常なexit(abnormal exit)でも、カレントバッファーはリストアされる(@ref{Nonlocal
Exits}を参照)。

@code{with-temp-buffer} (@ref{Definition of with-temp-buffer,, Current
Buffer}を参照)と同様に、このマクロが使用する一時バッファーではフック@code{kill-buffer-hook}、@code{kill-buffer-query-functions}
(@ref{Killing Buffers}を参照)、@code{buffer-list-update-hook} (@ref{Buffer
List}を参照)は実行されない。
@end defmac

@node File Locks
@section ファイルのロック
@cindex file locks
@cindex lock file
@cindex .#, lock file names

  2人のユーザーが同時に同じファイルを編集する際には、彼らはおそらく互いに干渉しあうでしょう。Emacsはファイルが変更される際に@dfn{ファイルロック(file
lock)}を記録することにより、このような状況の発生を防ぎます。そしてEmacsは他のEmacsジョブにロックされているファイルをvisitしているバッファーへの変更の最初の試みを検知して、ユーザーに何を行うべきかを尋ねます。このファイルロックの実態は、編集中のファイルと同じディレクトリーに格納される特別な名前をもつシンボリックリンクです。この名前はバッファーのファイル名に@file{.#}を前置することにより構築されます。シンボリックリンクのターゲットは@code{@var{user}@@@var{host}.@var{pid}:@var{boot}}という形式になります。ここで@var{user}はカレントのユーザー名(
@code{user-login-name}かより得)、@var{host}はEmacsを実行中のホスト(
@code{system-name}より取得)、@var{pid}はEmacsのプロセスID、@var{boot}は最後のブートからの経過時間です。ブート時刻が利用できなければ@code{:@var{boot}}は省略されます。(シンボリックリンクをサポートしないファイルシステムでは、@code{@var{user}@@@var{host}.@var{pid}:@var{boot}}という形式を構築するか割りに通常のファイルが使用される)。

  ファイルのアクセスにNFSを使用する際には、可能性は小さいものの他のユーザーと同じファイルを同時にロックするかもしれません。これが発生すると2人のユーザーが同時にファイルを変更することが可能になりますが、それでもEmacsは2番目に保存するユーザーにたいして警告を発するでしょう。たファイルをvisitしているバッファーでディスク上でファイルの変更を検知することにより、ある種の同時編集を捕捉できます。@ref{Modification
Time}を参照してください。

@defun file-locked-p filename
この関数はファイル@var{filename}がロックされていなければ@code{nil}をリターンする。このEmacsプロセスによりロックされていれば@code{t}、他のEmacsジョブによりロックされている場合はロックしたユーザーの名前をリターンする。

@example
@group
(file-locked-p "foo")
     @result{} nil
@end group
@end example
@end defun

@defun lock-buffer &optional filename
この関数はカレントバッファーが変更されていればファイル@var{filename}をロックする。引数@var{filename}のデフォルトはカレントバッファーがvisitしているファイル。カレントバッファーがファイルをvisitしていない、バッファーが変更されていない、または@code{create-lockfiles}が@code{nil}なら何もしない。
@end defun

@defun unlock-buffer
この関数はカレントバッファーが変更されていればバッファーによりvisitされているファイルをアンロックする。バッファーが変更されていなければ、そのファイルをロックしてはならないのでこの関数は何もしない。カレントバッファーがファイルをvisitしていない、またはファイルがロックされていなければこの関数は何もしない。
@end defun

@defopt create-lockfiles
この変数が@code{nil}ならEmacsはファイルをロックしない。
@end defopt

@defun ask-user-about-lock file other-user
この関数はユーザーが@var{file}の変更を試みたが、それが名前@var{other-user}のユーザーにロックされていたとき呼び出される。この関数のデフォルト定義は何を行うかユーザーに尋ねる関数。この関数がリターンする値はEmacsが次に何を行うかを決定する:

@itemize @bullet
@item
値@code{t}はそのファイルのロックを奪うことを意味する。その場合には@var{other-user}はロックを失い、そのユーザーがファイルを編集することができる。

@item
値@code{nil}はロックを無視して、とにかくユーザーがファイルを編集できるようにすることを意味する。

@item
@kindex file-locked
この関数はかわりにエラー@code{file-locked}をシグナルする。この場合には、ユーザーが行おうとしていた変更は行われない。

このエラーにたいするエラーメッセージは以下のようになる:

@example
@error{} File is locked: @var{file} @var{other-user}
@end example

@noindent
ここで@code{file}はファイル名、@var{other-user}はそのファイルのロックを所有するユーザーの名前。
@end itemize

望むなら他の方法で判定を行う独自バージョンで@code{ask-user-about-lock}関数を置き換えることができる。
@end defun

@node Information about Files
@section ファイルの情報
@cindex file, information about

  このセクションではファイル(またはディレクトリーやシンボリックリンク)に関してファイルが読み込み可能か、書き込み可能か、あるいはファイルのサイズのようなさまざまなタイプの情報を取得する関数を説明します。これらの関数はすべて引数にファイルの名前を受け取ります。特に注記した場合を除きこれらの引数には既存のファイルを指定する必要があり、ファイルが存在しなければエラーをシグナルします。

@cindex file names, trailing whitespace
@cindex trailing blanks in file names
  スペースで終わるファイル名には気をつけてください。いくつかのファイルシステム(特にMS-Windows)では、ファイル名の末尾の空白文字は暗黙かつ自動的に無視されます。

@menu
* Testing Accessibility::    そのファイルは読み取り可能か? 
                               書き込み可能か?
* Kinds of Files::           それはディレクトリー? 
                               それともシンボリックリンク?
* Truenames::                シンボリックリンクの最終的なファイル名。
* File Attributes::          ファイルのサイズや更新日時など。
* Extended Attributes::      アクセス制御にたいするファイル属性の拡張。
* Locating Files::           標準的な場所でファイルを見つける方法。
@end menu

@node Testing Accessibility
@subsection アクセシビリティのテスト
@cindex accessibility of a file
@cindex file accessibility

  以下の関数はファイルにたいする読み取り、書き込み、実行のパーミッションをテストします。これらの関数は明示しない限りボリックリンクをフォローします。@ref{Kinds
of Files}を参照してください。

  いくつかのオペレーティングシステムではACL(Access Control Lists:
アクセス制御リスト)のような機構を通じて、より複雑なアクセスパーミッションセットが指定できます。それらのパーミッションにたいする問い合わせやセットの方法については@ref{Extended
Attributes}を参照してください。

@defun file-exists-p filename
この関数はファイル名@var{filename}が存在しているようなら@code{t}をリターンする。これはファイルが読み取り可能である必要はなく、ファイルの属性を調べることが恐らく可能なこと意味する(Unixやその他のPOSIXシステム類ではファイルが存在してファイルを含むディレクトリーの実行パーミッションをもつ場合にはファイル自体のパーミッションに関わらず@code{t})。

ファイルが存在しない、またはファイルが存在するかどうかの判断に問題があるようなら、この関数は@code{nil}をリターンする。

ディレクトリーはファイルなので、ディレクトリーが与えられると@code{file-exists-p}は@code{t}をリターンするかもしれない。しかし@code{file-exists-p}はシンボリックリンクをフォローするので、ターゲットファイルが存在する場合のみシンボリックリンク名にたいして@code{t}をリターンする。
@end defun

@defun file-readable-p filename
この関数は@var{filename}という名前のファイルが存在して、それを読み取ることが可能なら@code{t}、それ以外は@code{nil}をリターンする。
@end defun

@defun file-executable-p filename
この関数は、@var{filename}という名前のファイルが存在して、それを実行することが可能なら@code{t}をリターンする。それ以外は@code{nil}をリターンする。Unixやその他のPOSIXシステム類ではファイルがディレクトリーなら実行パーミッションはディレクトリー内のファイルの存在と属性をチェックできるので、ファイルのモードが許せばオープンできることを意味する。
@end defun

@defun file-writable-p filename
この関数は@var{filename}という名前のファイルが書き込み可能か作成可能可能なら@code{t}、それ以外は@code{nil}をリターンする。ファイルが存在してそれに書き込むことができるならファイルは書き込み可能。ファイルは存在しないが親ディレクトリーが存在して、そのディレクトリーに書き込むことができるなら書き込み可能。

以下の例では、@file{foo}は親ディレクトリーが存在しないので、たとえユーザーがそのディレクトリーを作成可能であってもファイルは書き込み可能ではない。

@example
@group
(file-writable-p "~/no-such-dir/foo")
     @result{} nil
@end group
@end example
@end defun

@defun file-accessible-directory-p dirname
この関数はファイルとしての名前が@var{dirname}であるようなディレクトリー内にある既存のファイルをオープンするパーミッションをもつ場合は@code{t}、それ以外(そのようなディレクトリーが存在しない場合)は@code{nil}をリターンする。@var{dirname}の値はディレクトリー名(@file{/foo/}など)、または名前がディレクトリー(最後のスラッシュがない@file{/foo}など)であるようなファイル。

たとえば以下では@file{/foo/}内の任意のファイルを読み取る試みはエラーになると推測できる:

@example
(file-accessible-directory-p "/foo")
     @result{} nil
@end example
@end defun

@defun access-file filename string
この関数は@var{filename}が読み取り可能なら@code{nil}、それ以外なら@var{string}をエラーメッセージのテキストに使用してエラーをシグナルする。
@end defun

@defun file-ownership-preserved-p filename &optional group
この関数はファイル@var{filename}を削除後に新たに作成してもファイルの所有者が変更されずに維持されるようなら@code{t}をリターンする。これは存在しないファイルにたいしても@code{t}をリターンする。

オプション引数@var{group}が非@code{nil}なら、この関数はファイルのグループが変更されないこともチェックする。

この関数はシンボリックリンクをフォローしない。
@end defun

@defun file-modes filename &optional flag
@cindex mode bits
@cindex file permissions
@cindex permissions, file
@cindex file modes
この関数は@var{filename}の@dfn{モードビット(mode
bits)}をリターンする。これは読み取り、書き込み、実行パーミッションを要約する整数。この関数はシンボリックリンクを許容する。ファイルが存在しなければリターン値は@code{nil}。

モードビットの説明は@ref{File permissions,,, coreutils, The @sc{gnu} @code{Coreutils}
Manual}を参照のこと。たとえば最下位ビットが1ならそのファイルは実行可能、2ビット目が1なら書き込み可能、...となる。設定できる最大の値は4095(8進の7777)であり、これはすべてのユーザーが読み取り、書き込み、実行のパーミッションをもち、他のユーザーとグループにたいして@acronym{SUID}ビット、およびstickyビットがセットされる。

デフォルトでは、この関数はシンボリックリンクをフォローする。しかしオプション引数@var{flag}がシンボル@code{nofollow}なら、この関数はシンボリックリンクの@var{filename}をフォローしない。これはどこか別の場所でうっかりモードビットを取得してしまうことを防ぎ、@code{file-attributes}との整合性を保つ助けとなり得る(@ref{File
Attributes}を参照)。

これらのパーミッションのセットに使用される@code{set-file-modes}関数については@ref{Changing Files}を参照のこと。

@example
@group
(file-modes "~/junk/diffs" 'nofollow)
     @result{} 492               ; @r{10進整数}
@end group
@group
(format "%o" 492)
     @result{} "754"             ; @r{8進に変換した値}
@end group

@group
(set-file-modes "~/junk/diffs" #o666 'nofollow)
     @result{} nil
@end group

@group
$ ls -l diffs
-rw-rw-rw- 1 lewis lewis 3063 Oct 30 16:00 diffs
@end group
@end example

@cindex MS-DOS and file modes
@cindex file modes and MS-DOS
@strong{MS-DOSにたいする注意:}
MS-DOSでは実行可能であることをを表すようなファイルのモードビットは存在しない。そのため@code{file-modes}はファイル名が@file{.com}、@file{.bat}、@file{.exe}などのような標準的な実行可能な拡張子のいずれかで終わる場合にはファイルを実行可能であると判断する。POSIX標準の@samp{#!}署名で始まるshellスクリプトやPerlスクリプトも実行可能と判断される。POSIXとの互換性のためにディレクトリーも実行可能と報告される。@code{file-attributes}
(@ref{File Attributes}を参照)もこれらの慣習にしたがう。
@end defun

@node Kinds of Files
@subsection ファイル種別の区別
@cindex file classification
@cindex classification of file types
@cindex symbolic links

  このセクションではディレクトリー、シンボリックリンク、および通常ファイルのようなさまざまな種類のファイルを区別する方法を説明します。

  シンボリックリンクは通常はそれが出現した場合には常にフォローされます。たとえばファイル名@file{a/b/c}を解釈するためにシンボリックリンクかもしれない@file{a}、@file{a/b}、@file{a/b/c}はすべてフォローされて、リンクターゲット自身がシンボリックリンクなら再帰的にフォローされるかもしれません。しかしいくつかの関数は最後のファイル名(この例では@file{a/b/c})ではシンボリックリンクをフォローしません。そのような関数のことを@dfn{シンボリックリンク非フォロー(not
follow symbolic links)}と呼びます。

@defun file-symlink-p filename
@cindex symbolic links
ファイル@var{filename}がシンボリックリンクなら@code{file-symlink-p}関数はリンクをフォローせずに、かわりにリンクターゲットを文字列としてリターンする(リンクターゲット文字列はターゲットの完全な絶対ファイル名である必要はない。リンクが指すのが完全なファイル名かどうかを判断するのは簡単な処理ではない。以下参照)。

@code{file-symlink-p}はファイル@var{filename}がシンボリックリンクではないか、あるいは存在しなかったりシンボリックリンクかどうか判断するのに問題がある場合には@code{nil}をリターンする。

この関数の使用例をいくつか示す:

@example
@group
(file-symlink-p "not-a-symlink")
     @result{} nil
@end group
@group
(file-symlink-p "sym-link")
     @result{} "not-a-symlink"
@end group
@group
(file-symlink-p "sym-link2")
     @result{} "sym-link"
@end group
@group
(file-symlink-p "/bin")
     @result{} "/pub/bin"
@end group
@end example

3つ目の例では関数は@file{sym-link}をリターンするが、たとえそれ自体がシンボリックリンクであってもリンク先の解決を行わないことに注意。これは関数がシンボリックリンクをフォローしない、すなわちシンボリックリンクをフォローする処理はファイル名の最後のコンポーネントには適用されないからである。

この関数がリターンするのはそのシンボリックリンクに何が記録されているかを示す文字列であり、それにディレクトリー部分が含まれているかどうかは構わない。この関数は完全修飾されたファイル名を生成するためにリンクターゲットを@emph{展開しない}し、リンクターゲットが絶対ファイル名でなければ、(もしあっても)@var{filename}引数のディレクトリー部分は使用しない。以下に例を示す:

@example
@group
(file-symlink-p "/foo/bar/baz")
     @result{} "some-file"
@end group
@end example

@noindent
ここでは、たとえ与えられた@file{/foo/bar/baz}が完全修飾されたファイル名であるにも関わらずその結果は異なり、実際には何のディレクトリー部分ももたない。@file{some-file}自体がシンボリックリンクかもしれないので、単にその前に先行ディレクトリーを追加することはできず、絶対ファイル名を生成するために単に@code{expand-file-name}
(@ref{File Name Expansion}を参照)を使用することもできないからである。

この理由により、あるファイルがシンボリックリンクか否かという単一の事実よりも多くを判定する必要がある場合にこの関数が有用であることは稀である。実際にリンクターゲットのファイル名が必要なら、@ref{Truenames}で説明する@code{file-chase-links}や@code{file-truename}を使用すること。
@end defun

@defun file-directory-p filename
この関数は@var{filename}が既存のディレクトリー名なら@code{t}。@var{filename}がディレクトリー名ではない、あるいはディレクトリーかどうかの判断に問題がある場合には@code{nil}をリターンする。この関数はシンボリックリンクをフォローする。

@example
@group
(file-directory-p "~rms")
     @result{} t
@end group
@group
(file-directory-p "~rms/lewis/files-ja.texi")
     @result{} nil
@end group
@group
(file-directory-p "~rms/lewis/no-such-file")
     @result{} nil
@end group
@group
(file-directory-p "$HOME")
     @result{} nil
@end group
@group
(file-directory-p
 (substitute-in-file-name "$HOME"))
     @result{} t
@end group
@end example
@end defun

@defun file-regular-p filename
この関数はファイル@var{filename}が存在して、それが通常ファイル(ディレクトリー、名前付きパイプ、端末、その他I/Oデバイス以外)なら@code{t}をリターンする。@var{filename}が存在しない、通常ファイルではない、あるいは通常ファイルかどうかの判断に問題がある場合には@code{nil}をリターンする。この関数はシンボリックリンクをフォローする。
@end defun

@node Truenames
@subsection 本当の名前
@cindex truename (of file)

  ファイルの@dfn{実名(truename)}とは、全階層においてシンボリックリンクを残らずフォローした後に名前コンポーネントに出現する@samp{.}と@samp{..}を除いて簡略化した名前のことです。これはそのファイルにたいする正規名(canonical
name)の一種です。ファイルが常に一意な実名をもつ訳ではありません。あるファイルにたいする異なる実名の個数は、そのファイルにたいするハードリンクの個数と同じです。しかし実名はシンボリックリンクによる名前の変動を解消するのに有用です。

@defun file-truename filename
この関数はファイル@var{filename}の実名をリターンする。引数が絶対ファイル名でなければ、この関数は最初に@code{default-directory}にたいしてこれを展開する。

この関数は環境変数を展開しない。これを行うのは@code{substitute-in-file-name}のみ。@ref{Definition of
substitute-in-file-name}を参照のこと。

名前コンポーネントに出現する@samp{..}に先行するシンボリックリンクリンクをフォローする必要がある場合には直接と間接を問わず、@code{expand-file-name}を呼び出す前に@code{file-truename}を呼び出すこと。そうしないと@samp{..}の直前にある名前コンポーネントは、@code{file-truename}が呼び出される前の簡略化により取り除かれてしまう。@code{expand-file-name}呼び出しの必要を無くすために、@code{file-truename}は@code{expand-file-name}が行うのと同じ方法で@samp{~}を扱う。@ref{File
Name Expansion,, Functions that Expand Filenames}を参照のこと。

シンボリックリンクのターゲットがリモートファイル名の構文をもつ場合には、@code{file-truename}はそれをクォートしてリターンする。@ref{File
Name Expansion,, Functions that Expand Filenames}を参照のこと。
@end defun

@defun file-chase-links filename &optional limit
この関数は@var{filename}で始まるシンボリックリンクを、シンボリックリンクではない名前のファイル名までフォローして、そのファイル名をリターンする。この関数は親ディレクトリーの階層にあるシンボリックリンクを@emph{フォローしない}。

@var{limit}に数を指定するとその数のリンクを追跡した後、この関数はたとえそれが依然としてシンボリックリンクであってもそれをリターンする。
@end defun

  @code{file-chase-links}と@code{file-truename}の違いを説明するために、@file{/usr/foo}がディレクトリー@file{/home/foo}へのシンボリックリンク、@file{/home/foo/hello}が(少なくともシンボリックリンクではない)通常ファイル、または存在しないファイルだとします。この場合には以下のようになります:

@example
(file-chase-links "/usr/foo/hello")
     ;; @r{親ディレクトリーのリンクはフォローしない}
     @result{} "/usr/foo/hello"
(file-truename "/usr/foo/hello")
     ;; @r{@file{/home}はシンボリックリンクではないと仮定}
     @result{} "/home/foo/hello"
@end example

@defun file-equal-p file1 file2
この関数はファイル@var{file1}と@var{file2}の名前が同じファイルなら@code{t}をリターンする。これはリモートファイル名も適切な方法で処理することを除いて実名の比較と似ている。@var{file1}か@var{file2}が存在しなければリターン値は不定。
@end defun

@defun file-name-case-insensitive-p filename
ファイル名やその一部にたいして文字列としての比較を要する場合には、背景にあるファイルシステムが非caseセンシティブ(case-insensitive:
大文字小文字を区別しない)かどうかを知ることが重要になる。この関数はファイル@var{filename}が非caseセンシティブなファイルシステムにあれば@code{t}をリターンする。MS-DOSとMS-Windowsでは常に@code{t}をリターンする。CygwinとmacOSでは非caseセンシティブかもしれないので、実行時テストによりcaseセンシティブ性の判定を試みる。テストで決定されなければCygwinなら@code{t}、macOSなら@code{nil}をリターンする。

この関数は現在のところMS-DOS、MS-Windows、Cygwin、macOS以外のプラットフォームでは常に@code{nil}をリターンする。これはSamba共有やNFSマウントされたWindowsボリュームのようにマウントされたファイルシステムのcaseセンシティブ性は検知しない。リモートホストでは@samp{smb}メソッドにたいしては@code{t}とみなす。
@end defun

@defun file-in-directory-p file dir
この関数は、@var{file}がディレクトリー@var{dir}内のファイルかサブディレクトリーなら@code{t}をリターンする。また@var{file}と@var{dir}が同じディレクトリーの場合も@code{t}をリターンする。この関数は2つのディレクトリーの実名を比較する。@var{dir}が既存のディレクトリーの名前でなければリターン値は@code{nil}。
@end defun

@defun vc-responsible-backend file
この関数は与えられた@var{file}にたいしてVCバックエンドが責任を負うかどうかを判断する。たとえば@file{emacs.c}がGitでトラック(track:
追跡)されていれば@w{@code{(vc-responsible-backend
"emacs.c")}}は@samp{Git}をリターンする。@var{file}がシンボリックリンクなら@code{vc-responsible-backend}はシンボリックリンクを解決せずに、シンボリックリンクにたいするバックエンドが報告されることに注意。@var{file}が参照するファイルのバックエンドVCを取得するには、@code{file-chase-links}のようなシンボリックリンク解決用の関数で@var{file}をラップすること。

@smallexample
(vc-responsible-backend (file-chase-links "emacs.c"))
@end smallexample
@end defun

@node File Attributes
@subsection ファイルの属性
@cindex file attributes

  このセクションではファイルの詳細な情報を取得する関数について説明します。それらの情報にはファイルの所有者やグループの番号、ファイル名の個数、inode番号、サイズやアクセス日時、変更日時が含まれます。

@defun file-newer-than-file-p filename1 filename2
@cindex file age
@cindex file modification time
この関数はファイル@var{filename1}がファイル@var{filename2}より新しければ@code{t}をリターンする。@var{filename1}が存在しなければ@code{nil}、@var{filename1}は存在するが@var{filename2}が存在しなければ@code{t}をリターンする。

以下の例では、@file{aug-19}の書き込みが19日、@file{aug-20}の書き込みが20日、ファイル@file{no-file}は存在しないものとする。

@example
@group
(file-newer-than-file-p "aug-19" "aug-20")
     @result{} nil
@end group
@group
(file-newer-than-file-p "aug-20" "aug-19")
     @result{} t
@end group
@group
(file-newer-than-file-p "aug-19" "no-file")
     @result{} t
@end group
@group
(file-newer-than-file-p "no-file" "aug-19")
     @result{} nil
@end group
@end example
@end defun

@defun file-attributes filename &optional id-format
@anchor{Definition of file-attributes}
この関数はファイル@var{filename}の属性(attributes)のリストをリターンする。オープンできないファイルが指定された場合は、@code{nil}をリターンする。指定されたファイルが存在しなければ@code{nil}をリターンする。この関数はシンボリックリンクをフォローしない。オプション引数@var{id-format}は属性@acronym{UID}と@acronym{GID}(以下参照)にたいして望ましいフォーマットを指定する。有効な値は@code{'string}と@code{'integer}。デフォルトは@code{'integer}だが、わたしたちはこれの変更を計画しているので、リターンされる@acronym{UID}や@acronym{GID}を使用する場合には@var{id-format}にたいして非@code{nil}値を指定すること。

GNUプラットフォームではこの関数はロックファイル処理時はアトミックである。別のプロセスによりファイルシステムが同時に変更された場合には、この関数は変更の前か後のいずれかのファイル属性をリターンする。それ以外ならこの関数はアトミックではなく競合状態を検知したら@code{nil}、または以前とカレントが混ざったファイル属性をリターンするかもしれない。

このリスト内の要素にアクセスするためにアクセッサ関数が提供される。このアクセッサ以下の要素の記述とともに示される。

リストの要素は順に:

@enumerate 0
@item
ディレクトリーにたいしては@code{t}、シンボリックリンクにたいしては文字列(リンクされる名前)、テキストファイル(@code{file-attribute-type})にたいしては@code{nil}。

@c Wordy so as to prevent an overfull hbox.  --rjc 15mar92
@item
そのファイルがもつ名前の個数(@code{file-attribute-link-number})。ハードリンクとして知られる代替え名は関数@code{add-name-to-file}を使用して作成できる(@ref{Changing
Files}を参照)。

@item
ファイルの@acronym{UID}であり通常は文字列@code{file-attribute-user-id}。しかし名前をもつユーザーに対応しなければ値は整数。

@item
同様にファイルの@acronym{GID} (@code{file-attribute-group-id})。

@item
Lispのタイムスタンプによる最終アクセス時刻(@code{file-attribute-access-time})。タイムスタンプは@code{current-time}
(@ref{Time of
Day}を参照)の形式であり、ファイルシステムのタイムスタンプの精度に切り詰められる。たとえばFATベースのいくつかのファイルシステムでは最終アクセスの日付だけが記録されるので、この時刻には常に最終アクセス日の真夜中が保持されることに注意。

@cindex modification time of file
@item
Lispのタイムスタンプによる最終変更時刻(@code{file-attribute-modification-time})。これはファイルのコンテンツが変更された最終時刻。

@item
Lispのタイムスタンプによるステータスの最終変更時刻(@code{file-attribute-status-change-time}。上記参照)。これはファイルのアクセスモードビット、所有者とグループ、およびファイルにたいしてファイルのコンテンツ以外にファイルシステムが記録するその他の情報にたいする最終変更時刻。

@item
ファイルのバイトサイズ(@code{file-attribute-size})。

@item
@samp{ls
-l}で表示されるような10個の文字、またはダッシュからなる文字列で表されるファイルのモード(@code{file-attribute-modes})。

@item
後方互換のために提供される不定値。

@item
ファイルのinode番号であり非負の整数(@code{file-attribute-inode-number})。

@item
そのファイルがあるデバイスのファイルシステム番号(@code{file-attribute-device-number})。この要素とファイルのinode番号を併せればシステム上の2つを区別するのに足る情報が得られる(2つのファイルがこれら両方の番号で同じ値をもつことはできない)。
@end enumerate

たとえば以下は@file{files-ja.texi}のファイル属性:

@example
@group
(file-attributes "files-ja.texi" 'string)
     @result{}  (nil 1 "lh" "users"
          (20614 64019 50040 152000)
          (20000 23 0 0)
          (20614 64555 902289 872000)
          122295 "-rw-rw-rw-"
          t 6473924464520138
          1014478468)
@end group
@end example

@noindent
この結果を解釈すると:

@table @code
@item nil
ディレクトリーでもシンボリックリンクでもない。

@item 1
(カレントデフォルトディレクトリー内で名前@file{files-ja.texi}は)単一の名前をもつ。

@item "lh"
名前"lh"のユーザーにより所有される。

@item "users"
名前"users"のグループ。

@item (20614 64019 50040 152000)
最終アクセスがOctober 23, 2012, at 20:12:03.050040152 UTC。

@item (20000 23 0 0)
最終更新がJuly 15, 2001, at 08:53:43 UTC。

@item (20614 64555 902289 872000)
最終ステータス変更がOctober 23, 2012, at 20:20:59.902289872 UTC。

@item 122295
バイト長は122295バイト(しかしマルチバイトシーケンスが含まれていたり、EOLフォーマットがCRLFなら122295文字は含まれないかもしれない)。

@item "-rw-rw-rw-"
所有者、グループ、その他にたいして読み取り、書き込みアクセスのモードをもつ。

@item t
単なるプレースホルダーであり何の情報ももたない。

@item 6473924464520138
inode番号は6473924464520138。

@item 1014478468
ファイルシステムのデバイス番号は1014478468。
@end table
@end defun

@defun file-nlinks filename
この関数はファイル@var{filename}がもつ名前(ハードリンク)の個数をリターンする。ファイルが存在しなければ、この関数は@code{nil}をリターンする。シンボリックリンクはリンク先のファイルの名前とは判断されないので、この関数に影響しないことに注意。この関数はシンボリックリンクをフォローしない。

@example
@group
$ ls -l foo*
-rw-rw-rw- 2 rms rms 4 Aug 19 01:27 foo
-rw-rw-rw- 2 rms rms 4 Aug 19 01:27 foo1
@end group

@group
(file-nlinks "foo")
     @result{} 2
@end group
@group
(file-nlinks "doesnt-exist")
     @result{} nil
@end group
@end example
@end defun

@node Extended Attributes
@subsection 拡張されたファイル属性
@cindex extended file attributes

いくつかのオペレーティングシステムでは、それぞれのファイルを任意の@dfn{拡張ファイル属性(extended file
attributes)}に関連付けることができます。現在のところEmacsは拡張ファイル属性のうち2つの特定セット(ACL: Access
Control
List、およびSELinuxコンテキスト)にたいする問い合わせと設定をサポートします。これらの拡張ファイル属性は、前のセクションで議論したUnixスタイルの基本的なパーミッションより洗練されたファイルアクセス制御を強制するために、いくつかのシステムで利用されます。

@cindex access control list
@cindex ACL entries
@cindex SELinux context
  ACLとSELinuxについての詳細な解説はこのマニュアルの範囲を超えています。わたしたちの目的のためには、それぞれのファイルは@dfn{ACL}
(ACLベースのファイル制御システムの元でACLのプロパティを指定)および/または@dfn{SELinuxコンテキスト}
(SELinuxシステムの元でSELinuxのプロパティを指定)に割り当てることができるという理解で問題ないでしょう。

@defun file-acl filename
この関数はファイル@var{filename}にたいするACLをリターンする。ACLにたいする正確なLisp表現は不確定(かつ将来のEmacsバージョンで変更され得る)だが、これは@code{set-file-acl}が引数@var{acl}にとる値と同じである(@ref{Changing
Files}を参照)。

根底にあるACL実装はプラットフォームに固有である。EmacsはGNU/LinuxとBSDではPOSIX
ACLインターフェイスを使用して、MS-WindowsではネイティブのファイルセキュリティAPIをPOSIX ACLインターフェイスでエミュレートする。

ACLがサポートされていない、あるいはファイルが存在しなければリターン値は@code{nil}。
@end defun

@defun file-selinux-context filename
この関数はファイル@var{filename}のSELinuxコンテキストを@code{(@var{user} @var{role}
@var{type}
@var{range})}という形式のリストでリターンする。リストの要素はそのコンテキストのユーザー、ロール、タイプ、レンジを文字列として表す値である。これらの実際の意味についての詳細はSELinuxのドキュメントを参照のこと。リターン値は@code{set-file-selinux-context}が@var{context}引数で受け取るのと同じ形式(@ref{Changing
Files}を参照)。

SELinuxをサポートしない、あるいはファイルが存在しなければリターン値は@code{(nil nil nil nil)}。
@end defun

@defun file-extended-attributes filename
この関数はEmacsが認識するファイル@var{filename}の拡張属性をalistでリターンする。現在のところこの関数はACLとSELinuxの両方を取得するための便利な方法としての役目を果たす。他のファイルに同じファイルアクセス属性を適用するためにリターンされたalistを2つ目の引数として@code{set-file-extended-attributes}を呼び出すことができる(@ref{Changing
Files}を参照)。

要素のうちの1つは@code{(acl . @var{acl})}で、@var{acl}は@code{file-acl}がリターンするのと同じ形式。

他の要素は@code{(selinux-context
. @var{context})}で、@var{context}は@code{file-selinux-context}がリターンするのと同じ形式。
@end defun

@node Locating Files
@subsection 標準的な場所へのファイルの配置
@cindex locate file in path
@cindex find file in path

  このセクションではディレクトリーのリスト(@dfn{パス(path)})からファイルを検索したり、標準の実行可能ファイル用ディレクトリーから実行可能ファイルを検索する方法を説明します。

  ユーザー固有の設定ファイル(configuration file)の検索については@ref{Standard File
Names}の関数@code{locate-user-emacs-file}を参照してください。

@defun locate-file filename path &optional suffixes predicate
この関数は@var{path}で与えられるディレクトリーリスト内で@var{filename}という名前のファイルを検索して、@var{suffixes}内のサフィックスの検索を試みる。そのようなファイルが見つかったらファイルの絶対ファイル名(@ref{Relative
File Names}を参照)、それ以外は@code{nil}をリターンする。

オプション引数@var{suffixes}は検索時に@var{filename}に追加するファイル名サフィックスのリストを与える。@code{locate-file}は検索するディレクトリーごとにそれらのサフィックスを試みる。@var{suffixes}が@code{nil}や@code{("")}なら、サフィックスなしで@var{filename}だけがそのまま使用される。@var{suffixes}の典型的な値は@code{exec-suffixes}
(@ref{Subprocess
Creation}を参照)、@code{load-suffixes}、@code{load-file-rep-suffixes}、および関数@code{get-load-suffixes}
(@ref{Load Suffixes}を参照)。

実行可能プログラムを探すときは@code{exec-path} (@ref{Subprocess
Creation}を参照)、Lispファイルを探すときは@code{load-path} (@ref{Library
Search}を参照)が@var{path}の典型的な値である。@var{filename}が絶対ファイル名なら@var{path}の効果はないが、サフィックスにたいする@var{suffixes}は依然として試行される。

オプション引数@var{predicate}が非@code{nil}なら、それは候補ファイルが適切かどうかテストする述語関数を指定する。述語関数には単一の引数として候補ファイル名が渡される。@var{predicate}が@code{nil}か省略なら述語として@code{file-readable-p}を使用する。@code{file-executable-p}や@code{file-directory-p}など、その他の有用な述語については@ref{Kinds
of Files}を参照のこと。

この関数は通常はディレクトリーをスキップするので、ディレクトリーを探したければ、@var{predicate}関数がディレクトリーにたいして確実に@code{dir-ok}をリターンすること。たとえば:

@example
(locate-file "html" '("/var/www" "/srv") nil
             (lambda (f) (if (file-directory-p f) 'dir-ok)))
@end example


互換性のために@var{predicate}には@code{executable}、@code{readable}、@code{writable}、@code{exists}、またはこれらシンボルの1つ以上のリストも指定できる。
@end defun

@defun executable-find program &optional remote
この関数は@var{program}という名前の実行可能ファイルを検索して、その実行可能ファイルの絶対ファイル名と、もしあればファイル名の拡張子も含めてリターンする。ファイルが見つからなければ@code{nil}をリターンする。この関数は@code{exec-path}内のすべてのディレクトリーを検索して、@code{exec-suffixes}内のすべてのファイル名拡張子の検索も試みる(@ref{Subprocess
Creation}を参照)。

@var{remote}が@code{nil}、かつ非@code{default-directory}がリモートディレクトリーなら、@var{program}は各リモートホスト上で検索される。
@end defun

@node Changing Files
@section ファイルの名前と属性の変更
@c @cindex renaming files  Duplicates rename-file
@cindex copying files
@cindex deleting files
@cindex linking files
@cindex setting modes of files

  このセクションの関数はファイルのリネーム、コピー、削除やリンク、モードをセットします。これらの関数は処理に失敗すると、通常は失敗の理由を記述するシステム依存のエラーメッセージを報告する@code{file-error}エラーをシグナルします。ファイルが存在しないために失敗すると、かわりに@code{file-missing}エラーをシグナルします。

  性能的な理由によりオペレーティングシステムはこれらの関数により行われた変更を2次記憶装置に書き込むかわりに、キャッシュしたりエイリアスするかもしれません。@ref{Files
and Storage}を参照してください。

  引数@var{newname}をもつ関数では、それがディレクトリー名ならsource名の非ディレクトリー部分が追加されたかのように扱われます。ディレクトリー名は通常は@samp{/}で終端されます(@ref{Directory
Names}を参照)。たとえば@var{oldname}が@file{a/b/c}で@var{newname}が@file{d/e/f/}なら@file{d/e/f/c}であるかのように処理されます。@var{newname}がディレクトリー名ではなくディレクトリーであるような名前なら、この特別な扱いは適用されません。たとえば@var{newname}の@file{d/e/f}がディレクトリーでも、そのまま処理されます。

  @var{newname}という引数をもつ関数では、@var{newname}という名前のファイルが既に存在する場合には、その挙動が引数@var{ok-if-already-exists}の値に依存します。

@itemize @bullet
@item
@var{ok-if-already-exists}が@code{nil}なら@code{file-already-exists}エラーがシグナルされる。

@item
@var{ok-if-already-exists}が数字なら確認を求める。

@item
@var{ok-if-already-exists}が他の値なら確認なしで古いファイルを置き換える。
@end itemize

@deffn Command add-name-to-file oldname newname &optional ok-if-already-exists
@cindex file with multiple names
@cindex file hard link
この関数は、@var{oldname}という名前のファイルに@var{newname}という名前を追加で与える。これは@var{newname}という名前が@var{oldname}にたいする新たなハードリンクになることを意味する。

@var{newname}がシンボリックリンクなら、リンクが指すディレクトリーエントリーではなく、シンボリックリンクリンクのディレクトリーエントリーが置き換えられる。@var{oldname}がシンボリックリンクなら、この関数はリンクをフォローする可能性があるが、GNUプラットフォームではリンクをフォローしない。@var{oldname}がディレクトリーなら、たとえ処理を正常に行ってツリー構造ではないファイルシステムを作成できる古い様式の非GNUプラットフォームのスーパーユーザーでも、この関数は通常は失敗する。

以下の例の最初の部分では2つのファイル@file{foo}と@file{foo3}をリストする。

@example
@group
$ ls -li fo*
81908 -rw-rw-rw- 1 rms rms 29 Aug 18 20:32 foo
84302 -rw-rw-rw- 1 rms rms 24 Aug 18 20:31 foo3
@end group
@end example

ここで@code{add-name-to-file}を呼び出してハードリンクを作成して再度ファイルをリストする。このリストには1つのファイルにたいして2つの名前@file{foo}と@file{foo2}が表示される。

@example
@group
(add-name-to-file "foo" "foo2")
     @result{} nil
@end group

@group
$ ls -li fo*
81908 -rw-rw-rw- 2 rms rms 29 Aug 18 20:32 foo
81908 -rw-rw-rw- 2 rms rms 29 Aug 18 20:32 foo2
84302 -rw-rw-rw- 1 rms rms 24 Aug 18 20:31 foo3
@end group
@end example

最後に以下を評価する:

@example
(add-name-to-file "foo" "foo3" t)
@end example

@noindent
そしてファイルを再度リストする。今度は1つのファイルにたいして3つの名前@file{foo}、@file{foo2}、@file{foo3}がある。@file{foo3}の古いコンテンツは失われた。

@example
@group
(add-name-to-file "foo1" "foo3")
     @result{} nil
@end group

@group
$ ls -li fo*
81908 -rw-rw-rw- 3 rms rms 29 Aug 18 20:32 foo
81908 -rw-rw-rw- 3 rms rms 29 Aug 18 20:32 foo2
81908 -rw-rw-rw- 3 rms rms 29 Aug 18 20:32 foo3
@end group
@end example

この関数は1つのファイルにたいして複数の名前をもつことが許されないオペレーティングシステムでは無意味である。いくつかのシステムでは、かわりにファイルをコピーすることにより複数の名前を実装している。

@ref{File Attributes}の@code{file-nlinks}も参照のこと。
@end deffn

@deffn Command rename-file filename newname &optional ok-if-already-exists
このコマンドは@var{filename}を@var{newname}にリネームする。

@var{filename}が@var{filename}とは別に追加の名前をもつ場合には、それらは自身の名前をもち続ける。実際のところ@code{add-name-to-file}で名前@var{newname}を追加してから@var{filename}を削除するのは、瞬間的な遷移状態とエラーの処理、ディレクトリーとシンボリックリンクを別とすればリネームと同じ効果がある。

このコマンドはシンボリックリンクをフォローしない。@var{filename}がシンボリックリンクなら、このコマンドはリンクが指すファイルではなくシンボリックリンクをリネームする。@var{newname}がシンボリックリンクなら、リンクが指すディレクトリーエントリーではなくリンクのディレクトリーエントリーを置き換える。

@var{filename}と@var{newname}が同じディレクトリーエントリー(親ディレクトリーが同じでありそのディレクトリー内で同じ名前を与える)なら、このコマンドは何もしない。それ以外なら@var{filename}と@var{newname}が同一のファイルを命名する場合には、このコマンドはPOSIX準拠システムでは何も行わなず、いくつかの非POSIXシステムでは@var{filename}を削除する。

@var{newname}がすでに存在する場合には@var{oldname}がディレクトリーなら空のディレクトリー、非ディレクトリーなら非ディレクトリーでなければならない。
@end deffn

@deffn Command copy-file oldname newname &optional ok-if-already-exists time preserve-uid-gid preserve-extended-attributes
@c FIXME: See Bug#27986 for how the previous sentence might change.
このコマンドはファイル@var{oldname}を@var{newname}にコピーする。@var{oldname}が通常のファイルでなければエラーをシグナルする。@var{newname}がディレクトリーなら最後の名前コンポーネントを保持するようにディレクトリーの中に@var{oldname}をコピーする。

この関数は@var{newname}を作成するために壊れたシンボリックリンクをフォローしない点を除いて、シンボリックリンクをフォローする。

@var{time}が非@code{nil}なら、この関数は新たなファイルにたいして古いファイルと同じ最終変更時刻を与える(これはいくつかの限られたオペレーティングシステムでのみ機能する)。時刻のセットでエラーが発生すると、@code{copy-file}は@code{file-date-error}エラーをシグナルする。インタラクティブに呼び出された場合には、プレフィックス引数は@var{time}にたいして非@code{nil}値を指定する。

引数@var{preserve-uid-gid}が@code{nil}なら、新たなファイルのユーザーとグループの所有権の決定をオペレーティングシステムに委ねる(通常はEmacsを実行中のユーザー)。@var{preserve-uid-gid}が非@code{nil}なら、そのファイルのユーザーとグループの所有権のコピーを試みる。これはいくつかのオペレーティングシステムで、かつそれを行うための正しいパーミッションをもつ場合のみ機能する。

オプション引数@var{preserve-permissions}が非@code{nil}なら、この関数は@var{oldname}のファイルモード(または``パーミッション'')、同様にACL(Access
Control List)とSELinuxコンテキストを@var{newname}にコピーする。@ref{Information about
Files}を参照のこと。

それ以外では、@var{newname}が既存ファイルならファイルモードは変更されず、新たに作成された場合はデフォルトのファイルパーミッション(以下の@code{set-default-file-modes}を参照)によりマスクされる。どちらの場合でもACLやSELinuxコンテキストはコピーされない。
@end deffn

@deffn Command make-symbolic-link target linkname &optional ok-if-already-exists
@pindex ln
@kindex file-already-exists
このコマンドは@var{linkname}という名前で@var{target}にたいするシンボリックリンクを作成する。これはシェルコマンドと@samp{ln
-s @var{target}
@var{linkname}}と似ている。@var{target}は文字列としてのみ扱われる。既存ファイルの名前である必要はない。@var{ok-if-already-exists}が整数ならインタラクティブな使用を意味しており、@var{target}文字列内の先頭の@samp{~}は展開されて、先頭の@samp{/:}は取り除かれる。

@var{target}が相対ファイル名なら結果となるシンボリックリンクはシンボリックリンクを含むディレクトリーにたいして相対的に解釈される。@ref{Relative
File Names}を参照のこと。

@var{target}と@var{linkname}の両方がリモートファイル構文をもち、かつ両者のリモート識別が等価なら、シンボリックリンクは@var{target}のローカルファイル名部分を指す。

この関数はシンボリックリンクをサポートしないシステムでは利用できない。
@end deffn

@cindex trash
@vindex delete-by-moving-to-trash
@deffn Command delete-file filename &optional trash
@pindex rm
このコマンドはファイル@var{filename}を削除する。ファイルが複数の名前をもつ場合には他の名前で存在し続ける。@var{filename}がシンボリックリンクなら@code{delete-file}はシンボリックリンクだけを削除してターゲットは削除しない。

ファイルが存在しない、または削除できない場合には適切な種類の@code{file-error}エラーがシグナルされる(GNU/およびその他のPOSIX準拠システムではファイルのディレクトリーが書き込み可能ならファイルは削除可能)。

オプション引数@var{trash}が非@code{nil}、かつ変数@code{delete-by-moving-to-trash}が非@code{nil}なら、このコマンドはファイルを削除するかわりにシステムのTrash(ゴミ箱)にファイルを移動する。@ref{Misc
File Ops,,Miscellaneous File Operations, emacs, The GNU Emacs
Manual}を参照のこと。インタラクティブに呼び出された際には、プレフィックス引数がなければ@var{trash}は@code{t}、それ以外は@code{nil}。

@ref{Create/Delete Dirs}の@code{delete-directory}も参照のこと。
@end deffn

@cindex file permissions, setting
@cindex permissions, file
@cindex file modes, setting
@deffn Command set-file-modes filename mode &optional flag
この関数は、@var{filename}の@dfn{ファイルモード} (または@dfn{パーミッション})を@var{mode}にセットする。

この関数はデフォルトではシンボリックリンクをフォローする。しかしオプション引数@var{flag}がシンボル@code{nofollow}の場合には、@var{filename}がシンボリックリンクでもこの関数はシンボリックリンクをフォローしない。これによりどこか別の場所で意図せずモードビットを変更してしまうことを防げるかもしれない。シンボリックリンクでのモードビット変更をサポートしないプラットフォームでは、この関数は@var{filename}がシンボリックリンクかつ@var{flag}が@code{nofollow}の際にエラーをシグナルする。

非インタラクティブに呼び出された場合には、@var{mode}は整数でなければならない。その整数の下位12ビットだけが使用される。ほとんどのシステムでは意味があるのは下位9ビットのみ。@var{mode}を入力するLisp構文を使用できる。たとえば、

@example
(set-file-modes "myfile" #o644 'nofollow)
@end example

@noindent
これはそのファイルにたいして所有者による読み取りと書き込み、グループメンバーによる読み取り、その他のユーザーによる読み取り可能であることを指定する。モードビットの仕様の説明は@ref{File
permissions,,, coreutils, The @sc{gnu} @code{Coreutils} Manual}を参照のこと。

インタラクティブに呼び出されると、@var{mode}は@code{read-file-modes}(以下参照)を使用してミニバッファーから読み取られる。この場合にはユーザーは整数、またはパーミッションをシンボルで表現する文字列をタイプできる。

ファイルのパーミッションをリターンする関数@code{file-modes}については@ref{File Attributes}を参照のこと。
@end deffn

@defun set-default-file-modes mode
@cindex umask
この関数はEmacsおよびEmacsのサブプロセスが新たに作成するファイルにデフォルトのパーミッションをセットする。Emacsにより作成されたすべてのファイルはこれらのパーミッション、およびそれらのサブセットとなるパーミッションをもつ(デフォルトファイルパーミッションが実行を許可しても、@code{write-region}は実行パーミッションを付与しないだろう)。GNUやその他のPOSIX準拠システムでは、デフォルトのパーミッションは@samp{umask}の値のビット単位の補数で与えられる。すなわち引数@var{mode}でセットされた各ビットはEmacsが作成するファイルのデフォルトパーミッション内では@emph{リセット}される。

引数@var{mode}は上記の@code{set-file-modes}と同様、パーミッションを指定する整数であること。意味があるのは下位9ビットのみ。

デフォルトのファイルパーミッションは、既存ファイルの変更されたバージョンを保存する際は効果がない。ファイルの保存では既存のパーミッションが保持される。
@end defun

@defmac with-file-modes mode body@dots{}
このマクロは新たなファイルにたいするデフォルトのパーミッションを一時的に@var{modes}
(値は)@code{set-file-modes}にたいする値と同様)にセットしてフォーム@var{body}を評価する。終了時には元にデフォルトのファイルノパーミッションをリストアして、@var{body}の最後のフォームの値をリターンする。

これはたとえばプライベートファイルの作成に有用である。
@end defmac

@defun default-file-modes
この関数はデフォルトのファイルのパーミッションを整数でリターンする。
@end defun

@defun read-file-modes &optional prompt base-file
この関数はミニバッファーからファイルモードのビットのセットを読み取る。1つ目のオプション引数@var{prompt}は非デフォルトのプロンプトを指定する。2つ目のオプション引数@var{base-file}はユーザーが既存ファイルのパーミッションに相対的なモードビット指定をタイプした場合に、この関数がリターンするモードビッの元となる権限をもつファイルの名前を指定する。

ユーザー入力が8進数で表される場合には、この関数はその数字をリターンする。それが@code{"u=rwx"}のようなモードビットの完全なシンボル指定なら、この関数は@code{file-modes-symbolic-to-number}を使用して、それを等価な数字に変換して結果をリターンする。@code{"o+g"}のように相対的な指定なら、その指定の元となるパーミッションは@var{base-file}のモードビットから取得される。@var{base-file}が省略または@code{nil}なら、この関数は元となるモードビットとして@code{0}を使用する。完全指定と相対指定は@code{"u+r,g+rx,o+r,g-w"}のように組み合わせることができる。ファイルモード指定の説明は@ref{File
permissions,,, coreutils, The @sc{gnu} @code{Coreutils} Manual}を参照のこと。
@end defun

@defun file-modes-symbolic-to-number modes &optional base-modes
この関数は@var{modes}内のシンボルによるファイルモード指定を等価な整数に変換する。シンボル指定が既存ファイルにもとづく場合には、オプション引数@var{base-modes}からそのファイルのモードビットが取得される。その引数が省略または@code{nil}なら、0(すべてのアクセスが許可されない)がデフォルトになる。
@end defun

@defun file-modes-number-to-symbolic modes
この関数は@var{modes}の数値によるファイルモード指定を等価なシンボル形式に変換する。
@end defun

@defun set-file-times filename &optional time flag
この関数は@var{filename}のアクセス時刻と変更時刻を@var{time}にセットする。時刻が正しくセットされれば@code{t}、それ以外は@code{nil}がリターン値となる。@var{time}のデフォルトはカレント時刻でありtime値でなければならない(@ref{Time
of Day}を参照)。

この関数はデフォルトではシンボリックリンクをフォローする。しかしオプション引数@var{flag}がシンボル@code{nofollow}の場合には、@var{filename}がシンボリックリンクでもフォローしない。これはどこか別の場所でファイル時刻をうっかり変更してしまうことを防ぐのに役立つかもしれない。シンボリックリンクの時刻変更をサポートしないプラットフォームでは、この関数は@var{filename}がシンボリックリンクかつ@var{flag}が@code{nofollow}の際にはエラーをシグナルする。
@end defun

@defun set-file-extended-attributes filename attribute-alist
この関数は@code{filename}にたいしてEmacsが認識する拡張ファイル属性をセットする。2つ目の引数@var{attribute-alist}は@code{file-extended-attributes}がリターンするalistと同じ形式であること。属性のセットが成功したら@code{t}、それ以外は@code{nil}がリターン値となる。@ref{Extended
Attributes}を参照のこと。
@end defun

@defun set-file-selinux-context filename context
この関数は@var{filename}にたいするSELinuxセキュリティコンテキストに@var{context}をセットする。@var{context}引数は各要素が文字列であるような@code{(@var{user}
@var{role} @var{type} @var{range})}というリストであること。@ref{Extended
Attributes}を参照のこと。

この関数は@var{filename}のSELinuxコンテキストのセットに成功したら@code{t}をリターンする。コンテキストがセットされなかった場合(SELinuxが無効、またはEmacsがSELinuxサポートなしでコンパイルされた場合等)には@code{nil}をリターンする。
@end defun

@defun set-file-acl filename acl
この関数は@var{filename}にたいするACLに@var{acl}をセットする。@var{acl}引数は関数@code{file-acl}がリターンするのと同じ形式であること。@ref{Extended
Attributes}を参照のこと。

この関数は@var{filename}のACLのセットに成功したら@code{t}、それ以外は@code{nil}をリターンする。
@end defun

@node Files and Storage
@section ファイルと二次媒体
@cindex secondary storage

Emacsがファイルを変更した後、その後に生じた電源喪失と媒体エラーにより行った変更が保存されないことには2つの理由があります。1つ目は一方または他方のファイルが後で変更されるまで、オペレーティングシステムは書き込まれたデータを2次ストレージのどこかに格納済みのデータにエイリアスすることです。媒体エラーにより2次ストレージ上のコピーだけが失われると、ファイルは両方とも失われるでしょう。2つ目はオペレーティングシステムがデータを2次ストレージに即座に書き込まないかもしれないので、電源喪失時にはデータが失われます。

@findex write-region
これらはいずれも適切なファイルシステムの設定により回避され得る類のエラーですが、そのようなシステムは通常はより高価であるか非効率的です。より典型的なシステムでは媒体エラーに備えて異なるデバイスにファイルをコピーでき、電源喪失にたいしては変数@code{write-region-inhibit-fsync}に@code{nil}をセットして@code{write-region}を使用できます。@ref{Writing
to Files}を参照してください。

@node File Names
@section ファイルの名前
@cindex file names

  ファイルは一般的に名前で参照され、これはEmacsでも他と同様です。Emacsではファイル名は文字列で表現されます。ファイルを操作する関数はすべてファイル名引数に文字列を期待します。

  ファイル自体の操作に加えて、Emacs
Lispプログラムでファイル名を処理する必要(ファイル名の一部を取得して関連するファイル名構築にその一部を使用する等)がしばしばあります。このセクションではファイル名を扱う方法を説明します。

  このセクションの関数は実際にファイルにアクセスする訳ではないので、既存のファイルやディレクトリーを参照しないファイル名を処理できます。

@findex cygwin-convert-file-name-from-windows
@findex cygwin-convert-file-name-to-windows
@cindex MS-Windows file-name syntax
@cindex converting file names from/to MS-Windows syntax
  MS-DOSやMS-Windowsでは、(実際にファイルを操作する関数と同様)これらの関数はMS-DOSとMS-Windowsのファイル名構文を受け入れます。この構文はPOSIX構文のようにバックスラッシュでコンポーネントを区切りますが、これらの関数は常にPOSIX構文をリターンします。これによりPOSIX構文でファイル名を指定するLispプログラムが変更なしですべてのシステムで正しく機能することが可能になります@footnote{MS-WindowsバージョンのEmacsはCygwin環境用にコンパイルされており、2つのファイル名構文の変換に@code{cygwin-convert-file-name-to-windows}と@code{cygwin-convert-file-name-from-windows}を使用できます。}。

@menu
* File Name Components::     ファイル名のディレクトリー部分と、それ以外。
* Relative File Names::      カレントディレクトリーにたいして相対的なファイル名。
* Directory Names::          ディレクトリーとしてのディレクトリー名と、ファイルとしてのファイル名の違い。
* File Name Expansion::      相対ファイル名から絶対ファイル名への変換。
* Unique File Names::        一時ファイル用の名前の生成。
* File Name Completion::     与えられたファイル名にたいする補完を探す。
* Standard File Names::      パッケージが固定されたファイル名を使用する際に、種々のオペレーティングシステムをシンプルに処理する方法。
@end menu

@node File Name Components
@subsection ファイル名の構成要素
@cindex directory part (of file name)
@cindex nondirectory part (of file name)
@cindex version number (in file name)

  オペレーティングシステムはファイルをディレクトリーにグループ化します。あるファイルを指定するためには、ディレクトリーとそのディレクトリー内でのファイルの名前を指定しなければなりません。それゆえEmacsはファイル名を@dfn{ディレクトリー名}パートと@dfn{非ディレクトリー}(または@dfn{ディレクトリー内ファイル名})パートという、2つの主要パートから判断します。どちらのパートも空の場合があり得ます。これら2つのパートを結合することによって元のファイル名が再構築されます。

  ほとんどのシステムでは最後のスラッシュ(MS-DOSとMS-Windowsではバックスラッシュも許される)までのすべてがディレクトリーパートです。残りが非ディレクトリーパートです。

  ある目的のために、非ディレクトリーパートはさらに正式名称(the name
proper)と@dfn{バージョン番号}に細分されます。ほとんどのシステムでは、名前にバージョン番号をもつのはバックアップファイルだけです。

@defun file-name-directory filename
この関数は@var{filename}のディレクトリーパートをディレクトリー名(@ref{Directory
Names}を参照)としてリターンする。@var{filename}がディレクトリーパートを含まなければ@code{nil}をリターンする。

GNUや他のPOSIX準拠ixシステムでは、この関数がリターンする文字列は常にスラッシュで終わる。MS-DOSではコロンで終わることもあり得る。

@example
@group
(file-name-directory "lewis/foo")  ; @r{GNUの例}
     @result{} "lewis/"
@end group
@group
(file-name-directory "foo")        ; @r{GNUの例}
     @result{} nil
@end group
@end example
@end defun

@defun file-name-nondirectory filename
この関数は@var{filename}の非ディレクトリーパートをリターンする。

@example
@group
(file-name-nondirectory "lewis/foo")
     @result{} "foo"
@end group
@group
(file-name-nondirectory "foo")
     @result{} "foo"
@end group
@group
(file-name-nondirectory "lewis/")
     @result{} ""
@end group
@end example
@end defun

@defun file-name-sans-versions filename &optional keep-backup-version
この関数は、任意のファイルバージョン番号、バックアップバージョン番号、末尾のチルダを取り除いた@var{filename}をリターンする。

@var{keep-backup-version}が非@code{nil}なら、ファイルシステムなどが認識するような真のファイルバージョン番号は破棄されるが、バックアップバージョン番号は保持される。

@example
@group
(file-name-sans-versions "~rms/foo.~1~")
     @result{} "~rms/foo"
@end group
@group
(file-name-sans-versions "~rms/foo~")
     @result{} "~rms/foo"
@end group
@group
(file-name-sans-versions "~rms/foo")
     @result{} "~rms/foo"
@end group
@end example
@end defun

@defun file-name-extension filename &optional period
この関数は@var{filename}から、もしあればすべてのバージョン番号とバックアップ番号を取り除いた後の、終端の拡張子(extension)をリターンする。ファイル名の拡張子とは最後の名前コンポーネント(からすべてのバージョン番号とバックアップ番号を取り去った後)の最後の@samp{.}に後続するパートのこと。

この関数は@file{foo}のような拡張子のないファイル名にたいしては@code{nil}、@file{foo.}のようなnull拡張子にたいしては@code{""}をリターンする。ファイル名の最終コンポーネントが@samp{.}で始まる場合には、その@samp{.}は拡張子の開始とはみなされない。したがって@file{.emacs}の拡張子は@samp{.emacs}ではなく@code{nil}。

@var{period}が非@code{nil}なら、拡張子を区切るピリオドもリターン値に含まれる。その場合には、もし@var{filename}が拡張子をもたなければリターン値は@code{""}。
@end defun

@defun file-name-sans-extension filename
この関数は、もしあれば@var{filename}から拡張子を除いてリターンする。もしバージョン番号やバックアップ番号があるなら、ファイルが拡張子をもつ場合のみそれを削除する。たとえば、

@example
(file-name-sans-extension "foo.lose.c")
     @result{} "foo.lose"
(file-name-sans-extension "big.hack/foo")
     @result{} "big.hack/foo"
(file-name-sans-extension "/my/home/.emacs")
     @result{} "/my/home/.emacs"
(file-name-sans-extension "/my/home/.emacs.el")
     @result{} "/my/home/.emacs"
(file-name-sans-extension "~/foo.el.~3~")
     @result{} "~/foo"
(file-name-sans-extension "~/foo.~3~")
     @result{} "~/foo.~3~"
@end example

最後の2つの例の@samp{.~3~}は拡張子ではなくバックアップ番号であることに注意。
@end defun

@defun file-name-base filename
これは@code{file-name-sans-extension}と@code{file-name-nondirectory}を組み合わせた関数。たとえば、

@example
(file-name-base "/my/home/foo.c")
    @result{} "foo"
@end example
@end defun

@node Relative File Names
@subsection 絶対ファイル名と相対ファイル名
@cindex absolute file name
@cindex relative file name

  ファイルシステム内のすべてのディレクトリーはルートディレクトリーから開始されるツリーを形成します。このツリーのルートから開始されるすべてのディレクトリー名によりファイル名を指定でき、それを@dfn{絶対(absolute)}ファイル名と呼びます。デフォルトディレクトリーからの相対的なツリー中の位置でファイルを指定することもでき、それらは@dfn{相対(relative)}ファイル名と呼ばれます。GNUや他のPOSIX準拠システムでは@samp{~}で開始されるすべてのファイル名は@samp{/}で始まる絶対ファイル名(@ref{abbreviate-file-name}を参照)に展開されますが、相対ファイル名は展開されません。。MS-DOSとMS-Windowsでは絶対ファイル名はスラッシュ、バックスラッシュ、またはドライブ指定@samp{@var{x}:/}で始まります。ここで@var{x}は@dfn{ドライブ文字(drive
letter)}です。

@defun file-name-absolute-p filename
この関数はファイル@var{filename}が絶対ファイル名なら@code{t}、それ以外は@code{nil}をリターンする。ファイル名の最初のコンポーネントが@samp{~}か@samp{~@var{user}}
(@var{user}は有効なログイン名)なら絶対ファイル名とみなす。以下の例では@samp{rms}という名前のユーザーは存在するが、@samp{nosuchuser}という名前のユーザーは存在しないものとする。

@example
@group
(file-name-absolute-p "~rms/foo")
     @result{} t
@end group
@group
(file-name-absolute-p "~nosuchuser/foo")
     @result{} nil
@end group
@group
(file-name-absolute-p "rms/foo")
     @result{} nil
@end group
@group
(file-name-absolute-p "/user/rms/foo")
     @result{} t
@end group
@end example
@end defun

  相対ファイル名が与えられた場合には先頭に@samp{~}があれば展開して、@code{expand-file-name}を使用して絶対ファイル名に変換できます(@ref{File
Name Expansion}を参照)。この関数は絶対ファイル名を相対ファイル名に変換します:

@defun file-relative-name filename &optional directory
この関数は@var{directory}(絶対ディレクトリー名かディレクトリーファイル名)から相対的なファイルと仮定して、@var{filename}と等価な相対ファイル名のリターンを試みる。@var{directory}が省略か@code{nil}なら、カレントバッファーのデフォルトディレクトリーがデフォルト。

絶対ファイル名がデバイス名で始まるオペレーティングシステムがいくつか存在する。そのようなシステムでは、2つの異なるデバイス名から開始される@var{filename}は、@var{directory}にもといた等価な相対ファイル名をもたない。この場合には、@code{file-relative-name}は絶対形式で@var{filename}をリターンする。

@example
(file-relative-name "/foo/bar" "/foo/")
     @result{} "bar"
(file-relative-name "/foo/bar" "/hack/")
     @result{} "../foo/bar"
@end example
@end defun

@node Directory Names
@subsection ディレクトリーの名前
@cindex directory name
@cindex directory file name
@cindex file name of directory

  @dfn{ディレクトリー名(directory
name)}とは、ある文字列が何らかのファイルを命名する場合にはディレクトリーを命名する文字列のことです。ディレクトリーは実際にはファイルの一種なので、ファイル名(@dfn{ディレクトリーファイル名}と呼ばれる)をもち、これはディレクトリー名と関係はあるものの通常は等価ではありません(これはPOSIXの通常の用語と完全に同一ではない)。同じ実体にたいするこれら2つの異なる名前は構文的な変換により関連付けられます。GNUや他のPOSIXシステムではことは単純です。ディレクトリー名の最後が@samp{/}でなければ、ディレクトリーファイル名に@samp{/}を追加してディレクトリー名を取得できます。MS-DOSではこの関連付けはより複雑です。

  ディレクトリー名とディレクトリーファイル名の違いは些細ですが重要です。Emacsの変数や関数の引数を記述する際には、それがディレクトリー名であるとしており、ディレクトリーファイル名は許容されません。@code{file-name-directory}が文字列をリターンするときには常にディレクトリー名をリターンします。

  以下の2つの関数は、ディレクトリー名とディレクトリーファイル名の間で変換を行います。これらの関数は@samp{$HOME}のような環境変数や@samp{~}、@samp{.}、@samp{..}などの構文にたいして、特別なことは何も行いません。

@defun file-name-as-directory filename
この関数はオペレーティングシステムがディレクトリーの名前(ディレクトリー名)と解釈する形式で@var{filename}を表す文字列をリターンする。これはほとんどのシステムでは、(もし終端にそれがなければ)これは文字列にスラッシュを追加することを意味する。

@example
@group
(file-name-as-directory "~rms/lewis")
     @result{} "~rms/lewis/"
@end group
@end example
@end defun

@defun directory-name-p filename
この関数は@var{filename}の終端がディレクトリー区切り文字なら非@code{nil}をリターンする。これはGNUや他のPOSIX準拠システムではスラッシュ@samp{/}、MS-WindowsとMS-DOSではスラッシュとバックスラッシュ@samp{\}がディレクトリー区切りとして認識される。
@end defun

@defun directory-file-name dirname
この関数はオペレーティングシステムがファイルの名前と解釈する形式(ディレクトリーファイル名)で@var{dirname}を表す文字列をリターンする。ほとんどのシステムではこれは文字列すべてがディレクトリー区切り文字で構成されている場合を除き、文字列から最後のディレクトリー区切り文字を削除することを意味する。

@example
@group
(directory-file-name "~lewis/")
     @result{} "~lewis"
@end group
@end example
@end defun

  ディレクトリー名にたいしては@code{concat}を使用して相対ファイルと組み合わせることができます:

@example
(concat @var{dirname} @var{relfile})
@end example

@noindent
これを行う前にファイル名が相対的であることを確認してください。絶対ファイル名を使用すると構文的に不正な結果となったり、間違ったファイルを参照する可能性があります。

  ディレクトリーファイル名の作成にこのような組み合わせを使用しなければ、最初に@code{file-name-as-directory}を使用してそれをディレクトリー名に変換しなければなりません:

@example
(concat (file-name-as-directory @var{dirfile}) @var{relfile})
@end example

@noindent
以下のように手動でスラッシュの結合を試みてはなりません

@example
;;; @r{間違い!}
(concat @var{dirfile} "/" @var{relfile})
@end example

@noindent
なぜならこれには可搬性がないからです。常に@code{file-name-as-directory}を使用してください。

  上述の問題の回避や@var{dirname}の値が@code{nil}かもしれない場合(たとえば@code{load-path}の要素を使用する際)には以下を使用します:

@example
(expand-file-name @var{relfile} @var{dirname})
@end example

ただし@code{expand-file-name}は@var{relfile}の先頭の@samp{~}を展開しますが、これは望んだ動作ではないかもしれません。@ref{File
Name Expansion}を参照してください。

  ディレクトリー名をディレクトリーの省略名に変換するには以下の関数を使用します:

@cindex file name abbreviations
@cindex abbreviated file names
@vindex directory-abbrev-alist
@defun abbreviate-file-name filename
@anchor{abbreviate-file-name}
この関数は@var{filename}の省略された形式をリターンする。
これは@code{directory-abbrev-alist} (@ref{File Aliases,,File Aliases, emacs,
The GNU Emacs
Manual}を参照)で指定される省略名を適用して、引数で与えられるファイル名ががホームディレクトリーかそのサブディレクトリーにあれば、ユーザーのホームディレクトリーを@samp{~}に置換する。ホームディレクトリーがルートディレクトリーなの場合には、多くのシステムでは結果が短縮されないので@samp{~}で置き換えない。

これは名前の一部であるような省略形さえも認識するので、ディレクトリー名とファイル名にも使用できる。
@end defun

@node File Name Expansion
@subsection ファイル名を展開する関数
@cindex expansion of file names

  ファイル名の@dfn{展開(expanding)}と、相対ファイル名を絶対ファイル名に変換することを意味します。これはデフォルトディレクトリーから相対的に行われるため、展開されるファイル名と同様にデフォルトディレクトリーも指定しなければなりません。これは@file{~/}のような省略形
@ifnottex
(@ref{abbreviate-file-name}を参照)、
@end ifnottex
の展開、および@file{./}や@file{@var{name}/../}のような冗長さの排除も行います。

@defun expand-file-name filename &optional directory
この関数は@var{filename}を絶対ファイル名に変換する。@var{directory}が与えられた場合には@var{filename}が相対的であり先頭が@samp{~}でなければ、それが開始点となるデフォルトディレクトリーになる(@var{directory}の値はそれ自体が絶対ディレクトリー名かディレクトリーファイル名であるべきで、それは@samp{~}で始まるかもしれない)。それ以外ではカレントバッファーの@code{default-directory}の値が使用される。たとえば:

@example
@group
(expand-file-name "foo")
     @result{} "/xcssun/users/rms/lewis/foo"
@end group
@group
(expand-file-name "../foo")
     @result{} "/xcssun/users/rms/foo"
@end group
@group
(expand-file-name "foo" "/usr/spool/")
     @result{} "/usr/spool/foo"
@end group
@end example

@var{filename}の最初のスラッシュの前が@samp{~}ならユーザーのホームディレクトリー(通常は環境変数@env{HOME}の値で指定される)に展開される(@ref{General
Variables,,, emacs, The GNU Emacs
Manual}を参照)。最初のスラッシュの前が@samp{~@var{user}}で@var{user}が有効なログイン名なら@var{user}のホームディレクトリーに展開される。リテラル@samp{~}で始まるかもしれない相対的な@var{filename}にたいして展開を望まない場合には@code{(expand-file-name
filename directory)}のかわりに@code{(concat (file-name-as-directory directory)
filename)}を使用できる。

@samp{.}や@samp{..}を含むファイル名は正規化形式に簡略化される:

@example
@group
(expand-file-name "bar/../foo")
     @result{} "/xcssun/users/rms/lewis/foo"
@end group
@end example

出力に@samp{..}部分が残り得る場合もある:

@example
@group
(expand-file-name "../home" "/")
     @result{} "/../home"
@end group
@end example

@noindent
これはルートディレクトリー@file{/}の上位のスーパールート(superroot)という概念をもつファイルシステムのためのものである。その他のファイルシステムでは@file{/../}は@file{/}とまったく同じに解釈される。

@file{.}や空文字列を展開するとデフォルトディレクトリーがリターンされる:

@example
@group
(expand-file-name "." "/usr/spool/")
     @result{} "/usr/spool"
(expand-file-name "" "/usr/spool/")
     @result{} "/usr/spool"
@end group
@end example

@code{expand-file-name}は環境変数を@emph{展開しない}ことに注意。それを行うのは@code{substitute-in-file-name}のみ。

@example
@group
(expand-file-name "$HOME/foo")
     @result{} "/xcssun/users/rms/lewis/$HOME/foo"
@end group
@end example

@code{expand-file-name}はあらゆる階層においてシンボリックリンクをフォローしないことにも注意。これは@samp{..}の扱いが@code{file-truename}と@code{expand-file-name}で異なることに起因する。@samp{/tmp/bar}がディレクトリー@samp{/tmp/foo/bar}にたいするシンボリックリンクであると仮定すると:

@example
@group
(file-truename "/tmp/bar/../myfile")
     @result{} "/tmp/foo/myfile"
@end group
@group
(expand-file-name "/tmp/bar/../myfile")
     @result{} "/tmp/myfile"
@end group
@end example

直接間接を問わず事前に@code{expand-file-name}を呼び出さずに@samp{..}に先行するシンボリックリンクをフォローする必要があるかもしれない場合には、それを呼び出さずに確実に@code{file-truename}を呼び出すこと。@ref{Truenames}を参照されたい。
@end defun

@defvar default-directory
このバッファーローカル変数の値はカレントバッファーにたいするデフォルトディレクトリー。これは絶対ディレクトリー名であること。これは@samp{~}で始まるかもしれない。この変数はすべてのバッファーにおいてバッファーローカル。

2つ目の引数が@code{nil}なら、@code{expand-file-name}はデフォルトディレクトリーを使用する。

値は常にスラッシュで終わる文字列。

@example
@group
default-directory
     @result{} "/user/lewis/manual/"
@end group
@end example
@end defvar

@defun substitute-in-file-name filename
@anchor{Definition of substitute-in-file-name}
この関数は@var{filename}内で参照される環境変数を環境変数の値に置き換える。標準的なUnixシェル構文にしたがい
@samp{$}は環境変数値を置き換るプレフィックスである。入力に@samp{$$}が含まれる場合には、それらは@samp{$}に置き換えられる。これによりユーザーが@samp{$}をクォートする手段が与えられる。

環境変数名は@samp{$}の後に続く一連の英数字(アンダースコアを含む)である。@samp{$}の後続文字が@samp{@{}なら対応する@samp{@}}までのすべてが変数名である。

@code{substitute-in-file-name}により生成された出力で@code{substitute-in-file-name}を呼び出すと不正な結果となる傾向がある。たとえば単一の@samp{$}をクォートするために@samp{$$}を使用しても正しく機能せずに環境変数値の中の@samp{$}は再帰的な置換を導くだろう。したがってこの関数を呼び出して出力をこの関数に渡すプログラムは、その後の不正な結果を防ぐためにすべての@samp{$}文字を二重化する必要がある。

@c Wordy to avoid overfull hbox.  --rjc 15mar92
以下ではユーザーのホームディレクトリーを保持する環境変数@env{HOME}の値が@samp{/xcssun/users/rms}だと仮定する。

@example
@group
(substitute-in-file-name "$HOME/foo")
     @result{} "/xcssun/users/rms/foo"
@end group
@end example

置き換え後には、@samp{/}の直後に@samp{~}や別の@samp{/}が出現すると、この関数は@samp{/}の前にあるすべてを無視する。

@example
@group
(substitute-in-file-name "bar/~/foo")
     @result{} "~/foo"
@end group
@group
(substitute-in-file-name "/usr/local/$HOME/foo")
     @result{} "/xcssun/users/rms/foo"
     ;; @r{@file{/usr/local/}は破棄された}
@end group
@end example

@end defun

  ファイル名の展開が望ましくない場合もあります。そのような場合には展開を抑制するためにファイル名をクォートしてファイル名をそのままリテラルとして処理することができます。ファイル名の前に@samp{/:}を前置することによりクォートが行われます。

@defmac file-name-quote name
このマクロはファイル@var{name}にクォーテーションプレフィクス@samp{/:}を付加する。ローカルファイル@var{name}には@var{name}の前にプレフィクス@samp{/:}を付加する。@var{name}がリモートファイル名なら@var{name}のローカル部分がクォートされる(@ref{Magic
File Names}を参照)。@var{name}がクォート済みのファイル名なら、@var{name}は変更せずにリターンする。

@example
@group
(substitute-in-file-name (file-name-quote "bar/~/foo"))
     @result{} "/:bar/~/foo"
@end group

@group
(substitute-in-file-name (file-name-quote "/ssh:host:bar/~/foo"))
     @result{} "/ssh:host:/:bar/~/foo"
@end group
@end example

マジックファイル名によるファイル名ハンドラーを抑制するためにこのマクロは使用できない(@ref{Magic File Names}を参照)。
@end defmac

@defmac file-name-unquote name
このマクロはファイル@var{name}にクォーテーションプレフィクス@samp{/:}があれば削除する。@var{name}がリモートファイル名なら@var{name}のローカル部分を非クォート化する。
@end defmac

@defmac file-name-quoted-p name
このマクロは@var{name}がプレフィクス@samp{/:}でクォートされていれば非@code{nil}をリターンする。@var{name}がリモートファイル名なら@var{name}のローカル部分をチェックする。
@end defmac


@node Unique File Names
@subsection 一意なファイル名の生成
@cindex unique file names
@cindex temporary files

  一時ファイルに書き込む必要があるプログラムがいくつかあります。以下は、そのようなファイルを構築する便利な方法です:

@example
(make-temp-file @var{name-of-application})
@end example

@noindent
@code{make-temp-file}の役目は、2人の異なるユーザーやジョブが完全に一致する名前のファイルの使用を防ぐことです。

@defun make-temp-file prefix &optional dir-flag suffix text
この関数は一時ファイルを作成して、その名前をリターンする。EmacsはEmacsの各ジョブごとに異なるランダムないくつかの文字を@var{prefix}に追加することにより一時ファイルの名前を作成する。結果として文字列として@var{text}が与えられた場合にはそれを含むファイル、それ以外は空ファイルが新たに作成されることが保障される。MS-DOSでは、8+3のファイル名制限に適合するように、文字列@var{string}が切り詰められる可能性がある。@var{prefix}が相対ファイル名なら@code{temporary-file-directory}にたいして展開される。

@example
@group
(make-temp-file "foo")
     @result{} "/tmp/foo232J6v"
@end group
@end example

@code{make-temp-file}がリターンした際には、一時ファイルは空で作成される。この時点でそのファイルに意図するコンテンツを書き込むこと。

@var{dir-flag}が@code{nil}なら、@code{make-temp-file}は空のファイルのかわりに空のディレクトリーを作成する。これはディレクトリー名ではなく、ディレクトリーのファイル名をリターンする。@ref{Directory
Names}を参照のこと。

@var{suffix}が非@code{nil}なら、@code{make-temp-file}はそれをファイル名の最後に追加する。

@var{text}が文字列なら@code{make-temp-file}はそれをファイルに挿入する。

同じEmacs内で実行される異なるライブラリー間での競合を防ぐために、@code{make-temp-file}を使用する各Lispプログラムがプログラム自身の@var{prefix}を使用すること。@var{prefix}の最後に追加される数字は、異なるEmacsジョブ内で実行される同じアプリケーションを区別する。追加される文字により、同一のEmacsジョブ内でも多数の名前を区別することが可能になる。
@end defun

  一時ファイル用のデフォルトディレクトリーは変数@code{temporary-file-directory}により制御されます。この変数によりすべての一時ファイルにたいして、ユーザーがディレクトリーを指定する一貫した方法が与えられます。@code{small-temporary-file-directory}が非@code{nil}なら、かわりにそれを使うプログラムもいくつかあります。これを使う場合には、@code{make-temp-file}を呼び出す前に正しいディレクトリーにたいしてプレフィックスを展開するべきです。

@defopt temporary-file-directory
@cindex @env{TMPDIR} environment variable
@cindex @env{TMP} environment variable
@cindex @env{TEMP} environment variable
この変数は一時ファイル作成用のディレクトリー名を指定する。値はディレクトリー名であるべきだが、もし値がディレクトリーのファイル名(@ref{Directory
Names}を参照)ならば、Lispプログラムがかわりに対処すればよい。@code{expand-file-name}の2つ目の引数としてその値を使用するのは、それを達成するよい方法である。

デフォルト値はオペレーティングシステムにたいして適切な方法により決定される。これは環境変数@env{TMPDIR}、@env{TMP}、@env{TEMP}にもとづく値で、これらの変数が定義されていなければシステム依存の名前にフォールバックする。

一時ファイルの作成に@code{make-temp-file}を使用しない場合でも、一時ファイルを置くディレクトリーを判断するために依然としてこの変数を使用するべきである。しかし一時ファイルが小さくなることを求める場合には、@code{small-temporary-file-directory}が非@code{nil}ならそれを使用すること。
@end defopt

@defopt small-temporary-file-directory
この変数はサイズが小さいと予想される特定の一時ファイル作成用のディレクトリー名を指定する。

小さくなるかもしれない一時ファイルに書き込みたいなら、以下のようにディレクトリーを計算すること:

@example
(make-temp-file
  (expand-file-name @var{prefix}
                    (or small-temporary-file-directory
                        temporary-file-directory)))
@end example
@end defopt

@defun make-temp-name base-name
この関数は一意なファイル名として使用できる文字列を生成する。この名前は@var{base-name}で始まり、それに各Emacsジョブごとに異なる複数のランダムな文字を追加したものである。これは@code{make-temp-file}と似ているが、(i)名前だけを作成してファイルは作成せず、(ii)@var{base-name}はマジックファイル名ではない絶対ファイル名であること、(iii)リターンされるファイル名がマジックファイル名なら既存のファイルかもしれない、という点が異なる(MS-DOSシステムでは8+3ファイル名制限に適合するように@var{base-name}が切り詰められる)。

@strong{警告:} この関数を使用するべきではない。かわりに@code{make-temp-file}を使用すること!
この関数は競合状態の影響を受けやすい。@code{make-temp-name}呼び出しと一時ファイル作成のタイムラグはセキュリティーホールとなり得る。
@end defun

リモートホストやマウントされたディレクトリーで一時ファイルの作成を要する場合があります。以下の2つの関数はそれをサポートします。

@cindex temporary file on a remote host
@defun make-nearby-temp-file prefix &optional dir-flag suffix
この関数は@code{make-temp-file}と同様だができ得るかぎり@code{default-directory}に近接した一時ファイルを作成する点が異なる。@var{prefix}が相対ファイル名で@code{default-directory}がリモートファイル名かマウントされたファイルシステムに配置されていれば、一時ファイルは関数@code{temporary-file-directory}がリターンするディレクトリー内に作成される。それ以外なら関数@code{make-temp-file}を使用する。@var{prefix}、@var{dir-flag}、@var{suffix}の意味は@code{make-temp-file}の場合と同様。

@example
@group
(let ((default-directory "/ssh:remotehost:"))
  (make-nearby-temp-file "foo"))
     @result{} "/ssh:remotehost:/tmp/foo232J6v"
@end group
@end example
@end defun

@defun temporary-file-directory
@code{make-nearby-temp-file}を通じて一時ファイルを書き込むディレクトリー。@code{default-directory}がリモートの場合にはリモートホスト上の一時ファイル用のディレクトリー。そのようなディレクトリーが存在しない、または@code{default-directory}がマウントされるファイルシステム上に配置される場合(@code{mounted-file-systems}を参照)には、この関数は@code{default-directory}をリターンする。リモートでもマウントされたファイルシステムでもない@code{default-directory}では@code{temporary-file-directory}の値がリターンされる。
@end defun

一時ファイルのファイル名のローカル部分を抽出するためには@code{file-local-name}を使用してください(@ref{Magic File
Names}を参照)。

@node File Name Completion
@subsection ファイル名の補完
@cindex file name completion subroutines
@cindex completion, file name

  このセクションではファイル名を補完するための低レベルサブルーチンについて説明します。より高レベルの関数については@ref{Reading File
Names}を参照してください。

@defun file-name-all-completions partial-filename directory
この関数はディレクトリー@var{directory}内で@var{partial-filename}で始まる名前のファイルにたいする、すべての補完可能なリストをリターンする。補完の順番はそのディレクトリー内でのファイル順序であり、これは予測不能であり何の情報ももたない。

引数@var{partial-filename}は非ディレクトリーパートを含むファイル名でなければならず、スラッシュ(いくつかのシステムではバックスラッシュ)が含まれていてはならない。@var{directory}が絶対ディレクトリーでなければ、@var{directory}の前にカレントバッファーのデフォルトディレクトリーが追加される。

以下の例では@file{~rms/lewis}がカレントデフォルトディレクトリーで、名前が@samp{f}で始まる5つのファイル@file{foo}、@file{file~}、@file{file.c}、@file{file.c.~1~}、@file{file.c.~2~}がある:

@example
@group
(file-name-all-completions "f" "")
     @result{} ("foo" "file~" "file.c.~2~"
                "file.c.~1~" "file.c")
@end group

@group
(file-name-all-completions "fo" "")
     @result{} ("foo")
@end group
@end example
@end defun

@defun file-name-completion filename directory &optional predicate
この関数はディレクトリー@var{directory}内でファイル名@var{filename}を補完する。これはディレクトリー@var{directory}内で、@var{filename}で始まるすべてのファイル名にたいして、最長の共通プレフィックスをリターンする。@var{predicate}が非@code{nil}なら展開された絶対ファイル名を単一の引数として呼び出して、@var{predicate}を満足しない補完候補を無視する。

マッチが1つだけ存在して、かつ@var{filename}が正確にそれにマッチする場合には、この関数は@code{t}をリターンする。関数はディレクトリー@var{directory}が@var{filename}で始まる名前のファイルを含まなければ@code{nil}をリターンする。

以下の例では@file{~rms/lewis}がカレントデフォルトディレクトリーで、名前が@samp{f}で始まる5つのファイル@file{foo}、@file{file~}、@file{file.c}、@file{file.c.~1~}、@file{file.c.~2~}がある:

@example
@group
(file-name-completion "fi" "")
     @result{} "file"
@end group

@group
(file-name-completion "file.c.~1" "")
     @result{} "file.c.~1~"
@end group

@group
(file-name-completion "file.c.~1~" "")
     @result{} t
@end group

@group
(file-name-completion "file.c.~3" "")
     @result{} nil
@end group
@end example
@end defun

@defopt completion-ignored-extensions
@code{file-name-completion}はこのリスト内の任意の文字列で終わるファイル名を通常は無視する。すべての可能な補完がこれらのサフィックスのいずれか1つで終わるときはそれらを無視しない。この変数は@code{file-name-all-completions}に影響しない。

以下は典型的な値:

@example
@group
completion-ignored-extensions
     @result{} (".o" ".elc" "~" ".dvi")
@end group
@end example

@code{completion-ignored-extensions}のある要素がスラッシュ@samp{/}で終わる場合には、それはディレクトリーを示す。スラッシュで@emph{終わらない}要素がディレクトリーにマッチすることは決してない。したがって上記の値は@file{foo.elc}という名前のディレクトリーを除外しないだろう。
@end defopt

@node Standard File Names
@subsection 標準的なファイル名

  Emacs
Lispプログラムが特定の用途のために標準的なファイル名を指定することが必要な場合があります。典型的にはカレントユーザーによって指定された設定データを保持する場合が該当します。そのようなファイルは、通常は@code{user-emacs-directory}で指定されるディレクトリーに配置されて、
デフォルトでは通常は@file{~/.config/emacs/}か@file{~/.emacs.d/}です(@ref{Find Init,,How
Emacs Finds Your Init File, emacs, The GNU Emacs
Manual}を参照)。たとえばabbrev(abbreviation:
省略形)の定義は、デフォルトでは@file{~/.config/emacs/abbrev_defs}か@file{~/.emacs.d/abbrev_defs}に格納されます。このようなファイル名を指定するためには、関数@code{locate-user-emacs-file}を使用するのがもっとも簡単な方法です。

@defun locate-user-emacs-file base-name &optional old-name
この関数はEmacs特有の設定ファイルやデータファイルにたいする絶対ファイル名をリターンする。引数@file{base-name}は、相対ファイル名であること。リターン値は@code{user-emacs-directory}で指定されるディレクトリー内の絶対ファイル名。そのディレクトリーが存在しなければ、この関数はディレクトリーを作成する。

オプション引数@var{old-name}が非@code{nil}なら、それはユーザーのホームディレクトリー内のファイル@file{~/@var{old-name}}を指定する。そのようなファイルが存在すれば、リターン値は@var{base-name}で指定されるファイルではなくそのファイルの絶対ファイル名となる。これはEmacsパッケージが後方互換を提供するために使用されることを意図した引数。たとえば@code{user-emacs-directory}導入前には、abbrevファイルは@file{~/.abbrev_defs}に置かれていた。以下は@code{abbrev-file-name}の定義である:

@example
(defcustom abbrev-file-name
  (locate-user-emacs-file "abbrev_defs" ".abbrev_defs")
  "Default name of file from which to read abbrevs."
  @dots{}
  :type 'file)
@end example
@end defun

  ファイル名の標準化のための低レベル関数は@code{convert-standard-filename}で、これはサブルーチンとして@code{locate-user-emacs-file}により使用されます。

@defun convert-standard-filename filename
この関数は@var{filename}にもとづいたカレントオペレーティングシステムの慣習に適合するファイル名をリターンする。

GNUや他のPOSIX準拠システムでは単に@var{filename}をリターンする。その他のオペレーティングシステムではシステム固有のファイル名規約にしたがうだろう。たとえばMS-DOSでは、この関数はMS-DOSファイル名制限にしたがうように先頭の@samp{.}を@samp{_}に変換したり、@samp{.}の後続の文字を3文字に切り詰める等、さまざまな変更を行う。

この関数でGNUとUnixシステムの慣習に適合する名前を指定して、それを@code{convert-standard-filename}に渡すのが推奨される使用方法である。
@end defun

@node Contents of Directories
@section ディレクトリーのコンテンツ
@cindex directory-oriented functions
@cindex file names in directory

  ディレクトリーとはファイルの一種であり、さまざまな名前のファイルを含んでいます。ディレクトリーはファイルシステムの機能です。

  Emacsはディレクトリー内のファイル名をLispのリストとして一覧したり、シェルコマンド@code{ls}を使用してバッファー内にファイル名を表示することができます。後者の場合には、Emacsはオプションで各ファイルに関する情報も表示でき、それは@code{ls}コマンドに渡すオプションに依存します。

@defun directory-files directory &optional full-name match-regexp nosort count
この関数はディレクトリー@var{directory}内のファイルの名前のリストをリターンする。デフォルトではリストはアルファベット順。

この関数は@var{full-name}が非@code{nil}ならファイルの絶対ファイル名、それ以外なら指定されたディレクトリーにたいする相対ファイル名をリターンする。

@var{match-regexp}が非@code{nil}なら、この関数は非ディレクトリー部分が正規表現にたいするマッチを含むファイル名だけをリターンして、それ以外のファイル名はリストから除外される。case(大文字小文字)を区別するファイルシステムでは、caseを区別する正規表現マッチングが行われる。

@var{nosort}が非@code{nil}なら@code{directory-files}はリストをソートしないので、取得するファイル名に特定の順序はない。最大限の可能なスピードを得る必要がありファイル処理順を気にしなければこれを使用する。ユーザーから処理順が可視なら、名前をソートすれば多分ユーザーはより幸せになるだろう。

@var{count}が非@code{nil}なら最初の@var{count}個のファイル名、またはすべてのファイル名のいずれか早いほうをリターンする。@var{count}は0より大な整数であること。

@example
@group
(directory-files "~lewis")
     @result{} ("#foo#" "#foo.el#" "." ".."
         "dired-mods.el" "files-ja.texi"
         "files-ja.texi.~1~")
@end group
@end example

@var{directory}が読み取り可能なディレクトリー名でなければエラーがシグナルされる。
@end defun

@defun directory-empty-p directory
このユーティリティー関数は与えられた@var{directory}がアクセス可能なディレクトリーかつ何のファイルも含まない(空ディレクトリー)場合には@code{t}をリターンする。ディレクトリー内のファイルとして@samp{.}や@samp{..}をリターンするシステムでは、それらは無視される。

ディレクトリーへのシンボリックリンクはディレクトリーとみなされる。シンボリックリンクと区別する方法については@var{file-symlink-p}を参照のこと。
@end defun

@cindex recursive traverse of directory tree
@defun directory-files-recursively directory regexp &optional include-directories predicate follow-symlinks
@var{regexp}にマッチする名前をもつ@var{directory}配下のすべてのファイルをリターンする。この関数はベースネーム(basename:
先行するディレクトリー部分を除外したファイル名)が@var{regexp}にマッチするファイルを、@var{directory}とそのサブディレクトリーを再帰的に検索して、マッチしたファイルの絶対ファイル名(@ref{Relative
File Names, absolute file
names}を参照)のリストをリターンする。ファイル名は深さ優先順でリターンされ、それは親ディレクトリーの前に任意のサブディレクトリー内のファイルが配置されることを意味する。加えて各ディレクトリー内で見つかったファイルはベースネームにもとづいてソートされる。デフォルトでは@var{regexp}にマッチする名前のディレクトリーはリストから省略されるが、オプション引数@var{include-directories}が非@code{nil}ならそれらも含まれる。

デフォルトではすべてのサブディレクトリーが含まれる。@var{predicate}が@code{t}ならサブディレクトリーを含める際のエラー(たとえばそのユーザーでは読み取り不可の場合)は無視される。@code{nil}や@code{t}以外なら、1つのパラメーター(サブディレクトリー名)を受け取り、そのディレクトリーを含める場合には非@code{nil}をリターンする関数であること。

デフォルトではサブディレクトリーへのシンボリックリンクはフォローしないが、@var{follow-symlinks}が非@code{nil}ならフォローする。
@end defun


@defun locate-dominating-file file name
@var{file}から開始してディレクトリーツリー階層を上方に@var{name}
(文字列)というディレクトリーを検索して、最初に見つけたディレクトリーをリターンする。@var{file}がファイルならファイルのディレクトリーが検索の開始位置、それ以外なら@var{file}は検索を開始するディレクトリーであること。この関数は開始ディレクトリーを調べて、それからその親ディレクトリー、更にその親ディレクトリー、...のように@var{name}というディレクトリーを見つけるか、あるいは@var{name}が見つけることなくファイルシステムのロートディレクトリーに到達するまで検索を行う。後者の場合には@code{nil}をリターンする。

引数@code{name}は述語関数でもよい。この述語は関数により検査される、@var{file}
(@var{file}がディレクトリーでない場合でも)から開始されるすべてのディレクトリーにたいして呼び出される。この述語は1つの引数(ファイルかディレクトリー)で呼び出されて、それが検索しているディレクトリーなら非@code{nil}をリターンすること。
@end defun

@defun directory-files-and-attributes directory &optional full-name match-regexp nosort id-format count
これはどのファイルを報告するか、およびファイル名を報告する方法において@code{directory-files}と似ている。しかしこの関数はファイル名のリストをリターンするかわりに、各ファイルごとにリスト@code{(@var{filename}
.
@var{attributes})}をリターンする。ここで@var{attributes}は、そのファイルにたいして@code{file-attributes}がリターンする値。オプション引数@var{id-format}は、@code{file-attributes}の対応する引数と同じ意味をもつ(@ref{Definition
of file-attributes}を参照)。
@end defun

@defvr Constant directory-files-no-dot-files-regexp
この正規表現は@samp{.}と@samp{..}を除いたすべてのファイル名にマッチする。より正確にはこれら2つを除いたすべての空文字列以外の部分にマッチする。これは@code{directory-files}および@code{directory-files-and-attributes}の@var{match-regexp}引数として有用。

@example
(directory-files "/foo" nil directory-files-no-dot-files-regexp)
@end example

ディレクトリー@samp{/foo}が空なら@code{nil}をリターンする。
@end defvr

@defun file-expand-wildcards pattern &optional full
この関数はワイルドカードパターン@var{pattern}を展開して、それにマッチするファイル名のリストをリターンする。

絶対ファイル名として@var{pattern}が記述されると値も絶対ファイル名になる。

@var{pattern}が相対ファイル名で記述されていれば、それはカレントデフォルトディレクトリーにたいして相対的に解釈される。通常はリターンされるファイル名もカレントデフォルトディレクトリーにたいする相対ファイル名になる。しかし@var{full}が非@code{nil}なら絶対ファイル名がリターンされる。
@end defun

@defun insert-directory file switches &optional wildcard full-directory-p
この関数は@code{ls}の@var{switches}に対応するフォーマットで、(カレントバッファー内に)ディレクトリー@var{file}のディレクトリーリストを挿入する。これは挿入したテキストの後にポイントを残す。@var{switches}にはオプション文字列、または個別のオプションを表す文字列リストを指定できる。

引数@var{file}にはディレクトリー、またはワイルドカード文字を含むファイル名を指定できる。@var{wildcard}が非@code{nil}なら@var{file}はワイルドカードを伴うファイル指定として扱われることを意味する。

@var{full-directory-p}が非@code{nil}なら、ディレクトリーリストにたいしてディレクトリーの完全なコンテンツ表示を要求することを意味する。@var{file}がディレクトリーでスイッチに@samp{-d}が含まれないときには、@code{t}を指定すること(@code{ls}へのオプション@samp{-d}は、ディレクトリーのコンテンツではなくファイルとしてディレクトリーを表示するよう指定する)。

ほとんどのシステムでは、この関数は変数@code{insert-directory-program}の名前のディレクトリーリスト用プログラムを実行することにより機能する。@var{wildcard}が非@code{nil}なら、ワイルドカード展開するために@code{shell-file-name}で指定されるシェルの実行も行う。

MS-DOSとMS-Windowsシステムは標準的なUnixプログラム@code{ls}を欠くので、この関数はLispコードで@code{ls}をエミュレートする。

技術的な詳細としては@var{switches}にロングオプション@samp{--dired}が含まれる際に、@code{insert-directory}はdiredのためにこれを特別に扱う。しかし他のオプションと同様、通常は等価なショートオプション@samp{-D}が単に@code{insert-directory-program}に渡されるだけである。
@end defun

@defvar insert-directory-program
この変数の値は関数@code{insert-directory}用にディレクトリーリストを生成するプログラムである。この値はLispコードでこのリストを生成するシステムでは無視される。
@end defvar

@node Create/Delete Dirs
@section ディレクトリーの作成・コピー・削除
@cindex creating, copying and deleting directories
@c Emacs 19 features

  Emacs
Lispのファイル操作関数のほとんどは、ディレクトリーであるようなファイルに使用されたときはエラーとなります。たとえば@code{delete-file}でディレクトリーの削除はできません。以下のスペシャル関数はディレクトリーの作成と削除を行うために存在します。

@findex mkdir
@deffn Command make-directory dirname &optional parents
このコマンドは@var{dirname}という名前のディレクトリーを作成する。@var{parents}が非@code{nil}の場合(インタラクティブな呼び出しでは常に非@code{nil})には、その親ディレクトリーがまだ存在しなければ最初にそれを作成することを意味する。@code{mkdir}はこのコマンドにたいするエイリアス。
@end deffn

@deffn Command make-empty-file filename &optional parents
このコマンドは@var{filename}という名前の空のファイルを作成する。このコマンドは@code{make-directory}と同様に、@var{parents}が非@var{filename}がすでに存在する場合には、このコマンドはエラーをシグナルする。
@end deffn

@deffn Command copy-directory dirname newname &optional keep-time parents copy-contents
このコマンドは@var{dirname}という名前のディレクトリーを@var{newname}にコピーする。@var{newname}がディレクトリー名なら@var{dirname}はそれのサブディレクトリーにコピーされる。@ref{Directory
Names}を参照のこと。

これは常にコピーされるファイルのファイルモードを、対応する元のファイルモードと一致させる。

3つ目の引数@var{keep-time}が非@code{nil}なら、それはコピーされるファイルの修正時刻を保持することを意味する。プレフィックス引数を与えると、@var{keep-time}は非@code{nil}になる。

4つ目の引数@var{parents}は、親ディレクトリーが存在しない場合に作成するかどうかを指定する。インタラクティブな場合には、これはデフォルトで発生する。

5つ目の引数@var{copy-contents}が非@code{nil}の場合には、それは@var{newname}がディレクトリー名ならば、そのサブディレクトリーとして@var{dirname}をコピーするかわりに@var{dirname}のコンテンツを@var{newname}にコピーする。
@end deffn

@cindex trash
@vindex delete-by-moving-to-trash
@deffn Command delete-directory dirname &optional recursive trash
このコマンドは@var{dirname}という名前のディレクトリーを削除する。関数@code{delete-file}はディレクトリーであるようなファイルにたいしては機能しない。それらにたいしては@code{delete-directory}を使用しなければならない。@var{recursive}が@code{nil}でディレクトリー内にファイルが存在する場合には、@code{delete-directory}はエラーをシグナルする。@var{recursive}が非@code{nil}なら、@code{delete-directory}の処理前にそのディレクトリーやディレクトリーのファイルを他のプロセスが削除したという稀な状況を除いてエラーは発生しない。

@code{delete-directory}は親ディレクトリーの階層のシンボリックリンクだけをフォローする。

オプション引数@var{trash}が非@code{nil}、かつ変数@code{delete-by-moving-to-trash}が非@code{nil}なら、このコマンドはファイルを削除するかわりにシステムのTrash(ゴミ箱)にファイルを移動する。@ref{Misc
File Ops,,Miscellaneous File Operations, emacs, The GNU Emacs
Manual}を参照のこと。インタラクティブに呼び出された際には、プレフィックス引数がなければ@var{trash}は@code{t}、それ以外は@code{nil}。
@end deffn

@node Magic File Names
@section 特定のファイル名の``Magic''の作成
@cindex magic file names

  特定のファイル名にたいして特別な処理を実装できます。これはそれらの名前にたいする@dfn{magic}化と呼ばれます。この機能は主にリモートファイルにたいするアクセスの実装用に使用されます(@ref{Remote
Files,, Remote Files, emacs, The GNU Emacs Manual}を参照)。

  magicファイル名を定義するには、名前クラスを定義するための正規表現とそれにマッチするファイル名用のEmacsファイル操作プリミティブすべてを実装するハンドラーを定義しなければなりません。

@cindex file name handler
@vindex file-name-handler-alist
  変数@code{file-name-handler-alist}は各ハンドラーに適用するときを決定する正規表現とともにハンドラーのリストを保持します。各要素は以下の形式をもちます:

@example
(@var{regexp} . @var{handler})
@end example

@noindent
ファイルアクセスとファイル名変換にたいするすべてのEmacsプリミティブは、@code{file-name-handler-alist}にたいして与えられたファイル名をチェックします。そのファイル名が@var{regexp}にマッチしたら、そのプリミティブが@var{handler}を呼び出してファイルを処理します。

  @var{handler}の1つ目の引数には、プリミティブの名前をシンボルとして与えます。残りの引数はそのプリミティブに引数として渡されます(これらの引数の1つ目はほとんどの場合はファイル名自身)。たとえば以下を行って:

@example
(file-exists-p @var{filename})
@end example

@noindent
@var{filename}がハンドラー@var{handler}をもつなら、@var{handler}は以下のように呼び出されます:

@example
(funcall @var{handler} 'file-exists-p @var{filename})
@end example

  関数が2つ以上の引数を受け取る場合には、それらはファイル名でなければならず、関数はそれらのファイル名それぞれにたいしてハンドラーをチェックします。たとえば、

@example
(expand-file-name @var{filename} @var{dirname})
@end example

@noindent
以下を行うと、@var{filename}にたいするハンドラーをチェックした後に@var{dirname}にたいするハンドラーをチェックします。どちらの場合でも@var{handler}は以下のように呼び出されます:

@example
(funcall @var{handler} 'expand-file-name @var{filename} @var{dirname})
@end example

@noindent
その後に@var{handler}は@var{filename}と@var{dirname}のいずれかを処理するか解決する必要があります。

  指定されたファイル名が2つ以上のハンドラーにマッチする場合には、ファイル名の中で最後に開始するマッチが優先されます。リモートファイルアクセスのようなジョブにたいするハンドラーに先立って、解凍のようなジョブにたいするハンドラーが最初に処理されるようにこのルールが選択されました。

  以下はmagicファイル名ハンドラーが処理する操作です:

@ifnottex
@noindent
@code{access-file}、@code{add-name-to-file}、@code{byte-compiler-base-file-name}、@*
@code{copy-directory}、@code{copy-file}、@code{delete-directory}、@code{delete-file}、@code{diff-latest-backup-file}、@code{directory-file-name}、@code{directory-files}、@code{directory-files-and-attributes}、@code{dired-compress-file}、@code{dired-uncache}、@code{exec-path}、@code{expand-file-name}、@*
@code{file-accessible-directory-p}、@code{file-acl}、@code{file-attributes}、@code{file-directory-p}、@code{file-equal-p}、@code{file-executable-p}、@code{file-exists-p}、@code{file-in-directory-p}、@code{file-local-copy}、@code{file-modes}、@code{file-name-all-completions}、@code{file-name-as-directory}、@code{file-name-case-insensitive-p}、@code{file-name-completion}、@code{file-name-directory}、@code{file-name-nondirectory}、@code{file-name-sans-versions}、@code{file-newer-than-file-p}、@code{file-notify-add-watch}、@code{file-notify-rm-watch}、@code{file-notify-valid-p}、@code{file-ownership-preserved-p}、@code{file-readable-p}、@code{file-regular-p}、@code{file-remote-p}、@code{file-selinux-context}、@code{file-symlink-p}、@code{file-system-info}、@code{file-truename}、@code{file-writable-p}、@code{find-backup-file-name}、@*
@code{get-file-buffer}、@code{insert-directory}、@code{insert-file-contents}、@*
@code{load}、@code{make-auto-save-file-name}、@code{make-directory}、@code{make-directory-internal}、@code{make-nearby-temp-file}、@code{make-process}、@code{make-symbolic-link}、@*
@code{process-file}、@code{rename-file}、@code{set-file-acl}、@code{set-file-modes}、@code{set-file-selinux-context}、@code{set-file-times}、@code{set-visited-file-modtime}、@code{shell-command}、@code{start-file-process}、@code{substitute-in-file-name}、@*
@code{temporary-file-directory}、@code{unhandled-file-name-directory}、@code{vc-registered}、@code{verify-visited-file-modtime}、@*
@code{write-region}.
@end ifnottex
@iftex
@noindent
@flushleft
@code{access-file}、@code{add-name-to-file}、
@code{byte-com@discretionary{}{}{}piler-base-file-name}、
@code{copy-directory}、@code{copy-file}、
@code{delete-directory}、@code{delete-file}、
@code{diff-latest-backup-file}、
@code{directory-file-name}、
@code{directory-files}、
@code{directory-files-and-at@discretionary{}{}{}tributes}、
@code{dired-compress-file}、@code{dired-uncache}、
@code{exec-path}、@code{expand-file-name}、
@code{file-accessible-direc@discretionary{}{}{}tory-p}、
@code{file-acl}、
@code{file-attributes}、
@code{file-direc@discretionary{}{}{}tory-p}、
@code{file-equal-p}、
@code{file-executable-p}、@code{file-exists-p}、
@code{file-in-directory-p}、
@code{file-local-copy}、
@code{file-modes}、@code{file-name-all-completions}、
@code{file-name-as-directory}、
@code{file-name-case-insensitive-p}、
@code{file-name-completion}、
@code{file-name-directory}、
@code{file-name-nondirec@discretionary{}{}{}tory}、
@code{file-name-sans-versions}、@code{file-newer-than-file-p}、
@code{file-notify-add-watch}、@code{file-notify-rm-watch}、
@code{file-notify-valid-p}、
@code{file-ownership-pre@discretionary{}{}{}served-p}、
@code{file-readable-p}、@code{file-regular-p}、
@code{file-remote-p}、@code{file-selinux-context}、
@code{file-symlink-p}、@code{file-system-info}、
@code{file-truename}、@code{file-writable-p}、
@code{find-backup-file-name}、
@code{get-file-buffer}、
@code{insert-directory}、
@code{insert-file-contents}、
@code{load}、
@code{make-auto-save-file-name}、
@code{make-direc@discretionary{}{}{}tory}、
@code{make-direc@discretionary{}{}{}tory-internal}、
@code{make-process}、
@code{make-symbolic-link}、
@code{process-file}、
@code{rename-file}、@code{set-file-acl}、@code{set-file-modes}、
@code{set-file-selinux-context}、@code{set-file-times}、
@code{set-visited-file-modtime}、@code{shell-command}、
@code{start-file-process}、
@code{substitute-in-file-name}、
@code{unhandled-file-name-directory}、
@code{vc-regis@discretionary{}{}{}tered}、
@code{verify-visited-file-modtime}、
@code{write-region}。
@end flushleft
@end iftex

  @code{insert-file-contents}にたいするハンドラーは@var{visit}引数が非@code{nil}なら、通常は@code{(set-buffer-modified-p
nil)}によりそのバッファーの変更フラグをクリアーする必要があります。これにはもしそのバッファーがロックされていたら、ロックを解除する効果もあります。

  ハンドラー関数は上記すべての操作を処理しなければならず、他の操作が将来追加される可能性もあります。これらの操作自体すべてを実装する必要はありません
---
特定の操作にたいして特別なことを行う必要がないときには、その操作を通常の方法で処理するように、そのプリミティブを再呼び出しできます。認識できない操作にたいしては、常にそのプリミティブを再呼び出しするべきです。以下はこれを行う方法の1つです:

@smallexample
(defun my-file-handler (operation &rest args)
  ;; @r{特別に処理する必要がある、}
  ;; @r{特別な操作を最初にチェックする}
  (cond ((eq operation 'insert-file-contents) @dots{})
        ((eq operation 'write-region) @dots{})
        @dots{}
        ;; @r{関知しないその他の操作を処理する}
        (t (let ((inhibit-file-name-handlers
                  (cons 'my-file-handler
                        (and (eq inhibit-file-name-operation operation)
                             inhibit-file-name-handlers)))
                 (inhibit-file-name-operation operation))
             (apply operation args)))))
@end smallexample

  ハンドラー関数が通常のEmacsプリミティブを呼び出す決定をした際には、無限再帰を引き起こすような同一ハンドラーからのプリミティブの再呼び出しを防ぐ必要があります。上記の例では変数@code{inhibit-file-name-handlers}と@code{inhibit-file-name-operation}によって、これを行う方法を示しています。上記の例のように、これらを正確に使用するよう注意してください。複数ハンドラーの正しい振る舞いと、それぞれがハンドラーをもつかもしれない2つのファイル名にたいする操作にたいする詳細は非常に重要です。

@kindex safe-magic @r{(property)}
@c FIXME I don't think this means the PATH environment variable?
  ファイルへの実アクセスにたいして実際には特別なことを行わないハンドラー(たとえばリモートファイル名にたいしてホスト名の補完を実装するハンドラー等)は、@code{safe-magic}プロパティに非@code{nil}をもつべきです。たとえばEmacsは通常は@code{PATH}内で見い出されるようなディレクトリーがプレフィックス@samp{/:}によってmagicファイル名に見えるようなら、magicファイル名にならないように保護します。しかし@code{safe-magic}プロパティに非@code{nil}をもつハンドラーがそれらにたいして使用された場合には、@samp{/:}は追加されません。

@kindex operations @r{(property)}
  ファイル名ハンドラーは普通とは異なる方法でそれを処理(handle)するのがどの操作(operation)なのかを宣言するために、@code{operations}プロパティをもつことができます。このプロパティが非@code{nil}値をもつなら、それは操作のリストであるべきです。その場合には、それらの操作だけがハンドラーを呼び出すでしょう。これは無駄を省きますが、主な目的はオートロードされるハンドラー関数が実際に処理を行うとき以外はロードされないようにすることです。

  通常のプリミティブにたいして単にすべての操作を延期しても機能しません。たとえばファイル名ハンドラーが@code{file-exists-p}にたいして適用された場合には、通常の@code{load}コードは正しく機能しないでしょうから、ハンドラー自身で@code{load}を処理しなければなりません。しかしハンドラーが@code{file-exists-p}プロパティを使用して@code{file-exists-p}を処理しないことを宣言した場合には、普通とは異なる方法で@code{load}を処理する必要はなくなります。

@defvar inhibit-file-name-handlers
この変数は特定の操作にたいして現在のところ使用を抑制されているハンドラーのリストを保持する。
@end defvar

@defvar inhibit-file-name-operation
特定のハンドラーにたいしてその時点で抑制されている操作。
@end defvar

@defun find-file-name-handler file operation
この関数は@var{file}というファイル名にたいするハンドラー関数、それが存在しなければ@code{nil}をリターンする。引数@var{operation}はそのファイルを処理する操作であること。これはハンドラー呼び出し時に1つ目の引数として渡すことになる値である。@var{operation}が@code{inhibit-file-name-operation}と等しいか、そのハンドラーの@code{operations}内に存在しなければ、この関数は@code{nil}をリターンする。
@end defun

@defun file-local-copy filename
この関数はファイル@var{filename}がまだローカルマシン上になければ、それをローカルマシン上の通常の非magicファイルにコピーする。magicファイル名は、それらが他のマシン上のファイルを参照する場合には、@code{file-local-copy}操作を処理するべきである。リモートファイルアクセス以外の目的にたいして使用されるmagicファイル名は、@code{file-local-copy}を処理するべきではない。この場合には関数はそのファイルをローカルファイルとして扱うだろう。

@var{filename}がローカルなら、それがmagicか否かにかかわらずこの関数は何も行わずに@code{nil}をリターンする。それ以外ならローカルコピーファイルのファイル名をリターンする。
@end defun

@defun file-remote-p filename &optional identification connected
この関数は@var{filename}がリモートファイルかどうかをテストする。@var{filename}がローカル(リモートではない)ならリターン値は@code{nil}、@var{filename}が正にリモートならリターン値はそのリモートシステムを識別する文字列。

この識別子文字列はホスト名とユーザー名、およびリモートシステムへのアクセスに使用されるメソッドを表す文字列も同様に含めることができる。たとえばファイル名@code{/sudo::/some/file}にたいするリモート識別子文字列は@code{/sudo:root@@localhost:}。

2つの異なるファイルにたいして@code{file-remote-p}が同じ識別子をリターンした場合には、それらが同じファイルシステム上に格納されていて互いに配慮しつつアクセス可能であることを意味する。これはたとえば同時に両方のファイルにアクセスするリモートプロセスを開始することが可能なことを意味する。ファイル名ハンドラーの実装者はこの方式を保証する必要がある。

@var{identification}は文字列としてリターンされるべき識別子の一部を指定する。@var{identification}には@code{method}、@code{user}、@code{host}のシンボルを指定できる。他の値はすべて@code{nil}のように扱われて、それは完全な識別子文字列をリターンすることを意味する。上記の例ではリモートの@code{user}識別子文字列は@code{root}になるだろう。

@var{connected}が非@code{nil}なら、たとえ@var{filename}がリモートであってもEmacsがそのホストにたいする接続をもたなければ、この関数は@code{nil}をリターンする。これは接続が存在しない際の接続の遅延を回避したいときに有用。
@end defun

@defun unhandled-file-name-directory filename
この関数は非magicのディレクトリーの名前をリターンする。これは非magicの@var{filename}には対応するディレクトリー名(@ref{Directory
Names}を参照)をリターンする。magicの@var{filename}には、何の値をリターンするかを決定するためにファイル名ハンドラーを呼び出す。@var{filename}がローカルプロセスからアクセス不能なら、ファイル名ハンドラーは@code{nil}をリターンすることによってそれを示すこと。

これはサブプロセスの実行に有用。すべてのサブプロセスは自身が所属するカレントディレクトリーとして非magicディレクトリーをもたなければならず、この関数はそれを導出するよい手段である。
@end defun

@cindex local part of remote file name
@defun file-local-name filename
この関数は@var{filename}の@dfn{ローカル部分(local
part)}をリターンする。これはリモートホスト上でファイル名を識別する部分であり、通常はリモートファイル名からリモートホストを指定する部分とアクセス方法を取り除いた部分である。たとえば:

@smallexample
(file-local-name "/ssh:@var{user}@@@var{host}:/foo/bar")
     @result{} "/foo/bar"
@end smallexample

この関数はリモートの@var{filename}にたいして、リモートプロセス(@ref{Asynchronous
Processes}と@ref{Synchronous
Processes}を参照)やリモートホスト上で実行されるプログラムの引数として直接使用可能なファイル名をリターンする。@var{filename}がローカルなら、この関数はそれを変更せずにリターンする。
@end defun

@defopt remote-file-name-inhibit-cache
リモートファイルの属性は、よりよいパフォーマンスのためにキャッシュすることができる。キャッシュがEmacsの制御外で変更されると、そのキャッシュ値は無効になり再読込しなければならない。

この変数が@code{nil}にセットされているとキャッシュ値は決して失効しない。このセッティングはEmacs以外にリモートファイルを変更するものがないことが確実な場合のみ慎重に使用すること。これが@code{t}にセットされているとキャッシュ値は決して使用されない。これはもっとも安全な値であるがパフォーマンスは低下するかもしれない。

折衷的な値としてはこれを正の数字にセットする。これはキャッシュされてからその数字の秒数の間は、ャッシュ値を使用することを意味する。リモートファイルが定期的にチェックされる場合には、この変数を定期的なチェックの間隔より小さい値にletバインドするのは、よい考えかもしれない。たとえば:

@example
(defun display-time-file-nonempty-p (file)
  (let ((remote-file-name-inhibit-cache
         (- display-time-interval 5)))
    (and (file-exists-p file)
         (< 0 (file-attribute-size
               (file-attributes
                (file-chase-links file)))))))
@end example
@end defopt

@node Format Conversion
@section ファイルのフォーマット変換

@cindex file format conversion
@cindex encoding file formats
@cindex decoding file formats
@cindex text properties in files
@cindex saving text properties
  Emacsはバッファー内のデータ(テキスト、テキストプロパティ、あるいはその他の情報)とファイルへの格納に適した表現との間で双方向の変換をするために複数のステップを処理します。このセクションでは、この@dfn{フォーマット変換(format
conversion)}を行う基本的な関数、すなわちファイルをバッファーに読み込む@code{insert-file-contents}と、バッファーをファイルに書き込む@code{write-region}を説明します。

@menu
* Overview: Format Conversion Overview.  @code{insert-file-contents}と@code{write-region}
* Round-Trip: Format Conversion Round-Trip.  @code{format-alist}の使用。
* Piecemeal: Format Conversion Piecemeal.  非ペアー変換の指定。
@end menu

@node Format Conversion Overview
@subsection 概要
@noindent
関数@code{insert-file-contents}:

@itemize
@item 最初に、ファイルからバイトをバッファーに挿入して
@item バイトを適切な文字にデコードした後に
@item @code{format-alist}のエントリーで定義されているようにフォーマット処理してから
@item @code{after-insert-file-functions}内の関数を呼び出す。
@end itemize

@noindent
関数@code{write-region}:

@itemize
@item 最初に@code{write-region-annotate-functions}内の関数を呼び出して
@item @code{format-alist}のエントリーで定義されているようにフォーマット処理してから
@item 文字を適切なバイトにエンコードした後に
@item そのバイトでファイルを変更する。
@end itemize

  これはもっとも低レベルでの操作を対照的に示したもので、対象の読み取りと書き込みの処理が逆順で対応しています。このセクションの残りの部分では、上記で名前を挙げた3つの変数を取り巻く2つの機能と、関連するいくつかの関数を説明します。文字のエンコードとデコードについての詳細は@ref{Coding
Systems}を参照してください。

@node Format Conversion Round-Trip
@subsection ラウンドトリップ仕様

  読み取りと書き込みのもっとも一般的な機能は変数@code{format-alist}で制御されます。これは@dfn{ファイルフォーマット(file
format)}仕様のリストで、Emacsバッファー内のデータにたいしてファイル内で使用されるテキスト表現を記述します。読み取りと書き込みの仕様記述はペアーになっており、わたしたちがそれを``ラウンドトリップ(round-trip)''仕様と呼ぶのはこれが理由です(非ペアー仕様については@ref{Format
Conversion Piecemeal}を参照)。

@defvar format-alist
このリストには定義されるファイルフォーマットごとに1つのフォーマット定義が含まれる。フォーマット定義はそれぞれ以下の形式のリスト:

@example
(@var{name} @var{doc-string} @var{regexp} @var{from-fn} @var{to-fn} @var{modify} @var{mode-fn} @var{preserve})
@end example
@end defvar

@cindex format definition
@noindent
以下はフォーマット定義内で要素がもつ意味:

@table @var
@item name
フォーマットの名前。

@item doc-string
フォーマットのドキュメント文字列。

@item regexp
このフォーマットで表現されるファイルの認識に使用される正規表現。@code{nil}ならフォーマットが自動的に適用されることは決してない。

@item from-fn
このフォーマットのデータをデコードする、(ファイルデータを通常のEmacsデータ表現に変換するための)シェルコマンドか関数。

シェルコマンドは文字列として表され、Emacsはそのコマンドを変換処理用のフィルターとして実行する。

@var{from-fn}が関数なら、それは変換するべきバッファー部分を指定する2つの引数@var{begin}と@var{end}で呼び出される。これはインプレースでテキストを編集することにより変換を行うこと。これはテキスト長を変更する可能性があるので@var{from-fn}は変更されたend位置をリターンすること。

ファイルの先頭が変換により@var{regexp}にマッチしないようにするのは@var{from-fn}の役目の1つである。そうでないとおそらく再度変換が呼び出される。さらに@var{from-fn}はデコードされるバッファーやバッファーではないこと。さもなければフォーマット用の内部バッファーが上書きされるかもしれない。

@item to-fn
このフォーマットのデータをエンコード、すなわち通常のEmacsデータ表現をこのフォーマットに変換するためのシェルコマンドか関数。

@var{to-fn}が文字列ならそれはシェルコマンドである。Emacsは変換処理のためのフィルターとしてこのコマンドを実行する。

@var{to-fn}が関数なら、それは3つの引数で呼び出される。@var{begin}と@var{end}は変換されるべきバッファー部分、@var{buffer}でそれがどのバッファーかを指定する。変換を行うには2つの方法がある:

@itemize @bullet
@item
そのバッファー内でインプレースで編集を行う。@var{to-fn}はこの場合は変更にしたがいテキスト範囲のend位置をリターンすること。

@item
注釈(annotation)のリストをリターンする。これは@code{(@var{position}
.
@var{string})}という形式の要素をもつリストで、@var{position}は書き込まれるテキスト内での相対位置を指定する整数、@var{string}はそこに追加される注釈である。このリストは@var{to-fn}がそれをリターンする際には、位置順でソートされていなければならない。

@code{write-region}が実際にバッファーからファイルにテキストを書き込む際には、指定された注釈を対応する位置に混合する。これはすべてバッファーを変更せずに行われる。
@end itemize

@var{from-fn}はデコードされるバッファーやバッファーではないこと。さもなければフォーマット用の内部バッファーが上書きされるかもしれない。

@item modify
フラグ。エンコード関数がバッファーを変更するなら@code{t}、注釈リストをリターンすることによって機能するなら@code{nil}。

@item mode-fn
このフォーマットから変換されたファイルをvisit後に呼び出されるマイナーモード関数。この関数は1つの引数で呼び出されて、それが整数1ならマイナーモード関数はそのモードを有効にする。

@item preserve
フラグ。@code{format-write-file}が@code{buffer-file-format}からこのフォーマットを取り除くべきでなければ@code{t}。
@end table

関数@code{insert-file-contents}は指定されたファイルを読み込む際にファイルフォーマットを自動的に認識します。これはフォーマット定義の正規表現にたいしてファイルの先頭テキストをチェックして、マッチが見つかったら、そのフォーマットにたいするデコード関数を呼び出します。その後は再度すべての既知のフォーマットをチェックします。適用できるフォーマットがない間はチェックを続行します。

@code{find-file-noselect}やそれを使用するコマンドでファイルをvisitすることにより、同じように変換が行われます(内部で@code{insert-file-contents}を呼び出すため)。さらにそれをデコードする各フォーマットのモード関数も呼び出します。これはバッファーローカル変数@code{buffer-file-format}内にフォーマット名のリストを格納します。

@defvar buffer-file-format
この変数はvisitしているファイルのフォーマットを表す。より正確にはこれはカレントバッファーのファイルをvisitに起因するデコードのファイルフォーマット名のリストである。これはすべてのバッファーにたいして常にローカル。
@end defvar

@code{write-region}がデータをファイルに書き込む際には、まず@code{buffer-file-format}にリストされたフォーマットにたいするエンコード関数をリスト内での出現順に呼び出します。

@deffn Command format-write-file file format &optional confirm
このコマンドはカレントバッファーのコンテンツをフォーマット名のリスト@var{format}にもとづいたフォーマットでファイル@var{file}に書き込む。これは@var{format}を起点に、@code{buffer-file-format}の値から@var{preserve}フラグ(上記参照)が非@code{nil}の要素にたいして、それがまだ@var{format}内に存在しなければ任意の個数それらを追加する。その後に将来の保存においてデフォルトとなるように、このフォーマットで@code{buffer-file-format}を更新する。@var{format}引数を除けばこのコマンドは@code{write-file}と似ている。特に@var{confirm}は@code{write-file}での対応する引数と、意味やinteractiveでの扱いが同じである。@ref{Definition
of write-file}を参照のこと。
@end deffn

@deffn Command format-find-file file format
このコマンドはファイル@var{file}を探してそれをフォーマット@var{format}にしたがって変換する。これは後でそのバッファーを保存する場合に@var{format}をデフォルトにすることも行う。

引数@var{format}はフォーマット名のリスト。@var{format}が@code{nil}なら何の変換も行われない。interactiveに呼び出した場合には、@var{format}にたいして単に@key{RET}をタイプすると@code{nil}が指定される。
@end deffn

@deffn Command format-insert-file file format &optional beg end
このコマンドはファイル@var{file}のコンテンツをフォーマット@var{format}にしたがって変換して挿入する。@var{beg}と@var{end}が非@code{nil}なら、それは@code{insert-file-contents}と同様、ファイルのどの部分を読み込むかを指定する(@ref{Reading
from Files}を参照)。

リターン値は絶対ファイル名のリスト、および挿入されたデータの長さ(変換後)であり、これは@code{insert-file-contents}がリターンするものと同様。

引数@var{format}はフォーマット名のリスト。@var{format}が@code{nil}なら何の変換も行われない。interactiveに呼び出した場合には、@var{format}にたいして単に@key{RET}をタイプすると@code{nil}が指定される。
@end deffn

@defvar buffer-auto-save-file-format
この変数は自動保存(auto-saving)にたいして使用するフォーマットを指定する。値は@code{buffer-file-format}と同様、ファイル名のリストだが、これはauto-saveファイルへの書き込みで@code{buffer-file-format}のかわりに使用される。値が@code{t}(デフォルト)なら自動保存は当バッファーの通常の保存時と同じフォーマットを使用する。この変数はすべてのバッファーにおいて常にバッファーローカル。
@end defvar

@node Format Conversion Piecemeal
@subsection 漸次仕様

  前のサブセクション(@ref{Format Conversion
Round-Trip}を参照)で説明したラウンドトリップ指定とは対照的に、変数@code{after-insert-file-functions}と@code{write-region-annotate-functions}を使用して読み取りと書き込みの変換を個別に制御できます。

  変換はある表現を起点として他の表現を生成します。これを行う変換が1つだけのときは、何を起点とするかに関して競合は存在しません。しかし複数の変換呼び出しが存在する場合には、同じデータを起点にする必要がある2つの変換の間に競合が発生するかもしれません。

  この状況を理解するには、@code{write-region}中のテキストプロパティの変換コンテキストが最善です。たとえばあるバッファーの位置42の文字が@samp{X}で、それのテキストプロパティが@code{foo}だとします。@code{foo}にたいする変換が、たとえばそのバッファーに@samp{FOO:}を挿入することにより行われる場合には、それは位置42の文字@samp{X}を@samp{F}に変更します。そして次の変換は間違ったデータを起点に開始されるでしょう。

  競合を避けるためには協調的な変換がバッファーを変更せずに、@var{position}昇順でソートされた@code{(@var{position}
. @var{string})}という形式の要素をもつリストを@dfn{注釈(annotations)}に指定します。

  2つ以上の変換が存在する場合には、@code{write-region}はそれらの注釈を1つのソート済みリストに破壊的にマージします。後でそのバッファーのテキストを実際にファイルに書き込む際に、対応する位置にある指定された注釈を混合します。これはすべてバッファーを変更せずに行われます。

@c ??? What about "overriding" conversions like those allowed
@c ??? for 'write-region-annotate-functions', below?  --ttn

  読み取り時にはこれとは対照的にそのテキストの混合された注釈は即座に処理されます。@code{insert-file-contents}は変更される何らかのテキストの先頭にポイントをセットしてから、そのテキストの長さで変換関数を呼び出します。これらの関数は常に挿入されるテキストの先頭のポイントをリターンするべきです。最初の変換により注釈が削除されても、その後の変換が誤って処理することはないので、このアプローチは読み取りに際しては正しく機能します。すべての変換関数は、それが認識する注釈のスキャン、その注釈の削除、バッファーテキストの変更(たとえばテキストプロパティのセット等)、およびそれらの変更に由来する更新されたテキスト長のリターンを行うべきです。１つの関数によりリターンされた値は次の関数への引数になります。

@defvar write-region-annotate-functions
@code{write-region}にたいして呼び出す関数のリスト。リスト内の各関数は書き込まれるリージョンの開始と終了の2つの引数で呼び出される。これらの関数はそのバッファーのコンテンツを変更するべきではない。かわりに注釈をリターンすること。

特別なケースとして、関数がカレントと異なるバッファーをリターンするかもしれない。Emacsはこれを、出力される変更されたテキストをカレントバッファーが含むものとして理解する。つまりEmacsは@code{write-region}呼び出しの引数@var{start}と@var{end}を、新たなバッファーの@code{point-min}と@code{point-max}に変更して与える。さらに以前のすべての注釈はこの関数により処理されるのでEmacsはそれらの破棄も行う。
@end defvar

@defvar write-region-post-annotation-function
この変数の値が非@code{nil}なら、それは関数であること。この関数は@code{write-region}完了後に引数なしで呼び出される。

@code{write-region-annotate-functions}内のある関数がカレントと異なるバッファーをリターンした場合には、Emacsは@code{write-region-post-annotation-function}を複数回呼び出す。Emacsは最後にカレントだったバッファーでそれを呼び出し、その前にカレントだったバッファーで再度これを呼び出す、...のようにして元のバッファーに戻る。

したがって@code{write-region-annotate-functions}内の関数は、バッファーを作成して、@code{kill-buffer}のそのバッファーでのローカル値にこの変数を与え、変更されたテキストでそのバッファーをセットアップして、そのバッファーをカレントにすることができる。そのバッファーは、@code{write-region}完了後にkillされるだろう。
@end defvar

@defvar after-insert-file-functions
@c ??? The docstring mentions a handler from 'file-name-handler-alist'
@c     "intercepting" 'insert-file-contents'.  Hmmm.  --ttn
このリスト内の各関数は、挿入されるテキストの先頭にポイントがある状態で、挿入される文字数を１つの引数として@code{insert-file-contents}により呼び出される。すべての関数はポイントを未変更のまま、その関数によって変更された挿入後テキストの新たな文字数をリターンすること。
@end defvar

  わたしたちは、ユーザーがファイル内にテキストプロパティを格納したりそれらを取得するために、そしてさまざまなデータフォーマットを体験することにより適切なフォーマットを見つけるために、これらのフックを使用してLispプログラムを記述することを推奨します。最終的にはわたしたちがEmacs内にインストールできる、良質で汎用性のある拡張をユーザーが開発することを望みます。

  わたしたちはテキストプロパティの名前や値として、任意のLispオブジェクトの処理を試みることは推奨しません ---
なぜなら汎用的なプログラムはおそらく記述が困難かつ低速だからです。かわりに十分な柔軟性をもちエンコードが難しすぎない、想定されるデータ型のセットを選択してください。
