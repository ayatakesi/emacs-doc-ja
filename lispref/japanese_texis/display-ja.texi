@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*- mode: texinfo; coding: utf-8 -*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990--1995, 1998--2021 Free Software Foundation, Inc.
@c See the file elisp-ja.texi for copying conditions.
@node Display
@chapter Emacsのディスプレー表示

  このチャプターではEmacsによるユーザーへのプレゼンテーションとなる、表示に関連するいくつかの機能を説明します。

@menu
* Refresh Screen::           スクリーン上にあるすべてのもののクリアーと再描画。
* Forcing Redisplay::        再描画の強制。
* Truncation::               長いテキストの折り畳みと折り返し。
* The Echo Area::            スクリーン最下部へのメッセージ表示。
* Warnings::                 ユーザーへの警告メッセージの表示。
* Invisible Text::           バッファーのテキストの一部を隠す。
* Selective Display::        バッファーのテキストの一部を隠す(旧来の方式)。
* Temporary Displays::       自動的に消える表示。
* Overlays::                 オーバーレイを使用したバッファーの一部のハイライト。
* Size of Displayed Text::   表示されたテキストの大きさ。
* Line Height::              行の高さの制御。
* Faces::                    テキスト文字のグラフィカルスタイル(フォント、カラー等)を定義するフェイス。
* Fringes::                  ウィンドウフリンジの制御。
* Scroll Bars::              スクロールバーの制御。
* Window Dividers::          ウィンドウを視覚的に区別する。
* Display Property::         イメージ、マージン、テキストサイズ、etc.
* Images::                   Emacsバッファー内でのイメージ表示。
* Xwidgets::                 Emacsバッファー内でのネイティブウィジェットの表示。
* Buttons::                  Emacsバッファー内へのイメージ表示クリック可能ボタン追加。
* Abstract Display::         オブジェクトコレクション用のEmacsウィジェット。
* Blinking::                 Emacsがマッチする開カッコを表示する方法。
* Character Display::        Emacsがマッチする個々の文字を表示する方法。
* Beeping::                  ユーザーへの可聴シグナル。
* Window Systems::           どのウィンドウシステムが使用されているか。
* Tooltips::                 Emacsでのツールチップの表示。
* Bidirectional Display::    アラビア語やペルシア語のような双方向スクリプトの表示。
@end menu

@node Refresh Screen
@section スクリーンのリフレッシュ
@cindex refresh the screen
@cindex screen refresh

  関数@code{redraw-frame}は与えられたフレーム(@ref{Frames}を参照)のコンテンツ全体にたいしてクリアーと再描画を行います。これはスクリーンが壊れている(corrupted)場合に有用です。

@defun redraw-frame &optional frame
この関数はフレーム@var{frame}のクリアーと再表示を行う。@var{frame}が省略か@code{nil}なら選択されたフレームを再描画する。
@end defun

  更に強力なのは@code{redraw-display}です:

@deffn Command redraw-display
この関数はすべての可視なフレームのクリアーと再描画を行う。
@end deffn

  Emacsではユーザー入力は再描画より優先されます。入力が可能なときにこれらの関数を呼び出すと、これらはすぐに再描画はしませんが、要求された再描画はすべての入力処理後に行われます。

  テキスト端末では通常はEmacsのサスペントと再開によりスクリーンのリフレッシュも行われます。Emacsのようなディスプレイ指向のプログラムと通常のシーケンシャル表示のプログラムで、コンテンツを区別して記録する端末エミュレーターがいくつかあります。そのような端末を使用する場合には、おそらく再開時の再表示を抑制したいでしょう。

@defopt no-redraw-on-reenter
@cindex suspend (cf. @code{no-redraw-on-reenter})
@cindex resume (cf. @code{no-redraw-on-reenter})
この変数はEmacsがサスペンドや再開された後にスクリーン全体を再描画するかどうかを制御する。非@code{nil}なら再描画は不要、@code{nil}なら再描画が必要であることを意味する。デフォルトは@code{nil}。
@end defopt

@node Forcing Redisplay
@section 強制的な再表示
@cindex forcing redisplay

  Emacsは入力の待機時は常に再表示を試みます。以下の関数により実際に入力を待機することなく、Lispコードの中から即座に再表示を試みることを要求できます。

@defun redisplay &optional force
この関数は即座に再表示を試みる。オプション引数@var{force}が非@code{nil}の場合には、入力が保留中なら横取りされるかわりに強制的に再表示が行われる。

この関数は実際に再表示が試行されたなら@code{t}、それ以外は@code{nil}をリターンする。@code{t}という値は再表示の試行が完了したことを意味しない。新たに到着した入力に横取りされた可能性がある。
@end defun

  @code{redisplay}が即座に再表示を試みたとしても、Emacsがフレーム(複数可)のどの部分を再表示するか決定する方法が変更されるわけではありません。それとは対照的に以下の関数は特定のウィンドウを、(あたかもコンテンツが完全に変更されたかのように)保留中の再表示処理に追加します。しかし再描画を即座には試みません。

@defun force-window-update &optional object
この関数はEmacsが次に再表示を行う際にいくつか、あるいはすべてのウィンドウが更新されるよう強制する。@var{object}がウィンドウならそのウィンドウ、バッファーやバッファー名ならそのバッファーを表示するすべてのウィンドウ、@code{nil}
(または省略)ならすべてのウィンドウが更新される。

この関数は即座に再表示を行わない。再表示はEmacsが入力を待機時、または関数@code{redisplay}呼び出し時に行われる。
@end defun

@defvar pre-redisplay-function
再表示の直前に実行される関数。これは再表示されるウィンドウセットを単一の引数として呼び出される。ウィンドウセットは選択されたウィンドウを意味する@code{nil}、すべてのウィンドウを意味する@code{t}を指定できる。
@end defvar

@defvar pre-redisplay-functions
このフックは再表示の直前に実行される。これは再表示されようとするウィンドウそれぞれにたいして、そのウィンドウに表示されているバッファーを@code{current-buffer}にセットして1回呼び出される。
@end defvar

@node Truncation
@section 切り詰め
@cindex line wrapping
@cindex line truncation
@cindex continuation lines
@cindex @samp{$} in display
@cindex @samp{\} in display

  Emacsはテキスト行がウィンドウ右端を超過する際には、その行を@dfn{継続(continue)}させる(次のスクリーン行へwrap、すなわち折り返す)か、あるいはその行を@dfn{切り詰め(truncate)}て表示(その行をスクリーン行の1行に制限)することができます。長いテキスト行を表示するために使用される追加のスクリーン行は@dfn{継続(continuation)}行と呼ばれます。継続はフィルとは異なります。継続はバッファーのコンテンツ内ではなくスクリーン上でのみ発生して、単語境界ではなく正確に右マージンで行をブレークします。@ref{Filling}を参照してください。

   グラフィカルなディスプレイでは切り詰めと継続はウィンドウフリンジ内の小さな矢印イメージで示されます(@ref{Fringes}を参照)。テキスト端末では切り詰めはそのウィンドウの最右列の@samp{$}、折り返しは最右列の@samp{\}で示されます(ディスプレイテーブルでこれを行うための代替え文字を指定できる。@ref{Display
Tables}を参照)。

@defopt truncate-lines
このバッファーローカル変数が非@code{nil}ならウィンドウ右端を超過する行は切り詰められて、それ以外なら継続される。特別な例外として@dfn{部分幅(partial-width)}ウィンドウ(フレーム全体の幅を占有しないウィンドウ)では変数@code{truncate-partial-width-windows}が優先される。
@end defopt

@defopt truncate-partial-width-windows
@cindex partial-width windows
この変数は@dfn{部分幅(partial-width)}ウィンドウ内の行の切り詰めを制御する。部分幅ウィンドウとはフレーム全体の幅を占有しないウィンドウ(@ref{Splitting
Windows}を参照)。値が@code{nil}なら行の切り詰めは変数@code{truncate-lines}
(上記参照)により決定される。値が整数@var{n}の場合には、部分幅ウィンドウの列数が@var{n}より小さければ@code{truncate-lines}の値とは無関係に行は切り詰められて、部分幅ウィンドウの列数が@var{n}以上なら行の切り詰めは@code{truncate-lines}により決定される。それ以外の非@code{nil}値では@code{truncate-lines}の値とは無関係にすべての部分幅ウィンドウで行は切り詰められる。
@end defopt

  ウィンドウ内で水平スクロール(@ref{Horizontal Scrolling}を参照)を使用中は切り詰めが強制されます。

@defvar wrap-prefix
このバッファーローカル変数が非@code{nil}なら、それはEmacsが各継続行の先頭に表示する@dfn{折り返しプレフィックス(wrap
prefix)}を定義する(行を切り詰めている場合には@code{wrap-prefix}は使用されない)。この値は文字列、またはイメージ(@ref{Other
Display
Specs}を参照)やディスプレイプロパティ@code{:width}や@code{:align-to}で指定されるような伸長された空白文字を指定できる(@ref{Specified
Space}を参照)。値はテキストプロパティ@code{display}と同じ方法で解釈される。@ref{Display
Property}を参照のこと。

折り返しプレフィックスはテキストプロパティかオーバーレイプロパティ@code{wrap-prefix}を使用することにより、テキストのリージョンにたいして指定することもできる。これは@code{wrap-prefix}変数より優先される。@ref{Special
Properties}を参照のこと。
@end defvar

@defvar line-prefix
このバッファーローカル変数が非@code{nil}なら、それはEmacsがすべての非継続行の先頭に表示する@dfn{行プレフィックス(line
prefix)}を定義する。この値は文字列、イメージ(@ref{Other Display
Specs}を参照)、またはディスプレイプロパティ@code{:width}や@code{:align-to}で指定されるような伸長された空白文字を指定できる(@ref{Specified
Space}を参照)。値はテキストプロパティ@code{display}と同じ方法で解釈される。@ref{Display
Property}を参照のこと。

行プレフィックスはテキストプロパティまたはオーバーレイプロパティ@code{line-prefix}を使用することにより、テキストのリージョンにたいして指定することもできる。これは@code{line-prefix}変数より優先される。@ref{Special
Properties}を参照のこと。
@end defvar

@ignore
  If your buffer contains only very short lines, you might find it
advisable to set @code{cache-long-scans} to @code{nil}.

@defvar cache-long-scans
If this variable is non-@code{nil} (the default), various indentation
and motion functions, and Emacs redisplay, cache the results of
scanning the buffer, and consult the cache to avoid rescanning regions
of the buffer unless they are modified.

Turning off the cache speeds up processing of short lines somewhat.

This variable is automatically buffer-local in every buffer.
@end defvar
@end ignore

@node The Echo Area
@section エコーエリア
@cindex error display
@cindex echo area

@c FIXME: Why not use @xref{Minibuffers} directly?  --xfq
  @dfn{エコーエリア(echo
area)}はエラーメッセージ(@ref{Errors})や@code{message}プリミティブで作成されたメッセージの表示、およびキーストロークをエコーするために使用されます。(アクティブ時には)ミニバッファーがスクリーン上のエコーエリアと同じ場所に表示されるという事実にも関わらずエコーエリアはミニバッファーと同じではありません。@ref{Minibuffer,,
The Minibuffer, emacs, The GNU Emacs Manual}を参照してください。

  このセクションに記述された関数とは別に、出力ストリームとして@code{t}を指定することによりエコーエリアにLispオブジェクトをプリントできます。@ref{Output
Streams}を参照してください。

@menu
* Displaying Messages::      エコーエリア内に明示的にテキストを表示する。
* Progress::                 長時間の処理の進行状況をユーザーに知らせる。
* Logging Messages::         ユーザー用にログされるエコーエリアメッセージ。
* Echo Area Customization::  エコーエリアの制御。
@end menu

@node Displaying Messages
@subsection エコーエリアへのメッセージの表示
@cindex display message in echo area

  このセクションではエコーエリア内にメッセージを表示する標準的な関数を説明します。

@defun message format-string &rest arguments
この関数はエコーエリア内にメッセージを表示する。@code{format-message}関数(@ref{Formatting
Strings}を参照)の場合と同じように@var{format-string}はフォーマット文字列、@var{arguments}はそのフォーマット仕様にたいするオブジェクトである。フォーマットされた結果文字列はエコーエリア内に表示される。それに@code{face}テキストプロパティが含まれる場合には指定されたフェイスにより表示される(@ref{Faces}を参照)。この文字列は@file{*Messages*}バッファーにも追加されるがテキストプロパティは含まれない(@ref{Logging
Messages}を参照)。

フォーマット内のグレイヴアクセントとアポストロフィーは@t{"Missing `%s'"}から@t{"Missing
‘foo’"}のように、通常は対応するcurved quoteとして結果内に変換される。この変換に影響を与えたり抑制する方法については@ref{Text
Quoting Style}を参照のこと。

バッチモードでは後に改行が付加されたメッセージが標準エラーストリームにプリントされる。

@code{inhibit-message}が非@code{nil}のときはエコーエリアにはメッセージを何も表示せずに@samp{*Messages*}へのロギングだけとなる。

@var{format-string}が@code{nil}か空文字列なら、@code{message}はエコーエリアをクリアーする。エコーエリアが自動的に拡張されていたら、これにより通常のサイズに復元される。ミニバッファーがアクティブなら、これによりスクリーン上に即座にミニバッファーのコンテンツが復元される。

@example
@group
(message "Reverting `%s'..." (buffer-name))
 @print{} Reverting ‘subr.el’...
@result{} "Reverting ‘subr.el’..."
@end group

@group
---------- Echo Area ----------
Reverting ‘subr.el’...
---------- Echo Area ----------
@end group
@end example

エコーエリアやポップバッファー内に自動的にメッセージを表示するには、そのサイズに応じて@code{display-message-or-buffer}
(以下参照)を使用する。

@strong{警告:} 逐語的なメッセージとして独自の文字列を使用したければ、単に@code{(message
@var{string})}と記述してはならない。@var{string}に@samp{%}、@samp{`}、@samp{'}が含まれていると望まぬ結果に再フォーマットされるかもしれない。かわりに@code{(message
"%s" @var{string})}を使用すること。
@end defun

@defvar set-message-function
この変数が非@code{nil}なら、エコーエリア内に表示するためのメッセージテキストを単一の引数とする関数であること。その関数は@code{message}および関連する関数から呼び出されることになる。その関数が@code{nil}をリターンすると、通常どおりメッセージはエコーエリアに表示される。関数が文字列をリターンすると、その文字列が元メッセージのかわりにエコーエリアに表示される。その関数が他の非@code{nil}値をリターンした場合にはメッセージが処理済みであることを意味するので、@code{message}はエコーエリアに何も表示しない。その関数で表示されたメッセージのクリアーに使用可能な@code{clear-message-function}も参照のこと。

デフォルト値はミニバッファーアクティブ時にミニバッファー終端にメッセージを表示する関数。しかしアクティブなミニバッファーに表示されるテキストの何らかの文字が@code{minibuffer-message}テキストプロパティ(@ref{Special
Properties}を参照)をもつ場合には、メッセージはそのプロパティをもつ最初の文字の前に表示される。
@end defvar

@defvar clear-message-function
この変数が非@code{nil}の場合には、@code{message}および関連する関数は引数となるメッセージが@code{nil}か空文字列なら、それを引数なしで呼び出す。

この関数は通常はエコーエリアメッセージの表示後、次の入力イベントの到着時に呼び出される。これは@code{set-message-function}により指定されたカウンターパートとなる関数が表示したメッセージのクリアーを期待される関数である。

デフォルト値はアクティブなミニバッファーに表示されたメッセージをクリアーする関数。
@end defvar

@defvar inhibit-message
この変数が非@code{nil}なら、@code{message}および関連する関数はメッセージの表示にエコーエリアを使用しない。
@end defvar

@defmac with-temp-message message &rest body
この構文は@var{body}実行の間にエコーエリア内にメッセージを一時的に表示する。これは@var{message}を表示して@var{body}を実行して、それからエコーエリアの前のコンテンツをリストアするとともにbodyの最後のフォームの値をリターンする。
@end defmac

@defun message-or-box format-string &rest arguments
この関数は@code{message}と同様にメッセージを表示するが、エコーエリアではなくダイアログボックスにメッセージを表示するかもしれない。この関数があるコマンド内からマウスを使用して呼び出されると
--- より正確には@code{last-nonmenu-event} (@ref{Command Loop
Info}を参照)が@code{nil}かリストならメッセージの表示にダイアログボックスかポップアップメニュー、それ以外ならエコーエリアを使用する(これは@code{y-or-n-p}が同様の決定を行う際に使用する条件と同じ。@ref{Yes-or-No
Queries}を参照)。

呼び出しの前後で@code{last-nonmenu-event}を適切な値にバインドすることによりエコーエリアでのマウスの使用を強制できる。
@end defun

@defun message-box format-string &rest arguments
@anchor{message-box}
この関数は@code{message}と同様にメッセージを表示するが、利用可能なら常にダイアログボックス(かポップアップメニュー)を使用する。端末がサポートしないためにダイアログボックスやポップアップメニューが使用できなければ、@code{message-box}は@code{message}と同様にエコーエリアを使用する。
@end defun

@defun display-message-or-buffer message &optional buffer-name action frame
この関数はメッセージ@var{message}を表示する。@var{message}には文字列かバッファーを指定できる。これが@code{max-mini-window-height}で定義されるエコーエリアの最大高さより小さければ、@code{message}を使用してエコーエリアに表示される。それ以外ならメッセージを表示するために@code{display-buffer}はポップアップバッファーを使用する。

エコーエリアに表示したメッセージ、またはポップアップバッファー使用時はその表示に使用したウィンドウをリターンする。

@var{message}が文字列ならオプション引数@var{buffer-name}はポップアップバッファー使用時にメッセージ表示に使用するバッファー名(デフォルトは@file{*Message*})。@var{message}が文字列でエコーエリアに表示されていれば、いずれにせよコンテンツをバッファーに挿入するかどうかは指定されない。

オプション引数@var{action}と@var{frame}は@code{display-buffer}の場合と同様に、バッファーが表示されている場合のみ使用される。
@end defun

@defun current-message
この関数はエコーエリア内にカレントで表示されているメッセージ、またはそれが存在しなければ@code{nil}をリターンする。
@end defun

@node Progress
@subsection 処理の進捗レポート
@cindex progress reporting

  処理の完了まで暫く時間を要するかもしれない際には、進行状況についてユーザーに通知するべきです。これによりユーザーが残り時間を予測するとともに、Emacsがhungしているのではなく処理中であることを明確に確認できます。@dfn{プログレスリポーター(progress
reporter: 進行状況リポーター)}を使用するのが、これを行う便利な方法です。

  以下は何も有用なことを行わない実行可能な例です:

@smallexample
(let ((progress-reporter
       (make-progress-reporter "Collecting mana for Emacs..."
                               0  500)))
  (dotimes (k 500)
    (sit-for 0.01)
    (progress-reporter-update progress-reporter k))
  (progress-reporter-done progress-reporter))
@end smallexample

@defun make-progress-reporter message &optional min-value max-value current-value min-change min-time
この関数は以下に挙げる他の関数の引数として使用されることになるプログレスリポーターオブジェクトを作成してリターンする。これはプログレスリポーターを高速にするように、可能なかぎり多くのデータを事前に計算するというアイデアが元となっている。

この後にプログレスリポーターを使用する際には、進行状況のパーセンテージを後に付加して@var{message}が表示されるだろう。@var{message}は単なる文字列として扱われる。たとえばファイル名に依存させる必要があるなら、この関数の呼び出し前に@code{format-message}を使えばよい。

引数@var{min-value}と@var{max-value}は処理の開始と終了を意味する数値であること。たとえばバッファーをスキャンする処理なら、これらをそれぞれ@code{point-min}と@code{point-max}にセットするべきだろう。@var{max-value}は@var{min-value}より大であること。

かわりに@var{min-value}と@var{max-value}を@code{nil}にセットすることができる。この場合にはプログレスリポーターは進行状況のパーセンテージを報告しない。かわりにプログレスリポーターを更新するたびに刻み(notch)を回転する``スピナー(spinner)''を表示する。

@var{min-value}と@var{max-value}が数値なら、進行状況の初期の数値を与える引数@var{current-value}を与えることができる。省略時のデフォルトは@var{min-value}。

残りの引数はエコーエリアの更新レートを制御する。プログレスリポーターは次のメッセージを表示する前に、その処理が少なくとも@var{min-change}パーセントより多く完了するまで待機する。デフォルトは1パーセント。@var{min-time}は連続するプリントの間に空ける最小時間をミリ秒単位で指定する(いくつかのオペレーティングシステムではプログレスリポーターは秒の少数部をさまざまな精度で処理するかもしれない)。

この関数は@code{progress-reporter-update}を呼び出すので、最初のメッセージは即座にプリントされる。
@end defun

@defun progress-reporter-update reporter &optional value
この関数は操作の進行状況報告に関する主要な機能を担う。これは@var{reporter}のメッセージと、その後に@var{value}により決定された進行状況のパーセンテージを表示する。パーセンテージが0、または引数@var{min-change}と@var{min-time}に比べて十分0に近ければ出力は省略される。

@var{reporter}は@code{make-progress-reporter}呼び出しがリターンした結果でなければならない。@var{value}は処理のカレント状況を指定して、@code{make-progress-reporter}に渡された@var{min-value}と@var{max-value}の間(両端を含む)でなければならない。たとえばバッファーのスキャンにおいては、@var{value}は@code{point}び呼び出し結果であるべきだろう。

オプション引数@var{suffix}は、@var{reporter}のメインメッセージと進行状況テキストの後に表示する文字列。@var{reporter}が非数値のリポーターなら@var{value}は@code{nil}、または@var{suffix}のかわりに使用する文字列であること。

この関数は@code{make-progress-reporter}に渡された@var{min-change}と@var{min-time}にしたがい、毎回の呼び出しで新たなメッセージを出力しない。したがってこれは非常に高速であり、通常はこれを呼び出す回数を減らすことを試みるべきではない。結果として生じるオーバーヘッドは、あなたの努力をほぼ否定するだろう。
@end defun

@defun progress-reporter-force-update reporter &optional value new-message suffix
この関数は@code{progress-reporter-update}と同様だが、これは無条件にメッセージをエコーエリアにプリントする点が異なる。

@var{reporter}、@var{value}、@var{suffix}は@code{progress-reporter-update}の場合と同じ意味をもつ。オプションの@var{new-message}で@var{reporter}のメッセージを変更できる。この関数は常にエコーエリアを更新するので、そのような変更は即座にユーザーに示されるだろう。
@end defun

@defun progress-reporter-done reporter
この関数は処理の完了時に呼び出されること。これはエコーエリア内に単語@samp{done}を付加した@var{reporter}のメッセージを表示する。

@code{progress-reporter-update}に@samp{100%}とプリントさせようとせずに、常にこの関数を呼び出すこと。まずこの関数は決してそれをプリントしないだろうし、これが発生しないために多くの正当な理由がある。次に@samp{done}はより自明である。
@end defun

@defmac dotimes-with-progress-reporter (var count [result]) reporter-or-message body@dots{}
これは@code{dotimes}と同じ方法で機能するが、上述の関数を使用してループ進行状況(loop
progress)の報告も行う便利なマクロである。これによりタイプ量を幾分節約できる。引数@var{reporter-or-message}は文字列、またはプログレスリポーターオブジェクト。

以下の方法でこのマクロを使用することにより、このサブセクションの例を書き換えることができる:

@example
@group
(dotimes-with-progress-reporter
    (k 500)
    "Collecting some mana for Emacs..."
  (sit-for 0.01))
@end group
@end example

@var{make-progress-reporter}のオプション引数を指定したい場合には、@var{reporter-or-message}引数としてリポーターオブジェクトを使用するのが便利。たとえば前出の例は以下のように書き換えられる:

@example
@group
(dotimes-with-progress-reporter
    (k 500)
    (make-progress-reporter "Collecting some mana for Emacs..." 0 500 0 1 1.5)
  (sit-for 0.01))
@end group
@end example
@end defmac

@defmac dolist-with-progress-reporter (var count [result]) reporter-or-message body@dots{}
これは@code{dolist}と同じ方法で機能するが、上述の関数を使用してループ進行状況(loop
progress)の報告も行う便利なマクロである。これによりタイプ量を幾分節約できる。@code{dotimes-with-progress-reporter}の場合のように、@code{reporter-or-message}はプログレスリポーターか文字列。このマクロにより、前出の例を以下のように書き換えられる:

@example
@group
(dolist-with-progress-reporter
    (k (number-sequence 0 500))
    "Collecting some mana for Emacs..."
  (sit-for 0.01))
@end group
@end example
@end defmac

@node Logging Messages
@subsection @file{*Messages*}へのメッセージのロギング
@cindex logging echo-area messages

  エコーエリア内に表示されるほとんどすべてのメッセージは、ユーザーが後で参照できるように@file{*Messages*}バッファー内にも記録されます。これには@code{message}により出力されたメッセージも含まれます。デフォルトではこのバッファーは読み取り専用でメジャーモード@code{messages-buffer-mode}を使用します。ユーザーによる@file{*Messages*}バッファーのkillを妨げるものは何もありませんが、次回のメッセージ表示でバッファーは再作成されます。@file{*Messages*}バッファーに直接アクセスする必要があり、それが確実に存在するようにしたいLispコードは、すべて関数@code{messages-buffer}を使用するべきです。

@defun messages-buffer
この関数は@file{*Messages*}バッファーをリターンする。バッファーが存在しなければ作成してバッファーを@code{messages-buffer-mode}に切り替える。
@end defun

@defopt message-log-max
この変数は@file{*Messages*}バッファー内に保持するべき行数を指定する。値@code{t}は保持すべき行数に制限がないことを意味して、値@code{nil}はメッセージのロギングを完全に無効にする。以下はメッセージを表示して、それがロギングされることを防ぐ例:

@example
(let (message-log-max)
  (message @dots{}))
@end example
@end defopt

  @file{*Messages*}にたいするユーザーの利便性を向上させるために、ロギング機能は連続する同じメッセージを結合します。さらに2つのケースのために連続する関連メッセージの結合も行います。2つのケースとは応答を後にともなう質問(question
followed by answer)、および一連のプログレスメッセージ(series of progress messages)です。

  応答を後にともなう質問(question followed by an
answer)とは、1つ目が@samp{@var{question}}、2つ目が@samp{@var{question}...@var{answer}}のように@code{y-or-n-p}が生成するような2つのメッセージをもつ応答です。1つ目のメッセージは2つ目のメッセージ以上の追加情報を伝えないので、2つ目のメッセージをロギングして1つ目のメッセージは破棄します。

  一連のプログレスメッセージ(series of progress
messages)は、@code{make-progress-reporter}が生成するような連続するメッセージをもちます。これらは@samp{@var{base}...@var{how-far}}のような形式であり、@var{how-far}は毎回異なりますが@var{base}は常に同じです。このシリーズ内の各メッセージのロギングでは、そのメッセージが前のメッセージと連続していれば前のメッセージを破棄します。

  関数@code{make-progress-reporter}と@code{y-or-n-p}は、メッセージログ結合機能をアクティブにするために何ら特別なことを行う必要はありません。これは@samp{...}で終わる共通のプレフィックスを共有する連続する2つのメッセージをログする際には常にこの処理を行います。

@node Echo Area Customization
@subsection エコーエリアのカスタマイズ
@cindex echo area customization

  以下の変数はエコーエリアが機能する方法の詳細を制御します。

@defvar cursor-in-echo-area
この変数はエコーエリア内にメッセージ表示時にカーソルを表示する場所を制御する。これが非@code{nil}ならカーソルはメッセージの終端、それ以外ならカーソルはエコーエリア内ではなくポイント位置に表示される。

この値は通常は@code{nil}。Lispプログラムは短時間の間、これを@code{t}にバインドする。
@end defvar

@defvar echo-area-clear-hook
このノーマルフックは@code{(message nil)}、または別の何らかの理由によりエコーエリアが作成されると常に実行される。
@end defvar

@defopt echo-keystrokes
この変数はコマンド文字をエコーする前に、どれだけの時間を待機するかを決定する。この値は数字でなければならず、エコー前に待機する秒数を指定する。ユーザーが(@kbd{C-x}のような)プレフィックスキーをタイプしてから、継続してタイプを継続するのをこの秒数遅延した場合、エコーエリア内にそのプレフィックスキーがエコーされる(あるキーシーケンスで一度エコーが開始されると、同一のキーシーケンス内の後続するすべての文字は即座にエコーされる)。

値が0ならコマンド入力はエコーされない。
@end defopt

@defvar message-truncate-lines
長いメッセージの表示により、そのメッセージ全体を表示するために、通常はエコーエリアはリサイズされる。しかし変数@code{message-truncate-lines}が非@code{nil}なら、エコーエリアをリサイズせずエコーエリアに収まるようメッセージは切り詰められる。
@end defvar

  ミニバッファーウィンドウのリサイズの最大高さを指定する変数@code{max-mini-window-height}はエコーエリアにも適用される(エコーエリアは真にミニバッファーウィンドウの特殊な使い方である。@ref{Minibuffer
Windows}を参照)。

@node Warnings
@section 警告のレポート
@cindex warnings

  @dfn{警告(warnings)}とはプログラムがユーザーにたいして問題の可能性を知らせるが、実行は継続するための機能です。

@menu
* Warning Basics::           警告の概念と報告するための関数。
* Warning Variables::        プログラムが警告をカスタマイズするためにバインドする変数。
* Warning Options::          ユーザーが警告の表示を制御するためにセットする変数。
* Delayed Warnings::         コマンド終了まで警告を延期する。
@end menu

@node Warning Basics
@subsection 警告の基礎
@cindex severity level

  すべての警告は、ユーザーに問題を説明するためのテキストのメッセージと、@dfn{重大レベル(severity
level)}をもっています。重大レベルはシンボルです。以下は可能性のある重大レベルとその意味を、重大度の降順でリストしたものです:

@table @code
@item :emergency
直ちに対処しなければEmacs処理が間もなく深刻に害される問題。
@item :error
本質的に悪いデータや状況のリポート。
@item :warning
本質的に悪くはないが、可能性のある問題を励起する恐れのあるデータや状況のリポート。
@item :debug
デバッグ中なら有用かもしれない情報のリポート。
@end table

  あなたのプログラムが無効な入力データに遭遇した際には、@code{error}呼び出しによるLispエラーのシグナルするか、または重大度@code{:error}の警告をリポートすることができます。Lispエラーのシグナルはもっとも簡単に行えることですが、それはプログラムが処理を継続できないことを意味します。間違ったデータでも処理を継続するための方法を実装するためにトラブルを受け取めたい場合には、その問題をユーザーに知らせるために重大度@code{:error}の警告をリポートするのが正しい方法です。たとえばEmacs
Lispバイトコンパイラーはこの方法によりエラーを報告して、他の関数のコンパイルを継続できます(プログラムがLispエラーをシグナルして@code{condition-case}でhandleしたならユーザーがそのエラーを確認することはないだろう。これは警告としてリポートすることによりユーザーにメッセージを示すことができる)。

@c FIXME: Why use "(bytecomp)" instead of "'bytecomp" or simply
@c "bytecomp" here?  The parens are part of warning-type-format but
@c not part of the warning type. --xfq
@cindex warning type
  クラス分けのために警告にはそれぞれ@dfn{警告タイプ(warning
type)}があります。このタイプはシンボルのリストです。最初のシンボルはそのプログラムのユーザーオプションとして使用するカスタムグループであるべきです。たとえばバイトコンパイラーの警告は警告タイプ@code{(bytecomp)}を使用します。もし望むなら、このリスト内で更にシンボルを使用することにより警告をサブカテゴリー化することもできます。

@defun display-warning type message &optional level buffer-name
この関数はメッセージとして@var{message}、警告タイプとして@var{type}を使用して警告をリポートする。@var{level}は重大レベルであること。デフォルトは@code{:warning}。

@var{buffer-name}が非@code{nil}なら、それは警告をロギングするためのバッファー名を指定する。デフォルトは@file{*Warnings*}。
@end defun

@defun lwarn type level message &rest args
この関数は@file{*Warnings*}バッファー内のメッセージとして@code{(format-message @var{message}
@var{args}...)}の値を使用して警告をリポートする。他の点ではこれは@code{display-warning}と同じ。
@end defun

@defun warn message &rest args
この関数はメッセージとして@code{(format-message @var{message}
@var{args}...)}の値、タイプとして@code{(emacs)}、重大レベルとして@code{:warning}を使用して警告をリポートする。これは互換性のためだけに存在する。固有な警告タイプを指定するべきであり、この関数の使用は推奨しない。
@end defun

@node Warning Variables
@subsection 警告のための変数
@cindex warning variables

  このセクション内で説明する変数をバインドすることにより、プログラムは警告が表示される方法をカスタマイズできます。

@defvar warning-levels
このリストは警告の重大レベルの意味と重大度の順序を定義する。それぞれの要素は1つの重大レベルを定義して、それらを重大度の降順で配置した。

各要素は@code{(@var{level} @var{string}
@var{function})}という形式をもち、@var{level}はその要素が定義する重大レベル。@var{string}はそのレベルのテキストによる説明。@var{string}は警告タイプ情報の配置箇所の指定に@samp{%s}を使用するか、さもなくばその情報を含まぬよう@samp{%s}を省略できる。

オプションの@var{function}が非@code{nil}なら、これはユーザーの注目を得るために引数なしで呼び出される関数であること。

通常はこの変数の値を変更しないこと。
@end defvar

@defvar warning-prefix-function
値が非@code{nil}なら、それは警告用にプレフィックスを生成する関数であること。プログラムはこの変数を適切な関数にバインドできる。@code{display-warning}はwarningsバッファーがカレントの状態でこの関数を呼び出して、関数はそのバッファーにテキストを挿入できる。そのテキストが警告メッセージの先頭になる。

この関数は重大レベル、および@code{warning-levels}内でのその重大レベルのエントリーという2つの引数で呼び出される。これはエントリーとして使用するためのリストをリターンすること(この値は@code{warning-levels}の実際のメンバーである必要はない)。この値を構築することにより関数はその警告の重大レベルを変更したり、与えられた重大レベルにたいして異なる処理を指定することができる。

この変数の値が@code{nil}なら呼び出される関数は存在しない。
@end defvar

@defvar warning-series
プログラムは次の警告がシリーズの開始であることを告げるために、この変数を@code{t}にバインドできる。複数の警告がシリーズを形成するということは、それぞれの警告にたいしてポイントが維持されるように移動して、最後の警告にポイントが表示されるのではなくシリーズの最初の警告にポイントを残すことを意味する。このシリーズは、そのローカルバインドが非バインドされて@code{warning-series}が再び@code{nil}になったときに終了する。

この値は関数定義をもつシンボルでもよい。これは次の警告によりwarningsバッファーがカレントの状態で、引数なしでその関数が呼び出されることを除き@code{t}と等価。この関数は警告シリーズのヘッダーの役目をもつであろうテキストを挿入できる。

あるシリーズが開始されると、その値はwarningsバッファー内でシリーズ開始となるバッファー位置を指すマーカーとなる。

この変数の通常の値は@code{nil}で、これはそれぞれの警告を個別に処理することを意味する。
@end defvar

@defvar warning-fill-prefix
この変数が非@code{nil}なら、それは各警告テキストのフィルに使用するフィルプレフィックスを指定する。
@end defvar

@defvar warning-fill-column
警告をフィルする列。
@end defvar

@defvar warning-type-format
この変数は警告メッセージ内の警告タイプを表示するためのフォーマットを指定する。この方法でフォーマットされたタイプは、@code{warning-levels}内のエントリー内の文字列制御下にあるメッセージに含まれることになる。デフォルト値は@code{"
(%s)"}。これを@code{""}にバインドすると警告タイプはまったく表示されなくなる。
@end defvar

@node Warning Options
@subsection 警告のためのオプション
@cindex warning options

  以下の変数は何が発生したときにLispプログラムが警告をリポートするかをユーザーが制御するために使用されます。

@defopt warning-minimum-level
このユーザーオプションはユーザーにたいして即座に表示されるべき最小の重大レベルを指定する。デフォルトは@code{:warning}であり、これは@code{:debug}警告を除くすべての警告が即座に表示されることを意味する。
@end defopt

@defopt warning-minimum-log-level
このユーザーオプションはwarningsバッファー内にログされるべき最小の重大レベルを指定する。デフォルトは@code{:warning}であり、これは@code{:debug}警告を除くすべての警告がログされることを意味する。
@end defopt

@defopt warning-suppress-types
このリストはユーザーにたいしてどの警告タイプを即座に表示するべきではないかを指定する。このリスト内の各要素はシンボルのリストであること。それの要素が警告タイプ内の最初の要素にマッチしたら警告は即座に表示されない。
@end defopt

@defopt warning-suppress-log-types
このリストはユーザーにたいしてどの警告タイプがwarningsバッファーにログされるべきではないかを指定する。このリスト内の各要素はシンボルのリストであること。それの要素が警告タイプ内の最初の数要素にマッチしたら警告はログされない。
@end defopt

@node Delayed Warnings
@subsection 遅延された警告
@cindex delayed warnings

コマンド実行中には警告の表示を避けてコマンドの終わりでのみ警告を表示したいことがあるかもしれません。これは関数@code{delay-warning}を使用して行うことができます。

@defun delay-warning type message &optional level buffer-name
この関数は@code{display-warning} (@ref{Warning
Basics}を参照)の遅延対応版であり、同じ引数で呼び出される。警告メッセージは@code{delayed-warnings-list}にキューイングされる。
@end defun

@defvar delayed-warnings-list
この変数の値はカレントのコマンド完了後に表示される警告のリスト。各要素は以下のようなリストでなければならない:

@smallexample
(@var{type} @var{message} [@var{level} [@var{buffer-name}]])
@end smallexample

@noindent
これらは@code{display-warning}の引数リストと同じ形式、同じ意味である。@code{post-command-hook}
(@ref{Command
Overview}を参照)の実行直後に、Emacsのコマンドループはこの変数で指定されたすべての警告を表示してから変数を@code{nil}にリセットする。
@end defvar

  遅延警告メカニズムをよりカスタマイズする必要があるプログラムは変数@code{delayed-warnings-hook}を変更することができます:

@defvar delayed-warnings-hook
これは遅延警告を処理して表示するために、@code{post-command-hook}の後にEmacsコマンドループが実行するノーマルフック。

デフォルト値は2つの関数からなるリスト:

@smallexample
(collapse-delayed-warnings display-delayed-warnings)
@end smallexample

@findex collapse-delayed-warnings
@findex display-delayed-warnings
@noindent
関数@code{collapse-delayed-warnings}は@code{delayed-warnings-list}から重複するエントリーを削除する。関数@code{display-delayed-warnings}は@code{delayed-warnings-list}内の各要素にたいして順次@code{display-warning}を呼び出してから、@code{delayed-warnings-list}を@code{nil}にセットする。
@end defvar

@node Invisible Text
@section 不可視のテキスト

@cindex invisible text
@code{invisible}プロパティにより、スクリーン上に表示されないように文字を@dfn{不可視(invisible)}にすることができます。これはテキストプロパティ(@ref{Text
Properties}を参照)、またはオーバーレイプロパティ(@ref{Overlays}を参照)のいずれかで行うことができます。カーソル移動もこれらの文字を部分的に無視します。あるコマンドの後に不可視テキスト範囲内にポイントがあることをコマンドループが検知した場合には、コマンドループはポイントをそのテキストの別サイドへ再配置します。

もっともシンプルなケースでは、非@code{nil}の@code{invisible}プロパティにより文字は不可視になります。これがデフォルトのケースであり、もし@code{buffer-invisibility-spec}のデフォルト値を変更したくない場合には、これが@code{invisible}プロパティを機能させる方法です。自身で@code{buffer-invisibility-spec}をセットする予定がなければ、@code{invisible}プロパティの値として通常は@code{t}を使用するべきです。

より一般的にはどの@code{invisible}の値がテキストを不可視にするかを制御するために変数@code{buffer-invisibility-spec}を使用できます。テキストにたいして異なる@code{invisible}の値を与えることにより、事前に別のサブセットへテキストをクラス分けした後に@code{buffer-invisibility-spec}の値を変更して、さまざまなサブセットを可視や不可視にすることができます。

特にデータベース内のエントリーのリストを表示するプログラム内では、@code{buffer-invisibility-spec}による可視性の制御は有用です。これによりデータベース内の一部だけを閲覧するフィルターコマンドを簡便に実装することが可能になります。この変数をセットするのは非常に高速であり、バッファー内のすべてのテキストにたいしてプロパティが変更されたかスキャンするよりはるかに高速です。

@defvar buffer-invisibility-spec
この変数はどの種類の@code{invisible}プロパティが実際に文字を不可視にするかを指定する。この変数はセットすることによりバッファーローカルになる。

@table @asis
@item @code{t}
@code{invisible}プロパティが非@code{nil}ならその文字は不可視になる。これがデフォルト。

@item リスト
このリスト内の各要素は不可視性の条件を指定する。ある文字の@code{invisible}プロパティがこれらの条件のいずれかに適合したら、その文字は不可視になる。このリストは2種類の要素をもつことができる:

@table @code
@item @var{atom}
@code{invisible}プロパティの値が@var{atom}、または@var{atom}をメンバーにもつリストならその文字は不可視になる。比較は@code{eq}により行われる。

@item (@var{atom} . t)
@code{invisible}プロパティの値が@var{atom}、または@var{atom}をメンバーにもつリストならその文字は不可視になる。比較は@code{eq}により行われる。さらにそのような文字シーケンスは省略記号(ellipsis)として表示される。
@end table
@end table
@end defvar

  特に@code{buffer-invisibility-spec}への要素の追加と削除のために2つの関数が提供されています。

@defun add-to-invisibility-spec element
この関数は、@code{buffer-invisibility-spec}に要素@var{element}を追加する。@code{buffer-invisibility-spec}が@code{t}なら、これはリスト@code{(t)}に変更されて@code{invisible}プロパティが@code{t}のテキストは不可視のまま留まる。
@end defun

@defun remove-from-invisibility-spec element
この関数は@code{buffer-invisibility-spec}から要素@var{element}を削除する。リスト内に@var{element}がなければ何も行わない。
@end defun

  @code{buffer-invisibility-spec}を使用するための規約として、メジャーモードは@code{buffer-invisibility-spec}の要素、および@code{invisible}プロパティの値として自身のモード名を使用することになっている。

@example
;; @r{省略記号を表示したければ:}
(add-to-invisibility-spec '(my-symbol . t))
;; @r{表示したくなければ:}
(add-to-invisibility-spec 'my-symbol)

(overlay-put (make-overlay beginning end)
             'invisible 'my-symbol)

;; @r{不可視状態が終わったら:}
(remove-from-invisibility-spec '(my-symbol . t))
;; @r{または各々を:}
(remove-from-invisibility-spec 'my-symbol)
@end example

  以下の関数を使用することにより不可視性をチェックできます:

@defun invisible-p pos-or-prop
この関数は@var{pos-or-prop}がマーカーか数字の場合には、その位置のテキストがカレントで不可視なら非@code{nil}をリターンする。

@var{pos-or-prop}が別の類のLispオブジェクトなら、テキストプロパティかオーバーレイプロパティとして可能な値を意味すると解釈される。この場合には@code{buffer-invisibility-spec}のカレント値にもとづき、もしその値がテキストを不可視とするようならこの関数は非@code{nil}をリターンする。

この関数のリターン値はテキストがディスプレー上で完全に非表示なら@code{t}、省略記号(ellipsis)で置き換えられていれば@code{nil}でも@code{t}でもない値となる。
@end defun

@vindex line-move-ignore-invisible
  テキストを操作したりポイントを移動する関数は、通常はそのテキストが不可視かどうかに注意を払わずに、可視と不可視のテキストを同様に処理します。@code{next-line}や@code{previous-line}のようなユーザーレベルの行移動関数は@code{line-move-ignore-invisible}が非@code{nil}
(デフォルト)なら不可視な改行を無視します。これらの関数は不可視な改行がそのバッファーに存在しないかのように振る舞いますが、それはそう振る舞うように明示的にプログラムされているからです。

  あるコマンドが不可視テキストの境界内側のポイントで終了した場合には、メイン編集ループはその不可視テキストの両端のうちのいずれかにポイントを再配置します。そのコマンドの移動関数の全体的な方向と同じになるようにEmacsが再配置の方向を決定します。これに疑問がある場合には、挿入された文字が@code{invisible}プロパティを継承しないような位置を優先してください。加えてそのテキストが省略記号で置換されずに、コマンドが不可視テキスト内への移動のみを行う場合には、ポイントを1文字余計に移動して目に見えるようカーソルを移動することにより、そのコマンドの移動を反映するよう試みます。

  したがってコマンドが(通常のstickinessをもつ)不可視範囲に後方へとポイントを移動すると、Emacsはポイントをその範囲の先頭に後方へと移動します。コマンドが不可視範囲へ前方にポイントを移動した場合には、Emacsは不可視テキストの前にある最初の可視文字に前方へとポイントを移動して、その後さらに前方へ1文字余計に移動します。

  これら不可視テキスト中間で終了するポイントにたいするこれらの@dfn{調整(adjustments)}は、@code{disable-point-adjustment}を非@code{nil}にセットすることにより無効にできます。@ref{Adjusting
Point}を参照してください。

  インクリメンタル検索はマッチが不可視テキストを含む場合には、一時的および/または永続的に不可視オーバーレイを可視にすることができます。これを有効にするためには、そのオーバーレイが非@code{nil}の@code{isearch-open-invisible}プロパティをもつ必要があります。プロパティの値は、そのオーバーレイを引数として呼び出される関数であるべきです。その関数はオーバーレイを永続的に可視にする必要があります。これは検索からのexit時にマッチがそのオーバーレイに重なるときに使用されます。

  検索の間にそのようなオーバーレイのinvisible、およびintangibleプロパティを一時的に変更することによりオーバーレイは一時的に可視にされます。特定のオーバーレイにたいして異なる方法でこれを行いたいなら、それを@code{isearch-open-invisible-temporary}プロパティ(関数)に与えてください。その関数は2つの引数により呼び出されます。1つ目はそのオーバーレイ、2つ目は@code{nil}ならオーバーレイを可視、@code{t}なら再び不可視にします。

@node Selective Display
@section 選択的な表示
@c @cindex selective display   Duplicates selective-display

  @dfn{選択的表示(selective display)}とはスクリーン上で特定の行を隠蔽する関連する機能ペアーを指します。

@cindex explicit selective display
  1つ目の変種は明示的な選択的表示であり、これはLispプログラム内で使用するようにデザインされています。これはテキスト変更により、どの行を隠すかを制御します。この種の隠蔽は現在では時代遅れであ推奨されていません。同じ効果を得るには、かわりに@code{invisible}プロパティ(@ref{Invisible
Text}を参照)を使用する必要があります。

  2つ目の変種はインデントにもとづいて隠す行の選択を自動的に行います。この変種はユーザーレベルの機能としてデザインされています。

  選択的表示を明示的に制御する方法では改行(control-j)を復帰(control-m)に置換します。これにより以前は行末に改行があった行は隠蔽されます。厳密に言うと改行だけが行を分離できるので、これはもはや一時的には行ではなく前の行の一部です。

  選択的表示は編集コマンドに直接影響を与えません。たとえば@kbd{C-f}
(@code{forward-char})は隠蔽された行へと気軽にポイントを移動します。しかし復帰文字による改行文字の置換は、いくつかの編集コマンドに影響を与えます。たとえば@code{next-line}は改行だけを検索するために、隠蔽された行をスキップします。選択的表示を使用するモードは改行を考慮するコマンドを定義したり、テキストのどの部分を隠すか制御することもできます。

  選択的表示されたバッファーをファイルに書き込む際には、control-mはすべて改行として出力されます。これはファイル内のテキストを読み取る際には、すべて問題なく隠蔽されずに表示されることを意味します。選択的表示はEmacs内でのみ顕在する効果です。

@defvar selective-display
このバッファーローカル変数は選択的表示を有効にする。これは行、または行の一部を隠すことができることを意味する。

@itemize @bullet
@item
@code{selective-display}の値が@code{t}なら、文字control-mが隠蔽されたテキストの開始をマークする。control-mと後続する行の残りは表示されない。これは明示的な選択的表示である。

@item
@code{selective-display}の値が正の整数なら、それより多くの列によるインデントで始まる行は表示されない。
@end itemize

バッファーの一部が隠蔽されている際には垂直移動コマンドはあたかもその部分を存在しないかのように処理して、1回の@code{next-line}コマンドで任意の行数の隠蔽された行をスキップできる。しかし(
@code{forward-char}のような)文字移動コマンドは隠蔽された部分をスキップせずに、(注意すれば)隠蔽された部分にたいしてテキストの挿入と削除が可能である。

以下の例では@code{selective-display}の値の変更によるバッファー@code{foo}の@emph{外観表示}を示す。このバッファーの@emph{コンテンツ}は変更されない。

@example
@group
(setq selective-display nil)
     @result{} nil

---------- Buffer: foo ----------
1 on this column
 2on this column
  3n this column
  3n this column
 2on this column
1 on this column
---------- Buffer: foo ----------
@end group

@group
(setq selective-display 2)
     @result{} 2

---------- Buffer: foo ----------
1 on this column
 2on this column
 2on this column
1 on this column
---------- Buffer: foo ----------
@end group
@end example
@end defvar

@defopt selective-display-ellipses
このバッファーローカル変数が非@code{nil}なら、Emacsは隠蔽されたテキストを後にともなう行の終端に@samp{@dots{}}を表示する。以下は前の例からの継続。

@example
@group
(setq selective-display-ellipses t)
     @result{} t

---------- Buffer: foo ----------
1 on this column
 2on this column ...
 2on this column
1 on this column
---------- Buffer: foo ----------
@end group
@end example

省略記号(@samp{@dots{}})にたいして他のテキストを代替えするためにディスプレイテーブルを使用できる。@ref{Display
Tables}を参照のこと。
@end defopt

@node Temporary Displays
@section 一時的な表示
@cindex temporary display
@cindex temporary buffer display

  一時的表示(temporary
display)は出力をバッファーに配置して編集用ではなく閲覧用としてユーザーに示すためにLispプログラムにより使用されます。多くのヘルプコマンドはこの機能を使用します。

@defmac with-output-to-temp-buffer buffer-name body@dots{}
この関数は@var{buffer-name}という名前のバッファー(必要なら最初に作成される)にプリントされた任意の出力が挿入されるようアレンジ、さらにバッファーをHelpモードにして@var{body}内のフォームを実行する(類似する以下のフォーム@code{with-temp-buffer-window}を参照)。最後にそのバッファーはいずれかのウィンドウに表示されるが、そのウィンドウは選択されない。

@var{body}内のフォームが出力バッファーのメジャーモードを変更しないため、実行の最後においても依然としてHelpモードにあるなら、@code{with-output-to-temp-buffer}は最後にそのバッファーを読み取り専用するとともに、クリック可能なクロスリファレンスとなるように関数名と変数名のスキャンも行う。特にドキュメント文字列内のハイパーリンク上アイテムに関する詳細は@ref{Docstring
hyperlinks, , Tips for Documentation Strings}を参照のこと。

文字列@var{buffer-name}は一時的なバッファーを指定して、これはあらかじめ存在する必要はない。引数はバッファーではなく文字列でなければならない。そのバッファーは最初に消去されて(確認なし)、@code{with-output-to-temp-buffer}のexit後は未変更(unmodified)とマークされる。

@code{with-output-to-temp-buffer}は@code{standard-output}を一時的バッファーにバインドして@var{body}内のフォームを評価する。@var{body}内のLisp出力関数を使用した出力のデフォルト出力先は、そのバッファーになる(しかしスクリーン表示やエコーエリア内のメッセージは一般的な世界の感覚では``出力''であるものの影響は受けない)。@ref{Output
Functions}を参照のこと。

この構構文の振る舞いをカスタマイズするために利用できるフックがいくつかあり、それらは以下にリストしてある。

リターン値は@var{body}内の最後のフォームの値。

@example
@group
---------- Buffer: foo ----------
 This is the contents of foo.
---------- Buffer: foo ----------
@end group

@group
(with-output-to-temp-buffer "foo"
    (print 20)
    (print standard-output))
@result{} #<buffer foo>

---------- Buffer: foo ----------

20

#<buffer foo>

---------- Buffer: foo ----------
@end group
@end example
@end defmac

@defopt temp-buffer-show-function
この変数が非@code{nil}なら、@code{with-output-to-temp-buffer}はヘルプバッファーを表示する処理を行うためにその関数を呼び出す。この関数は表示すべきバッファーという1つの引数を受け取る。

@code{with-output-to-temp-buffer}が通常行うように、@code{save-selected-window}内部や選択されたウィンドウ内でバッファーか選択された状態で@code{temp-buffer-show-hook}を実行するのは、この関数にとってよいアイデアである。
@end defopt

@defvar temp-buffer-setup-hook
このノーマルフックは@var{body}を評価する前に@code{with-output-to-temp-buffer}により実行される。フック実行時には一時的バッファーがカレントになる。このフックは通常はそのバッファーをHelpモードにするための関数にセットアップされる。
@end defvar

@defvar temp-buffer-show-hook
このノーマルフックは一時的バッファー表示後に@code{with-output-to-temp-buffer}により実行される。フック実行時には一時的バッファーがカレントになり、それが表示されているウィンドウが選択される。
@end defvar

@defmac with-temp-buffer-window buffer-or-name action quit-function body@dots{}
このマクロは@code{with-output-to-temp-buffer}と類似している。@code{with-output-to-temp-buffer}構文と同様に、これはプリントされる任意の出力が@var{buffer-or-name}という名前のバッファーに挿入されるようにアレンジして@var{body}を実行して、そのバッファーをいずれかのウィンドウに表示する。しかし@code{with-output-to-temp-buffer}とは異なり、このマクロはそのバッファーを自動的にHelpモードに切り替えない。

引数@var{buffer-or-name}は一時的バッファーを指定する。これはバッファー(既存でなければならない)、または文字列を指定でき、文字列の場合には必要ならその名前のバッファーが作成される。そのバッファーは@code{with-temp-buffer-window}のexit時には、未変更かつ読み取り専用とマークされる。

このマクロは@code{temp-buffer-show-function}を呼び出さない。かわりにそのバッファーを表示するために@var{action}引数を@code{display-buffer}
(@ref{Choosing Window}を参照)に渡す。

引数@var{quit-function}が指定されていなければ@var{body}内の最後のフォームの値がリターンされる。指定されている場合には、そのバッファーを表示するウィンドウと@var{body}の結果という2つの引数で呼び出される。その場合には、最終的なリターン値は何であれ@var{quit-function}がリターンした値となる。

@vindex temp-buffer-window-setup-hook
@vindex temp-buffer-window-show-hook
このマクロは@code{with-output-to-temp-buffer}により実行される類似フックのかわりにノーマルフック@code{temp-buffer-window-setup-hook}と@code{temp-buffer-window-show-hook}を使用する。
@end defmac

次の2つの構文は@code{with-temp-buffer-window}とほとんど同じですが、説明している点が異なります：

@defmac with-current-buffer-window buffer-or-name action quit-function &rest body
このマクロは@code{with-temp-buffer-window}と同様だが、@var{body}の実行に際して@var{buffer-or-name}で指定したバッファーをカレントにする点が異なる。
@end defmac

一時バッファーを表示しているウィンドウは以下のモードを使用してそのバッファーにサイズを適合できます:

@defopt temp-buffer-resize-mode
このマイナーモードが有効なときは、一時的バッファーを表示しているウィンドウはバッファーのコンテンツにフィットするように自動的にリサイズされる。

そのバッファーにたいして特別に作成されたウィンドウの場合のみウィンドウはリサイズされる。特に前に別のバッファーを表示していたウィンドウはリサイズされない。デフォルトではこのモードはリサイズに@code{fit-window-to-buffer}を使用する(@ref{Resizing
Windows}を参照)。以下のオプション@code{temp-buffer-max-height}と@code{temp-buffer-max-width}をカスタマイズして他の関数を指定できる。
@end defopt

@defopt temp-buffer-max-height
このオプションは@code{temp-buffer-resize-mode}が有効な際に一時的バッファーを表示するウィンドウの最大高さ(行数)を指定する。その種のバッファーの高さ選択のために呼び出す関数でもよい。これはバッファーを唯一の引数として受け取り、正の整数をリターンすること。関数の呼び出し時にはリサイズされるウィンドウが選択される。
@end defopt

@defopt temp-buffer-max-width
このオプションは@code{temp-buffer-resize-mode}が有効な際に一時的バッファーを表示するウィンドウの最大幅(列数)を指定する。その種のバッファーの高さ選択のために呼び出す関数でもよい。これはバッファーを唯一の引数として受け取り、正の整数をリターンすること。関数の呼び出し時にはリサイズされるウィンドウが選択される。
@end defopt

以下の関数は一時的な表示にカレントバッファーを使用します:

@defun momentary-string-display string position &optional char message
この関数はカレントバッファー内の@var{position}に@var{string}を瞬間表示(momentarily
display)する。これはundoリストやバッファーの変更状態(modification status)に影響を与えない。

瞬間表示は次の入力イベントまで留まる。次の入力イベントが@var{char}なら@code{momentary-string-display}はそれを無視してリターンする。それ以外ならそのイベントは後続の入力として使用するためにバッファリングされる。つまり@var{char}とタイプすると表示からその文字列を単に削除して、(たとえば)
@var{char}ではない@kbd{C-f}とタイプすると表示からその文字列を削除して、その後に(おそらく)ポイントを前方へ移動するだろう。引数@var{char}のデフォルトはスペース。

@code{momentary-string-display}のリターン値に意味はない。

文字列@var{string}がコントロール文字を含まなければ、@code{before-string}プロパティでオーバーレイを作成(その後に削除)することで、同じことをより汎用的に行うことができる。@ref{Overlay
Properties}を参照のこと。

@var{message}が非@code{nil}なら、バッファー内に@var{string}が表示されている間はエコーエリアにそれが表示される。@code{nil}の場合のデフォルトは、継続するためには@var{char}をタイプするように告げるメッセージ。

以下の例では最初はポイントは2行目の先頭に置かれている:

@example
@group
---------- Buffer: foo ----------
This is the contents of foo.
@point{}Second line.
---------- Buffer: foo ----------
@end group

@group
(momentary-string-display
  "**** Important Message! ****"
  (point) ?\r
  "Type RET when done reading")
@result{} t
@end group

@group
---------- Buffer: foo ----------
This is the contents of foo.
**** Important Message! ****Second line.
---------- Buffer: foo ----------

---------- Echo Area ----------
Type RET when done reading
---------- Echo Area ----------
@end group
@end example
@end defun

@node Overlays
@section オーバーレイ
@cindex overlays
@c FIXME: mention intervals in this section?

バッファーのテキストのスクリーン上の見栄えを変更するために、
プレゼンテーション機能として@dfn{オーバーレイ(overlay)}を使用できます。オーバーレイとは個々のバッファーに属するオブジェクトであり、指定された開始と終了をもっています。確認したりセットすることができるプロパティももっています。それらはオーバーレイをもつテキストの表示に影響を与えます。

@cindex scalability of overlays
@cindex overlays, scalability
オーバーレイの視覚的効果は、対応するテキストプロパティと同様です(@ref{Text
Properties}を参照)。しかし実装が異なるために、オーバーレイは一般的にスケーラブルではありません(処理数に応じてバッファー内のオーバーレイ数に比例した時間を要する)。バッファー内の多数の部分の視覚的外観に効果を及ぼす必要がある場合にはテキストプロパティの使用を推奨します。

オーバーレイはその開始と終了を記録するためにマーカーを使用します。したがってバッファーのテキスト編集では、すべてのオーバーレイがそのテキストに留まるように開始と終了が調整されます。オーバーレイ作成時にはオーバーレイの先頭、または同様に終端にテキストが挿入された場合に、それがオーバーレイの内側(または外側)になるべきなのかを指定できます。

@menu
* Managing Overlays::        オーバーレイの作成と変更。
* Overlay Properties::       プロパティ読み取りとセットの方法。どのプロパティがスクリーン表示に何を行うか。
* Finding Overlays::         オーバーレイにたいする検索。
@end menu

@node Managing Overlays
@subsection オーバーレイの管理
@cindex managing overlays
@cindex overlays, managing

  このセクションではオーバーレイの作成、削除、移動、およびそれらのコンテンツを調べる関数を説明します。オーバーレイはバッファーのコンテンツの一部ではないので、その変更はバッファーのundoリストに記録されません。

@defun overlayp object
この関数は@var{object}がオーバーレイなら@code{t}をリターンする。
@end defun

@defun make-overlay start end &optional buffer front-advance rear-advance
この関数は@var{buffer}に属する、@var{start}から@var{end}の範囲のオーバーレイを作成してリターンする。@var{start}と@var{end}はいずれもバッファーの位置を指定しなければならず、整数かマーカーを指定できる。@var{buffer}が省略されると、そのオーバーレイはカレントバッファーに作成される。

@cindex empty overlay
@cindex overlay, empty
@var{start}と@var{end}が同一のバッファー位置を指定するオーバーレイは@dfn{空(empty)}のオーバーレイとして知られる。@var{start}と@var{end}の間のテキストが削除されれば、非空のオーバーレイも空になり得る。これが発生したとき、デフォルトではオーバーレイは削除されないが、@samp{evaporate}プロパティを与えることにより削除されるようにできる(@ref{Overlay
Properties, evaporate property}を参照)。

引数@var{front-advance}と@var{rear-advance}はそれぞれオーバーレイの開始と終了にたいするマーカーの挿入タイプを指定する。@ref{Marker
Insertion Types}を参照のこと。どちらも@code{nil}
(デフォルト)なら、そのオーバーレイは先頭に挿入された任意のテキストを含むように拡張されるが、終端に挿入されたテキストにたいしては拡張されない。@var{front-advance}が非@code{nil}なら、オーバーレイの先頭に挿入されたテキストはオーバーレイから除外される。@var{rear-advance}が非@code{nil}なら、オーバーレイの終端に挿入されたテキストはオーバーレイに含まれる。
@end defun

@defun overlay-start overlay
この関数は@var{overlay}が開始する位置を整数でリターンする。
@end defun

@defun overlay-end overlay
この関数は@var{overlay}が終了する位置を整数でリターンする。
@end defun

@defun overlay-buffer overlay
この関数は@var{overlay}が所属するバッファーをリターンする。@var{overlay}が削除されていたら@code{nil}をリターンする。
@end defun

@defun delete-overlay overlay
この関数は@var{overlay}を削除する。そのオーバーレイはLispオブジェクトとして存在し続けて、そのプロパティリストは変更されないがバッファーへの所属と表示にたいするすべての効果を失う。

削除済みオーバーレイが永続的に非接続という訳ではない。@code{move-overlay}を呼び出すことによりバッファー内の位置を与えることができる。
@end defun

@defun move-overlay overlay start end &optional buffer
この関数は@var{overlay}を@var{buffer}に移動して、その境界を@var{start}と@var{end}に配置する。@var{start}と@var{end}の引数はいずれもバッファーの位置を指定しなければならず、整数かマーカーを指定できる。

@var{buffer}が省略された場合、@var{overlay}はすでに関連付けられている同じバッファーに留まる。さらに@var{overlay}が削除されていたら、それをカレントバッファーに所属させる。

リターン値は@var{overlay}。

これはオーバーレイの両端位置を変更する唯一の有効な方法である。手作業でオーバーレイ内のマーカーの変更を試みてはならない。それにより他の重要なデータ構造の更新が失敗して、いくつかのオーバーレイが失われる可能性がある。
@end defun

@defun remove-overlays &optional start end name value
この関数はプロパティ@var{name}が値@var{value}をもつような、@var{start}と@var{end}の間のすべてのオーバーレイを削除する。これによりオーバーレイの両端位置が変更されたり分割される可能がある。

@var{name}が省略か@code{nil}なら、それは指定されたリージョン内のすべてのオーバーレイを削除することを意味する。@var{start}および/または@var{end}が省略か@code{nil}なら、それぞれバッファーの先頭と終端を意味する。したがって@code{(remove-overlays)}はカレントバッファー内のすべてのオーバーレイを削除する。
@end defun

@defun copy-overlay overlay
この関数は@var{overlay}のコピーをリターンする。このコピーは@var{overlay}と同じ両端位置とプロパティをもつ。しかしオーバーレイの開始と終了にたいするマーカー挿入タイプはデフォルト値にセットされる(@ref{Marker
Insertion Types}を参照)。
@end defun

  以下にいくつか例を示します:

@example
;; @r{オーバーレイの作成}
(setq foo (make-overlay 1 10))
     @result{} #<overlay from 1 to 10 in display-ja.texi>
(overlay-start foo)
     @result{} 1
(overlay-end foo)
     @result{} 10
(overlay-buffer foo)
     @result{} #<buffer display-ja.texi>
;; @r{後でチェックできるようプロパティ付与}
(overlay-put foo 'happy t)
     @result{} t
;; @r{プロパティが付与されたか検証}
(overlay-get foo 'happy)
     @result{} t
;; @r{オーバーレイを移動}
(move-overlay foo 5 20)
     @result{} #<overlay from 5 to 20 in display-ja.texi>
(overlay-start foo)
     @result{} 5
(overlay-end foo)
     @result{} 20
;; @r{オーバーレイを削除}
(delete-overlay foo)
     @result{} nil
;; @r{削除されたか検証}
foo
     @result{} #<overlay in no buffer>
;; @r{削除済みオーバーレイは位置をもたない}
(overlay-start foo)
     @result{} nil
(overlay-end foo)
     @result{} nil
(overlay-buffer foo)
     @result{} nil
;; @r{オーバーレイの削除取り消し}
(move-overlay foo 1 20)
     @result{} #<overlay from 1 to 20 in display-ja.texi>
;; @r{結果の検証}
(overlay-start foo)
     @result{} 1
(overlay-end foo)
     @result{} 20
(overlay-buffer foo)
     @result{} #<buffer display-ja.texi>
;; @r{オーバーレイの移動と削除では、オーバーレイのプロパティは変更されない}
(overlay-get foo 'happy)
     @result{} t
@end example

  Emacsはそれぞれのバッファーのオーバーレイを任意の中心位置(center
position)で分割される2つのリストに格納します。一方のリストはバッファーの中心位置から後方に拡張されて、もう一方は中心位置から前方へと拡張されます。中心位置はバッファーの任意の位置をとることができます。

@defun overlay-recenter pos
この関数はカレントバッファーのオーバーレイを位置@var{pos}の周辺に再センタリングする。これにより位置@var{pos}近傍のオーバーレイの照合は高速になるが、@var{pos}から離れた位置にたいしては低速になる。
@end defun

  バッファーを前方にスキャンしてオーバーレイを作成するループは、最初に@code{(overlay-recenter
(point-max))}を行うことにより高速になる可能性があります。

@node Overlay Properties
@subsection オーバーレイのプロパティ
@cindex overlay properties

  オーバーレイプロパティは文字が表示される方法をどちらのソースからも取得できるという点においてテキストプロパティと似ています。しかしほとんどの観点において両者は異なります。これらの比較は@ref{Text
Properties}を参照してください。

  テキストプロパティはそのテキストの一部として考えることができます。オーバーレイとそのプロパティは特にテキストの一部とはみなされません。したがってさまざまなバッファーや文字列の間でテキストをコピーすると、テキストプロパティは保持されますがオーバーレイを保持しようとは試みません。バッファーのテキストプロパティの変更はバッファーを変更済みとマークしますが、オーバーレイの移動やプロパティの変更は違います。テキストプロパティの変更とは異なり、オーバーレイプロパティの変更はバッファーのundoリストに記録されません。

  複数のオーバーレイが同じ文字にたいしてプロパティ値を指定できるので、Emacsは各オーバーレイにたいして優先度の指定を促します。優先度の値はオーバーラップするオーバーレイのどちらが``勝つ''かを判断するために使用されます。

  以下の関数はオーバーレイのプロパティの読み取りとセットを行います:

@defun overlay-get overlay prop
この関数は@var{overlay}内に記録されたプロパティ@var{prop}の値をリターンする。そのプロパティにたいして@var{overlay}が何も値を記録していないが、シンボルであるような@code{category}プロパティをもつ場合には、そのシンボルの@var{prop}プロパティが使用される。それ以外なら値は@code{nil}。
@end defun

@defun overlay-put overlay prop value
この関数は@var{overlay}内に記録されたプロパティ@var{prop}の値に@var{value}をセットする。リターン値は@var{value}。
@end defun

@defun overlay-properties overlay
これは@var{overlay}のプロパティリストのコピーをリターンする。
@end defun

  与えられた文字にたいしてテキストプロパティとオーバーレイプロパティの両方をチェックする関数@code{get-char-property}も参照してください。@ref{Examining
Properties}を参照してください。

  多くのオーバーレイプロパティには特別な意味があります。以下はそれらのテーブルです:

@table @code
@item priority
@kindex priority @r{(overlay property)}
このプロパティの値はオーバーレイの優先度を決定する。優先度にたいして値を指定したければ@code{nil}
(か0)、または正の整数を使用すること。それ以外のすべての値にたいする動作は未定義。

2つ以上のオーバーレイが同じ文字をカバーし、いずれもが同じプロパティを指定する場合には、優先度が重要になる。他より@code{priority}の値が大きいほうが他をオーバーライドする。(@code{face}プロパティにたいしては、より高い優先度のオーバーレイの値は他の値を完全にはオーバーライドしない。かわりに高い優先度のface属性がより低い優先度の@code{face}プロパティのface属性をオーバーライドする)。2つのオーバーレイが同じ優先値をもち、一方がもう一方にネストされている場合には、内側のオーバーレイが外側のオーバーレイより優先される。いずれのオーバーレイも他方にネストされていなければ、どちらのオーバーレイが優先するかを仮定しないこと。

現在のところ、すべてのオーバーレイはテキストプロパティより優先される。

Emacsは内部的ないくつかのオーバーレイに非数値の優先値を使用するときがあるので、(自分が作成したものでなければ)オーバーレイの優先度にたいして数値演算を試みてはならない。特にリージョンの表示に使用されるオーバーレイは@w{@code{(@var{primary}
. @var{secondary})}}
(@var{primary}は上述のように使用されて、@var{secondary}は@var{primary}とネストを考慮したオーバーレイ間の優先度の解決が失敗した際に使用される)という形式の優先値を使用する。しかしあなたにはこの実装の詳細にもとづいてLispプログラムをデザインしないようにアドバイスした。優先順にオーバーレイを配置する必要があるなら@code{overlays-at}の@var{sorted}引数を使用すること。@ref{Finding
Overlays}を参照のこと。

@item window
@kindex window @r{(overlay property)}
@code{window}プロパティが非@code{nil}ならオーバーレイはそのウィンドウだけに適用される。

@item category
@kindex category @r{(overlay property)}
オーバーレイが@code{category}プロパティをもつなら、それをオーバーレイの@dfn{カテゴリー(category)}と呼ぶ。これはシンボルであること。そのシンボルのプロパティはオーバーレイのプロパティにたいしてデフォルトの役割を果たす。

@item face
@kindex face @r{(overlay property)}
このプロパティはテキストの外観を制御する(@ref{Faces}を参照)。プロパティの値は以下のいずれか:

@itemize @bullet
@item
フェイス名(シンボルか文字列)。

@item
anonymousフェイス: @code{(@var{keyword} @var{value}
@dots{})}という形式のプロパティリストであり@var{keyword}はフェイス属性名、@var{value}はその属性の値。

@item
フェイスのリスト。リストの要素はそれぞれフェイス名かanonymousフェイスのいずれかであること。これはリストされた各フェイスの属性を集約するフェイスを指定する。このリスト内で先に出現するフェイスが、より高い優先度をもつ。

@item
@code{(foreground-color . @var{color-name})}か@code{(background-color
. @var{color-name})}という形式のコンスセル。これは@code{(:foreground
@var{color-name})}や@code{(:background
@var{color-name})}と同じように、フォアグラウンドとバックグラウンドのカラーを指定する。この形式は後方互換性のためだけにサポートされており、使用は避けること。
@end itemize

@item mouse-face
@kindex mouse-face @r{(overlay property)}
このプロパティはマウスがオーバーレイ範囲内にあるときに、@code{face}のかわりに使用される。しかしEmacsはこのプロパティに由来するテキストのサイズを変更するようなフェイス属性(@code{:height}、@code{:weight}、@code{:slant})をすべて無視する。これらの属性はハイライトされていないテキストでは常に同一である。

@item display
@kindex display @r{(overlay property)}
このプロパティはテキストが表示される方法を変更するさまざまな機能をアクティブにする。たとえばこれはテキストの外観を縦長(taller)や横長(shorter)にしたり、高く(higher)したり低く(lower)したり、イメージによる置き換えを行う。@ref{Display
Property}を参照のこと。

@item help-echo
@kindex help-echo @r{(overlay property)}
あるオーバーレイが@code{help-echo}プロパティをもつなら、そのオーバーレイ内のテキスト上にマウスを移動した際に、Emacsはエコーエリアかツールチップウィンドウにヘルプ文字列を表示する。詳細は@ref{Text
help-echo}を参照のこと。

@item field
@kindex field @r{(overlay property)}
@c Copied from Special Properties.
同じ@code{field}プロパティをもつ連続する文字は@emph{フィールド(field)}を形成する。@code{forward-word}や@code{beginning-of-line}を含むいくつかの移動関数はフィールド境界で移動を停止する。@ref{Fields}を参照のこと。

@item modification-hooks
@kindex modification-hooks @r{(overlay property)}
このプロパティの値はオーバーレイ内の任意の文字の変更、またはオーバーレイの厳密に内側にテキストが挿入された場合に呼び出される関数のリスト。

このフックの関数は各変更の前後両方で呼び出される。これらの関数が受け取った情報を保存して呼び出し間で記録を比較すれば、バッファー内のテキストでどのような変更が行われたかを正確に判断できる。

変更前に呼び出された際にはオーバーレイ、@code{nil}、変更されたテキスト範囲の開始と終了という4つの引数を各関数は受け取る。

変更後に呼び出された際にはオーバーレイ、@code{t}、変更されたテキスト範囲の開始と終了、およびその範囲により置き換えられた変更前のテキスト長という5つの引数を各関数は受け取る(変更前の長さは挿入では0、削除では削除された文字数であり、変更後の先頭と終端が等しくなる)。

これらの関数が呼び出される際には@code{inhibit-modification-hooks}が、非@code{nil}にバインドされる。関数がバッファーを変更した場合には変更にたいして変更フックが実行されるように、@code{inhibit-modification-hooks}を@code{nil}にバインドしたいと思うかもしれない。しかしこれを行うことにより、あなた自身の変更フックが再帰的に呼び出されるかもしれないので、それに確実に備える必要がある。@ref{Change
Hooks}を参照のこと。

テキストプロパティも@code{modification-hooks}プロパティをサポートするが詳細は幾分異なる(@ref{Special
Properties}を参照)。

@item insert-in-front-hooks
@kindex insert-in-front-hooks @r{(overlay property)}
このプロパティの値はオーバーレイ先頭へのテキスト挿入前後に呼び出される関数のリスト。呼び出し方は@code{modification-hooks}の関数と同様。

@item insert-behind-hooks
@kindex insert-behind-hooks @r{(overlay property)}
このプロパティの値はオーバーレイ終端へのテキスト挿入前後に呼び出される関数のリスト。呼び出し方は@code{modification-hooks}の関数と同様。

@item invisible
@kindex invisible @r{(overlay property)}
@code{invisible}プロパティによりオーバーレイ内のテキストを不可視にできる。これはそのテキストがスクリーン上に表示されないことを意味する。詳細は@ref{Invisible
Text}を下さいのこと。

@item intangible
@kindex intangible @r{(overlay property)}
オーバーレイの@code{intangible}プロパティは正に@code{intangible}テキストプロパティと同様に機能する。これは時代遅れである。詳細は@xref{Special
Properties}を参照のこと。

@item isearch-open-invisible
このプロパティはインクリメンタル検索にたいして最後のマッチがそのオーバーレイに重なる場合に、不可視なオーバーレイを永続的に可視にする方法を告げる。@ref{Invisible
Text}を参照のこと。

@item isearch-open-invisible-temporary
このプロパティはインクリメンタル検索にたいして、検索の間に不可視なオーバーレイを一時的に可視にする方法を告げる。@ref{Invisible
Text}を参照のこと。

@item before-string
@kindex before-string @r{(overlay property)}
このプロパティの値はオーバーレイ先頭に表示するために追加する文字列。この文字列はいかなる意味においてもバッファー内には出現せずにスクリーン上にのみ表れる。

@item after-string
@kindex after-string @r{(overlay property)}
このプロパティの値はオーバーレイ終端に表示するために追加する文字列。この文字列はいかなる意味においてもバッファー内には出現せずにスクリーン上にのみ表れる。

@item line-prefix
このプロパティは表示時にそれぞれの非継続行の後に追加するディスプレイ仕様(display
spec)を指定する。@ref{Truncation}を参照のこと。

@item wrap-prefix
このプロパティは表示時にそれぞれの継続行の前に追加するディスプレイ仕様(display
spec)を指定する。@ref{Truncation}を参照のこと。

@item evaporate
@kindex evaporate @r{(overlay property)}
このプロパティが非@code{nil}の場合には、そのオーバーレイが空(長さが0)になったら自動的に削除される。空のオーバーレイ(@ref{Managing
Overlays, empty
overlay}を参照)にたいして非@code{nil}の@code{evaporate}プロパティを与えた場合には即座に削除される。オーバーレイがこのプロパティをもたなければ、バッファーからオーバーレイの開始位置と終了位置の間のテキストが削除された際に削除されないことに注意。

@item keymap
@cindex keymap of character (and overlays)
@kindex keymap @r{(overlay property)}
このプロパティが@code{nil}なら、そのテキスト範囲にたいしてキーマップを指定する。このキーマップはポイントの後の文字がそのオーバーレイ内にあるときに使用されて、他のほとんどのキーマップより優先される。@ref{Active
Keymaps}を参照のこと。

@item local-map
@kindex local-map @r{(overlay property)}
@code{local-map}プロパティは@code{keymap}プロパティと同様だが、既存のキーマップに付け加えるのではなくバッファーのローカルマップを置き換える点が異なる。これはそのキーマップがマイナーモードキーマップより低い優先度をもつことも意味する。
@end table

@code{keymap}と@code{local-map}プロパティは@code{before-string}、@code{after-string}、@code{display}プロパティにより表示された文字列には影響しません。これはポイントがその文字列上にない場合のマウスクリックや、その文字列に関する他のマウスイベントにのみ関係があります。その文字列に特別なマウスイベントをバインドするには、そのイベントを@code{keymap}か@code{local-map}プロパティに割り当てます。@ref{Special
Properties}を参照してください。

@node Finding Overlays
@subsection オーバーレイにたいする検索
@cindex searching for overlays
@cindex overlays, searching for

@defun overlays-at pos &optional sorted
この関数はカレントバッファー内の位置@var{pos}にある文字をカバーするすべてオーバーレイのリストをリターンする。@var{sorted}が非@code{nil}ならリストは優先度降順、それ以外なら特定の順にはソートされない。オーバーレイが@var{pos}、またはそれより前から始まり、かつ@var{pos}の後で終わるなら位置@var{pos}はオーバーレイに含まれる。

以下はポイント位置の文字にたいしてプロパティ@var{prop}を指定するオーバーレイのリストをリターンするLisp関数の使用例:

@smallexample
(defun find-overlays-specifying (prop)
  (let ((overlays (overlays-at (point)))
        found)
    (while overlays
      (let ((overlay (car overlays)))
        (if (overlay-get overlay prop)
            (setq found (cons overlay found))))
      (setq overlays (cdr overlays)))
    found))
@end smallexample
@end defun

@defun overlays-in beg end
この関数は@var{beg}から@var{end}のリージョンと重複(overlap)するオーバーレイのリストをリターンする。オーバーレイがリージョン内の文字を少なくとも1つ含めば、オーバーレイとリージョンは重複している。空のオーバーレイ(@ref{Managing
Overlays, empty
overlay}を参照)が@var{beg}にある場合、厳密には@var{beg}と@var{beg}の間、または@var{end}がバッファー終端の位置を意味するときは@var{end}にある場合には重複している。
@end defun

@defun next-overlay-change pos
この関数は@var{pos}の後にあるオーバーレイの開始か終了となるバッファー位置をリターンする。それが存在しなければ@code{(point-max)}をリターンする。
@end defun

@defun previous-overlay-change pos
この関数は@var{pos}の前にあるオーバーレイの開始か終了となるバッファー位置をリターンする。それが存在しなければ@code{(point-min)}をリターンする。
@end defun

  以下に例としてプリミティブ関数@code{next-single-char-property-change} (@ref{Property
Search}を参照)の単純化(かつ非効率的)したバージョンを示します。これは位置@var{pos}から前方へ与えられたプロパティ@code{prop}にたいして、オーバーレイプロパティまたはテキストプロパティのいずれかの値が変化した次の位置を検索します。

@smallexample
(defun next-single-char-property-change (position prop)
  (save-excursion
    (goto-char position)
    (let ((propval (get-char-property (point) prop)))
      (while (and (not (eobp))
                  (eq (get-char-property (point) prop) propval))
        (goto-char (min (next-overlay-change (point))
                        (next-single-property-change (point) prop)))))
    (point)))
@end smallexample

@node Size of Displayed Text
@section 表示されるテキストのサイズ
@cindex size of text on display
@cindex character width on display

すべての文字が同じ幅をもつ訳ではありませんが、以下の関数により文字の幅をチェックできます。関連する関数については@ref{Primitive
Indent}と@ref{Screen Lines}を参照してください。

@defun char-width char
この関数は文字@var{char}がカレントバッファーに表示された場合(つまりそのバッファーのディスプレイテーブルがあれば考慮に入れる。@ref{Display
Tables}を参照)の幅を列数でリターンする。タブ文字の幅、通常は@code{tab-width} (@ref{Usual Display}を参照)。
@end defun

@defun string-width string &optional from to
This function returns the width in columns of the string @var{string}, if it
were displayed in the current buffer and the selected window.  Optional
arguments @var{from} and @var{to} specify the substring of @var{string} to
consider, and are interpreted as in @code{substring} (@pxref{Creating
Strings}).

リターン値は近似値。ディスプレイプロパティやフォント等は無視して構成文字(constituent
characters)にたいしては@code{char-width}のリターン値、タブ文字は常に@code{tab-width}列を占めるものとみなす。これらの理由により、以下で説明する@code{window-text-pixel-size}使用を推奨する。
@end defun

@defun truncate-string-to-width string width &optional start-column padding ellipsis ellipsis-text-property
This function returns a new string that is a truncation of @var{string}
which fits within @var{width} columns on display.

If @var{string} is narrower than @var{width}, the result is equal to
@var{string}; otherwise excess characters are omitted from the result.  If a
multi-column character in @var{string} exceeds the goal @var{width}, that
character is omitted from the result.  Thus, the result can sometimes fall
short of @var{width}, but cannot go beyond it.

The optional argument @var{start-column} specifies the starting column.  If
this is non-@code{nil}, then the first @var{start-column} columns of the
string are omitted from the result.  If one multi-column character in
@var{string} extends across the column @var{start-column}, that character is
omitted.

The optional argument @var{padding}, if non-@code{nil}, is a padding
character added at the beginning and end of the result string, to extend it
to exactly @var{width} columns.  The padding character is appended at the
end of the result if it falls short of @var{width}, as many times as needed
to reach @var{width}.  It is also prepended at the beginning of the result
if a multi-column character in @var{string} extends across the column
@var{start-column}.

If @var{ellipsis} is non-@code{nil}, it should be a string which will
replace the end of @var{string} when it is truncated.  In this case, more
characters will be removed from @var{string} to free enough space for
@var{ellipsis} to fit within @var{width} columns.  However, if the display
width of @var{string} is less than the display width of @var{ellipsis},
@var{ellipsis} will not be appended to the result.  If @var{ellipsis} is
non-@code{nil} and not a string, it stands for the value returned by the
function @code{truncate-string-ellipsis}, described below.

オプション引数@var{ellipsis-text-property}が非@code{nil}なら、実際に文字列を切り詰めずに省略記号(ellipsis)を表示する@code{display}テキストプロパティ(@ref{Display
Property}を参照)で@var{string}の超過部分を隠すことを意味する。

@example
(truncate-string-to-width "\tab\t" 12 4)
     @result{} "ab"
(truncate-string-to-width "\tab\t" 12 4 ?\s)
     @result{} "    ab  "
@end example
@end defun

@defun truncate-string-ellipsis
この関数は@code{truncate-string-to-width}および同様のコンテキストにおいて省略記号(ellipses)として使用する文字列をリターンする。値は変数@code{truncate-string-ellipsis}が@code{nil}でなければその値、すなわち選択されたフレームで表示可能なら単一文字@sc{U+2026
HORIZONTAL ELLIPSIS}、それ以外なら文字列@samp{...}。
@end defun


以下の関数は与えられたウィンドウにあるテキストを表示したときのサイズをピクセル単位でリターンします。この関数はテキストを含むためにウィンドウを十分大きくするために@code{fit-window-to-buffer}と@code{fit-frame-to-buffer}
(@ref{Resizing Windows}を参照)により使用されます。

@defun window-text-pixel-size &optional window from to x-limit y-limit mode-and-header-line
この関数は@var{window}のバッファーのテキストサイズをピクセル単位でリターンする。@var{window}は生きたウィンドウでなければならずデフォルトは選択されたウィンドウ。リターン値は任意のテキスト行の最大ピクセル幅と、すべてのテキスト行の最大ピクセル高さのコンス。この関数はバッファーテキストの表示に要する@var{window}サイズを、Lispプログラムが調整できるようにするために存在する。

オプション引数@var{from}が非@code{nil}なら、それは考慮すべき最初のテキスト位置を指定する。デフォルトはそのバッファーのアクセス可能な最小の位置。@var{from}が@code{t}なら、改行文字ではないアクセス可能な最小位置を意味する。オプション引数@var{to}が非@code{nil}なら、それは考慮すべき最後のテキスト位置を指定する。デフォルトはそのバッファーのアクセス可能な最大の位置。@var{to}が@code{t}なら、改行文字ではないアクセス可能な最大位置を意味する。

オプション引数@var{x-limit}が非@code{nil}なら、その位置を超えるテキストを指定するような最大X座標を指定する。したがってこれはこの関数がリターンし得る最大のピクセル幅でもある。@var{x-limit}が@code{nil}または省略なら、@var{window}のbody(@ref{Window
Sizes}を参照)のピクセル幅を使用することを意味する。このデフォルト値はウィンドウより永井切り詰められた行のテキストは無視されることを意味する。このデフォルト値はは呼び出し側が@var{window}の幅の変更を意図しない場合に有用。それ以外なら呼び出し側はここで想定される@var{window}のbodyの最大幅を指定すること。特に行の切り詰めが予想される場合に、それらの行のテキストを勘定に入れる必要があるなら、@var{x-limit}を大きな値にセットする必要がある。長い行の幅の計算にはいくらかの時間を要するかもしれないので、必要に応じてこの変数を小さくするのはよいアイデアである。これはいずれにせよ切り詰められるような長い行をバッファーが含む場合が特に該当する。

オプション引数@var{y-limit}が非@code{nil}なら、その値を超えるテキストは無視されるような最大Y座標を指定する。したがってこれは関数がリターンし得る最大のピクセル高さでもある。@var{y-limit}がnilか省略なら、@var{to}で指定したバッファー位置までのすべてのテキスト行を考慮することを意味する。大きなバッファーのピクセル高さの計算には多くの時間を要する可能性があるので、特に呼び出し側がバッファーのサイズを知らない場合におけるこの変数の指定は合理的である。

オプション引数@var{mode-and-header-line}が@code{nil}または省略された場合には、リターン値に@var{window}のモードラインとヘッダーラインの高さを含めないことを意味する。これがシンボル@code{mode-line}か@code{header-line}のいずれかなら、それらが存在する場合にはリターン値にそのラインの高さだけを含める。これが@code{t}なら存在する場合は両方の高さをリターン値に含める。
@end defun

@code{window-text-pixel-size}はウィンドウ内に表示されているテキスト全体を扱い、個々の行サイズには留意しません。それは以下の関数が行います。

@defun window-lines-pixel-dimensions &optional window first last body inverse left
この関数は指定した@var{window}に表示された各行のピクセルサイズを計算する。これは@var{window}のカレントグリフマトリクス(
@var{window}にカレントで表示されている各バッファー文字のグリフを格納するマトリクス。@ref{Glyphs}を参照)を調べることにより機能する。成功したら各行末文字の右下隅のX座標とY座標を表すコンスペアのリストをリターンする。これらの座標は@var{window}の左上隅にある原点(0,
0)からピクセル単位で計測される。@var{window}は生きたウィンドウでなければならずデフォルトは選択されたウィンドウ。

オプション引数@var{first}が整数なら、リターンする@var{window}のグリフマトリクスの最初の行のインデックス(0から開始)を示す。@var{window}にヘッダーラインがあればインデックス0の行はヘッダーラインになることに注意。@var{first}が@code{nil}なら考慮する最初の行はオプション引数@var{body}の値で判断される。@var{body}が非@code{nil}なら、(もしあれば)ヘッダーラインをすべてスキップして@var{window}のbodyの最初の行から開始することを意味する。それ以外なら@var{window}のグリフマトリクスの最初の行(ヘッダーラインかもしれない)から開始することを意味する。

オプション引数@var{last}が整数なら、リターンする@var{window}のグリフマトリクスの最後の行のインデックスを示す。@var{last}が@code{nil}なら考慮する最初の行はオプション引数@var{body}の値で判断される。@var{body}が非@code{nil}なら、@var{window}のモードラインを省略して@var{window}のbodyの最後の行を使用することを意味する。それ以外なら@var{window}のグリフマトリクスの最後の行(モードラインかもしれない)を使用することを意味する。

オプション引数@var{inverse}が@code{nil}なら、リターンされる任意の行にたいするYピクセル値が@var{window}の左エッジ(@var{body}が非@code{nil}なら左bodyエッジ)から、その行の最後のグリフの右エッジまでのピクセル単位の距離を指定することを意味する。非@code{nil}の@var{inverse}は、リターンされる任意の行にたいするYピクセル値がその行の最後のグリフの右エッジから右エッジ(@var{body}が非@code{nil}なら右bodyエッジ)までのピクセル単位の距離を指定することを意味する。これは各行末の未使用スペースの量を判断するために有用。

オプション引数@var{left}が非@code{nil}なら各行左端文字の左下隅のX座標とY座標をリターンすることを意味する。これは主に右から左にテキストを表示にたいして使用されるべき値である。

@var{left}が非@code{nil}で@var{inverse}が@code{nil}なら、リターンされる任意の行にたいするYピクセル値がその行の最後(左端)のグリフの左エッジから、@var{window}の右エッジ(
@var{body}が非@code{nil}なら右bodyエッジ)までのピクセル単位の距離を指定することを意味する。@var{left}と@var{inverse}がいずれも非@code{nil}なら、リターンされる任意の行にたいするYピクセル値が@var{window}の左エッジ(
@var{body}が非@code{nil}なら左bodyエッジ)から、その行の最後(左端)のグリフの左エッジまでのピクセル単位の距離を指定することを意味する。

この関数は@var{window}のカレントグリフマトリクスが最新でなければ@code{nil}をリターンする。これはたとえばコマンドの処理中のようにEmacsがbusyな際に通常は発生する。これは遅延が0秒であるようなアイドルタイマーからこの関数が実行された際に取得され得る値である。
@end defun

@defun line-pixel-height
この関数は選択されたウィンドウのポイント位置にある行の高さをピクセル単位でリターンする。値にはその行の行スペーシングが含まれる(@ref{Line
Height}を参照)。
@end defun

行番号(@ref{Display Custom,,, emacs, The GNU Emacs
Manual}を参照)とともにバッファーを表示している際には、行番号の表示に必要な幅が解ると便利なときがあります。以下はレイアウト計算用にこの情報を必要とするLispプログラムのための関数です。

@defun line-number-display-width &optional pixelwise
この関数は選択されたウィンドウで行番号の表示に使用される幅をリターンする。オプション引数@var{pixelwise}がシンボル@code{columns}なら、リターン値はフレームの正準列(清純文字幅)にたいする浮動小数点数となる。@var{pixelwise}が@code{t}やそれ以外の非@code{nil}値なら、値はピクセルで計測した整数となる。@var{pixelwise}が省略か@code{nil}なら、値は@code{line-number}フェイスにたいして定義されたフォントによる列数を表す整数となる。この場合には値には番号の表示の間隙を埋めるために使用する2列分は含まれない。選択されたウィンドウに行番号が表示されていなければ、@var{pixelwise}の値にかかわらず値は0になる。別のウィンドウにたいしてこの情報が必要なら@code{with-selected-window}を使用すること(@ref{Selecting
Windows}を参照)。
@end defun


@node Line Height
@section 行の高さ
@cindex line height
@cindex height of a line

  各ディスプレイ行のトータル高さは、その行のコンテンツ高さにディスプレイ上部や下部にオプションで追加される垂直行スペーシングを加えて構成されます。

  行のコンテンツ高さは、もしあれば最後の改行を含む、そのディスプレイ行の文字またはイメージの最大高さです(継続されるディスプレイ行には最後の改行が含まれない)。特にこれより大きい高さを指定しなければ、これがデフォルトの行高さになります(これは一般的には対応するフレームのデフォルトのフォント高さに等しい。@ref{Frame
Font}を参照)。

  より大きい行高さを明示的に指定するためにはディスプレイ行の絶対高さ、または垂直スペースを指定する複数の方法が存在します。しかし何を指定したかに関わらず、実際の行高さがデフォルトの高さより小さくなることはありません。

@kindex line-height @r{(text property)}
  改行はその改行で終わるディスプレイ行のトータル高さを制御するテキストプロパティとオーバーレイプロパティ@code{line-height}をもつことができます。プロパティ値はいずれかの形式をもつことができます:

@table @code
@item t
プロパティの値が@code{t}なら改行文字はその行の表示高さにたいして効果をもたず、可視なコンテンツだけが高さを決定します。この場合には以下で説明する@code{line-spacing}プロパティも無視されます。これはイメージ間に追加のブランク領域をもたない、小さなイメージ(やイメージスライス)にたいして有用です。
@item (@var{height} @var{total})
プロパティの値がこの形式のリストなら、これはディスプレイ行の@emph{下部}に余分なスペースを追加します。最初にEmacsは、その行の@emph{上部}の余分なスペースを制御するための高さspecとして、@var{height}を使用します。それから行のトータル高さを@var{total}にするために、行の@emph{下部}に必要なスペースを追加します。この場合には、改行にたいする@code{line-spacing}プロパティのすべての値は無視されます。
@end table

@cindex height spec
  他の種類のプロパティ値は高さspec(height
spec)です。これは行の高さを指定する数値に変換されます。高さspecを記述するためには複数の方法があります。以下はそれらが数値に変換される方法です:

@table @code
@item @var{integer}
高さspecが正の整数なら高さの値はその整数。
@item @var{float}
高さspecが浮動小数点数@var{float}なら高さ数値はそのフレームのデフォルト行高さの@var{float}倍。
@item (@var{face} . @var{ratio})
高さspecがこのフォーマットのコンスなら、高さ数値はフェイス@var{face}の高さの@var{ratio}倍。@var{ratio}には任意の型の数値を指定でき、@code{nil}は1のratioを意味する。@var{face}が@code{t}ならカレントフェイスを参照する。
@item (nil . @var{ratio})
高さspecがこのフォーマットのコンスなら高さ数値はその行のコンテンツ高さの@var{ratio}倍。
@end table

  したがって任意の有効な種々の高さspecによりピクセル単位で高さが決定されます。行のコンテンツ高さがこれより小さければ、Emacsは指定されたトータル高さになるように余分な垂直スペースを行の上部に追加します。

  @code{line-height}プロパティを指定しない場合には、その行の高さは行のコンテンツ高さとに行スペーシングを追加して構成されます。Emacsの異なるさまざまな部分のテキストにたいして、行スペーシングを指定する複数の方法が存在します。

  グラフィカルなディスプレイではフレームパラメーター@code{line-spacing} (@ref{Layout
Parameters}を参照)を使用することにより、フレーム内のすべての行にたいして行スペーシングを指定できます。しかし@code{line-spacing}のデフォルト値が非@code{nil}なら、それはそのフレームのフレームパラメーター@code{line-spacing}をオーバーライドします。整数は行の下部に配するピクセル数を指定します。浮動小数点数はフレームのデフォルト行高さに相対的にスペーシングを指定します。

@vindex line-spacing
  バッファーローカル変数@code{line-spacing}を通じて、バッファー内のすべての行の行スペーシングを指定できます。整数は行の下部に配するピクセル数を指定します。浮動小数点数はデフォルトフレーム行高さに相対的にスペーシングを指定します。これはそのフレームにたいして指定された行スペーシングをオーバーライドします。

@kindex line-spacing @r{(text property)}
  最後に改行は改行で終わるディスプレイ行にたいしてデフォルトフレーム行スペーシングを広くできるテキストプロパティとオーバーレイプロパティ@code{line-spacing}、および変数@code{line-spacing}をもつことができます。その値がバッファーやフレームのデフォルトより大きければ、その改行で終端されるディスプレイ行にはかわりにその値が使用されます。

  種々の方法によりこれらのメカニズムは各行のスペーシングにたいするLisp値を指定します。値は高さspecで、これは上述したLisp値に変換されます。しかしこの場合には高さ数値は行高さではなく行スペーシングを指定します。

  テキスト端末では行スペーシングは変更できません。

@node Faces
@section フェイス
@cindex faces

  @dfn{フェイス(face)}とはフォント、フォアグラウンドカラー、バックグラウンドカラー、オプションのアンダーライン等のテキストを表示するためのグラフィカルな属性のコレクションのことです。フェイスはEmacsがバッファー内や、同様にモードラインのようなフレームの他の部分でテキストを表示する方法を制御します。

@cindex anonymous face
  フェイスを表現する1つの方法として@code{(:foreground "red" :weight
bold)}のような属性のプロパティリストがあります。このようなリストは@dfn{anonymousフェイス(anonymous
face)}と呼ばれます。たとえば@code{face}テキストプロパティとしてanonymousフェイスを割り当てることができ、Emacsは指定された属性でテキストを表示するでしょう。@ref{Special
Properties}を参照してください。

@cindex face name
  より一般的にはフェイスは@dfn{フェイス名(face
name)}を通じて参照されます。これはフェイス属性のセットに関連付けられたLispシンボル@footnote{後方互換のため、フェイス名の指定に文字列も使用できます。これは同名のLispシンボルと等価です。}です。名前つきフェイスは@code{defface}マクロを使用して定義できます(@ref{Defining
Faces}を参照)。Emacsにはいくつかの標準名前つきフェイスが同梱されています(@ref{Basic Faces}を参照)。

  Emacsのある部分では名前つきフェイスが要求されます(たとえば@ref{Attribute
Functions}に記す関数)。特に明記しないかぎり、名前つきフェイスの参照だけに用語@dfn{フェイス}を使用することにします。

@defun facep object
この関数は@var{object}が名前つきフェイス(フェイス名の役目をもつLispシンボルか文字列)なら非@code{nil}、それ以外なら@code{nil}をリターンする。
@end defun

@menu
* Face Attributes::          フェイスとは?
* Defining Faces::           フェイスを定義する方法。
* Attribute Functions::      フェイス属性の確認やセットを行う関数。
* Displaying Faces::         ある文字にたいして指定されたフェイスをEmacsが組み合わせる方法。
* Face Remapping::           フェイスを別の定義にリマップする。
* Face Functions::           フェイスの定義と確認を行う方法。
* Auto Faces::               自動的にフェイスを割り当てるフック。
* Basic Faces::              デフォルトで定義されるフェイス。
* Font Selection::           あるフェイスに最適なフォントを見つける。
* Font Lookup::              利用可能なフォント名とそれらの情報の照会。
* Fontsets::                 フォントセットは文字セットの範囲を処理するフォントコレクション。
* Low-Level Font::           文字表示フォントのLisp表現。
@end menu

@node Face Attributes
@subsection フェイスの属性
@cindex face attributes

  @dfn{フェイス属性(Face
attributes)}は、フェイスの視覚的外観を決定します。以下はすべてのフェイス属性と、それらの可能な値と効果に関するテーブルです。

  以下の値とは別に各フェイス属性は値@code{unspecified}をもつことができます。この特殊な値はフェイスがその属性を直接指定しないことを意味します。@code{unspecified}属性はEmacsにかわりに親フェイス(以下の@code{:inherit}属性の記述を参照)を参照して、それに失敗したら基礎フェイス(@ref{Displaying
Faces}を参照)を参照することを指示します。@code{default}フェイスはすべての属性を指定しなければなりません。

  これらの属性のいくつかは特定の種類のディスプレイにおいてのみ意味があります。ディスプレイが特定の属性を処理できなければ、その属性は無視されます。

@table @code
@item :family
フォントファミリー名(文字列)。フォントファミリーに関する詳細は@ref{Fonts,,, emacs, The GNU Emacs
Manual}を参照のこと。関数@code{font-family-list} (以下参照)は利用可能なファミリー名のリストをリターンする。

@item :foundry
@code{:family}属性により指定されるフォントファミリーにたいする@dfn{フォントfoundry} (文字列)。@ref{Fonts,,,
emacs, The GNU Emacs Manual}を参照のこと。

@item :width
相対的な文字幅。これはシンボル@code{ultra-condensed}、@code{extra-condensed}、@code{condensed}、@code{semi-condensed}、@code{normal}、@code{semi-expanded}、@code{expanded}、@code{extra-expanded}、@code{ultra-expanded}のいずれかであること。

@item :height
フォントの高さ。もっともシンプルなケースでは1/10ポイントを単位とする整数。

値には@dfn{基礎フェイス(underlying
face)}にたいして相対的に高さを指定する浮動小数点数、または関数も指定できる(@ref{Displaying
Faces}を参照)。浮動小数点数は基礎フェイスの高さをスケーリングする量を指定する。関数値は基礎フェイスの高さを単一の引数として呼び出されて、新たなフェイスの高さをリターンする。関数が整数を引数として渡された場合には整数をリターンしなければならない。

デフォルトフェイスの高さは整数を使用して指定しなければならない。浮動小数点数や関数は受け入れられない。

@item :weight
フォントのweight。シンボル@code{ultra-bold}、@code{extra-bold}、@code{bold}、@code{semi-bold}、@code{normal}、@code{semi-light}、@code{light}、@code{extra-light}、@code{ultra-light}
(太字から細字順)のいずれか。可変輝度テキストをサポートするテキスト端末では、normalより大なweightはより高輝度、小なweightはより低輝度で表示される。

@cindex italic text
@item :slant
フォントのslant。シンボル@code{italic}、@code{oblique}、@code{normal}、@code{reverse-italic}、@code{reverse-oblique}のいずれか。可変輝度テキストをサポートするテキスト端末ではslantされたテキストはhalf-brightで表示される。

@item :foreground
フォアグラウンドカラー(文字列)。値にはシステム定義済みカラー、または16進カラー仕様を指定できる。@ref{Color
Names}を参照のこと。白黒ディスプレイでは特定のグレー色調が点描パターンで実装されている。

@item :distant-foreground
代替えのフォアグラウンドカラー(文字列)。これは@code{:foreground}と似ているが、使用されるであろうフォアグラウンドカラーがバックグラウンドカラーに近いときのみフォアグラウンドカラーとして使用される点が異なる。これはたとえばテキストをマーク時(リージョンフェイス)に有用。そのテキストがリージョンフェイスとして可視なフォアグラウンドをもつ場合には、そのフォアグラウンドが使用される。フォアグラウンドがリージョンフェイスのバックグラウンドに近ければ、テキストを可読にするために@code{:distant-foreground}が使用される。

@item :background
バックグラウンドカラー(文字列)。値にはシステム定義済みカラー、または16進カラー仕様を指定できる。@ref{Color Names}を参照のこと。

@cindex underlined text
@item :underline
文字にアンダーラインを引くべきか否か、およびその方法。@code{:underline}属性として可能な値は以下のとおり:

@table @asis
@item @code{nil}
アンダーラインを引かない。

@item @code{t}
そのフェイスのフォアグラウンドカラーでアンダーラインを引く。

@item @var{color}
文字列@var{color}で指定されたカラーでアンダーラインを引く。

@item @code{(:color @var{color} :style @var{style})}
@var{color}は文字列、またはそのフェイスのフォアグラウンドカラーを意味するシンボル@code{foreground-color}。属性@code{:color}の省略はフェイスのフォアグラウンドカラーの使用を意味する。@var{style}は直線を意味する@code{line}、または波線を意味する@code{wave}いずれかのシンボルであること。属性@code{:style}の省略は直線を意味する。
@end table

@cindex overlined text
@item :overline
文字にオーバーラインを引くべきか否か、およびそのカラー。値が@code{t}ならフェイスのフォアグラウンドカラーを使用してオーバーラインを引く。値が文字列ならそのカラーを使用してオーバーラインを引く。値@code{nil}はオーバーラインを引かないことを意味する。

@cindex strike-through text
@item :strike-through
文字に取り消し線を引くべきか否か、およびそのカラー。値は@code{:overline}で使用される値と同じ。

@cindex 2D box
@cindex 3D box
@item :box
文字周囲に枠(box)を描画するか否か、そのカラー、枠線の幅、および3D外観。以下は@code{:box}の可能な値と意味:

@table @asis
@item @code{nil}
枠を描画しない。

@item @code{t}
幅1のフォアグラウンドカラーで枠線を描画する。

@item @var{color}
幅1のカラー@var{color}で枠線を描画する。

@item @code{(:line-width (@var{vwidth} . @var{hwidth}) :color @var{color} :style @var{style})}
This way you can explicitly specify all aspects of the box.  The values
@var{vwidth} and @var{hwidth} specifies respectively the width of the
vertical and horizontal lines to draw; they default to (1 . 1).  A negative
horizontal or vertical width @minus{}@var{n} means to draw a line of width
@var{n} that occupies the space of the underlying text, thus avoiding any
increase in the character height or width. For simplification the width
could be specified with only a single number @var{n} instead of a list, such
case is equivalent to @code{((abs @var{n}) . @var{n})}.

The value @var{style} specifies whether to draw a 3D box.  If it is
@code{released-button}, the box looks like a 3D button that is not being
pressed.  If it is @code{pressed-button}, the box looks like a 3D button
that is being pressed.  If it is @code{nil}, @code{flat-button} or omitted,
a plain 2D box is used.

The value @var{color} specifies the color to draw with.  The default is the
background color of the face for 3D boxes and @code{flat-button}, and the
foreground color of the face for other boxes.
@end table

@item :inverse-video
文字が反転表示されて表示されるべきか否か。値は@code{t} (反転表示する)か@code{nil} (反転表示しない)のいずれか。

@item :stipple
バックグラウンドの点描(ビットマップ)。

値には文字列を指定できる。外部形式Xビットマップデータを含むファイルの名前であること。ファイルは変数@code{x-bitmap-file-path}にリストされるディレクトリー内で検索される。

かわりに@code{(@var{width} @var{height}
@var{data})}という形式のリストによりビットマップで直接値を指定できる。ここで@var{width}と@var{height}はピクセル単位によるサイズ、@var{data}は行単位でビットマップのrawビットを含む文字列。各行は文字列内で連続する@math{(@var{width}
+ 7) / 8}バイトを占める(最善の結果を得るためにはユニバイト文字列であること)。これは各行が常に少なくとも1バイト全体を占めることを意味する。

値が@code{nil}なら点描パターンを使用しないことを意味する。

これは特定のグレー色調を処理するために自動的に使用されるので、通常はstipple属性のセットは必要ない。

@item :font
そのフェイスの表示に使用されるフォント。値はフォントオブジェクトかフォントセットであること。フォントオブジェクト、フォントスペース、フォントエンティティーに関する情報は@ref{Low-Level
Font}、フォントセットに関する情報は@ref{Fontsets}を参照のこと。

@anchor{face-font-attribute}
@code{set-face-attribute}や@code{set-face-font} (@ref{Attribute
Functions}を参照)を使用してこの属性を指定する際にはフォントspec、フォントエンティティー、または文字列を与えることもできる。Emacsはそのような値を適切なフォントオブジェクトに変換して、実際の属性値としてそのフォントオブジェクトを格納する。文字列を指定する場合には、その文字列のコンテンツはフォント名であること(@ref{Fonts,,,
emacs, The GNU Emacs
Manual}を参照)。フォント名がワイルドカードを含むXLFDなら、Emacsはそれらのワイルドカードに最初にマッチするフォントを選択する。この属性の指定により@code{:family}、@code{:foundry}、@code{:width}、@code{:height}、@code{:weight}、@code{:slant}の属性値も変更される。

@cindex inheritance, for faces
@item :inherit
属性を継承するフェイス名、またはフェイス名のリスト。継承フェイス由来の属性は基礎フェイスより高い優先度で、基礎フェイスの場合と同じような方法でマージされる(@ref{Displaying
Faces}を参照)。継承元のフェイスが@code{unspecified}ならEmacsは@code{:inherit}属性を決してマージしないので@code{nil}と同様に扱われる。フェイスのリストが使用された場合には、リスト内先頭側フェイスの属性が末尾側フェイスの属性をオーバーライドする。

@item :extend
そのフェイスが行末を超えて拡張されるか、および行末とウィンドウのエッジの間の空スペースの表示に影響を与えるかどうか。値は行末とウィンドウのエッジの間の空スペースの表示にそのフェイスを使用するらら@code{t}、使用しなければ@code{nil}。Emacsが行末を超える空スペースの表示でいくつかのフォントをマージする際に、@code{:extend}が非@code{nil}のフェイスだけがマージされる。デフォルトではこの属性がセットされているのは少数のフェイス、特に@code{region}だけである。この属性はテーマがフェイスに明示的な値を指定しない際に、値が@code{defface}によるフェイスの元定義から継承される点において他の属性とは異なる(@ref{Defining
Faces}を参照)。

@end table

@defun font-family-list &optional frame
この関数は利用可能なフォントファミリー名のリストをリターンする。オプション引数@var{frame}はそのテキストが表示されるフレームを指定する。これが@code{nil}なら選択されたフレームが使用される。
@end defun

@defopt underline-minimum-offset
この変数はアンダーラインが引かれたテキスト表示時に、ベースラインとアンダーライン間の最小距離をピクセル単位で指定する。
@end defopt

@defopt x-bitmap-file-path
この変数は@code{:stipple}属性のビットマップファイルを検索するディレクトリーのリストを指定する。
@end defopt

@defun bitmap-spec-p object
これは@var{object}、@code{:stipple}
(上記参照)での使用に適した有効なビットマップ仕様なら@code{t}、それ以外なら@code{nil}をリターンする。
@end defun

@node Defining Faces
@subsection フェイスの定義
@cindex defining faces

@cindex face spec
  フェイスを定義する通常の方法は@code{defface}マクロを通じて定義する方法です。このマクロはフェイス名(シンボル)をデフォルトの@dfn{フェイスspec(face
spec)}と関連付けます。フェイスspecとは任意の与えられた端末上でフェイスがどの属性をもつべきかを指定する構文です。たとえばあるフェイスspecは高カラー端末ではあるフォアグラウンドカラーし、低カラー端末では異なるフォアグラウンドカラーを指定するかもしれません。

  値がフェイス名であるような変数を作りたがる人がいます。ほとんどの場合には、これは必要ありません。通常の手順は@code{defface}でフェイスを定義して、その名前を直接使用することです。

@cindex face (non-removability of)
(通常は@code{defface}により)一度フェイスを定義したら、Emacsを再起動する以外にそのフェイスを安全に未定義にすることはできません。

@defmac defface face spec doc [keyword value]@dots{}
このマクロは@var{spec}によりデフォルトフェイスspecが与えられるような名前つきフェイスとして@var{face}を宣言する。シンボル@var{face}はクォートせずに@samp{-face}で終わらないこと(冗長かもしれない)。引数@var{doc}はフェイスにたいするドキュメント文字列。追加の@var{keyword}引数は@code{defgroup}や@code{defcustom}の場合と同じ意味をもつ(@ref{Common
Keywords}を参照)。

@var{face}がすでにデフォルトフェイスspecをもつ場合には、このマクロは何も行わない。

デフォルトフェイスspecは何もカスタマイゼーション(@ref{Customization}を参照)の効果がないときの@var{face}の外観を決定する。@var{face}が(Customテーマやinitファイルから読み込んだカスタマイズにより)すでにカスタマイズ済みなら、その外観はデフォルトフェイスspecの@var{spec}をオーバーライドするカスタムフェイスspecにより決定される。しかしその後カスタマイゼーションが削除されたら、@var{face}の外観は再びそのデフォルトフェイスspecにより決定されるだろう。

@cindex @code{eval-defun}, and @code{defface} forms
@cindex @code{eval-last-sexp}, and @code{defface} forms
As an exception, if you evaluate a @code{defface} form with @kbd{C-M-x}
(@code{eval-defun}) or with @kbd{C-x C-e} (@code{eval-last-sexp}) in Emacs
Lisp mode, a special feature of these commands overrides any custom face
specs on the face, causing the face to reflect exactly what the
@code{defface} says.

@var{spec}引数は異なる種別の端末上でそのフェイスがどのような外観で表示されるべきかを示す@dfn{フェイスspec}。これは各要素が以下の形式であるようなalistであること

@example
(@var{display} . @var{plist})
@end example

@noindent
@var{display}は端末のクラス(以下参照)を指定する。@var{plist}はそのような端末上でフェイスがどのような外観かを指定するフェイス属性とその値からなるプロパティリストであること。後方互換性のために@code{(@var{display}
@var{plist})}のように要素を記述することもできる。

@var{spec}の要素の@var{display}の部分は、その要素がマッチする端末を決定する。与えられた端末にたいして複数の要素がマッチした場合には、最初にマッチした要素がその端末にたいして使用される。@var{display}には以下の3つが可能:

@table @asis
@item @code{default}
@var{spec}のこの要素はどの端末にもマッチしない。かわりにすべての端末に適用されるデフォルトを指定する。この要素が使用する場合には、@var{spec}の最初の要素でなければならない。この後の要素はこれらのデフォルトの一部、またはすべてをオーバーライドできる。

@item @code{t}
@var{spec}のこの要素はすべての端末にマッチする。したがって@var{spec}の後続要素が使用されることはない。@code{t}は通常は@var{spec}の最後(か唯一)の要素として使用される。

@item リスト
@var{display}がリストなら各要素は@code{(@var{characteristic}
@var{value}@dots{})}という形式をもつこと。ここで@var{characteristic}は端末をクラス分けする方法、@var{value}は@var{display}に適用されるべき可能なクラス分類。@var{characteristic}に利用可能な値は:

@table @code
@item type
その端末が使用するウィンドウシステムの種類で@code{graphic} (任意のグラフィック対応ディスプレイ)、@code{x}、@code{pc}
(MS-DOSコンソール)、@code{w32} (MS Windows 9X/NT/2K/XP)、または@code{tty}
(グラフィック非対応ディスプレイ)のいずれか。@ref{Window Systems, window-system}を参照のこと。

@item class
その端末がサポートするカラーの種類であり@code{color}、@code{grayscale}か@code{mono}のいずれか。

@item background
バックグラウンドの種類であり@code{light}か@code{dark}のいずれか。

@item min-colors
その端末がサポートするべき最小カラー数を表す整数。端末の@code{display-color-cells}の値が少なくとも指定された整数ならその端末にマッチ。

@item supports
その端末が@var{value}@dots{}で与えられたフェイス属性を表示可能か否か(@ref{Face
Attributes}を参照)。このテストがどのように行われるかについてのより正確な情報は@ref{Display Face Attribute
Testing}を参照のこと。
@end table

与えられた@var{characteristic}にたいして@var{display}の要素が複数の@var{value}を指定する場合には、いずれの値も許容され得る。@var{display}が複数の要素をもつ場合には、各要素は異なる@var{characteristic}を指定すること。その端末の@emph{それぞれ}のcharacteristicは@var{display}内で指定された値のいずれか1つとマッチしなければならない。
@end table
@end defmac

  たとえば以下は標準フェイス@code{highlight}の定義です:

@example
(defface highlight
  '((((class color) (min-colors 88) (background light))
     :background "darkseagreen2")
    (((class color) (min-colors 88) (background dark))
     :background "darkolivegreen")
    (((class color) (min-colors 16) (background light))
     :background "darkseagreen2")
    (((class color) (min-colors 16) (background dark))
     :background "darkolivegreen")
    (((class color) (min-colors 8))
     :background "green" :foreground "black")
    (t :inverse-video t))
  "Basic face for highlighting."
  :group 'basic-faces)
@end example

  内部的にはEmacsはフェイスのシンボルプロパティ@code{face-defface-spec}内にそれぞれのフェイスのデフォルトspecを格納します(@ref{Symbol
Properties}を参照)。@code{saved-face}プロパティはカスタマイゼーションバッファーを使用してユーザーが保存した任意のフェイスspecを格納します。@code{customized-face}プロパティはカレントセッションにたいしてカスタマイズされた保存されていないフェイスspecを格納します。そして@code{theme-face}プロパティはそのフェイスにたいするアクティブなカスタマイゼーションセッティングと、フェイスspecをもつCustomテーマを関連付けるalistです。そのフェイスのドキュメント文字列は@code{face-documentation}プロパティ内に格納されます。

  フェイスは通常は@code{defface}を使用して1回だけ宣言されて、その外観にたいするそれ以上の変更はCustomizeフレームワーク(Customizeユーザーインターフェースか@code{custom-set-faces}関数を通じて。@ref{Applying
Customizations}を参照)、またはフェイスリマッピング(@ref{Face
Remapping}を参照)により行われます。Lispから直接フェイスspec変更を要する稀な状況では@code{face-spec-set}関数を使用できます。

@defun face-spec-set face spec &optional spec-type
この関数は@code{face}にたいするフェイスspecとして@var{spec}を適用する。@var{spec}は上述した@code{defface}にたいするフェイスspecであること。

この関数はもし@var{face}が既存のものでなければ有効なフェイス名として@var{face}を定義して、既存フレームのその属性の(再)計算も行う。

@cindex override spec @r{(for a face)}
オプション引数@var{spec-type}はどのspecをセットするかを決定する。これが省略か@code{nil}、または@code{face-override-spec}なら、この関数は@dfn{オーバーライドspec(override
spec)}をセットする。これは後述する@var{face}上の他のすべてのフェイスspecをオーバーライドする。これはCustomのコード外部からこの関数を呼び出す際に有用。@var{spec-type}が@code{customized-face}か@code{saved-face}なら、この関数はカスタマイズされたspec、または保存されたカスタムspecをセットする。@code{face-defface-spec}なら、この関数はデフォルトフェイスspec(@code{defface}によりセットされるものと同一)をセットする。@code{reset}なら、この関数は@var{face}からすべてのカスタマイゼーションspecとオーバーライドspecをクリアーする(この場合には@var{spec}の値は無視される)。@var{spec-type}の他の任意の値がフェイスspecに及ぼす効果は内部的な使用のために予約済みだが、それでも後述するようにこの関数は@var{face}自体の定義を行い属性を再計算する。
@end defun

@node Attribute Functions
@subsection フェイス属性のための関数
@cindex face attributes, access and modification

  このセクションでは名前つきフェイスの属性に直接アクセスしたり変更する関数を説明します。

@defun face-attribute face attribute &optional frame inherit
この関数は@var{frame}上の@var{face}にたいする属性@var{attribute}の値をリターンする。

@var{frame}が省略か@code{nil}なら選択されたフレームを意味する(@ref{Input
Focus}を参照)。@var{frame}が@code{t}なら、この関数は新たに作成されるフレームにたいして指定された属性の値をリターンする(これは下記の@code{set-face-attribute}を使用して何らかの値を指定していなければ通常は@code{unspecified})。

@var{inherit}が@code{nil}なら@var{face}により定義される属性だけが考慮されるのでリターンされる値は@code{unspecified}、または相対的な値かもしれない。@var{inherit}が非@code{nil}なら@var{face}の@var{attribute}の定義が、@code{:inherit}属性で指定されたフェイスとマージされる。しかしリターンされる値は依然として@code{unspecified}、または相対的な値かもしれない。@var{inherit}がフェイスかフェイスのリストなら、指定された絶対的な値になるまで結果はそのフェイス(1つ以上)と更にマージされる。

リターン値が指定されていて、かつ絶対的であることを保証するためには@var{inherit}にたいして@code{default}の値を使用すること。(常に完全に指定される)@code{default}フェイスとマージすることにより、すべての未指定や相対的な値は解決されるだろう。

たとえば

@example
(face-attribute 'bold :weight)
     @result{} bold
@end example
@end defun

@c FIXME: Add an index for "relative face attribute", maybe here?  --xfq
@defun face-attribute-relative-p attribute value
この関数は@var{value}がフェイス属性@var{attribute}の値として使用された際に相対的なら非@code{nil}をリターンする。これはフェイスリスト内の後続のフェイス、または継承した他のフェイスが由来となる任意の値で完全にオーバーライドするのではなく、それが変更されるであろうことを意味する。

すべての属性にたいして@code{unspecified}は相対的な値。@code{:height}にたいしては浮動小数点数と関数値も相対的である。

たとえば:

@example
(face-attribute-relative-p :height 2.0)
     @result{} t
@end example
@end defun

@defun face-all-attributes face &optional frame
この関数は@var{face}の属性のalistをリターンする。結果の要素は@w{@code{(@var{attr-name}
.
@var{attr-value})}}という形式の名前/値ペアー。オプション引数@var{frame}はリターンするべき@var{face}の定義をもつフレームを指定する。省略か@code{nil}ならリターン値には新たに作成されるフレームにたいする@var{face}のデフォルト属性が記述される。
@end defun

@defun merge-face-attribute attribute value1 value2
@var{value1}がフェイス属性@var{attribute}にたいして相対的な値なら、基礎的な値@var{value2}とマージしてリターンする。それ以外の場合には@var{value1}がフェイス属性@var{attribute}にたいして絶対的な値なら@var{value1}を変更せずにリターンする。
@end defun

  Emacsは通常は各フレームのフェイス属性を自動的に計算するために、各フェイスのフェイスspecを使用します(@ref{Defining
Faces}を参照)。関数@code{set-face-attribute}は特定またはすべてのフレームのフェイスに直接属性を割り当てることにより、この計算をオーバーライドできます。この関数は主として内部的な使用を意図したものです。

@defun set-face-attribute face frame &rest arguments
この関数は@var{frame}にたいする@var{face}の1つ以上の属性をセットする。この方法で指定された属性は@var{face}に属するフェイスspec(1つ以上)をオーバーライドする。

余分の引数@var{arguments}はセットするべき属性と値を指定する。これらは(@code{:family}や@code{:underline}のような)属性名と値が交互になるように構成されていること。つまり、

@example
(set-face-attribute 'foo nil :weight 'bold :slant 'italic)
@end example

@noindent
これは属性@code{:weight}を@code{bold}、.属性@code{:slant}を@code{italic}にセットする。


@var{frame}が@code{t}ならこの関数は新たに作成されるフレームにたいするデフォルト属性をセットする。@var{frame}が@code{nil}ならこの関数はすべての既存フレーム、同様に新たに作成されるフレームにたいしてその属性をセットする。
@end defun

  以下のコマンドと関数は主として古いバージョンのEmacsにたいする互換性のために提供されます。これらは@code{set-face-attribute}を呼び出すことにより機能します。これらの@var{frame}引数にたいする値@code{t}と@code{nil}
(や省略)は@code{set-face-attribute}や@code{face-attribute}の場合と同様に処理されます。コマンドがインタラクティブに呼び出されるとミニバッファーを使用して引数を読み取ります。

@deffn Command set-face-foreground face color &optional frame
@deffnx Command set-face-background face color &optional frame
これらはそれぞれ@var{face}の@code{:foreground}属性、または@code{:background}属性に@var{color}をセットする。
@end deffn

@deffn Command set-face-stipple face pattern &optional frame
これは@var{face}の@code{:stipple}属性に@var{pattern}をセットする。
@end deffn

@deffn Command set-face-font face font &optional frame
@var{face}のフォント関連の属性を@var{font}
(文字列かフォントオブジェクト)の属性に変更する。@var{font}引数でアポートされるフォーマットについては@ref{face-font-attribute}を参照のこと。この関数はフェイスの@code{:font}属性、および間接的に@code{:family}、@code{:foundry}、@code{:width}、@code{:height}、@code{:weight}、@code{:slant}の属性もそのフォントで定義された値にセットする。@var{frame}が非@code{nil}なら、指定したフレームの属性だけを変更する。
@end deffn

@defun set-face-bold face bold-p &optional frame
これは@var{face}の@code{:weight}属性にたいして@var{bold-p}が@code{nil}なら@var{normal}、それ以外なら@var{bold}をセットする。
@end defun

@defun set-face-italic face italic-p &optional frame
これは@var{face}の@code{:slant}属性にたいして@var{italic-p}が@code{nil}なら@var{normal}、それ以外なら@var{italic}をセットする。
@end defun

@deffn Command set-face-underline face underline &optional frame
これは@var{face}の@code{:underline}属性に@var{underline}をセットする。
@end deffn

@deffn Command set-face-inverse-video face inverse-video-p &optional frame
これは@var{face}の@code{:inverse-video}属性に@var{inverse-video-p}をセットする。
@end deffn

@deffn Command invert-face face &optional frame
これはフェイス@var{face}のフォアグラウンドカラーとバックグラウンドカラーを交換する。
@end deffn

@deffn Command set-face-extend face extend &optional frame
これは@var{face}の@code{:extend}属性に@var{extend}をセットする。
@end deffn

  以下はフェイスの属性を調べる関数です。これらは主として古いバージョンのEmacsとの互換性のために提供されます。これらにたいして@var{frame}を指定しなければ選択されたフレーム、@code{t}なら新たなフレームにたいするデフォルトデータを参照します。フェイスがその属性にたいして何の値も定義していなければ@code{unspecified}がリターンされます。@var{inherit}が@code{nil}ならそのフェイスにより直接定義された属性だけがリターンされます。@var{inherit}が非@code{nil}ならそのフェイスの@code{:inherit}属性により指定される任意のフェイス、@var{inherit}がフェイスまたはフェイスのリストなら指定された属性が見つかるまでそれらも考慮します。リターンされる値が常に指定された値であることを保証するためには@var{inherit}に値@code{default}を使用してください。

@defun face-font face &optional frame character
この関数はフェイス@var{face}のフォント名をリターンする。

オプション引数@var{frame}が指定されたら、そのフレームの@var{face}のフォント名をリターンする。@var{frame}が省略か@code{nil}なら選択されたフレームを使用する。後者の場合にはオプションの3つ目の引数@var{character}が与えられると、@var{character}にたいして使用されるフォント名をリターンする。
@end defun

@defun face-foreground face &optional frame inherit
@defunx face-background face &optional frame inherit
これらの関数はそれぞれフェイス@var{face}のフォアグラウンドカラーまたはバックグラウンドカラーを文字列としてリターンする。カラーが未指定ならをリターンする。
@end defun

@defun face-stipple face &optional frame inherit
この関数はフェイス@var{face}のバックグラウンド点描パターンの名前、もしなければ@code{nil}をリターンする。
@end defun

@defun face-bold-p face &optional frame inherit
この関数は@var{face}の@code{:weight}属性がnormalよりbold寄り(@code{semi-bold}、@code{bold}、@code{extra-bold}、@code{ultra-bold}のいずれか)なら非@code{nil}、それ以外なら@code{nil}をリターンする。
@end defun

@defun face-italic-p face &optional frame inherit
この関数は@var{face}の@code{:slant}属性が@code{italic}か@code{oblique}なら非@code{nil}、それ以外なら@code{nil}をリターンする。
@end defun

@defun face-underline-p face &optional frame inherit
この関数はフェイス@var{face}が非@code{nil}の@code{:underline}属性を指定すれば非@code{nil}をリターンする。
@end defun

@defun face-inverse-video-p face &optional frame inherit
この関数はフェイス@var{face}が非@code{nil}の@code{:inverse-video}属性を指定すれば非@code{nil}をリターンする。
@end defun

@defun face-extend-p face &optional frame
この関数はフェイス@var{face}が非@code{nil}の@code{:extend}属性を指定すれば非@code{nil}をリターンする。
@end defun


@node Displaying Faces
@subsection フェイスの表示
@cindex displaying faces
@cindex face merging

  Emacsが与えられたテキスト断片を表示する際には、そのテキストの視覚的外観は異なるソースから描画されるフェイスにより決定されるかもしれません。これら種々のソースが特定の文字にいたいして複数のフェイスを指定する場合には、Emacsはそれらのさまざまなフェイスの属性をマージします。以下にEmacsがフェイスをマージする順序を優先度順に記します:

@itemize @bullet
@item
そのテキストが特別なグリフで構成される場合には、そのグリフは特定のフェイスを指定できる。@ref{Glyphs}を参照のこと。

@item
アクティブなリージョンにテキストがある場合には、Emacsは@code{region}フェイスを使用してそれをハイライトする。@ref{Standard
Faces,,, emacs, The GNU Emacs Manual}を参照のこと。

@item
非@code{nil}の@code{face}属性をもつオーバーレイにテキストがある場合には、Emacsはそのプロパティにより指定されるフェイス(1つ以上)を適用する。そのオーバーレイが@code{mouse-face}プロパティをもち、マウスがそのオーバーレイに十分に近ければEmacsはかわりに@code{mouse-face}で指定されるフェイスかフェイス属性を適用する。@ref{Overlay
Properties}を参照のこと。

1つの文字を複数のオーバーレイがカバーする場合には、高優先度のオーバーレイが低優先度のオーバーレイをオーバーライドする。@ref{Overlays}を参照のこと。

@item
そのテキストが@code{face}や@code{mouse-face}プロパティを含む場合には、Emacsは指定されたフェイスやフェイス属性を適用する。@ref{Special
Properties}を参照のこと(これはFont Lockモードのフェイス適用方法。@ref{Font Lock Mode}を参照)。

@item
そのテキストが選択されたウィンドウのモードラインにある場合には、Emacsは@code{mode-line}フェイスを適用する。選択されていないウィンドウのモードラインではEmacsは@code{mode-line-inactive}フェイスを使用する。ヘッダーラインにたいしてはEmacsは@code{header-line}フェイスを適用する。タブラインにたいしては、Emacsは@code{tab-line}フェイスを適用する。

@item
@code{before-string}や@code{after-string}プロパティを介したオーバーレイ文字列(@ref{Overlay
Properties}を参照)、あるいはディスプレイ文字列(@ref{Other Display
Specs}を参照)に由来するテキストであり、かつ文字列に@code{face}や@code{mouse-face}のプロパティが含まれない、またはそれらのプロパィが何らかのフェイス属性を未定義のままにしているが、バッファーのテキストがフェイスを定義するディスプレイプロパティやオーバーレイプロパティの影響を受ける場合には、Emacsは``基礎''にあるバッファーテキストのフェイスやフェイス属性を適用する。これはたとえオーバーレイ文字列やディスプレイ文字列がマージン内に表示されている場合も同様であることに注意(@ref{Display
Margins}を参照)。

@item
先行ステップの間に与えられた属性が指定されなければ、Emacsは@code{default}フェイスの属性を適用する。
@end itemize

  各ステージにおいてフェイスが有効な@code{:inherit}属性をもつ場合には、Emacsは値@code{unspecified}をもつすべての属性が、親フェイス(1つ以上)由来で描画に使用される対応する値をもつものとして扱います。@ref{Face
Attributes}を参照してください。親フェイスでも属性がunspecifiedのままかもしれないことに注意してください。その場合にはフェイスマージの次レベルでもその属性はunspecifiedのままです。

@node Face Remapping
@subsection フェイスのリマップ
@cindex face remapping

  変数@code{face-remapping-alist}はあるフェイスの外観のバッファーローカル、またはグローバルな変更にたいして使用されます。たとえばこれは@code{text-scale-adjust}コマンド(@ref{Text
Scale,,, emacs, The GNU Emacs Manual}を参照)の実装に使用されています。

@defvar face-remapping-alist
この変数の値は要素が@code{(@var{face}
.
@var{remapping})}という形式をもつalist。これによりEmacsはフェイス@var{face}をもつ任意のテキストを、通常の@var{face}の定義ではなく@var{remapping}で表示する。

@var{remapping}にはテキストプロパティ@code{face}にたいして適切な任意のフェイスspec、すなわちフェイス(フェイス名か属性/値ペアーのプロパティリスト)、またはフェイスのリストのいずれかを指定できる。詳細は@ref{Special
Properties}の@code{face}テキストプロパティの記述を参照のこと。@var{remapping}はリマップされるフェイスにたいる完全な仕様としての役目をもつ。これは通常の@var{face}を変更せずに置き換える。

@code{face-remapping-alist}がバッファーローカルなら、そのローカル値はそのバッファーだけに効果をもつ。@w{@code{(:filtered
(:window @var{param} @var{val})
@var{spec})}}を使用することにより特定のウィンドウだけに適用されるフェイスを含んだ@code{face-remapping-alist}では、そのフェイスはそのフィルター条件にマッチするだけに効果を及ぼす(@ref{Special
Properties}を参照)。フェイスのフィルタリングを一時的にオフにするには、@code{face-filters-always-match}を非@code{nil}値にバインドすれば、すべてのフェイスフィルターは任意のウィンドウにマッチする。

注意:
フェイスのリマッピングは再帰的ではない。@var{remapping}が同じフェイス名@var{face}を参照する場合には、直接または@var{remapping}内の他の何らかのフェイスの@code{:inherit}属性を通じて、その参照は@var{face}の通常の定義を使用する。たとえば@code{mode-line}フェイスが@code{face-remapping-alist}内の以下のエントリーでリマップされるなら:

@example
(mode-line italic mode-line)
@end example

@noindent
@code{mode-line}フェイスの新たな定義は@code{italic}フェイス、および(リマップされていない)@emph{通常}の@code{mode-line}フェイスの定義から継承される。
@end defvar

@cindex relative remapping, faces
@cindex base remapping, faces
  以下の関数は@code{face-remapping-alist}にたいする高レベルなインターフェースを実装します。ほとんどのLispコードはリマッピングが他の場所に適用されてしまうのを避けるために、@code{face-remapping-alist}を直接セットするのではなくこれらの関数を使用するべきです。これらの関数はバッファーローカルなリマッピングを意図しており、すべてが副作用として@code{face-remapping-alist}をバッファーローカルにします。これらは以下の形式の@code{face-remapping-alist}エントリーを管理します

@example
  (@var{face} @var{relative-spec-1} @var{relative-spec-2} @var{...} @var{base-spec})
@end example

@noindent
上述したように@var{relative-spec-N}と@var{base-spec}はそれぞれフェイス名か属性/値ペアーのプロパティリストです。@dfn{相対的リマッピング(relative
remapping)}エントリー@var{relative-spec-N}はそれぞれ関数@code{face-remap-add-relative}と@code{face-remap-remove-relative}により管理されます。これらはテキストサイズ変更のような単純な変更を意図しています。@dfn{ベースリマッピング(base
remapping)}エントリー@var{base-spec}は最低の優先度をもち、関数@code{face-remap-set-base}と@code{face-remap-reset-base}により管理されます。これはメジャーモードが制御下のバッファーでフェイスをリマップするために用いることを意図しています。

@defun face-remap-add-relative face &rest specs
この関数はカレントバッファー内のフェイス@var{face}にたいして、相対的リマッピングとして@var{specs}内にフェイスspecを追加する。残りの引数@var{specs}はフェイス名のリスト、または属性/値ペアーのプロパティリストのいずれかの形式であること。

リターン値はcookieとしての役目をもつLispオブジェクト。後でそのリマッピングの削除を要する場合には、引数として@code{face-remap-remove-relative}にこのオブジェクトを渡すことができる。

@example
;; 'escape-glyph'フェイスを'highlight'と'italic'
;; を組み合わせたフェイスにリマップする
(face-remap-add-relative 'escape-glyph 'highlight 'italic)

;; 'default'フェイスのサイズを50%増加:
(face-remap-add-relative 'default :height 1.5)
@end example
@end defun

@defun face-remap-remove-relative cookie
この関数は以前@code{face-remap-add-relative}で追加された相対的リマッピングを削除する。@var{cookie}はリマッピングが追加されたときに@code{face-remap-add-relative}がリターンしたLispオブジェクトであること。
@end defun

@defun face-remap-set-base face &rest specs
この関数はカレントバッファー内の@var{face}のベースリマッピングを@var{specs}にセットする。@var{specs}が空なら@code{face-remap-reset-base}(以下参照)を呼び出したようにデフォルトベースリマッピングがリストアされる。これは単一の値@code{nil}を含む@var{specs}とは異なることに注意。これは逆の結果をもたらす(@var{face}のグローバル定義は無視される)。

これはグローバルなフェイス定義を継承したデフォルトの@var{base-spec}を上書きするので、必要ならそのような継承を追加するのは呼び出し側の責任である。
@end defun

@defun face-remap-reset-base face
この関数は@var{face}のベースリマッピングに、@var{face}のグローバル定義から継承したデフォルト値にセットする。
@end defun

@node Face Functions
@subsection フェイスを処理するための関数

  以下はフェイスの作成や処理を行う追加の関数です。

@defun face-list
この関数はすべての定義済みフェイス名のリストをリターンする。
@end defun

@cindex face number
@cindex face property of face symbols
@defun face-id face
この関数はフェイス@var{face}の@dfn{フェイス番号(face
number)}をリターンする。これはEmacs内部の低レベルでフィエスを一意に識別する番号。フェイス番号によるフェイスの参照を要するのは稀である。しかし@code{make-glyph-code}や@code{glyph-face}
(@ref{Glyphs}を参照)のようなグリフを操作する関数は内部的にフェイス番号にアクセスする。フェイス番号はフェイスシンボルの@code{face}プロパティの値として格納されることに注意。このフェイスプロパティにあなた自身が値をセットしないことを推奨する。
@end defun

@defun face-documentation face
この関数はフェイス@var{face}のドキュメント文字列、指定されていなければ@code{nil}をリターンする。
@end defun

@defun face-equal face1 face2 &optional frame
これはフェイス@var{face1}とフェイス@var{face2}が表示にたいして同じ属性をもつなら@code{t}をリターンする。
@end defun

@defun face-differs-from-default-p face &optional frame
これはフェイス@var{face}の表示がデフォルトフェイスと異なるなら非@code{nil}をリターンする。
@end defun

@cindex face alias
@cindex alias, for faces
@dfn{フェイスエイリアス(face
alias)}はあるフェイスにたいして等価な名前を提供します。エイリアスシンボルの@code{face-alias}プロパティに対象となるフェイス名を与えることによってフェイスエイリアスを定義できます。以下の例では@code{mode-line}フェイスにたいするエイリアスとして@code{modeline}を作成します。

@example
(put 'modeline 'face-alias 'mode-line)
@end example

@defmac define-obsolete-face-alias obsolete-face current-face when
このマクロは@var{current-face}のエイリアスとして@code{obsolete-face}を定義するとともに、将来に削除されるかもしれないことを示すためにobsolete(時代遅れ)とマークする。@var{when}は@code{obsolete-face}がobsoleteになる時期を示す文字列であること(通常はバージョン番号文字列)。
@end defmac

@node Auto Faces
@subsection フェイスの自動割り当て
@cindex automatic face assignment
@cindex faces, automatic choice

  以下のフックはバッファー内のテキストに自動的にフェイスを割り当てるために使用されます。これはJit-Lockモードの実装の一部でありFont-Lockにより使用されます。

@defvar fontification-functions
この変数は再表示を行う直前にEmacsの再表示により呼び出される関数のリストを保持する。これらはFont
Lockが有効でないときでも呼び出される。Font
Lockモードが有効なら、この変数は通常は単一の関数@code{jit-lock-function}だけを保持する。

関数はバッファー位置@var{pos}を単一の引数としてリストされた順に呼び出される。これらはカレントバッファー内の@var{pos}で開始されるテキストにたいして集合的にフェイスの割り当てを試みること。

関数は@code{face}プロパティをセットすることにより割り当てるフェイスを記録すること。またフェイスを割り当てたすべてのテキストに非@code{nil}の@code{fontified}プロパティも追加すること。このプロパティは再表示にたいして、そのテキストにたいしてそのフェイスがすでに割り当て済みであることを告げる。

@var{pos}の後の文字がすでに非@code{nil}の@code{fontified}プロパティをもつがフォント表示化を要さない場合には、何も行わない関数を追加するのがおそらくよいアイデアである。ある関数が前の関数による割り当てをオーバーライドする場合には、実際に問題となるのは最後の関数終了後のプロパティである。

効率化のために通常は各呼び出しにおいて400から600前後の文字にフェイスを割り当てるように、これらの関数を記述することを推奨する。
@end defvar

@node Basic Faces
@subsection 基本的なフェイス
@cindex basic faces

テキストにたいしてEmacs
Lispプログラムが何らかのフェイス割り当てを要する場合には、完全に新たなフェイスを定義するより特定の既存フェイス、またはそれらを継承したフェイスを使用するほうがよいアイデアである場合がしばしばあります。Emacsに特定の外観を与えるために別のユーザーが基本フェイス(basic
face)をカスタマイズしていても、この方法なら追加のカスタマイズなしでプログラムは適合することでしょう。

  以下にEmacsが定義する基本フェイスのいくつかをリストしました。これらに加えて、ハイライトがFont
Lockモードによりまだ処理されていなかったり、いくつかのFont Lockフェイスが使用されていなければ、構文的ハイライトのためにFont
Lockフェイスを使うようにしたいと思うかもしれません。@ref{Faces for Font Lock}を参照してください。

@table @code
@item default
属性がすべて指定されたデフォルトフェイス。他のすべてのフェイスは暗にこのフェイスを継承する。未指定(unspecified)な任意の属性は、このフェイスの属性をデフォルトとする(@ref{Face
Attributes}を参照)。

@item bold
@itemx italic
@itemx bold-italic
@itemx underline
@itemx fixed-pitch
@itemx fixed-pitch-serif
@itemx variable-pitch
これらは名前に示されるような属性をもち(@code{bold}はboldの@code{:weight}属性をもつ)、それ以外のすべての属性は未指定(そのために@code{default}により与えられる)。

@item shadow
テキストの淡色表示(dimmed out)用。たとえばこれはミニバッファー内で無視されるファイル名部分に使用される(@ref{Minibuffer
File,, Minibuffers for File Names, emacs, The GNU Emacs Manual}を参照)。

@item link
@itemx link-visited
ユーザーを別のバッファーや位置へと送るクリック可能テキストボタン用。

@item highlight
一時的に強調するべきテキスト範囲用。たとえば一般的にカーソルのハイライトには@code{mouse-face}プロパティが割り当てられる(@ref{Special
Properties}を参照)。

@item match
@itemx isearch
@itemx lazy-highlight
それぞれ定型検索(permanent
search)のマッチ、インタラクティブ検索のマッチ、カレントのインタラクティブな検索のマッチ以外のlazyハイライトにたいするテキスト用。

@item error
@itemx warning
@itemx success
エラー、警告、成功に関するテキスト用。たとえば@file{*Compilation*}内のメッセージにたいして使用される。
@end table

@node Font Selection
@subsection フォントの選択
@cindex font selection
@cindex selecting a font

  Emacsがグラフィカルなディスプレイ上で文字を描画可能になる前に、まずその文字にたいする@dfn{フォント(font)}を選択しなければなりません@footnote{このコンテキストでは用語@dfn{font}はFont
Lock(@ref{Font Lock Mode}を参照)にたいして何も行いません。}。@ref{Fonts,,, emacs, The GNU
Emacs
Manual}を参照してください。Emacsは通常はその文字に割り当てられたフェイス、特にフェイス属性@code{:family}、@code{:weight}、@code{:slant}、@code{:width}(@ref{Face
Attributes}を参照)にもとづいて自動的にフォントを選択します。フォントの選択は表示される文字にも依存します。表示できるのは文字セットが限定されているフォントもいくつかあります。利用可能なフォントがこの要件を完全に満たさなければEmacsは@dfn{もっとも近いフォント(closest
matching font)}を探します。このセクション内の変数はEmacsがこの選択を行う方法を制御します。

@defopt face-font-family-alternatives
あるfamilyが指定されたが存在しなければ、この変数は試みるべき代替えのフォントファミリーを指定する。各要素は以下の形式をもつ:

@example
(@var{family} @var{alternate-families}@dots{})
@end example

@var{family}が指定されたが利用できなければ、Emacsは@var{alternate-families}で与えられるファミリーで存在するものが見つかるまで1つずつファミリーを試みる。
@end defopt

@defopt face-font-selection-order
希望するすべてのフェイス属性(@code{:width}、@code{:height}、@code{:weight}、@code{:slant})に完全にマッチするフォントが存在しなければ、この変数はもっとも近いフォントの選択時に考慮すべきこれらの属性の順序を指定する。値はこれらの属性シンボルを重要度降順で含むリストであること。デフォルトは@code{(:width
:height :weight :slant)}。

フォント選択はまずこのリスト内の最初の属性にたいして利用可能な最適マッチを探す。その後に、この方法で最適なフォントの中から2つ目の属性にたいして最適なマッチを検索、...のように選択を行う。

属性@code{:weight}と@code{:width}は@code{normal}を中心とする範囲のようなシンボリック値をもつ。より極端(@code{normal}から離れた)なマッチは、より極端ではない(@code{normal}に近い)マッチより幾分優先される。これは可能なかぎり非normalなフェイスが、normalなフェイスとは対照的になることを保証するようにデザインされている。

この変数が違いを生むケースの例はデフォルトフォントに等価なイタリックがない場合である。デフォルトの順では@code{italic}フェイスはデフォルトのフォントに類似した非イタリックのフォントを使用するだろう。しかし@code{:height}の前に@code{:slant}を配置すると、@code{italic}フェイスはたとえheightが同じでなくともイタリックフォントを使用するだろう。
@end defopt

@defopt face-font-registry-alternatives
この変数はregistryが指定されたがそれが存在しない場合に試みるべき代替えのフォントレジストリーを指定する。各要素は以下の形式をもつ:

@example
(@var{registry} @var{alternate-registries}@dots{})
@end example

@var{registry}が指定されたが利用できなければ、Emacsは@var{alternate-registries}内で存在するレジストリーが見つかるまで他のレジストリーを1つずつ試みる。
@end defopt

@cindex scalable fonts
  Emacsがスケーラブルフォントを使用するようにできますがデフォルトではそれらを使用しないようになっています。

@defopt scalable-fonts-allowed
この変数はどのスケーラブルフォントを使用するかを制御する。値@code{nil}
(デフォルト)はスケーラブルフォントを使用しないことを意味する。@code{t}はそのテキストにたいして適切と思われる任意のスケーラブルフォントを使用することを意味する。

それ以外なら値は正規表現のリストであること。その場合には名前がこのリスト内の正規表現にマッチする任意のスケーラブルフォントの使用が有効になる。たとえば、

@example
(setq scalable-fonts-allowed '("iso10646-1$"))
@end example

@noindent
これはレジストリーが@code{iso10646-1}のようなスケーラブルフォントの使用を可能にする。
@end defopt

@defvar face-font-rescale-alist
この変数は特定のフォントにたいするスケーリングを指定する。値は以下の形式の要素をもつリストであること

@example
(@var{fontname-regexp} . @var{scale-factor})
@end example

使用しようとするフォントの名前が@var{fontname-regexp}にマッチする場合には、これはファクター@var{scale-factor}に対応した同様な大きさのフォントの選択を指示する。特定のフォントが提示する通常のheightやwidthが大きい、または小さい場合にフォントサイズを正規化するためにこの機能を使用できるだろう。
@end defvar

@node Font Lookup
@subsection フォントの照会
@cindex font lookup
@cindex looking up fonts

@defun x-list-fonts name &optional reference-face frame maximum width
この関数は@var{name}にマッチする利用可能なフォント名のリストをリターンする。@var{name}はFontconfig、GTK+、またはXLFDのいずれかのフォーマットによるフォント名を含む文字列であること(@ref{Fonts,,,
emacs, The GNU Emacs
Manual}を参照)。XLFD文字列ではワイルドカード文字が使用できる。@samp{*}文字は任意の部分文字列、@samp{?}は任意の単一文字にマッチする。フォント名のマッチングではcase(大文字小文字)の違いは無視される。

オプション引数@var{reference-face}と@var{frame}が指定された場合には、リターンされるリストにはその時点でフレーム@var{frame}上での@var{reference-face}
(フェイス名)と同じサイズのフォントだけが含まれる。

オプション引数@var{maximum}はリターンされるフォント数の制限をセットする。これが非@code{nil}ならリターン値は最初にマッチした@var{maximum}個のフォントの後が切り捨てられる。@var{maximum}に小さい値を指定すれば、そのパターンに多くのフォントがマッチするような場合に関数をより高速にできる。

オプション引数@var{width}は希望するフォントの幅を指定する。これが非@code{nil}なら、この関数は文字の幅(平均)が@var{reference-face}の@var{width}倍の幅であるようなフォントだけをリターンする。
@end defun

@defun x-family-fonts &optional family frame
この関数は@var{frame}上のファミリー@var{family}にたいして利用可能なフォントを記述するリストをリターンする。@var{family}が省略か@code{nil}ならこのリストはすべてのファミリーに適用されて、それはすなわち利用可能なすべてのフォントを含む。それ以外なら@var{family}は文字列であること。これにはワイルドカード@samp{?}と@samp{*}を含めることができる。

このリストは@var{frame}のあるディスプレイを記述する。@var{frame}が省略か@code{nil}なら、これは選択されたフレームのディスプレイに適用される(@ref{Input
Focus}を参照)。

このリスト内の各要素は以下の形式のベクターであること:

@example
[@var{family} @var{width} @var{point-size} @var{weight} @var{slant}
 @var{fixed-p} @var{full} @var{registry-and-encoding}]
@end example

最初の5つの要素はフェイス属性に対応する。あるフェイスにたいしてこれらの属性を指定した場合には、そのフォントが使用されるだろう。

最後の3つの要素は、そのフォントに関する追加の情報を与える。そのフォントが固定ピッチ(fixed-pitch)でなければ@var{fixed-p}は非@code{nil}。@var{full}はそのフォントのフルネーム、@var{registry-and-encoding}はそのフォントのレジストリーとエンコーディングを与える。
@end defun

@node Fontsets
@subsection フォントセット
@cindex fontset

  @dfn{フォントセット(fontset)}とは、それぞれが文字コードの範囲に割り当てられるフォントのリストのことです。個々のフォントではEmacsがサポートする文字の全範囲を表示できませんが、フォントセットであれば表示することができます。フォントのようにフォントセットは名前をもつことができ、フレームやフェイスにたいしてフォントを指定する際に、フォント名としてフォントセット名を使用できます。以下はLispプログラム制御下でのフォントセット定義に関する情報です。

@defun create-fontset-from-fontset-spec fontset-spec &optional style-variant-p noerror
この関数は仕様文字列@var{fontset-spec}に応じて新たなフォントセットを定義する。この文字列は以下のような形式であること:

@smallexample
@var{fontpattern}, @r{[}@var{charset}:@var{font}@r{]@dots{}}
@end smallexample

@noindent
カンマの前後の空白文字は無視される。

この文字列の最初の部分@var{fontpattern}は、最後の2つのフィールドが@samp{fontset-@var{alias}}であることを除外して標準Xフォント名形式をもつこと。

新たなフォントセットはlong名とshort名という2つの名前をもつ。long名はそれ全体が@var{fontpattern}、short名は@samp{fontset-@var{alias}}。いずれの名前でもこのフォントセットを参照できる。同じ名前がすでに存在するフォントセットでは@var{noerror}が@code{nil}ならエラーがシグナルされ、@var{noerror}が非@code{nil}ならこの関数は何も行わない。

オプション引数@var{style-variant-p}が非@code{nil}なら、そのフォントセットのbold、italic、およびbold-italicも同様に作成するよう指示する。これらの変種フォントセットはshort名をもたずbold、および/またはitalicを示すように@var{fontpattern}を変更して作成したlong名だけをもつ。

仕様文字列はそのフォントセット内でどのフォントを使用するかも宣言する。詳細は以下を参照。
@end defun

  構文@samp{@var{charset}:@var{font}}はある特定の文字セットにたいして、(このフォントセット内の)どのフォントを使用するかを指定します。ここで@var{charset}は文字セットの名前、@var{font}はその文字セットにたいして使用するフォントです。仕様文字列内ではこの構文を任意の回数使用できます。

  明示的に指定しなかった残りの文字セットにたいして、Emacsは@var{fontpattern}にもとづいてフォントを選択します。これは@samp{fontset-@var{alias}}をその文字セットを命名する値に置き換えます。文字セット@acronym{ASCII}にたいしては、@samp{fontset-@var{alias}}は@samp{ISO8859-1}に置き換えられます。

  加えて後続の複数フィールドがワイルドカードなら、Emacsはそれらを1つのワイルドカードにまとめます。これは自動スケールフォント(auto-scaled
fonts)の使用を防ぐためです。フォントを大きくスケーリングすることにより作成されたフォントは編集に使用できず、小さくスケーリングされたフォントは、それ自身のサイズがより小さいフォントを使用する(Emacsが行う方法)ほうがよいので有用ではありません。

  つまり以下のような@var{fontpattern}なら

@example
-*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24
@end example

@noindent
@acronym{ASCII}にたいするフォントspecは以下のようになるでしょう:

@example
-*-fixed-medium-r-normal-*-24-*-ISO8859-1
@end example

@noindent
またChinese GB2312文字にたいするフォントspecは以下のようになるでしょう:

@example
-*-fixed-medium-r-normal-*-24-*-gb2312*-*
@end example

  上記のフォントspecにマッチするChineseフォントをもっていないかもしれません。ほとんどのXディストリビューションには、@var{family}フィールドに@samp{song
ti}か@samp{fangsong
ti}をもつChineseフォントだけが含まれます。そのような場合には以下のように@samp{Fontset-@var{n}}を指定できます:

@smallexample
Emacs.Fontset-0: -*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24,\
        chinese-gb2312:-*-*-medium-r-normal-*-24-*-gb2312*-*
@end smallexample

@noindent
この場合にはChinese
GB2312以外のすべての文にたいするフォントspecは@var{family}フィールドに@samp{fixed}をもち、Chinese
GB2312にたいするフォントspecは@var{family}フィールドにワイルドカード@samp{*}をもちます。

@defun set-fontset-font name character font-spec &optional frame add
この関数は指定された@var{character}にたいして、@var{font-spec}のフォントマッチングを使用するように既存のフォントセット@var{name}を変更する。

@var{name}が@code{nil}ならこの関数は@var{frame}のフォントセット、@var{frame}が@code{nil}なら選択されたフレームのフォントセットを変更する。

@var{name}が@code{t}ならこの関数はshort名が@samp{fontset-default}であるようなデフォルトフォントセットを変更する。

@var{character}には@code{(@var{from}
.
@var{to})}のようなコンスを指定できる。ここで@var{from}と@var{to}は文字コードポイント。この場合には範囲@var{from}から@var{to}
(両端を含む)までのすべての文字にたいして@var{font-spec}を使用する。

@var{character}には文字セット(@ref{Character
Sets}を参照)も指定できる。この場合には、その文字セット内のすべての文字にたいして@var{font-spec}を使用する。

@var{character}にはスクリプト名(@ref{Character Properties,
char-script-table}を参照)も指定できる。この場合にはスクリプトに属するすべての文字にたいして@var{font-spec}を使用する。

@var{character}には@code{nil}も指定できる。この場合にはフォント仕様が指定されていないすべての文字に@var{font-spec}を使用する。

@var{font-spec}は関数@code{font-spec}が作成したfont-specオブジェクトかもしれない(@ref{Low-Level
Font}を参照)。

@var{font-spec}にはコンス@code{(@var{family}
.
@var{registry})}を指定できる。ここで@var{family}はフォントのファミリー名(先頭にfoundry名が含まれるかもしれない)、@var{registry}はフォントのレジストリー名(末尾にエンコーディング名が含まれるかもしれない)。

@var{font-spec}にはフォント名(文字列)も指定できる。

@var{font-spec}には、指定された@var{character}にたいするフォントが存在しないことを明示的に指定する@code{nil}を指定できる。これはたとえばUnicodeのPUA(Private
Use Area)由来のようなグリフをもたない文字のフォントにたいするシステムワイドの高価な検索を避けるために有用。

オプション引数@var{add}が非@code{nil}なら以前セットされたフォントspecに@var{font-spec}を追加する方法を指定する。@code{prepend}なら@var{font-spec}は先頭、@code{append}なら@var{font-spec}は末尾に追加される。デフォルトでは@var{font-spec}は以前のセッティングをオーバーライドする。

たとえば以下は文字セット@code{japanese-jisx0208}に属するすえての文字にたいして、ファミリー名が@samp{Kochi
Gothic}であるようなフォントを使用するようにデフォルトフォントセットを変更する。

@smallexample
(set-fontset-font t 'japanese-jisx0208
                  (font-spec :family "Kochi Gothic"))
@end smallexample
@end defun

@defun char-displayable-p char
This function returns non-@code{nil} if Emacs ought to be able to display
@var{char}.  Or more precisely, if the selected frame's fontset has a font
to display the character set that @var{char} belongs to.

フォントセットは文字単位でフォントを指定できる。フォントセットがこれを行う場合には、この関数の値は正確ではないかもしれない。

この関数はテキスト端末用のコーディングシステムがその文字をエンコード可能かどうかもチェックするので、利用可能なフォントがなくても非@code{nil}をリターンするかもしれない(@ref{Terminal
I/O Encoding}を参照)。
@end defun

@node Low-Level Font
@subsection 低レベルのフォント表現
@cindex font property

  通常はフォントを直接扱う必要はありません。これを行う必要がある場合にはこのセクションでその方法を説明します。

  Emacs Lispではフォントは@dfn{フォントオブジェクト(font objects)}、@dfn{フォントspec(font
specs)}、@dfn{フォントエンティティー(font entities)}という3つの異なるLispオブジェクトを使用して表現されます。

@defun fontp object &optional type
@var{object}がフォントオブジェクト、フォントspec、フォントエンティティーなら@code{t}、それ以外なら@code{nil}をリターンする。

オプション引数@var{type}が非@code{nil}なら、チェックするLispオブジェクトの正確なタイプを決定する。この場合には@var{type}は@code{font-object}、@code{font-spec}、@code{font-entity}のいずれかであること。
@end defun

@cindex font object
  フォントオブジェクトはEmacsが@dfn{オープンした}フォントを表します。Lispでフォントオブジェクトは変更できませんが調べることはできます。

@defun font-at position &optional window string
ウィンドウ@var{window}内の位置@var{position}にある文字を表示するために使用されているフォントオブジェクトをリターンする。@var{window}が@code{nil}の場合のデフォルトは選択されたウィンドウ。@var{string}が@code{nil}なら@var{position}はカレントバッファー内の位置を指定する。それ以外なら@var{string}は文字列、@var{position}はその文字列内での位置を指定すること。
@end defun

@cindex font spec
  フォントspecはフォントを探すために使用できる仕様セットを含むLispオブジェクトです。フォントspec内の仕様にたいして1つ以上のフォントがマッチすることができます。

@defun font-spec &rest arguments
@var{arguments}内の仕様を使用して新たなフォントspecをリターンする。これは@code{property}-@code{value}のペアーであること。可能な仕様は以下のとおり:

@table @code
@item :name
XLFD、Fontconfig、GTK+いずれかのフォーマットによるフォント名(文字列)。@ref{Fonts,,, emacs, The GNU
Emacs Manual}を参照のこと。

@item :family
@itemx :foundry
@itemx :weight
@itemx :slant
@itemx :width
これらは同じ名前のフェイス属性と同じ意味をもつ。@ref{Face
Attributes}を参照のこと。@code{:family}と@code{:foundry}は文字列で、それ以外はシンボル。例の値のように@code{:slant}は@code{italic}、@code{:weight}は@code{bold}、@code{:width}は@code{normal}かもしれない。

@item :size
フォントサイズ。非負の整数はピクセル単位、浮動小数点数ならポイントサイズを指定する。

@item :adstyle
@samp{sans}のような、そのフォントにたいするタイポグラフィックスタイル(typographic
style)の追加情報。値は文字列かシンボルであること。

@cindex font registry
@item :registry
@samp{iso8859-1}のようなフォントの文字セットレジストリーとエンコーディング。値は文字列かシンボルであること。

@item :dpi
フォントがデザインされたインチあたりのドット数による解像度。値は非負の数値でなければならない。

@item :spacing
フォントのスペーシング(proportional, dual, mono, or
charcell)。値は整数(proportionalは0、dualは90、monoは100、charcellは110)、あるいは1文字のシンボル(@code{P}、@code{D}、@code{M}、@code{C})であること。

@item :avgwidth
1/10ピクセル単位でのフォントの平均幅。値は非負の数値であること。

@item :script
そのフォントがサポートしなければならないスクリプト(シンボル)。

@item :lang
そのフォントがサポートするべき言語。値は名前が2文字のISO-639言語名であるようなシンボルであること。Xでは値は(もし空でなければ)フォントのXLFD名の``Additional
Style''フィールドにたいしてマッチされる。MS-Windowsではそのspecにマッチするフォントにはその言語にたいして必要なコードページのサポートが要求される。現在のところこのプロパティでは@samp{ja}、@samp{ko}、@samp{zh}というCJK言語の小セットだけがサポートされる。

@item :otf
@cindex OpenType font
複雑なテキストレイアウトを必要とするスクリプトをサポートするGNU/Linux上の@samp{libotf}のようなライブラリーとともにEmacsがコンパイルされているような場合には、そのフォントはそれらのOpenType機能をサポートするOpenTypeフォントでなければならない。値は以下の形式のリストでなければならない

@smallexample
@code{(@var{script-tag} @var{langsys-tag} @var{gsub} @var{gpos})}
@end smallexample

ここで@var{script-tag}はOpenTypeスクリプトタグシンボル、@var{langsys-tag}はOpenType言語システムタグシンボル(@code{nil}ならデフォルト言語システムを使用)、@code{gsub}はOpenType
GSUB機能タグシンボル(何も要求されなければ@code{nil})、@code{gpos}はOpenType
GPOS機能タグシンボルのリスト(何も要求されなければ@code{nil})。@code{gsub}や@code{gpos}がリストなら、そのリスト内の@code{nil}要素は、そのフォントが残りすべてのタグシンボルにマッチしてはならないことを意味する。@code{gpos}は省略可。
@end table
@end defun

@defun font-put font-spec property value
フォントspec @var{font-spec}内のプロパティ@var{property}に@var{value}をセットする。
@end defun

@cindex font entity
  フォントエンティティーはオープンする必要がないフォントへの参照です。フォントオブジェクトとフォントspecの中間的な性質をもちフォントspecとは異なり、フォントオブジェクトと同じように単一かつ特定のフォントを参照します。フォントオブジェクトとは異なりフォントエンティティーの作成では、そのフォントのコンテンツはコンピューターへのメモリーにロードされません。Emacsはスケーラブルフォントを参照するために単一のフォントエンティティーから複数の異なるサイズのフォントオブジェクトをオープンするかもしれません。

@defun find-font font-spec &optional frame
この関数はフレーム@var{frame}上のフォントspec
@var{font-spec}にもっともマッチするフォントエンティティーをリターンする。@var{frame}が@code{nil}の場合のデフォルトは選択されたフレーム。
@end defun

@defun list-fonts font-spec &optional frame num prefer
この関数はフォントspec @var{font-spec}にマッチするすべてのフォントエンティティーのリストをリターンする。

オプション引数@var{frame}が非@code{nil}なら、そのフォントが表示されるフレームを指定する。オプション引数@var{num}が非@code{nil}なら、それはリターンされるリストの最大長を指定する整数だること。オプション引数@var{prefer}が非@code{nil}なら、それはリターンされるリスト順を制御するために使用する別のフォントspecであること。リターンされるフォントspecはそのフォントspecにもっとも近い降順にソートされて格納される。
@end defun

  @code{:font}属性の値としてフォントspec、フォントエンティティー、フォント名文字列を渡して@code{set-face-attribute}を呼び出すと、Emacsは表示に利用可能なもっともマッチするフォントをオープンします。そしてそのフェイスにたいする@code{:font}属性の実際の値として、対応するフォントオブジェクトを格納します。

  以下の関数はフォントに関する情報を取得するために使用できます。これらの関数の@var{font}引数にはフォントオブジェクト、フォントエンティティー、またはフォントspecを指定できます。

@defun font-get font property
この関数は@var{font}にたいするフォントプロパティ@var{property}の値をリターンする。

@var{font}がフォントspecであり、そのフォントspecが@var{property}を指定しなければリターン値は@code{nil}。@var{font}がフォントオブジェクトかフォントエンティティーなら、@var{:script}プロパティにたいする値はそのフォントがサポートするスクリプトのリストかもしれない。
@end defun

@defun font-face-attributes font &optional frame
この関数は@var{font}に対応するフェイス属性のリストをリターンする。オプション引数@var{frame}はフォントが表示されるフレームを指定する。これが@code{nil}なら選択されたフレームが使用される。リターン値は以下の形式

@smallexample
(:family @var{family} :height @var{height} :weight @var{weight}
   :slant @var{slant} :width @var{width})
@end smallexample

ここで@var{family}、@var{height}、@var{weight}、@var{slant}、@var{width}の値はフェイス属性の値。@var{font}により指定されない場合には、いくつかのキー/属性ペアーはこのリストから省略されるかもしれない。
@end defun

@defun font-xlfd-name font &optional fold-wildcards
この関数は@var{font}にマッチするXLFD((X Logical Font
Descriptor))を文字列としてリターンする。XLFDに関する情報は@ref{Fonts,,, emacs, The GNU Emacs
Manual}を参照のこと。その名前がXLFD(最大255文字を含むことが可能)にたいして長すぎれば、この関数は@code{nil}をリターンする。

オプション引数@var{fold-wildcards}が非@code{nil}なら連続するワイルドカードは1つにまとめられる。
@end defun

以下の2つの関数はフォントに関して重要な情報をリターンします。

@defun font-info name &optional frame
この関数は@var{frame}で使用されるような文字列@var{name}で指定されたフォントに関する情報をリターンする。@var{frame}が省略か@code{nil}の場合のデフォルトは選択されたフレーム。

この関数は@code{[@var{opened-name} @var{full-name} @var{size} @var{height}
@var{baseline-offset} @var{relative-compose} @var{default-ascent}
@var{max-width} @var{ascent} @var{descent} @var{space-width}
@var{average-width} @var{filename}
@var{capability}]}という形式のベクターによる値をリターンする。以下はこのベクターの各コンポーネントの意味:

@table @var
@item opened-name
フォントのオープンに使用された名前(文字列)。

@item full-name
フォントの完全名(文字列)。

@item size
フォントのピクセルサイズ。

@item height
フォント高さ(ピクセル単位)。

@item baseline-offset
@acronym{ASCII}ベースラインからのピクセル単位のオフセット(上方が正)。

@item relative-compose
@itemx default-ascent
文字の組み合わせ(compose)の方式を制御する数値。

@item max-width
フォントの最大のアドバンス幅。

@item ascent
@itemx descent
このフォントのアセント(ascent)とディセント(descent)。これら2つの数値の合計は上述の@var{height}と等しくなること。

@item space-width
そのフォントのスペース文字の幅(ピクセル単位)。

@item average-width
そのフォントの文字の平均幅。これが0ならEmacsは表示のテキストレイアウト計算時にかわりに@var{space-width}の値を使用する。

@item filename
フォントのファイル名(文字列)。フォントのバックエンドがフォントのファイル名を見つける手段を提供しなければ@code{nil}もあり得る。

@item capability
最初の要素がフォントタイプを表す@code{x}、@code{opentype}、@code{truetype}、@code{type1}、@code{pcf}、@code{bdf}のいずれかのシンボルであるようなリスト。OpenTypeフォントでは、フォントによりサポートされる機能@sc{gsub}と@sc{gpos}の2つの要素が含まれる。これらの要素はそれぞれ@code{((@var{script}
(@var{langsys} @var{feature} @dots{}) @dots{})
@dots{})}という形式のリストであり、ここで@var{script}はOpenTypeのscriptタグを表すシンボル、@var{langsys}はOpenTypeのlangsysタグを表すシンボル(またはデフォルトのlangsysを表す@code{nil})、そよび@var{feature}はそれぞれOpenTypeのfeatureタグを表す。
@end table
@end defun

@defun query-font font-object
この関数は@var{font-object}に関する情報をリターンする(これは引数としてフォント名を文字列で受け取る@code{font-info}とは対照的)。

この関数は@code{[@var{name} @var{filename} @var{pixel-size} @var{max-width}
@var{ascent} @var{descent} @var{space-width} @var{average-width}
@var{capability}]}という形式のベクターで値をリターンする。以下はこのベクターの各要素の意味:

@table @var
@item name
フォント名(文字列)。

@item filename
フォントのファイル名(文字列)。フォントのバックエンドがフォントのファイル名を見つける手段を提供しなければ@code{nil}もあり得る。

@item pixel-size
フォントをオープンするために使用されたフォントのピクセルサイズ。

@item max-width
フォントの最大のアドバンス幅。

@item ascent
@itemx descent
このフォントのアセント(ascent)とディセント(descent)。これら2つの数値の合計はフォントの高さを与える。

@item space-width
そのフォントのスペース文字の幅(ピクセル単位)。

@item average-width
そのフォントの文字の平均幅。これが0ならEmacsは表示のテキストレイアウト計算時にかわりに@var{space-width}の値を使用する。

@item capability
最初の要素がフォントタイプを表す@code{x}、@code{opentype}、@code{truetype}、@code{type1}、@code{pcf}、@code{bdf}のいずれかのシンボルであるようなリスト。OpenTypeフォントでは、フォントによりサポートされる機能@sc{gsub}と@sc{gpos}の2つの要素が含まれる。これらの要素はそれぞれ@code{((@var{script}
(@var{langsys} @var{feature} @dots{}) @dots{})
@dots{})}という形式のリストであり、ここで@var{script}はOpenTypeのscriptタグを表すシンボル、@var{langsys}はOpenTypeのlangsysタグを表すシンボル(またはデフォルトのlangsysを表す@code{nil})、そよび@var{feature}はそれぞれOpenTypeのfeatureタグを表す。
@end table
@end defun

@cindex font information for layout
以下の4つの関数はさまざまなフェイスにより使用されるフォントに関するサイズ情報をリターンして、Lispプログラム内でのさまざまなレイアウトの検討を可能にします。これらの関数は問い合わせられたフェイスがリマップされていたら、リマップされたフェイスに関する情報をリターンすることによりフェイスのシマップを考慮します。@ref{Face
Remapping}を参照してください。

@defun default-font-width
カレントバッファーの選択されたフレームにたいして定義されたデフォルトフェイスで使用されるフォントの平均幅をピクセル単位でリターンする。
@end defun

@defun default-font-height
この関数は選択されたフレームにたいして定義されたカレントバッファーのデフォルトフェイスで使用されるフォントの高さをピクセル単位でリターンする。
@end defun

@defun window-font-width &optional window face
この関数は@var{window}内の@var{face}で使用されるフォントの平均幅をピクセル単位でリターンする。@var{window}には生きたウィンドウを指定しなければならない。@code{nil}か省略なら@var{window}のデフォルトは選択されたウィンドウ、@var{face}のデフォルトは@var{window}内のデフォルトフェイス。
@end defun

@defun window-font-height &optional window face
この関数は@var{window}内の@var{face}で使用されるフォントの高さをピクセル単位でリターンする。@var{window}には生きたウィンドウを指定しなければならない。@code{nil}か省略なら@var{window}のデフォルトは選択されたウィンドウ、@var{face}のデフォルトは@var{window}内のデフォルトフェイス。
@end defun

@node Fringes
@section フリンジ
@cindex fringes

  グラフィカルなディスプレイではEmacsは各ウィンドウに隣接して@dfn{フリンジ(fringes)}を描画します。これは切り詰め(truncation)、継続(continuation)、水平スクロールを示すビットマップを表示できる側面の細い垂直ストリップです。

@menu
* Fringe Size/Pos::          ウィンドウフリンジの配置場所を指定する。
* Fringe Indicators::        ウィンドウフリンジ内にインジケーターアイコンを表示する。
* Fringe Cursors::           右フリンジ内にカーソルを表示する。
* Fringe Bitmaps::           フリンジインジケーターにたいしてビットマップを指定する。
* Customizing Bitmaps::      フリンジ内で使用する独自ビットマップの指定。
* Overlay Arrow::            位置を示す矢印の表示。
@end menu

@node Fringe Size/Pos
@subsection フリンジのサイズと位置

  以下のバッファーローカル変数はバッファーを表示するウィンドウのフリンジの位置と幅を制御します。

@defvar fringes-outside-margins
フリンジは通常はディスプレイマージンとウィンドウテキストの間に表示される。この値が非@code{nil}ならフリンジはディスプレイマージンの外側に表示される。@ref{Display
Margins}を参照のこと。
@end defvar

@defvar left-fringe-width
この変数が非@code{nil}なら、それは左フリンジの幅をピクセル単位で指定する。値@code{nil}はそのウィンドウのフレームの左フリンジ幅を使用することを意味する。
@end defvar

@defvar right-fringe-width
この変数が非@code{nil}なら、それは右フリンジの幅をピクセル単位で指定する。値@code{nil}はそのウィンドウのフレームの右フリンジ幅を使用することを意味する。
@end defvar

  これらの変数にたいして値を指定しないすべてのバッファーは、フレームパラメーター@code{left-fringe}および@code{right-fringe}で指定された値を使用します(@ref{Layout
Parameters}を参照)。

  上記の変数はサブルーチンとして@code{set-window-fringes}を呼び出す関数@code{set-window-buffer}
(@ref{Buffers and
Windows}を参照)を通じて実際に効果をもちます。これらの変数のいずれかを変更しても影響を受ける各ウィンドウで@code{set-window-buffer}を呼び出さなければ、そのバッファーを表示する既存のウィンドウのフリンジ表示は更新されません。個別のウィンドウでのフリンジ表示を制御するために@code{set-window-fringes}を使用することもできます。

@defun set-window-fringes window left &optional right outside-margins persistent
この関数はウィンドウ@var{window}のフリンジ幅をセットする。@var{window}が@code{nil}なら選択されたウィンドウが使用される。

引数@var{left}は左フリンジ、同様に@var{right}は右フリンジにたいしてピクセル単位で幅を指定する。いずれかにたいする値@code{nil}はデフォルトの幅を意味する。@var{outside-margins}が非@code{nil}ならフリンジをディスプレイマージンの外側に表示することを指定する。

期待する幅のフリンジを収容するのに@var{window}が十分大きくなければ、@var{window}のフリンジは未変更のままになる。

ここで指定した値は、@var{window}にたいして@var{keep-margins}を@code{nil}か省略した@code{set-window-buffer}
(@ref{Buffers and
Windows}を参照)の呼び出しによって後刻オーバーライドされるかもしれない。しかしオプションの5つ目の引数@var{persistent}が非@code{nil}、かつ他の引数が成功裏に処理されたら、ここで指定した値は後続の@code{set-window-buffer}呼び出しに引き継がれる。これはミニバッファーウィンドウでフリンジを永続的にオフにするために使用できる。例は@code{set-window-scroll-bars}
(@ref{Scroll Bars}を参照)の説明を参照のこと。
@end defun

@defun window-fringes &optional window
この関数はウィンドウ@var{window}のフリンジに関する情報をリターンする。@var{window}が省略か@code{nil}なら選択されたウィンドウが使用される。値は@code{(@var{left-width}
@var{right-width} @var{outside-margins} @var{persistent})}という形式。
@end defun


@node Fringe Indicators
@subsection フリンジのインジケーター
@cindex fringe indicators
@cindex indicators, fringe

  @dfn{フリンジインジケーター(Fringe
indicators)}は行の切り詰めや継続、バッファー境界などを示すウィンドウフリンジ内に表示される小さいアイコンのことです。

@defopt indicate-empty-lines
@cindex fringes, and empty line indication
@cindex empty lines, indicating
これが非@code{nil}ならEmacsはグラフィカルなディスプレイ上で、バッファー終端にある空行それぞれにたいしてフリンジ内に特別なグリフを表示する。@ref{Fringes}を参照のこと。この変数はすべてのバッファーにおいて自動的にバッファーローカルになる。
@end defopt

@defopt indicate-buffer-boundaries
@cindex buffer boundaries, indicating
このバッファーローカル変数はウィンドウフリンジ内でバッファー境界とウィンドウのスクロールを示す方法を制御する。

Emacsはバッファー境界(そのバッファーの最初の行と最後の行)がスクリーン上に表示された際には、それを三角アイコン(angle
icon)で示すことができる。加えてスクリーンより上にテキストが存在すれば上矢印(up-arrow)、スクリーンの下にテキストが存在すれば下矢印(down-arrow)をフリンジ内に表示してそれを示すことができる。

基本的な値として3つの値がある:

@table @asis
@item @code{nil}
これらのフリンジアイコンを何も表示しない。
@item @code{left}
左フリンジに三角アイコンと矢印を表示する。
@item @code{right}
右フリンジに三角アイコンと矢印を表示する。
@item その他の非alist
左フリンジに三角アイコンを表示して矢印を表示しない。
@end table

値がそれ以外ならどのフリンジインジケーターをどこに表示するかを指定するalistであること。alistの各要素は@code{(@var{indicator}
.
@var{position})}のような形式をもつ。ここで@var{indicator}は@code{top}、@code{bottom}、@code{up}、@code{down}、または@code{t}
(指定されていないすべてのアイコンをカバーする)のいずれかであり@var{position}は@code{left}、@code{right}、または@code{nil}のいずれか。

たとえば@code{((top . left) (t . right))}は左フリンジにtop angleビットマップを、右フリンジにbottom
angleビットマップと両arrowビットマップを配置する。左フリンジにangleビットマップを表示してarrowビットマップを表示しないようにするには@code{((top
.  left) (bottom . left))}を使用する。
@end defopt

@defvar fringe-indicator-alist
このバッファーローカル変数は論理的ロジカルフリンジインジケーターから、ウィンドウフリンジ内に実際に表示されるビットマップへのマッピングを指定する。値は@code{(@var{indicator}
.
@var{bitmaps})}のような要素をもつalist。ここで@var{indicator}は論理的インジケータータイプ、@var{bitmaps}はそのインジケーターに使用するフリンジビットマップを指定する。

  @var{indicator}はそれぞれ以下のシンボルのいずれかであること:

@table @asis
@item @code{truncation}、@code{continuation}。
行の切り詰めと継続に使用される。

@item @code{up}、@code{down}、@code{top}、@code{bottom}、@code{top-bottom}
@code{indicate-buffer-boundaries}が非@code{nil}の際に使用される。@code{up}と@code{down}は、そのウィンドウ端より上と下にあるバッファー境界を示す。@code{top}と@code{bottom}はバッファーの最上端と最下端のテキスト行を示す。@code{top-bottom}はバッファー内にテキスト行1行だけが存在することを示す。

@item @code{empty-line}
@code{indicate-empty-lines}が非@code{nil}の際に、バッファーの後の空行を示すために使用される。

@item @code{overlay-arrow}
@c Is this used anywhere?
@c @item Unknown bitmap indicator:
@c @code{unknown}.
オーバーレイ矢印に使用される(@ref{Overlay Arrow}を参照)。
@end table

  各@var{bitmaps}の値にはシンボルのリスト@code{(@var{left} @var{right} [@var{left1}
@var{right1}])}を指定できる。シンボル@var{left}と@var{right}は特定のインジケーターにたいして左および/または右フリンジに表示するビットマップを指定する。@var{left1}と@var{right1}はインジケーター@code{bottom}と@code{top-bottom}に固有であり、最後の改行をもたない最後のテキスト行を示すために使用される。かわりに@var{bitmaps}に左フリンジと右フリンジの両方で使用される単一のシンボルを指定することもできる。

  標準のビットマップシンボルのリストと自身で定義する方法については@ref{Fringe
Bitmaps}を参照のこと。加えて@code{nil}は空ビットマップ(表示されないインジケーター)を表す。

  @code{fringe-indicator-alist}がバッファーローカルな値をもち、論理的インジケーターにたいしてビットマップが定義されていないかビットマップが@code{t}ならば、@code{fringe-indicator-alist}のデフォルト値から対応する値が使用される。
@end defvar

@node Fringe Cursors
@subsection フリンジのカーソルFrin
@cindex fringe cursors
@cindex cursor, fringe

  ある行がウィンドウと正確に同じ幅なとき、2行を使用するかわりにEmacsは右フリンジ内にカーソルを表示します。フリンジ内のカーソルを表すために使用されるビットマップの違いはカレントバッファーのカーソルタイプに依存します。

@defopt overflow-newline-into-fringe
これが非@code{nil}なら、ウィンドウと正確に同じ幅の(最後の改行文字に継続されない)行は継続されない。ポイントが行端に達した際には、カーソルはかわりに右フリンジに表示される。
@end defopt

@defvar fringe-cursor-alist
この変数は論理的カーソルタイプから、右フリンジ内に実際に表示されるフリンジビットマップへのマッピングを指定する。値は各要素が@code{(@var{cursor-type}
.
@var{bitmap})}のような形式をもつようなalist。ここで@var{bitmap}は使用するフリンジビットマップ、@var{cursor-type}は表示するカーソルタイプ。

@var{cursor-type}はそれぞれ@code{box}、@code{hollow}、@code{bar}、@code{hbar}、@code{hollow-small}のいずれかであること。最初の4つはフレームパラメーター@code{cursor-type}の場合と同じ意味をもつ(@ref{Cursor
Parameters}を参照)。@code{hollow-small}タイプは特定のディスプレイ行にたいして通常の@code{hollow-rectangle}が高すぎる際に@code{hollow}のかわりに使用される。

@var{bitmap}はそれぞれ、その論理的カーソルタイプにたいして表示されるフリンジビットマップを指定するシンボルであること。
@iftex
詳細は次のサブセクションを参照のこと。
@end iftex
@ifnottex
詳細は@ref{Fringe Bitmaps}を参照のこと。
@end ifnottex

@c FIXME: I can't find the fringes-indicator-alist variable.  Maybe
@c it should be fringe-indicator-alist or fringe-cursor-alist?  --xfq
@code{fringe-cursor-alist}がバッファーローカルな値をもち、カーソルタイプにたいして定義されたビットマップが存在しなければ、@code{fringes-indicator-alist}のデフォルト値の対応する値が使用される。
@end defvar

@node Fringe Bitmaps
@subsection フリンジのビットマップ
@cindex fringe bitmaps
@cindex bitmaps, fringe

  @dfn{フリンジビットマップ(fringe
bitmaps)}は行の切り詰めや継続、バッファー境界、オーバーレイ矢印等にたいする論理的フリンジインジケーターを表現する実際のビットマップです。それぞれのビットマップはシンボルにより表されます。
@iftex
これらのシンボルは前のサブセクションで説明した変数@code{fringe-indicator-alist}と@code{fringe-cursor-alist}から参照されます。
@end iftex
@ifnottex
これらのシンボルはフリンジインジケーターからビットマップへのマッピングを行う変数@code{fringe-indicator-alist}
(@ref{Fringe
Indicators}を参照)、およびフリンジカーソルからビットマップへのマッピングを行う変数@code{fringe-cursor-alist}
(@ref{Fringe Cursors}を参照)から参照されます。
@end ifnottex

  Lispプログラムも行内に出現する文字の1つに@code{display}プロパティを使用することにより、左フリンジまたは右フリンジ内にビットマップを直接表示することができます。そのような表示指定は以下の形式をもちます

@example
(@var{fringe} @var{bitmap} [@var{face}])
@end example

@noindent
@var{fringe}は@code{left-fringe}か@code{right-fringe}いずれかのシンボル、@var{bitmap}は表示するビットマップを識別するシンボルです。オプションの@var{face}はビットマップの表示でフォアグラウンカラーおよびバックグラウンドカラーを使用するフェイスを命名します(
@var{face}が指定しないカラーにたいしては@code{fringe}フェイスの属性を使用する)。@var{face}を省略すると、@code{fringe}が指定しないカラーに@code{default}フェイスの属性を使用することを意味します。@code{default}フェイスや@code{fringe}フェイスの属性に依存しない予測可能な結果を得るために、@var{face}は省略せず常に特定のフェイスを与えることを推奨します。特にビットマップを@code{fringe}フェイスで表示したければ、@var{face}として@code{fringe}を使用してください。

  たとえば左フリンジに矢印を表示するためには、@code{warning}フェイスを使用して以下のようにできます:

@lisp
(overlay-put
 (make-overlay (point) (point))
 'before-string (propertize
                 "x" 'display
                 `(left-fringe right-arrow warning)))
@end lisp

  以下はEmacsが定義する標準的なフリンジビットマップと、(@code{fringe-indicator-alist}と@code{fringe-cursor-alist}を通じて)Emacs内で現在それらが使用される方法のリストです。

@table @asis
@item @code{left-arrow}、@code{right-arrow}
切り詰められた行を示すために使用される。

@item @code{left-curly-arrow}、@code{right-curly-arrow}
継続された行を示すために使用される。

@item @code{right-triangle}、@code{left-triangle}
前者はオーバーレイ矢印により使用され、後者は使用されない。

@item @code{up-arrow}、@code{down-arrow}
@itemx @code{bottom-left-angle}、@code{bottom-right-angle}
@itemx @code{top-left-angle}、@code{top-right-angle}
@itemx @code{left-bracket}、@code{right-bracket}
@itemx @code{empty-line}
バッファー境界を示すために使用される。

@item @code{filled-rectangle}、@code{hollow-rectangle}
@itemx @code{filled-square}、@code{hollow-square}
@itemx @code{vertical-bar}、@code{horizontal-bar}
フリンジカーソルの異なるタイプにたいして使用される。

@item @code{exclamation-mark}、@code{question-mark}
Emacsの中核機能では使用されない。
@end table

@noindent
次のサブセクションではフリンジビットマップを独自に定義する方法を説明します。

@defun fringe-bitmaps-at-pos &optional pos window
この関数はウィンドウ@var{window}内の位置@var{pos}を含むディスプレイ行のフリンジビットマップをリターンする。リターン値は@code{(@var{left}
@var{right}
@var{ov})}という形式をもつ。ここで@var{left}は左フリンジ内のフリンジビットマップにたいするシンボル(ビットマップなしなら@code{nil})、@var{right}は同様に右フリンジにたいして、@var{ov}が非@code{nil}なら左フリンジにオーバーレイ矢印が存在することを意味する。

@var{window}内で@var{pos}が可視でなければ値は@code{nil}。@var{window}が@code{nil}なら選択されたウィンドウを意味する。@var{pos}が@code{nil}なら@var{window}内のポイントの値を意味する。
@end defun

@node Customizing Bitmaps
@subsection フリンジビットマップのカスタマイズ
@cindex fringe bitmaps, customizing

@defun define-fringe-bitmap bitmap bits &optional height width align
この関数はシンボル@var{bitmap}を新たなフリンジビットマップとして定義、またはその名前の既存のビットマップを置き換える。

引数@var{bits}は使用するイメージを指定する。これは各要素(整数)が対応するビットマップの1行を指定する文字列か整数ベクターであること。整数の各ビットはそのビットマップの1ピクセル、低位ビットはそのビットマップの最右ピクセルに対応する(このビットオーダーはXBMイメージと逆順であることに注意。@ref{XBM
Images}を参照)。

高さは通常は@var{bits}の長さ。しかし非@code{nil}の@var{height}により異なる高さを指定できる。幅は通常は8だが非@code{nil}の@var{width}により異なる幅を指定できる。widthは1から16の整数でなければならない。

引数@var{align}はそのビットマップが使用される行範囲に相対的なビットマップの位置を指定する。デフォルトはそのビットマップの中央。指定できる値は@code{top}、@code{center}、@code{bottom}。

@var{align}引数にはリスト@code{(@var{align}
@var{periodic})}も指定できて、@var{align}は上述のように解釈される。@var{periodic}が非@code{nil}なら、それは@code{bits}内の行が指定される高さに達するのに十分な回数繰り返されるべきであることを指定する。
@end defun

@defun destroy-fringe-bitmap bitmap
この関数は@var{bitmap}により識別されるフリンジビットマップを破棄する。@var{bitmap}が標準フリンジビットマップを識別する場合には、それを完全に消去するかわりに実際にはそのビットマップの標準定義をリストアする。
@end defun

@defun set-fringe-bitmap-face bitmap &optional face
これはフリンジビットマップ@var{bitmap}にたいするフェイスに@var{face}をセットする。@var{face}が@code{nil}なら@code{fringe}フェイスを選択する。ビットマップのフェイスはそれを描画するカラーを制御する。

@var{face}は@code{fringe}にマージされるため@var{face}は通常はフォアグラウンドカラーだけを指定すること。
@end defun

@node Overlay Arrow
@subsection オーバーレイ矢印
@c @cindex overlay arrow  Duplicates variable names

  @dfn{オーバーレイ矢印(overlay
arrow)}は、バッファー内の特定の行にたいしてユーザーに注意を促すために有用です。たとえばデバッガーでのインターフェースに使用されるモードでは、オーバーレイ矢印は実行されているコード行を示します。この機能は@dfn{オーバーレイ(overlays)}にたいして何も行いません(@ref{Overlays}を参照)。

@defvar overlay-arrow-string
この変数は特定の行にたいして注意を喚起するために表示する文字列、または矢印機能が使用されていなければ@code{nil}を保持する。グラフィカルなディスプレイではこの文字列のコンテンツは無視され、かわりにフリンジ領域からディスプレイ領域左側にグリフが表示される。
@end defvar

@defvar overlay-arrow-position
この変数はオーバーレイ矢印を表示する箇所を示すマーカーを保持する。これは行の先頭となるポイントであること。非グラフィカルなディスプレイではその行の先頭に矢印テキストが表示され、矢印テキストが表示されないときに表示されるべきテキストがオーバーレイされる。その矢印は通常は短く行は普通はインデントで開始されるので、上書きが問題となることは通常はない。

@c !!! overlay-arrow-position: but the overlay string may remain in the display
@c of some other buffer until an update is required.  This should be fixed
@c now.  Is it?
オーバーレイ矢印の文字列は、そのバッファーの@code{overlay-arrow-position}の値がバッファー内を指せば与えられた任意のバッファーで表示される。したがって@code{overlay-arrow-position}のバッファーローカルなバインディングを作成することにより、複数のオーバーレイ矢印の表示が可能である。しかしこれを達成するためには、@code{overlay-arrow-variable-list}を使用するほうが通常はより明快。
@end defvar

  @code{before-string}プロパティをもつオーバーレイを作成することにより同様のことを行うことができます。@ref{Overlay
Properties}を参照してください。

  変数@code{overlay-arrow-variable-list}を通じて複数のオーバーレイ矢印を定義できます。

@defvar overlay-arrow-variable-list
この変数の値は、それぞれがオーバーレイ矢印の位置を指定する変数のリスト。変数@code{overlay-arrow-position}はこのリスト上にあるために通常の意味をもつ。
@end defvar

このリスト上の各変数は対応するオーバーレイ矢印位置に表示するためのオーバーレイ矢印文字列を指定する@code{overlay-arrow-string}プロパティ(テキスト端末用)、およびフリンジビットマップを指定する@code{overlay-arrow-bitmap}プロパティ(グラフィカル端末用)をもつことができます。これらのプロパティがセットされていなければデフォルトのフリンジインジケーター@code{overlay-arrow-string}と@code{overlay-arrow}が使用されます。


@node Scroll Bars
@section スクロールバー
@cindex scroll bars

フレームパラメーター@code{vertical-scroll-bars}はそのフレーム内のウィンドウが垂直スクロールバーをもつべきかと、それらが左か右のいずれかに配置されるべきかを通常は制御します。フレームパラメーター@code{scroll-bar-width}はそれらの幅を指定します(@code{nil}はデフォルトを意味する)。

   フレームパラメーター@code{horizontal-scroll-bars}はフレーム内のウィンドウが水平スクロールバーをもつかどうかを制御します。フレームパラメーター@code{scroll-bar-height}はそれらの高さを指定します(@code{nil}はデフォルトを意味する)。@ref{Layout
Parameters}を参照のしてください。

@vindex horizontal-scroll-bars-available-p
   水平スクロールバーはすべてのプラットフォームで利用可能ではありません。引数を受け取らない関数@code{horizontal-scroll-bars-available-p}は、システム上で水平スクロールバーが利用可能なら非@code{nil}をリターンします。

   以下の3つの関数は引数として生きたフレームを受け取り、デフォルトは選択されたフレームです。

@defun frame-current-scroll-bars &optional frame
この関数はフレーム@var{frame}のスクロールバーのタイプを報告する。値はコンスセル@code{(@var{vertical-type} .@:
@var{horizontal-type})}。ここで@var{vertical-type}は@code{left}、@code{right}、または@code{nil}
(スクロールバーなしを意味する)のいずれか。@var{horizontal-type}は@code{bottom}か@code{nil}
(水平スクロールバーなしを意味する)のいずれか。
@end defun

@defun frame-scroll-bar-width &optional frame
この関数はウィンドウ@var{window}にたいして垂直スクロールバーの幅をピクセル単位でリターンする。
@end defun

@defun frame-scroll-bar-height &optional frame
この関数は@var{frame}の水平スクロールバーの高さをピクセル単位でリターンする。
@end defun

以下の関数を使用することにより、特定のウィンドウにたいするフレーム固有のセッティングをオーバーライドできます:

@defun set-window-scroll-bars window &optional width vertical-type height horizontal-type persistent
この関数はウィンドウ@var{window}のスクロールバーの幅および/または高さ、およびタイプをセットする。@var{window}が@code{nil}なら選択されたウィンドウが使用される。

@var{width}はピクセル単位で垂直スクロールバーの幅を指定する(@code{nil}はそのフレームにたいして指定された幅の使用を意味する)。@var{vertical-type}は垂直スクロールバーをもつかどうか、もつ場合にはその位置を指定する。可能な値は@code{left}、@code{right}、@code{t}
(フレームのデフォルトの使用を意味する)、垂直スクロールバーなしなら@code{nil}のいずれか。

@var{height}はピクセル単位で水平スクロールバーの高さを指定する(@code{nil}はそのフレームにたいして指定された高さの使用を意味する)。@var{horizontal-type}は水平スクロールバーをもつかどうかを指定する。可能な値は@code{bottom}、@code{t}
(フレームのデフォルトの使用を意味する)、水平スクロールバーなしなら@code{nil}のいずれか。ミニウィンドウにたいして値@code{t}は@code{nil}、すなわち水平スクロールバーを表示しないことを意味することに注意。ミニウィンドウで水平スクロールバーを表示するためには、明示的に@code{bottom}を指定する必要がある。

期待するサイズのスクロールバーを収容するのに@var{window}が十分大きくなければ、@var{window}のスクロールバーは未変更のままになる。

ここで指定した値は@var{window}にたいする引数@var{keep-margins}が@code{nil}か省略した@code{set-window-buffer}
(@ref{Buffers and
Windows}を参照)の呼び出しにより後からオーバーライドされるかもしれない。しかしオプションの1つ目の引数@var{persistent}が非@code{nil}、かつ他の引数が成功裏に処理されたなら、ここで指定された値は後続の@code{set-window-buffer}呼び出しに引き継がれる。
@end defun

@code{set-window-scroll-bars}および@code{set-window-fringes} (@ref{Fringe
Size/Pos}を参照)の@var{persistent}引数を使用すれば、以下のスニペットを早期initファイル(early init
file)に追加することにより、すべてのミニバッファーウィンドウでスクロールバーおよび/またはフリンジを信頼性をもって永続的にオフにすることができます(@ref{Init
File}を参照)。

@smallexample
@group
(add-hook 'after-make-frame-functions
          (lambda (frame)
            (set-window-scroll-bars
             (minibuffer-window frame) 0 nil 0 nil t)
            (set-window-fringes
             (minibuffer-window frame) 0 0 nil t)))
@end group
@end smallexample

以下の4つの関数は引数として生きたウィンドウを受け取り、デフォルトは選択されたウィンドウです。

@defun window-scroll-bars &optional window
この関数は@code{(@var{width} @var{columns} @var{vertical-type} @var{height}
@var{lines} @var{horizontal-type} @var{persistent})}という形式のリストをリターンする。

値@var{width}は垂直スクロールバーの幅に指定された値(@code{nil}もあり得る)。@var{columns}は垂直スクロールバーが実際に占有する列数(丸められているかもしれない)。

値@var{height}は水平スクロールバーの高さに指定された値(@code{nil}もあり得る)。@var{lines}は水平スクロールバーが実際に占有する行数(丸められているかもしれない)。

@var{persistent}の値は最後に成功裏に@code{set-window-scroll-bars}を呼び出した際に@var{window}に指定した値、そのような呼び出しがなければ@code{nil}。
@end defun

@defun window-current-scroll-bars &optional window
この関数はウィンドウ@var{window}にたいするスクロールバータイプを報告する。値はコンスセル@code{(@var{vertical-type}
.@:
@var{horizontal-type})}。@code{window-scroll-bars}とは異なりフレームのデフォルトと@code{scroll-bar-mode}を考慮して実際に使用されているスクロールバータイプを報告する。
@end defun

@defun window-scroll-bar-width &optional window
この関数は@var{window}の垂直スクロールバーの幅をピクセル単位でリターンする。
@end defun

@defun window-scroll-bar-height &optional window
この関数は、@var{window}の水平スクロールバーの高さをピクセル単位でリターンする。
@end defun

@code{set-window-scroll-bars}でウィンドウのスクロールバーのセッティングを指定しない場合には、表示されようとするバッファーのバッファーローカル変数@code{vertical-scroll-bar}、@code{horizontal-scroll-bar}、@code{scroll-bar-width}、@code{scroll-bar-height}がウィンドウのスクロールバーを制御します。@code{set-window-buffer}はこれらの変数を調べる関数です。あるウィンドウですでに可視なバッファーでこれらを変更した場合には、すでに表示されているのと同じバッファーを指定して@code{set-window-buffer}を呼び出すことにより、そのウィンドウに新たな値を記録させることができます。

以下の変数をセット(セットにより自動的にバッファーローカルになる)することにより、特定のバッファーのスクロールバーの外観を制御できます。

@defvar vertical-scroll-bar
この変数は垂直スクロールバーの配置を指定する。可能な値は@code{left}、@code{right}、そのフレームのデフォルトの使用を意味する@code{t}、スクロールバーなしの@code{nil}のいずれか。
@end defvar

@defvar horizontal-scroll-bar
この変数は水平スクロールバーの配置を指定する。可能な値は@code{bottom}、そのフレームのデフォルトの使用を意味する@code{t}、スクロールバーなしの@code{nil}のいずれか。
@end defvar

@defvar scroll-bar-width
この変数はそのバッファーの垂直スクロールバーをピクセル単位で量った幅を指定する。値@code{nil}はフレームにより指定された値の使用を意味する。
@end defvar

@defvar scroll-bar-height
この変数はそのバッファーの水平スクロールバーをピクセル単位で量った高さを指定する。値@code{nil}はフレームにより指定された値の使用を意味する。
@end defvar

最後に変数@code{scroll-bar-mode}と@code{horizontal-scroll-bar-mode}をカスタマイズすることにより、すべてのフレームでのスクロールバーの表示を切り替えることができます。

@defopt scroll-bar-mode
この変数はすべてのフレームに垂直スクロールバーを配置するべきかと、その場所を制御する。可能な値は、スクロールバーなしの@code{nil}、左にスクロールバーを配置する@code{left}、右にスクロールバーを配置する@code{right}のいずれか。
@end defopt

@defopt horizontal-scroll-bar-mode
この変数はすべてのフレームに水平スクロールバーを表示するかどうかを制御する。
@end defopt


@node Window Dividers
@section ウィンドウディバイダー
@cindex window dividers
@cindex right dividers
@cindex bottom dividers

ウィンドウディバイダーとはフレームのウィンドウ間に描画されるバーのことです。右(right)ディバイダーはあるウィンドウと、その右に隣接する任意のウィンドウの間に描画されます。その幅(厚さ)はフレームパラメーター@code{right-divider-width}で指定されます。下(bottom)ディバイダーはあるウィンドウと、その下に隣接するウィンドウやエコーエリアとの間に描画されます。その幅はフレームパラメーター@code{bottom-divider-width}で指定されます。いずれの場合でも幅に0を指定すると、そのようなディバイダーを描画しないことを意味します。@ref{Layout
Parameters}を参照してください。

   技術的には右ディバイダーはそれの左にあるウィンドウに所属して、その幅がそのウィンドウのトータル幅に寄与することを意味します。下ディバイダーは上にあるウィンドウに所属して、その幅がそのウィンドウのトータル高さに寄与することを意味します。@ref{Window
Sizes}を参照してください。あるウィンドウが右ディバイダーと左ディバイダーの両方をもつ場合には下ディバイダーが優勢になります。これは右ディバイダーが下ディバイダーの上で終端されるのに比べて、下ディバイダーはそのウィンドウの完全なトータル幅で描画されることを意味しています。

   ディバイダーはマウスでドラッグできるのでマウスで隣接するウィンドウのサイズを調整するために有用です。これらはスクロールバーやモードラインが表示されていないときに隣接するウィンドウを視覚的に分離する役目もあります。以下の3つのフェイスによりディバイダーの外観をカスタマイズできます:

@table @code
@item window-divider
ディバイダーの幅が3ピクセル未満のときは、このフェイスのフォアグラウンドカラーで塗りつぶしで描画される。これより広いディバイダーでは、最初と最後のピクセルを除いた内部にたいしてのみこのフェイスが使用される。

@item window-divider-first-pixel
これは少なくとも幅が3ピクセルあるディバイダーの最初のピクセルを描画するために使用される。塗りつぶし(solid)の外観を得るためには@code{window-divider}フェイスに使用されるのと同じ値をセットすること。

@item window-divider-last-pixel
これは少なくとも幅が3ピクセルあるディバイダーの最後のピクセルを描画するために使用される。塗りつぶし(solid)の外観を得るためには@code{window-divider}フェイスに使用されるのと同じ値をセットすること。
@end table

以下の2つの関数により特定のウィンドウのディバイダーのサイズを取得できます。

@defun window-right-divider-width &optional window
@var{window}の右ディバイダーの幅(厚さ)をピクセル単位でリターンする。@var{window}は生きたウィンドウでなければならずデフォルトは選択されたウィンドウ。最右ウィンドウにたいするリターン値は常に0。
@end defun

@defun window-bottom-divider-width &optional window
@var{window}の下ディバイダーの幅(厚さ)をピクセル単位でリターンする。@var{window}は生きたウィンドウでなければならずデフォルトは選択されたウィンドウ。ミニバッファーウィンドウやミニバッファーがないフレームの最下ウィンドウにたいするリターン値は常に0。
@end defun


@node Display Property
@section @code{display}プロパティ
@cindex display specification
@cindex display property
@kindex display @r{(text property)}

  テキストプロパティ(またはオーバーレイプロパティ)の@code{display}はテキストへのイメージ挿入、およびテキスト表示のその他の事相を制御します。@code{display}プロパティの値はディスプレイ仕様、または複数のディスプレイ仕様を含むリストかベクターであるべきです。同じ@code{display}プロパティ値内のディスプレイ仕様は、一般的にはそれらがカバーするテキストにたいして並行して適用されます。

  複数のソース(オーバーレイおよび/またはテキストプロパティ)が@code{display}プロパティにたいして値を指定しますが1つの値だけが効果をもち、それは@code{get-char-property}のルールにしたがいます。@ref{Examining
Properties}を参照してください。

@cindex display property, unsafe evaluation
@cindex security, and display specifications
  いくつかのディスプレイ仕様には、表示時に評価されるLispフォームを含めることができます。これは特定の状況では安全ではないかもしれません(ディスプレイ仕様が何らかの外部のプログラムやエージェントにより生成されたとき等)。@w{@code{('disable-eval
@var{spec})}}のように特別なシンボル@code{disable-eval}で始まるリスト内にディスプレイ仕様をラップすることにより、他のすべてのディスプレイプロパティ機能をサポートしつつ、@var{spec}内の任意のLisp評価が無効になります。

  このセクションの残りの部分では、複数の種類のディスプレイ仕様とそれらの意味を説明します。

@menu
* Replacing Specs::          テキストを置換するディスプレイspec。
* Specified Space::          指定された幅に1つのスペースを表示する。
* Pixel Specification::      ピクセル単位でスペースの幅や高さを指定する。
* Other Display Specs::      イメージの表示。高さ、スペーシング、その他のテキストプロパティの調整。
* Display Margins::          メインテキスト側面へのテキストやイメージの表示。
@end menu

@node Replacing Specs
@subsection テキストを置換するディスプレー仕様
@cindex replacing display specs

  ある種のディスプレイ仕様は、そのプロパティをもつテキストのかわりに表示する何かを指定します。これらは@dfn{置換(replacing)}ディスプレイ仕様と呼ばれます。Emacsはユーザーにたいして、この方法で置換されたバッファーテキストの中間への対話的なポイント移動を許可しません。

  ディスプレイ仕様のリストに1つ以上の置換ディスプレイ仕様が含まれる場合には、最初の置換ディスプレイ仕様が残りをオーバーライドします。置換ディスプレイ仕様は他のほとんどのディスプレイ仕様は置換を許容しないので、それらとは無関係です。

  置換ディスプレイ仕様では、@dfn{そのプロパティをもつテキスト}とは、@code{display}プロパティとして同一のLispオブジェクトをもつ連続したすべての文字を意味します。これらの文字は単一の単位として置換されます。@code{display}プロパティに異なるLispオブジェクト(@code{eq}ではないオブジェクト)をもつ2つの文字は個別に処理されます。

  以下はこの要点を示すための例です。文字列が置換ディスプレイ仕様としての役割をもち、指定された文字列のプロパティをもつテキストを置換します(@ref{Other
Display Specs}を参照)。以下の関数を考えてみてください:

@smallexample
(defun foo ()
  (dotimes (i 5)
    (let ((string (concat "A"))
          (start (+ i i (point-min))))
      (put-text-property start (1+ start) 'display string)
      (put-text-property start (+ 2 start) 'display string))))
@end smallexample

@noindent
この関数はバッファー内の最初の10文字それぞれにたいして文字列@code{"A"}であるような@code{display}プロパティを与えますが、これらはすべて同じ文字列オブジェクトを取得しません。最初の2文字は同じ文字列オブジェクトなので1つの@samp{A}に置換されます。2つの別々の@code{put-text-property}呼び出しでそのディスプレイプロパティが割り当てられたという事実は無関係です。同様に次の2文字は2つ目の文字列(@code{concat}により新たに作成された文字列オブジェクト)を取得するので1つの@samp{A}で置換されて、...となります。したがって10文字は5つのAで表示されます。

@node Specified Space
@subsection スペースの指定
@cindex spaces, specified height or width
@cindex variable-width spaces

  指定された幅および/または高さのスペースを表示するためには@code{(space
.
@var{props})}という形式のディスプレイ仕様を使用します。このプロパティを1つ以上の連続する文字にputすることができます。これら@emph{すべて}の文字のかわりに指定された高さと幅のスペースが表示されます。以下はスペースのウェイトを指定するために@var{props}内で使用できるプロパティです:

@table @code
@item :width @var{width}
@var{width}が数字なら、それはスペースの幅が通常の文字幅の@var{width}倍であるべきかを指定する。@var{width}は@dfn{ピクセル幅(pixel
width)}仕様でも可(@ref{Pixel Specification}を参照)。

@item :relative-width @var{factor}
幅の広さは同じ@code{display}プロパティをもつ連続する文字のグループ内の最初の文字から計算される必要があることを指定する。スペースの幅はその文字のピクセル幅に@var{factor}を乗じた幅である(テキストモード端末では文字の``ピクセル幅''は通常は1だがTAB文字や2倍の幅をもつCJK文字では1以上になり得る)。

@item :align-to @var{hpos}
スペースが@var{hpos}に達するほど十分に広くあるべきことを指定する。@var{hpos}が数字なら通常の文字幅の単位で量られる。@var{hpos}は@dfn{ピクセル幅(pixel
width)}仕様でも可(@ref{Pixel Specification}を参照)。
@end table

  上記プロパティのいずれか1つだけを使用するべきです。以下のプロパティでスペースの高さも指定できます:

@table @code
@item :height @var{height}
スペースの高さを指定する。@var{height}が数字ならスペースの高さが通常の文字高さの@var{height}倍であるべきことを指定する。@var{height}は@dfn{ピクセル高さ仕様(pixel
height)}でも可(@ref{Pixel Specification}を参照)。

@item :relative-height @var{factor}
このディスプレイ仕様をもつテキストの通常の高さに@var{factor}を乗じることによりスペースの高さを指定する。

@item :ascent @var{ascent}
@var{ascent}の値が非負の100以下の数字ならスペースの高さの@var{ascent}パーセントをスペースのアセント(ascent:
上方)、すなわちベースラインより上の部分とみなす。@dfn{ピクセルアセント(pixel
ascent)}仕様によりアセントをピクセル単位で指定することも可(@ref{Pixel Specification}を参照)。

@end table

  @code{:height}と@code{:relative-height}を両方同時に使用しないでください。

  @code{:width}と@code{:align-to}プロパティは非グラフィック端末でサポートされますが、このセクションのその他のスペースプロパティはサポートされません。

  スペースプロパティは双方向テキスト表示の並べ替えのためのパラグラフ区切りとして扱われます。詳細は@ref{Bidirectional
Display}を参照してください。

@node Pixel Specification
@subsection スペースにたいするピクセル指定
@cindex spaces, pixel specification

  プロパティ@code{:width}、@code{:align-to}、@code{:height}、@code{:ascent}の値は再表示の間に評価される特別な種類の式です。その評価の結果はピクセルの絶対数として使用されます。

  以下の式がサポートされています:

@smallexample
@group
  @var{expr} ::= @var{num} | (@var{num}) | @var{unit} | @var{elem} | @var{pos} | @var{image} | @var{xwidget} | @var{form}
  @var{num}  ::= @var{integer} | @var{float} | @var{symbol}
  @var{unit} ::= in | mm | cm | width | height
@end group
@group
  @var{elem} ::= left-fringe | right-fringe | left-margin | right-margin
        |  scroll-bar | text
  @var{pos}  ::= left | center | right
  @var{form} ::= (@var{num} . @var{expr}) | (@var{op} @var{expr} ...)
  @var{op}   ::= + | -
@end group
@end smallexample

  フォーム@var{num}はデフォルトフレームフォントの高さか幅、フォーム@code{(@var{num})}は絶対ピクセル数を指定します。@var{num}がシンボル@var{symbol}なら、それのバッファーローカルな変数バインディングが使用されます。このバインディングには数字か上述の形式のコンスセル(他にもバッファーローカルなバインディングをもつシンボルが@code{car}であるような他のコンスセルも含む)が可能です。

  単位@code{in}、@code{mm}、@code{cm}はそれぞれインチ、ミリメートル、センチメートルごとのピクセル数を指定します。単位@code{width}と@code{height}はそれぞれカレントフェイスのデフォルトの幅と高さに対応します。@w{@code{(image
. @var{props})}}という形式のイメージ仕様は、指定されたイメージの幅や高さに対応します(@ref{Image
Descriptors}を参照)。同様に@w{@code{(xwidget
.
@var{props})}}という形式のxwidget仕様は指定されたxwidgetび幅や高さを意味します。@ref{Xwidgets}を参照してください。

  要素@code{left-fringe}、@code{right-fringe}、@code{left-margin}、@code{right-margin}、@code{scroll-bar}、@code{text}はそのウィンドウの対応する領域の幅を指定します。そのウィンドウで行番号(@ref{Size
of Displayed Text}を参照)を表示している際にはテキストエリアの幅は行番号の表示に要するスクリーンスペースで減じられます。

  位置@code{left}、@code{center}、@code{right}はテキストエリアの左端、中央、右端から相対的に位置を指定するために@code{:align-to}とともに使用できます。ウィンドウで行番号を表示している際の@code{left}と@code{center}の位置は、行番号の表示に要するスクリーンスペースを考慮したオフセットになります。

  (@code{text}を除いた)上記ウィンドウ要素は与えられたエリアの左端から相対的に位置を指定するために@code{:align-to}とともに使用することもできます。(最初に出現するこれらシンボルのいずれかにより)相対的位置にたいするベースオフセットが一度セットがされると、残りのシンボルは指定されたエリアの幅として解釈されます。たとえば左マージンの中央に位置揃えするには以下のようにします

@example
:align-to (+ left-margin (0.5 . left-margin))
@end example

  位置揃えにたいしてベースオフセットが何も指定されなければ、テキストエリア左端にたいして常に相対的になります。たとえばヘッダーライン内の@samp{:align-to
0}はテキストエリアの最初のテキスト行に位置揃えします。ウィンドウで行番号を表示している際には、テキストは行番号表示の終了に使用されるスペースから開始するとみなされます。

  @code{(@var{num}
. @var{expr})}という形式の値は、@var{num}と@var{expr}により生成される値を意味します。たとえば@code{(2
. in)}は2インチの幅、@code{(0.5 .  @var{image})}は指定された@var{image}
(それのイメージspecにより与えられる必要がある)の幅(または高さ)の半分を指定します。

  フォーム@code{(+ @var{expr} ...)}は式の値を合計します。フォーム@code{(- @var{expr}
...)}は式の値を符号反転または減算します。

@node Other Display Specs
@subsection その他のディスプレー仕様

  以下は@code{display}テキストプロパティ内で使用できる他のディスプレイ仕様です。

@table @code
@item @var{string}
このプロパティをもつテキストのかわりに@var{string}を表示する。

再帰的なディスプレイ仕様はサポートされない。つまり@var{string}の@code{display}プロパティがあっても使用されない。

@item (image . @var{image-props})
この種のディスプレイ仕様はイメージディスクリプタである(@ref{Image
Descriptors}を参照)。ディスプレイ仕様として使用時には、そのディスプレイ仕様をもつテキストのかわりに表示するイメージを意味する。

@item (slice @var{x} @var{y} @var{width} @var{height})
この仕様は@code{image}とともに、表示するイメージの@dfn{スライス(slice:
イメージの特定の領域)}を指定する。要素@var{y}と@var{x}はイメージ内での左上隅、@var{width}と@var{height}はそのスライスの幅と高さを指定する。整数はピクセル数、0.0から1.0までの浮動小数点数はイメージ全体の幅や高さの割合を意味する。

@item ((margin nil) @var{string})
この形式のディスプレイ仕様は、このディスプレイ仕様をもつテキストのかわりにテキストと同じ位置に表示する@var{string}を意味する。これは単に@var{string}を使用するのと同じだが、マージン表示(@ref{Display
Margins}を参照)の特殊なケースとして行われる点が異なる。

@item (left-fringe @var{bitmap} @r{[}@var{face}@r{]})
@itemx (right-fringe @var{bitmap} @r{[}@var{face}@r{]})
テキスト行の任意の文字がこのディスプレイ仕様をもつ場合には、その文字のかわりにその行の左や右のフリンジに表示する@var{bitmap}を指定する。オプションの@var{face}はビットマップ表示にカラーを使用するフェイスを指定する。詳細は@ref{Fringe
Bitmaps}を参照のこと。

@item (space-width @var{factor})
このディスプレイ仕様は、この仕様をもつテキスト内のすべてのスペース文字に効果を及ぼす。これらすべてのスペースは通常の幅の@var{factor}倍の幅で表示される。要素@var{factor}は整数か浮動小数点数であること。スペース以外の文字は影響を受けない。特にこれはタブ文字に影響を与えない。

@item (height @var{height})
このディスプレイ仕様はテキストを高く(taller)、または低く(shorter)する。@var{height}には以下を指定できる:

@table @asis
@item @code{(+ @var{n})}
@c FIXME: Add an index for "step"?  --xfq
これは@var{n}ステップ大きいフォントの使用を意味する。@dfn{ステップ}は利用可能なフォントのセットから定義される。利用可能なフォントとは、具体的には、このような場合でなければ、heightを除いてそのテキストに指定されたすべての属性にマッチするフォント。適切なフォントの各サイズは別のステップとして利用可能とみなされる。@var{n}は整数であること。

@item @code{(- @var{n})}
これは@var{n}ステップ小さいフォントの使用を意味する。

@item @var{factor} (数値)
数値@var{factor}はデフォルトフォントの@var{factor}倍高いフォントの使用を意味する。

@item @var{function} (シンボル)
高さを計算する関数。この関数はカレントの高さを引数として呼び出されて、使用する新たな高さをリターンすること。

@item @var{form} (上記以外)
@var{height}の値が上記のいずれにもマッチしなければ、それはフォームである。Emacsは@code{height}をカレントで指定されたフォントの高さにバインドして新たな高さを取得するためにフォームを評価する。
@end table

@item (raise @var{factor})
この種のディスプレイ仕様は、その行のベースラインに相対的にテキストを上(raise)、または下(lower)に指定する。これは主に上付き文字と下付き文字を意図している。

@var{factor}は影響を受けるテキストの高さにたいする乗数として解釈される数値でなければならない。これが正なら上、負なら下に文字を表示することを意味する。

テキストが@code{raise}より前(左)に指定された@code{height}ディスプレイ仕様をもつ場合には、テキストが上下される量はテキストの高さにもとづくので、上下されるピクセル数には@code{raise}が効果をもつ。したがって通常のテキスト高さより小さい上付きや下付きで表示したければ、@code{height}の前に@code{raise}を指定することを考慮するべきである。
@end table

@c We put all the '@code{(when ...)}' on one line to encourage
@c makeinfo's end-of-sentence heuristics to DTRT.  Previously, the dot
@c was at eol; the info file ended up w/ two spaces rendered after it.
  任意のディスプレイ仕様にたいして条件を作成できます。これを行うには、@code{(when @var{condition}
.
@var{spec})}という形式の別リスト内にパッケージします。この場合には、仕様@var{spec}は@var{condition}が非@code{nil}値に評価されたときだけ適用されます。この評価の間に@code{object}は条件つき@code{display}プロパティをもつ文字列、またはバッファーにバインドされます。@code{position}と@code{buffer-position}はそれぞれ@code{object}内の位置、および@code{display}プロパティが見つかったバッファー位置にバインドされます。@code{object}が文字列の際には両者の位置は異なるかもしれません。

@var{condition}はこのディスプレイ仕様が配置された箇所のテキストを再表示が調べる際だけ評価されるので、この機能は比較的安定した条件にもっとも適していることに注意してください(特定のバッファー位置それぞれにたいして評価ごとに同じ結果を取得する)。同じのテキスト位置にたいする結果が異なる、つまり結果がポイント位置に依存するようなら、この条件仕様はあなたの望むものではないかもしれません。なぜなら再表示は最後の表示サイクル以降に何かが変更されたといなす理由があるバッファーテキストの部分だけを調べるからです。

@node Display Margins
@subsection マージン内への表示
@cindex display margins
@cindex margins, display

  バッファーはその左側と右側に@dfn{ディスプレイマージン(display
margins)}と呼ばれるブランクエリアをもつことができます。それらのエリア内には通常はテキストが出現することはありませんが、@code{display}プロパティを使用してディスプレイマージン内に何かを配置することができます。現在のところマージン内のテキストやイメージをマウスセンシティブにする方法はありません。

  マージン内に何かを表示するにはテキストの@code{display}プロパティのマージン表示仕様(margin display
specification)で指定します。これは配置したテキストが表示されないことを意味する置換表示仕様です。マージン表示は表示されますがそのテキストは表示されません。

  マージン表示仕様とは@code{((margin right-margin) @var{spec})}や@code{((margin
left-margin)
@var{spec})}のようなものです。ここで@var{spec}はマージン内に何を表示するかを告げる別の表示仕様です。典型的にはこれは表示するテキスト文字列やイメージディスクリプタです。

  特定のバッファーテキストに@emph{割り当てられた}マージンに何かを表示するためには、そのテキストに@code{before-string}プロパティを付してコンテンツとしてマージン表示仕様をputします。

  マージン内に表示する文字列がフェイスを指定しなければ、テキストエリア内に表示される文字列に準じたいくつかの規則と優先度によりフェイスが決定されることに注意してください(@ref{Displaying
Faces}を参照)。これが望ましくないマージンへのフェイスの``漏洩''をもたらすようなら、文字列が文字列用に明示的なフェイスを確実にもつようにしてください。

  ディスプレイマージンが何かを表示可能になる前に、それらに非0の幅を与えなければなりません。これを行う通常の方法は以下の変数をセットする方法です:

@defvar left-margin-width
この変数は左マージンの幅を文字セル(別名は``列'')単位で指定する。これ、すべてのバッファーでバッファーローカルである。値@code{nil}は左マージンエリアなしを意味する。
@end defvar

@defvar right-margin-width
この変数は右マージンの幅を文字セル単位で指定する。これはすべてのバッファーでバッファーローカルである。値@code{nil}は右マージンエリアなしを意味する。
@end defvar

  これらの変数をセットしてもウィンドウには即座には反映されません。これらの変数はウィンドウ内に新たなバッファーを表示する際にチェックされます。したがって@code{set-window-buffer}を呼び出すことにより変更を反映することができます。これらの変数を左右のマージンのカレント幅の判定を試みるために使用してはいけません。かわりに関数@code{window-margins}を使用してください。

  マージン幅を即座にセットすることもできます。

@defun set-window-margins window left &optional right
この関数はウィンドウ@var{window}のマージン幅、文字セル単位で指定する。引数@var{left}は左マージン、@var{right}は右マージン(デフォルトは@code{0})を制御する。

期待する幅のマージンを収容するのに@var{window}が十分大きくなければ、@var{window}のマージンは未変更のままになる。

ここで指定した値は@var{window}にたいする引数@var{keep-margins}が@code{nil}か省略した@code{set-window-buffer}
(@ref{Buffers and Windows}を参照)の呼び出しにより後からオーバーライドされるかもしれない。
@end defun

@defun window-margins &optional window
この関数は@var{window}の左マージンと右マージンの幅を@w{@code{(@var{left}
.
@var{right})}}という形式のコンスセルでリターンする。2つのマージンエリアのいずれか一方が存在しなければ幅は@code{nil}でリターンされる。2つのマージンがどちらも存在しなければ、この関数は@code{(nil)}をリターンする。@var{window}が@code{nil}なら選択されたウィンドウが使用される。
@end defun

@node Images
@section イメージ
@cindex images in buffers

  Emacsバッファー内にイメージを表示するためには最初にイメージディスクリプタを作成して、それを表示されるテキストの@code{display}プロパティ(@ref{Display
Property}を参照)内のディスプレイ指定子として使用しなければなりません。

  Emacsはグラフィカルな端末で実行時には、通常はイメージの表示が可能です。テキスト端末、イメージサポートを欠く特定のグラフィカル端末、またはイメージサポートなしでコンパイルされたEmacsではイメージを表示できません。原則的にイメージが表示可能か判断するためには関数@code{display-images-p}を使用できます(@ref{Display
Feature Testing}を参照)。

@menu
* Image Formats::            サポートされるイメージフォーマット。
* Image Descriptors::        @code{:display}内で使用されるイメージの指定方法。
* XBM Images::               XBMフォーマット用の特別な機能。
* XPM Images::               XPMフォーマット用の特別な機能。
* ImageMagick Images::       ImageMagickを通じて利用できる特別な機能。
* SVG Images::               SVGイメージの作成と操作。
* Other Image Types::        サポートされる他のさまざまなフォーマット。
* Defining Images::          後で使用するためにイメージを定義する便利な方法。
* Showing Images::           一度定義されたイメージを表示するための便利な方法。
* Multi-Frame Images::       1つ以上のフレームを含むイメージ。
* Image Cache::              イメージ表示の内部的メカニズム。
@end menu

@node Image Formats
@subsection イメージのフォーマット
@cindex image formats
@cindex image types

  Emacsはいくつかの異なるフォーマットのイメージを表示できます。これらのイメージフォーマットのいくつかは、特定のサポートライブラリーがインストールされている場合のみサポートされます。いくつかのプラットフォームではEmacsはオンデマンドでサポートライブラリーをロードできます。そのような場合には、それらの動的ライブラリーにたいする既知の名前セットを変更するために変数@code{dynamic-library-alist}を使用できます。@ref{Dynamic
Libraries}を参照してください。

  サポートされるイメージフォーマット(と要求されるサポートライブラリー)にはPBMとXBM(サポートライブラリーに依存せず常に利用可能)、XPM
(@code{libXpm})、GIF (@code{libgif}か@code{libungif})、JPEG
(@code{libjpeg})、TIFF (@code{libtiff})、PNG (@code{libpng})、SVG
(@code{librsvg})が含まれます。

  これらのイメージフォーマットはそれぞれ@dfn{イメージタイプシンボル(image type
symbol)}に関連付けられます。上記のフォーマットにたいするシンボルは順に@code{pbm}、@code{xbm}、@code{xpm}、@code{gif}、@code{jpeg}、@code{tiff}、@code{png}、@code{svg}になります。

  さらにImageMagick(@code{libMagickWand})のサポートつきでEmacsをビルドした場合には、EmacsはImageMagickが表示可能なイメージフォーマットを表示できます。@ref{ImageMagick
Images}を参照してください。ImageMagickを通じて表示されるすべてのイメージはタイプシンボル@code{imagemagick}をもちます。

@defvar image-types
この変数はカレント構成で潜在的にサポートされるイメージフォーマットにたいするタイプシンボルのリストを含む。

``潜在的''とはEmacsがそのイメージタイプを知っていることを意味しており、実際に使用可能である必要はない(たとえば動的ライブラリーが利用できないせいかもしれない)。どのイメージタイプが実際に利用できるか知るためには@code{image-type-available-p}を使用すること。
@end defvar

@defun image-type-available-p type
この関数はタイプ@var{type}のイメージのロードと表示が可能なら非@code{nil}をリターンする。@var{type}はイメージタイプシンボルであること。

サポートライブラリーが静的にリンクされたイメージタイプにたいして、この関数は常に@code{t}をリターンする。サポートライブラリーが動的にロードされるイメージタイプにたいしてはライブラリーがロード可能なら@code{t}、それ以外なら@code{nil}をリターンする。
@end defun

@node Image Descriptors
@subsection イメージのディスクリプタ
@cindex image descriptor

  @dfn{イメージディスクリプタ(image
descriptor)}とは、イメージにたいする基礎的なデータと表示する方法を指定するリストです。これは通常はオーバーレイプロパティかテキストプロパティ@code{display}(@ref{Other
Display Specs}を参照)の値を通じて使用されますが、バッファーにイメージを挿入する便利なヘルパー関数については@ref{Showing
Images}を参照してください。

  イメージディスクリプタはそれぞれ@code{(image
.
@var{props})}という形式をもちます。ここで@var{props}はキーワードシンボルと値のペアーからなるプロパティリストであり、少なくともそのイメージタイプを指定するペアー@code{:type
@var{type}}を含みます。

  イメージのサイズを定義するイメージディスクリプタ@code{:width}、@code{:height}、@code{:max-width}、@code{:max-height}は整数(サイズをピクセルで表現)、あるいは
@code{(@var{value}
.
em)}という形式をとります。ここで@var{value}は@dfn{ems}@footnote{タイポグラフィではemはタイプの高さに相当する距離のこと。たとえば12ポイントタイプの1emは12ポイントと同じ。これの使用により距離とタイプの比率が保たれる。}によるサイズの長さ。1emはフォント高さと等しく、@var{value}は整数または浮動小数。

  以下はすべてのイメージタイプにたいして意味のあるプロパティのリストです(以降のサブセクションで説明するように特定のイメージタイプにたいしてのみ意味があるプロパティも存在する):

@table @code
@item :type @var{type}
イメージタイプ。
@ifnottex
@ref{Image Formats}を参照のこと。
@end ifnottex
すべてのイメージディスクリプタは。このプロパティを含まなければならない。

@item :file @var{file}
これはファイル@var{file}からイメージをロードすることを意味する。@var{file}が絶対ファイル名でなければ、それは@code{data-directory}の@file{images}サブディレクトリーから相対的に展開される。これに失敗すると@code{x-bitmap-file-path}にリストされたディレクトリーから相対的に展開される(@ref{Face
Attributes}を参照)。

@item :data @var{data}
これはrawイメージデータを指定する。すべてのイメージディスクリプタは@code{:data}か@code{:file}のいずれかをもたなければならないが両方もつことはできない。

ほとんどのイメージタイプにたいして、@code{:data}プロパティの値はイメージデータを含む文字列であること。いくつかのイメージタイプは@code{:data}をサポートしない。それ以外のイメージタイプにたいしては@code{:data}単独では不十分であり、@code{:data}とともに他のイメージプロパティを使用する必要がある。詳細は以下のサブセクションを参照のこと。

@item :margin @var{margin}
これはイメージ周囲に余分なマージンとして何ピクセル追加するかを指定する。値@var{margin}は非負の数値か、そのような数値のペアー@code{(@var{x}
.
@var{y})}でなければならない。ペアーなら@var{x}は水平方向に追加するピクセル数、@var{y}は垂直方向に追加するピクセル数を指定する。@code{:margin}が指定されない場合のデフォルトは0。

@item :ascent @var{ascent}
これはイメージのアセント(ベースラインの上の部分)に使用するイメージの高さの分量を指定する。値@var{ascent}は0から100の数値かシンボル@code{center}でなければならない。

@var{ascent}が数値ならアセントに使用するイメージの高さのパーセンテージであること。

@var{ascent}が@code{center}なら、イメージにたいしてテキストプロパティやオーバーレイプロパティにより指定される方法で、センターライン(そのイメージ位置にテキストを描画する際の垂直方向のセンターライン)の垂直方向中心にイメージが配置される。

このプロパティが省略された場合のデフォルトは50。

@item :relief @var{relief}
これはイメージ周辺にシャドー矩形を追加する。値@var{relief}はシャドーライン幅をピクセルで指定する。@var{relief}が負ならボタンを押下した状態、それ以外はボタンを押下していない状態のイメージでシャドーを描画する。

@item :width @var{width}, :height @var{height}
キーワード@code{:width}と@code{:height}はイメージのスケーリングに使用される。いずれか一方のみが指定された場合には、アスペクト比を保つためにもう一方が算出される。両方が指定された場合にはアスペクト比は保たれないかもしれない。

@item :max-width @var{max-width}, :max-height @var{max-height}
キーワード@code{:max-width}と@code{:max-height}は、イメージのサイズがこれらの値を超過した場合のスケーリングに使用される。@code{:width}がセットされた場合には@code{max-width}より優先されて、@code{:height}がセットされた場合には@code{max-height}より優先されるだろうが、それ以外ではこれらのキーワードを望むように混交できる。

@code{:max-width}と@code{:height}が指定されていて@code{:width}が未指定なら、アスペクト比を維持することにより@code{:max-width}を超える幅が要求されるかもしれない。これが発生した場合には、スケーリングは@code{:max-width}を超過しないアスペクト比を維持できるように、小さい値を使用する。@code{:max-height}と@code{:width}が指定されていて@code{:height}が未指定のときも同様。たとえば200x100のイメージがあり@code{:width}を400、@code{:max-height}を150に指定すると、アスペクト比を保持しつつ``max''のセッティングを超過しないようにイメージは最終的には300x150になる。このパラメーターの組み合わせは、``可能なかぎり大きく、ただし利用可能なディスプレイエリア以下でこのイメージを表示せよ''のように指示する簡便な手段である。

@item :scale @var{scale}
これは数字であること。1より大きい値は幅および高さを乗じたサイズの増加、小さい値はサイズの減少を意味する。たとえば値0.25はイメージをオリジナルの1/4のサイズにするだろう。このスケーリングにより@code{:max-width}や@code{:max-height}で指定されたイメージの元のサイズより大きくなる場合でも、結果サイズがこれら2つの値を超過することはない。@code{:scale}および@code{:height}/@code{:width}の両方が指定されたら、高さ/幅は指定されたスケーリング倍率に調整される。

@item :rotation @var{angle}
ローテーション角度を度数(degree)で指定する。イメージタイプが@code{imagemagick}でなければ、90°の倍数のみをサポート。値が正なら時計回り、負なら反時計回り。ローテーションはスケーリングとクロッピング(cropping:
切り取り、抜き出し)の後に行われる。

@item :transform-smoothing @var{smooth}
これが@code{t}ならイメージ変換にスムージングを適用、@code{nil}ならスムージングを適用しない。使用する正確なアルゴリズムはプラットフォームに依存するが、バイリニアフィルタリング(bilinear
filtering)と等価であること。スムージングを無効にすると、もっとも近い類似アルゴリズムを使用する。

このプロパティが未指定なら、@code{create-image}はスケーリングするかしないかを指示するために、ユーザーオプション@code{image-transform-smoothing}を使用する。このオプションは@code{nil}
(スムージングなし)、@code{t}
(スムージングを使用)、またはイメージオブジェクトを唯一のパラメーターとして呼び出されて@code{nil}か@code{t}をリターンする述語関数であること。デフォルトではダウンスケーリングにはスムージングを適用、巨大なアップスケーリングにはスムージングを適用しない。

@item :index @var{frame}
@ref{Multi-Frame Images}を参照のこと。

@item :conversion @var{algorithm}
これはイメージを表示する前に適用するべき変換アルゴリズムを指定する。値@var{algorithm}は何のアルゴリズムかを指定する。

@table @code
@item laplace
@itemx emboss
カラーの大きな差異を強調して小さな差異を不鮮明にするラプラスエッジ検出アルゴリズム(Laplace edge detection
algorithm)を指定する。無効なボタンのイメージ表示に、これが役立つと考える人もいます。

@item (edge-detection :matrix @var{matrix} :color-adjust @var{adjust})
@cindex edge detection, images
一般的なエッジ検出アルゴリズムを指定する。@var{matrix}は数値からなる9要素のリストかベクターでなければならない。変換されたイメージ内の位置@math{x/y}にあるピクセルは、その位置周辺にある元のピクセルから計算される。@var{matrix}は@math{x/y}に近接する各ピクセルにたいして、そのピクセルが変換先ピクセルに影響するファクター(factor:
要因)を指定する。以下のように要素@math{0}は@math{x-1/y-1}にあるピクセルのファクター、要素@math{1}は@math{x/y-1}にあるピクセルにたいするファクター、...を指定する。
@iftex
@tex
$$\pmatrix{x-1/y-1 & x/y-1  & x+1/y-1 \cr
   x-1/y  &   x/y &    x+1/y \cr
   x-1/y+1&   x/y+1 &  x+1/y+1 \cr}$$
@end tex
@end iftex
@ifnottex
@display
  (x-1/y-1  x/y-1  x+1/y-1
   x-1/y    x/y    x+1/y
   x-1/y+1  x/y+1  x+1/y+1)
@end display
@end ifnottex

結果となるピクセルは周辺ピクセルのRGB値を合計したカラーを指定されたファクターで乗じて、その合計をファクター絶対値の合計で除した色強度から計算される。

ラプラスエッジ検出は現在のところは以下のマトリクス
@iftex
@tex
$$\pmatrix{1 & 0 & 0 \cr
   0&  0 &  0 \cr
   0 & 0 & -1 \cr}$$
@end tex
@end iftex
@ifnottex
@display
  (1  0  0
   0  0  0
   0  0 -1)
@end display
@end ifnottex

エンボスエッジ検出(Emboss edge-detection)は以下のマトリクスを使用する
@iftex
@tex
$$\pmatrix{ 2 & -1 &  0 \cr
   -1 &  0 &  1 \cr
    0  & 1 & -2 \cr}$$
@end tex
@end iftex
@ifnottex
@display
  ( 2 -1  0
   -1  0  1
    0  1 -2)
@end display
@end ifnottex

@item disabled
イメージが無効(disabled)に見えるよう変換することを指定する。
@end table

@item :mask @var{mask}
@var{mask}が@code{heuristic}か@code{(heuristic
@var{bg})}なら、フレームのバックグラウンドがイメージ背後に見えるようにイメージのクリッピングマスクを構築する。@var{bg}が未指定か@code{t}なら、イメージ4隅に最頻するカラーをそのイメージのバックグラウンドカラーとみなしてバックグラウンドカラーを決定する。それ以外なら@var{bg}はイメージのバックグラウンドとみなすべきカラーを指定するリスト@code{(@var{red}
@var{green} @var{blue})}でなければならない。

@var{mask}が@code{nil}なら、イメージがマスクをもつ場合にはマスクを削除する。マスクを含むフォーマットのイメージは@code{:mask
nil}を指定することにより削除される可能性がある。

@item :pointer @var{shape}
これはマウスポインターがそのイメージ上にある際のポインターシェイプを指定する。利用可能なポインターシェイプについては@ref{Pointer
Shape}を参照のこと。

@item :map @var{map}
@cindex image maps
これはイメージに@dfn{ホットスポット(hot spots)}のイメージマップを関連付ける。

イメージマップは各要素が@code{(@var{area} @var{id}
@var{plist})}という形式をもつalist。@var{area}にはrectangle(矩形)、circle(円)、またはpolygon(ポリゴン、多角形)のいずれかを指定する。

rectangleは矩形エリアの左上隅と右下隅のピクセル座標を指定するコンス@code{(rect . ((@var{x0} . @var{y0})
. (@var{x1} . @var{y1})))}。

circleは円の中心と半径を指定するコンス@code{(circle . ((@var{x0} . @var{y0})
. @var{r}))}。@var{r}は整数か浮動小数点数。

polygonは各ペアーが多角形の1つの頂点を記述するコンス@code{(poly . [@var{x0} @var{y0} @var{x1}
@var{y1} ...])}。

マウスポインターがホットスポット上にある際には、ホットスポットの@var{plist}が参照される。これが@code{help-echo}プロパティを含むならそのホットスポットのツールチップ、@code{pointer}プロパティを含む場合はマウスカーソルがホットスポット上にあるときのマウスカーソルのシェイプを指定する。利用可能なポインターシェイプについては@ref{Pointer
Shape}を参照のこと。

マウスポインターがホットスポット上にあるときにマウスをクリックしたときのイベントは、ホットスポットの@var{id}とマウスイベントを組み合わせて構成される。たとえばホットスポットの@var{id}が@code{area4}なら@code{[area4
mouse-1]}。
@end table

@defun image-mask-p spec &optional frame
この関数はイメージ@var{spec}がマスクビットマップをもつなら@code{t}をリターンする。@var{frame}はそのイメージが表示されるフレーム。@var{frame}が@code{nil}か省略された場合には選択されたフレームが使用される(@ref{Input
Focus}を参照)。
@end defun

@defun image-transforms-p &optional frame
この関数は@var{frame}がイメージのスケーリングとローテーションをサポートすれば非@code{nil}をリターンする。@var{frame}が@code{nil}か省略なら選択されたフレームの使用を意味する(@ref{Input
Focus}を参照)。リターンされるリストには何のイメージ変換操作がサポートされるかを示すシンボルが含まれる:

@table @code
@item scale
@var{frame}は@code{:scale}、@code{:width}、@code{:height}、@code{:max-width}、@code{:max-height}のプロパティを通じたイメージスケーリングをサポートする。
@item rotate90
@var{frame}はローテーション角度が90°の整数倍ならイメージローテーションをサポートする。
@end table

イメージ変換がサポートされていなければ@code{:rotation}、@code{:crop}、@code{:width}、@code{:height}、@code{:scale}、@code{:max-width}、@code{:max-height}は(利用可能なら)ImageMagickを通じた場合のみ使用可能(@ref{ImageMagick
Images}を参照)。
@end defun
@node XBM Images
@subsection XBMイメージ
@cindex XBM

  XBMフォーマットを使用するにはイメージタイプとして@code{xbm}を指定します。このイメージフォーマットは外部ライブラリーを要求せず、このタイプのイメージは常にサポートされます。

  @code{xbm}イメージタイプにたいして追加のイメージプロパティがサポートされます:

@table @code
@item :foreground @var{foreground}
値@var{foreground}はそのイメージのフォアグラウンドカラーを指定する文字列、またはデフォルトカラーを指定する@code{nil}であること。このカラーはXBM内の1の各ピクセルに使用される。デフォルトはフレームのフォアグラウンドカラー。

@item :background @var{background}
値@var{background}はそのイメージのバックグラウンドカラーを指定する文字列、またはデフォルトカラーを指定する@code{nil}であること。このカラーはXBM内の0の各ピクセルに使用される。デフォルトはフレームのバックグラウンドカラー。
@end table

  外部ファイルのかわりにEmacs内のデータを指定してXBMイメージを指定するには以下の3つのプロパティを使用する:

@table @code
@item :data @var{data}
値@var{data}はイメージのコンテンツを指定する。@var{data}として使用できる3つのフォーマットが存在する:

@itemize @bullet
@item
それぞれがイメージの1ラインを指定するような文字列ベクターかboolベクター。@code{:height}と@code{:width}を指定する。

@item
文字列ならXBMファイルが含むのと同じバイトシーケンスを含む。この場合は@code{:height}と@code{:width}を指定してはならない。これらを省略することが、そのデータがXBMファイルのフォーマットをもつことを示すからである。イメージの高さと幅はファイルのコンテンツにより指定される。

@item
イメージのビットを含む文字列かboolベクター(終端の使用されない余分なビットを含むかもしれない)。少なくとも@w{@code{@var{stride}
*
@var{height}}}ビットを含むこと(@var{stride}はイメージ幅以上の8の最小倍数)。この場合にはその文字列がXBMファイル全体ではなく、単にビットだけを含むことを示すとともに、そのイメージのサイズを指定するために@code{:height}、@code{:width}、@code{:stride}を指定する必要がある。
@end itemize

@item :width @var{width}
値@var{width}はピクセル単位でイメージの幅を指定する。

@item :height @var{height}
値@var{height}はピクセル単位でイメージの高さを指定する。

@code{:width}と@code{:height}は幅と高さを指定しないデータ(イメージビットを含んだ文字列やベクター)を渡された場合のみ使用できることに注意。@acronym{XBM}ファイルは通常は自身でこれらを指定するので、これらのファイルにたいしてこれら2つのプロパティを使用するとエラーになる。更に@code{:width}と@code{:height}は他のほとんどのイメージフォーマットにおいて、表示するイメージが何であるか(通常は何らかのスケーリングを行うことを意味する)を指定するために使用されることにも注意。これは@acronym{XBM}イメージではサポートされない。

@item :stride @var{stride}
各行に格納さたブールベクターのエントリー数(@var{width}以上の8の最小倍数)。
@end table

@node XPM Images
@subsection XPMイメージ
@cindex XPM

  XPMフォーマットを使用するにはイメージタイプに@code{xpm}を指定します。@code{xpm}イメージタイプでは追加のプロパティ@code{:color-symbols}にも意味があります。

@table @code
@item :color-symbols @var{symbols}
値@var{symbols}は要素が@code{(@var{name}
.
@var{color})}という形式をもつようなalistであること。各要素において@var{name}はイメージファイル内に出現するカラー名、@var{color}はそのカラー名の実際の表示に使用するカラーを指定する。
@end table

@node ImageMagick Images
@subsection ImageMagickイメージ
@cindex ImageMagick images
@cindex images, support for more formats

  ImageMagickのサポートつきのEmacsビルドでは、多くくのイメージフォーマットをロードするためにImageMagickライブラリーを使用できます(@ref{File
Conveniences,,, emacs, The GNU Emacs
Manual}を参照)。ImageMagickを通じてロードしたイメージのイメージタイプシンボルは、基礎となる実際のイメージフォーマットとは無関係に@code{imagemagick}になります。

ImageMagickサポートをチェックするには以下を使用してください:

@lisp
(image-type-available-p 'imagemagick)
@end lisp

@defun imagemagick-types
この関数はカレントのImageMagickインストールによりサポートされるイメージファイル拡張子のリストをリターンする。リストの各要素は@file{.bmp}イメージは@code{BMP}のような、イメージタイプにたいして内部的なImageMagick名を表すシンボル。
@end defun

@defopt imagemagick-enabled-types
この変数の値はEmacsがImageMagickを使用してレンダリングを試みるかもしれないImageMagickイメージタイプのリスト。リストの各要素は@code{imagemagick-types}がリターンするリスト内のシンボルのいずれか、または等価な文字列。もしくは値@code{t}はImageMagickにたいして利用できるすべてのイメージタイプを有効にする。この変数の値とは関係なく@code{imagemagick-types-inhibit}
(以下参照)が優先される。
@end defopt

@defopt imagemagick-types-inhibit
この変数の値は@code{imagemagick-enabled-types}の値とは無関係に、ImageMagickを使用して決してレンダリングされることのないImageMagickイメージタイプのリスト。値@code{t}はImageMagickを完全に無効にする。
@end defopt

@defvar image-format-suffixes
この変数はイメージタイプをファイル名拡張子にマッピングするalist。EmacsはImageMagickライブラリーにイメージのタイプに関するヒントを与えるために、この変数と@code{:format}イメージプロパティ(以下参照)を組み合わせて使用する。各要素は@code{(@var{type}
@var{extension})}という形式をもち@var{type}はイメージのcontent-typeを指定するシンボル、@var{extension}は関連付けられるファイル名拡張子を指定する文字列。
@end defvar

  ImageMagickによりロードされたイメージは、追加で以下のイメージディスクリプタプロパティをサポートします:

@table @code
@item :background @var{background}
@var{background}が非@code{nil}なら、カラーを指定する文字列であること。これはイメージが透明度をサポートする場合に、イメージのバックグラウンドカラーとして使用される。値が@code{nil}の場合のデフォルトはフレームのバックグラウンドカラー。

@item :format @var{type}
値@var{type}は@code{image-format-suffixes}で見られるような、イメージのタイプを指定するシンボルであること。これはイメージが関連付けられたファイル名をもたない際に、イメージタイプを検出する助けとなるヒントをImageMagickに提供する。

@item :crop @var{geometry}
@var{geometry}の値は@code{(@var{width} @var{height} @var{x}
@var{y})}という形式のリストであること。@var{width}と@var{height}はクロップするイメージの幅と高さを指定する。@var{x}が正の数値なら元イメージの左エッジ、負の数値なら右エッジからクロップのオフセットを指定する。@var{y}が正の数値なら元イメージの上エッジ、負の数値なら下エッジからクロップのオフセットを指定する。@var{x}か@var{y}が@code{nil}か未指定ならクロップ領域は元イメージの中央になる。

クロップ領域がイメージ外部、またはエッジとオーバーラップする場合には、イメージ外部の全領域を除外するように縮小される。これは@var{width}や@var{height}に大きな値を与えてイメージサイズを増加するために@code{:crop}を使用できないことを意味する。

クロッピングはスケーリング後、ローテーション前に行われる。
@end table

@node SVG Images
@subsection SVGイメージ
@cindex SVG images

SVG (Scalable Vector Graphics) is an XML format for specifying images.  SVG
images support the following additional image descriptor properties:

@table @code
@item :foreground @var{foreground}
@var{foreground}, if non-@code{nil}, should be a string specifying a color,
which is used as the image's foreground color.  If the value is @code{nil},
it defaults to the current face's foreground color.

@item :background @var{background}
@var{background}, if non-@code{nil}, should be a string specifying a color,
which is used as the image's background color if the image supports
transparency.  If the value is @code{nil}, it defaults to the current face's
background color.

@item :css @var{css}
@var{css}が非@code{nil}なら、イメージ生成時に使用されるデフォルトCSSをオーバーライドするCSSを指定する文字列であること。
@end table

@subsubheading SVG library

If your Emacs build has SVG support, you can create and manipulate these
images with the following functions from the @file{svg.el} library.

@defun svg-create width height &rest args
指定したサイズで新たにSVGイメージを作成する。@var{args}はplist引数であり、以下を指定できる:

@table @code
@item :stroke-width
作成するすべてのラインのデフォルト幅(ピクセル単位)。

@item :stroke
作成するすべてのラインのデフォルトのストロークカラー。
@end table

@cindex SVG object
この関数は@dfn{SVGオブジェクト}
(SVGイメージを指定するLispデータ構造)をリターンする。以下の関数はすべてこのブジェクトにたいして機能する。以下の関数の引数@var{svg}はこのようなSVGオブジェクトを指定する。
@end defun

@defun svg-gradient svg id type stops
@var{svg}に識別子@var{id}でグラデーションを作成する。@var{type}はグラデーションタイプで@code{linear}か@code{radial}のいずれかを指定する。@var{stops}はパーセント割合/カラーのペアからなるリスト。

以下は最初の赤から25%の緑、最後は青に至る線形グラデーションを作成する:

@lisp
(svg-gradient svg "gradient1" 'linear
              '((0 . "red") (25 . "green") (100 . "blue")))
@end lisp

作成(およびSVGオブジェクトに挿入)されたグラデーションは、後でシェイプを作成するすべての関数で使用できる。
@end defun

以下の関数はすべてさまざまな属性のデフォルト値を変更するオプションのキーワードパラメーターを受け取ります。有効な属性には以下が含まれます:

@table @code
@item :stroke-width
ラインとソリッドシェイプ枠線の描画幅(ピクセル単位)。

@item :stroke-color
ラインとソリッドシェイプ枠線の描画カラー。

@item :fill-color
ラインとソリッドシェイプに使用するカラー。

@item :id
シェイプの識別子。

@item :gradient
与えられた場合には以前に定義されたグラデーションオブジェクトの識別子であること。

@item :clip-path
クリックパスの識別子。
@end table

@defun svg-rectangle svg x y width height &rest args
左上隅が位置@var{x}/@var{y}、サイズが@var{width}/@var{height}の矩形を@var{svg}に追加する。

@lisp
(svg-rectangle svg 100 100 500 500 :gradient "gradient1")
@end lisp
@end defun

@defun svg-circle svg x y radius &rest args
中央が位置@var{x}/@var{y}、半径が@var{radius}の円を@var{svg}に追加する。
@end defun

@defun svg-ellipse svg x y x-radius y-radius &rest args
中央が位置@var{x}/@var{y}、水平半径が@var{x-radius}、垂直半径が@var{y-radius}の楕円を@var{svg}に追加する。
@end defun

@defun svg-line svg x1 y1 x2 y2 &rest args
始点が@var{x1}/@var{y1}、終点が@var{x2}/@var{y2}の線を@var{svg}に追加する。
@end defun

@defun svg-polyline svg points &rest args
@var{points}
(XとYの位置ペアのリスト)を通過する複数セグメントラライン、いわゆる``ポリゴン(polyline)''を@var{svg}に追加する。

@lisp
(svg-polyline svg '((200 . 100) (500 . 450) (80 . 100))
              :stroke-color "green")
@end lisp
@end defun

@defun svg-polygon svg points &rest args
ポリゴン外周の位置XとYのペアからなるリストであるような@var{points}により記述されるポリゴンを@var{svg}に追加する。

@lisp
(svg-polygon svg '((100 . 100) (200 . 150) (150 . 90))
             :stroke-color "blue" :fill-color "red")
@end lisp
@end defun

@defun svg-path svg commands &rest args
@var{commands}に応じて@var{svg}にシェイプのアウトラインを追加する。@ref{SVG Path Commands}を参照のこと。

デフォルトでは絶対座標。最後(または最初)の位置を基準に相対座標を指定するには、属性@var{:relative}に@code{t}をセットする。この属性は関数や個々のcommandsにたいして指定できる。関数に指定された場合には、すべてのcommandsはデフォルトで相対座標を使用する。個々のcommandsに絶対座標を使用させるなら、@var{:relative}に@code{nil}をセットする。

@lisp
(svg-path svg
	  '((moveto ((100 . 100)))
	    (lineto ((200 . 0) (0 . 200) (-200 . 0)))
	    (lineto ((100 . 100)) :relative nil))
	  :stroke-color "blue"
	  :fill-color "lightblue"
	  :relative t)
@end lisp
@end defun

@defun svg-text svg text &rest args
指定した@var{text}を@var{svg}に追加する。

@lisp
(svg-text
 svg "This is a text"
 :font-size "40"
 :font-weight "bold"
 :stroke "black"
 :fill "white"
 :font-family "impact"
 :letter-spacing "4pt"
 :x 300
 :y 400
 :stroke-width 1)
@end lisp
@end defun

@defun svg-embed svg image image-type datap &rest args
埋め込みの(ラスター)イメージを@var{svg}に追加する。@var{datap}が@code{nil}なら@var{image}はファイル名、それ以外なら@var{image}はイメージデータをrawバイトとして含む文字列であること。@var{image-type}は@code{"image/jpeg"}のような@acronym{MIME}イメージタイプであること。

@lisp
(svg-embed svg "~/rms.jpg" "image/jpeg" nil
           :width "100px" :height "100px"
           :x "50px" :y "75px")
@end lisp
@end defun

@defun svg-embed-base-uri-image svg relative-filename &rest args
@var{svg}に@var{relative-filename}にある埋め込み(ラスター)イメージを追加する。@var{relative-filename}はsvgのイメージプロパティ@code{:base-uri}の@code{file-name-directory}内部で検索される。@code{:base-uri}は作成する(存在しないかもしれない)svgイメージのファイル名を指定するので、すべての埋め込みファイルは@code{:base-uri}ファイル名の電子に相対的に検索される。@code{:base-uri}が省略された場合には、svgイメージをロードするファイル名を使用する。@code{svg-embed}と比較してlibrsvgが処理を直接行うので、@code{:base-uri}の使用は巨大なイメージの埋め込みの効率を改善する。

@lisp
;; Embeding /tmp/subdir/rms.jpg and /tmp/another/rms.jpg
(svg-embed-base-uri-image svg "subdir/rms.jpg"
           :width "100px" :height "100px"
           :x "50px" :y "75px")
(svg-embed-base-uri-image svg "another/rms.jpg"
           :width "100px" :height "100px"
           :x "75px" :y "50px")
(svg-image svg :scale 1.0
           :base-uri "/tmp/dummy"
           :width 175 :height 175)
@end lisp
@end defun

@defun svg-clip-path svg &rest args
@var{svg}にクリッピングパスを追加する。@var{:clip-path}プロパティを通じてシェイプに適用された場合には、クリッピング外部のシェイプ部分は描画されない。

@lisp
(let ((clip-path (svg-clip-path svg :id "foo")))
  (svg-circle clip-path 200 200 175))
(svg-rectangle svg 50 50 300 300
               :fill-color "red"
               :clip-path "url(#foo)")
@end lisp
@end defun

@defun svg-node svg tag &rest args
カスタムノード@var{tag}を@var{svg}に追加する。

@lisp
(svg-node svg
          'rect
          :width 300 :height 200 :x 50 :y 100 :fill-color "green")
@end lisp
@end defun

@defun svg-remove svg id
@code{svg}から識別子@code{id}の要素を取り除く。
@end defun

@defun svg-image svg
最後に@code{svg-image}は引数としてSVGを受け取り、@code{insert-image}のような関数での使用に適したイメージオブジェクトをリターンする。
@end defun

以下は円のイメージを作成して挿入する完全な例です:

@lisp
(let ((svg (svg-create 400 400 :stroke-width 10)))
  (svg-gradient svg "gradient1" 'linear '((0 . "red") (100 . "blue")))
  (svg-circle svg 200 200 100 :gradient "gradient1"
                  :stroke-color "green")
  (insert-image (svg-image svg)))
@end lisp


@subsubheading SVG Path Commands

@cindex svg path commands
@anchor{SVG Path Commands}
@dfn{SVGパス(SVG paths)}によりライン(lines: 線)、カーブ(curves: 曲線)、アーク(arcs:
円弧)、またはその他の基本的なシェイプを組み合わせて複雑なイメージを作成できます。以下に説明する関数でLispプログラムからSVGパスコマンドを呼び出すことができます。

@deffn Command moveto points
@var{points}の最初のポイントにペンを移動する。それ以降のポイントはラインで接続される。@var{points}はXY座標ペアのリスト。後続の@command{moveto}コマンドは新たな@dfn{サブパス(subpath)}の開始を表す。

@lisp
(svg-path svg '((moveto ((200 . 100) (100 . 200) (0 . 100))))
          :fill "white" :stroke "black")
@end lisp
@end deffn

@deffn Command closepath
サブパスの初期ポイントに接続することによりカレントのサブパスを終了する。ラインは接続に沿って描画される。

@lisp
(svg-path svg '((moveto ((200 . 100) (100 . 200) (0 . 100)))
                (closepath)
                (moveto ((75 . 125) (100 . 150) (125 . 125)))
                (closepath))
          :fill "red" :stroke "black")
@end lisp
@end deffn

@deffn Command lineto points
カレントのポイントから@var{points}
(XY位置ペアのリスト)の最初の要素にラインを描画する。複数ポイントを指定するとポリライン(polyline: 折れ線)を描画する。
@lisp
(svg-path svg '((moveto ((200 . 100)))
                (lineto ((100 . 200) (0 . 100))))
          :fill "yellow" :stroke "red")
@end lisp
@end deffn

@deffn Command horizontal-lineto x-coordinates
カレントポイントから@var{x-coordinates}の最初の要素へ水平ラインを描画する。通常は無意味だが複数座標の指定は可能。

@lisp
(svg-path svg '((moveto ((100 . 200)))
                (horizontal-lineto (300)))
          :stroke "green")
@end lisp
@end deffn

@deffn Command vertical-lineto y-coordinates
垂直ラインを描画する。

@lisp
(svg-path svg '((moveto ((200 . 100)))
                (vertical-lineto (300)))
          :stroke "green")
@end lisp
@end deffn

@deffn Command curveto coordinate-sets
@var{coordinate-sets}の最初の要素を使用して、カレントポイントからベジェ曲線(cubic Bézier
curve)を描画する。複数の座標セットがあればポリベジェ(polybezier:
複数のベジェ曲線)を描画する。座標セットはそれぞれ@code{(@var{x1} @var{y1} @var{x2} @var{y2} @var{x}
@var{y})}という形式のリストであり、@w{(@var{x}, @var{y})}はカーブの終点。@w{(@var{x1},
@var{y1})}と@w{(@var{x2}, @var{y2})}はそれぞれ先頭ポイントと終点ポイントを制御する。

@lisp
(svg-path svg '((moveto ((100 . 100)))
                (curveto ((200 100 100 200 200 200)
                          (300 200 0 100 100 100))))
          :fill "transparent" :stroke "red")
@end lisp
@end deffn

@deffn Command smooth-curveto coordinate-sets
@var{coordinate-sets}の最初の要素を使用して、カレントポイントから三次ベジェ曲線(cubic Bézier
curve)を描画する。複数の座標セットがあればポリベジェ(polybezier:
複数のベジェ曲線)を描画する。座標セットはそれぞれ@code{(@var{x2} @var{y2} @var{x}
@var{y})}という形式のリストであり、@w{(@var{x}, @var{y})}はカーブの終点、@w{(@var{x2},
@var{y2})}は対応するコントロールポイント。前のコマンドが@command{curveto}か@command{smooth-curveto}なら、そのコマンドの2つ目のコントロールポイントのカレントポイントから相対的なリフレクション(reflection)。それ以外なら最初のコントロールポイントはカレントポイントと一致する。

@lisp
(svg-path svg '((moveto ((100 . 100)))
                (curveto ((200 100 100 200 200 200)))
                (smooth-curveto ((0 100 100 100))))
          :fill "transparent" :stroke "blue")
@end lisp
@end deffn

@deffn Command quadratic-bezier-curveto coordinate-sets
@var{coordinate-sets}の最初の要素を使用して、カレントポイントから二次ベジェ曲線(quadratic Bézier
curve)を描画する。複数の座標セットがあればポリベジェ(polybezier:
複数のベジェ曲線)を描画する。座標セットはそれぞれ@code{(@var{x1} @var{y1} @var{x}
@var{y})}という形式のリストであり、@w{(@var{x}, @var{y})}はカーブの終点、@w{(@var{x1},
@var{y1})}はコントロールポイント。

@lisp
(svg-path svg '((moveto ((200 . 100)))
                (quadratic-bezier-curveto ((300 100 300 200)))
                (quadratic-bezier-curveto ((300 300 200 300)))
                (quadratic-bezier-curveto ((100 300 100 200)))
                (quadratic-bezier-curveto ((100 100 200 100))))
          :fill "transparent" :stroke "pink")
@end lisp
@end deffn

@deffn Command smooth-quadratic-bezier-curveto coordinate-sets
@var{coordinate-sets}の最初の要素を使用して、カレントポイントから二次ベジェ曲線(quadratic Bézier
curve)を描画する。複数の座標セットがあればポリベジェ(polybezier:
複数のベジェ曲線)を描画する。座標セットはそれぞれ@code{(@var{x} @var{y})}という形式のリストであり、@w{(@var{x},
@var{y})}はカーブの終点。前のコマンドが@command{quadratic-bezier-curveto}か@command{smooth-quadratic-bezier-curveto}なら、そのコマンドのコントロールポイントのカレントポイントから相対的なリフレクション(reflection)。それ以外なら最初のコントロールポイントはカレントポイントと一致する。

@lisp
(svg-path svg '((moveto ((200 . 100)))
                (quadratic-bezier-curveto ((300 100 300 200)))
                (smooth-quadratic-bezier-curveto ((200 300)))
                (smooth-quadratic-bezier-curveto ((100 200)))
                (smooth-quadratic-bezier-curveto ((200 100))))
          :fill "transparent" :stroke "lightblue")
@end lisp
@end deffn

@deffn Command elliptical-arc coordinate-sets
@var{coordinate-sets}の最初の要素を使用して、カレントポイントから楕円弧(elliptical
arc)を描画する。複数の座標セットがあれば一連の楕円弧を描画する。座標セットはそれぞれ@code{(@var{rx} @var{ry} @var{x}
@var{y})}という形式のリストであり、@w{(@var{x}, @var{y})}は楕円の終点、@w{(@var{rx},
@var{ry})}は楕円の半径。リストに属性を追加できる:

@table @code
@item :x-axis-rotation
カレントの座標システムのX軸から相対的にローテートされた楕円X軸の度数角度。

@item :large-arc
@code{t}にセットすると、180°以上のアークスイープ(arc sweep)を描画する。それ以外なら180°以下のアークスイープを描画する。

@item :sweep
@code{t}にセットすると@dfn{正の角度方向(positive angle
direction)}、それ以外なら@dfn{負の角度方向(negative angle direction)}にアークを描画する。
@end table

@lisp
(svg-path svg '((moveto ((200 . 250)))
                (elliptical-arc ((75 75 200 350))))
          :fill "transparent" :stroke "red")
(svg-path svg '((moveto ((200 . 250)))
                (elliptical-arc ((75 75 200 350 :large-arc t))))
          :fill "transparent" :stroke "green")
(svg-path svg '((moveto ((200 . 250)))
                (elliptical-arc ((75 75 200 350 :sweep t))))
          :fill "transparent" :stroke "blue")
(svg-path svg '((moveto ((200 . 250)))
                (elliptical-arc ((75 75 200 350 :large-arc t
                                     :sweep t))))
          :fill "transparent" :stroke "gray")
(svg-path svg '((moveto ((160 . 100)))
                (elliptical-arc ((40 100 80 0)))
                (elliptical-arc ((40 100 -40 -70
                                     :x-axis-rotation -120)))
                (elliptical-arc ((40 100 -40 70
                                     :x-axis-rotation -240))))
          :stroke "pink" :fill "lightblue"
          :relative t)
@end lisp
@end deffn


@node Other Image Types
@subsection その他のイメージタイプ
@cindex PBM

  PBMイメージにはイメージタイプ@code{pbm}を指定します。カラー、グレースケール、およびモノクロのイメージがサポートされます。モノクロのPBMイメージにたいしては、2つの追加イメージプロパティがサポートされます。

@table @code
@item :foreground @var{foreground}
値@var{foreground}はイメージのフォアグラウンドカラーを指定する文字列、またはデフォルトカラーなら@code{nil}であること。このカラーはPBM内の1であるようなピクセルすべてに使用される。デフォルトはフレームのフォアグラウンドカラー。

@item :background @var{background}
値@var{background}はイメージのバックグラウンドカラーを指定する文字列、またはデフォルトカラーなら@code{nil}であること。このカラーはPBM内の0であるようなピクセルすべてに使用される。デフォルトはフレームのバックグラウンドカラー。
@end table

@noindent
Emacsがサポート可能な残りのイメージタイプは以下のとおり:

@table @asis
@item GIF
イメージタイプ@code{gif}。@code{:index}プロパティをサポートする。@ref{Multi-Frame Images}を参照のこと。

@item JPEG
イメージタイプ@code{jpeg}。

@item PNG
イメージタイプ@code{png}。

@item TIFF
イメージタイプ@code{tiff}。@code{:index}プロパティをサポートする。@ref{Multi-Frame Images}を参照のこと。
@end table

@node Defining Images
@subsection イメージの定義
@cindex define image

  関数@code{create-image}、@code{defimage}、@code{find-image}はイメージディスクリプタを作成するための便利な手段を提供します。

@defun create-image file-or-data &optional type data-p &rest props
この関数は@var{file-or-data}内のデータを使用するイメージディスクリプタを作成してリターンする。@var{file-or-data}はファイル名、またはイメージデータを含む文字列を指定できる。前者なら@var{data-p}は@code{nil}、後者なら非@code{nil}であること。

オプション引数@var{type}はイメージタイプを指定するシンボル。@var{type}が省略か@code{nil}なら、@code{create-image}はファイル先頭の数バイトかファイル名からイメージタイプの判断を試みる。

残りの引数@var{props}は追加のイメージプロパティを指定する。たとえば、

@c ':heuristic-mask' is not documented?
@example
(create-image "foo.xpm" 'xpm nil :heuristic-mask t)
@end example

この関数はそのタイプのイメージがサポートされていなければ@code{nil}、それ以外ならイメージディスクリプタをリターンする。
@end defun

@defmac defimage symbol specs &optional doc
このマクロはイメージマクロとして@var{symbol}を定義する。引数@var{specs}はイメージの表示方法を指定するリストである。3つ目の引数@var{doc}はオプションのドキュメント文字列。

@var{specs}内の各要素はプロパティリストの形式をもち、それぞれが少なくとも@code{:type}プロパティと、@code{:file}か@code{:data}いずれかのプロパティをもつこと。@code{:type}の値はイメージタイプを指定するシンボル、@code{:file}の値はイメージをロードするファイル、@code{:data}の値は実際のイメージデータを含む文字列であること。以下は例:

@example
(defimage test-image
  ((:type xpm :file "~/test1.xpm")
   (:type xbm :file "~/test1.xbm")))
@end example

@code{defimage}はそれが使用可能か、つまりそのタイプがサポートされているかとファイルが存在するかを確認するために各要素を1つずつテストする。最初に使用可能な引数が@var{symbol}内に格納するイメージディスクリプタを作成するために使用される。

機能する候補がなければ@var{symbol}は@code{nil}として定義される。
@end defmac

@defun image-property image property
@var{image}の@var{property}の値をリターンする。プロパティは@code{setf}を使用してセットできる。プロパティに@code{nil}をセットすることによりイメージからプロパティを削除できる。
@end defun

@defun find-image specs
この関数はイメージ仕様@var{specs}のリストの1つを満足するイメージを探すための、便利な手段を提供する。

@var{specs}内の各仕様はイメージタイプに応じた内容のプロパティリストである。すべての仕様は少なくとも@code{:type
@var{type}}、および@w{@code{:file @var{file}}}か@w{@code{:data
@var{data}}}のいずれかのプロパティを含まなければならない。ここで@var{type}は@code{xbm}のようにイメージタイプを指定するシンボル、@var{file}はイメージをロードするファイル、@var{data}は実際のイメージデータを含む文字列。このリスト内で@var{type}がサポートされていて、かつ@var{file}が存在する最初の仕様が、リターンされるイメージ仕様の構築に使用される。満足する仕様がなければ@code{nil}がリターンされる。

イメージは@code{image-load-path}内で検索される。
@end defun

@defopt image-load-path
この変数の値はイメージファイルを検索する場所のリスト。要素が文字列か値が文字列であるような変数シンボルなら、その文字列が検索を行うディレクトリーの名前になる。値がリストであるような変数シンボルの場合、それは検索を行うディレクトリーのリストとなる。

デフォルトでは@code{data-directory}で指定されたディレクトリーのサブディレクトリー@file{images}、次に@code{data-directory}で指定されたディレクトリー、最後に@code{load-path}で指定されたディレクトリー内を検索する。サブディレクトリーは自動的には検索に含まれないので、イメージファイルをサブディレクトリー内に配置した場合には、サブディレクトリーを明示的に与える必要がある。たとえば@code{data-directory}内でイメージ@file{images/foo/bar.xpm}を見つけるには以下のようにそのイメージを指定すること:

@example
(defimage foo-image '((:type xpm :file "foo/bar.xpm")))
@end example
@end defopt

@defun image-load-path-for-library library image &optional path no-error
この関数はLispパッケージ@var{library}により使用されるイメージにたいして適切な検索パスをリターンする。

この関数はまず@code{image-load-path}
(@file{@code{data-directory}/images}を除外)を使用し、次に@code{load-path}の後に@var{library}にとって適切なパス(ライブラリーファイル自身にたいする相対パス@file{../../etc/images}と@file{../etc/images}を含む)を補い、最後に@file{@code{data-directory}/images}から@var{image}を検索する。

それからこの関数は先頭に@var{image}が見つかったディレクトリー、その後に@code{load-path}の値が続くディレクトリーのリストをリターンする。@var{path}が与えられたら@code{load-path}のかわりに使用する。

@var{no-error}が非@code{nil}、かつ適切なパスが見つからない場合にはエラーをシグナルしない。かわりに前記のディレクトリーリストをリターンするが、イメージのディレクトリーの箇所に@code{nil}が出現する点が異なる。

以下は@code{image-load-path-for-library}の使用例:

@example
(defvar image-load-path) ; shush compiler
(let* ((load-path (image-load-path-for-library
                    "mh-e" "mh-logo.xpm"))
       (image-load-path (cons (car load-path)
                              image-load-path)))
  (mh-tool-bar-folder-buttons-init))
@end example
@end defun

@vindex image-scaling-factor
イメージは@code{image-scaling-factor}変数にもとづいて作成時に自動的にスケーリングされます。この値は浮動小数点数(1より大きい値はサイズの拡大、小さい値はサイズの縮小を意味する)、またはフォントのピクセルサイズにもとづいたスケーリング倍率で計算を行うシンボル@code{auto}のいずれかです。

@node Showing Images
@subsection イメージの表示
@cindex show image

  自分で@code{display}プロパティをセットアップしてイメージディスクリプタを使用できますが、このセクションの関数を使用するほうがより簡単です。

@defun insert-image image &optional string area slice
この関数はカレントバッファーのポイント位置に@var{image}を挿入する。@var{image}はイメージディスクリプタであること。これは@code{create-image}によりリターンされた値、または@code{defimage}で定義されたシンボルの値を使用できる。引数@var{string}はイメージを保持するためにバッファー内に配置するテキストを指定する。これが省略か@code{nil}なら、@code{insert-image}はデフォルトで@code{"
"}を使用する。

引数@var{area}はマージン内にイメージを置くかどうかを指定する。これが@code{left-margin}なら左マージンにイメージが表示され、@code{right-margin}なら右マージンを指定する。@var{area}が@code{nil}か省略なら、イメージはバッファーのテキスト内のポイント位置に表示される。

引数@var{slice}は挿入するイメージのスライスを指定する。@var{slice}が@code{nil}か省略された場に合はイメージ全体が挿入される。それ以外では、@var{slice}がリスト@code{(@var{x}
@var{y} @var{width}
@var{height})}なら@var{x}と@var{y}は位置、@var{width}と@var{height}は挿入するイメージの領域を指定する。整数値はピクセル単位。0.0から1.0までの浮動小数点数はイメージ全体の幅や高さにたいする割合を指定する。

この関数は内部的にはバッファー内に@var{string}を挿入して、@var{image}を指定する@code{display}プロパティにそれを渡す。@ref{Display
Property}を参照のこと。
@end defun

@cindex slice, image
@cindex image slice
@defun insert-sliced-image image &optional string area rows cols
この関数は@code{insert-image}と同様にカレントバッファー内に@var{image}を挿入するが、イメージを@var{rows}✕@var{cols}の同一サイズのスライスに分割する点が異なる。

Emacsは各スライスを個別のイメージとして表示して、(巨大な)イメージを表示するバッファーのページングの際にイメージ全体を上下にジャンプするのではなく、より直感的な上下スクロールが可能になる。
@end defun

@defun put-image image pos &optional string area
この関数はカレントバッファー内の@var{pos}の前にイメージ@var{image}を配置する。引数@var{pos}は整数かマーカーであること。これはイメージが表示されるべきバッファー位置を指定する。引数@var{string}は代替として表示されるべきデフォルトのイメージを保持するテキストであること。

引数@var{image}はイメージディスクリプタでなければならず、それは@code{create-image}がリターンされたか、あるいは@code{defimage}により格納されたイメージディスクリプタかもしれない。

引数@var{area}はマージン内にイメージを置くかどうかを指定する。これが@code{left-margin}なら左マージンにイメージが表示され、@code{right-margin}なら右マージンを指定する。@var{area}が@code{nil}か省略なら、イメージはバッファーのテキスト内のポイント位置に表示される。

内部的には、この関数はオーバーレイを作成して、値がそのイメージであるような@code{display}プロパティをもつテキストを含む、@code{before-string}プロパティをそのオーバーレイに与えている(なんと!)。
@end defun

@defun remove-images start end &optional buffer
この関数は@var{buffer}の位置@var{start}と@var{end}の間のイメージを削除する。@var{buffer}が省略か@code{nil}ならカレントバッファーからイメージを削除する。

これは@code{put-image}が行う方法で@var{buffer}に配置されたイメージだけを削除して、@code{insert-image}や他の方法で挿入されたイメージは削除しない。
@end defun

@defun image-size spec &optional pixels frame
@cindex size of image
この関数はペアー@w{@code{(@var{width}
.
@var{height})}}としてイメージのサイズをリターンする。@var{spec}はイメージspec。@var{pixels}が非@code{nil}ならピクセル単位、それ以外なら@var{frame}のデフォルトの文字サイズ単位で量ったサイズをリターンする(@ref{Frame
Font}を参照)。@var{frame}はイメージが表示されるフレーム。@var{frame}が@code{nil}または省略された場合には選択されたフレームを使用する(@ref{Input
Focus}を参照)。
@end defun

@defvar max-image-size
この変数はEmacsがロードするイメージの最大サイズを定義するために使用される。Emacsはこの制限より大きいイメージのロード(と表示)を拒絶するだろう。

値が整数ならピクセル単位で量ったイメージの最大の高さと幅を直接指定する。浮動小数点数ならフレームの高さと幅にたいする比率として、イメージの最大の高さと幅を指定する。値が数値でなければイメージサイズにたいする明示的な制限は存在しない。

この変数の目的は意図せずEmacsに不当に大きなイメージがロードされるとを防ぐことである。これはイメージの初回ロード時だけ効果がある。イメージが一度イメージキャッシュに置かれると、その後に@code{max-image-size}の値が変更されても、そのイメージは常に表示可能である(@ref{Image
Cache}を参照)。
@end defvar

上記の挿入関数で挿入されたイメージは、表示されたイメージを横断するテキスト(またはオーバーレイ)のプロパティ内にインストールされたローカルキーマップも取得します。このキーマップは以下のコマンドを定義します。

@table @kbd
@item +
イメージサイズを拡大する(@code{image-increase-size})。@samp{4}というプレフィクス値は40%のサイズ拡大を意味する。デフォルトは20%。

@item -
イメージサイズを縮小する(@code{image-increase-size})。@samp{4}というプレフィクス値は40%のサイズ縮小を意味する。デフォルトは20%。

@item r
イメージを時計回りに90°ローテートする(@code{image-rotate}。プレフィスを与えるとかわりに反時計回りに90°ローテートすることを意味する。

@item o
イメージをファイルに保存する(@code{image-save})。
@end table

@node Multi-Frame Images
@subsection マルチフレームのイメージ
@cindex multi-frame images

@cindex animation
@cindex image animation
@cindex image frames
複数のイメージを含むことができるイメージファイルがいくつかあります。わたしたちはこのような場合には、イメージ内に複数の``フレーム''があると表現しています。現在のところEmacsはGIF、TIFF、およびDJVMのような特定のImageMagickフォーマットにたいする複数フレームをサポートします。

フレームは複数のページを表現するため(通常はたとえばマルチフレームTIFFのケースが該当)、あるいはアニメーションを作成するため(通常はマルチフレームGIFファイルのケースが該当)に使用できます。

マルチフレームイメージは、表示されるフレームを指定する整数値(0から数える)が値であるようなプロパティ@code{:index}をもっています。

@defun image-multi-frame-p image
この関数は@var{image}が2つ以上のフレームを含めば非@code{nil}をリターンする。実際のリターン値はコンス@code{(@var{nimages}
.
@var{delay})}であり@var{nimages}はフレーム数、@var{delay}はフレーム間の遅延秒数、イメージが遅延を指定しなければ@code{nil}。通常はアニメーションを意図されたイメージはフレームの遅延を指定して、複数ページとして扱われることを意図したイメージは指定しない。
@end defun

@defun image-current-frame image
この関数は@var{image}にたいして0から数えたカレントフレーム番号のインデックスをリターンする。
@end defun

@defun image-show-frame image n &optional nocheck
この関数は@var{image}をフレーム番号@var{n}とスイッチする。@var{nocheck}が@code{nil}なら有効範囲外のフレーム番号を範囲終端に置き換える。@var{image}が指定された番号のフレームを含まなければイメージは中抜きの四角(hollow
box)で表示される。
@end defun

@defun image-animate image &optional index limit
この関数は@var{image}をアニメーション表示する。オプションの整数@var{index}は開始するフレームを指定する(デフォルトは0)。オプション引数@var{limit}はアニメーションの長さを制御する。これが省略か@code{nil}ならアニメーション回数は1回、@code{t}なら永久にループ表示する。数値ならその秒数後にアニメーションは停止する。
@end defun

@vindex image-minimum-frame-delay
@vindex image-default-frame-delay
@noindent Animation operates by means of a timer.  Note that Emacs imposes a
アニメーションはタイマーにより処理されます。Emacsは最小のフレーム遅延を0.01秒(
@code{image-minimum-frame-delay}の値)とすることに注意してください。そのイメージ自身が遅延を指定しなければEmacsは@code{image-default-frame-delay}を使用します。

@defun image-animate-timer image
この関数はもし存在すれば@var{image}のアニメーションに責任をもつタイマーをリターンする。
@end defun


@node Image Cache
@subsection イメージキャッシュ
@cindex image cache

  Emacsはイメージをより効果的に再表示できるようにイメージをキャッシュします。Emacsがイメージを表示する際には、既存のイメージ仕様が望む仕様と@code{equal}なイメージキャッシュを検索します。マッチが見つかったらイメージはキャッシュから表示され、それ以外ではイメージは通常のようにロードされます。

@defun image-flush spec &optional frame
この関数はフレーム@var{frame}のイメージキャッシュから仕様@var{spec}のイメージを削除する。イメージ仕様の比較には@code{equal}を使用する。@var{frame}が@code{nil}の場合のデフォルトは選択されたフレーム。@var{frame}が@code{t}ならイメージはすべての既存フレームでフラッシュされる。

Emacsの現実装では各グラフィカル端末はイメージキャッシュを処理して、それはその端末上のすべてのフレームにより共有される(@ref{Multiple
Terminals}を参照)。つまりあるフレームでイメージをリフレッシュすると、同一端末上の他のすべてのフレームでもリフレッシュされる。
@end defun

  @code{image-flush}の1つの用途はEmacsにイメージファイルの変更を伝えることです。イメージ仕様が@code{:file}プロパティを含む場合には、そのイメージの初回表示時にファイルコンテンツにもとづいてイメージがキャッシュされます。たとえその後にファイルが変更されても、Emacsはそのイメージの古いバージョンを表示し続けます。@code{image-flush}を呼び出すことによりそのイメージはキャッシュからフラッシュされて、イメージの表示が次回必要になった際にEmacsにファイルの再読み込みを強制します。

  @code{image-flush}の他の用途はメモリー節約です。Lispプログラムで@code{image-cache-eviction-delay}
(以下参照)より遥かに短い期間に多数の一時イメージを作成する場合には、Emacsが自動的に行うことを待たずに自身で使用されていないイメージのフラッシュを選択できます。

@defun clear-image-cache &optional filter
この関数はイメージキャッシュ内に格納されたすべてのイメージを削除してイメージキャッシュをクリアーする。@var{filter}が省略か@code{nil}なら選択されたフレームにたいしてキャッシュをクリアーする。@var{filter}がフレームなら、そのフレームにたいしてキャッシュをクリアーする。@var{filter}が@code{t}なら、すべてのイメージキャッシュをクリアーする。それ以外なら@var{filter}はファイル名として解釈されて、すべてのイメージキャッシュからそのファイル名に関連付けられたすべてのイメージを削除する。
@end defun

イメージキャッシュ内のイメージが指定された期間内に表示されなければ、Emacsはそれをキャッシュから削除して割り当てられたメモリーを解放します。

@defvar image-cache-eviction-delay
この変数は表示されることなくイメージがキャッシュ内に残留できる秒数を指定する。あるイメージがこの秒数の間に表示されなければ、Emacsはそれをイメージキャッシュから削除する。

ある状況下では、もしキャッシュ内のイメージ数が大きくなり過ぎた場合には実際の立ち退き遅延(eviction delay)はこれより短くなり得る。

値が@code{nil}なら明示的にキャッシュをクリアーした場合を除き、Emacsはキャッシュからイメージを削除しない。このモードはデバッグ時に有用かもしれない。
@end defvar

@defun image-cache-size
この関数はカレントイメージキャッシュの総バイト数をリターンする。たとえば24ビットカラーでサイズ200x100のイメージのキャッシュサイズは60000バイト。
@end defun

@node Xwidgets
@section 埋め込みネイティブウィジェット
@cindex xwidget
@cindex embedded widgets
@cindex webkit browser widget

  必要なサポートライブラリーつきでEmacsがビルドされていて、かつグラフィカル端末上で実行されていれば、Emacsバッファー内にGTK+
WebKitウィジェットのようなネイティブウィジェットを表示することができます。Emacsが埋め込みウィジェットを表示可能かテストするには、@code{xwidget-internal}機能が利用可能かどうかをチェックします(@ref{Named
Features}を参照)。

  Emacsバッファー内に埋め込みウィジェットを表示するためには、最初にxwidgetオブジェクトを作成して、テキストプロパティまたはオーバーレイプロパティ@code{display}内のディスプレイ仕様としてそのオブジェクトを使用します(@ref{Display
Property}を参照)。

@defun make-xwidget type title width height arguments &optional buffer
これはxwidgetオブジェクトを作成してリターンする。@var{buffer}が省略か@code{nil}の場合のデフォルトはカレントバッファー。@var{buffer}が存在しないバッファーの名前を指定する場合には作成する。@var{type}はxwidgetコンポーネントを識別するもので以下のいずれかが可能：

@table @code
@item webkit
WebKitコンポーネント。
@end table

引数@var{width}と@var{height}はウィジェットのサイズをピクセル単位で指定して、@var{title}はそのタイトルを指定する文字列。
@end defun

@defun xwidgetp object
この関数は@var{object}がxwidgetなら@code{t}、それ以外は@code{nil}をリターンする。
@end defun

@defun xwidget-plist xwidget
この関数は@var{xwidget}のプロパティリストをリターンする。
@end defun

@defun set-xwidget-plist xwidget plist
この関数は@var{plist}で与えられた新たなプロパティリストで@var{xwidget}のプロパティリストを置き換える。
@end defun

@defun xwidget-buffer xwidget
この関数は@var{xwidget}のバッファーをリターンする。
@end defun

@defun get-buffer-xwidgets buffer
この関数は@var{buffer}に関連付けられたxwidgetオブジェクトのリストをリターンする。@var{buffer}はバッファーオブジェクトか既存のバッファー名(文字列)を指定できる。@var{buffer}にxwidgetが含まれなければ値は@code{nil}。
@end defun

@defun xwidget-webkit-goto-uri xwidget uri
この関数は与えられた@var{xwidget}内で指定した@var{uri}をブラウズ(browse:
閲覧)する。@var{uri}はファイルかURLを指定する文字列。  @end defun

@defun xwidget-webkit-execute-script xwidget script
この関数は@var{xwidget}で指定されるブラウザウィジェットに、@code{script}で指定するJavaScriptを実行させる。
@end defun

@defun xwidget-webkit-execute-script-rv xwidget script &optional default
この関数は@code{xwidget-webkit-execute-script}と同様に指定した@var{script}を実行するが、スクリプトのリターン値も文字列としてリターンする。この関数は@var{script}が値をリターンしなければ@var{default}、@var{default}が省略されたら@code{nil}をリターンする。
@end defun

@defun xwidget-webkit-get-title xwidget
この関数は@var{xwidget}のタイトルを文字列としてリターンする。
@end defun

@defun xwidget-resize xwidget width height
この関数は指定した@var{xwidget}を@var{width}x@var{height}のサイズ(ピクセル単位)にリサイズする。
@end defun

@defun xwidget-size-request xwidget
この関数は@var{xwidget}のサイズを@code{(@var{width}
@var{height})}という形式のリストでリターンする。単位はピクセル。
@end defun

@defun xwidget-info xwidget
この関数は@code{[@var{type} @var{title} @var{width}
@var{height}]}という形式のベクターで@var{xwidget}の属性をリターンする。属性は通常はxwidgetの作成時に@code{make-xwidget}で決定される。
@end defun

@defun set-xwidget-query-on-exit-flag xwidget flag
この関数はEmacsが@var{xwidget}に関連付けられたバッファーのexitやkillの前にユーザーに確認を求めるようにアレンジすることを可能にする。@var{flag}が非@code{nil}ならEmacsはユーザーに確認を求めて、それ以外なら確認を求めない。
@end defun

@defun xwidget-query-on-exit-flag xwidget
この関数は@var{xwidget}のquery-on-exitフラグのカレントセッティングを@code{t}か@code{nil}のいずれかでリターンする。
@end defun

@node Buttons
@section ボタン
@cindex buttons in buffers
@cindex clickable buttons in buffers

  Buttonパッケージはマウスやキーボードコマンドでアクティブ化することができる、@dfn{ボタン(buttons)}の挿入と操作に関する関数を定義します。これらのボタンは典型的には種々のハイパーリンクに使用されます。

  本質的にボタンとはバッファー内のテキスト範囲にアタッチされたテキストプロパティやオーバーレイのプロパティのセットです。これらのプロパティは@dfn{ボタンプロパティ(button
properties)}と呼ばれます。これらのプロパティのうちの1つは@dfn{アクションプロパティ(action
property)}であり、これはユーザーがキーボードかマウスを使用してボタンを呼び出した際に呼び出される関数を指定します。アクション関数はボタンを調べ、必要に応じて他のプロパティを使用できます。

  いくつかの機能面でButtonパッケージとWidgetパッケージは重複しています。@ref{Top, , Introduction, widget,
The Emacs Widget
Library}を参照してください。Buttonパッケージの利点は、より高速で小さくプログラムにたいしてよりシンプルであることです。ユーザーの観点からは、2つのパッケージが提供するインターフェイスは非常に類似しています。

@menu
* Button Properties::        特別な意味をもつボタンプロパティ。
* Button Types::             ボタンのクラスにたいして一般的なプロパティを定義する。
* Making Buttons::           Emacsバッファーへのボタンの追加。
* Manipulating Buttons::     ボタンプロパティの取得とセット。
* Button Buffer Commands::   ボタンにたいするバッファー規模のコマンドとバインディング。
@end menu

@node Button Properties
@subsection ボタンのプロパティ
@cindex button properties

  ボタンはその外観と振る舞いを定義するプロパティの連想リスト(associated
list)をもち、アプリケーションの特別な目的のために他の任意のプロパティを使用できます。以下のプロパティはButtonパッケージにたいして特別な意味をもちます:

@table @code
@item action
@kindex action @r{(button property)}
ユーザーがボタンを呼び出した際に呼び出す関数であり、単一の引数@var{button}を渡して呼び出される。デフォルトではこれは何も行わない@code{ignore}。

@item mouse-action
@kindex mouse-action @r{(button property)}
これは@code{action}と似ているが与えられた際には、(@key{RET}押下のかわりに)マウスクリックによりボタンが呼び出された場合ｎ@code{action}のかわりに使用される。与えられなければマウスクリックはかわりに@code{action}を使用する。

@item face
@kindex face @r{(button property)}
このタイプのボタンが表示される方法を制御するEmacsフェイス。デフォルトは@code{button}フェイス。

@item mouse-face
@kindex mouse-face @r{(button property)}
ボタン上にマウスがある際の外観を制御する追加のフェイス(通常のbuttonフェイスとマージされる)。デフォルトはEmacsの通常の@code{highlight}フェイス。

@item keymap
@kindex keymap @r{(button property)}
そのボタンリージョン(button
region)でアクティブなバインディングを定義するボタンのキーマップ。デフォルトは変数@code{button-map}に格納された通常のボタンリージョンキーマップであり、これはボタン呼び出しにたいして@key{RET}と@key{mouse-2}を定義している。

@item type
@kindex type @r{(button property)}
ボタンのタイプ。@ref{Button Types}を参照のこと。

@item help-echo
@kindex help-echo @r{(button property)}
Emacsのツールチップヘルプシステムが表示する文字列であり、デフォルトは@code{"mouse-2, RET: Push this
button"}。かわりに表示される文字列をリターンする関数や文字列に評価されるフォーム、あるいは@code{nil}。詳細は@ref{Text
help-echo}を参照のこと。

関数なら@var{window}、@var{object}、@var{pos}という3つの引数で呼び出される。2つ目の引数@var{object}はプロパティをもつオーバーレイ(オーバーレイボタンにたいして)、あるいはボタンを含むバッファー(テキストプロパティボタンにたいして)のいずれか。その他の引数はスペシャルテキストプロパティ@code{help-echo}の場合と同じ意味をもつ。

@item follow-link
@kindex follow-link @r{(button property)}
このボタンにたいして@key{mouse-1}クリックが振る舞う方法を定義する@code{follow-link}プロパティ。@ref{Clickable
Text}を参照のこと。

@item button
@kindex button @r{(button property)}
すべてのボタンは非@code{nil}の@code{button}プロパティをもち、これはボタンを含むテキストリージョンを探すのに有用かもしれない(標準的なボタン関数はこれを行う)。
@end table

  ボタン内のテキストリージョンにたいして定義された他のプロパティも存在しますが、それらは典型的な用途にたいしては一般的には無関係でしょう。

@node Button Types
@subsection ボタンのタイプ
@cindex button types

  すべてのボタンはボタンのプロパティにたいするデフォルト値を定義する@dfn{ボタンタイプ(button
type)}をもっています。ボタンタイプは、より汎用的なタイプから特化したタイプへと継承される階層構造で構成されており、特定のタスクにたいして特殊用途のボタンを簡単に定義できます。

@defun define-button-type name &rest properties
@var{name} (シンボル)と呼ばれるボタンタイプを定義する。残りの引数は@var{property
value}ペアーのシーケンスを形成する。これはそのタイプのボタンにたいするデフォルトのプロパティ値を指定する(ボタンのタイプはキーワード引数@code{:type}を使用してボタン作成時にそれを@code{type}プロパティに与えることによりセット可能)。

加えて@var{name}がデフォルトプロパティ値を継承するボタンタイプ指定するためにキーワード引数@code{:supertype}を使用できる。この継承は@var{name}の定義時のみ発生することに注意。その後にsupertypeに行われた変更はsubtypeには反映されない。
@end defun

  @code{define-button-type}を使用してボタンのデフォルトプロパティを定義するのは必須ではありません ---
特定のタイプをもたないボタンはビルトインのボタンタイプ@code{button}を使用します ---
が推奨しません。これを行うことにより通常はコードがより明快かつ効果的になるからです。

@node Making Buttons
@subsection ボタンの作成
@cindex making buttons

  ボタンはボタン固有の情報を保持するために、オーバーレイプロパティかテキストプロパティを使用してテキストのリージョンに関連付けられます。これらはすべてボタンのタイプ(デフォルトはビルトインのボタンタイプ@code{button})から初期化されます。すべてのEmacsテキストと同じようにボタンの外観は@code{face}プロパティにより制御されます。(ボタンタイプ@code{button}から継承された@code{face}プロパティを通じることにより)デフォルトでは典型的なウェブページリンクのようなシンプルなアンダーラインです。

  簡便さのために2種類のボタン作成関数があります。1つはバッファーの既存リージョンにボタンプロパティを追加する@code{make-...button}と呼ばれる関数、もう1つはボタンテキストを挿入する@code{insert-...button}と呼ばれる関数です。

  すべてのボタン作成関数は@code{&rest}引数の@var{properties}を受け取ります。これはボタンに追加するプロパティを指定する@var{property
value}ペアーのシーケンスである必要があります。@ref{Button
Properties}を参照してください。これに加えて他のプロパティの継承元となるボタンタイプの指定にキーワード引数@code{:type}を使用できます。@ref{Button
Types}を参照してください。作成の間に明示的に指定されなかったプロパティは、(そのタイプがそのようなプロパティを定義していれば)そのボタンのタイプから継承されます。

  以下の関数はボタンプロパティを保持するためにオーバーレイを使用してボタンを追加します(@ref{Overlays}を参照)。

@defun make-button beg end &rest properties
これはカレントバッファー内の@var{beg}から@var{end}にボタンを作成してリターンする。
@end defun

@defun insert-button label &rest properties
これはポイント位置にラベル@var{label}のボタンを挿入してリターンする。
@end defun

  以下の関数も同様ですが、ボタンプロパティを保持するためにテキストプロパティを使用します(@ref{Text
Properties}を参照)。この種のボタンはバッファーにマーカーを追加しないので、非常に多数のボタンが存在してもバッファーでの編集が低速になることはありません。しかしそのテキストに既存のfaceテキストプロパティが存在する場合(たとえばFont
Lockモードにより割り当てられたフェイス)には、そのボタンのフェイスは可視にならないかもしれません。これらの関数はいずれも新たなボタンの開始位置をリターンします。

@defun make-text-button beg end &rest properties
これはテキストプロパティを使用してカレントバッファー内の@var{beg}から@var{end}にボタンを作成する。
@end defun

@defun insert-text-button label &rest properties
これはテキストプロパティを使用してポイント位置にラベル@var{label}のボタンを挿入する。
@end defun

@defun button-buttonize string callback &optional data
たとえば後でバッファーに挿入されるかもしれないデータ構造の作成時など、即座にバッファーに挿入せずに文字列をボタンにできれば便利なことがある。この関数は@var{string}をそのような文字列にして、ユーザーがそのボタンをクリックした際には@var{callback}が呼び出されるようにする。オプションの@var{data}パラメーターは@var{callback}の呼び出し時にパラメーターとして使用される。@code{nil}ならかわりにボタンがパラメーターとして使用される。
@end defun

@node Manipulating Buttons
@subsection ボタンの操作
@cindex manipulating buttons

ボタンのプロパティの取得やセットを行う関数が存在します。これらは何を行うかを判断するためにボタンが呼び出す関数からよく使用される関数です。

@var{button}パラメーターが指定された場合にはオーバーレイ(オーバーレイボタンの場合)、またはバッファー位置やマーカー(テキストプロパティボタンの場合)いずれかという、特定のボタンを参照するオブジェクトを意味します。そのようなオブジェクトはボタンが関数を呼び出す際に1つ目の引数として渡されます。

@defun button-start button
@var{button}が開始される位置をリターンする。
@end defun

@defun button-end button
@var{button}が終了する位置をリターンする。
@end defun

@defun button-get button prop
ボタン@var{button}の@var{prop}という名前のプロパティを取得する。
@end defun

@defun button-put button prop val
@var{button}の@var{prop}プロパティに@var{val}をセットする。
@end defun

@defun button-activate button &optional use-mouse-action
@var{button}の@code{action}プロパティを呼び出す(単一の引数@var{button}を渡してプロパティの値である関数を呼び出す)。@var{use-mouse-action}が非@code{nil}なら、@code{action}のかわりにそのボタンの@code{mouse-action}プロパティの呼び出しを試みる。ボタンが@code{mouse-action}プロパティをもたなければ通常どおり@code{action}を使用する。@var{button}で@code{button-data}プロパティが与えられた場合には、@code{action}関数の引数として@var{button}のかわりに使用される。
@end defun

@defun button-label button
@var{button}のテキストラベルをリターンする。
@end defun

@defun button-type button
@var{button}のボタンタイプをリターンする。
@end defun

@defun button-has-type-p button type
@var{button}がボタンタイプ@var{type}、または@var{type}のsubtypeのいずれかをもつなら@code{t}をリターンする。
@end defun

@defun button-at pos
カレントバッファー内の位置@var{pos}にあるボタン、または@code{nil}をリターンする。@var{pos}にあるボタンがテキストプロパティボタンならリターン値は@var{pos}を指すマーカー。
@end defun

@defun button-type-put type prop val
ボタンタイプ@var{type}の@var{prop}プロパティに@var{val}をセットする。
@end defun

@defun button-type-get type prop
ボタンタイプ@var{type}の@var{prop}という名前のプロパティを取得する。
@end defun

@defun button-type-subtype-p type supertype
ボタンタイプ@var{type}が@var{supertype}のsubtypeなら@code{t}をリターンする。
@end defun

@node Button Buffer Commands
@subsection ボタンのためのバッファーコマンド
@cindex button buffer commands

Emacsバッファー内にボタンの配置や操作を行うコマンドや関数が存在します。

@code{push-button} is the command that a user uses to actually push a
button, and is bound by default in the button itself to @key{RET} and to
@key{mouse-2} using a local keymap in the button's overlay or text
properties.  Commands that are useful outside the buttons itself, such as
@code{forward-button} and @code{backward-button} are additionally available
in the keymap stored in @code{button-buffer-map}; a mode which uses buttons
may want to use @code{button-buffer-map} as a parent keymap for its keymap.
Alternatively, the @code{button-mode} can be switched on for much the same
effect: It's a minor mode that does nothing else than install
@code{button-buffer-map} as a minor mode keymap.

ボタンが非@code{nil}の@code{follow-link}プロパティをもち、かつ@code{mouse-1-click-follows-link}がセットされている場合には、素早い@key{mouse-1}クリックにより@code{push-button}コマンドもアクティブになるでしょう。@ref{Clickable
Text}を参照してください。

@deffn Command push-button &optional pos use-mouse-action
位置@var{pos}にあるボタンが指定するアクションを行う。@var{pos}はバッファー位置、またはマウスイベントのいずれか。@var{use-mouse-action}が非@code{nil}、または@var{pos}がマウスイベントなら@code{action}のかわりにそのボタンの@code{mouse-action}プロパティの呼び出しを試みて、ボタンに@code{mouse-action}プロパティがなければ通常のように@code{action}を使用する。@code{push-button}がマウスイベントの結果としてインタラクティブに呼び出されたときはそのマウスイベントの位置、それ以外ではポイントの位置が@var{pos}のデフォルトになる。@var{pos}にボタンがなければ何もせずに@code{nil}をリターンして、それ以外なら@code{t}をリターンする。
@end deffn

@deffn Command forward-button n &optional wrap display-message no-error
次の@var{n}番目、@var{n}が負なら前の@var{n}番目のボタンに移動する。@var{n}が0ならポイント位置にある任意のボタンの開始に移動する。@var{wrap}が非@code{nil}ならバッファーの先頭または終端を超えてもう一方の端へ移動を継続する。@var{display-message}が非@code{nil}ならボタンのhelp-echo文字列が表示される。非@code{nil}の@code{skip}プロパティをもつボタンはすべてスキップされる。見つかったボタンをリターンするか、ボタンが見つからなければエラーをシグナルする。@var{no-error}が非@code{nil}なら、エラーをシグナルするかわりに@code{nil}をリターンする。
@end deffn

@deffn Command backward-button n &optional wrap display-message no-error
前の@var{n}番目、@var{n}が負なら次の@var{n}番目のボタンに移動する。@var{n}が0ならポイント位置にある任意のボタンの開始に移動する。@var{wrap}が非@code{nil}ならバッファーの先頭または終端を超えて、もう一方の端へ移動を継続する。@var{display-message}が非@code{nil}ならボタンのhelp-echo文字列が表示される。非@code{nil}の@code{skip}プロパティをもつボタンはすべてスキップされる。見つかったボタンをリターンするか、ボタンが見つからなければエラーをシグナルする。@var{no-error}が非@code{nil}なら、エラーをシグナルするかわりに@code{nil}をリターンする。
@end deffn

@defun next-button pos &optional count-current
@defunx previous-button pos &optional count-current
カレントバッファー内の位置@var{pos}の次(@code{next-button}の場合)、または前(@code{previous-button}の場合)のボタンをリターンする。@var{count-current}が非@code{nil}なら、次のボタンから検索を開始するかわりに@var{pos}にある任意のボタンを考慮する。
@end defun

@node Abstract Display
@section 抽象的なディスプレー
@cindex ewoc
@cindex display, abstract
@cindex display, arbitrary objects
@cindex model/view/controller
@cindex view part, model/view/controller

  EwocパッケージはLispオブジェクトの構造を表すバッファーテキストを構成して、その構造体の変更にしたがってテキストを更新します。これはデザインパラダイム``model--view--controller''内の``view''コンポーネントと似ています。Ewocは``Emacs's
Widget for Object Collections(オブジェクトコレクション用Emacsウィジェット)''を意味します。

  @dfn{ewoc}は特定のLispデータを表現するバッファーテキストの構築に要される情報を組織化します。ewocのバッファーテキストは順番に、まず固定された@dfn{header}テキスト、次に一連のデータ要素のテキスト記述(あなたが指定するLispオブジェクト)、最後に固定された@dfn{footer}テキストという3つのパートをもっています。具体的にはewocは以下の情報を含んでいます:

@itemize @bullet
@item
そのテキストが生成されたバッファー。

@item
バッファー内でのそのテキストの開始位置。

@item
ヘッダー文字列とフッター文字列。

@item
@cindex node, ewoc
@c or "@cindex node, abstract display"?
2重リンクされた@dfn{ノード(nodes)}のチェーン。各ノードは以下を含む:

@itemize
@item
@dfn{データ要素(data element)}。単一のLispオブジェクト。

@item
そのチェーン内で先行と後続のノードへのリンク。
@end itemize

@item
カレントバッファー内にデータ要素値のテキスト表現を挿入する責務をもつ@dfn{pretty-printer}関数。
@end itemize

  通常は@code{ewoc-create}によりewocを定義して、その結果のewoc構造体内にノードを構築するためにEwocパッケージ内の別の関数に渡してバッファー内に表示します。バッファー内でこれが一度表示されれば、他の関数はバッファー位置とノードの対応を判断したり、あるノードのテキスト表現から別のノードのテキスト表現への移動等を行います。@ref{Abstract
Display Functions}を参照してください。

@cindex encapsulation, ewoc
@c or "@cindex encapsulation, abstract display"?
  ノードは変数が値を保持するのと同じ方法でデータ要素を@dfn{カプセル化(encapsulate)}します。カプセル化は通常はewocへのノード追加の一部として発生します。以下のようにデータ要素値を取得して、その場所に新たな値を配置することができます:

@lisp
(ewoc-data @var{node})
@result{} value

(ewoc-set-data @var{node} @var{new-value})
@result{} @var{new-value}
@end lisp

@noindent
データ要素値として実際の値のコンテナーであるようなLispオブジェクト(リストまたはベクター)、または他の構造体へのインデックスも使用できます。例(@ref{Abstract
Display Example}を参照)では後者のアプローチを使用しています。

  データが変更された際にはバッファー内のテキストを更新したいでしょう。@code{ewoc-refresh}呼び出しにより全ノード、@code{ewoc-invalidate}を使用して特定のノード、または@code{ewoc-map}を使用して述語を満足するすべてのノードを更新できます。あるいは@code{ewoc-delete}を使用して無効なノードを削除したり、その場所に新たなノードを追加できます。ewocからのノード削除はバッファーからそれに関連付けられたテキスト記述も同様に削除します。

@menu
* Abstract Display Functions::  Ewocパッケージ内の関数。
* Abstract Display Example::  Ewocの使用例。
@end menu

@node Abstract Display Functions
@subsection 抽象ディスプレーの関数

  このセクションでは、@var{ewoc}と@var{node}は上述(@ref{Abstract
Display}を参照)の構造体を、@var{data}はデータ要素として使用される任意のLispオブジェクトを意味します。

@defun ewoc-create pretty-printer &optional header footer nosep
これはノード(とデータ要素)をもたない新たなewocを構築してリターンする。@var{pretty-printer}は1つの引数を受け取る関数であること。この引数は当該ewoc内で使用を計画する類のデータ要素であり、@code{insert}を使用してポイント位置にそのテキスト記述を挿入する(Ewocパッケージの内部的メカニズムと干渉するために@code{insert-before-markers}は決して使用しない)。

ヘッダー、フッター、およびすべてのノードのテキスト記述の後には、通常は自動的に改行が挿入される。@var{nosep}が非@code{nil}なら改行は何も挿入されない。これはewoc全体を単一行に表示したり、これらのノードにたいして何も行わないように@var{pretty-printer}をアレンジすることによりノードを不可視にするために有用かもしれない。

ewocは作成時にカレントだったバッファー内のテキストを保守するので、@code{ewoc-create}呼び出し前に意図するバッファーへ切り替えること。
@end defun

@defun ewoc-buffer ewoc
これは、@var{ewoc}がそのテキストを保守するバッファーをリターンする。
@end defun

@defun ewoc-get-hf ewoc
これは@var{ewoc}のヘッダーとフッターから作成されたコンスセル@code{(@var{header}
. @var{footer})}をリターンする。
@end defun

@defun ewoc-set-hf ewoc header footer
これは@var{ewoc}のヘッダーとフッターに文字列@var{header}と@var{footer}をセットする。
@end defun

@defun ewoc-enter-first ewoc data
@defunx ewoc-enter-last ewoc data
これらはそれぞれ@var{data}を新たなノードにカプセル化して、それを@var{ewoc}のチェーンノードの先頭または終端に配置する。
@end defun

@defun ewoc-enter-before ewoc node data
@defunx ewoc-enter-after ewoc node data
これらはそれぞれ@var{data}を新たなノードにカプセル化して、それを@var{ewoc}の@var{node}の前または後に追加する。
@end defun

@defun ewoc-prev ewoc node
@defunx ewoc-next ewoc node
これらはそれぞれ@var{ewoc}内の@var{node}の前または次のノードをリターンする。
@end defun

@defun ewoc-nth ewoc n
これは@var{ewoc}内で0基準のインデックス@var{n}で見つかったノードをリターンする。負の@var{n}は終端から数えることを意味する。@var{n}が範囲外なら@code{ewoc-nth}は@code{nil}をリターンする。
@end defun

@defun ewoc-data node
これは@var{node}にカプセル化されたデータを抽出してリターンする。
@end defun

@defun ewoc-set-data node data
これは@var{node}にカプセル化されるデータとして@var{data}をセットする。
@end defun

@defun ewoc-locate ewoc &optional pos guess
これはポイント(指定された場合は@var{pos})を含む@var{ewoc}内のノードを判断して、そのノードをリターンする。@var{ewoc}がノードをもたなければ、@code{nil}をリターンする。@var{pos}が最初のノードの前なら最初のノード、最後のノードの後なら最後のノードをリターンする。オプションの3つ目の引数@var{guess}は、@var{pos}近傍にあると思われるノードであること。これは結果を変更しないが、関数の実行を高速にする。
@end defun

@defun ewoc-location node
これは@var{node}の開始位置をリターンする。
@end defun

@defun ewoc-goto-prev ewoc arg
@defunx ewoc-goto-next ewoc arg
これらはそれぞれ@var{ewoc}内の前または次の@var{arg}番目のノードにポイントを移動する。すでに最初のノードにポイントがある場合、または@var{ewoc}が空の場合には@code{ewoc-goto-prev}は移動しない。また@code{ewoc-goto-next}が最後のノードを超えて移動すると結果は@code{nil}。この特殊なケースを除き、これらの関数は移動先のノードをリターンする。
@end defun

@defun ewoc-goto-node ewoc node
これは@var{ewoc}内の@var{node}の開始にポイントを移動する。
@end defun

@defun ewoc-refresh ewoc
この関数は@var{ewoc}のテキストを再生成する。これはヘッダーとフッターの間のテキスト、すなわちすべてのデータ要素の表現を削除して、各ノードにたいして1つずつ順にpretty-printer関数を呼び出すことによりすることにより機能する。
@end defun

@defun ewoc-invalidate ewoc &rest nodes
これは@code{ewoc-refresh}と似ているが、@var{ewoc}内のノードセット全体ではなく@var{nodes}だけを対象とする点が異なる。
@end defun

@defun ewoc-delete ewoc &rest nodes
これは@var{ewoc}から@var{nodes}内の各要素を削除する。
@end defun

@defun ewoc-filter ewoc predicate &rest args
これは@var{ewoc}内の各データ要素にたいして@var{predicate}を呼び出して、@var{predicate}が@code{nil}をリターンしたノードを削除する。任意の@var{args}を@var{predicate}に渡すことができる。
@end defun

@defun ewoc-collect ewoc predicate &rest args
これは@var{ewoc}内の各データ要素にたいして@var{predicate}を呼び出して、@var{predicate}が非@code{nil}をリターンしたノードのリストをリターンする。リスト内の要素はバッファー内での順序になる。任意の@var{args}を@var{predicate}に渡すことができる。
@end defun

@defun ewoc-map map-function ewoc &rest args
これは@var{ewoc}内の各データ要素にたいして@var{map-function}を呼び出して、@var{map-function}が非@code{nil}をリターンしたノードを更新する。任意の@var{args}を@var{map-function}に渡すことができる。
@end defun

@node Abstract Display Example
@subsection 抽象ディスプレーの例

  以下は3つの整数からなるベクターを表すバッファー内の領域である@dfn{カラー構成(color
components)}表示をewocパッケージ内の関数を使用して、さまざまな方法で実装するシンプルな例です。

@example
(setq colorcomp-ewoc nil
      colorcomp-data nil
      colorcomp-mode-map nil
      colorcomp-labels ["Red" "Green" "Blue"])

(defun colorcomp-pp (data)
  (if data
      (let ((comp (aref colorcomp-data data)))
        (insert (aref colorcomp-labels data) "\t: #x"
                (format "%02X" comp) " "
                (make-string (ash comp -2) ?#) "\n"))
    (let ((cstr (format "#%02X%02X%02X"
                        (aref colorcomp-data 0)
                        (aref colorcomp-data 1)
                        (aref colorcomp-data 2)))
          (samp " (sample text) "))
      (insert "Color\t: "
              (propertize samp 'face
                          `(foreground-color . ,cstr))
              (propertize samp 'face
                          `(background-color . ,cstr))
              "\n"))))

(defun colorcomp (color)
  "新たなバッファー内でCOLORの編集を許可する。
そのバッファーはColor Componentsモードになる。"
  (interactive "sColor (name or #RGB or #RRGGBB): ")
  (when (string= "" color)
    (setq color "green"))
  (unless (color-values color)
    (error "No such color: %S" color))
  (switch-to-buffer
   (generate-new-buffer (format "originally: %s" color)))
  (kill-all-local-variables)
  (setq major-mode 'colorcomp-mode
        mode-name "Color Components")
  (use-local-map colorcomp-mode-map)
  (erase-buffer)
  (buffer-disable-undo)
  (let ((data (apply 'vector (mapcar (lambda (n) (ash n -8))
                                     (color-values color))))
        (ewoc (ewoc-create 'colorcomp-pp
                           "\nColor Components\n\n"
                           (substitute-command-keys
                            "\n\\@{colorcomp-mode-map@}"))))
    (set (make-local-variable 'colorcomp-data) data)
    (set (make-local-variable 'colorcomp-ewoc) ewoc)
    (ewoc-enter-last ewoc 0)
    (ewoc-enter-last ewoc 1)
    (ewoc-enter-last ewoc 2)
    (ewoc-enter-last ewoc nil)))
@end example

@cindex controller part, model/view/controller
  この例は@code{colorcomp-data}の変更して選択プロセスを``完了''して、それらを互いに簡便に結ぶキーマップを定義することにより(言い換えると``model/view/controller''デザインパラダイムのcontroller部分)、``color
selection widget''への拡張が可能です。

@smallexample
(defun colorcomp-mod (index limit delta)
  (let ((cur (aref colorcomp-data index)))
    (unless (= limit cur)
      (aset colorcomp-data index (+ cur delta)))
    (ewoc-invalidate
     colorcomp-ewoc
     (ewoc-nth colorcomp-ewoc index)
     (ewoc-nth colorcomp-ewoc -1))))

(defun colorcomp-R-more () (interactive) (colorcomp-mod 0 255 1))
(defun colorcomp-G-more () (interactive) (colorcomp-mod 1 255 1))
(defun colorcomp-B-more () (interactive) (colorcomp-mod 2 255 1))
(defun colorcomp-R-less () (interactive) (colorcomp-mod 0 0 -1))
(defun colorcomp-G-less () (interactive) (colorcomp-mod 1 0 -1))
(defun colorcomp-B-less () (interactive) (colorcomp-mod 2 0 -1))

(defun colorcomp-copy-as-kill-and-exit ()
  "color componentsをkillリングにコピーしてバッファーをkill。
文字列は#RRGGBB(6桁16進が付加されたハッシュ)にフォーマットされる。"
  (interactive)
  (kill-new (format "#%02X%02X%02X"
                    (aref colorcomp-data 0)
                    (aref colorcomp-data 1)
                    (aref colorcomp-data 2)))
  (kill-buffer nil))

(setq colorcomp-mode-map
      (let ((m (make-sparse-keymap)))
        (suppress-keymap m)
        (define-key m "i" 'colorcomp-R-less)
        (define-key m "o" 'colorcomp-R-more)
        (define-key m "k" 'colorcomp-G-less)
        (define-key m "l" 'colorcomp-G-more)
        (define-key m "," 'colorcomp-B-less)
        (define-key m "." 'colorcomp-B-more)
        (define-key m " " 'colorcomp-copy-as-kill-and-exit)
        m))
@end smallexample

わたしたちが決して各ノード内のデータを変更していないことに注意してください。それらのデータはewoc作成時に@code{nil}、または実際のカラーコンポーネントであるベクター@code{colorcomp-data}にたいするインデックスに固定されています。

@node Blinking
@section カッコの点滅
@cindex parenthesis matching
@cindex blinking parentheses
@cindex balancing parentheses

  このセクションではユーザーが閉カッコを挿入した際に、マッチする開カッコをEmacsが示すメカニズムを説明します。

@defvar blink-paren-function
この変数の値は閉カッコ構文(close parenthesis
syntax)の文字が挿入された際に常に呼び出される関数(引数なし)であること。@code{blink-paren-function}の値は@code{nil}も可能であり、この場合は何も行わない。
@end defvar

@defopt blink-matching-paren
この変数が@code{nil}なら@code{blink-matching-open}は何も行わない。
@end defopt

@defopt blink-matching-paren-distance
この変数はギブアップする前にマッチするカッコをスキャンする最大の距離を指定する。
@end defopt

@defopt blink-matching-delay
この変数はマッチするカッコを示し続ける秒数を指定する。分数の秒も良好な結果をもたらすことがあるが、デフォルトはすべてのシステムで機能する1である。
@end defopt

@deffn Command blink-matching-open
この関数は@code{blink-paren-function}のデフォルト値である。この関数は閉カッコ構文の文字の後にポイントがあると仮定して、マッチする開カッコに瞬時適切な効果を適用する。その文字がまだスクリーン上になければ、エコーエリア内にその文字のコンテキストを表示する。長い遅延を避けるために、この関数は文字数@code{blink-matching-paren-distance}より遠くを検索しない。

以下はこの関数を明示的に呼び出す例。

@smallexample
@group
(defun interactive-blink-matching-open ()
  "ポイント前のカッコによるsexp開始を瞬時示す"
  (interactive)
@end group
@group
  (let ((blink-matching-paren-distance
         (buffer-size))
        (blink-matching-paren t))
    (blink-matching-open)))
@end group
@end smallexample
@end deffn

@node Character Display
@section 文字の表示

  このセクションでは文字がEmacsにより実際に表示される方法について説明します。文字は通常は@dfn{グリフ(glyph)}として表示されます。グリフとはスクリーン上で1文字の位置を占めるグラフィカルなシンボルであり、その外観はその文字自身に対応します。たとえば文字@samp{a}
(文字コード97)は@samp{a}と表示されます。しかしいくつかの文字は特別な方法で表示されます。たとえば改頁文字(文字コード12)は通常は2つのグリフのシーケンス@samp{^L}で表示されて、改行文字(文字コード10)は新たなスクリーン行を開始します。

  @dfn{ディスプレイテーブル(display
table)}を定義することにより、各文字が表示される方法を変更できます。これはそれぞれの文字をグリフのシーケンスにマップするテーブルです。@ref{Display
Tables}を参照してください。

@menu
* Usual Display::            文字の表示にたいする通常の慣習。
* Display Tables::           ディスプレイテーブルの構成要素。
* Active Display Table::     使用するディスプレイテーブルをEmacsが選択する方法。
* Glyphs::                   グリフの定義方法とグリフの意味。
* Glyphless Chars::          グリフなしの文字の描画方法。
@end menu

@node Usual Display
@subsection 通常の表示の慣習

  以下は各文字コードの表示にたいする慣習です(ディスプレイテーブルが存在しなければこれらの慣習をオーバーライドできる
@iftex
)。
@end iftex
@ifnottex
。@ref{Display Tables})を参照)。
@end ifnottex

@cindex printable ASCII characters
@itemize @bullet
@item
コード32から126の@dfn{プリント可能@acronym{ASCII}文字(printable @acronym{ASCII}
characters: 数字、英文字、および@samp{#}のようなシンボル)}は文字通りそのまま表示される。

@item
タブ文字(文字コード9)は次のタブストップ列まで伸長された空白文字として表示される。@ref{Text Display,,, emacs, The
GNU Emacs Manual}を参照のこと。変数@code{tab-width}はタブストップごとのスペース数を制御する(以下参照)。

@item
改行文字(文字コード10)は特殊効果をもつ。これは先行する行を終端して新たな行を開始する。

@cindex ASCII control characters
@item
非プリント可能@dfn{@acronym{ASCII}制御文字(@acronym{ASCII} control characters)} ---
文字コード0から31と@key{DEL}文字(文字コード127) ---
は変数@code{ctl-arrow}に応じて2つの方法のいずれかで表示される。この変数が非@code{nil}
(デフォルト)なら、たとえば@key{DEL}にたいしては@samp{^?}のように、これらの文字は1つ目のグリフが@samp{^}
(@samp{^}のかわりに使用する文字をディスプレイテーブルで指定できる)のような2つのグリフのシーケンスとして表示される。

@code{ctl-arrow}が@code{nil}なら、これらの文字は8進エスケープとして表示される(以下参照)。

このルールはバッファー内に復帰文字(CR: carriage
return、文字コード13)があればそれにも適用される。しかし復帰文字は通常はバッファーテキスト内には存在しない。これらは行末変換(end-of-line
conversion)の一部として除去される(@ref{Coding System Basics}を参照)。

@cindex octal escapes
@item
@dfn{rawバイト(raw
bytes)}とはコード128から255の非@acronym{ASCII}文字である。これらの文字は@dfn{8進エスケープ(octal
escapes)}として表示される。これは1つ目が@samp{\}にたいする@acronym{ASCII}コードのグリフで、残りがその文字のコードを8進で表した数字である(ディスプレイテーブルで@samp{\}のかわりに使用するグリフを指定できる)。

@item
255を超える非@acronym{ASCII}文字は、端末がサポートしていればそのまま表示される。端末がサポートしない場合には、その文字は@dfn{グリフなし(glyphless)}と呼ばれて、通常はプレースホルダーグリフを使用して表示される。たとえばある文字にたいしてグラフィカル端末がフォントをもたなければ、Emacsは通常は16進文字コードを含むボックスを表示する。@ref{Glyphless
Chars}を参照のこと。
@end itemize

  The above display conventions apply even when there is a display table, for
any character whose entry in the active display table is @code{nil}.  Thus,
when you set up a display table, you need only specify the characters for
which you want special display behavior.

  以下の変数はスクリーン上で特定の文字が表示される方法に影響します。これらはその文字が占める列数を変更するのでインデント関数にも影響を与えます。またモードラインが表示される方法にも影響があります。新たな値を使用してモードラインを強制的に再表示するには関数@code{force-mode-line-update}を呼び出してください(@ref{Mode
Line Format}を参照)。

@defopt ctl-arrow
@cindex control characters in display
このバッファーローカル変数はコントロール文字が表示される方法を制御する。非@code{nil}なら@samp{^A}のようにカレットとその文字、@code{nil}なら@samp{\001}のようにバックスラッシュと8進3桁のように8進エスケープとして表示される。
@end defopt

@defopt tab-width
このバッファーローカル変数の値はEmacsバッファー内でのタブ文字表示で使用するタブストップ間のスペース数。値は列単位でデフォルトは8。この機能はコマンド@code{tab-to-tab-stop}で使用されるユーザー設定可能なタブストップとは完全に無関係であることに注意。@ref{Indent
Tabs}を参照のこと。
@end defopt

@node Display Tables
@subsection ディスプレーテーブル

@cindex display table
  A display table is a special-purpose char-table (@pxref{Char-Tables}), with
@code{display-table} as its subtype, which is used to override the usual
character display conventions.  This section describes how to make, inspect,
and assign elements to a display table object.  The next section
(@pxref{Active Display Table})  describes the various standard display
tables and their precedence.

@defun make-display-table
これはディスプレイテーブルを作成してリターンする。テーブルは初期状態ではすべての要素に@code{nil}をもつ。
@end defun

  ディスプレイテーブルの通常の要素は文字コードによりインデックス付けされます。インデックス@var{c}の要素はコード@var{c}の表示方法を示します。値は@code{nil}
(これは通常の表示慣習に応じて文字@var{c}を表示することを意味する。@ref{Usual
Display}を参照)、またはグリフコードのベクター(これらのグリフとして文字@var{c}を表示することを意味する。@ref{Glyphs}を参照)のいずれかです。

  @strong{警告:} 改行文字の表示を変更するためにディスプレイテーブルを使用すると、バッファー全体が1つの長い行として表示されるでしょう。

  ディスプレイテーブルは特殊用途向け6つの@dfn{エクストラスロット(extra
slots)}をもつこともできます。以下はそれらの意味についてのテーブルです。@code{nil}のスロットは以下で示すそのスロットにたいするデフォルトの使用を意味します。

@table @asis
@item 0
切り詰められたスクリーン行終端のグリフ(デフォルトでは@samp{$})。@ref{Glyphs}を参照のこと。グラフィカルな端末ではフリンジを無効にしていなれば(@ref{Fringes,,
Window Fringes, emacs, the GNU Emacs
Manual}を参照)、Emacsはデフォルトでは切り詰められたことをフリンジ内の矢印で示し、ディスプレイテーブルは使用しない。

@item 1
継続行終端のグリフ(デフォルトは@samp{\})。グラフィカルな端末ではフリンジを無効にしていなれば、デフォルトではEmacsは継続ををフリンジ内の曲矢印で示し、ディスプレイテーブルは使用しない。

@item 2
8進文字コードとして表示される文字を示すグリフ(デフォルトは@samp{\})。

@item 3
コントロール文字を示す(デフォルトは@samp{^})。

@item 4
不可視行があることを示すグリフのベクター(デフォルトは@samp{...})。@ref{Selective Display}を参照のこと。

@item 5
横並びのウィンドウ間のボーダー描画に使用されるグリフ(デフォルトは@samp{|})。@ref{Splitting
Windows}を参照のこと。これは現在のところテキスト端末でのみ効果がある。グラフィカル端末では垂直スクロールバーがサポートされていて使用中ならスクロールバーが2つのウィンドウを分割する。垂直スクロールバーとディバイダー(@ref{Window
Dividers}を参照)がなければ、Emacsは境界を示すために細いラインを使用する。
@end table

  たとえば以下は関数@code{make-glyph-code}にたいして@code{ctl-arrow}に非@code{nil}をセットして得られる効果を模倣するディスプレイテーブル(@ref{Glyphs}を参照のこと)を構築する例です:

@example
(setq disptab (make-display-table))
(dotimes (i 32)
  (or (= i ?\t)
      (= i ?\n)
      (aset disptab i
            (vector (make-glyph-code ?^ 'escape-glyph)
                    (make-glyph-code (+ i 64) 'escape-glyph)))))
(aset disptab 127
      (vector (make-glyph-code ?^ 'escape-glyph)
              (make-glyph-code ?? 'escape-glyph)))))
@end example

@defun display-table-slot display-table slot
この関数は@var{display-table}のエクストラスロット@var{slot}の値をリターンする。引数@var{slot}には0から5の数字(両端を含む)、またはスロット名(シンボル)を指定できる。有効なシンボルは@code{truncation}、@code{wrap}、@code{escape}、@code{control}、@code{selective-display}、@code{vertical-border}。
@end defun

@defun set-display-table-slot display-table slot value
この関数は@var{display-table}のエクストラスロット@var{slot}に@var{value}を格納する。引数@var{slot}には0から5の数字(両端を含む)、またはスロット名(シンボル)を指定できる。有効なシンボルは@code{truncation}、@code{wrap}、@code{escape}、@code{control}、@code{selective-display}、@code{vertical-border}。
@end defun

@defun describe-display-table display-table
この関数はヘルプバッファーにディスプレイテーブル@var{display-table}の説明を表示する。
@end defun

@deffn Command describe-current-display-table
このコマンドはヘルプバッファーにカレントディスプレイテーブルの説明を表示する。
@end deffn

@node Active Display Table
@subsection アクティブなディスプレーテーブル
@cindex active display table

  ウィンドウはそれぞれディスプレイテーブルを指定でき、各バッファーもディスプレイテーブルを指定できます。もしウィンドウにディスプレイテーブルがあれば、それはバッファーのディスプレイテーブルより優先されます。ウィンドウとバッファーがいずれもディスプレイテーブルをもたなければ、Emacsは標準的なディスプレイテーブルの使用を試みます。標準ディスプレイテーブルが@code{nil}ならEmacsは通常の文字表示慣習を使用します(@ref{Usual
Display}を参照)。

  ディスプレイテーブルはモードラインが表示される方法に影響を与えるので、新たなディスプレイテーブルを使用してモードラインを強制的に再表示するには@code{force-mode-line-update}を使用することに注意してください(@ref{Mode
Line Format}を参照)。

@defun window-display-table &optional window
この関数は@var{window}のディスプレイテーブル、ディスプレイテーブルがなければ@code{nil}をリターンする。@var{window}のデフォルトは選択されたウィンドウ。
@end defun

@defun set-window-display-table window table
この関数は@var{window}のディスプレイテーブルに@var{table}をセットする。引数@var{table}はディスプレイテーブルか@code{nil}のいずれかであること。
@end defun

@defvar buffer-display-table
この変数はすべてのバッファーにおいて自動的にバッファーローカルになる。変数の値はバッファーのディスプレイテーブルを指定する。これが@code{nil}ならバッファーのディスプレイテーブルは存在しない。
@end defvar

@defvar standard-display-table
この変数の値はウィンドウ内にバッファーを表示する際、ウィンドウディスプレイテーブルとバッファーディスプレイテーブルのいずれも定義されていないとき、またはEmacsがテキストを標準出力やエラーストリームに出力しているときににEmacsが使用する標準ディスプレイテーブル(standard
display table)。デフォルトが通常は@code{nil}だとしても、curved
quotesを表示できない端末でのインタラクティブなセッションでは、デフォルトでcurved
quotesをASCII近似文字にマップする。@ref{Text Quoting Style}を参照のこと。
@end defvar

@file{disp-table}ライブラリーでは、標準ディスプレイテーブルを変更するために、いくつかの関数を定義されています。

@node Glyphs
@subsection グリフ
@cindex glyph

@cindex glyph code
  @dfn{グリフ(glyph)}とはスクリーン上で1文字を占めるグラフィカルなシンボルです。各グリフはLisp内で@dfn{グリフコード(glyph
code)}として表現されます。これは文字と、表示するフェイスをオプションで指定します(@ref{Faces}を参照)。ディスプレイテーブル内でのエントリーとしての使用がグリフコードの主な用途です(@ref{Display
Tables}を参照)。以下の関数はグリフコードを操作するために使用されます:

@defun make-glyph-code char &optional face
この関数は文字@var{char}を表すグリフをフェイス@var{face}でリターンする。@var{face}が省略か@code{nil}ならグリフはデフォルトフェイスを使用して、その場合にはグリフコードは整数。@var{face}が非@code{nil}ならグリフコードが整数オブジェクトである必要はない。
@end defun

@defun glyph-char glyph
この関数はグリフコード@var{glyph}の文字をリターンする。
@end defun

@defun glyph-face glyph
この関数はグリフコード@var{glyph}のフェイス、または@var{glyph}がデフォルトフェイスを使用する場合には@code{nil}をリターンする。
@end defun

@ifnottex
  テキスト端末上で実際にどのようにグリフコードを表示するかを変更するために@dfn{glyph
table}をセットアップできる。この機能は半ば時代遅れであり、かわりに@code{glyphless-char-display}を使用すること(@ref{Glyphless
Chars}を参照)。

@defvar glyph-table
この変数の値が非@code{nil}なら、それはカレントグリフテーブルである。これは文字端末上でのみ効果があり、グラフィカルディスプレイ上ではすべてのグリフはそのままliteralに表示される。グリフテーブルは@var{g}番目の要素がグリフコード@var{g}の表示方法を指定するようなベクターであること。ここで@var{g}はフェイス未指定なグリフにたいするグリフコード。要素はそれぞれ以下のいずれかであること:

@table @asis
@item @code{nil}
そのグリフをそのままliteralに表示する。

@item 文字列
指定された文字列を端末に送信することによりグリフを表示する。

@item グリフコード
指定されたグリフコードをかわりに表示する。
@end table

グリフテーブルのテーブル長以上の整数グリフコードは、そのままliteralに表示される。
@end defvar
@end ifnottex

@node Glyphless Chars
@subsection グリフなし文字の表示
@cindex glyphless characters

  @dfn{グリフ無し文字(glyphless
characters)}とはliteralに表示されるのではなく特別な方法、すなわち16進コードを中に含むボックスとして表示される文字です。これらの文字にはグリフが無いと明示的に定義された文字や、利用可能なフォントがない文字(グラフィカルなディスプレイ)、その端末のコーディングシステムではエンコードできない文字(テキスト端末)が同様に含まれます。

@defvar glyphless-char-display
この変数の値はグリフ無し文字と表示方法を定義する文字テーブル。エントリーはそれぞれ以下の表示メソッドのいずれかでなければならない:

@table @asis
@item @code{nil}
通常の方法でその文字を表示する。

@item @code{zero-width}
その文字を表示しない。

@item @code{thin-space}
グラフィカルな端末では幅が1ピクセル、テキスト端末では幅が1文字の狭いスペース。

@item @code{empty-box}
空のボックスを表示する。

@item @code{hex-code}
その文字のUnicodeコードポイントの16進表記を含むボックスを表示する。

@item @acronym{ASCII}文字列
その文字列を含むボックスを表示する。文字列には最大で6文字が含まれること。

@item コンスセル @code{(@var{graphical} . @var{text})}
グラフィカルな端末では@var{graphical}、テキスト端末では@var{text}をで表示する。@var{graphical}と@var{text}はいずれも上述した表示メソッドのいずれかでなければならない。
@end table

@noindent
@code{thin-space}、@code{empty-box}、@code{hex-code}、および@acronym{ASCII}文字列は@code{glyphless-char}フェイスで描画される。テキスト端末ではボックスはsquare
brackets @samp{[]}でエミュレートされる。

文字テーブルには利用可能なすべてのフォントでも表示できない、またはその端末のコーディングシステムでエンコードできないすべての文字の表示方法を定義する余分なスロットが1つある。その値は上述した表示メソッドのうち@code{zero-width}とコンスセル以外のいずれかでなければならない。

アクティブなディスプレイテーブル内に非@code{nil}なエントリーをもつ文字では、そのディスプレイテーブルが効果をもつ。この場合にはEmacsは@code{glyphless-char-display}をまったく参照しない。
@end defvar

@defopt glyphless-char-display-control
このユーザーオプションは似かよった文字のグループにたいして@code{glyphless-char-display}をセットする便利な手段を提供する。Lispコードからこの値を直接セットしてはならない。@code{glyphless-char-display}更新するカスタム関数@code{:set}を通じた場合のみ値は効果をもつ。

この値は要素が@code{(@var{group}
.
@var{method})}であるようなalistであること。ここで@var{group}は文字のグループを指定するシンボル、@var{method}はそれらを表示する方法を指定するシンボル。

@var{group}は以下のいずれかであること:

@table @code
@item c0-control
改行文字とタブ文字を除く@code{U+0000}から@code{U+001F}までの@acronym{ASCII}コントロール文字(通常は@samp{^A}のようなエスケープシーケンスとして表示される。@ref{Text
Display,, How Text Is Displayed, emacs, The GNU Emacs Manual}を参照)。

@item c1-control
@code{U+0080}から@code{U+009F}までの非@acronym{ASCII}、非プリント文字(通常は@samp{\230}のような8進エスケープシーケンスとして表示される)。

@item format-control
U+200E @sc{left-to-right mark}のようなUnicode General Category [Cf]の文字だが、U+00AD
@sc{soft hyphen}のようにグラフィックイメージをもつ文字を除く。

@item no-font
適切なフォントが存在しない、あるいはその端末のコーディングシステムではエンコードできない文字。
@end table

@c FIXME: this can also be 'acronym', but that's not currently
@c completely implemented; it applies only to the format-control
@c group, and only works if the acronym is in 'char-acronym-table'.
@var{method}シンボルは@code{zero-width}、@code{thin-space}、@code{empty-box}、@code{hex-code}のいずれかであること。これらは上述の@code{glyphless-char-display}での場合と同様の意味をもつ。
@end defopt

@node Beeping
@section ビープ
@cindex bell

  このセクションではユーザーの注意を喚起するために、Emacsでベルを鳴らす方法を説明します。これを行う頻度は控え目にしてください。頻繁なベルは刺激過剰になる恐れがあります。同様にエラーのシグナル時に過度にビープ音を使用しないよう注意してください。

@defun ding &optional do-not-terminate
@cindex keyboard macro termination
この関数はビープ音を鳴らす、またはスクリーンをフラッシュする(後述の@code{visible-bell}を参照)。@var{do-not-terminate}が@code{nil}なら、この関数はカレントで実行中のキーボードマクロも終了する。
@end defun

@defun beep &optional do-not-terminate
これは@code{ding}のシノニム。
@end defun

@defopt visible-bell
この変数はベルを表すためにスクリーンをフラッシュすべきかどうかを決定する。非@code{nil}ならフラッシュして、@code{nil}ならフラッシュしない。これはグラフィカルなディスプレイで効果的であり、テキスト端末ではその端末のTermcapエントリーが可視ベル(visible
bell) @samp{vb}の能力を定義する。
@end defopt

@defopt ring-bell-function
これが非@code{nil}ならEmacsがどのようにベルを鳴らすかを定義すること。値は引数なしの関数であること。これが非@code{nil}なら@code{visible-bell}より優先される。
@end defopt

@node Window Systems
@section ウィンドウシステム

  Emacsは複数のウィンドウシステムで機能しますが、特にXウィンドウシステムにおいてもっとも機能します。EmacsとXはどちらも``ウィンドウ''を使用しますが異なる使い方をします。EmacsのフレームはXにおいては単一のウィンドウです。Emacsの個々のウィンドウについては、Xはまったく関知しません。

@defvar window-system
この端末ローカルな変数は、Emacsがフレームを表示するのに何のウィンドウシステムを使用しているかを示す。可能な値は、

@table @code
@item x
@cindex X Window System
EmacsはXを使用してフレームを表示している。
@item w32
EmacsはネイティブMS-Windows GUIを使用してフレームを表示している。
@item ns
EmacsはNextstepインターフェイスを使用してフレームを表示している(GNUstepとmacOSで使用されている)。
@item pc
EmacsはMS-DOSのスクリーン直接書き込みを使用してフレームを表示している。
@item nil
Emacsは文字ベース端末を使用してフレームを表示している。
@end table
@end defvar

@defvar initial-window-system
この変数はスタートアップの間にEmacsが作成する最初のフレームにたいして使用される@code{window-system}の値を保持する(デーモンとしてEmacsを呼び出し時には初期フレームを作成しないので、@code{w32}のMS-Windowsを除き@code{initial-window-system}は@code{nil}。@ref{Initial
Options, daemon,, emacs, The GNU Emacs Manual}を参照)。
@end defvar

@defun window-system &optional frame
この関数は@var{frame}を表示するために使用されているウィンドウシステムを示す名前のシンボルをリターンする。この関数がリターンし得るシンボルのリストは変数@code{window-system}の記述と同様。
@end defun

  テキスト端末とグラフィカルなディスプレイで異なる処理を行うコードを記述したいときは、@code{window-system}と@code{initial-window-system}を述語やブーリーンフラグ変数として@emph{使用しないでください}。これは与えられたディスプレイタイプでのEmacsの能力指標として@code{window-system}が適していないからです。かわりに@code{display-graphic-p}、または@ref{Display
Feature Testing}で説明しているその他の述語@code{display-*-p}を使用してください。

@node Tooltips
@section ツールチップ
@cindex tooltips
@dfn{ツールチップ(Tooltips)}はマウスポインターのカレント位置に関連するヘルプ的なヒント(別名``tips'')の表示に使用される特別なフレームです(@ref{Frames}を参照)。Emacsはテキストのアクティブ範囲(@ref{Special
Properties}を参照)、およびメニューアイテム(@ref{Extended Menu
Items}を参照)やツールバーのボタン(@ref{Tool
Bar}を参照)のような種々のUI要素に関するヘルプ文字列の表示にツールチップを使用します。

@defun tooltip-mode
Tooltipモードはツールチップの表示を有効にするマイナーモード。このモードをオフにするとツールチップはエコーエリアに表示される。テキストモード(別名``TTY'')のフレームでは、ツールチップは常にエコーエリアに表示される。
@end defun

@vindex x-gtk-use-system-tooltips
GTK+サポート付きでEmacsがビルドされた際にはデフォルトでGTK+関数を使用してツールチップを表示して、ツールチップの外観はGTK+のセッティングにより制御されます。GTK+ツールチップは変数@code{x-gtk-use-system-tooltips}の値を@code{nil}に変更して無効にできます。このセクションの残りではEmacs自身が提供する非GTK+ツールチップを制御する方法を説明します。

@cindex tooltip frames
ツールチップは独自のパラメーターをもつツールチップフレームと呼ばれる特別なフレームに表示されます(@ref{Frame
Parameters}を参照)。他のフレームとは異なり、ツールチップフレームのデフォルトパラメターは特別な変数に格納されています。

@defopt tooltip-frame-parameters
このカスタマイズ可能なオプションはツールチップ表示に使用するデフォルトのフレームパラメーターを保持する。フォントとカラーに関するパラメーターは無視して、@code{tooltip}フェイスの対応する属性をかわりに使用する。@code{left}や@code{top}のパラメーターが含まれていれば、ツールチップを表示すべきフレームに相対的な絶対座標として使用する(@ref{Tooltips,,,
emacs, The GNU Emacs
Manual}に記された変数を使用すればマウスに相対的なツールチップをカスタマイズできる)。@code{left}と@code{top}のパラメーターが与えられた場合にはマウスに相対的なオフセットをオーバーラードすることに注意。
@end defopt

@vindex tooltip@r{ face}
@code{tooltip}フェイスはツールチップ内に表示されるテキストの見栄えを決定します。デフォルトのフレームフォントより一般的にはサイズの小さい可変ピッチフォントの使用が必要になります。

@findex tooltip-help-tips
@defvar tooltip-functions
これはEmacsがツールチップの表示を必要とする際に呼び出す関数のリストであるようなアブノーマルフック。関数はそれぞれ最後のマウス移動イベントである@var{event}を単一の引数として呼び出される。このリスト上の関数が実際にツールチップを表示するなら非@code{nil}をリターンして、残りの関数は呼び出されない。この変数のデフォルト値は@code{tooltip-help-tips}という1つの関数。
@end defvar

@code{tooltip-functions}のリストに配置する関数を独自に記述する場合には、ツールチップの表示をトリガーしたマウスイベントのバッファーを知る必要があるかもしれません。以下はこの情報を提供する関数です。

@defun tooltip-event-buffer event
この関数は@var{event}が発生したバッファーをリターンする。テキストがツールチップをトリガーしたバッファーを取得するために、これを@code{tooltip-functions}の関数の引数で呼び出す。イベントはバッファーではないところ(たとえばツールバー)で発生したかもしれず、そのような場合にはこの関数は@code{nil}をリターンする。
@end defun

ツールチップ表示に関する他の側面は、いくつかのカスタマイズ可能なセッティングにより制御されます。@ref{Tooltips,,, emacs, The
GNU Emacs Manual}を参照してください。

@node Bidirectional Display
@section 双方向テキストの表示
@cindex bidirectional display
@cindex right-to-left text

  Emacsはアラビア語、ペルシア語、ヘブライ語のような水平方向テキストの自然な表示順がR2L(right-to-left:
右から左)に実行されるようなスクリプトで記述されたテキストを表示できます。さらにL2R(right-to-left:
左から右)のテキストに埋め込まれたR2Lスクリプト(例:
プログラムソースファイル内のアラビア語やヘブライ語のコメント)は適宜右から左にR2Lに表示される一方、ラテンスクリプト部やR2Lテキストに埋め込まれた数字はL2Rで表示されます。そのようなL2RとR2Lが混交されたテキストを、わたしたちは@dfn{双方向テキスト(bidirectional
text)}と呼んでいます。このセクションでは双方向テキストの編集と表示にたいする機能とオプションについて説明します。

@cindex logical order
@cindex reading order
@cindex visual order
@cindex unicode bidirectional algorithm
@cindex UBA
@cindex bidirectional reordering
@cindex reordering, of bidirectional text
  Text is stored in Emacs buffers and strings in @dfn{logical} (or
@dfn{reading}) order, i.e., the order in which a human would read each
character.  In right-to-left and bidirectional text, the order in which
characters are displayed on the screen (called @dfn{visual order}) is not
the same as logical order; the characters' screen positions do not increase
monotonically with string or buffer position.  In performing this
@dfn{bidirectional reordering}, Emacs follows the Unicode Bidirectional
Algorithm (a.k.a.@: @acronym{UBA}), which is described in Annex #9 of the
Unicode standard (@url{https://www.unicode.org/reports/tr9/}).  Emacs
provides a ``Full Bidirectionality'' class implementation of the
@acronym{UBA}, consistent with the requirements of the Unicode Standard
v9.0.  Note, however, that the way Emacs displays continuation lines when
text direction is opposite to the base paragraph direction deviates from the
UBA, which requires to perform line wrapping before reordering text for
display.

@defvar bidi-display-reordering
このバッファーローカル変数の値が非@code{nil}
(デフォルト)なら、Emacsは表示で双方向の並べ替えを行う。この並べ替えはバッファーテキスト、同様に文字列表示やバッファー内のテキストプロパティやオーバーレイプロパティ由来のオーバーレイ文字列に効果を及ぼす(@ref{Overlay
Properties}および@ref{Display
Property}を参照)。値が@code{nil}ならEmacsはバッファー内での双方向の並べ替えを行わない。

@code{bidi-display-reordering}のデフォルト値は、モードライン内に表示されるテキスト(@ref{Mode Line
Format}を参照)、およびヘッダー行(@ref{Header
Lines}を参照)を含む、バッファーにより直接提供されない文字列の並べ替えを制御する。
@end defvar

@cindex unibyte buffers, and bidi reordering
  たとえバッファーの@code{bidi-display-reordering}が非@code{nil}でも、Emacsがユニバイトバッファーのテキストの並べ替えを行うことはありません。これはユニバイトバッファーに含まれるのが文字ではなくrawバイトであり、並べ替えに要する方向的なプロパティを欠くからです。したがってあるバッファーのテキストが並べ替えられるかどうかテストするには、@code{bidi-display-reordering}のテスト単独では不十分です。正しいテストは以下のようになります:

@example
 (if (and enable-multibyte-characters
          bidi-display-reordering)
     ;; 表示時にバッファーは並べ替えられるだろう
   )
@end example

  とはいえ親バッファーが並べ替えられた際には、ユニバイト表示やオーバーレイ文字列は@emph{並べ替えられます}。これはEmacsによりプレーン@sc{ascii}文字列がユニバイト文字列に格納されるからです。ユニバイト表示やオーバーレイ文字列が非@sc{ascii}文字列を含むなら、それらの文字はL2Rの方向をもつとみなされます。

@cindex display properties, and bidi reordering of text
  テキストプロパティ@code{display}、値が文字列であるような@code{display}プロパティによるオーバーレイ、バッファーテキストを置換するその他任意のプロパティにカバーされたテキストは表示時の並べ替えの際には単一の単位として扱われます。つまりこれらのプロパティにカバーされたテキストのchunk全体が一緒に並べ替えられます。さらにそのようなテキストchunk内の文字の双方向的なプロパティは無視されて、Emacsはあたかもそれらが@dfn{オブジェクト置換文字(Object
Replacement
Character)}として知られる単一文字で置換されたかのように並べ替えます。これはテキスト範囲上にdisplayプロパティを配置することにより、表示時に周辺テキストを並べ替える方法が変更され得ることを意味しています。このような予期せぬ効果を防ぐには、常に周辺テキストと等しい方向のテキストにたいしてそのようなプロパティを配置してください。

@cindex base direction of a paragraph
  双方向テキストのパラグラフはそれぞれ、R2LかL2Rいずれかの@dfn{基本方向(base
direction)}をもちます。L2Rパラグラフはウィンドウの左マージンを先頭に表示され、そのテキストが右マージンに達したら切り詰めや継続されます。R2Lパラグラフはウィンドウの右マージンを先頭に表示され、そのテキストが左マージンに達したら切り詰めや継続されます。

@cindex paragraph-start, and bidirectional display
@cindex paragraph-separate, and bidirectional display
  Emacsの@acronym{UBA}実装の目的におけるパラグラフの開始および終了の正確な位置は、以下の2つのローカル変数により決定されます(@code{paragraph-start}と@code{paragraph-separate}に効果はないことに注意)。デフォルトではこれらの変数は@code{nil}であり、パラグラフは空行(改行を後に併なう0個以上の空白文字)で囲まれます。

@defvar bidi-paragraph-start-re
この変数の値が非@code{nil}ならパラグラフの開始か2つのパラグラフを分割する行にマッチする正規表現であること。この正規表現は常に改行の後にマッチするので、それをアンカーにする(@code{"^"}で開始する)のが最善である。
@end defvar

@defvar bidi-paragraph-separate-re
この変数の値が非@code{nil}なら2つのパラグラフを分割する行にマッチする正規表現であること。この正規表現は常に改行の後にマッチするので、それをアンカーにする(@code{"^"}で開始する)のが最善である。
@end defvar

  これら2つの変数
のいずれかを変更する場合には、整合性のあるパラグラフの記述を保証するために、通常は両方を変更するべきです。たとえば双方向の並べ替え目的のために各改行を新たなパラグラフの開始とするには両方の変数に@code{"^"}をセットしてください。

  デフォルトではEmacsはテキスト先頭を調べることにより各パラグラフの基本方向を判断します。基本方向の精細な決定手法は@acronym{UBA}により指定されており、簡潔に言うとその明示にな方向生をもつそのパラグラフ内の最初の文字がパラグラフの基本方向を決定します。とはいえ、あるバッファーが自身のパラグラフにたいして特定の基本方向の強制を要する場合もあります。たとえばプログラムソースコードを含むバッファーは、すべてのパラグラフがL2Rで表示されるよう強制されるべきでしょう。これを行うために以下の変数を使用できます:

@defopt bidi-paragraph-direction
このバッファーローカル変数の値が@code{right-to-left}か@code{left-to-right}いずれかのシンボルなら、そのバッファー内のすべてのパラグラフがその指定された方向をもつとみなされる。その他すべての値は@code{nil}
(デフォルト)と等価であり、それは各パラグラフの基本方向が内容により判断されることを意味する。

@cindex @code{prog-mode}, and @code{bidi-paragraph-direction}
プログラムソースコードにたいするモードは、これを@code{left-to-right}にセットすること。Progモードはデフォルトでこれを行うので、Progモードから派生したモードは明示的にセットする必要はない(@ref{Basic
Major Modes}を参照)。
@end defopt

@defun current-bidi-paragraph-direction &optional buffer
この関数は@var{buffer}という名前のバッファーのポイント位置のパラグラフ方向をリターンする。リターンされる値は@code{left-to-right}か@code{right-to-left}いずれかのシンボルである。@var{buffer}が省略または@code{nil}の場合のデフォルトはカレントバッファー。変数@code{bidi-paragraph-direction}のバッファーローカル値が非@code{nil}なら、リターンされる値はその値と等しくなるだろう。それ以外ならリターンされる値はEmacsにより動的に決定されたパラグラフの方向を反映する。@code{bidi-display-reordering}の値が@code{nil}のバッファー、同様にユニバイトバッファーにたいしては、この関数は常に@code{left-to-right}をリターンする。
@end defun

@cindex visual-order cursor motion
  バッファーのカレントのスクリーン位置にたいして、ビジュアル順にL2RかR2Lいずれかの方向に厳密なポイント移動を要す場合があります。Emacsはこれを行うためのプリミティブを提供します。

@defun move-point-visually direction
この関数は、カレントで選択されたウィンドウのバッファーにたいしてポイントを、スクリーン上ですぐ右か左のポイントへ移動する。@var{direction}が正ならスクリーン位置は右、それ以外ならスクリーン位置は左へ移動するだろう。周囲の双方向コンテキストに依存して、これは潜在的に多くのバッファーのポイントを移動し得ることに注意。スクリーン行終端で呼び出された場合には、この関数は@var{direction}に応じて適宜、次行か前行の右端か左端のスクリーン位置にポイントを移動する。

この関数は値として新たなバッファー位置をリターンする。
@end defun

@cindex layout on display, and bidirectional text
@cindex jumbled display of bidirectional text
@cindex concatenating bidirectional strings
  バッファー内で双方向の内容をもつ2つの文字列が並置されているときや、プログラムで1つのテキスト文字列に結合した場合には、双方向の並べ替えは以外かつ不快な効果を与える可能性があります。典型的な問題ケースはBuffer
MenuモードやRmail
Summaryモードのようにバッファーがスペースや区切り文字分割されたテキストのフィールドのシーケンスで構成されているときです。それはセパレーターとして使用されている区切り文字が@dfn{弱い方向性}をもち、周囲のテキストの方向を採用するためです。結果として双方向の内容のフィールドが後続する数値フィールドは、先行するフィールドヘ@emph{左方向}に表示され、期待したレイアウトを破壊してしまいます。この問題を回避するための方法がいくつかあります：

@itemize @minus
@item
双方向の内容をもち得る各フィールド終端に、スペシャル文字LEFT-TO-RIGHT MARK(略して@acronym{LRM})のU+200E
@sc{left-to-right
mark}を付加する。後述の関数@code{bidi-string-mark-left-to-right}は、この目的に手頃(R2LパラグラフではかわりにRIGHT-TO-LEFT
MARK、略して@acronym{RLM}のU+200F @sc{right-to-left
mark}を使用する)。これはUBAにより推奨される解決策の1つである。

@item
フィールドセパレーターにタブ文字を含める。タブ文字は双方向の並べ替えにおいて@dfn{セグメントセパレーター(segment
separator)}の役割を演じて、両側のテキストを個別に並べ替えさせる。

@cindex @code{space} display spec, and bidirectional text
@item
@code{display}プロパティ、または@code{(space . PROPS)}という形式の値をもつオーバーレイ(@ref{Specified
Space}を参照)でフィールドを区切る。Emacsはこのdisplay仕様を@dfn{パラグラフセパレーター(paragraph
separator)}として扱い両側のテキストを個別に並べ替える。
@end itemize

@defun bidi-string-mark-left-to-right string
この関数は結果を安全に他の文字列に結合できるよう、あるいはこの文字列とスクリーン上で次行となる行に関連するレイアウトを乱すことなくバッファー内の他の文字列に並置できるよう、自身への引数@var{string}を恐らく変更してリターンする。この関数がリターンする文字列がR2Lパラグラフの一部として表示される文字列なら、それは常に後続するテキストの左に出現するだろう。この関数は自身の引数の文字を検証することにより機能して、もしそれらの文字のいずれかがディスプレイ上の並べ替えを発生し得るなら、この関数はその文字列に@acronym{LRM}文字を付加する。付加された@acronym{LRM}文字はテキストプロパティ@code{invisible}に@code{t}を与えることにより不可視にできる(@ref{Invisible
Text}を参照)。
@end defun

  並べ替えアルゴリズムは@code{bidi-class}プロパティとして格納された文字の双方向プロパティを使用します(@ref{Character
Properties}を参照)。Lispプログラムは@code{put-char-code-property}関数を呼び出すことにより、これらのプロパティを変更できます。しかしこれを行うには@acronym{UBA}の完全な理解が要求されるので推奨しません。ある文字の双方向プロパティにたいする任意の変更はグローバルな効果をもちます。これらはEmacsのフレームのすべてのフレームとウィンドウに影響します。

  同様に@code{mirroring}プロパティは並べ替えられたテキスト内の適切にミラーされた文字の表示に使用されます。Lispプログラムはこのプロパティを変更することにより、ミラーされた表示に影響を与えることができます。繰り返しますがそのような変更はEmacsのすべての表示に影響を与えます。

@cindex overriding bidirectional properties
@cindex directional overrides
@cindex LRO
@cindex RLO
  スペシャル双方向制御文字LEFT-TO-RIGHT OVERRIDE (@acronym{LRO})とRIGHT-TO-LEFT OVERRIDE
(@acronym{RLO})をテキストに挿入することにより、文字の双方向プロパティをオーバーライドできます。@acronym{RLO}と改行かPOP
DIRECTIONAL FORMATTING
(@acronym{PDF})のいずれか先にある文字間のすべての文字は、それらが強いR2Lであるかのように表示されます(反転して表示される)。同様に@acronym{LRO}と@acronym{PDF}か改行の間のすべての文字は、それらがたとえ強いR2Lであっても強いL2Rであるかのように反転して表示@emph{されません}。

@cindex phishing using directional overrides
@cindex malicious use of directional overrides
  これらのオーバーライドは、あるテキストを並び替えアルゴリズムの影響を受けずに、直接表示順を制御したいときに有用です。しかしこれらは@dfn{フィッシング(phishing)}として知られるような悪意のある用途にも使用されます。特にウェブ上のURLやemailメッセージ内のリンクは真のリンク先はまったく異なるのに、ブラウザによる論理順で解釈される外観を認識不能に操作したり、何らかの著名で安全なリンク先に偽装される可能性があります。

  Emacsはアプリケーションが使用するために、双方向プロパティでL2R文字をR2L、またはその逆にするようにオーバーライドされたテキストのインスタンスを検知するプリミティブを提供します。

@defun bidi-find-overridden-directionality from to &optional object
この関数は@var{object}で指定されたテキストの@var{from} (含む)と@var{to}
(含まず)の間のテキストを調べてR2Lの文字であるかのように表示が強制されている双方向プロパティの強いL2R文字、L2Rの文字であるかのように表示が強制されている強いR2L文字の最初の位置をリターンする。指定されたテキストリージョンでそのような文字が見つからなければ@code{nil}をリターンする。

オプション引数@var{object}は検索するテキストを指定して、デフォルトはカレントバッファー。@var{object}が非@code{nil}なら別のバッファーや文字列、またはウィンドウかもしれない。文字列ならこの関数はその文字列を検索する。ウィンドウならこの関数はそのウィンドウが表示するバッファーを検索する。検査したいテキストをもつバッファーが何らかのウィンドウに表示されていれば、この関数にバッファーを渡すのではなくそのウィンドウの指定を推奨する。これはウィンドウ固有のオーバーレイにカバーされたバッファーのテキストでは関数の結果が変化し得るが、関数にウィンドウ固有のオーバーレイを正しく考慮するように指示するからである。
@end defun

@cindex copying bidirectional text, preserve visual order
@cindex visual order, preserve when copying bidirectional text
  テキストがR2L文字とL2R文字の混交を含み、かつ双方向制御が別の場所にコピーされる際には、その視覚的外見は変化するかもしれず、コピー先の周辺テキストの視覚的外見にも影響するかもしれません。これは@acronym{UBA}で指定される双方向テキストの並び替えでは、コピーされるテキストとそれを取り囲む周辺テキストの両方が非自明かつコンテキスト依存の効果をもつからです。

  コピーされるテキストとコピー先周辺のテキストの視覚的外見をLispプロパティが保証することが必要なときがあるかもしれません。この効果を達成するためにLispプログラムは以下の関数を使用できます。

@defun buffer-substring-with-bidi-context start end &optional no-properties
この関数は@code{buffer-substring} (@ref{Buffer
Contents}を参照)と同様に機能するが、テキストが別の場所にコピーされる際に視覚的外見を保つために必要な双方向制御文字を前や後に付加する点が異なる。オプション引数@var{no-properties}が非@code{nil}なら、それはテキストのコピーからテキストプロパティを削除することを意味する。
@end defun
