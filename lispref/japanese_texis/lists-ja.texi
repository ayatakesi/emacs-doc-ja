@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================

@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990--1995, 1998--1999, 2001--2024 Free Software
@c Foundation, Inc.
@c See the file elisp-ja.texi for copying conditions.
@node Lists
@chapter リスト
@cindex lists
@cindex element (of list)

  @dfn{リスト(list)}は0個以上の要素(任意のLispオブジェクト)のシーケンスを表します。リストとベクターの重要な違いは、2つ以上のリストが構造の一部を共有できることです。加えて、リスト全体をコピーすることなく要素の挿入と削除ができます。

@menu
* Cons Cells::               コンスセルからリストが作られる方法。
* List-related Predicates::  このオブジェクトはリストか? 
                               2つのリストを比較する。
* List Elements::            リストの一部を抽出する。
* Building Lists::           リスト構造の作成。
* List Variables::           変数に保存されたリストにたいする変更。
* Modifying Lists::          既存のリストに新しい要素を保存する。
* Sets And Lists::           リストは有限な数学集合を表現できる。
* Association Lists::        リストは有限な関係またはマッピングを表現できる。
* Property Lists::           要素ペアのリスト。
@end menu

@node Cons Cells
@section リストとコンスセル
@cindex lists and cons cells

  Lispでのリストは基本データ型ではありません。リストは@dfn{コンスセル(cons cells)}から構築されます(@ref{Cons Cell
Type}を参照)。コンスセルは順序つきペアを表現するデータオブジェクトです。つまりコンスセルは2つのスロットをもち、それぞれのスロットはLispオブジェクトを@dfn{保持(holds)}または@dfn{参照(refers
to)}します。1つのスロットは@sc{car}、もう1つは@sc{cdr}です(これらの名前は歴史的なものである。@ref{Cons Cell
Type}を参照されたい)。@sc{cdr}は``could-er(クダー)''と発音します。

  わたしたちは、コンスセルの@sc{car}スロットに現在保持されているオブジェクトが何であれ、``このコンスセルの@sc{car}は、...''のような言い方をします。これは@sc{cdr}の場合でも同様です。

  リストとは互いに連なる(chained
together)一連のコンスセルであり、各セルは次のセルを参照します。リストの各要素にたいして1つのコンスセルがあります。慣例によりコンスセルの@sc{car}はリストの要素を保持し、@sc{cdr}はリストをチェーンするのに使用されます(@sc{car}と@sc{cdr}の間の非対称性は完全に慣例的なものである。コンスセルのレベルでは@sc{car}スロットと@sc{cdr}スロットは同じようなプロパティをもつ)。したがって、リスト内の各コンスセルの@sc{cdr}スロットは次のコンスセルを参照します。

@cindex proper list
@cindex true list
  これも慣例的なものですがリスト内の最後のコンスセルの@sc{cdr}は@code{nil}です。わたしたちはこのような@code{nil}で終端された構造を@dfn{正リスト(proper
list)}と呼びます@footnote{これは@dfn{真リスト(true
list)}と呼ばれることもありますが、このマニュアルでは一般的にこの用語を使用しません。}。Emacs
Lispではシンボル@code{nil}はシンボルであり、かつ要素なしのリストでもあります。便宜上、シンボル@code{nil}はその@sc{cdr}(と@sc{car})に@code{nil}をもつと考えます。

  したがって正リストの@sc{cdr}は常に正リストです。空でない正リストの@sc{cdr}は1番目の要素以外を含む正リストです。

@cindex dotted list
@cindex circular list
  リストの最後のコンスセルの@sc{cdr}が@code{nil}以外の何らかの値の場合、このリストのプリント表現はドットペア表記(dotted pair
notation。@ref{Dotted Pair
Notation}を参照のこと)を使用するので、わたしたちはこの構造を@dfn{ドットリスト(dotted
list)}と呼びます。他の可能性もあります。あるコンスセルの@sc{cdr}が、そのリストのそれより前にある要素を指すかもしれません。わたしたちは、この構造を@dfn{循環リスト(circular
list)}と呼びます。

  ある目的においてはそのリストが正リストか循環リストなのか、あるいはドットリストなのかが問題にならない場合もあります。そのプログラムがリストを充分に辿って最後のコンスセルの@sc{cdr}を確認しようとしないなら、これは問題になりません。しかしリストを処理する関数のいくつかは正リストを要求し、ドットリストの場合はエラーをシグナルします。リストの最後を探そうと試みる関数のほとんどは循環リストを与えると無限ループに突入します。リストが正リストかどうかを判断するためには、次セクションで説明する関数@code{proper-list-p}
(@ref{List-related Predicates, proper-list-p}を参照)を使うことができます。

@cindex list structure
  ほとんどのコンスセルはリストの一部として使用されるので、わたしたちはコンスセルで構成される任意の構造を@dfn{リスト構造(list
structure)}と呼びます。

@node List-related Predicates
@section リストのための述語
@cindex predicates for lists
@cindex list predicates

  以下の述語はあるLispオブジェクトがアトムか、コンスセルか、リストなのか、またはオブジェクトが@code{nil}かどうかテストします(これらの述語の多くは他の述語で定義することもできるが、多用されるので個別に定義する価値がある)。

@defun consp object
この関数は@var{object}がコンスセルなら@code{t}、それ以外は@code{nil}をリターンする。たとえ@code{nil}が@emph{リスト}であっても、コンスセルではない。
@end defun

@defun atom object
この関数は@var{object}がアトムなら@code{t}、それ以外は@code{nil}をリターンする。シンボル@code{nil}はアトムであり、かつリストでもある。そのようなLispオブジェクトは@code{nil}だけである。

@example
(atom @var{object}) @equiv{} (not (consp @var{object}))
@end example
@end defun

@defun listp object
この関数は@var{object}がコンスセルか@code{nil}なら@code{t}、それ以外は@code{nil}をリターンする。

@example
@group
(listp '(1))
     @result{} t
@end group
@group
(listp '())
     @result{} t
@end group
@end example
@end defun

@defun nlistp object
この関数は@code{listp}の反対である。@var{object}がリストでなければ@code{t}、それ以外は@code{nil}をリターンする。

@example
(listp @var{object}) @equiv{} (not (nlistp @var{object}))
@end example
@end defun

@defun null object
この関数は@var{object}が@code{nil}なら@code{t}、それ以外は@code{nil}をリターンする。この関数は@code{not}と等価だが、明解にするためにわたしたちは@var{object}を真偽値だと考えるときは@code{not}
(@ref{Combining Conditions}の@code{not}を参照)、それ以外の場合に@code{null}を使用している。

@example
@group
(null '(1))
     @result{} nil
@end group
@group
(null '())
     @result{} t
@end group
@end example
@end defun

@defun proper-list-p object
この関数は@var{object}が適正なリストなら@var{object}の長さ、それ以外は@code{nil}をリターンする(@ref{Cons
Cells}を参照)。適正なリストとは@code{listp}を満足することに加えて、循環リストやドットリストでもない。

@example
@group
(proper-list-p '(a b c))
    @result{} 3
@end group
@group
(proper-list-p '(a b . c))
    @result{} nil
@end group
@end example
@end defun

@node List Elements
@section リスト要素へのアクセス
@cindex list elements

@defun car cons-cell
この関数はコンスセル@var{cons-cell}の1番目のスロットが参照する値をリターンする。言い換えるとこの関数は@var{cons-cell}の@sc{car}をリターンする。

特別なケースとして@var{cons-cell}が@code{nil}の場合、この関数は@code{nil}をリターンする。したがってリストはすべて引数として有効である。引数がコンスセルでも@code{nil}でもなければエラーがシグナルされる。

@example
@group
(car '(a b c))
     @result{} a
@end group
@group
(car '())
     @result{} nil
@end group
@end example
@end defun

@defun cdr cons-cell
この関数はコンスセル@var{cons-cell}の2番目のスロットにより参照される値をリターンする。言い換えるとこの関数は@var{cons-cell}の@sc{cdr}をリターンする。

特別なケースとして@var{cons-cell}が@code{nil}の場合、この関数は@code{nil}をリターンする。したがってリストはすべて引数として有効である。引数がコンスセルでも@code{nil}でもければエラーがシグナルされる。

@example
@group
(cdr '(a b c))
     @result{} (b c)
@end group
@group
(cdr '())
     @result{} nil
@end group
@end example
@end defun

@defun car-safe object
この関数により他のデータ型によるエラーを起こさずに、コンスセルの@sc{car}を取得できり。この関数は@var{object}がコンスセルなら@var{object}の@sc{car}、それ以外は@code{nil}をリターンする。この関数は、@var{object}がリストでなければエラーをシグナルする@code{car}とは対象的である。

@example
@group
(car-safe @var{object})
@equiv{}
(let ((x @var{object}))
  (if (consp x)
      (car x)
    nil))
@end group
@end example
@end defun

@defun cdr-safe object
この関数により他のデータ型によるエラーを起こさずに、コンスセルの@sc{cdr}を取得できる。この関数は@var{object}がコンスセルなら@var{object}の@sc{cdr}、それ以外は@code{nil}をリターンする。この関数は、@var{object}がリストでないときはエラーをシグナルする@code{cdr}とは対象的である。

@example
@group
(cdr-safe @var{object})
@equiv{}
(let ((x @var{object}))
  (if (consp x)
      (cdr x)
    nil))
@end group
@end example
@end defun

@defmac pop listname
このマクロはリストの@sc{car}を調べて、それをリストから取り去るのを一度に行なう便利な方法を提供する。この関数は@var{listname}に格納されたリストにたいして処理を行なう。この関数はリストから1番目の要素を削除して、@sc{cdr}を@var{listname}に保存し、その後で削除した要素をリターンする。

もっとも単純なケースは、リストに名前をつけるためのクォートされていないシンボルの場合である。この場合、このマクロは@w{@code{(prog1
(car listname) (setq listname (cdr listname)))}}と等価である。

@example
x
     @result{} (a b c)
(pop x)
     @result{} a
x
     @result{} (b c)
@end example

より一般的なのは@var{listname}が汎変数(generalized
variable)の場合である。この場合、このマクロは@code{setf}を使用して@var{listname}に保存する。@ref{Generalized
Variables}を参照のこと。

リストに要素を追加する@code{push}マクロについては@ref{List Variables}を参照のこと。
@end defmac

@defun nth n list
@anchor{Definition of nth}
この関数は@var{list}の@var{n}番目の要素をリターンする。要素は0から数えられるので@var{list}の@sc{car}は要素0になる。@var{list}の長さが@var{n}以下なら値は@code{nil}。

@c Behavior for -ve n undefined since 2013/08; see bug#15059.
@ignore
If @var{n} is negative, @code{nth} returns the first element of @var{list}.
@end ignore

@example
@group
(nth 2 '(1 2 3 4))
     @result{} 3
@end group
@group
(nth 10 '(1 2 3 4))
     @result{} nil

(nth n x) @equiv{} (car (nthcdr n x))
@end group
@end example

これは関数@code{elt}も類似しているが、任意の種類のシーケンスに適用される。歴史的な理由によりこの関数は逆の順序で引数を受け取る。@ref{Sequence
Functions}を参照のこと。
@end defun

@findex drop
@defun nthcdr n list
この関数は@var{list}の@var{n}番目の@sc{cdr}をリターンする。言い換えると、この関数は@var{list}の最初の@var{n}個のリンクをスキップしてから、それ以降をリターンする。

@c "or negative" removed 2013/08; see bug#15059.
@var{n}が0なら@code{nthcdr}は@var{list}全体をリターンする。@var{list}の長さが@var{n}以下なら@code{nthcdr}は@code{nil}をリターンする。

@code{nthcdr}のエイリアスは@code{drop}。

@example
@group
(nthcdr 1 '(1 2 3 4))
     @result{} (2 3 4)
@end group
@group
(nthcdr 10 '(1 2 3 4))
     @result{} nil
@end group
@group
(nthcdr 0 '(1 2 3 4))
     @result{} (1 2 3 4)
@end group
@end example
@end defun

@defun take n list
この関数は@var{list}の最初の@var{n}個の要素をリターンする。要するに@var{list}から@code{nthcdr}をスキップした部分をリターンする。

@var{list}の要素の数が@var{n}より少なければ@var{list}、@var{n}が0か負なら@code{nil}をリターンする。

一般的に@code{(append (take @var{n} @var{list}) (drop @var{n}
@var{list}))}は@var{list}と同じリストをリターンする。

@example
@group
(take 3 '(a b c d))
     @result{} (a b c)
@end group
@group
(take 10 '(a b c d))
     @result{} (a b c d)
@end group
@group
(take 0 '(a b c d))
     @result{} nil
@end group
@end example
@end defun

@defun ntake n list
これは引数であるリストの構造を破壊的に変更することによって機能するバージョンの@code{take}である。これにより高速になるが、@var{list}の元の値は失われるだろう。

@code{ntake}は要素の数が@var{n}より少なければ変更せずに@var{list}を、@var{n}が0か負なら@code{nil}をリターンする。それ以外の場合には最初の@var{n}個の要素に切り詰められた@var{list}をリターンする。

これは@var{n}が正だと判っていない場合には単純に切り詰め効果を信頼するのではなく、通常はリターン値を使うほうが賢明だということを意味している。
@end defun

@defun last list &optional n
この関数は@var{list}の最後のリンクをリターンする。このリンクの@code{car}はこのリストの最後の要素。@var{list}がnullなら@code{nil}がリターンされる。@var{n}が非@code{nil}なら@var{n}番目から最後までのリンクがリターンされる。@var{n}が@var{list}の長さより大きければ@var{list}全体がリターンされる。
@end defun

@defun safe-length list
@anchor{Definition of safe-length}
この関数はエラーや無限ループの危険なしで、@var{list}の長さをリターンする。この関数は一般的に、リスト内のコンスセルの個数をリターンする。しかし循環リストでは単に上限値が値となるため、非常に大きくなる場合があります。

@var{list}が@code{nil}とコンスセルのいずれでもなければ@code{safe-length}は0をリターンする。
@end defun

  循環リストを考慮しなくてもよい場合にリストの長さを計算するもっとも一般的な方法は、@code{length}を使う方法です。@ref{Sequence
Functions}を参照してください。

@defun caar cons-cell
これは@code{(car (car @var{cons-cell}))}と同じ。
@end defun

@defun cadr cons-cell
これは@code{(car (cdr @var{cons-cell}))}か@code{(nth 1 @var{cons-cell})}と同じ。
@end defun

@defun cdar cons-cell
これは@code{(cdr (car @var{cons-cell}))}と同じ。
@end defun

@defun cddr cons-cell
これは@code{(cdr (cdr @var{cons-cell}))}か@code{(nthcdr 2 @var{cons-cell})}と同じ。
@end defun

@findex caaar
@findex caadr
@findex cadar
@findex caddr
@findex cdaar
@findex cdadr
@findex cddar
@findex cdddr
@findex caaaar
@findex caaadr
@findex caadar
@findex caaddr
@findex cadaar
@findex cadadr
@findex caddar
@findex cadddr
@findex cdaaar
@findex cdaadr
@findex cdadar
@findex cdaddr
@findex cddaar
@findex cddadr
@findex cdddar
@findex cddddr
上記に加えて@code{c@var{xxx}r}や@code{c@var{xxxx}r}のような@code{car}と@code{cdr}で構成される24の関数が定義されています。ここで@code{@var{x}}は@code{a}か@code{d}のいずれかです。@code{cadr}と@code{caddr}と@code{cadddr}はそれぞれリストの2つ目、3つ目、4つ目の要素です。@file{cl-lib}は同じものを@code{cl-second}、@code{cl-third}、@code{cl-fourth}という名前で提供しています。@ref{List
Functions,,, cl, Common Lisp Extensions}を参照してください。

@defun butlast x &optional n
この関数はリスト@var{x}から、最後の要素か最後の@var{n}個の要素を削除してリターンする。@var{n}が0より大きければこの関数はリストのコピーを作成するので、元のリストに影響はない。一般的に@code{(append
(butlast @var{x} @var{n})  (last @var{x} @var{n}))}は、@var{x}と等しいリストをリターンする。
@end defun

@defun nbutlast x &optional n
この関数はリストのコピーを作成するのではなく、@code{cdr}を適切な要素に変更することにより破壊的に機能するバージョンの@code{butlast}である。
@end defun

@node Building Lists
@section コンスセルおよびリストの構築
@cindex cons cells
@cindex building lists

  リストはLispの中核にあたる機能なので、リストを構築するために多くの関数があります。@code{cons}はリストを構築する基本的な関数です。しかしEmacsのソースコードでは、@code{cons}より@code{list}のほうが多く使用されているのは興味深いことです。

@defun cons object1 object2
この関数は新しいリスト構造を構築するための、もっとも基本的な関数である。この関数は@var{object1}を@sc{car}、@var{object2}を@sc{cdr}とする新しいコンスセルを作成して、それから新しいコンスセルをリターンする。引数@var{object1}と@var{object2}には任意のLispオブジェクトを指定できるが、ほとんどの場合@var{object2}はリストである。

@example
@group
(cons 1 '(2))
     @result{} (1 2)
@end group
@group
(cons 1 '())
     @result{} (1)
@end group
@group
(cons 1 2)
     @result{} (1 . 2)
@end group
@end example

@cindex consing
リストの先頭に1つの要素を追加するために、@code{cons}がよく使用される。これを@dfn{リストに要素をコンスする}と言います。@footnote{リストの最後に要素を追加するための、これと完全に同等な方法はありません。@var{listname}をコピーすることにより新しいリストを作成してから、@var{newelt}をそのリストの最後に追加する@code{(append
@var{listname} (list
@var{newelt}))}を使用することができます。すべての@sc{cdr}を辿って終端の@code{nil}を置き換える、@code{(nconc
@var{listname} (list
@var{newelt}))}を使用することもできます。コピーも変更も行なわずにリストの先頭に要素を追加する@code{cons}と比較してみてください。}たとえば:

@example
(setq list (cons newelt list))
@end example

この例で使用されている@code{list}という名前の変数と、以下で説明する@code{list}という名前の関数は競合しないことに注意されたい。すべてのシンボルが、変数と関数の両方の役割を果たすことができる。
@end defun

@defun list &rest objects
この関数は@var{objects}を要素とするリストを作成する。結果となるリストは常に@code{nil}で終端される。@var{objects}を指定しないと空リストがリターンされる。

@example
@group
(list 1 2 3 4 5)
     @result{} (1 2 3 4 5)
@end group
@group
(list 1 2 '(3 4 5) 'foo)
     @result{} (1 2 (3 4 5) foo)
@end group
@group
(list)
     @result{} nil
@end group
@end example
@end defun

@defun make-list length object
この関数は各要素が@var{object}であるような、@var{length}個の要素からなるリストを作成する。@code{make-list}と@code{make-string}(@ref{Creating
Strings}を参照)を比較してみよ。

@example
@group
(make-list 3 'pigs)
     @result{} (pigs pigs pigs)
@end group
@group
(make-list 0 'pigs)
     @result{} nil
@end group
@group
(setq l (make-list 3 '(a b)))
     @result{} ((a b) (a b) (a b))
(eq (car l) (cadr l))
     @result{} t
@end group
@end example
@end defun

@defun append &rest sequences
@cindex copying lists
この関数は@var{sequences}のすべての要素を含むリストをreturnします。@var{sequences}にはリスト、ベクター、ブールベクター、文字列も指定できるが、通常は最後にリストを指定すること。最後の引数を除くすべての引数はコピーされるので、変更される引数はない(コピーを行なわずにリストを結合する方法については@ref{Rearrangement}の@code{nconc}を参照のこと)。

より一般的には@code{append}にたいする最後の引数は任意のLispオブジェクトを指定できる。最後の引数のコピーや変換は行わない。最後の引数は新しいリストの最後のコンスセルの@sc{cdr}となる。最後の引数もリストならば、このリストの要素は実質的には結果リストの要素になる。最後の要素がリストでなければ、最後の@sc{cdr}が(正リストで要求される)@code{nil}ではないので結果はドットリストになる(@ref{Cons
Cells}を参照)。
@end defun

  以下は@code{append}を使用した例です:

@example
@group
(setq trees '(pine oak))
     @result{} (pine oak)
(setq more-trees (append '(maple birch) trees))
     @result{} (maple birch pine oak)
@end group

@group
trees
     @result{} (pine oak)
more-trees
     @result{} (maple birch pine oak)
@end group
@group
(eq trees (cdr (cdr more-trees)))
     @result{} t
@end group
@end example

  @code{append}がどのように機能するか、ボックスダイアグラムで確認できます。変数@code{trees}はリスト@code{(pine
oak)}にセットされ、それから変数@code{more-trees}にリスト@code{(maple birch pine
oak)}がセットされます。しかし変数@code{trees}は継続して元のリストを参照します:

@smallexample
@group
more-trees                trees
|                           |
|     --- ---      --- ---   -> --- ---      --- ---
 --> |   |   |--> |   |   |--> |   |   |--> |   |   |--> nil
      --- ---      --- ---      --- ---      --- ---
       |            |            |            |
       |            |            |            |
        --> maple    -->birch     --> pine     --> oak
@end group
@end smallexample

  空のシーケンスは@code{append}によりリターンされる値に寄与しません。この結果、最後の引数に@code{nil}を指定すると、それより前の引数のコピーを強制することになります。

@example
@group
trees
     @result{} (pine oak)
@end group
@group
(setq wood (append trees nil))
     @result{} (pine oak)
@end group
@group
wood
     @result{} (pine oak)
@end group
@group
(eq wood trees)
     @result{} nil
@end group
@end example

@noindent
関数@code{copy-sequence}が導入される以前は,これがリストをコピーする通常の方法でした。@ref{Sequences Arrays
Vectors}を参照してください。

  以下は@code{append}の引数としてベクターと文字列を使用する例です:

@example
@group
(append [a b] "cd" nil)
     @result{} (a b 99 100)
@end group
@end example

  @code{apply} (@ref{Calling
Functions}を参照)の助けを借りることにより、リストのリストの中のすべてのリストをappendできます。

@example
@group
(apply 'append '((a b c) nil (x y z) nil))
     @result{} (a b c x y z)
@end group
@end example

  @var{sequences}が与えられなければ@code{nil}がリターンされます:

@example
@group
(append)
     @result{} nil
@end group
@end example

  以下は最後の引数がリストでない場合の例です:

@example
(append '(x y) 'z)
     @result{} (x y . z)
(append '(x y) [z])
     @result{} (x y . [z])
@end example

@noindent
2番目の例は最後の引数はリストではないシーケンスの場合で、このシーケンスの要素は、結果リストの要素にはなりません。かわりに最後の引数がリストでないときと同様、シーケンスが最後の@sc{cdr}になります。

@defun copy-tree tree &optional vectors-and-records
この関数はツリー@var{tree}のコピーをリターンする。@var{tree}がコンスセルなら同じ@sc{car}と@sc{cdr}をもつ新しいコンスセルを作成してから、同じ方法によって@sc{car}と@sc{cdr}を再帰的にコピーする。

@var{tree}がコンスセル以外の場合、通常は@code{copy-tree}は単に@var{tree}をリターンする。しかし@var{vectors-and-records}が非@code{nil}なら、この関数はベクターとレコードもコピーします(そしてベクターの要素を再帰的に処理する)。@var{tree}引数は循環を含んでいてはならない。
@end defun

@defun flatten-tree tree
この関数は@var{tree}を``平坦化''したコピー(
@var{tree}をルートとするコンスセルのツリーのすべての非@code{nil}な終端nodeとleave)をリターンする。リターンされたリストのleaveの順序は@var{tree}での順序と同じ。
@end defun

@example
(flatten-tree '(1 (2 . 3) nil (4 5 (6)) 7))
    @result{}(1 2 3 4 5 6 7)
@end example

@defun ensure-list object
この関数は@var{object}をリストとしてリターンする。@var{object}がすでにリストならそれをリターンし、それ以外なら@var{object}を含む1要素のリストをリターンする。

これは通常はリストのときもあればそうでないときもある変数を使用する場合に有用であり、たとえば以下のような記述ができる:

@lisp
(dolist (elem (ensure-list foo))
  (princ elem))
@end lisp
@end defun

@defun number-sequence from &optional to separation
この関数は@var{from}から@var{separation}ずつインクリメントして、@var{to}の直前で終わる数字のリストをリターンする。@var{separation}には正か負の数を指定でき、デフォルトは1。@var{to}が@code{nil}、または数値的に@var{from}と等しければ、値は1要素のリスト@code{(@var{from})}になる。@var{separation}が正で@var{to}が@var{from}より小さい、または@var{separation}が負で@var{to}が@var{from}より大きければ、これらの引数は空のシーケンスを指示することになるので、値は@code{nil}になる。

@var{separation}が0で、@var{to}が@code{nil}でもなく、数値的に@var{from}とも等しくなければ、これらの引数は無限シーケンスを指示することになるので、エラーがシグナルされる。

引数はすべて数字である。浮動小数点数の計算は正確ではないので、浮動小数点数の引数には注意する必要がある。たとえばマシンへの依存により、@code{(number-sequence
0.4 0.8 0.2)}が3要素のリストをリターンして、@code{(number-sequence 0.4 0.6
0.2)}が1要素のリスト@code{(0.4)}をリターンすることがよく起こる。リストの@var{n}番目の要素は、厳密に@code{(+
@var{from} (* @var{n}
@var{separation}))}という式により計算される。リストに確実に@var{to}が含まれるようにするために、この式に適切な型の@var{to}を渡すことができる。別の方法として@var{to}を少しだけ大きな値(@var{separation}が負なら少しだけ小さな値)に置き換えることもできる。

例をいくつか示す:

@example
(number-sequence 4 9)
     @result{} (4 5 6 7 8 9)
(number-sequence 9 4 -1)
     @result{} (9 8 7 6 5 4)
(number-sequence 9 4 -2)
     @result{} (9 7 5)
(number-sequence 8)
     @result{} (8)
(number-sequence 8 5)
     @result{} nil
(number-sequence 5 8 -1)
     @result{} nil
(number-sequence 1.5 6 2)
     @result{} (1.5 3.5 5.5)
@end example
@end defun

@node List Variables
@section リスト変数の変更
@cindex modify a list
@cindex list modification

  以下の関数と1つのマクロは、変数に格納されたリストを変更する便利な方法を提供します。

@defmac push element listname
このマクロは@sc{car}が@var{element}で、@sc{cdr}が@var{listname}のリストであるような新しいリストを作成して、そのリストを@var{listname}に保存する。@var{listname}がリストに名前をつけるクォートされていないシンボルのときは単純で、この場合マクロは@w{@code{(setq
@var{listname} (cons @var{element} @var{listname}))}}と等価になる。

@example
(setq l '(a b))
     @result{} (a b)
(push 'c l)
     @result{} (c a b)
l
     @result{} (c a b)
@end example

より一般的なのは@code{listname}が汎変数の場合である。この場合、このマクロは@w{@code{(setf @var{listname}
(cons @var{element} @var{listname}))}}と等価になる。@ref{Generalized
Variables}を参照のこと。

リストから1番目の要素を取り出す@code{pop}マクロについては、@ref{List Elements}を参照されたい。
@end defmac

  以下の2つの関数は、変数の値であるリストを変更します。

@defun add-to-list symbol element &optional append compare-fn
この関数は@var{element}が@var{symbol}の値のメンバーでなければ、@var{symbol}に@var{element}をコンスすることにより、変数@var{symbol}をセットする。この関数はリストが更新されているか否かに関わらず、結果のリストをリターンする。@var{symbol}の値は呼び出し前にすでにリストであることが望ましい。@var{element}がリストの既存メンバーか比較するために、@code{add-to-list}は@var{compare-fn}を使用する。@var{compare-fn}が@code{nil}なら@code{equal}を使用する。

@var{element}が追加される場合は、通常は@var{symbol}の前に追加されるが、オプションの引数@var{append}が非@code{nil}なら最後に追加される。

引数@var{symbol}は暗黙にクォートされない。@code{setq}とは異なり@code{add-to-list}は@code{set}のような通常の関数である。クォートしたい場合には自分で引数をクォートすること。

This function is for adding elements to configuration variables such as
@code{load-path} (@pxref{Library Search}), @code{image-load-path}
(@pxref{Defining Images}), etc.  Its code includes quite a few special
checks for these uses, and emits warnings in support of them.  For this
reason, we recommend against using it in Lisp programs for constructing
arbitrary lists; use @code{push} instead.  @xref{List Variables}.

@var{symbol}がレキシカル変数を参照する際にはこの関数を使用しないこと。
@end defun

以下に@code{add-to-list}を使用する方法をシナリオで示します:

@example
(setq foo '(a b))
     @result{} (a b)

(add-to-list 'foo 'c)     ;; @r{@code{c}を追加}
     @result{} (c a b)

(add-to-list 'foo 'b)     ;; @r{効果なし}
     @result{} (c a b)

foo                       ;; @r{@code{foo}が変更された}
     @result{} (c a b)
@end example

  以下は@code{(add-to-list '@var{var} @var{value})}と等価な式です:

@example
(if (member @var{value} @var{var})
    @var{var}
  (setq @var{var} (cons @var{value} @var{var})))
@end example

@defun add-to-ordered-list symbol element &optional order
この関数は古い値の@var{order}
(リストであること)で指定された位置に、@var{element}を挿入して変数@var{symbol}をセットする。@var{element}がすでにこのリストのメンバなら、リスト内の要素の位置は@var{order}にしたがって調整される。メンバーか否かは@code{eq}を使用してテストされる。この関数は更新されているかどうかに関わらず、結果のリストをリターンする。

@var{order}は通常は数字(整数か浮動小数点数)で、リストの要素はその数字の昇順で並べられる。

@var{order}は省略または@code{nil}を指定できる。これによりリストに@var{element}がすでに存在するなら、@var{element}の数字順序は変更されない。それ以外なら@var{element}は数字順序をもたない。リストの数字順序をもたない要素はリストの最後に配置され、特別な順序はつかない。

@var{order}に他の値を指定すると、@var{element}がすでに数字順序をもつときは数字順序が削除される。それ以外はなら@code{nil}と同じ。

引数@var{symbol}は暗黙にクォートされない。@code{add-to-ordered-list}は@code{setq}などとは異なり、@code{set}のような通常の関数である。必要なら引数を自分でクォートすること。

順序の情報は@var{symbol}の@code{list-order}プロパティにハッシュテーブルで保存される。@var{symbol}はレキシカル変数を参照できない。
@end defun

以下に@code{add-to-ordered-list}を使用する方法をシナリオで示します:

@example
(setq foo '())
     @result{} nil

(add-to-ordered-list 'foo 'a 1)     ;; @r{@code{a}を追加}
     @result{} (a)

(add-to-ordered-list 'foo 'c 3)     ;; @r{@code{c}を追加}
     @result{} (a c)

(add-to-ordered-list 'foo 'b 2)     ;; @r{@code{b}を追加}
     @result{} (a b c)

(add-to-ordered-list 'foo 'b 4)     ;; @r{@code{b}を移動}
     @result{} (a c b)

(add-to-ordered-list 'foo 'd)       ;; @r{@code{d}を後に追加}
     @result{} (a c b d)

(add-to-ordered-list 'foo 'e)       ;; @r{@code{e}を追加}
     @result{} (a c b e d)

foo                       ;; @r{@code{foo}が変更された}
     @result{} (a c b e d)
@end example

@node Modifying Lists
@section 既存のリスト構造の変更
@cindex destructive list operations
@cindex mutable lists

  プリミティブ@code{setcar}と@code{setcdr}でコンスセルの@sc{car}および@sc{cdr}のコンテンツを変更できます。これらは既存のリスト構造を変更するので破壊的な操作です。破壊的操作はmutable(変更可能)なリスト、すなわち@code{cons}、@code{list}、または類似の操作により構築される必要があります。クォートにより作成されたリストはプログラムの一部であり、破壊的な操作により変更するべきではありません。@ref{Mutability}を参照してください。

@cindex CL note---@code{rplaca} vs @code{setcar}
@quotation
@findex rplaca
@findex rplacd
@b{Common Lispに関する注意: }Common
Lispはリスト構造の変更に@code{rplaca}と@code{rplacd}を使用する。これらは@code{setcar}や@code{setcdr}と同じ方法でリスト構造を変更するが、@code{setcar}と@code{setcdr}は新しい@sc{car}や@sc{cdr}をリターンするのにたいして、Common
Lispの関数はコンスセルをリターンする。
@end quotation

@menu
* Setcar::                   リスト内の要素の置き換え。
* Setcdr::                   リストの根幹部分の置き換え。これは要素の追加や削除に使用される。
* Rearrangement::            リスト内の要素の再配置、リストの合成。
@end menu

@node Setcar
@subsection @code{setcar}によるリスト要素の変更
@cindex replace list element
@cindex list, replace element

  コンスセルの@sc{car}の変更は@code{setcar}で行ないます。リストにたいして使用すると@code{setcar}はリストの1つの要素を別の要素に置き換えます。

@defun setcar cons object
この関数は以前の@sc{car}を置き換えて、@var{cons}の新しい@sc{car}に@var{object}を格納する。言い換えると、この関数は@var{cons}の@sc{car}スロットを@var{object}を参照するように変更する。この関数は値@var{object}をリターンする。たとえば:

@example
@group
(setq x (list 1 2))
     @result{} (1 2)
@end group
@group
(setcar x 4)
     @result{} 4
@end group
@group
x
     @result{} (4 2)
@end group
@end example
@end defun

  コンスセルが複数のリストを共有する構造の一部なら、コンスに新しい@sc{car}を格納することにより、これら共有されたリストの各1つの要素を変更します。以下は例です:

@example
@group
;; @r{部分的に共有された2つのリストを作成}
(setq x1 (list 'a 'b 'c))
     @result{} (a b c)
(setq x2 (cons 'z (cdr x1)))
     @result{} (z b c)
@end group

@group
;; @r{共有されたリンクの@sc{car}を置き換え}
(setcar (cdr x1) 'foo)
     @result{} foo
x1                           ; @r{両方のリストが変更された}
     @result{} (a foo c)
x2
     @result{} (z foo c)
@end group

@group
;; @r{共有されていないリンクの@sc{car}を置き換え}
(setcar x1 'baz)
     @result{} baz
x1                           ; @r{1つのリストだけが変更された}
     @result{} (baz foo c)
x2
     @result{} (z foo c)
@end group
@end example

  なぜ@code{b}を置き換えると両方が変更されるのかを説明するために、変数@code{x1}と@code{x2}の2つのリストによる共有構造を視覚化してみましょう:

@example
@group
        --- ---        --- ---      --- ---
x1---> |   |   |----> |   |   |--> |   |   |--> nil
        --- ---        --- ---      --- ---
         |        -->   |            |
         |       |      |            |
          --> a  |       --> b        --> c
                 |
       --- ---   |
x2--> |   |   |--
       --- ---
        |
        |
         --> z
@end group
@end example

  同じ関係を別のボックス図で示すと、以下のようになります:

@example
@group
x1:
 --------------       --------------       --------------
| car   | cdr  |     | car   | cdr  |     | car   | cdr  |
|   a   |   o------->|   b   |   o------->|   c   |  nil |
|       |      |  -->|       |      |     |       |      |
 --------------  |    --------------       --------------
                 |
x2:              |
 --------------  |
| car   | cdr  | |
|   z   |   o----
|       |      |
 --------------
@end group
@end example

@node Setcdr
@subsection リストのCDRの変更
@cindex replace part of list

  @sc{cdr}を変更するもっとも低レベルのプリミティブ関数は@code{setcdr}です:

@defun setcdr cons object
この関数は前の@sc{cdr}を置き換えて、@var{cons}の新しい@sc{cdr}に@var{object}を格納する。言い換えると、この関数は@var{cons}の@sc{cdr}が@var{object}を参照するように変更する。この関数は値@var{object}をリターンする。
@end defun

  以下はリストの@sc{cdr}を、他のリストに置き換える例です。1番目の要素以外のすべての要素は、別のシーケンスまたは要素のために取り除かれます。1番目の要素はリストの@sc{car}なので変更されず、@sc{cdr}を通じて到達することもできないからです。

@example
@group
(setq x (list 1 2 3))
     @result{} (1 2 3)
@end group
@group
(setcdr x '(4))
     @result{} (4)
@end group
@group
x
     @result{} (1 4)
@end group
@end example

  リスト内のコンスセルの@sc{cdr}を変更することにより、リストの途中から要素を削除できます。たとえば以下では、1番目のコンスセルの@sc{cdr}を変更することにより、2番目の要素@code{b}をリスト@code{(a
b c)}から削除します。

@example
@group
(setq x1 (list 'a 'b 'c))
     @result{} (a b c)
(setcdr x1 (cdr (cdr x1)))
     @result{} (c)
x1
     @result{} (a c)
@end group
@end example

  以下に結果をボックス表記で示します:

@smallexample
@group
                   --------------------
                  |                    |
 --------------   |   --------------   |    --------------
| car   | cdr  |  |  | car   | cdr  |   -->| car   | cdr  |
|   a   |   o-----   |   b   |   o-------->|   c   |  nil |
|       |      |     |       |      |      |       |      |
 --------------       --------------        --------------
@end group
@end smallexample

@noindent
以前は要素@code{b}を保持していた2番目のコンスセルは依然として存在し、その@sc{car}も@code{b}のままですが、すでにこのリストの一部を形成していません。

  @sc{cdr}を変更して新しい要素を挿入するのも同じくらい簡単です:

@example
@group
(setq x1 (list 'a 'b 'c))
     @result{} (a b c)
(setcdr x1 (cons 'd (cdr x1)))
     @result{} (d b c)
x1
     @result{} (a d b c)
@end group
@end example

  以下に結果をボックス表記で示します:

@smallexample
@group
 --------------        -------------       -------------
| car  | cdr   |      | car  | cdr  |     | car  | cdr  |
|   a  |   o   |   -->|   b  |   o------->|   c  |  nil |
|      |   |   |  |   |      |      |     |      |      |
 --------- | --   |    -------------       -------------
           |      |
     -----         --------
    |                      |
    |    ---------------   |
    |   | car   | cdr   |  |
     -->|   d   |   o------
        |       |       |
         ---------------
@end group
@end smallexample

@node Rearrangement
@subsection リストを再配置する関数
@cindex rearrangement of lists
@cindex reordering, of elements in lists
@cindex modification of lists

  以下ではリストの構成要素であるコンスセルの@sc{cdr}を変更することにより、リストを破壊的に再配置する関数をいくつか示します。これらの関数が破壊的だという理由は、これらの関数が引数として渡された元のリストを処理してリターン値となる新しいリストを形成するために、リストのコンスセルを再リンクするからです。

@ifnottex
  コンスセルを変更する他の関数については、@ref{Sets And Lists}の@code{delq}を参照してください。
@end ifnottex
@iftex
   以降のセクションで説明する関数@code{delq}は、破壊的にリストを操作する別の例です。
@end iftex

@defun nconc &rest lists
@cindex concatenating lists
@cindex joining lists
この関数は@var{lists}の要素すべてを含むリストをリターンする。@code{append} (@ref{Building
Lists}を参照)とは異なり、@var{lists}は@emph{コピーされない}。かわりに@var{lists}の各リストの最後の@sc{cdr}が次のリストを参照するように変更される。@var{lists}の最後のリストは変更されない。たとえば:

@example
@group
(setq x (list 1 2 3))
     @result{} (1 2 3)
@end group
@group
(nconc x '(4 5))
     @result{} (1 2 3 4 5)
@end group
@group
x
     @result{} (1 2 3 4 5)
@end group
@end example

   @code{nconc}の最後の引数は変更されないので、上記の例のように@code{'(4
5)}のような定数リストを使用するのが合理的である。また同じ理由により最後の引数がリストである必要はない。

@example
@group
(setq x (list 1 2 3))
     @result{} (1 2 3)
@end group
@group
(nconc x 'z)
     @result{} (1 2 3 . z)
@end group
@group
x
     @result{} (1 2 3 . z)
@end group
@end example

しかし他の(最後を除くすべての)引数はmutableリストでなければなければならない。これらの引数はドットリストでもよく、その場合には@sc{cdr}の最後はは次の引数で置き換えられる:

@example
@group
(nconc (cons 1 2) (cons 3 (cons 4 5)) 'z)
     @result{} (1 3 4 . z)
@end group
@end example

一般的な落とし穴としては、@code{nconc}にたいしてリスト定数を最後以外の引数として使用した場合である。これを行なった場合の結果としての挙動は未定義である(@ref{Self-Evaluating
Forms}を参照)。実行するごとにプログラムはリスト定数を変更する可能性がある! (必ず発生する保証はないが)以下のようなことが起こり得る:

@smallexample
@group
(defun add-foo (x)            ; @r{この関数では@code{foo}}
  (nconc '(foo) x))           ;   @r{を引数の前に追加したい}
@end group

@group
(symbol-function 'add-foo)
     @result{} #f(lambda (x) [t] (nconc '(foo) x))
@end group

@group
(setq xx (add-foo '(1 2)))    ; @r{動いているように見える}
     @result{} (foo 1 2)
@end group
@group
(setq xy (add-foo '(3 4)))    ; @r{何が起きているのか?}
     @result{} (foo 1 2 3 4)
@end group
@group
(eq xx xy)
     @result{} t
@end group

@group
(symbol-function 'add-foo)
     @result{} #f(lambda (x) [t] (nconc '(foo 1 2 3 4) x))
@end group
@end smallexample
@end defun

@node Sets And Lists
@section 集合としてのリストの使用
@cindex lists as sets
@cindex sets

  リストは順序なしの数学的集合 --- リスト内に要素があれば集合の要素の値としてリスト内の順序は無視される ---
を表すことができます。2つの集合を結合(union)するには、(重複する要素を気にしなければ)@code{append}を使用します。@code{equal}である重複を取り除くには@code{delete-dups}や@code{seq-uniq}を使用します。集合にたいする他の有用な関数には@code{memq}や@code{delq}や、それらの@code{equal}バージョンである@code{member}と@code{delete}が含まれます。

@cindex CL note---lack @code{union}, @code{intersection}
@quotation
@b{Common Lispに関する注意:} 集合を処理するためにCommon Lispには関数@code{union}
(要素の重複がない)と@code{intersection}がある。Emacs
Lispでは@file{cl-lib}がこれらの変種を提供する。@ref{Lists as Sets,,,cl,Common Lisp
Extensions}を参照のこと。
@end quotation

@defun memq object list
@cindex membership in a list
この関数は@var{object}が@var{list}のメンバーかどうかをテストする。メンバーなら@code{memq}は、@var{object}で最初に見つかった要素から開始されるリストをリターンする。メンバーでなければ@code{nil}をリターンする。@code{memq}の文字@samp{q}は、この関数が@var{object}とリスト内の要素の比較に@code{eq}を使用することを示す。たとえば:

@example
@group
(memq 'b '(a b c b a))
     @result{} (b c b a)
@end group
@group
(memq '(2) '((1) (2)))    ; @r{2つの@code{(2)}が@code{eq}である必要はない}
     @result{} @r{未定義; @code{nil}か@code{((2))}かも}
@end group
@end example
@end defun

@defun delq object list
@cindex deleting list elements
この関数は@var{list}から@var{object}と@code{eq}であるような、すべての要素を破壊的に取り除いて結果のリストをリターンする。@code{delq}の文字@samp{q}は、この関数が@var{object}とリスト内の要素の比較に@code{eq}を使用することを示す(@code{memq}や@code{remq}と同様)。

@code{delq}を呼び出すときは、通常は元のリストを保持していた変数にリターン値を割り当てて使用する必要がある(理由は以下参照)。
@end defun

@code{delq}関数がリストの先頭にある要素を削除する場合は、単にリストを読み進めてこの要素の後から開始される部分リストをリターンします。つまり:

@example
@group
(delq 'a '(a b c)) @equiv{} (cdr '(a b c))
@end group
@end example

@noindent
リストの途中にある要素を削除するときは、必要な@sc{cdr} (@ref{Setcdr}を参照)を変更することで削除を行います。

@example
@group
(setq sample-list (list 'a 'b 'c '(4)))
     @result{} (a b c (4))
@end group
@group
(delq 'a sample-list)
     @result{} (b c (4))
@end group
@group
sample-list
     @result{} (a b c (4))
@end group
@group
(delq 'c sample-list)
     @result{} (a b (4))
@end group
@group
sample-list
     @result{} (a b (4))
@end group
@end example

@code{(delq 'a sample-list)}は何も取り除きませんが(単に短いリストをリターンする)、@code{(delq 'c
sample-list)}は3番目の要素を取り除いて@code{sample-list}を変更することに注意してください。引数@var{list}を保持するように形成された変数が、実行後にもっと少ない要素になるとか、元のリストを保持すると仮定しないでください!
かわりに@code{delq}の結果を保存して、それを使用してください。元のリストを保持していた変数に結果を書き戻すことはよく行なわれます。

@example
(setq flowers (delq 'rose flowers))
@end example

以下の例では、@code{delq}が比較しようとしている@code{(list
4)}と@code{sample-list}内の@code{(4)}は、@code{equal}ですが@code{eq}ではありません:

@example
@group
(delq (list 4) sample-list)
     @result{} (a c (4))
@end group
@end example

与えられた値と@code{equal}な要素を削除したい場合には、@code{delete} (以下参照)を使用してください。

@defun remq object list
この関数は@var{object}と@code{eq}なすべての要素が除かれた、@var{list}のコピーをリターンする。@code{remq}の文字@samp{q}は、この関数が@var{object}とリスト内の要素の比較に@code{eq}を使用することを示す。

@example
@group
(setq sample-list (list 'a 'b 'c 'a 'b 'c))
     @result{} (a b c a b c)
@end group
@group
(remq 'a sample-list)
     @result{} (b c b c)
@end group
@group
sample-list
     @result{} (a b c a b c)
@end group
@end example
@end defun

@defun memql object list
関数@code{memql}は@code{eql}(浮動小数点数の要素は値で比較される)を使用してメンバーと@code{eql}を比較することにより、@var{object}が@var{list}のメンバーかどうかをテストする。@var{object}がメンバーなら、@code{memql}は@var{list}内で最初に見つかった要素から始まるリスト、それ以外なら@code{nil}をリターンする。

@code{memq}と比較してみよう:

@example
@group
(memql 1.2 '(1.1 1.2 1.3))  ; @r{@code{1.2}と@code{1.2}は@code{eql}。}
     @result{} (1.2 1.3)
@end group
@group
(memq 1.2 '(1.1 1.2 1.3))  ; @r{2つの@code{1.2}が@code{eq}である必要はない}
     @result{} @r{未定義; @code{nil}か@code{(1.2 1.3)}かもしれない}
@end group
@end example
@end defun

以下の3つの関数は@code{memq}、@code{delq}、@code{remq}と似ていますが、要素の比較に@code{eq}ではなく@code{equal}を使用します。@ref{Equality
Predicates}を参照してください。

@defun member object list
関数@code{member}は、メンバーと@var{object}を@code{equal}を使用して比較して、@var{object}が@var{list}のメンバーかどうかをテストする。@var{object}がメンバーなら、@code{member}は@var{list}で最初に見つかったところから開始されるリスト、それ以外なら@code{nil}をリターンする。

@code{memq}と比較してみよう:

@example
@group
(member '(2) '((1) (2)))  ; @r{@code{(2)} and @code{(2)} are @code{equal}.}
     @result{} ((2))
@end group
@group
(memq '(2) '((1) (2)))    ; @r{2つの@code{(2)}が@code{eq}である必要はない}
     @result{} @r{未定義; @code{nil}か@code{(2)}かもしれない}
@end group
@group
;; @r{同じ内容の2つの文字列は@code{equal}}
(member "foo" '("foo" "bar"))
     @result{} ("foo" "bar")
@end group
@end example
@end defun

@defun delete object sequence
この関数は@var{sequence}から@var{object}と@code{equal}な要素を取り除いて、結果のシーケンスをリターンする。

@var{sequence}がリストなら、@code{delete}が@code{delq}に対応するように、@code{member}は@code{memq}に対応する。つまりこの関数は@code{member}と同様、要素と@var{object}の比較に@code{equal}を使用する。マッチする要素が見つかったら、@code{delq}が行なうようにその要素を取り除く。@code{delq}と同様、通常は元のリストを保持していた変数にリターン値を割り当てて使用する。

@code{sequence}がベクターか文字列なら、@code{delete}は@code{object}と@code{equal}なすべての要素を取り除いた@code{sequence}のコピーをリターンする。

たとえば:

@example
@group
(setq l (list '(2) '(1) '(2)))
(delete '(2) l)
     @result{} ((1))
l
     @result{} ((2) (1))
;; @r{@code{l}の変更に信頼性を要するときは}
;; @r{@code{(setq l (delete '(2) l))}と記述する。}
@end group
@group
(setq l (list '(2) '(1) '(2)))
(delete '(1) l)
     @result{} ((2) (2))
l
     @result{} ((2) (2))
;; @r{このケースでは@code{l}のセットの有無に違い}
;; @r{はないが他のケースに倣ってセットするべき}
@end group
@group
(delete '(2) [(2) (1) (2)])
     @result{} [(1)]
@end group
@end example
@end defun

@defun remove object sequence
この関数は@code{delete}に対応する非破壊的な関数である。この関数は@code{object}と@code{equal}な要素を取り除いた、@code{sequence}(リスト、ベクター、文字列)のコピーをリターンする。たとえば:

@example
@group
(remove '(2) '((2) (1) (2)))
     @result{} ((1))
@end group
@group
(remove '(2) [(2) (1) (2)])
     @result{} [(1)]
@end group
@end example
@end defun

@quotation
@b{Common Lispに関する注意:} GNU Emacs
Lispの関数@code{member}、@code{delete}、@code{remove}はCommon
Lispではなく、Maclispを継承する。Common Lispでは比較に@code{equal}を使用しない。
@end quotation

@defun member-ignore-case object list
この関数は@code{member}と同様だが、@var{object}が文字列でcaseとテキスト表現の違いを無視する。文字の大文字と小文字は等しいものとして扱われ、比較に先立ちユニバイト文字列はマルチバイト文字列に変換される。
@end defun

@defun delete-dups list
この関数は@var{list}からすべての@code{equal}な重複を破壊的に取り除いて、結果を@var{list}に保管してそれをリターンする。@var{list}内の要素に@code{equal}な要素がいくつかあるなら、@code{delete-dups}は最初の要素を残す。非破壊的な操作については@code{seq-uniq}を参照してください(@ref{Sequence
Functions}を参照)。
@end defun

  変数に格納されたリストへの要素の追加や、それを集合として使用する方法については、@ref{List
Variables}の関数@code{add-to-list}も参照してください。

@node Association Lists
@section 連想リスト
@cindex association list
@cindex alist

  @dfn{連想リスト(association
list、短くはalist)}は、キーと値のマッピングを記録します。これは@dfn{連想(associations)}と呼ばれるコンスセルのリストです。各コンスセルにおいて@sc{car}は@dfn{キー(key)}で、@sc{cdr}は@dfn{連想値(associated
value)}となります。@footnote{ここでの``キー(key)''の使い方は、用語``キーシーケンス(key
sequence)''とは関係ありません。キーはテーブルにあるアイテムを探すために使用される値という意味です。この場合、テーブルはalistでありalistはアイテムに関連付けられます。}

  以下はalistの例です。キー@code{pine}は値@code{cones}、キー@code{oak}は@code{acorns}、キー@code{maple}は@code{seeds}に関連付けられます。

@example
@group
((pine . cones)
 (oak . acorns)
 (maple . seeds))
@end group
@end example

  alist内の値とキーには、任意のLispオブジェクトを指定できます。たとえば以下のalistでは、シンボル@code{a}は数字@code{1}、文字列@code{"b"}は@emph{リスト}@code{(2
3)}(alist要素の@sc{cdr})に関連付けられます。

@example
((a . 1) ("b" 2 3))
@end example

  要素の@sc{cdr}の@sc{car}に連想値を格納するようにalistデザインするほうがよい場合があります。以下はそのようなalistです。

@example
((rose red) (lily white) (buttercup yellow))
@end example

@noindent
この例では、@code{red}が@code{rose}に関連付けられる値だと考えます。この種のalistの利点は、@sc{cdr}の@sc{cdr}の中に他の関連する情報
--- 他のアイテムのリストでさえも ---
を格納することができることです。不利な点は、与えられた値を含む要素を見つけるために@code{rassq}(以下参照)を使用できないことです。これらを検討することが重要でない場合には、すべての与えられたalistにたいして一貫している限り、選択は好みの問題といえます。

  上記で示したのと同じalistは、要素の@sc{cdr}に連想値をもつと考えることができます。この場合、@code{rose}に関連付けられる値はリスト@code{(red)}になるでしょう。

  連想リストは新しい連想値を簡単にリストの先頭に追加できるので、スタックに保持したいような情報を記録するのによく使用されます。連想リストから与えられたキーにたいして連想値を検索する場合、それが複数ある場合は、最初に見つかったものがreturnされます。

  Emacs
Lispでは、連想リストがコンスセルでなくても、それは@emph{エラーではありません}。alist検索関数は、単にそのような要素を無視します。多くの他のバージョンのLispでは、このような場合はエラーをシグナルします。

  いくつかの観点において、プロパティリストは連想リストと似ていることに注意してください。それぞれのキーが一度だけ出現するような場合、プロパティリストは連想リストと同様に振る舞います。プロパティリストと連想リストの比較については、@ref{Property
Lists}を参照してください。

@defun assoc key alist &optional testfn
この関数はalist要素にたいして@var{testfn}が関数なら@var{testfn}、それ以外なら@code{equal}を使用して、@var{alist}内から@var{key}をもつ最初の連想をリターンする。@var{testfn}が関数の場合には@var{alist}の要素の@sc{car}と@var{key}の2つの引数で呼び出される。@var{testfn}でテストした結果、@sc{car}が@var{key}と一致する連想が@var{alist}になければ、この関数は@code{nil}をリターンする。たとえば:

@smallexample
(setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
     @result{} ((pine . cones) (oak . acorns) (maple . seeds))
(assoc 'oak trees)
     @result{} (oak . acorns)
(cdr (assoc 'oak trees))
     @result{} acorns
(assoc 'birch trees)
     @result{} nil
@end smallexample

以下はキーと値がシンボルでない場合の例である:

@smallexample
(setq needles-per-cluster
      '((2 "Austrian Pine" "Red Pine")
        (3 "Pitch Pine")
        (5 "White Pine")))

(cdr (assoc 3 needles-per-cluster))
     @result{} ("Pitch Pine")
(cdr (assoc 2 needles-per-cluster))
     @result{} ("Austrian Pine" "Red Pine")
@end smallexample
@end defun

  関数@code{assoc-string}は@code{assoc}と似ていますが、文字列間の特定の違いを無視する点が異なります。@ref{Text
Comparison}を参照してください。

@defun rassoc value alist
この関数は@var{alist}の中から値@var{value}をもつ最初の連想をリターンする。@sc{cdr}が@var{value}と@code{equal}であるような連想値が@var{alist}になければ、この関数は@code{nil}をリターンする。

@code{rassoc}は@code{assoc}と似てイルが、@sc{car}ではなく@var{alist}の連想値の@sc{cdr}を比較する。この関数は与えられた値に対応するキーを探す、@code{assoc}の逆バージョンと考えることができよう。
@end defun

@defun assq key alist
この関数は@var{alist}から@var{key}をもつ最初の連想値をリターンする点は@code{assoc}と同様だが、比較に@code{eq}を使用する点が異なる。@sc{car}が@var{key}と@code{eq}であるような連想値が@var{alist}内に存在しなければ@code{assq}は@code{nil}をリターンする。@code{eq}は@code{equal}より高速であり、ほとんどのalistはキーにシンボルを使用するので、この関数は@code{assoc}より多用される。@ref{Equality
Predicates}を参照のこと。

@smallexample
(setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
     @result{} ((pine . cones) (oak . acorns) (maple . seeds))
(assq 'pine trees)
     @result{} (pine . cones)
@end smallexample

逆にキーがシンボルではないalistでは、通常は@code{assq}は有用ではない:

@smallexample
(setq leaves
      '(("simple leaves" . oak)
        ("compound leaves" . horsechestnut)))

(assq "simple leaves" leaves)
     @result{} @r{未定義; @code{nil}か@code{("simple leaves" . oak)}かもしれない}
(assoc "simple leaves" leaves)
     @result{} ("simple leaves" . oak)
@end smallexample
@end defun

@defun alist-get key alist &optional default remove testfn
この関数は@code{assq}と似ている。これは@var{alist}の要素の@var{key}を比較して最初の連想@w{@code{(@var{key}
.
@var{value})}}を見つける。連想が見つからなければ、関数は@var{default}をリターンする。@var{alist}にたいする@var{key}の比較には@var{testfn}で指定された関数を使用する(デフォルトは@code{eq})。

これは@code{setf}での値の変更に使用できる汎変数(@ref{Generalized
Variables}を参照)である。値の設定にこれを使用する際にオプション引数@var{remove}が@code{nil}の場合は、新たな値が@var{default}と@code{eql}なら@var{alist}から@var{key}の連想を削除することを意味する。
@end defun

@defun rassq value alist
この関数は、@var{alist}内から値@var{value}をもつ最初の連想値をリターンする。@var{alist}内に@sc{cdr}が@var{value}と@code{eq}であるような連想値が存在しないなら@code{nil}をリターンする。

@code{rassq}は@code{assq}と似ていますが、@sc{car}ではなく@var{alist}の各連想の@sc{cdr}を比較します。この関数を、与えられた値に対応するキーを探す@code{assq}の逆バージョンと考えることができます。

たとえば:

@smallexample
(setq trees '((pine . cones) (oak . acorns) (maple . seeds)))

(rassq 'acorns trees)
     @result{} (oak . acorns)
(rassq 'spores trees)
     @result{} nil
@end smallexample

@code{rassq}は要素の@sc{cdr}の@sc{car}に保管された値の検索はできません:

@smallexample
(setq colors '((rose red) (lily white) (buttercup yellow)))

(rassq 'white colors)
     @result{} nil
@end smallexample

この場合、連想@code{(lily
white)}の@sc{cdr}は@code{white}ではなくリスト@code{(white)}です。これは連想をドットペア表記で記述すると明確になります:

@smallexample
(lily white) @equiv{} (lily . (white))
@end smallexample
@end defun

@defun assoc-default key alist &optional test default
この関数は、@var{key}にたいするマッチを@var{alist}から検索する。@var{alist}の各要素にたいして、この関数は@var{key}と要素(アトムの場合)、または要素の@sc{car}(コンスの場合)を比較する。比較は@var{test}に2つの引数
--- 要素(か要素の@sc{car})と@var{key} ---
を与えて呼び出すことにより行なわれる。引数はこの順番で渡されるので、正規表現(@ref{Regexp
Search}を参照)を含むalistでは、@code{string-match}を使用することにより有益な結果を得ることができる。@var{test}が省略または@code{nil}なら比較に@code{equal}が使用される。

alistの要素がこの条件により@var{key}とマッチすると、@code{assoc-default}はその要素の値をリターンする。要素がコンスなら値は要素の@sc{cdr}、それ以外ならリターン値は@var{default}となる。

@var{key}にマッチする要素がalistに存在しないなら、@code{assoc-default}は@code{nil}をリターンする。
@end defun

@defun copy-alist alist
@cindex copying alists
この関数は深さのレベルが2の@var{alist}のコピーをリターンする。この関数は各連想の新しいコピーを作成するので、元のalistを変更せずに新しいalistを変更できる。

@smallexample
@group
(setq needles-per-cluster
      '((2 . ("Austrian Pine" "Red Pine"))
        (3 . ("Pitch Pine"))
@end group
        (5 . ("White Pine"))))
@result{}
((2 "Austrian Pine" "Red Pine")
 (3 "Pitch Pine")
 (5 "White Pine"))

(setq copy (copy-alist needles-per-cluster))
@result{}
((2 "Austrian Pine" "Red Pine")
 (3 "Pitch Pine")
 (5 "White Pine"))

(eq needles-per-cluster copy)
     @result{} nil
(equal needles-per-cluster copy)
     @result{} t
(eq (car needles-per-cluster) (car copy))
     @result{} nil
(cdr (car (cdr needles-per-cluster)))
     @result{} ("Pitch Pine")
@group
(eq (cdr (car (cdr needles-per-cluster)))
    (cdr (car (cdr copy))))
     @result{} t
@end group
@end smallexample

  以下の例は、@code{copy-alist}を使用して、他方のコピーへの影響なしに一方のコピーの連想を変更することが可能である方法を示す:

@smallexample
@group
(setcdr (assq 3 copy) '("Martian Vacuum Pine"))
(cdr (assq 3 needles-per-cluster))
     @result{} ("Pitch Pine")
@end group
@end smallexample
@end defun

@defun assq-delete-all key alist
この関数は、@code{delq}を使用してマッチする要素を1つずつ削除するときのように、@sc{car}が@var{key}と@code{eq}であるようなすべての要素を@var{alist}から削除する。この関数は短くなったalistをリターンし、@var{alist}の元のリスト構造を変更することもよくある。正しい結果を得るために、@var{alist}に保存された値ではなく@code{assq-delete-all}のリターン値を使用すること。

@example
(setq alist (list '(foo 1) '(bar 2) '(foo 3) '(lose 4)))
     @result{} ((foo 1) (bar 2) (foo 3) (lose 4))
(assq-delete-all 'foo alist)
     @result{} ((bar 2) (lose 4))
alist
     @result{} ((foo 1) (bar 2) (lose 4))
@end example
@end defun

@defun assoc-delete-all key alist &optional test
この関数は@code{assq-delete-all}と同様だが、オプション引数@var{test} (
@var{alist}内のキーを比較するための述語関数)を受け取る点が異なる。@var{test}が省略か@code{nil}ならデフォルトは@code{equal}。この関数は@code{assq-delete-all}のように、多くの場合は@var{alist}の元のリスト構造を変更する。
@end defun

@defun rassq-delete-all value alist
この関数は、@var{alist}から@sc{cdr}が@var{value}と@code{eq}であるようなすべての要素を削除する。この関数は短くなったリストをリターンし、@var{alist}の元のリスト構造を変更することもよくある。@code{rassq-delete-all}は@code{assq-delete-all}と似ているが、@sc{car}ではなく@var{alist}の各連想の@sc{cdr}を比較する。
@end defun

@defmac let-alist alist body
連想リスト@var{alist}のキーとして使用される先頭にドットを付したシンボルそれぞれにたいしてバインディングを作成する。これは同じ連想リスト内の複数のアイテムにアクセスする際に有用かもしれない。理解するためにもっともよいのは以下のシンプルな例だろう:

@lisp
(setq colors '((rose . red) (lily . white) (buttercup . yellow)))
(let-alist colors
  (if (eq .rose 'red)
      .lily))
     @result{} white
@end lisp

@var{body}をコンパイル時に検査して、@var{body}内に出現する先頭文字として@samp{.}を付したシンボルだけがバインドされる。キーの検索は@code{assq}、この@code{assq}のリターン値の@code{cdr}がそのバインディングにたいする値として割り当てられる。

ネストされた連想リストをサポートする:

@lisp
(setq colors '((rose . red) (lily (belladonna . yellow) (brindisi . pink))))
(let-alist colors
  (if (eq .rose 'red)
      .lily.belladonna))
     @result{} yellow
@end lisp

互いに内部に@code{let-alist}をネストすることが可能だが、内側の@code{let-alist}は外側の@code{let-alist}がバインドする変数にはアクセスできない。
@end defmac

@node Property Lists
@section プロパティリスト
@cindex property list
@cindex plist

  @dfn{プロパティリスト(property
list、短くはplist)}は、ペアになった要素のリストです。各ペアはプロパティ名(通常はシンボル)とプロパティ値を対応づけます。以下はプロパティリストの例です:

@example
(pine cones numbers (1 2 3) color "blue")
@end example

@noindent
このプロパティリストは@code{pine}を@code{cones}、@code{numbers}を@code{(1 2
3)}、@code{color}を@code{"blue"}に関連づけます。プロパティ名とプロパティ値には任意のLispオブジェクトを指定できますが、通常プロパティ名は(この例のように)シンボルです。

  いくつかのコンテキストでプロパティリストが使用されます。たとえば関数@code{put-text-property}はプロパティリストを引数にとり、文字列やバッファー内のテキストにたいして、テキストプロパティとテキストに適用するプロパティ値を指定します。@ref{Text
Properties}を参照してください。

  プロパティリストが頻繁に使用される他の例は、シンボルプロパティの保管です。すべてのシンボルはシンボルに関する様々な情報を記録するために、プロパティのリストを処理します。これらのプロパティはプロパティリストの形式で保管されます。@ref{Symbol
Properties}を参照してください。

@defun plistp object
この述語関数は@var{object}が有効なプロパティリストなら非@code{nil}をリターンする。
@end defun

@menu
* Plists and Alists::        プロパティリストと連想リストの利点の比較。
* Plist Access::             他の場所に保管されたプロパティリストへのアクセス。
@end menu

@node Plists and Alists
@subsection プロパティリストと連想リスト
@cindex plist vs. alist
@cindex alist vs. plist

@cindex property lists vs association lists
  連想リスト(@ref{Association
Lists}を参照)は、プロパティリストとよく似ています。連想リストとは対照的にプロパティ名は一意でなければならないので、プロパティリスト内でペアの順序に意味はありません。

  様々なLisp関数や変数に情報を付加するためには、連想リストよりプロパティリストの方が適しています。プログラムでこのような情報すべてを1つの連想リストに保持する場合は、特定のLisp関数や変数にたいする連想をチェックする度にリスト全体を検索する必要が生じ、それにより遅くなる可能性があります。対照的に関数名や変数自体のプロパティリストに同じ情報を保持すれば、検索ごとにそのプロパティリストの長さだけを検索するようになり、通常はこちらの方が短時間で済みます。変数のドキュメントが@code{variable-documentation}という名前のプロパティに記録されているのはこれが理由です。同様にバイトコンパイラーも、特別に扱う必要がある関数を記録するためにプロパティを使用します。

  とはいえ連想リストにも独自の利点があります。アプリケーションに依存しますが、プロパティを更新するより連想リストの先頭に連想を追加する方が高速でしょう。シンボルにたいするすべてのプロパティは同じプロパティリストに保管されるので、プロパティ名を異なる用途のために使用すると衝突の可能性があります(この理由により、そのプログラムで通常の変数や関数の名前につけるプレフィクスをプロパティ名の先頭につけて、一意と思われるプロパティ名を選ぶのはよいアイデアだと言える)。連想リストは、連想をリストの先頭にpushして、その後にある連想は無視されるので、スタックと同様に使用できます。これはプロパティリストでは不可能です。

@node Plist Access
@subsection プロパティリストと外部シンボル
@cindex plist access
@cindex accessing plist properties

  以下の関数はプロパティリストを操作するために使用されます。これらの関数はすべて、デフォルトではプロパティ名の比較に@code{eq}を使用します。

@defun plist-get plist property &optional predicate
この関数はプロパティリスト@var{plist}に保管された、プロパティ@var{property}の値をリターンする。比較は@var{predicate}
(デフォルトは@code{eq})で行われる。この関数には不正な形式(malformed)の@var{plist}引数を指定できる。@var{plist}で@var{property}が見つからないと、この関数は@code{nil}をリターンする。たとえば、

@example
(plist-get '(foo 4) 'foo)
     @result{} 4
(plist-get '(foo 4 bad) 'foo)
     @result{} 4
(plist-get '(foo 4 bad) 'bad)
     @result{} nil
(plist-get '(foo 4 bad) 'bar)
     @result{} nil
@end example
@end defun

@defun plist-put plist property value &optional predicate
この関数はプロパティリスト@var{plist}に、プロパティ@var{property}の値として@var{value}を保管する。比較は@var{predicate}
(デフォルトは@code{eq})で行われる。この関数は@var{plist}を破壊的に変更するかもしれず、元のリスト構造を変更せずに新しいリストを構築することもある。この関数は変更されたプロパティリストをリターンするので、@var{plist}を取得した場所に書き戻すことができる。たとえば、

@example
(setq my-plist (list 'bar t 'foo 4))
     @result{} (bar t foo 4)
(setq my-plist (plist-put my-plist 'foo 69))
     @result{} (bar t foo 69)
(setq my-plist (plist-put my-plist 'quux '(a)))
     @result{} (bar t foo 69 quux (a))
@end example
@end defun

@defun lax-plist-get plist property
この廃れた関数は@code{plist-get}と同様だが、プロパティの比較に@code{eq}ではなく@code{equal}を使用する。
@end defun

@defun lax-plist-put plist property value
この廃れた関数は@code{plist-put}と同様だが、プロパティの比較に@code{eq}ではなく@code{equal}を使用する。
@end defun

@defun plist-member plist property &optional predicate
この関数は与えられた@var{property}が@var{plist}に含まれるなら非@code{nil}をリターンする。比較は@var{predicate}
(デフォルトは@code{eq})で行われる。@code{plist-get}とは異なりこの関数は存在しないプロパティと、値が@code{nil}のプロパティを区別できる。実際にリターンされる値は、@code{car}が@var{property}で始まる@var{plist}の末尾部分である。
@end defun
