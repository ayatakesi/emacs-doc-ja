@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990--1993, 1998--1999, 2001--2024 Free Software
@c Foundation, Inc.
@c See the file elisp-ja.texi for copying conditions.
@node GNU Emacs Internals
@appendix GNU Emacsの内部

このチャプターでは実行可能なEmacs実行可能形式を事前ロードされたLispライブラリーとともにダンプする方法、ストレージが割り当てられる方法、およびCプログラマーが興味をもつかもしれないGNU
Emacsの内部的な側面のいくつかを説明します。

@menu
* Building Emacs::           ダンプ済みEmacsの作成方法。
* Pure Storage::             その場かぎりの事前ロードされたLisp関数を共有する。
* Garbage Collection::       Lispオブジェクトの使用されないスペースの回収。
* Stack-allocated Objects::  Cスタック上の一時的なコンスと文字列。
* Memory Usage::             これまでに作成されたLispオブジェクトの総サイズの情報。
* C Dialect::                Emacsを記述するC系言語は何か。
* Writing Emacs Primitives::  Emacs用にCコードを記述する。
* Writing Dynamic Modules::  Emacsにロード可能なモジュールの記述。
* Object Internals::         バッファー、ウィンドウ、プロセスのデータフォーマット。
* C Integer Types::          Emacs内部でCの整数型が使用される方法。
@end menu

@node Building Emacs
@section Emacsのビルド
@cindex building Emacs
@pindex temacs

  このセクションではEmacs実行可能形式のビルドに関するステップの説明をします。makefileがこれらすべてを自動的に行うので、Emacsをビルドやインストールをするためにこの題材を知る必要はありません。この情報はEmacs開発者に適しています。

  EmacsのビルドにはGNU Makeのバージョン3.81以降が必要です。

  @file{src}ディレクトリー内のCソースファイルをコンパイルすることにより、@file{temacs}と呼ばれる実行可能形式ファイルが生成されます。これは@dfn{bare
impure Emacs(裸で不純なEmacs)}とも呼ばれます。これにはEmacs
LispインタープリターとI/Oルーチンが含まれますが編集コマンドは含まれません。

@cindex @file{loadup.el}
  コマンド@w{@command{temacs -l
loadup}}は@file{temacs}を実行して@file{loadup.el}をロードするように計らいます。@code{loadup}ライブラリーは通常のEmacs編集環境をセットアップする追加のLispライブラリーをロードします。このステップの後にはEmacs実行可能形式は@dfn{bare(裸)}ではなくなります。

@cindex dumping Emacs
@cindex @option{--temacs} option, and dumping method
  標準的なLispファイルのロードには若干の時間を要するので、ユーザーが直接@file{temacs}実行可能形式を実行することは通常はありません。そのかわり、Emacsビルドの最終ステップの1つとしてコマンド@w{@samp{temacs
-batch -l loadup
--temacs=@var{dump-method}}}が実行されます。特別なオプション@option{--temacs}は@command{temacs}にたいして、この後に続けてEmacsを実行した際に開始がより高速になるように、標準のすべての事前ロードされるLispの関数と変数の記録方法を指示します。オプション@option{--temacs}には引数@var{dump-method}が必要であり、以下のいずれかを指定できます:

@table @samp
@item pdump
@cindex dump file
@dfn{ダンプファイル(dump
file)}に事前ロードLispデータを記録する。このメソッドはEmacsの開始時にロードされることになる追加データファイルを生成する。生成されたダンプファイルは通常は@file{emacs.pdmp}と呼ばれて、Emacsの@code{exec-directory}にインストールされる(@ref{Help
Functions}を参照)。これはモダンなシステムにおいてセキュリティとプライバシーを強化するために使用されるさまざまなメモリーレイアウト技術を妨害する可能性のある、メモリー割り当ての特別なテクニックの使用をEmacsに要求しないので、もっとも好ましいメソッドの1つ。

@item pbootstrap
@cindex bootstrapping Emacs
@samp{pdump}と同様だが、以前のEmacsバイナリおよびバイトコンパイル済みLispファイル@file{*.elc}が存在しないときに、Emacsの@dfn{ブートストラップ(bootstrapping)}の間に使用される。この場合には、生成されるダンプファイルは通常は@file{bootstrap-emacs.pdmp}。

@item dump
@cindex unexec
このメソッドはすべての標準Lispファイルがすでに事前ロード済みの@file{emacs}という実行可能プログラムを@command{temacs}にダンプさせる(@samp{-batch}引数は@command{temacs}にその端末上のすべてのデータ初期化の試みを抑制するので、ダンプされたEmacsの端末情報テーブルは空になる)。このメソッドは実行中プロセスからプログラムファイルを生成するため、プログラムを実行(exec)してプロセスを開始することとある意味で反対なことから@dfn{unexec}として知られている。このメソッドは伝統的にEmacsの状態を保存する手段だったが、今や非推奨となった。

@item bootstrap
@samp{dump}と同様だが、@code{unexec}メソッドでEmacsをブートストラップする際に使用する。
@end table

@cindex preloaded Lisp files
@vindex preloaded-file-list
  インストールされるEmacsは、ダンプされた@file{emacs}実行可能形式です(@dfn{pure}なEmacsとも呼ばれる)。Emacsのビルドにポータブルダンパーを使用した場合には、@file{emacs}実行可能形式は実際には@file{temacs}の正確なコピーであり、対応機種@file{emacs.pdmp}ファイルも同様にインストールされます。変数@code{preloaded-file-list}にはダンプファイルやダンプされたEmacs実行可能形式に記録された事前ロード済みLispファイルのリストが格納されます。新たなオペレーティングシステムにEmacsをポートする際に、そのOSが何の種類のダンプも実装していなければEmacsは起動時に毎回@file{loadup.el}をロードしなければなりません。

@cindex build details
@cindex deterministic build
@cindex @option{--disable-build-details} option to @command{configure}
  ダンプされた@file{emacs}にはデフォルトではビルド時刻やホスト名のような詳細が記録されます。これらの詳細を抑制するために@command{configure}のオプションに@option{--disable-build-details}を使用すれば、同一のソースからEmacsを2回ビルドしてインストールする際に同一のEmacsのコピーが生成される可能性が高くなります。

@cindex @file{site-load.el}
  @file{site-load.el}という名前のライブラリーを記述することにより、事前ロードするファイルを追加指定できます。追加するファイルを保持するために純粋(pure)なスペース@var{n}バイトを追加するように、以下の定義

@example
#define SITELOAD_PURESIZE_EXTRA @var{n}
@end example

@noindent
でEmacsをリビルドする必要があるでしょう。@file{src/puresize.h}を参考にしてください(十分大きくなるまで20000ずつ増加させる)。しかし追加ファイルの事前ロードの優位はマシンの高速化により減少します。現代的なマシンでは通常はお勧めしません。

  @file{loadup.el}が@file{site-load.el}を読み込んだ後に@code{Snarf-documentation}を呼び出すことにより、それらが格納された場所のファイル@file{etc/DOC}内にあるプリミティブと事前ロードされる関数(と変数)のドキュメント文字列を探します(@ref{Definition
of Snarf-documentation,, Accessing Documentation}を参照)。

@cindex @file{site-init.el}
@cindex preloading additional functions and variables
  @file{site-init.el}という名前のライブラリー名に配置することにより、ダンプ直前に実行する他のLisp式を指定できます。このファイルはドキュメント文字列を見つけた後に実行されます。

  関数や変数の定義を事前ロードしたい場合には、それを行うために3つの方法があります。それらにより定義ロードしてその後のEmacs実行時にドキュメント文字列をアクセス可能にします:

@itemize @bullet
@item
@file{etc/DOC}の生成時にそれらのファイルをスキャンするよう計らい@file{site-load.el}でロードする。

@item
ファイルを@file{site-init.el}でロードしてEmacsインストール時にLispファイルのインストール先ディレクトリーにファイルをコピーする。

@item
それらの各ファイルでローカル変数として@code{byte-compile-dynamic-docstrings}に@code{nil}値を指定して@file{site-load.el}か@file{site-init.el}でロードする(この手法にはEmacsが毎回そのドキュメント文字列用のスペースを確保するという欠点がある)。
@end itemize

@cindex change @code{load-path} at configure time
@cindex @option{--enable-locallisppath} option to @command{configure}
  通常の未変更のEmacsでユーザーが期待する何らかの機能を変更するような何かを@file{site-load.el}や@file{site-init.el}内に配置することはお勧めしません。あなたのサイトで通常の機能をオーバーライドしなければならないと感じた場合には、@file{default.el}でそれを行えばユーザーが望む場合にあなたの変更をオーバーライドできます。@ref{Startup
Summary}を参照してください。@file{site-load.el}か@file{site-init.el}のいずれかが@code{load-path}を変更する場合には変更はダンプ後に失われます。@ref{Library
Search}を参照してください。@code{load-path}を永続的に変更するには@command{configure}の@option{--enable-locallisppath}オプションを指定してください。

  事前ロード可能なパッケージでは、その後のEmacsスタートアップまで特定の評価の遅延が必要(または便利)なことがあります。そのようなケースの大半はカスタマイズ可能な変数の値に関するものです。たとえば@code{tutorial-directory}は事前ロードされる@file{startup.el}内で定義される変数です。これのデフォルト値は@code{data-directory}にもとづいてセットされます。この変数はEmacsダンプ時ではなくスタート時に@code{data-directory}の値を必要とします。なぜならEmacs実行可能形式はダンプされたものなので、恐らく異なる場所にインストールされるからです。

@defun custom-initialize-delay symbol value
この関数は次回のEmacs開始まで@var{symbol}の初期化を遅延する。通常はカスタマイズ可能変数の@code{:initialize}プロパティとしてこの関数を指定することにより使用する(引数@var{value}はフォームCustom由来の互換性のためだけに提供されており使用しない)。
@end defun

@code{custom-initialize-delay}が提供するより一般的な機能を要する稀なケースでは@code{before-init-hook}を使用できます(@ref{Startup
Summary}を参照)。

@defun dump-emacs-portable to-file &optional track-referrers
この関数は@code{pdump}メソッドを使用して、Emacsのカレント状態をダンプファイル@var{to-file}にダンプする。ダンプファイルは通常は@file{@var{emacs-name}.dmp}と呼ばれる。ここで@var{emacs-name}はEmacsの実行可能形式ファイル名。オプション引数@var{track-referrers}が非@code{nil}なら、ポータブルダンパーは@code{pdump}メソッドでは未サポートのオブジェクトタイプの出所追跡の助けとなる追加情報を維持する。

多くのプラットフォームでポータブルダンパーのコードが実行可能だとしても、それが生成するダンプファイルに可搬性はない(ダンプしたEmacs実行可能形式だけがロードできる)。

すでにダンプ済みのEmacs内でこの関数を使用する場合には@samp{-batch}オプションでEmacsを実行しなければならない。

@vindex after-pdump-load-hook
ダンプ済みのEmacsに@samp{.el}ファイルが含まれていて、かつその@samp{.el}ファイルには通常はロード時に実行されるコードがある場合には、ダンプ後にEmacsを起動する際にそのコードは実行されないだろう。この問題を回避するために、@code{after-pdump-load-hook}フックに関数を配置することができる。このフックはEmacs起動時に実行される。
@end defun

@defun dump-emacs to-file from-file
@cindex unexec
この関数は@code{unexec}メソッドを使用して、Emacsのカレント状態を実行可能ファイル@var{to-file}にダンプする。これは@var{from-file}
(通常はファイル@file{temacs})からシンボルを取得する。

この関数をすでにダンプ済みのEmacsで使用することはできない。この関数は非推奨であり、Emacsはデフォルトでは@code{unexec}サポートなしでビルドされているので利用できない。
@end defun

@defun pdumper-stats
カレントのEmacsセッションの状態がダンプファイルからリストアされると、この関数はダンプファイルに関する情報とEmacs状態のリストアに要した時間をリターンする。値は@w{@code{((dumped-with-pdumper
. t) (load-time . @var{time})  (dump-file-name
.
@var{file}))}}のようなalist。ここで@var{file}はダンプファイル名、@var{time}はダンプファイルから状態をリストアするのに要した秒数。カレントセッションがダンプファイルからリストアされたものでなければ値は@code{nil}。
@end defun

@node Pure Storage
@section 純粋ストレージ
@cindex pure storage

  Emacs Lispはユーザー作成Lispオブジェクトにたいして、@dfn{通常ストレージ(normal
storage)}と@dfn{純粋ストレージ(pure
storage)}という2種のストレージをもちます。通常ストレージはEmacsセッションが維持される間に新たにデータが作成される場所です。純粋ストレージは事前ロードされた標準Lispファイル内の特定のデータのために使用されます。このデータは実際のEmacs使用中に決して変更されるべきではないデータです。

  純粋ストレージは@command{temacs}が標準的な事前ローLispライブラリーのロード中にのみ割り当てられます。ファイル@file{emacs}ではこのメモリースペースは読み取り専用とマークされるのでマシン上で実行中のすべてのEmacsジョブで共有できます。純粋ストレージは拡張できません。Emacsのコンパイル時に固定された量が割り当てられて、それが事前ロードされるライブラリーにたいして不足なら@file{temacs}はそれに収まらない部分を動的メモリーに割り当てます。Emacsを@code{pdump}メソッド(@ref{Building
Emacs}を参照)を使用してダンプする場合には純粋ストレージのオーバーフローは特に重要ではありません(単に事前ロード済みのライブラリーのいくつかが別のEmacsジョブで共有できないことを意味する)。しかしEmacsを時代遅れとなった@code{unexec}メソッドでダンプする場合には結果イメージは動作するでしょうが、この状況ではメモリーリークとなるのでガーベージコレクション(@ref{Garbage
Collection}を参照)は無効です。そのような通常なら発生しないオーバーフローは、あなたが事前ロードライブラリの追加や標準的な事前ロードライブラリに追加を試みないかぎり発生しません。Emacsが@code{unexec}を使用してダンプされていたら、Emacsは開始時にオーバーフローに関する警告を表示するでしょう。これが発生したらファイル@file{src/puresize.h}内のコンパイルパラメーターを@code{SYSTEM_PURESIZE_EXTRA}を増やしてEmacsをリビルドする必要があります。

@defun purecopy object
この関数は純粋ストレージに@var{object}のコピーを作成してリターンする。これは同じ文字で新たに文字列を作成することにより文字列をコピーするが、純粋ストレージではテキストプロパティはない。これはベクターとコンスセルのコンテンツを再帰的にコピーする。シンボルのような他のオブジェクトのコピーは作成しないが未変更でリターンする。マーカーのコピーを試みるとエラーをシグナルする。

この関数はEmacsのビルド中とダンプ中を除き何もしない。通常は事前ロードされるLispファイル内でのみ呼び出される。
@end defun

@defvar pure-bytes-used
この変数の値は、これまでに割り当てられた純粋ストレージのバイト数。ダンプされたEmacsでは通常は利用可能な純粋ストレージの総量とほとんど同じであり、もしそうでないならわたしたちは事前割り当てをもっと少なくするだろう。
@end defvar

@defvar purify-flag
この変数は@code{defun}が純粋ストレージにその関数定義のコピーを作成するべきか否かを判断する。これが非@code{nil}ならその関数の定義は純粋ストレージにコピーされる。

このフラグはEmacsのビルド用の基本的な関数の初回ロード中は@code{t}となる。実行可能形式としてEmacsをダンプすることにより、ダンプ前後の実際の値とは無関係に常にこの変数に@code{nil}が書き込まれる。

実行中のEmacsでこのフラグを変更しないこと。
@end defvar

@node Garbage Collection
@section ガーベージコレクション

@cindex memory allocation
  プログラムがリストを作成するときや、(ライブライのロード等により)ユーザーが新しい関数を定義する際には、そのデータは通常ストレージに配置されます。通常ストレージが少なくなるとEmacsはもっとメモリーを割り当てるようにオペレーティングシステムに要求します。シンボル、コンスセル、小さいベクター、マーカー等のような別のタイプのLispオブジェクトはメモリー内の個別のブロックに隔離されます(大きいベクター、長い文字列、バッファー、および他の特定の編集タイプは非常に巨大であり1つのオブジェクトにたいして個別のブロックが割り当てられて、小さな文字列は8kバイトのブロック、小さいベクターは4kバイトのブロックにパックされる)。

@cindex vector-like objects, storage
@cindex storage of vector-like Lisp objects
  基本的なベクター以上のマーカー、オーバーレイ、バッファーのような多くのオブジェクトが、あたかもベクターであるかのように管理されています。対応するCデータ構造体には@code{union
vectorlike_header}フィールドが含まれ、そのメンバー@code{size}には@code{enum
pvec_type}で列挙されたサブタイプ、その構造体が含む@code{Lisp_Object}フィールドの数に関する情報、および残りのデータのサイズが含まれます。この情報は、オブジェクトのメモリーフットプリントの計算に必要であり、ベクターブロックの繰り返し処理の際のベクター割り当てコードにより使用されます。

@cindex garbage collection
  しばらくの間いくつかのストレージを使用して、(たとえば)バッファーのkillやあるオブジェクトを指す最後のポインターの削除によりそれを解放するのは非常に一般的です。この放棄されたストレージを再利用するためにEmacsは@dfn{ガーベージコレクター(garbage
collector)}を提供します。ガーベージコレクターは本質的には、いまだにLispプログラムからアクセス可能なすべてのLispオブジェクトを検索、マークすることにより動作します。これを開始するにはすべてのシンボル、それらの値と関連付けられている関数定義、現在スタック上にあるすべてのデータをアクセス可能であると仮定します。別のアクセス可能オブジェクトを介して間接的に到達できるすべてのオブジェクトもアクセス可能とみなされますが計算は``保守的''に行われるので、アクセス可能なオブジェクトの個数はいくらか過大に評価されるかもしれません。
accessible, but this calculation is done , so it may slightly overestimate
how many objects that are accessible.

  マーキングが終了してもマークされないオブジェクトはすべてガーベージ(garbage:
ごみ)です。Lispプログラムかユーザーの行為かに関わらず、それらに到達する手段はもはや存在しないので参照することは不可能です。誰もそれを失うことはないので、それらのスペースは再利用されることになります。ガーベージコレクターの2つ目ののフェーズ(sweep:
スイープ、一掃)ではそれらの再利用を計らいます(がマーキングは``保守的''に行われるのですべてのスイープが一度ですべての未使用オブジェクトをガーベージコレクトする保証はない)。

@c ??? Maybe add something describing weak hash tables here?

@cindex free list
  スイープフェーズは将来の割り当て用に、シンボルやマーカーと同様に未使用のコンスセルを@dfn{フリーリスト(free
list)}上に配置します。これはアクセス可能な文字列は少数の8kブロックを占有するように圧縮して、その後に他の8kブロックを解放します。ベクターブロックから到達不可能はベクターは可能なかぎり最大のフリーエリアを作成するために統合して、フリーエリアが完全な4kブロックに跨がるようならブロックは解放されます。それ以外ならフリーエリアはフリーリスト配列に記録されます。これは各エントリーが同サイズのエリアのフリーリストに対応します。巨大なベクター、バッファー、その他の巨大なオブジェクトは個別に割り当てと解放が行われます。

@cindex CL note---allocate more storage
@quotation
@b{Common Lispに関する注意:} 他のLispと異なりGNU Emacs
Lispはフリーリストが空のときにガーベージコレクターを呼び出さない。かわりに単にオペレーティングシステムに更なるストレージの割り当てを要求して、@code{gc-cons-threshold}バイトを使い切るまで処理を継続する。

これは特定のLispプログラムの範囲の実行直前に明示的にガーベージコレクターを呼び出せば、その範囲の実行中はガーベージコレクターが実行されないだろうと確信できることを意味する(そのプログラム範囲が2回目のガーベージコレクションを強制するほど多くのスペースを使用しないという前提)。
@end quotation

@deffn Command garbage-collect
このコマンドはガーベージコレクションを実行して使用中のスペース量の情報をリターンする(前回のガーベージコレクション以降に@code{gc-cons-threshold}バイトより多いLispデータを使用した場合には自然にガーベージコレクションが発生することもあり得る)。

@code{garbage-collect}は使用中のスペース量の情報をリストでリターンする。これの各エントリーは@samp{(@var{name}
@var{size}
@var{used})}という形式をもつ。このエントリーで@var{name}はそのエントリーが対応するオブジェクトの種類を記述するシンボル、@var{size}はそれが使用するバイト数、@var{used}はヒープ内で生きていることが解ったオブジェクトの数、オプションの@var{free}は生きていないがEmacsが将来の割り当て用に保持しているオブジェクトの数。全体的な結果は以下のようになる:

@example
((@code{conses} @var{cons-size} @var{used-conses} @var{free-conses})
 (@code{symbols} @var{symbol-size} @var{used-symbols} @var{free-symbols})
 (@code{strings} @var{string-size} @var{used-strings} @var{free-strings})
 (@code{string-bytes} @var{byte-size} @var{used-bytes})
 (@code{vectors} @var{vector-size} @var{used-vectors})
 (@code{vector-slots} @var{slot-size} @var{used-slots} @var{free-slots})
 (@code{floats} @var{float-size} @var{used-floats} @var{free-floats})
 (@code{intervals} @var{interval-size} @var{used-intervals} @var{free-intervals})
 (@code{buffers} @var{buffer-size} @var{used-buffers})
 (@code{heap} @var{unit-size} @var{total-size} @var{free-size}))
@end example

以下は例:

@example
(garbage-collect)
      @result{} ((conses 16 49126 8058) (symbols 48 14607 0)
                 (strings 32 2942 2607)
                 (string-bytes 1 78607) (vectors 16 7247)
                 (vector-slots 8 341609 29474) (floats 8 71 102)
                 (intervals 56 27 26) (buffers 944 8)
                 (heap 1024 11715 2678))
@end example

以下は各要素を説明するためのテーブル。最後の@code{heap}エントリーはオプションであり、背景にある@code{malloc}実装が@code{mallinfo}関数を提供する場合のみ与えられることに注意。

@table @var
@item cons-size
コンスセルの内部的サイズ(@code{sizeof (struct Lisp_Cons)})。

@item used-conses
使用中のコンスセルの数。

@item free-conses
オペレーティングシステムから取得したスペースにあるがカレントで未使用のコンスセルの数。

@item symbol-size
シンボルの内部的サイズ(@code{sizeof (struct Lisp_Symbol)})。

@item used-symbols
使用中のシンボルの数。

@item free-symbols
オペレーティングシステムから取得したスペースにあるがカレントで未使用のシンボルの数。

@item string-size
文字列ヘッダーの内部的サイズ(@code{sizeof (struct Lisp_String)})。

@item used-strings
使用中の文字列ヘッダーの数。

@item free-strings
オペレーティングシステムから取得したスペースにあるがカレントで未使用の文字列ヘッダーの数。

@item byte-size
これは利便性のために使用されるもので@code{sizeof (char)}と同じ。

@item used-bytes
すべての文字列データの総バイト数。

@item vector-size
長さ1のベクターのヘッダーを含めたバイトサイズ。

@item used-vectors
ベクターブロックから割り当てられたベクターブロック数。

@item slot-size
ベクタースロットの内部的なサイズで常に@code{sizeof (Lisp_Object)}と等しい。

@item used-slots
全使用済みベクターのスロット数。スロット数にはプラットフォームに応じてベクターのヘッダーに由来する一部、またはすべてのオーバーヘッドが含まれるかもしれない。

@item free-slots
すべてのベクターブロックのフリースロットの数。

@item float-size
浮動小数点数オブジェクトの内部的なサイズ(@code{sizeof (struct
Lisp_Float)})。(ネイティブプラットフォームの@code{float}や@code{double}と混同しないこと。)

@item used-floats
使用中の浮動小数点数の数。

@item free-floats
オペレーティングシステムから取得したスペースにあるがカレントで未使用の浮動小数点数の数。

@item interval-size
インターバルオブジェクト(interval object)の内部的なサイズ(@code{sizeof (struct interval)})。

@item used-intervals
使用中のインターバルの数。

@item free-intervals
オペレーティングシステムから取得したスペースにあるがカレントで未使用のインターバルの数。

@item buffer-size
バッファーの内部的なサイズ(@code{sizeof (struct
buffer)})。(@code{buffer-size}関数がリターンする値と混同しないこと。)

@item used-buffers
使用中のバッファーオブジェクトの数。これにはユーザーからは不可視のkillされたバッファー、つまりリスト@code{all_buffers}内のバッファーすべてが含まれる。

@item unit-size
ヒープスペースを計る単位であり常に1024バイトと等しい。

@item total-size
@var{unit-size}単位での総ヒープサイズ。

@item free-size
@var{unit-size}単位でのカレントで未使用のヒープスペース。
@end table

純粋スペース(@ref{Pure
Storage}を参照)内にオーバーフローがあり、かつEmacsが(時代遅れとなった)@code{unexec}メソッド(@ref{Building
Emacs}を参照)を使用してダンプされていたら、この場合は実際にガーベージコレクションを行うことは不可能なので@code{garbage-collect}は@code{nil}をリターンする。
@end deffn

@defopt garbage-collection-messages
この変数が非@code{nil}ならEmacsはガーベージコレクションの最初と最後にメッセージを表示する。デフォルト値は@code{nil}。
@end defopt

@defvar post-gc-hook
これはガーベージコレクションの終わりに実行されるノーマルフック。ガーベージコレクションはこのフックの関数の実行中は抑制されるので慎重に記述すること。
@end defvar

@defopt gc-cons-threshold
この変数の値は別のガーベージコレクションをトリガーするために、ガーベージコレクション後にLispオブジェクト用に割り当てなければならないストレージのバイト数。特定のオブジェクトタイプに関する情報を取得するために、@code{garbage-collect}がリターンした結果を使用できる。バッファーのコンテンツに割り当てられたスペースは勘定に入らない。

threshold(しきい値)の初期値は@code{GC_DEFAULT_THRESHOLD}であり、これは@file{alloc.c}内で定義されている。これは@code{word_size}単位で定義されているので、デフォルトの32ビット設定では400,000、64ビット設定では800,000になる。大きい値を指定するとガーベージコレクションの頻度が下る。これはガーベージコレクションにより費やされる時間を減少させる(のでガーベージコレクションが滅多に発生しないサイクル間ではLispプログラムは高速に実行されるだろう)が、メモリーの総使用量は増大する。大量のLispデータを作成するプログラムにおいて、特に高速な実行を要する場合にはこれを行いたいと思うかもしれない。ただしわたしたちは長期間に渡るthresholdの増加は推奨しないし、満足できる速さでプログラムが実行できる以上にの値には決してセットしないことをお勧める。必要以上に大きいthresholdを用いることによってシステムレベルでメモリーが逼迫する可能性があること、更にガーベージコレクションの各サイクルにより時間を要することにもなるので避けるべきである。

@code{GC_DEFAULT_THRESHOLD}の1/10まで下げた小さな値を指定することにより、より頻繁にガーベージコレクションを発生させることができる。この最小値より小さい値は後続のガーベージコレクションで、@code{garbage-collect}がthresholdを最小値に戻すときまでしか効果をもたないだろう。
@end defopt

@defopt gc-cons-percentage
この変数の値はガーベージコレクション発生するまでのコンス(訳注:
これは@code{gc-cons-threshold}や@code{gc-cons-percentage}の@samp{-cons-}のことで、これらの変数が定義されている@file{alloc.c}内ではLisp方言での@samp{cons}をより一般化したメモリー割り当てプロセスのことを指す模様)の量をカレントヒープサイズにたいする割り合いで指定する。この条件と@code{gc-cons-threshold}を並行して適用して、条件が両方満足されたときだけガーベージコレクションが発生する。

ヒープサイズ増加にともないガーベージコレクションの処理時間は増大する。したがってガーベージコレクションの頻度割合を減らすのが望ましいことがある。

@code{gc-cons-threshold}と同じように必要以上に増加させず、長期間増加したままにしないこと。
@end defopt

  @code{gc-cons-threshold}および@code{gc-cons-percentage}を介した制御は単なる近似です。たとえEmacsが定期的にしきい値(threshold)の枯渇をチェックしていても、効率上の理由によりヒープ、または@code{gc-cons-threshold}や@code{gc-cons-percentage}の変更のそれぞれにたいして、その後即座にガーベージコレクターをトリガーする訳ではありません。更にしきい値計算の効率化のために、Emacsはヒープ内のカレントでアクセス可能なオブジェクトを計数してヒープサイズを近似します。

  @code{garbage-collect}がリターンする値はデータ型に分類されたLispデータのメモリー使用量を記述します。それとは対照的に関数@code{memory-limit}はEmacsがカレントで使用中の総メモリー量の情報を提供します。

@defun memory-limit
この関数はEmacsがカレントで使用中の仮想メモリーの総バイト数を1024で除してリターンする。あるアクションがメモリー使用にどのよな効果を及ぼすかについて概観を得るためにこの関数を使用できる。
@end defun

@defvar memory-full
この変数はLispオブジェクト用のメモリーが不足に近い状態なら@code{t}、それ以外なら@code{nil}。
@end defvar

@defun memory-use-counts
これはそのEmacsセッションで作成されたオブジェクト数をカウントしたリスト。これらのカウンターはそれぞれ特定の種類のオブジェクトを数える。詳細はドキュメント文字列を参照のこと。
@end defun

@defun memory-info
この関数はシステムメモリーのトータル量とフリーな量をリターンする。サポートされないシステムでは値は@code{nil}かもしれない。

@code{default-directory}がリモートホスト上を指している場合には、そのホストのメモリー情報がリターンされる。
@end defun

@defvar gcs-done
この変数はそのEmacsセッションでそれまでに行われたガーベージコレクションの合計回数。
@end defvar

@defvar gc-elapsed
この変数はそのEmacsセッションでガーベージコレクションの間に費やされた経過時間を浮動小数点数で表した総秒数。
@end defvar

@defun memory-report
Emacsがどこでメモリーを使用(種々の変数、バッファー、キャッシュ)しているかが確認できれば便利なときがあるかもしれない。このコマンドはその概要を提供する(@samp{"*Memory
Report*"}という)バッファーを新たにオープンすることに加えて、``最大''のバッファーおよび変数をリストする。

ここでのデータは変数サイズを計算する同質的な方法が究極的に存在しないために近似値である。たとえば2つの変数がデータ構造を共有するかもしれず、その場合には2回カウントされるだろうが、このコマンドは依然としてEmacsが使用する有用なメモリーの高レベル概要を与えるかもしれない。
@end defun

@node Stack-allocated Objects
@section スタックに割り当てられたオブジェクト

@cindex stack allocated Lisp objects
@cindex Lisp objects, stack-allocated
  上述のガーベージコレクターはLispプログラムから可視なデータ、同様にLispインタープリターが内部的に使用するほとんどのデータの管理に使用されます。インタプリターのCスタックを使用して一時的に内部オブジェクトを割り当てることが有用なときがあります。割り当てとガーベージコレクターによる解放は、ヒープメモリーよりスタック割り当てを使用するほうが通常は高速なので、これはパフォーマンスの改善の助けになります。これには解放後にそのようなオブジェクトを使用することにより未定義の挙動を引き起こすという欠点があるので、使用においては熟考するとともに@code{GC_CHECK_MARKED_OBJECTS}機能(@file{src/alloc.c}を参照)を使用して慎重にデバッグするべきです。特にスタックに割り当てられたオブジェクトはユーザーのLispコードからは決して可視にならないようにする必要があります。

  現在のことろコンスセルと文字列をこの方法で割り当てできます。これはblock寿命をもつ名前つき@code{Lisp_Object}を定義する@code{AUTO_CONS}や@code{AUTO_STRING}のようなCマクロで実装されています。これらのオブジェクトはガーベージコレクターでは解放されません。かわりにこれらは自動記憶期間(automatic
storage
duration)をもちます。つまりそれらはすべてローカル変数のように割り当てられて、そのオブジェクトを定義するCブロックの実行の最後に自動的に解放されます。

  性能的な理由によりスタックに割り当てられる文字列は@acronym{ASCII}文字に限定されており、それらの多くが不変です。つまりそれらにたいして@code{ASET}を呼び出すと未定義の挙動を引き起こします。

@node Memory Usage
@section メモリー使用量
@cindex memory usage

  以下の関数と変数はEmacsが行なったメモリー割り当ての総量に関する情報をデータ型ごとに分類して提供します。これらの関数や変数と@code{garbage-collect}がリターンする値との違いに注意してください。@code{garbage-collect}はカレントで存在するオブジェクトを計数しますが、以下の関数や変数はすでに解放されたオブジェクトを含めて割り当てのすべての数やサイズを計数します。

@defvar cons-cells-consed
そのEmacsセッションでそれまでに割り当てられたコンスセルの総数。
@end defvar

@defvar floats-consed
そのEmacsセッションでそれまでに割り当てられた浮動小数点数の総数。
@end defvar

@defvar vector-cells-consed
そのEmacsセッションでそれまでに割り当てられたベクターセルの総数。これにはマーカー、オーバーレイのようなベクター様のオブジェクトに加えてユーザーには不可視な特定のオブジェクトが含まれる。
@end defvar

@defvar symbols-consed
そのEmacsセッションでそれまでに割り当てられたシンボルの総数。
@end defvar

@defvar string-chars-consed
そのEmacsセッションでそれまでに割り当てられた文字列の文字の総数。
@end defvar

@defvar intervals-consed
そのEmacsセッションでそれまでに割り当てられたインターバルの総数。
@end defvar

@defvar strings-consed
そのEmacsセッションでそれまでに割り当てられた文字列の総数。
@end defvar

@node C Dialect
@section C方言
@cindex C programming language

EmacsのC部分はC99およびそれ以降にたいして可搬性があります。C99以降の@samp{<stdckdint.h>}や@samp{[[noreturn]]}のようなC11固有の機能は通常はconfigure時に行われるチェックなしでは使用しておらず、Emacsのビルド手順は必要なら代替えの実装を提供します。C99以降の無名な構造体や共用体のようないくつかのC11機能はエミュレートが非常に困難なので完全に無視しています。

そう遠くない将来のある時点で基本となるC方言は間違いなくC99以降のものに変更されるでしょう。

@node Writing Emacs Primitives
@section Emacsプリミティブの記述
@cindex primitive function internals
@cindex writing Emacs primitives

  LispプリミティブとはCで実装されたLisp関数です。Lispから呼び出せるようにC関数インターフェースの詳細はCのマクロで処理されます。新たなCコードの記述のしかたを真に理解するにはソースを読むのが唯一の方法ですが、ここではいくつかの事項について説明します。

  スペシャルフォームの例として以下は@file{eval.c}の@code{or}です(通常の関数は同様の一般的な外観をもつ)。

@smallexample
@group
DEFUN ("or", For, Sor, 0, UNEVALLED, 0,
       doc: /* Eval args until one of them yields non-nil,
then return that value.
The remaining args are not evalled at all.
If all args return nil, return nil.
@end group
@group
usage: (or CONDITIONS...)  */)
  (Lisp_Object args)
@{
  Lisp_Object val = Qnil;
@end group

@group
  while (CONSP (args))
    @{
      val = eval_sub (XCAR (args));
      if (!NILP (val))
        break;
      args = XCDR (args);
      maybe_quit ();
    @}
@end group

@group
  return val;
@}
@end group
@end smallexample

@cindex @code{DEFUN}, C macro to define Lisp primitives
  では@code{DEFUN}マクロの引数について詳細に説明しましょう。以下はそれらのテンプレートです:

@example
DEFUN (@var{lname}, @var{fname}, @var{sname}, @var{min}, @var{max}, @var{interactive}, @var{doc})
@end example

@table @var
@item lname
これは関数名として定義するLispシンボル名。上記例では@code{or}。

@item fname
これは関数のC関数名。これはCコードでその関数を呼び出すために使用される名前。名前は慣習として@samp{F}の後にLisp名をつけて、Lisp名のすべてのダッシュ(@samp{-})をアンダースコアに変更する。つまりCコードから呼び出す場合には@code{For}を呼び出す。

@item sname
これはLispでその関数を表すsubrオブジェクト用にデータ保持のための構造体に使用されるC変数名。この構造体はそのシンボルを作成してそれの定義にsubrオブジェクトを格納する初期化ルーチンでLispシンボル名を伝達する。慣習により常に@var{fname}の@samp{F}を@samp{S}に置き換えた名前になる。

@item min
これは関数が要求する引数の最小個数。関数@code{or}は最小で0個の引数を受け入れる。

@item max
これは関数が受け入れる引数の最大個数が定数なら引数の最大個数。あるいは@code{UNEVALLED}なら未評価の引数を受け取るスペシャルフォーム、@code{MANY}なら評価される引数の個数に制限がないことを意味する(@code{&rest}と等価)。@code{UNEVALLED}と@code{MANY}はいずれもマクロ。@var{max}が数字なら@var{min}より大きく8より小さいこと。

@cindex interactive specification in primitives
@item interactive
これはLisp関数で@code{interactive}の引数として使用されるようなインタラクティブ仕様(文字列)である(@ref{Using
Interactive}を参照)。@code{or}の場合は@code{0}
(nullポインター)であり@code{or}がインタラクティブに呼び出せないことを示す。値@code{""}はインタラクティブに呼び出し時に、関数が引数を受け取るべきではないことを示す。値が@samp{"(}で始まる場合には、その文字列はLispフォームとして評価される。たとえば:

@example
@group
DEFUN ("foo", Ffoo, Sfoo, 0, 3,
       "(list (read-char-by-name \"Insert character: \")\
              (prefix-numeric-value current-prefix-arg)\
              t)",
       doc: /* @dots{} */)
@end group
@end example

@item doc
これはドキュメント文字列。複数行を含むために特別なことを要しないので、これにはCの文字列構文ではなくCコメント構文を使用する。@samp{doc:}の後のコメントはドキュメント文字列として認識される。コメントの開始と終了の区切り文字@samp{/*}と@samp{*/}はドキュメント文字列の一部にはならない。

ドキュメント文字列の最後の行がキーワード@samp{usage:}で始まる場合には、その行の残りの部分は引数リストをドキュメント化するためのものとして扱われる。この方法によりCコード内で使用される引数名とは異なる引数名をドキュメント文字列内で使用することができる。その関数の引数の個数に制限がなければ@samp{usage:}は必須。

プロットフォームにたいして1つといったように、複数の定義をもつプリミティブがいくつかある(たとえば@code{x-create-frame})。このような場合には各定義に同じドキュメント文字列を記述するよりも、ただ1つの定義が実際のドキュメントをもつようにしたほうがよい。他の定義は@file{DOC}ファイルをパースする関数から無視される、@samp{SKIP}で始まるプレースホルダーをもつ。

Lispコードでのドキュメント文字列にたいするすべての通常ルール(@ref{Documentation
Tips}を参照)はCコードのドキュメント文字列にも適用される。

以下のようにドキュメント文字列の後に、そのプリミティブを実装するC関数にたいするC関数属性のリストがあるかもしれない:

@example
@group
DEFUN ("bar", Fbar, Sbar, 0, UNEVALLED, 0
       doc: /* @dots{} */
       attributes: @var{attr1} @var{attr2} @dots{})
@end group
@end example

@noindent
後に続けることにより複数の属性を指定できる。現在のところ以下の属性が認識される:

@table @code
@item noreturn
決してリターンしないC関数を宣言する。これはC23の@code{[[noreturn]]}、C11の@code{_Noreturn}GCCの@w{@code{__attribute__
((__noreturn__))}} (@ref{Function Attributes,,, gcc, Using the GNU Compiler
Collection}を参照)に対応している(未サポートのプラットフォームにおいて@code{_Noreturn}はマクロとして定義されているので、Emacs独自コードは内部的にはこれを使っている)。

@item const
引数以外の値を検査せず、リターン値以外に影響しない関数を宣言する。これはC23の@code{[[unsequenced]]}、GCCの@w{@code{__attribute__
((__const__))}}に対応している。

@item noinline
これは関数がインラインとみなされることを抑止するGCCの属性@w{@code{__attribute__
((__noinline__))}}に対応している。これはたとえばスタックベースの変数にたいするリンク時の最適化の効果を取り消すために必要になるかもしれない。
@end table

@end table

  @code{DEFUN}マクロ呼び出しの後には、そのC関数にたいする引数リストを引数のタイプを含めて記述しなければなりません。そのプリミティブがLispで固定された最大個数をもつ引数を受け入れるなら、Lisp引数それぞれにたいして1つのC引数をもち、各引数のタイプは@code{Lisp_Object}でなければなりません(ファイル@file{lisp.h}ではタイプ@code{Lisp_Object}の値を作成する種々のマクロと関数が宣言されている)。プリミティブがスペシャルフォームなら、評価されないタイプ@code{Lisp_Object}の単一のLisp引数を含むLispリストを受け取らなければなりません。プリミティブのLispの最大引数個数に上限がない場合には正確に2つのC引数をもたなければなりません。1つ目はLisp引数の個数、2つ目はそれらの値を含むブロックのアドレスです。これらはそれぞれ@code{ptrdiff_t}、@w{@code{Lisp_Object
*}}のタイプをもちます。@code{Lisp_Object}は任意のデータ型と任意のLispオブジェクトを保持できるので、実行時のみ実際のデータ型を判断できます。特定のタイプの引数だけを受け入れるプリミティブを記述したい場合は、適切な述語を使用してタイプを明確にチェックしなければなりません(@ref{Type
Predicates}を参照)。
@cindex type checking internals

@cindex garbage collection protection
@cindex protect C variables from garbage collection
  関数@code{For}自体ではローカル変数@code{args}はEmacsのスタックマーキングによるガーベージコレクターが制御するオブジェクトを参照します。ガーベージコレクターはたとえCの@code{Lisp_Object}スタック変数から到達可能なオブジェクトを回収しなくても、文字列コンテンツやバッファーのテキストのようなオブジェクトの何らかのコンポーネントを移動するかもしれません。したがってこれらのコンポーネントにアクセスする関数はLispの評価を行なった後に、それらのアドレスの再取得に留意しなければなりません。これはコードが文字列コンテンツやバッファーテキストにたいするCポインターを維持するかわりに、バッファーや文字列の位置を維持して、Lispの評価を行なった後にその位置からCポインターを再計算する必要があることを意味しています。Lisp評価は直接と間接を問わず、@code{eval_sub}や@code{Feval}の呼び出しを通じて発生する可能性があります。

@cindex @code{maybe_quit}, use in Lisp primitives
  ループ内部の@code{maybe_quit}呼び出しに注意してください。この関数はユーザーが@kbd{C-g}を渡したかどうかをチェックして、もしそうなら処理をabortします。多数の繰り返しを要する可能性があるすべてのループ内でこれを行うべきです。この場合には引数のリストは非常に長くなるかもしれません。これはEmacsの応答性とユーザーエクスペリエンスを向上させます。

  Emacsが一度ダンプされた後に変数に何か書き込まれているときには、その静的変数やグローバル変数にCの初期化を使用してはなりません。初期化されたこれらの変数はEmacsのダンプの結果として、(特定のオペレーティングシステムでは)読み取り専用となるメモリーエリアに割り当てられます。@ref{Pure
Storage}を参照してください。

@cindex @code{defsubr}, Lisp symbol for a primitive
  C関数の定義だけではLispプリミティブを利用可能にするのに十分ではありません。そのプリミティブにたいしてLispシンボルを作成して関数セルに適切なsubrオブジェクトを格納しなければなりません。このコードは以下のようになるでしょう:

@example
defsubr (&@var{sname});
@end example

@noindent
ここで@var{sname}は@code{DEFUN}の3つ目の引数として使用する名前です。

  すでにLispプリミティブが定義されたファイルにプリミティブを追加する場合には、(そのファイル終端付近にある)@code{syms_of_@var{something}}という名前の関数を探して@code{defsubr}の呼び出しを追加してください。ファイルにこの関数がない、または新たなファイルを作成する場合には@code{syms_of_@var{filename}}
(例:
@code{syms_of_myfile})を追加します。それから@file{emacs.c}でそれらの関数が呼び出されるすべての箇所を探して@code{syms_of_@var{filename}}の呼び出しを追加してください。

@anchor{Defining Lisp variables in C}
@vindex byte-boolean-vars
@cindex defining Lisp variables in C
@cindex @code{DEFVAR_INT}, @code{DEFVAR_LISP}, @code{DEFVAR_BOOL}, @code{DEFSYM}
  関数@code{syms_of_@var{filename}}はLisp変数として可視となるすべてのC変数を定義する場所でもあります。@code{DEFVAR_LISP}はタイプ@code{Lisp_Object}のC変数をLispから可視にします。@code{DEFVAR_INT}はタイプ@code{int}のC変数を常に整数となる値をもつようにしてLispから可視にします。@code{DEFVAR_BOOL}はタイプ@code{int}のC変数を常に@code{t}か@code{nil}のいずれかとなる値をもつようにしてLispから可視にします。@code{DEFVAR_BOOL}で定義された変数はバイトコンパイラーに使用されるリスト@code{byte-boolean-vars}に自動的に追加されることに注意してください。

  これらのマクロはすべて3つの引数を期待します:

@table @code
@item lname
Lispプログラムが使用する変数名。
@item vname
Cソース内の変数名。
@item doc
Cコメントとしての変数用のドキュメント。詳細は@ref{Documentation Basics}を参照のこと。
@end table

  慣例として``ネイティブ''なタイプ(@code{int}と@code{bool})の変数の定義時には、Cの変数名はLisp変数の@code{-}が@code{_}で置換されます。変数がタイプ@code{Lisp_Object}をもつ際には、Cの変数名に@code{V}も前置します。たとえば

@smallexample
DEFVAR_INT ("my-int-variable", my_int_variable,
           doc: /* An integer variable.  */);

DEFVAR_LISP ("my-lisp-variable", Vmy_lisp_variable,
           doc: /* A Lisp variable.  */);
@end smallexample

  Lispではシンボルの値ではなくシンボル自身の参照を要する状況が存在します。1つは変数の値の一時的なオーバーライドであり、これはLispでは@code{let}で行われます。これはCソースでは、@code{specbind}を使用して対応する定数シンボルを定義することにより行われます。慣例により@code{Qmy_lisp_variable}は@code{Vmy_lisp_variable}に対応します。これを定義するには@code{DEFSYM}マクロを使用します。たとえば

@smallexample
DEFSYM (Qmy_lisp_variable, "my-lisp-variable");
@end smallexample

  実際にバインディングを行うには:

@smallexample
specbind (Qmy_lisp_variable, Qt);
@end smallexample

  Lispシンボルではクォートの使用が必要な場合がありますが、Cで同様の効果を達成するためには対応する定数シンボル@code{Qmy_lisp_variable}を使用します。たとえばLispでバッファーローカル変数(@ref{Buffer-Local
Variables}を参照)を作成する際には以下のように記述します:

@smallexample
(make-variable-buffer-local 'my-lisp-variable)
@end smallexample

C側の対応するコードは、以下のように@code{DEFSYM}と組み合わせて@code{Fmake_variable_buffer_local}を使用します。

@smallexample
DEFSYM (Qmy_lisp_variable, "my-lisp-variable");
Fmake_variable_buffer_local (Qmy_lisp_variable);
@end smallexample

@cindex defining customization variables in C
  Cで定義されたLisp変数を@code{defcustom}で宣言された変数のように振る舞わせたい場合には、@file{cus-start.el}に適切なエントリーを追加します。使用するフォーマットの説明は@ref{Variable
Definitions}を参照してください。

@cindex @code{staticpro}, protection from GC
  タイプ@code{Lisp_Object}のファイルをスコープとするC変数を直接定義する場合には、以下のように@code{syms_of_@var{filename}}内で@code{staticpro}を呼び出してガーベージコレクションから保護しなければなりません:

@example
staticpro (&@var{variable});
@end example

  以下はより複雑な引数をもつ別の関数例です。これは@file{window.c}からのコードであり、Lispオブジェクトを操作するためのマクロと関数の使用を示すものです。

@smallexample
@group
DEFUN ("coordinates-in-window-p", Fcoordinates_in_window_p,
       Scoordinates_in_window_p, 2, 2, 0,
       doc: /* Return non-nil if COORDINATES are in WINDOW.
  @dots{}
@end group
@group
  or `right-margin' is returned.  */)
  (register Lisp_Object coordinates, Lisp_Object window)
@{
  struct window *w;
  struct frame *f;
  int x, y;
  Lisp_Object lx, ly;
@end group

@group
  w = decode_live_window (window);
  f = XFRAME (w->frame);
  CHECK_CONS (coordinates);
  lx = Fcar (coordinates);
  ly = Fcdr (coordinates);
  CHECK_NUMBER (lx);
  CHECK_NUMBER (ly);
  x = FRAME_PIXEL_X_FROM_CANON_X (f, lx) + FRAME_INTERNAL_BORDER_WIDTH (f);
  y = FRAME_PIXEL_Y_FROM_CANON_Y (f, ly) + FRAME_INTERNAL_BORDER_WIDTH (f);
@end group

@group
  switch (coordinates_in_window (w, x, y))
    @{
    case ON_NOTHING:            /* NOT in window at all.  */
      return Qnil;
@end group

    @dots{}

@group
    case ON_MODE_LINE:          /* In mode line of window.  */
      return Qmode_line;
@end group

    @dots{}

@group
    case ON_SCROLL_BAR:         /* On scroll-bar of window.  */
      /* Historically we are supposed to return nil in this case.  */
      return Qnil;
@end group

@group
    default:
      emacs_abort ();
    @}
@}
@end group
@end smallexample

  CコードはCで記述されていなければ名前で呼び出すことはできないことに注意してください。Lispで記述された関数を呼び出すには関数@code{funcall}をCで具現化した@code{Ffuncall}を使用します。Lisp関数@code{funcall}は個数制限なしの引数を受け付けるので、Cでの引数はLispレベルでの引数個数とそれらの値を含む1次元配列という2個の引数になります。Lispレベルでの1つ目の引数は呼び出す関数、残りはそれに渡す引数です。

  C関数@code{call0}、@code{call1}、@code{call2}、...は個数が固定された引数でLisp関数を手軽に呼び出す便利な方法を提供します。これらは@code{Ffuncall}を呼び出すことにより機能します。

  @file{eval.c}は例を探すのに適したファイルです。@file{lisp.h}には重要なマクロと関数の定義がいくつか含まれています。

  副作用がない関数や純粋関数を定義したら、@code{side-effect-free}や@code{pure}のプロパティに非@code{nil}を与えてください(@ref{Standard
Properties}を参照)。

@node Writing Dynamic Modules
@section 動的にロードされるモジュールの記述
@cindex writing emacs modules
@cindex dynamic modules, writing

@cindex module @acronym{API}
  このセクションでがEmacsのモジュール@acronym{API}、およびEmacs用の拡張モジュール記述の一部としてそれらを使用する方法について説明します。モジュール@acronym{API}はCプログラム言語で定義されているので、このセクション内の記述と例はモジュールがCで記述されていると仮定します。別のプログラム言語ではCコード呼び出しのための適切なバインディングやインターフェースと機能の使用が必要になるでしょう。EmacsのCコードにはC99以降のコンパイラー(@ref{C
Dialect}を参照)が必要であり、このセクションもこの標準にしたがいます。

モジュールの記述とEmacsへの統合には以下のタスクが含まれます:

@itemize @bullet
@item
モジュール用の初期化コードの記述。

@item
1つ以上のモジュール関数の記述。

@item
Emacsとモジュール間での値とオブジェクトのやり取り。

@item
エラーコンディションと非ローカル脱出のハンドリング。
@end itemize

@noindent
以下のサクセクションこれらのタスクと@acronym{API}自体の詳細を説明します。

モジュールを一度記述したら共有ライブラリーを生成するために、背景のプラットドームの慣習に応じてモジュールをコンパイルします。その後で@code{load-path}
(@ref{Library Search}を参照)に言及されたディレクトリー内(Emacsが共有ライブラリーを探す場所)にそれを配置します。

Emacsダイナミックモジュール@acronym{API}にたいしてモジュールの適合性を検証したければ@kbd{--module-assertions}オプションでEmacsを呼び出します。@ref{Initial
Options,,,emacs, The GNU Emacs Manual}を参照してください。

@menu
* Module Initialization::
* Module Functions::
* Module Values::
* Module Misc::
* Module Nonlocal::          
@end menu

@node Module Initialization
@subsection モジュールの初期化コード
@cindex module initialization

  ヘッダーファイル@file{emacs-module.h}のインクルードとGPL互換性シンボル(GPL compatibility
symbol)によりモジュールの記述を始めましょう:

@example
#include <emacs-module.h>

int plugin_is_GPL_compatible;
@end example

Emacsインストールの一部としてシステムのインクルードツリーに@file{emacs-module.h}ファイルがインストールされます。かわりにEmacsのソースツリー内で見つけることもできます。

@anchor{module initialization function}
次にモジュール用の初期化関数を記述します。

@deftypefn Function int emacs_module_init (struct emacs_runtime *@var{runtime})
Emacsはモジュールをロードする際にこの関数を呼び出す。モジュールが@code{emacs_module_init}という名前の関数をエクスポートしていなければモジュールはエラーをシグナルする。この初期化関数は初期化成功時には0、それ以外は非0をリターンすること。後者の場合にはEmacsはエラーをシグナルして、モジュールのロードは失敗する。初期化中にユーザーが@kbd{C-g}を押下すると、Emacsは初期化関数のリターン値を無視してquitする(@ref{Quitting}を参照)(必要なら初期化関数内でユーザーのquitをcatchできる。@ref{should_quit}を参照)。

引数@var{runtime}は2つのパブリックなフィールドを含むCの@code{struct}へのポインター、@code{size}はその構造体のバイトサイズ、@code{get_environment}はEmacsの環境オブジェクトとそのインターフェースにモジュール初期化関数をアクセス可能にする関数へのポインターを提供する。

初期化関数はモジュールに必要な初期化は何であれすべて行うこと。さらに以下のタスクを行うことができる:

@table @asis
@cindex compatibility, between modules and Emacs
@item 互換性の検証
モジュールにコンパイルされた@var{runtime}構造体の@code{size}メンバーの値を比較することにより、モジュールをロードするEmacs実行可能形式がモジュールと互換性があるか検証できる。

@example
int
emacs_module_init (struct emacs_runtime *runtime)
@{
  if (runtime->size < sizeof (*runtime))
    return 1;
@}
@end example

@noindent
モジュールに渡されたruntimeオブジェクトのsizeが期待する値より小さければ、ロードしようとしているモジュールがEmacsの新しい(最近の)バージョン向けにコンパイルされていることを意味する(そのモジュールはEmacsのバイナリーとは非互換かもしれない)。

さらにモジュールは期待しているモジュール@acronym{API}の互換性も検証できる。以下の例では上述の@code{emacs_module_init}関数の一部であることを仮定している:

@example
  emacs_env *env = runtime->get_environment (runtime);
  if (env->size < sizeof (*env))
    return 2;
@end example

@noindent
@cindex module runtime environment
これは@acronym{API}の@dfn{環境(environment)}へのポインターの取得用に構造体@code{runtime}
(@code{size}フィールドに構造体のバイトサイズも保有するC@code{struct}
)で提供されるポインターを使用して@code{get_environment}関数を呼び出す。

最後にEmacsから渡された環境のサイズと既知のサイズを比較することによって、以下のように古いバージョンのEmacsで動作するモジュールを記述できる:

@example
  emacs_env *env = runtime->get_environment (runtime);
  if (env->size >= sizeof (struct emacs_env_26))
    emacs_version = 26;  /* Emacs 26 or later.  */
  else if (env->size >= sizeof (struct emacs_env_25))
    emacs_version = 25;
  else
    return 2; /* Unknown or unsupported version.  */
@end example

@noindent
新しいバージョンのEmacsではメンバーを環境に常に@emph{追加}して@emph{削除}は決して行わないので、新たなEmacsのリリースではサイズは増加するだけであることにより機能する。与えられたバージョンのEmacsにたいして、そのバージョンに存在するモジュール@acronym{API}は新しいバージョンのものと等しいので、その部分だけを使用できる。

@file{emacs-module.h}はプリプロセッサマクロ@code{EMACS_MAJOR_VERSION}を定義する。これはヘッダーがサポートするEmacsの最新バージョンとなる整数リテラルに展開される。@ref{Version
Info}を参照のこと。@code{EMACS_MAJOR_VERSION}はコンパイル時の定数であり、モジュールをロードしたカレントで実行中のEmacsのバージョンを表さないことに注意。@file{emacs-module.h}やEmacsの種々なバージョンにたいして互換性をもたせたければ、@code{EMACS_MAJOR_VERSION}にもとづいた条件コンパイルを使用できる。

モジュールが処理全体を初期化関数内で行い、Lispオブジェクトにアクセスしたり環境構造体を通じてアクセス可能なEmacs関数を使用することがない場合を除いて、モジュールの互換性検証を常に行うことを推奨する。

@item Lispシンボルへのモジュール関数のバインド
これはLispコードが名前で呼び出せるようにモジュール関数に名前を与える。これを行う方法については以下の@ref{Module
Functions}で説明する。
@end table
@end deftypefn

@node Module Functions
@subsection モジュール関数の記述
@cindex writing module functions
@cindex module functions

  Emacsモジュールを記述する主な理由は、そのモジュールをロードしたLispプログラムが追加の関数を利用できるようにするためです。このサブセクションでは、そのような@dfn{モジュール関数(module
functions)}の記述方法を説明します。

モジュール関数は以下のような一般的なフォームとシグネチャをもっています:

@deftypefn Function emacs_value emacs_function (emacs_env *@var{env}, ptrdiff_t @var{nargs}, emacs_value *@var{args}, void *@var{data})
@tindex emacs_function The @var{env} argument provides a pointer to the
@acronym{API} environment, needed to access Emacs objects and functions.
The @var{nargs} argument is the required number of arguments, which can be
zero (see @code{make_function} below for more flexible specification of the
argument number), and @var{args} is a pointer to the array of the function
arguments.  The argument @var{data} points to additional data required by
the function, which was arranged when @code{make_function} (see below) was
called to create an Emacs function from @code{emacs_function}.

モジュール関数はEmacsとモジュール間でLispオブジェクトをやり取りするためにタイプ@code{emacs_value}を使用する(@ref{Module
Values}を参照)。以下で説明する@acronym{API}と以降のサブセクションではCの基本データ型と、それらに対応する@code{emacs_value}オブジェクトの慣習にたいする機能を提供する。

モジュール関数のbodyにおいては、インデックス@code{@var{nargs}-1}を超えた配列@var{args}の要素へのアクセスを@emph{試みてはならない}。配列@var{args}にたいするメモリーは@var{nargs}の値を正確に収納できるように割り当てられるため、それを超えてアクセスを行うとあなたのモジュールはほとんどの場合はクラッシュするだろう。特に実行時に関数に渡された@var{nargs}の値が0の場合には、メモリーは何も割り当てられないので@var{args}にアクセスしてはならない。

モジュール関数は常に値をリターンする。関数が正常にリターンすると、それに呼び出されたLispコードは関数がリターンした@code{emacs_value}値に対応するLispオブジェクトを目にすることになる。しかしユーザーが@kbd{C-g}をタイプしたり、モジュール関数やその呼び出し先がエラーをシグナルしたり非ローカルなexit
(@ref{Module
Nonlocal}を参照)を行なった場合には、Emacsはリターン値を無視してLispコードが同じ状況に遭遇した際のようにquitやthrrowを行う。

ヘッダー@file{emacs-module.h}は関数ポインターからモジュール関数へのエイリアス型として@code{emacs_function}型をを提供する。
@end deftypefn

モジュール関数用のCコード記述後には、そこから@code{make_function}を使用してLisp関数オブジェクトを作成する必要があります。@code{make_function}関数へのポインターは環境内で提供されます(環境へのポインターは@code{get_environment}がリターンすることを思い出してほしい)。これは通常は@acronym{API}のモジュール初期化関数(@ref{module
initialization function}を参照)の内部で互換性検証後に行われます。

@deftypefn Function emacs_value make_function (emacs_env *@var{env}, ptrdiff_t @var{min_arity}, ptrdiff_t @var{max_arity}, emacs_function @var{func}, const char *@var{docstring}, void *@var{data})
@vindex emacs_variadic_function
これはC関数@var{func}が作成した上記@code{emacs_function}で説明したシグネチャをもつEmacs関数をリターンする。引数@var{min_arity}と@var{max_arity}は、@var{func}が受け付ける引数の最大個数と最小個数を指定する。引数@var{max_arity}は特別な値@code{emacs_variadic_function}をもつことができる。これはLispの@code{&rest}キーワードのように、関数の受け付ける引数の個数を無制限にする(@ref{Argument
List}を参照)。

引数@var{data}は@var{func}の呼び出し時に任意の追加データを渡すための手段である。@code{make_function}に渡されたポインターが何であれ、それは変更されずに@var{func}に渡される。

引数@var{docstring}はその関数用のドキュメント文字列を指定する。これは@acronym{ASCII}文字列かUTF-8にエンコードされた非@acronym{ASCII}文字列、または@code{NULL}ポインターのいずれかであること。後者の場合には関数がドキュメントをもたないことを意味する。ドキュメント文字列はadvertised-calling-conventionを指定する行で終端できる。@ref{Function
Documentation}を参照のこと。

すべてのモジュール関数は1つ目の引数として環境へのポインターを受け取らなければならないので、@code{make_function}は任意のモジュール関数から呼び出され得るが、モジュールが一度ロードされればすべてのモジュール関数がEmacsに既知となるように、通常はこれをモジュール初期化関数で行うことを望むだろう。
@end deftypefn

最後にLispコードが関数を名前で呼び出せるようにLisp関数をシンボルにバインドする必要があります。これを行うにはモジュール@acronym{API}関数@code{intern}
(@ref{intern}を参照)を使用します。この関数のポインターもモジュール関数がアクセス可能な環境内で提供されています。

上述のステップを組み合わせて、モジュール初期化関数の中で以下のようにC用にアレンジしたコード@code{module_func}が、Lispから@code{module-func}として呼び出し可能になります:

@example
 emacs_env *env = runtime->get_environment (runtime);
 emacs_value func = env->make_function (env, min_arity, max_arity,
                                        module_func, docstring, data);
 emacs_value symbol = env->intern (env, "module-func");
 emacs_value args[] = @{symbol, func@};
 env->funcall (env, env->intern (env, "defalias"), 2, args);
@end example

@noindent
@code{env->intern}の呼び出しによりシンボル@code{module-func}はEmacsが知ることとなり、それから関数をこのシンボルにバインドするためにEmacsから@code{defalias}を呼び出します。@code{defalias}のかわりに@code{fset}の使用も可能なことに注意してください。両者の違いは@ref{Defining
Functions, defalias}に説明があります。

@code{emacs_module_init}関数(@ref{module initialization
function}を参照)を含むモジュール関数は、直接間接を問わずEmacsから呼び出されていれば、何らかの生きた@code{emacs_env}ポインターによる環境関数呼び出しにより、Emacsだけと対話する可能性があります。言い換えると、モジュール関数によるLisp関数やEmacsプリミティブを呼び出し、@code{emacs_value}とCデータタイプ(@ref{Module
Values}を参照)の間の変換、あるいは別の方法によるEmacsとの対話を行いたい場合には、Emacsからの@code{emacs_module_init}やモジュール関数への呼び出しのいくつかがコールスタック上になければなりません。モジュール関数はガーベージコレクションの間はEmacsと対話しないかもしれません。@ref{Garbage
Collection}を参照してください。モジュール関数はEmacsが作成したLispインタープリタースレッド(メインスレッドを含む)とだけ対話するかもしれません。@ref{Threads}を参照してください。コマンドラインオプション@kbd{--module-assertions}は、上記の要件にたいする違反のいくつかを検知できます。@ref{Initial
Options,,,emacs, The GNU Emacs Manual}を参照してください。

モジュール@acronym{API}の使用により、より複雑な関数やデータ型(インライン関数、マクロ等)の定義が可能になります。ただしCの結果コードは扱いにくく、可読性も低下します。したがって関数やデータ構造を作成するモジュールコードを可能なかぎり最小限に留めるとともに、残りの部分をモジュールに付属するLispパッケージに付託することを推奨します。なぜならこれらの追加タスクをLispで行うのはより用意であり、より可読性の高いコードが生成されるでしょう。たとえば上記のようにモジュール関数@code{module-func}が定義されていれば、以下のようなシンプルなLispラッパーによってマクロ@code{module-macro}を作成するのも1つの方法です:

@lisp
(defmacro module-macro (&rest args)
  "Documentation string for the macro."
  (module-func args))
@end lisp

モジュールに同梱されるLispパッケージは、Emacsにパッケージがロードされる際に@code{load}プリミティブ(@ref{Dynamic
Modules}を参照)を使用してモジュールをロードできます。

デフォルトでは@code{make_function}により作成したモジュール関数は非インタラクティブです。これらをインタラクティブにするために、以下の関数を使用できます。

@deftypefun void make_interactive (emacs_env *@var{env}, emacs_value @var{function}, emacs_value @var{spec})
このEmacs
28以降で利用可能になった関数はインタラクティブ仕様@var{spec}を使用して、関数@var{function}をインタラクティブにする。Emacsは@var{spec}を@code{interactive}フォームの引数のように解釈する。@ref{Using
Interactive}と@ref{Interactive
Codes}を参照のこと。@var{function}は@code{make_function}がリターンするEmacsモジュール関数であること。
@end deftypefun

モジュール関数のインタラクティブ仕様を取得するためのネイティブなモジュールサポートは存在しないことに注意。これを行うためには@code{interactive-form}を使用する。@ref{Using
Interactive}を参照のこと。一度@code{make_interactive}を使用してモジュール関数をインタラクティブにした後に、非インタラクティブにすることはできない。

@anchor{Module Function Finalizers}
モジュール関数オブジェクト(例:
@code{make_function}がリターンしたオブジェクト)がガーベージコレクトされた際に何らかのコードを実行したい場合には、@dfn{関数ファイナライザー(function
finalizer)}をインストールできます。関数ファイナライザーはEmacs
28以降で利用できます。たとえば@code{make_function}の@var{data}引数にヒープ割り当てした構造体を渡した場合には、構造体の割り当て解放にファイナライザーを使用できます。@ref{Basic
Allocation,,,libc}と@ref{Freeing after
Malloc,,,libc}を参照してください。ファイナライザー関数は以下のsignatureをもちます:

@example
void finalizer (void *@var{data})
@end example

ここで@var{data}は@code{make_function}呼び出し時に@var{data}に渡された値です。ファイナライザーがEmacsと相互作用する手段は何もないことに注意してください。

@code{make_function}呼びの直後には、新たに作成された関数はファイナライザーをもちません。ファイナライザーを望む場合には、ファイナライザーを追加するために@code{set_function_finalizer}を使用します。

@deftypefun void emacs_finalizer (void *@var{ptr})
ヘッダー@file{emacs-module.h}はEmacsファイナライザー関数にたいするエイリアスタイプとしてタイプ@code{emacs_finalizer}を提供する。
@end deftypefun

@deftypefun emacs_finalizer get_function_finalizer (emacs_env *@var{env}, emacs_value @var{arg})
このEmacs
28以降で利用可能になった関数は、@var{arg}により示されるモジュール関数に関連付けられた関数ファイナライザーをリターンする。@var{arg}はモジュール関数、すなわち@code{make_function}がリターンするオブジェクトを参照しなければならない。その関数に関連付けられたファイナライザーがなければ、@code{NULL}をリターンする。
@end deftypefun

@deftypefun void set_function_finalizer (emacs_env *@var{env}, emacs_value @var{arg}, emacs_finalizer @var{fin})
このEmacs
28以降で利用可能になった関数は、@var{arg}で示されるモジュール関数に関連付けられる関数ファイナライザーに@var{fin}をセットする。@var{arg}はモジュール関数、すなわち@code{make_function}がリターンするオブジェクトを参照しなければならない。@var{fin}には@var{arg}の関数ファイナライザーをクリアーする@code{NULL}、あるいは@var{arg}により示されるオブジェクトのガーベージコレクト時に呼び出される関数へのポインターを指定できる。関数ごとに最大で1つの関数ファイナライザーをセットできる。@var{arg}がすでにファイナライザーを所有する場合には@var{fin}で置き換えられる。
@end deftypefun

@node Module Values
@subsection Lisp・モジュール間の値変換
@cindex module values, conversion

@cindex @code{emacs_value} data type
  非常に少数の例外を除くほとんどのモジュールでは、モジュールを呼び出すLispプログラムとの間でモジュール関数への引数やリターン値の受け渡しでデータのやり取りが必要になります。この目的にたいしてモジュール@acronym{API}は@code{emacs_value}タイプを提供しています。これは@acronym{API}を通じたやり取りにおいてEmacsのLispオブジェクトを表現するタイプであり、EmacsのCプリミティブ(@ref{Writing
Emacs
Primitives}を参照)で使用される@code{Lisp_Object}タイプと機能的には等価です。このセクションではLispの基本データ型に対応する@code{emacs_value}オブジェクトの作成を可能とするモジュール@acronym{API}の部分と、Lispオブジェクトに対応する@code{emacs_value}オブジェクト内のCデータへのアクセス方法について説明します。

以下で説明するすべての関数は、実際にはすべてのモジュール関数が受け取る環境へのポインターを介して提供される@emph{関数ポインター(function
pointers)}です。したがってモジュールのコードでは以下のように環境ポインターを通じてこれらの関数を呼び出す必要があります:

@example
emacs_env *env;  /* the environment pointer */
env->some_function (arguments@dots{});
@end example

@noindent
@code{emacs_env}ポインターは通常はモジュール関数の1つ目の引数、モジュール初期化関数内で環境が必要な場合には@code{get_environment}の呼び出しから取得できます。

以下で説明するもののほとんどはEmacs 25で利用可能になった関数であり、Emacs
25はダイナミックモジュールを最初にサポートした最初のEmacsリリースです。それ以降のリリースで利用可能になったいくつかの関数につていは、それらをサポートする最初のEmacsバージョンを付記します。

以下の@acronym{API}関数は@code{emacs_value}オブジェクトから種々のCデータ型を抽出します。これらすべては引数の@code{emacs_value}オブジェクトがその関数の期待するタイプでなければ、エラーコンディション@code{wrong-type-argument}をraiseします(@ref{Type
Predicates}を参照)。Emacsモジュール内でエラーをシグナルする方法、およびEmacsにエラーが報告される前にモジュール内部でエラーコンディションをcatchする方法の詳細は@ref{Module
Nonlocal}を参照してください。@code{emacs_value}のタイプ取得には@acronym{API}関数@code{type_of}を使用できます(@ref{Module
Misc, type_of}を参照)。

@deftypefn Function intmax_t extract_integer (emacs_env *@var{env}, emacs_value @var{arg})
この関数は@var{arg}で指定されたLisp整数の値をリターンする。リターン値のCデータ型@code{intmax_t}はCコンパイラーがサポートする最大の整数型であり、一般的には@w{@code{long
long}}。@var{arg}の値が@code{intmax_t}に収まらなければ、関数はエラーシンボル@code{overflow-error}を使用してエラーをシグナルする。
@end deftypefn

@deftypefn Function bool extract_big_integer (emacs_env *@var{env}, emacs_value @var{arg}, int *@var{sign}, ptrdiff_t *@var{count}, emacs_limb_t *@var{magnitude})
このEmacs
27から利用可能になった関数は、@var{arg}の整数値を抽出する。@var{arg}の値は整数(fixnumかbignum)でなければならない。@var{sign}が@code{NULL}以外なら、@var{arg}の符号(-1、0、+1)を@code{*sign}に格納する。マグニチュード(magnitude:
大きさ)は次のように@var{magnitude}に格納される。@var{count}と@var{magnitude}がいずれも非@code{NULL}なら、@var{magnitude}は少なくとも@code{*count}
@code{unsigned
long}要素の配列を指さなければならない。@var{magnitude}が@var{arg}のマグニチュードを保持するのに十分大きければ、この関数は@var{magnitude}配列にリトルエンディアン形式でマグニチュードを書き込み、配列の要素数を@code{*count}に格納して@code{true}をリターンする。@var{magnitude}の大きさが十分でなければ、必要な配列サイズを@code{*count}に格納，エラーをシグナルして@code{false}をリターンする。@var{count}が非@code{NULL}かつ@var{magnitude}が@code{NULL}なら、必要となる配列サイズを@code{*count}に格納して@code{true}をリターンする。

Emacsは@code{*count}に要求される最大値が@code{min (PTRDIFF_MAX, SIZE_MAX) / sizeof
(emacs_limb_t)}を超えないことを保証するので、@code{magnitude}配列の割り当てではサイズ計算で整数のオーバーフローを心配せずに@code{malloc
(*count * sizeof *magnitude)}を使用できる。
@end deftypefn

@deftp {Type alias} emacs_limb_t
これは大きい整数向け変換関数のマグニチュード配列の要素タイプとして使用される符号なし整数タイプ。このタイプは一意なオブジェクト表現をもつ(パディングビットがない)ことが保証されている。
@end deftp

@defvr Macro EMACS_LIMB_MAX
これは@code{emacs_limb_t}にたいして可能な最大値を指定する定数式に展開されるマクロ。この式は@code{#if}内での利用に適する。
@end defvr

@deftypefn Function double extract_float (emacs_env *@var{env}, emacs_value @var{arg})
この関数は@var{arg}で指定されたLisp浮動小数の値をCの@code{double}値としてリターンする。
@end deftypefn

@deftypefn Function {struct timespec} extract_time (emacs_env *@var{env}, emacs_value @var{arg})
このEmacs 27から利用可能になった関数は@var{arg}をEmacs Lispのtime値として解釈して、それに対応する@code{struct
timespec}をリターンする。@ref{Time of Day}を参照のこと。@code{struct
timespec}はナノ秒の精度のタイムスタンプを表す。以下のメンバーをもつ:

@table @code
@item time_t tv_sec
整数秒。
@item long tv_nsec
ナノ秒としての小数秒数。@code{extract_time}がリターンするタイムスタンプでは常に非負かつ十億未満(@code{tv_nsec}のタイプが@code{long}であることをPOSIXがが要求しているとしても、非標準的なプラットフォームでは@code{long
long}である)。
@end table

@noindent
@ref{Elapsed Time,,,libc}を参照のこと。

@var{time}がナノ秒より高い精度をもつ場合には、この関数はナノ秒の精度へ負の無限大方向に切り詰める。@code{struct
timespec}が(ナノ秒に切り詰めた)@var{time}を表現できなければ、この関数はエラーをシグナルする。たとえば@code{time_t}が32ビット整数タイプなら100億秒という@var{time}値はエラーをシグナルするが、600ピコ秒の@var{time}値は0に切り詰められるだろう。

@code{struct
timespec}で表現できないtime値を処理する必要があったり、より高い精度が必要ならLisp関数@code{encode-time}を呼び出してリターン値を処理すればよい。@ref{Time
Conversion}を参照のこと。
@end deftypefn

@deftypefn Function bool copy_string_contents (emacs_env *@var{env}, emacs_value @var{arg}, char *@var{buf}, ptrdiff_t *@var{len})
これは@var{arg}で指定されたLisp文字列をUTF-8にエンコードしたテキストを@var{buf}が指す@code{char}配列に格納する。@var{buf}は少なくとも終端のnullバイトを含む@code{*@var{len}}バイトを保持するために十分なスペースをもつこと。引数@var{len}は@code{NULL}ポインターであってはならない。この関数の呼び出し時には@var{buf}のバイトサイズを指定する値を指していること。

@code{*@var{len}}で指定されたバッファーサイズが文字列のテキストを保持するために十分大きければ、関数は終端のnullバイト含む実際にコピーされる@code{*@var{len}}バイトを@var{buf}にコピーして@code{true}をリターンする。バッファーが小さすぎる場合には、関数はエラーコンディション@code{args-out-of-range}をraiseするとともに、必要なバイト数を@code{*@var{len}}に格納して@code{false}をリターンする。保留中のエラーコンディションのハンドル方法は@ref{Module
Nonlocal}を参照のこと。

引数@var{buf}は@code{NULL}ポインターでもよく、この場合には関数は@var{arg}のコンテンツの格納に必要なバイト数を@code{*@var{len}}に格納して@code{true}をリターンする。これは特定の文字列を格納するために必要な@var{buf}サイズを決定する手段となり得る。1回目は@var{buf}を@code{NULL}で@code{copy_string_contents}を呼び出して、関数により@code{*@var{len}}に格納されたバイト数の保持に十分なメモリーを割り当ててから、実際にテキストのコピーを行うために非@code{NULL}の@var{buf}で関数を再び呼び出す。
@end deftypefn

@deftypefn Function emacs_value vec_get (emacs_env *@var{env}, emacs_value @var{vector}, ptrdiff_t @var{index})
この関数は@var{vector}の@var{index}の要素をリターンする。ベクターの最初の要素の@var{index}は0。@var{index}の値が無効ならこの関数はエラーコンディション@code{args-out-of-range}をraiseする。関数のリターン値からCデータを抽出するためには、ベクターの当該要素に格納されたLispデータタイプに応じて、ここで説明している他の抽出関数を使用すればよい。
@end deftypefn

@deftypefn Function ptrdiff_t vec_size (emacs_env *@var{env}, emacs_value @var{vector})
この関数は@var{vector}内の要素数をリターンする。
@end deftypefn

@deftypefn Function void vec_set (emacs_env *@var{env}, emacs_value @var{vector}, ptrdiff_t @var{index}, emacs_value @var{value})
この関数は@var{vector}のインデックス@var{index}の要素に@var{value}を格納する。@var{index}の値が無効ならこの関数はエラーコンディション@code{args-out-of-range}をraiseする。
@end deftypefn

以下はCの基本データ型から@code{emacs_value}オブジェクトを作成する@acronym{API}関数です。これらはすべて作成した@code{emacs_value}オブジェクトをリターンします。

@deftypefn Function emacs_value make_integer (emacs_env *@var{env}, intmax_t @var{n})
この関数は引数@var{n}
(整数)を受け取り対応する@code{emacs_value}オブジェクトをリターンする。@var{n}の値が@code{most-negative-fixnum}と@code{most-positive-fixnum}の内外いずれであるかに応じてfixnumかbignumのいずれかをリターンする(@ref{Integer
Basics}を参照)。@var{n}の値をEmacs整数で表現できない、すなわち@code{most-negative-fixnum}と@code{most-positive-fixnum}の範囲外(@ref{Integer
Basics}を参照)ならエラーコンディション@code{overflow-error}をraiseする。
@end deftypefn

@deftypefn Function emacs_value make_big_integer (emacs_env *@var{env}, int sign, ptrdiff_t count, const emacs_limb_t *magnitude)
このEmacs
27から利用可能になった関数は任意のサイズの整数の引数を受け取り、それに対応する@code{emacs_value}オブジェクトをリターンする。@var{sign}引数はリターン値の符号を与える。@var{sign}が0以外なら、@var{magnitude}はリターン値のマグニチュードをリトルエンディアンで指定する、少なくとも@var{count}個の要素数の配列を指さなければならない。
@end deftypefn

以下は与えられた整数の次の確率的素数を計算するためにGNU Multiprecision Library
(GMP)を使用する例です。GMPの概要は@ref{Top,,,gmp}、@code{magnitude}とGMPの@code{mpz_t}値との間の変換方法については@ref{Integer
Import and Export,,,gmp}を参照してください。

@example
#include <emacs-module.h>
int plugin_is_GPL_compatible;

#include <assert.h>
#include <limits.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include <gmp.h>

static void
memory_full (emacs_env *env)
@{
  static const char message[] = "Memory exhausted";
  emacs_value data = env->make_string (env, message,
                                       strlen (message));
  env->non_local_exit_signal
    (env, env->intern (env, "error"),
     env->funcall (env, env->intern (env, "list"), 1, &data));
@}

enum
@{
  order = -1, endian = 0, nails = 0,
  limb_size = sizeof (emacs_limb_t),
  max_nlimbs = ((SIZE_MAX < PTRDIFF_MAX ? SIZE_MAX : PTRDIFF_MAX)
                / limb_size)
@};

static bool
extract_big_integer (emacs_env *env, emacs_value arg, mpz_t result)
@{
  ptrdiff_t nlimbs;
  bool ok = env->extract_big_integer (env, arg, NULL, &nlimbs, NULL);
  if (!ok)
    return false;
  assert (0 < nlimbs && nlimbs <= max_nlimbs);
  emacs_limb_t *magnitude = malloc (nlimbs * limb_size);
  if (magnitude == NULL)
    @{
      memory_full (env);
      return false;
    @}
  int sign;
  ok = env->extract_big_integer (env, arg, &sign, &nlimbs, magnitude);
  assert (ok);
  mpz_import (result, nlimbs, order, limb_size, endian, nails, magnitude);
  free (magnitude);
  if (sign < 0)
    mpz_neg (result, result);
  return true;
@}

static emacs_value
make_big_integer (emacs_env *env, const mpz_t value)
@{
  size_t nbits = mpz_sizeinbase (value, 2);
  int bitsperlimb = CHAR_BIT * limb_size - nails;
  size_t nlimbs = nbits / bitsperlimb + (nbits % bitsperlimb != 0);
  emacs_limb_t *magnitude
    = nlimbs <= max_nlimbs ? malloc (nlimbs * limb_size) : NULL;
  if (magnitude == NULL)
    @{
      memory_full (env);
      return NULL;
    @}
  size_t written;
  mpz_export (magnitude, &written, order, limb_size, endian, nails, value);
  assert (written == nlimbs);
  assert (nlimbs <= PTRDIFF_MAX);
  emacs_value result = env->make_big_integer (env, mpz_sgn (value),
                                              nlimbs, magnitude);
  free (magnitude);
  return result;
@}

static emacs_value
next_prime (emacs_env *env, ptrdiff_t nargs, emacs_value *args,
            void *data)
@{
  assert (nargs == 1);
  mpz_t p;
  mpz_init (p);
  extract_big_integer (env, args[0], p);
  mpz_nextprime (p, p);
  emacs_value result = make_big_integer (env, p);
  mpz_clear (p);
  return result;
@}

int
emacs_module_init (struct emacs_runtime *runtime)
@{
  emacs_env *env = runtime->get_environment (runtime);
  emacs_value symbol = env->intern (env, "next-prime");
  emacs_value func
    = env->make_function (env, 1, 1, next_prime, NULL, NULL);
  emacs_value args[] = @{symbol, func@};
  env->funcall (env, env->intern (env, "defalias"), 2, args);
  return 0;
@}
@end example

@deftypefn Function emacs_value make_float (emacs_env *@var{env}, double @var{d})
この関数は@code{double}の引数@var{d}を受け取り対応するEmacs浮動小数点値をリターンする。
@end deftypefn

@deftypefn Function emacs_value make_time (emacs_env *@var{env}, struct timespec @var{time})
このEmacs 27から利用可能になった関数は@code{struct
timespec}の引数@var{time}を受け取り、@code{(@var{ticks}
.
@var{hz})}というペアーとしてそれに対応するEmacsタイムスタンプをリターンする。リターン値は正確に@var{time}と同一のタイムスタンプを表す。つまりすべての入力値は表現可能であり、精度を失うことは決してない。@code{@var{time}.tv_sec}および@code{@var{time}.tv_nsec}は任意の値をとり得る。特に@var{time}が正規化されている必要はない。これは@code{@var{time}.tv_nsec}が負、あるいは999,999,999より大きくなり得ることを意味する。
@end deftypefn

@deftypefn Function emacs_value make_string (emacs_env *@var{env}, const char *@var{str}, ptrdiff_t @var{len})
この関数は@var{str}が指す、終端のnullバイトを含まないバイト長が@var{len}であるようなCテキスト文字列からEmacs文字列を作成する。@var{str}の元文字列は@acronym{ASCII}文字列かUTF-8にエンコードされた非@acronym{ASCII}文字列が可能であり、文字列には埋め込みのnullバイトを含むことができ、@code{@var{str}[@var{len}]}にあるnullバイトで終端される必要はない。@var{len}が負、またはEmacs文字列の最大長を超過する場合には、この関数はエラーコンディション@code{overflow-error}をraiseする。@var{len}が0なら@var{str}は@code{NULL}でもよいが、そうでなければ有効なメモリーを指していなければならない。非0の@var{len}では、@code{make_string}は一意でmutableな文字列オブジェクトをリターンする。
@end deftypefn

@deftypefn Function emacs_value make_unibyte_string (emacs_env *@var{env}, const char *@var{str}, ptrdiff_t @var{len})
この関数は@code{make_string}と似ているがC文字列のバイト値にたいする制限がなく、Emacsにユニバイト形式でバイナリーデータを渡すために使用できる。
@end deftypefn

この@acronym{API}はたとえば@code{cons}と@code{list}によるリスト作成(@ref{Building
Lists}を参照)、@code{car}と@code{cdr}によるリストメンバーの抽出(@ref{List
Elements}を参照)、@code{vector}によるベクター作成(@ref{Vector
Functions}を参照)等のようなLispデータ構造を操作する関数は提供しません。これらにたいしてはたいおう
するLisp関数を呼び出すために、次のサブセクションで説明する@code{intern}と@code{funcall}を使用します。

@code{emacs_value}オブジェクトのライフタイムはかなり短いのが普通です。このライフタイムはオブジェクトの作成に使用された@code{emacs_env}ポインターがスコープ外になると終了します。@code{emacs_value}が望む間は行き続けるような@dfn{グローバル参照(global
references)}を作成を要する場合もあるかもしれません。そのようなオブジェクトの管理には以下の2つの関数を使用します。

@deftypefn Function emacs_value make_global_ref (emacs_env *@var{env}, emacs_value @var{value})
この関数は@var{value}のグローバル参照をリターンする。
@end deftypefn

@deftypefn Function void free_global_ref (emacs_env *@var{env}, emacs_value @var{global_value})
この関数は以前に@code{make_global_ref}で作成した@var{global_value}を解放する。@var{global_value}はこの呼び出し後は無効になる。モジュールのコードでは@code{make_global_ref}と対応する@code{free_global_ref}の呼び出しそれぞれをペアーとすること。
@end deftypefn

@cindex user pointer, using in module functions
後でモジュール関数に渡す必要があるCデータ構造体を追跡するための代替え手段は@dfn{ユーザーポインター(user
pointer)}オブジェクトの作成です。ユーザーポインター(または@code{user-ptr}
)はCポインターをカプセル化したLispオブジェクトであり、関連付けられたファイナライザー(オブジェクトがガーベージコレクトされる際に呼び出される。@ref{Garbage
Collection}を参照)をもつことができます。モジュール@acronym{API}は@code{user-ptr}オブジェクトの作成やアクセスを行う関数を提供します。これらの関数は@code{user-ptr}オブジェクトを表現しない@code{emacs_value}で呼び出されるとエラーコンディション@code{wrong-type-argument}をraiseします。

@deftypefn Function emacs_value make_user_ptr (emacs_env *@var{env}, emacs_finalizer @var{fin}, void *@var{ptr})
この関数はCポインター@var{ptr}をラップした@code{user-ptr}オブジェクトを作成してリターンする。ファイナライザー関数@var{fin}は@code{NULL}
(ファイナライザーなし)、または以下のシグネチャをもつ関数のいずれか:

@example
typedef void (*emacs_finalizer) (void *@var{ptr});
@end example

@noindent
@var{fin}が@code{NULL}ポインターでなければ、@code{user-ptr}オブジェクトがガーベージコレクトされる際に@var{ptr}を引数として呼び出される。Emacsの応答性を維持するためにGCは短時間で終了しなければならないので、ファイナライザーでは高価なコードの実行は行ってはならない。
@end deftypefn

@deftypefn Function {void *}get_user_ptr (emacs_env *@var{env}, emacs_value @var{arg})
この関数は@var{arg}で表されるLispオブジェクトからCポインターを抽出する。
@end deftypefn

@deftypefn Function void set_user_ptr (emacs_env *@var{env}, emacs_value @var{arg}, void *@var{ptr})
この関数は@var{arg}で表される@code{user-ptr}オブジェクトに埋め込まれたCポインターに@var{ptr}をセットする。
@end deftypefn

@deftypefn Function emacs_finalizer get_user_finalizer (emacs_env *@var{env}, emacs_value @var{arg})
この関数は@var{arg}で表される@code{user-ptr}オブジェクトのファイナライザー、ファイナライザーがなければ@code{NULL}をリターンする。
@end deftypefn

@deftypefn Function void set_user_finalizer (emacs_env *@var{env}, emacs_value @var{arg}, emacs_finalizer @var{fin})
この関数は@var{arg}で表される@code{user-ptr}オブジェクトのファイナライザーを@var{fin}に変更する。@var{fin}が@code{NULL}なら@code{user-ptr}オブジェクトのファイナライザーはなくなる。
@end deftypefn

@code{emacs_finalizer}タイプはユーザーポインターと関数ファイナライザーの両方にたいして機能することに注意してください。@ref{Module
Function Finalizers}を参照してください。

@node Module Misc
@subsection その他の便利なモジュール用関数

  このサブセクションではモジュール@acronym{API}が提供する便利な関数をいくつか説明します。前のサブセクションで説明した関数と同じようにこれらの関数は実際には関数ポインターであり、@code{emacs_env}ポインターを介して呼び出す必要があります。Emacs
25以降に導入された関数の説明はそれらが利用可能になった最初のバージョンを付記します。

@deftypefn Function bool eq (emacs_env *@var{env}, emacs_value @var{a}, emacs_value @var{b})
この関数は@var{a}と@var{b}が表すLispオブジェクトが等しければ@code{true}、それ以外なら@code{false}をリターンする。これはLisp関数@code{eq}
(@ref{Equality Predicates}を参照)と同じだが、引数が表すオブジェクトのinternの要否を無視する。

等価性に関する他の述語は@acronym{API}関数には存在しないので、より複雑な等価性のテストを行うためには、以下で説明する@code{intern}と@code{funcall}を使う必要がある。
@end deftypefn

@deftypefn Function bool is_not_nil (emacs_env *@var{env}, emacs_value @var{arg})
このえ関数は@var{arg}で表されるLispオブジェクトをテストして非@code{nil}なら@code{true}、それ以外は@code{false}をリターンする。

等価性をテストするたに@code{intern}を使って@code{nil}を表す@code{emacs_value}を取得して、上述の@code{eq}を使用すれば自身で等価性テストを実装できることに注意。しかしこの関数を使用するほうが簡便だろう。
@end deftypefn

@deftypefn Function emacs_value type_of (emacs_env *@var{env}, emacs_value @code{arg})
この関数はシンボルを表す値(文字列は@code{string}、整数は@code{integer}、プロセスなら@code{process}等)として@var{arg}のタイプをリターンする。@ref{Type
Predicates}を参照のこと。オブジェクトのタイプにコードが依存する必要があれば、既知のタイプシンボルと比較するために@code{intern}と@code{eq}を使用できる。
@end deftypefn

@anchor{intern}
@deftypefn Function emacs_value intern (emacs_env *@var{env}, const char *name)
この関数は名前が@var{name}
(null終端された@acronym{ASCII}文字列であること)であるような、internされたEmacsシンボルをリターンする。すでに存在していなれば新たにシンボルを作成する。

この関数は以下で説明する@code{funcall}と共に用いることにより、Lispで呼び出し可能なEmcas関数(名前が純粋な@acronym{ASCII}文字列である場合にかぎる)純粋な@acronym{ASCII}文字列であるようなを呼び出す手段を提供する。たとえば以下はより協力なEmacsの@code{intern}関数(@ref{Creating
Symbols}を参照)を呼び出すことにより、名前@code{name_str}が非@acronym{ASCII}であるようなシンボルをinternする方法:

@example
emacs_value fintern = env->intern (env, "intern");
emacs_value sym_name =
  env->make_string (env, name_str, strlen (name_str));
emacs_value symbol = env->funcall (env, fintern, 1, &sym_name);
@end example

@end deftypefn

@deftypefn Function emacs_value funcall (emacs_env *@var{env}, emacs_value @var{func}, ptrdiff_t @var{nargs}, emacs_value *@var{args})
この関数は@var{args}が指す配列の@var{nargs}個の引数を渡して@var{func}の指定先を呼び出す。引数@var{func}は(上述の@code{intern}がリターンした)関数シンボル、@code{make_function}がリターンしたモジュール関数(@ref{Module
Functions}を参照)、Cで記述されたサブルーチン等。@var{nargs}が0なら@var{args}は@code{NULL}ポインターでもよい。

この関数は@var{func}がリターンした値をリターンする。
@end deftypefn

モジュールに長時間実行される可能性のあるコードが含まれる場合には、たとえば@kbd{C-g}をタイプする(@ref{Quitting}を参照)等によりユーザーがquitを望むかどうかをコード内でときどきチェックするのはよいアイデアです。Emacs
26.1から利用可能になった以下の関数は、この目的のために提供されました。

@anchor{should_quit}
@deftypefn Function bool should_quit (emacs_env *@var{env})
この関数はユーザーがquitを望むようなら@code{true}をリターンする。この場合にはモジュール関数は実行中の処理をabortして可能なかぎり速やかにリターンすることを推奨する。ほとんどの場合は@code{process_input}を使用すること。
@end deftypefn

ユーザーがquitを望むかどうかをチェックすることに加えて入力イベントを処理するには、Emacs
27.1以降で利用可能になった以下の関数を使用してください。

@anchor{process_input}
@deftypefn Function {enum emacs_process_input_result} process_input (emacs_env *@var{env})
この関数は保留中の入力イベントを処理する。ユーザーがquitを望んでいたり、シグナル処理中にエラーが発生したら@code{emacs_process_input_quit}をリターンする。この場合にはモジュール関数は行っているすべての処理をabortして可能なかぎり即座にリターンすることを推奨する。モジュールコードが実行を継続できるなら、@code{process_input}は@code{emacs_process_input_continue}をリターンする。@code{env}内に保留中の非ローカルexitが存在しない場合のみ、リターン値は@code{emacs_process_input_continue}。@code{process_input}呼び出し後にモジュールが継続する場合には、変数値やバッファーコンテンツのとうなグローバル状態は任意の手段で変更され得る。
@end deftypefn

@anchor{open_channel}
@deftypefun int open_channel (emacs_env *@var{env}, emacs_value @var{pipe_process})
このEmacs
28以降で利用可能になった関数は、既存のpipeプロセスへのチャンネルをオープンする。@var{pipe_process}は@code{make-pipe-process}が作成した既存のpipeプロセスを参照しなければならない。@ref{Pipe
Processes}を参照のこと。成功すると、そのpipeへの書き込みに使用できる新たなファイルデスクリプターを値としてリターンする。他のすべてのモジュール関数と異なり、アクティブなモジュール環境がなくても、任意のスレッドがリターンしたファイルデスクリプターを使用できる。このファイルデスクリプターへの書き込みには@code{write}関数を使用できる。使用後には@code{close}を使用してファイルデスクリプターをクローズする。@ref{Low-Level
I/O,,,libc}を参照のこと。
@end deftypefun

@node Module Nonlocal
@subsection モジュールでの非ローカル脱出
@cindex nonlocal exits, in modules

  Emacs Lispは非ローカル脱出(nonlocal
exits)をサポートしており、これによりプログラムの制御はプログラムのあるポイントから別の離れたポイントに転送されます。@ref{Nonlocal
Exits}を参照してください。したがってモジュールから呼び出されたLisp関数は@code{signal}や@code{throw}を呼び出して非ローカルにexitするかもしれず、そのような非ローカル脱出をモジュール関数は正しくハンドルしなければなりません。このようなハンドリングはCプログラムがリソースを自動的に解放せず、このような場合には別のクリーンアップを行うために必要になります。モジュールコードは自身でこれを行わなければなりません。そのための機能をモジュール@acronym{API}は提供しており、このサブセクションではそれを説明します。これらは一般的にはEmacs
25以降で利用可能です。これ以降のリリースで利用可能になったものについては、@acronym{API}に含まれるようになった最初のEmacsのバージョンを付記します。

モジュール関数から呼び出されたLispコードがエラーをシグナルしたりthrowを行う際には、非ローカル脱出はtrapされて保留中のexitと関連するデータは環境内に格納されます。環境内で非ローカル脱出が保留中の際には、環境へのポインターで呼び出されたすべてのモジュール@acronym{API}関数は何も処理を行わずに即座にリターンします(関数@code{non_local_exit_check}、@code{non_local_exit_get}、@code{non_local_exit_clear}はこのルールの例外)。モジュール関数が何も行わずにEmacsにリターンすれば、保留中の非ローカル脱出にたいしてEmacsがエラーをシグナルしたり、対応する@code{catch}へのthrowという対処を行うでしょう。

したがって特別なことな何も行わずに、何事もなかったかのようにコードの残りを実行するのが、モジュール関数での非ローカル脱出にけるもっともシンプルな``ハンドリング''です。しかしこれは2つのクラスの問題を引き起こすかもしれません:

@itemize @minus
@item
期待する値を生成することなく@acronym{API}関数は即座にリターンするので、初期化や定義が行われていない値をモジュール関数が使用するかもしれない。

@item
リソースを解放する機会がないかもしれないのでモジュールがリソースをリークするかもしれない。
@end itemize

したがってモジュール関数は以下に説明する関数を使用して、非ローカル脱出のコンディションのチェックとリカバリングを行うことを推奨します。

@deftypefn Function {enum emacs_funcall_exit} non_local_exit_check (emacs_env *@var{env})
この関数は@var{env}に格納された非ローカル脱出のコンディションをリターンする。可能な値は:

@vindex emacs_funcall_exit@r{, enumeration}
@vtable @code
@item emacs_funcall_exit_return
最後の@acronym{API}関数は正常にexitした。
@item emacs_funcall_exit_signal
最後の@acronym{API}関数はエラーをシグナルした。
@item emacs_funcall_exit_throw
最後の@acronym{API}関数は@code{throw}を通じてexitした。
@end vtable
@end deftypefn

@deftypefn Function {enum emacs_funcall_exit} non_local_exit_get (emacs_env *@var{env}, emacs_value *@var{symbol}, emacs_value *@var{data})
この関数は@code{non_local_exit_check}が行うように@var{env}に格納された非ローカル脱出の種別をリターンするが、もしあれば非ローカル脱出に関する完全な情報もリターンする。リターン値が@code{emacs_funcall_exit_signal}なら関数は@code{*@var{symbol}}にエラーシンボル、@code{*@var{data}}にエラーデータを格納する(@ref{Signaling
Errors}を参照)。リターン値が@code{emacs_funcall_exit_throw}なら関数は@code{*@var{symbol}}に@code{catch}されたたタグシンボル、@code{*@var{data}}に@code{throw}された値を格納する。リターン値が@code{emacs_funcall_exit_return}なら関数はこれらの引数が指すメンモリー内に何も格納しない。
@end deftypefn

何らかのリソースの割り当て前や解放を要するリソースの割り当て後、あるいは失敗がそれ以上の処理が不可能もしくは実行不能を意味するような場合のように、非ローカル脱出が問題になるようならチェックするべきです。

モジュール関数が保留中の非ローカル脱出を一度検知すれば、(必要なローカルクリーンアップの実施後に)Emacsにリターンしたり、非ローカル脱出からのリカバリーを試みることができます。以下の@acronym{API}関数はこれらのタスクの助けとなるでしょう。

@deftypefn Function void non_local_exit_clear (emacs_env *@var{env})
この関数は保留中の非ローカル脱出のコンディションと@var{env}由来のデータをクリアーする。これの呼び出し後にはモジュール@acronym{API}関数は通常どおり機能するだろう。モジュール関数が呼び出したLisp関数の非ローカル脱出からリカバーして継続可能な場合、あるいは以下の2つの関数のいずれか(非ローカル脱出が保留中の際に他の@acronym{API}関数に意図した動作を行わせたい場合にはそれらの@acronym{API}関数も)を呼び出す前にもこの関数を使用すること
@end deftypefn

@deftypefn Function void non_local_exit_throw (emacs_env *@var{env}, emacs_value @var{tag}, emacs_value @var{value})
この関数は@var{tag}で表されるLispの@code{catch}シンボルにリターン値として@var{value}を渡してthrowを行う。モジュール関数は一般的にはこの関数の呼び出し後は即座にリターンすること。この関数は呼び出された@acronym{API}関数やLisp関数のいずれかから非ローカル脱出を再throwしたい際の1つの手段である。
@end deftypefn

@deftypefn Function void non_local_exit_signal (emacs_env *@var{env}, emacs_value @var{symbol}, emacs_value @var{data})
この関数はエラーシンボル@var{symbol}で表されるエラーを、指定したエラーデータ@var{data}とともにシグナルする。モジュール関数はこの関数の呼び出し後は即座にリターンすること。この関数はたとえばモジュール関数からEmacsにエラーをシグナルする際に有用かもしれない。
@end deftypefn


@node Object Internals
@section オブジェクトの内部
@cindex object internals

  Emacs
Lispは豊富なデータタイプのセットを提供します。コンスセル、整数、文字列のようにこれらのいくつかは、ほとんどすべてのLisp方言で一般的です。マーカやバッファーのようなそれ以外のものはLisp内でエディターコマンドを記述するための基本的サポートを提供するために極めて特別かつ必要なものです。そのような種々のオブジェクトタイプを実装してインタープリターのサブシステムとの間でオブジェクトを渡す効果的な方法を提供するために、Cデータ構造体セットとそれらすべてにたいするポインターを表す@dfn{タグ付きポインター(tagged
pointer)}と呼ばれる特別なタイプが存在します。

  Cではタグ付きポインターはタイプ@code{Lisp_Object}のオブジェクトです。そのようなタイプの初期化された変数は基本的なデータタイプである整数、シンボル、文字列、コンスセル、浮動小数点数、ベクター類似オブジェクトのいずれかを値として常に保持します。これらのデータタイプのそれぞれは対応するタグ値をもちます。すべてのタグは@code{enum
Lisp_Type}により列挙されており、@code{Lisp_Object}の3ビットのビットフィールドに配置されます。残りのビットはそれ自身の値です。整数は即値(@dfn{値ビット}で直接表される)、他のすべてのオブジェクトはヒープに割り当てられた対応するオブジェクトへのCポインターで表されます。@code{Lisp_Object}のサイズはプラットフォームと設定に依存します。これは通常は背景プラットフォームのポインターと同一(32ビットマシンなら32ビット、64ビットマシンなら64ビット)ですが@code{Lisp_Object}が64ビットでも、すべてのポインターが32ビットのような特別な構成もあります。後者は@code{Lisp_Object}にたいして64ビットの@code{long
long}タイプを使用することにより、32ビットシステム上のLisp整数にたいする値範囲の制限を乗り越えるためにデザインされたトリックです。

  以下のCデータ構造体は整数ではない基本的なデータタイプを表すために@file{lisp.h}で定義されています:

@table @code
@item struct Lisp_Cons
コンスセル。リストを構築するために使用されるオブジェクト。

@item struct Lisp_String
文字列。文字シーケンスを表す基本的オブジェクト。

@item struct Lisp_Vector
配列。インデックスによりアクセスできる固定サイズのLispオブジェクトのセット。

@item struct Lisp_Symbol
シンボル。一般的に識別子として使用される一意な名前のエンティティ。

@item struct Lisp_Float
Floating-point value.
@end table

  これらのタイプは内部的タイプシステムのファーストクラスの市民です。タグスペースは限られているので他のすべてのタイプは@code{Lisp_Vectorlike}のサブクラスです。サブタイプのベクターは@code{enum
pvec_type}により列挙されておりウィンドウ、バッファー、フレーム、プロセスのようなほとんどすべての複雑なオブジェクトはこのカテゴリーに分類されます。

  @code{Lisp_Vectorlike}のいくつかのサブタイプを説明します。バッファーオブジェクトは表示や編集を行うテキストを表します。ウィンドウはバッファーを表示したり、同一フレーム上で再帰的に他のウィンドウを配置するためのコンテナーとして使用される表示構造の一部です(Emacs
Lispのウィンドウオブジェクトと、のようなユーザーインターフェースシステムに管理されるエンティティとしてのウィンドウを混同しないこと。Emacsの用語では後者はフレームと呼ばれる)。最後にプロセスオブジェクトはサブプロセスの管理に使用されます。

@menu
* Buffer Internals::         バッファー構造体の構成子。
* Window Internals::         ウィンドウ構造体の構成子。
* Process Internals::        プロセス構造体の構成子。
@end menu

@node Buffer Internals
@subsection バッファーの内部
@cindex internals, of buffer
@cindex buffer internals

  Cでバッファーを表すために2つの構造体(@file{buffer.h}を参照)が使用されます。@code{buffer_text}構造体にはバッファーのテキストを記述するフィールドが含まれます。@code{buffer}構造体は他のフィールドを保持します。インダイレクトバッファーの場合には、2つ以上の@code{buffer}構造体が同じ@code{buffer_text}構造体を参照します。

以下に@code{struct buffer_text}内のフィールドをいくつか示します:

@table @code
@item beg
バッファーコンテンツのアドレス。バッファーコンテンツは途中にギャップをもつ@code{char}の線形C配列。

@item gpt
@itemx gpt_byte
バッファーのギャップの文字位置とバイト位置。@ref{Buffer Gap}を参照のこと。

@item z
@itemx z_byte
バッファーテキストの終端の文字位置とバイト位置。

@item gap_size
バッファーのギャップのサイズ。@ref{Buffer Gap}を参照のこと。

@item modiff
@itemx save_modiff
@itemx chars_modiff
@itemx overlay_modiff
これらのフィールドは、そのバッファーで行われたバッファー変更イベントの数をカウントする。@code{modiff}はバッファー変更イベントのたびに増分されて、それ以外では決して変化しない。@code{save_modiff}にはバッファーが最後にvisitや保存されたときの@code{modiff}の値が含まれる。@code{chars_modiff}はバッファー内の文字にたいする変更だけをカウントして、(テキストプロパティのように)その他すべての種類の変更を無視する。@code{overlay_modiff}はバッファーのオーバーレイにたいする変更だけをカウントする。

@item beg_unchanged
@itemx end_unchanged
最後の再表示完了以降に未変更だと解っているテキスト、開始と終了の箇所での文字数。

@item unchanged_modified
@itemx overlay_unchanged_modified
それぞれ最後に再表示が完了した後の@code{modiff}と@code{overlay_modiff}の値。これらのカレント値が@code{modiff}や@code{overlay_modiff}とマッチしたら、それは@code{beg_unchanged}と@code{end_unchanged}に有用な情報が含まれないことを意味する。

@item markers
このバッファーを参照するマーカー。これは実際には単一のマーカーであり、自身のマーカー@dfn{チェーン}
(リンクリスト)内の一連の要素がバッファー内のテキストを参照する他のマーカーになる。

@item intervals
そのバッファーのテキストプロパティを記録するインターバルツリー。
@end table

@code{struct buffer}のいくつかのフィールドを以下に示します:

@table @code
@item header
タイプ@code{union vectorlike_header}のヘッダーは、すべてのベクター類似のオブジェクトに共通。

@item own_text
構造体@code{struct
buffer_text}は通常はバッファーのコンテンツを保持する。このフィールドはインダイレクトバッファーでは使用されない。

@item text
そのバッファーの@code{buffer_text}構造体へのポインター。通常のバッファーでは上述の@code{own_text}フィールド。インダイレクトバッファーではベースバッファーの@code{own_text}フィールド。

@item next
killされたバッファーを含むすべてのバッファーのチェーン内において次のバッファーへのポインター。このチェーンはkillされたバッファーを正しく回収するために割り当てとガーベージコレクションのためだけに使用される。

@item pt
@itemx pt_byte
バッファー内のポイントの文字位置とバイト位置。

@item begv
@itemx begv_byte
そのバッファー内のアクセス可能範囲の先頭位置の文字位置とバイト位置。

@item zv
@itemx zv_byte
そのバッファー内のアクセス可能範囲の終端位置の文字位置とバイト位置。

@item base_buffer
インダイレクトバッファーではベースバッファーのポイント。通常のバッファーではnull。

@item local_flags
このフィールドはバッファー内でローカルな変数にたいしてそれを示すフラグを含む。そのような変数はCコードでは@code{DEFVAR_PER_BUFFER}を使用して宣言され、それらのバッファーローカルなバインディングはバッファー構造体自身内のフィールドに格納される(これらのフィールドのいくつかはこのテーブル内で説明している)。

@item modtime
visitされているファイルの変更時刻。これはファイルの書き込みと読み込み時にセットされる。そのバッファーをファイルに書き込む前にファイルがディスク上で変更されていないことを確認するために、このフィールドとそのファイルの変更時刻を比較する。@ref{Buffer
Modification}を参照のこと。

@item auto_save_modified
そのバッファーが最後に自動保存されたときの時刻。

@item last_window_start
そのバッファーが最後にウィンドウに表示されたときのバッファー内での@code{window-start}位置。

@item clip_changed
このフラグはバッファーでのナローイングが変更されているかを示す。@ref{Narrowing}を参照のこと。

@item prevent_redisplay_optimizations_p
このフラグはバッファーの表示において再表示最適化が使用されるべきではないことを示す。

@item inhibit_buffer_hooks
このフラグはそのバッファーではフック@code{kill-buffer-hook}、@code{kill-buffer-query-functions}
(@ref{Killing Buffers}を参照)、@code{buffer-list-update-hook} (@ref{Buffer
List}を参照)が実行されないことを示す。このフラグはバッファー作成時にセットされて(@ref{Creating
Buffers}を参照)、内部バッファーや@code{with-temp-buffer} (@ref{Definition of
with-temp-buffer,, Current Buffer})が作成するバッファーの速度低下を防ぐ。

@item name
バッファーを命名するLisp文字列。一意であることが保証されている。@ref{Buffer
Names}を参照のこと。このフィールドと以降のフィールドは以下のように@code{BVAR}を介するアクセス以外の方法で直接アクセスするべきではないことを示すためにC構造体定義内の名前の最後に@code{_}をもつ:

@example
  Lisp_Object buf_name = BVAR (buffer, name);
@end example

@item save_length
そのバッファーがvisitしているファイルを最後に読み込み、または保存したときの長さ。2つの特別な値をもつことができる。@minus{}1はそのバッファーで自動保存がオフであること、@minus{}2はバッファーのテキストが大量に減少するようなら自動保存をオフに切り替えないことを意味する。インダイレクトバッファーは決して保存されることはないので、保存に関して、このフィールドとその他のフィールドは@code{buffer_text}構造体で維持されない

@item directory
相対ファイル名を展開するディレクトリー。これはバッファーローカル変数@code{default-directory}の値(@ref{File Name
Expansion}を参照)。

@item filename
そのバッファーがvisitしているファイルの名前。これはバッファーローカル変数@code{buffer-file-name}の値(@ref{Buffer
File Name}を参照)。

@item undo_list
@itemx backed_up
@itemx auto_save_file_name
@itemx auto_save_file_format
@itemx read_only
@itemx file_format
@itemx file_truename
@itemx invisibility_spec
@itemx display_count
@itemx display_time
これらのフィールドは自動的にバッファーローカル(@ref{Buffer-Local
Variables}を参照)になるLisp変数の値を格納する。これらに対応する変数は名前に追加のプレフィクス@code{buffer-}がつき、アンダースコアがダッシュで置換される。たとえば@code{undo_list}は@code{buffer-undo-list}の値を格納する。

@item mark
そのバッファーにたいするマーク。マークはマーカーなのでリスト@code{markers}内にも含まれる。@ref{The Mark}を参照のこと。

@item local_var_alist
この連想リストはバッファーのバッファーローカル変数のバインディングを記述する。これにはバッファーオブジェクト内に特別なスロットをもつ、ビルトインのバッファーローカルなバインディングは含まれない(このテーブルではそれらのスロットは省略している)。@ref{Buffer-Local
Variables}を参照のこと。

@item major_mode
そのバッファーのメジャーモードを命名するシンボル(例: @code{lisp-mode})。

@item mode_name
そのメジャーモードの愛称(例: @code{"Lisp"})。

@item keymap
@itemx abbrev_table
@itemx syntax_table
@itemx category_table
@itemx display_table
これらのフィールドはバッファーのローカルキーマップ(@ref{Keymaps}を参照)、abbrevテーブル(@ref{Abbrev
Tables}を参照)、構文テーブル(@ref{Syntax
Tables}を参照)、カテゴリーテーブル(@ref{Categories}を参照)、ディスプレイテーブル(@ref{Display
Tables}を参照)を格納する。

@item downcase_table
@itemx upcase_table
@itemx case_canon_table
これらのフィールドはテキストを小文字、大文字、およびcase-fold検索でのテキストの正規化の変換テーブルを格納する。@ref{Case
Tables}を参照のこと。

@item minor_modes
そのバッファーのマイナーモードのalist。

@item pt_marker
@itemx begv_marker
@itemx zv_marker
これらのフィールドはインダイレクトバッファー、またはインダイレクトバッファーのベースバッファーであるようなバッファーでのみ使用される。これらはそれぞれバッファーがカレントでないときにバッファーにたいする@code{pt}、@code{begv}、@code{zv}を記録するマーカーを保持する。

@item mode_line_format
@itemx header_line_format
@itemx tab_width
@itemx fill_column
@itemx left_margin
@itemx auto_fill_function
@itemx truncate_lines
@itemx word_wrap
@itemx ctl_arrow
@itemx bidi_display_reordering
@itemx bidi_paragraph_direction
@itemx selective_display
@itemx selective_display_ellipses
@itemx overwrite_mode
@itemx abbrev_mode
@itemx mark_active
@itemx enable_multibyte_characters
@itemx buffer_file_coding_system
@itemx cache_long_line_scans
@itemx point_before_scroll
@itemx left_fringe_width
@itemx right_fringe_width
@itemx fringes_outside_margins
@itemx scroll_bar_width
@itemx indicate_empty_lines
@itemx indicate_buffer_boundaries
@itemx fringe_indicator_alist
@itemx fringe_cursor_alist
@itemx scroll_up_aggressively
@itemx scroll_down_aggressively
@itemx cursor_type
@itemx cursor_in_non_selected_windows
これらのフィールドは自動的にバッファーローカル(@ref{Buffer-Local
Variables}を参照)になるLisp変数の値を格納する。これらに対応する変数は名前のアンダースコアがダッシュで置換される。たとえば@code{mode_line_format}は@code{mode-line-format}の値を格納する。

@item overlays
そのバッファーのオーバーレイを含んだインターバルツリー(interval tree： 区間木)。

@item last_selected_window
これは最後に選択されていたときにそのバッファーを表示していたウィンドウ、またはそのウィンドウがすでにそのバッファーを表示していなければ@code{nil}。
@end table

@node Window Internals
@subsection ウィンドウの内部
@cindex internals, of window
@cindex window internals

  ウィンドウのフィールドには以下が含まれます(完全なリストは@file{window.h}の@code{struct window}を参照):

@table @code
@item frame
そのウィンドウがあるフレーム(Lispオブジェクト)。

@item mini
そのウィンドウがミニバッファーウィンドウ、ミニバッファーかエコーエリアを表示しているウィンドウなら非0。

@item pseudo_window_p
@cindex pseudo window
そのウィンドウが@dfn{疑似ウィンドウ(pseudo
window)}なら非0。疑似ウィンドウとはメニューバーかツールバーの表示に使用されているウィンドウ(自身のメニューバーやツールバーを表示しないツールキットをEmacsが使用している場合)、タブバー、またはツールチップフレーム上でツールチップを表示しているウィンドウのいずれか。一般的には疑似ウィンドウはLispコードからアクセスできない。

@item parent
Emacsは内部的にウィンドウをツリーにアレンジする。ウィンドウの兄弟グループは、そのエリアがすべての兄弟を含むような親ウィンドウをもつ。このフィールドはツリー内でのウィンドウの親をLispオブジェクトとして指す。これはツリーのルートウィンドウとミニバッファーウィンドウでは常に@code{nil}。

親ウィンドウはバッファーを表示せず、子ウィンドウ形成を除いて表示では少ししか役割を果たさない。Emacs
Lispプログラムは親ウィンドウを直接操作できない。Emacs
Lispプログラムでは実際にバッファーを表示するツリーの子ノードのウィンドウにたいして操作を行う。

@item contents
リーフウィンドウ(leaf
window)およびツールチップを表示中のウィンドウでは、そのウィンドウが表示しているLispオブジェクトとしてのバッファー、内部ウィンドウ(``親''ウィンドウ)では最初の子ウィンドウ、メニューバーやツールバーを表示している疑似ウィンドウでは@code{nil}、削除されたウィンドウでも@code{nil}。

@item next
@itemx prev
そのウィンドウの次の兄弟と前の兄弟(Lispオブジェクト)。自身のグループ内でそのウィンドウが右端か下端なら@code{next}は@code{nil}。自身のグループ内でそのウィンドウが左端か上端なら@code{prev}は@code{nil}。兄弟が左右あるいは上下であるかは兄弟の親の@code{horizontal}フィールドで判断される。これが非0なら兄弟は水平に配置されている。

特別なケースとしてミニバッファーのみのフレームやミニバッファーなしのフレームでなければ、フレームのルートウィンドウの@code{next}は、そのフレームのミニバッファーウィンドウを指す。そのようなフレームのミニバッファーウィンドウの@code{prev}は、そのフレームのルートウィンドウを指す。それ以外の場合にはルートウィンドウの@code{next}フィールド、および(もしあれば)ミニバッファーの@code{prev}フィールドは@code{nil}。

@item left_col
そのウィンドウの左端をウィンドウのネイティブフレームの最左列(列0)から相対的に数えた列数。

@item top_line
そのウィンドウの上端をウィンドウのネイティブフレームの最上行(行0)から相対的に数えた行数。

@item pixel_left
@itemx pixel_top
そのウィンドウの左側上端をウィンドウのネイティブフレームの左上隅(0, 0)から相対的に計測したピクセル数。

@item total_cols
@itemx total_lines
列数または行数で数えた、そのウィンドウの幅または高さの合計。値にはスクロールバーとフリンジ、ディバイダー、および/または(もしあれば)ウィンドウ右側のセパレーターラインが含まれる。

@item pixel_width;
@itemx pixel_height;
ピクセルで計測したウィンドウの幅または高さの合計。

@item start
そのウィンドウ内に表示されるバッファーで、ウィンドウに最初(ロジカル順。@ref{Bidirectional
Display}を参照)に表示される文字の位置を指すマーカー。

@item pointm
@cindex window point internals
これはウィンドウが選択されているときのカレントバッファーのポイント値。選択されていなければ前の値が保たれる。

@item old_pointm
最後の再表示時の@code{pointm}の値。

@item force_start
このフラグが非@code{nil}ならLispプログラムによりそのウィンドウが明示的にスクロールされたことを示し、再表示のためにウィンドウの@code{start}の値がセットされる。これはポイントがスクリーン外の場合の次回再表示に影響を与える。影響とはポイント周辺のテキストを表示するためにウィンドウをスクロールするかわりに、スクリーン上にある位置にポイントを移動するというものである。

@item optional_new_start
これは@code{force_start}と同様だが、次回表示ではポイントが可視の場合のみしたがう。

@item start_at_line_beg
非@code{nil}は@code{start}のカレント値がウィンドウ選択時に先頭行だったことを意味する。

@item use_time
これはウィンドウが最後に選択された時刻。関数@code{get-lru-window}はこの値を使用する。

@item sequence_number
そのウィンドウ作成時に割り当てられた一意な番号。

@item last_modified
前回のそのウィンドウの再表示完了時のウィンドウのバッファーの@code{modiff}フィールド。

@item last_overlay_modified
前回のウィンドウの再表示完了時のウィンドウのバッファーの@code{overlay_modiff}フィールド。

@item last_point
前回のウィンドウの再表示完了時のウィンドウのバッファーのポイント値。

@item last_had_star
非0値はウィンドウが最後に更新されたとき、そのウィンドウのバッファーが変更されたことを意味する。

@item vertical_scroll_bar_type
@itemx horizontal_scroll_bar_type
そのウィンドウの垂直スクロールバーおよび水平スクロールバーのタイプ。

@item scroll_bar_width
@itemx scroll_bar_height
そのウィンドウの垂直スクロールバーの幅および水平スクロールバーの高さ(ピクセル単位)。

@item left_margin_cols
@itemx right_margin_cols
そのウィンドウの左マージンと右マージンの幅。値0はマージンがないことを意味する。

@item left_fringe_width
@itemx right_fringe_width
そのウィンドウの左フリンジと右フリンジのピクセル幅。値@minus{}1はフレームの値の使用を意味する。

@item fringes_outside_margins
非0値はディスプレイマージン外側のフリンジ、それ以外ならフリンジはマージンとテキストの間にあることを意味する。

@item window_end_pos
これは@code{z}から、そのウィンドウのカレントマトリクス内の最後のグリフのバッファー位置を減じて算出される。この値は@code{window_end_valid}が非0のときだけ有効である。

@item window_end_bytepos
@code{window_end_pos}に対応するバイト位置。

@item window_end_vpos
@code{window_end_pos}を含む行のウィンドウに相対的な垂直位置。

@item window_end_valid
このフィールドは@code{window_end_pos}および@code{window_end_vpos}が真に有効なら非0値にセットされる。これは重要な再表示が先に割り込んだ場合には、@code{window_end_pos}を算出した表示がスクリーン上に出現しなくなるので0になる。

@item cursor
そのウィンドウ内でカーソルがどこにあるかを記述する構造体。

@item last_cursor_vpos
最後の再表示完了時にカーソルを表示していた行の、ウィンドウに相対的な垂直位置。

@item phys_cursor
そのウィンドウのカーソルが物理的にどこにあるかを記述する構造体。

@item phys_cursor_type
@c FIXME What is this?
@c itemx phys_cursor_ascent
@itemx phys_cursor_height
@itemx phys_cursor_width
そのウィンドウの最後の表示でのカーソルのタイプ、高さ、幅。

@item phys_cursor_on_p
このフィールドはカーソルが物理的にオンなら非0。

@item cursor_off_p
非0はそのウィンドウのカーソルが論理的にオフであることを意味する。これはカーソルの点滅に使用される。

@item last_cursor_off_p
このフィールドは最後の再表示時の@code{cursor_off_p}の値を含む。

@item must_be_updated_p
これはウィンドウを更新しなければならないとき、再表示の間は1にセットされる。

@item hscroll
これはウィンドウ内の表示が左へ水平スクロールされている列数。通常は0。カレント行だけが水平スクロールされている際には、カレント行がどれだけ左へ水平スクロールされているかを示す。

@item min_hscroll
@code{set-window-hscroll}を通じてユーザーがセットする@code{hscroll}の最小値(@ref{Horizontal
Scrolling}を参照)。カレント行だけが水平スクロールされている際には、カレント行以外の行がどれだけ左へ水平スクロールされているかを示す。

@item vscroll
ピクセル単位での垂直スクロール量。これは通常は0。

@item dedicated
そのウィンドウがそれのバッファー専用(dedicated)なら非@code{nil}。

@item combination_limit
このウィンドウの組み合わせ限界は親ウィンドウにとってのみ意味がある。これが@code{t}ならそのウィンドウの削除は許されず、そのウィンドウの他の兄弟と子ウィンドウを再組み合わせする。

@item window_parameters
そのウィンドウのパラメーターのalist。

@item display_table
そのウィンドウのディスプレイテーブル、何も指定されていなければ@code{nil}。

@item update_mode_line
非0はウィンドウのモードラインの更新が必要なことを意味する。

@item mode_line_height
@itemx header_line_height
モードラインおよびヘッダーラインのピクセル高さ、不明なら@minus{}1。

@item base_line_number
そのバッファーの特定の位置の行番号か0。これはモードラインでポイントの行番号を表示するために使用される。

@item base_line_pos
行番号が既知であるバッファー位置、不明なら0。これが@minus{}1なら、そのウィンドウがバッファーを表示するかぎり行番号は表示されない。

@item column_number_displayed
そのウィンドウのモードラインに表示されているカレント列番号、列番号が表示されていなければ@minus{}1。

@item current_matrix
@itemx desired_matrix
そのウィンドウのカレント、および望まれる表示を記述するグリフ。
@end table

@node Process Internals
@subsection プロセスの内部
@cindex internals, of process
@cindex process internals

  プロセスのフィールドには以下が含まれます(完全なリストは@file{process.h}の@code{struct
Lisp_Process}の定義を参照):

@table @code
@item name
プロセス名(Lisp文字列)。

@item command
そのプロセスの開始に使用されたコマンド引数を含むリスト。ネットワークプロセスとシリアルプロセスではプロセスが実行中なら@code{nil}、停止していたら@code{t}。

@item filter
そのプロセスから出力を受け取るために使用されるLisp関数。

@item sentinel
そのプロセスの状態が変化したら常に呼び出されるLisp関数。

@item buffer
そのプロセスに関連付けられたバッファー。

@item pid
オペレーティングシステムのプロセス@acronym{ID} (整数)。ネットワークプロセスやシリアルプロセスのような疑似プロセスでは値0を使用する。

@item childp
フラグ。実際に子プロセスなら@code{t}。ネットワークプロセスやシリアルプロセスでは@code{make-network-process}や@code{make-serial-process}にもとづくplist。

@item mark
そのプロセスの出力からバッファーに挿入された終端位置を示すマーカー。常にではないがこれはバッファー終端であることが多い。

@item kill_without_query
これが非0ならプロセス実行中にEmacsをkillしてもプロセスのkillにたいして確認を求めない。

@item raw_status
システムコール@code{wait}がリターンするrawプロセス状態。

@item status
@code{process-status}がリターンするようなプロセス状態。Lispシンボル、コンスセル、またはリストのいずれか。

@item tick
@itemx update_tick
これら2つのフィールドが等しくないなら、センチネル実行かプロセスバッファーへのメッセージ挿入によりプロセスの状態変更が報告される必要がある。

@item pty_flag
そのサブプロセスがptyを使用して対話する場合は非0。パイプを使用する場合には0。

@item infd
そのプロセスからの入力にたいするファイルディクリプター。

@item outfd
そのプロセスへの出力にたいするファイルディクリプター。

@item tty_name
そのサブプロセスが使用する端末の名前、パイプを使用する場合には@code{nil}。

@item decode_coding_system
そのプロセスからの入力のデコーディングにたいするコーディングシステム。

@item decoding_buf
デコーディング用の作業バッファー。

@item decoding_carryover
デコーディングでのキャリーオーバーのサイズ。

@item encode_coding_system
そのプロセスからの出力のエンコーディングにたいするコーディングシステム。

@item encoding_buf
エンコーディング用の作業バッファー。

@item inherit_coding_system_flag
プロセス出力のデコードに使用されるコーディングシステムからプロセスバッファーの@code{coding-system}をセットするフラグ。

@item type
プロセスのタイプを示す@code{real}、@code{network}、@code{serial}のいずれかのシンボル。

@end table

@node C Integer Types
@section Cの整数型
@cindex integer types (C programming language)

以下はEmacsのCソースコード内で整数タイプを使用する際のガイドラインです。これらのガイドラインはときに相反するアドバイスを与えることがありますが一般的な常識に沿ったものがアドバイスです。

@itemize @bullet
@item
任意の制限の使用を避ける。たとえば@code{s}の長さを@code{int}の範囲に収めることが要求されるのでなければ@code{int len =
strlen (s);}を使用しないこと。

@item
符号付き整数の算術演算のオーバーフローのラップアラウンドを前提としてはならない。Emacsのポート対象先によっては成立しない。実際には符号付き整数のオーバーフローは未定義であり、コアダンプや早晩に非論理的な振る舞いさえ起こし得る。符号なし整数のオーバーフローは2のべき乗の剰余に確実にラップアラウンドされることが保証されている。

@item
符号なしタイプと符号付きタイプを組み合わせるとコードが混乱するので符号なしタイプより符号付きタイプを優先すること。他のガイドラインの多くはタイプが符号付きだとみなしている。符号なしタイプを要する稀なケースでは、符号付きの符号なし版(@code{ptrdiff_t}のかわりに@code{size_t}、@code{intptr_t}のかわりに@code{uintptr_t})にたいして同様のアドバイスを適用できる。

@item
0から0x3FFFFFまでの範囲ではEmacs文字コードには@code{int}を優先すること。より一般的には、たとえばスクリーン列数のように@code{int}範囲と既知である整数には@code{int}を優先すること。

@item
サイズ(たとえばすべての個別のCオブジェクトの最大サイズや、すべてのC配列の最大要素数にバインドされる整数)にたいしては@code{ptrdiff_t}を優先すること。これは符号付きタイプにたいするEmacsの一般的な優先事項である。@code{ptrdiff_t}の使用によりオブジェクトは@code{PTRDIFF_MAX}に制限されるが、より大きいオブジェクトはポインター減算を破壊するかもしれず結局のところ問題を起こす可能性があるので、これは一方的に制限を課すものではない。

@item
@code{ssize_t}関連の制限をもつ低レベルAPIト対話する際を除いて@code{ssize_t}を避けること。これは典型的なプラトフォームでは@code{ptrdiff_t}と等価だとしても、@code{ssize_t}は範囲が狭いときがあり使用によりサイズ関連の計算がオーバーフローするかもしれない。同じく@code{ptrdiff_t}はより一般的で標準化されており、標準的な@code{printf}フォーマットをもち、Emacsの内部的なサイズオーバーフローのチェックの基礎である。@code{ssize_t}を使用する際にはPOSIXガ@minus{}から@code{SSIZE_MAX}の範囲の値にたいするサポートだけを要求することに注意してほしい。

@item
通常はポインターの内部表現や与えられた任意のタイミングで存在可能なオブジェクト数や割り当て可能な総バイト数にのみバインドされる整数には@code{intptr_t}を優先すること。しかしページ境界を横切る可能性のあるポインター演算を表す場合には@code{uintptr_t}を優先すること。たとえば32ビットのアドレス空間をもつマシンでの配列は0x7fffffff/0x80000000境界を横断する可能性があり、@code{(intptr_t)
0x7fffffff}に1を加算することによって整数のオーバーフローが発生し得る。

@item
Emacs
Lispのfixnumへの変換や逆変換を表す値ではfixnum演算が@code{EMACS_INT}にもとづくのでEmacsで定義されたタイプ@code{EMACS_INT}を優先すること。

@item
(ファイルサイズやエポック以降の経過秒数等の)システム値を表す際には、(@code{off_t}や@code{time_t}等の)システムタイプを優先すること。安全だと解っていなければシステムタイプが符号付きだと仮定してはならない。たとえば@code{off_t}は常に符号付きだが@code{time_t}は符号付きである必要はない。

@item
符号付き整数かもしれない値を表す場合には@code{intmax_t}を優先すること。@code{printf}族の関数は@code{"%"PRIdMAX}のようなフォーマットを使用してこのような値をプリントできる。

@item
ブーリーンには@code{bool}、@code{false}、@code{true}を使用すること。@code{bool}の使用によりプログラムの可読性が増して、@code{int}を使用するより若干高速になる。@code{int}、@code{0}、@code{1}を使用しても大丈夫だが旧スタイルは段階的に廃止される。@code{bool}を使用する際には@code{bool}の代替実装の制限を尊重すること。特にブーリーンのビットフィールドは、@code{bool}ではなく@code{bool_bf}タイプであること。そうすれば標準のGCCでObjective
Cをコンパイルするときでさえ正しく機能する。

@item
ビットフィールドでは@code{int}は可搬性に劣るので、@code{int}より@code{unsigned int}か@code{signed
int}を優先すること。単一ビットのビットフィールドの値は0か1なので@code{unsigned
int}か@code{bool_bf}を使用すること。
@end itemize

@c FIXME Mention src/globals.h somewhere in this file?
