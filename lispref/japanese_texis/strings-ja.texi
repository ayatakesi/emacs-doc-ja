@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================

@c -*- mode: texinfo; coding: utf-8 -*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990--1995, 1998--1999, 2001--2024 Free Software
@c Foundation, Inc.
@c See the file elisp-ja.texi for copying conditions.
@node Strings and Characters
@chapter 文字列と文字
@cindex strings
@cindex character arrays
@cindex characters
@cindex bytes

  Emacs Lispの文字列は、文字列の順序列(ordered
sequence)を含む配列です。文字列はシンボル、バッファー、ファイルの名前に使用されます。その他にもユーザーにたいしてメッセージを送ったりバッファー間でコピーする文字列を保持したり等、多くの目的に使用されます。文字列は特に重要なので、Emacs
Lispは特別には文字列を操作するために多くの関数があります。Emacs Lispプログラムでは個々の文字より文字列を多用します。

  キーボードの文字イベントの文字列にたいする特別な考慮は、@ref{Strings of Events}を参照してください。

@menu
* Basics: String Basics.     文字列と文字の基本的なプロパティ。
* Predicates for Strings::   オブジェクトが文字列か文字かをテストする。
* Creating Strings::         新しい文字列を割り当てる関数。
* Modifying Strings::        既存の文字列の内容を変更する。
* Text Comparison::          文字または文字列を比較する。
* String Conversion::        文字から文字列への変換と逆変換。
* Formatting Strings::       @code{format}: @code{printf}のEmacs版。
* Custom Format Strings::    カスタマイズした@code{format}仕様によるフォーマット。
* Case Conversion::          大文字小文字の変換関数。
* Case Tables::              case変換のカスタマイズ。
@end menu

@node String Basics
@section 文字列と文字の基礎

  文字(character)とは、テキスト内の1つの文字を表すLispオブジェクトです。Emacs
Lispでは文字は単なる整数です。ある整数が文字か文字でないかを区別するのは、それが使用される方法だけです。Emacsでの文字表現についての詳細は@ref{Character
Codes}を参照してください。

  文字列(string)とは固定された文字シーケンスです。これは@dfn{配列(array)}と呼ばれるシーケンス型であり、配列長が固定で一度作成したら変更できないことを意味します(@ref{Sequences
Arrays Vectors}を参照)。Cとは異なり、Emacs Lispの文字列は文字コードを判断することにより@emph{終端されません}。(訳注:
文字列の終端用の文字コードはない、ということ。)

  文字列は配列であるということは同様にシーケンスでもあるので、@ref{Sequences Arrays
Vectors}にドキュメントされている一般的な配列関数やシーケンス関数で文字列を処理できます。たとえば関数@code{aref}を使用して文字列内の特定の文字にアクセスしたり変更することができます(@ref{Array
Functions}を参照)。

  Emacs文字列での非@acronym{ASCII}にたいすテキスト表現は2つ ---
ユニバイト(unibyte)とマルチバイト(multibyte)があります。ほとんどのLispプログラミングでは、これら2つの表現を気にする必要はありません。詳細は@ref{Text
Representations}を参照してください。

  キーシーケンスがユニバイト文字列で表されることがあります。ユニバイト文字列がキーシーケンスの場合、範囲128から255までの文字列要素は範囲128から255の文字コードではなく、メタ文字(これは非常に大きな整数である)を表します。文字列はハイパー(hyper)、スーパー(super)、アルト(alt)で修飾された文字を保持できません。文字列は@acronym{ASCII}コントロール文字を保持できますが、それは他のコントロール文字です。文字列は@acronym{ASCII}コントロール文字のcaseを区別できません。そのような文字をシーケンスに保存したい場合は、文字列ではなくベクターを使用しなければなりません。キーボード入力文字についての情報は@ref{Character
Type}を参照してください。

  文字列は正規表現を保持するために便利です。@code{string-match} (@ref{Regexp
Search}を参照)を使用して、文字列にたいして正規表現をマッチすることもできます。関数@code{match-string}
(@ref{Simple Match Data}を参照)と@code{replace-match} (@ref{Replacing
Match}を参照)は、文字列にたいして正規表現をマッチした後に、文字列を分解・変更するのに便利です。

  バッファーのように、文字列は文字列内の文字自身とその文字にたいするテキストプロパティを含みます。@ref{Text
Properties}を参照してください。文字列からバッファーや他の文字列にテキストをコピーする、すべてのLispプリミティブ(Lisp
primitives)はコピーされる文字のプロパティもコピーします。

  文字列の表示やバッファーにコピーする関数についての情報は@ref{Text}を参照してください。文字または文字列の構文についての情報は、@ref{Character
Type}と@ref{String
Type}を参照してください。異なるテキスト表現間で変換したり、文字コードのエンコードやデコードを行う関数については@ref{Non-ASCII
Characters}を参照してください。ディスプレイ上の文字列幅の計算に@code{length}を@emph{使用するべきではない}ことにも注意してください。かわりに@code{string-width}を使用してください(@ref{Size
of Displayed Text}を参照)。

@node Predicates for Strings
@section 文字列のための述語
@cindex predicates for strings
@cindex string predicates

一般的なシーケンスや配列にたいする述語についての情報は、@ref{Sequences Arrays
Vectors}と@ref{Arrays}を参照してください。

@defun stringp object
この関数は@var{object}が文字列なら@code{t}、それ以外は@code{nil}をリターンする。
@end defun

@defun string-or-null-p object
この関数は@var{object}が文字列か@code{nil}なら@code{t}、それ以外は@code{nil}をリターンする。
@end defun

@defun char-or-string-p object
この関数は@var{object}が文字列か文字(たとえば整数)なら@code{t}、それ以外は@code{nil}をリターンする。
@end defun

@node Creating Strings
@section 文字列の作成
@cindex creating strings
@cindex string creation

  以下の関数はスクラッチ、文字列同士、またはその一部から文字列を作成します(@code{string-replace}や@code{replace-regexp-in-string}のように他の文字列内容を変更して文字列を作成する関数については@ref{Search
and Replace}を参照)。

@defun make-string count character &optional multibyte
この関数は@var{character}を@var{count}回繰り返すことにより作成された文字列をリターンする。@var{count}が負ならエラーをシグナルする。

@example
(make-string 5 ?x)
     @result{} "xxxxx"
(make-string 0 ?x)
     @result{} ""
@end example

  @var{character}が@acronym{ASCII}文字なら、結果は通常はユニバイト文字列になる。しかしオプション引数@var{multibyte}が非@code{nil}なら、この関数はかわりにマルチバイト文字列を生成する。これは結果を後で非@acronym{ASCII}文字列と結合したり、結果の中のいくつかの文字を非@acronym{ASCII}文字で置換する必要がある際に有用。

  この関数に対応する他の関数には@code{make-vector} (@ref{Vectors}を参照)や@code{make-list}
(@ref{Building Lists}を参照)が含まれる。
@end defun

@defun string &rest characters
この関数は文字@var{characters}を含む文字列をリターンする。

@example
(string ?a ?b ?c)
     @result{} "abc"
@end example
@end defun

@defun substring string &optional start end
この関数は@var{string}から、インデックス@var{start}の文字(その文字を含む)と@var{end}の文字(その文字は含まない)の間の範囲の文字で構成される、新しい文字列をリターンする。文字列の最初の文字はインデックス0。引数が1つなら、この関数は単に@var{string}をコピーする。

@example
@group
(substring "abcdefg" 0 3)
     @result{} "abc"
@end group
@end example

@noindent
上記の例では@samp{a}のインデックスは0、@samp{b}のインデックスは1、@samp{c}のインデックスは2となる。インデックス3 ---
この文字列の4番目の文字 ---
は、コピーされる部分文字列の文字位置までをマークする。したがって文字列@code{"abcdefg"}から@samp{abc}がコピーされる。

負の数は文字列の最後から数えることを意味するので、@minus{}1は文字列の最後の文字のインデックスである。たとえば:

@example
@group
(substring "abcdefg" -3 -1)
     @result{} "ef"
@end group
@end example

@noindent
この例では@samp{e}のインデックスは@minus{}3、@samp{f}のインデックスは@minus{}2、@samp{g}のインデックスは@minus{}1。つまり@samp{e}と@samp{f}が含まれ、@samp{g}は含まれない。

@var{end}に@code{nil}を使用した場合、それは文字列の長さを意味する。したがって、

@example
@group
(substring "abcdefg" -3 nil)
     @result{} "efg"
@end group
@end example

引数@var{end}を省略した場合、それは@code{nil}を指定したのと同じである。@code{(substring @var{string}
0)}は@var{string}のすべてをコピーしてリターンする。

@example
@group
(substring "abcdefg" 0)
     @result{} "abcdefg"
@end group
@end example

@noindent
しかしこの目的のためには@code{copy-sequence}を推奨する(@ref{Sequence Functions}を参照)。

@var{string}からコピーされた文字がテキストプロパティをもつなら、そのプロパティは新しい文字列へもコピーされる。@ref{Text
Properties}を参照のこと。

@code{substring}の最初の引数にはベクターも指定できる。たとえば:

@example
(substring [a b (c) "d"] 1 3)
     @result{} [b (c)]
@end example

@var{start}が整数でない、または@var{end}が整数でも@code{nil}でもななければ、@code{wrong-type-argument}エラーがシグナルされる。@var{start}が@var{end}の後の文字を指す、または@var{string}にたいして範囲外の整数をいずれかに指定すると、@code{args-out-of-range}エラーがシグナルされる。

この関数に対応するのは@code{buffer-substring} (@ref{Buffer
Contents}を参照)で、これはカレントバッファー内のテキストの一部を含む文字列をリターンする。文字列の先頭はインデックス0だが、バッファーの先頭はインデックス1である。
@end defun

@defun substring-no-properties string &optional start end
これは@code{substring}と同じように機能するが、値のすべてのテキストプロパティを破棄する。@var{start}を省略したり@code{nil}を指定することができ、その場合は0と等価である。したがって@w{@code{(substring-no-properties
@var{string})}}は、すべてのテキストプロパティが削除された@var{string}のコピーをリターンする。
@end defun

@defun concat &rest sequences
@cindex copying strings
@cindex concatenating strings
この関数は渡された引数内の文字からなる文字列をリターンする(もしあればテキストプロパティも)。引数には文字列、数のリスト、数のベクターを指定できる。引数は変更されない。@code{concat}に引数を指定しなければ空文字列をリターンする。

@example
(concat "abc" "-def")
     @result{} "abc-def"
(concat "abc" (list 120 121) [122])
     @result{} "abcxyz"
;; @r{@code{nil}は空のシーケンス。}
(concat "abc" nil "-def")
     @result{} "abc-def"
(concat "The " "quick brown " "fox.")
     @result{} "The quick brown fox."
(concat)
     @result{} ""
@end example

@noindent
この関数は常に新たな文字列の割り当てを行う訳ではない。呼び出し側は結果が新たな文字列であること、もしくは既存の文字列にたいして@code{eq}であることに依存しないよう推奨する。

特にリターン値を変更すると誤って別の文字列を変更したり、プログラム内の定数文字列の変更や、エラーをraiseすることさえあり得る。安全に変更できる文字列を取得するには、結果に@code{copy-sequence}を使用すること。

他の結合関数(concatenation functions)についての情報は@ref{Mapping
Functions}の@code{mapconcat}、@ref{Vector
Functions}の@code{vconcat}、@ref{Building
Lists}の@code{append}を参照のこと。シェルコマンドで使用される文字列の中に、個々のコマンドライン引数を結合するには、@ref{Shell
Arguments, combine-and-quote-strings}を参照されたい。
@end defun

@defun split-string string &optional separators omit-nulls trim
この関数は正規表現@var{separators}(@ref{Regular
Expressions}を参照)にもとづいて、@var{string}を部分文字列に分解する。@var{separators}にたいする各マッチは分割位置を定義する。分割位置の間にある部分文字列をリストにまとめてリターンする。

@var{separators}が@code{nil}
(か省略)ならデフォルトは@code{split-string-default-separators}の値となり、関数は@var{omit-nulls}が@code{t}であるかのように振る舞う。

@var{omit-nulls}が@code{nil}(または省略)なら、連続する2つの@var{separators}へのマッチか、@var{string}の最初か最後にマッチしたときの空文字列が結果に含まれる。@var{omit-nulls}が@code{t}なら、これらの空文字列は結果から除外される。

オプションの引数@var{trim}が非@code{nil}なら、その値は各部分文字列の最初と最後からトリム(trim:
除去)するテキストにマッチする正規表現を指定する。トリムによりその部分文字列が空になるようなら、それは空文字列として扱われる。

文字列を分割して@code{call-process}や@code{start-process}に適するような、個々のコマンドライン引数のリストにする必要がある場合は@ref{Shell
Arguments, split-string-and-unquote}を参照のこと。

以下は例:

@example
(split-string "  two words ")
     @result{} ("two" "words")
@end example

有用性はほとんどないであろう@code{("" "two" "words"
"")}という結果とはならない。このような結果が必要なら@var{separators}に明示的な値を使用すること

@example
(split-string "  two words "
              split-string-default-separators)
     @result{} ("" "two" "words" "")
@end example

@example
(split-string "Soup is good food" "o")
     @result{} ("S" "up is g" "" "d f" "" "d")
(split-string "Soup is good food" "o" t)
     @result{} ("S" "up is g" "d f" "d")
(split-string "Soup is good food" "o+")
     @result{} ("S" "up is g" "d f" "d")
@end example

空のマッチはカウントされます。例外は、空でないマッチを使用することにより、すでに文字列の最後に到達しているとき、または@var{string}が空の時で、この場合@code{split-string}は最後の空マッチを探しません。

@example
(split-string "aooob" "o*")
     @result{} ("" "a" "" "b" "")
(split-string "ooaboo" "o*")
     @result{} ("" "" "a" "b" "")
(split-string "" "")
     @result{} ("")
@end example

しかし@var{separators}が空文字列にマッチできるとき、通常は@var{omit-nulls}を@code{t}にすれば、前の3つの例の不明瞭さはほとんど発生しない:

@example
(split-string "Soup is good food" "o*" t)
     @result{} ("S" "u" "p" " " "i" "s" " " "g" "d" " " "f" "d")
(split-string "Nice doggy!" "" t)
     @result{} ("N" "i" "c" "e" " " "d" "o" "g" "g" "y" "!")
(split-string "" "" t)
     @result{} nil
@end example

空でないマッチより空のマッチを優先するような、一部の``非貪欲(non-greedy)''な値を@var{separators}に指定することにより、幾分奇妙(ではあるが予見可能)な振る舞いが発生することがある。繰り返しになるが、そのような値は実際には稀である:

@example
(split-string "ooo" "o*" t)
     @result{} nil
(split-string "ooo" "\\|o+" t)
     @result{} ("o" "o" "o")
@end example
@end defun

@defvar split-string-default-separators
@code{split-string}の@var{separators}にたいするデフォルト値。通常の値は@w{@code{"[
\f\t\n\r\v]+"}}。
@end defvar

@defun string-clean-whitespace string
@var{string}内の連続する空白文字を単一のスペースに、同様に@var{string}の先頭と終端にあるすべての空白文字を取り除くことにより空白文字を整理する。
@end defun

@defun string-trim-left string &optional regexp
@var{string}の先頭から@var{regexp}にマッチするテキストを削除する。@var{regexp}のデフォルトは@samp{[
\t\n\r]+}。
@end defun

@defun string-trim-right string &optional regexp
@var{string}の末尾から@var{regexp}にマッチするテキストを削除する。@var{regexp}のデフォルトは@samp{[
\t\n\r]+}。
@end defun

@defun string-trim string &optional trim-left trim-right
@var{string}から@var{trim-left}にマッチする先頭のテキストと、@var{trim-right}にマッチする末尾のテキストを削除する。いずれのregexpもデフォルトは@samp{[
\t\n\r]+}。
@end defun

@defun string-fill string width
Attempt to Word-wrap @var{string} so that it displays with lines no wider
than @var{width}.  Filling is done on whitespace boundaries only.  If there
are individual words that are longer than @var{width}, these will not be
shortened, and therefore @var{string} might be shown with lines wider than
@var{width} in that case.
@end defun

@defun string-limit string length &optional end coding-system
@var{string}の文字数が@var{length}より短ければ@var{string}をそのままリターンする。それ以外なら最初の@var{length}文字からなる@var{string}の部分文字列をリターンする。オプションのパラメーター@var{end}が与えられた場合には、かわりに最後の@var{length}文字からなる文字列をリターンする。

@var{coding-system}が非@code{nil}なら@var{string}を切り詰める前にエンコードして、結果は@code{length}バイトより短いユニバイト文字列になる。@var{string}にエンコードされると複数バイトになる文字(たとえば@code{utf-8}使用時)が含まれる場合には、結果となるユニバイト文字列が文字表現の途中で切り詰められることはない。

この関数は文字列長を文字数かバイトで数えるので、文字列を表示用に短くする必要がある場合には一般的に適していない。かわりに@code{truncate-string-to-width}、@code{window-text-pixel-size}、@code{string-glyph-split}を使用すること(@ref{Size
of Displayed Text}を参照)。
@end defun

@defun string-lines string &optional omit-nulls keep-newlines
改行を境界として@var{string}を文字列のリストに分割する。オプション引数@var{omit-nulls}が非@code{nil}なら、結果から空行を除外する。オプション引数@var{keep-newlines}が非@code{nil}なら、結果文字列から末尾の改行を取り除かない。
@end defun

@defun string-pad string length &optional padding start
@var{padding}をパディング文字に使用して、与えられた@var{length}になるように@var{string}をパディングする。@var{padding}のデフォルトはスペース文字。@var{length}より@var{string}が長ければパディングしない。@var{start}が@code{nil}
(または省略)ならパディングは文字列終端、非@code{nil}なら文字列先頭に追加される。
@end defun

@defun string-chop-newline string
@var{string}からもしあれば最後の改行を削除する。
@end defun

@node Modifying Strings
@section 文字列の変更
@cindex modifying strings
@cindex string modification

  このセクションで説明する処理を介して変更可能な文字列のコンテンツを変更できます。@ref{Mutability}を参照してください。

  既存の文字列の内容を変更するもっとも基本的な方法は、@code{aset} (@ref{Array
Functions}を参照)を使用する方法です。@w{@code{(aset @var{string} @var{idx}
@var{char})}}は、@var{string}の文字インデックス@var{idx}に、@var{char}を格納します。これは@var{string}が純正な@acronym{ASCII}なら必要に応じてマルチバイト文字列(@ref{Text
Representations}を参照)に変換しますが、@var{char}がrawバイトではなく非@acronym{ASCII}文字の場合には、たとえば@code{string-to-multibyte}
(@ref{Converting
Representations}を参照)を使う等により、@var{string}がマルチバイトになるよう常に保証することをお勧めします。

  パスワードを含む文字列をクリアーするときには@code{clear-string}を使用します:

@defun clear-string string
This makes @var{string} a unibyte string and clears its contents to null
characters.  It may also change @var{string}'s length.
@end defun

@need 2000
@node Text Comparison
@section 文字および文字列の比較
@cindex string equality
@cindex text comparison
@cindex string comparison

@cindex compare characters
@defun char-equal character1 character2
この関数は引数が同じ文字を表すなら@code{t}、それ以外は@code{nil}をリターンする。@code{case-fold-search}が非@code{nil}なら、この関数はcaseの違いを無視する。

@example
(char-equal ?x ?x)
     @result{} t
(let ((case-fold-search nil))
  (char-equal ?x ?X))
     @result{} nil
@end example
@end defun

@cindex compare strings
@defun string-equal string1 string2
この関数は、2つの文字列の文字が正確にマッチすれば@code{t}をリターンする。引数にはシンボルも指定でき、この場合はそのシンボル名が使用される。@code{case-fold-search}とは無関係にcaseは常に意味をもつ。

This function is equivalent to @code{equal} for comparing two strings
(@pxref{Equality Predicates}).  In particular, the text properties of the
two strings are ignored; use @code{equal-including-properties} if you need
to distinguish between strings that differ only in their text properties.
However, unlike @code{equal}, if either argument is not a string or symbol,
@code{string-equal} signals an error.

@example
(string-equal "abc" "abc")
     @result{} t
(string-equal "abc" "ABC")
     @result{} nil
(string-equal "ab" "ABC")
     @result{} nil
@end example

A unibyte and a multibyte string are equal in the sense of
@code{string-equal} if and only if they contain the same sequence of
character codes all being in the range 0--127 (@acronym{ASCII}).  @xref{Text
Representations}.
@end defun

@defun string= string1 string2
@code{string=} is another name for @code{string-equal}.
@end defun

@cindex case-insensitive string comparison
@defun string-equal-ignore-case string1 string2
@code{string-equal-ignore-case}は@code{case-fold-search}が@code{t}の際の@code{char-equal}のように、case(大文字小文字)の違いを無視して文字列を比較する。
@end defun

@cindex locale-dependent string equivalence
@defun string-collate-equalp string1 string2 &optional locale ignore-case
この関数は@var{locale} (デフォルトはカレントのシステムlocale)で指定された照合ルール(collation
rule)にもとづいて、@var{string1}と@var{string2}が等しければ@code{t}をリターンする。照合ルールは@var{string1}と@var{string2}に含まれる文字の辞書順だけではなく、それらの文字間の関係に関する他のルールにより判断される。これは通常はEmacs実行中のlocale環境、およびEmacsがリンクされた標準Cライブラリー@footnote{照合ルールとlocaleにたいする依存関係についての詳細は@uref{https://unicode.org/reports/tr10/,
The Unicode Collation Algorithm}を参照のこと。@acronym{GNU}
Cライブラリー(@dfn{glibc}とも呼ばれる)のような一部の標準CライブラリーはUCA(Unicode Collation Algorithm:
Unicode照合アルゴリズム)の大部分を実装しており、関連のあるlocaleデータや@acronym{CLDR}(Common Locale Data
Repository: 共通ロケールデータレポジトリ)を使用する。}により決定される。

たとえばUnicode文字の異なるグレイブアクセントのように、コーディングポイントが異なっても意味が同じなら、一部のlocaleでは等しいとみなされるかもしれない。

@example
@group
(string-collate-equalp (string ?\uFF40) (string ?\u1FEF))
     @result{} t
@end group
@end example

オプション引数@var{locale}(文字列)は、照合用のカレントlocale識別子(current locale
identifier)をオーバーライドする。値はシステムに依存する。たとえばPOSIXシステムでは@code{"en_US.UTF-8"}、MS-Windowsシステムでは@code{"enu_USA.1252"}の@var{locale}が適用できるだろう。

@var{ignore-case}が非@code{nil}なら、文字を小文字に変換することによってcaseを区別せずに文字の比較を行う。ただし背景となるシステムライブラリーがlocale固有の照合ルールを提供していない場合には、この関数は@code{string-equal}にフォールバックする。この場合には@var{ignore-case}引数を無視して、常にcaseを区別した比較を行う。

@vindex w32-collate-ignore-punctuation
MS-WindowsシステムでUnicode互換の照合をエミュレートする場合、MS-Windowsではlocaleのコードセット部分を@code{"UTF-8"}にできないので、@code{w32-collate-ignore-punctuation}に非@code{nil}値をバインドすること。

あるlocale環境をシステムがサポートしなれければ、この関数は@code{string-equal}と同様に振る舞う。

一般的にファイルシステムは照合ルールが実装するような文字列の言語学的な等価性を尊重しないので、この関数をファイル名の等価性の比較に@emph{使用しないこと}。
@end defun

@cindex lexical comparison of strings
@anchor{definition of string-lessp}
@defun string-lessp string1 string2
この関数は2つの文字列を1文字ずつ比較する。この関数は同時に2つの文字列をスキャンして、対応する文字同士がマッチしない最初のペアを探す。2つの文字列内で小さいほうの文字が@var{string1}の文字なら@var{string1}が小さいことになり、この関数は@code{t}をリターンする。小さいほうの文字が@var{string2}の文字なら@var{string1}が大きいことになり、この関数は@code{nil}をリターンする。2つの文字列が完全にマッチしたら値は@code{nil}になる。

文字のペアーは文字コードで比較される。@acronym{ASCII}文字セットでは英小文字は英大文字より高い数値をもつことに留意されたい。数字と区切り文字の多くは英大文字より低い数値をもつ。@acronym{ASCII}文字は任意の非@acronym{ASCII}文字より小さくなる。ユニバイトの非@acronym{ASCII}文字は、任意のマルチバイト非@acronym{ASCII}文字より常に小さくなります(@ref{Text
Representations}を参照)。

@example
@group
(string-lessp "abc" "abd")
     @result{} t
(string-lessp "abd" "abc")
     @result{} nil
(string-lessp "123" "abc")
     @result{} t
@end group
@end example

文字列の長さが異なり、@var{string1}の長さまでマッチする場合、結果は@code{t}になる。@var{string2}の長さまでマッチする場合、結果は@code{nil}になる。文字を含まない文字列は、他の任意の文字列より小さくなる。

@example
@group
(string-lessp "" "abc")
     @result{} t
(string-lessp "ab" "abc")
     @result{} t
(string-lessp "abc" "")
     @result{} nil
(string-lessp "abc" "ab")
     @result{} nil
(string-lessp "" "")
     @result{} nil
@end group
@end example

引数としてシンボルを指定することもでき、この場合はシンボルのプリント名が比較される。
@end defun

@defun string< string1 string2
@code{string<} is another name for @code{string-lessp}.
@end defun

@defun string-greaterp string1 string2
この関数は逆順で@var{string1}と@var{string2}を比較した結果をリタンーする。つまりこれは@code{(string-lessp
@var{string2} @var{string1})}を呼び出すのと等価である。
@end defun

@defun string> string1 string2
@code{string>} is another name for @code{string-greaterp}.
@end defun

@cindex locale-dependent string comparison
@cindex string collation
@defun string-collate-lessp string1 string2 &optional locale ignore-case
この関数は指定された@var{locale}
(デフォルトはカレントのシステムlocale)の照合順において、@var{string1}が@var{string2}より小さければ@code{t}をリターンする。照合順は@var{string1}と@var{string2}に含まれる文字の辞書順だけではなく、それらの文字間の関係に関するルールによっても判断される。これは通常はEmacs実行中の@var{locale}環境、およびEmacsとリンクされた標準Cライブラリーによって決定される。

たとえばソートでは区切り文字と空白文字は無視されるだろう(@ref{Sequence Functions}を参照)。

@example
@group
(sort '("11" "12" "1 1" "1 2" "1.1" "1.2")
       :lessp #'string-collate-lessp)
     @result{} ("11" "1 1" "1.1" "12" "1 2" "1.2")
@end group
@end example

この振る舞いはシステム依存であり、例えばCygwinではlocaleに関係なく区切り文字と空白文字が無視されることは一切ない。

オプション引数@var{locale}(文字列)は、照合用のカレントlocale識別子(current locale
identifier)をオーバーライドする。値はシステムに依存する。たとえばPOSIXシステムでは@code{"en_US.UTF-8"}、MS-Windowsシステムでは@code{"enu_USA.1252"}の@var{locale}が適用できるだろう。@var{locale}の値を@code{"POSIX"}か@code{"C"}にすると、@code{string-collate-lessp}は@code{string-lessp}と同様に振る舞う。

@example
@group
(sort '("11" "12" "1 1" "1 2" "1.1" "1.2")
      :lessp (lambda (s1 s2) (string-collate-lessp s1 s2 "POSIX")))
     @result{} ("1 1" "1 2" "1.1" "1.2" "11" "12")
@end group
@end example

@var{ignore-case}が非@code{nil}なら、文字を小文字に変換することによってcaseを区別せずに文字の比較を行う。ただし背景となるシステムライブラリーがlocale固有の照合ルールを提供していない場合には、この関数は@code{string-equal}にフォールバックする。この場合には@var{ignore-case}引数を無視して、常にcaseを区別した比較を行う。

MS-WindowsシステムでUnicode互換の照合をエミュレートする場合、MS-Windowsではlocaleのコードセット部分を@code{"UTF-8"}にできないので、@code{w32-collate-ignore-punctuation}に非@code{nil}値をバインドすること。

locale環境をサポートしないシステムでは、この関数は@code{string-lessp}と同様に振る舞う。
@end defun

@cindex version comparison
@cindex comparing version strings
@defun string-version-lessp string1 string2
この関数は文字列を辞書順で比較するが、数字のシーケンスを10進数で構成されているかのように扱い、その数値を比較する。つまりたとえ辞書順で@samp{12}が@samp{2}より``小''だとしても、この述語に応じて@samp{foo12.png}より@samp{foo2.png}が``小''になる。
@end defun

@cindex string starts with prefix
@defun string-prefix-p string1 string2 &optional ignore-case
この関数は@var{string1}が@var{string2}のプレフィクス(たとえば@var{string2}が@var{string1}で始まる)なら、非@code{nil}をリターンする。オプションの引数@var{ignore-case}が非@code{nil}なら、比較においてcaseの違いは無視される。
@end defun

@cindex string ends with suffix
@defun string-suffix-p suffix string &optional ignore-case
この関数は@var{suffix}が@var{string}のサフィックス(たとえば@var{string}が@var{suffix}で終わる)なら、非@code{nil}をリターンする。オプションの引数@var{ignore-case}が非@code{nil}なら、比較においてcaseの違いは無視される。
@end defun

@defun string-search needle haystack &optional start-pos
@var{haystack}内で最初に@var{needle}
(いずれも文字列)が出現する位置をリターンする。@var{start-pos}が非@code{nil}なら、検索は@var{haystack}内のその位置から開始される。マッチ(一致するもの)が見つからなければ@code{nil}をリターンする。この関数は比較を行う際にはテキストプロパティは無視して、文字列内の文字だけを考慮する。マッチングでは常にcaseを区別する。
@end defun

@defun compare-strings string1 start1 end1 string2 start2 end2 &optional ignore-case
この関数は@var{string1}の指定部分をと@var{string2}指定部分を比較する。@var{string1}の指定部分とは、インデックス@var{start1}(その文字を含む)から、インデックス@var{end1}(その文字を含まない)まで。@var{start1}に@code{nil}を指定すると文字列の最初という意味になり、@var{end1}に@code{nil}を指定すると文字列の長さを意味する。同様に@var{string2}の指定部分とはインデックス@var{start2}からインデックス@var{end2}まで。

文字列は文字列内の文字の数値により比較される。たとえば@var{str1}と@var{str2}は、最初に異なる文字で@var{str1}の文字の数値が小さければ小さいと判断される。@var{ignore-case}が非@code{nil}なら比較を行なう前に、カレントバッファーのcaseテーブル(@ref{Case
Tables}を参照)を使用して大文字に変換される。比較用にユニバイト文字列はマルチバイト文字列に変換されるので(@ref{Text
Representations}を参照)、ユニバイト文字列とそれを変換したマルチバイト文字列は常に等しくなる。

2つの文字列の指定部分がマッチ(一致)した場合、値は@code{t}になる。それ以外なら値は整数で、何文字が一致してどちらの文字が小さいかを示す。この値の絶対値は、2つの文字列の先頭から一致した文字数に1加えた値になる。@var{string1}(または指定部分)のほうが小さければ符号は負になる。
@end defun

@cindex Levenshtein distance
@cindex distance between strings
@cindex edit distance between strings
@defun string-distance string1 string2 &optional bytecompare
この関数はソース文字列@var{string1}とターゲット文字列@var{string2}の間の@dfn{レーベンシュタイン距離(Levenshtein
distance)}をリターンする。レーベンシュタイン距離はソース文字列をターゲット文字列に変換(削除、挿入、置換)するために必要な単一文字の個数。これは文字列間の@dfn{編集距離(edit
distance)}として使用可能な定義の1つである。

計算距離にとって文字列の英字のcase(大文字小文字)は意味をもつが、テキストプロパティは無視される。オプション引数@var{bytecompare}が非@code{nil}なら、この関数は文字ではなくバイトで計算する。バイト単位での比較はEmacsの内部的な文字表現を使用するので、rawバイトを含むマルチバイト文字列では不正確な結果を生成するかもしれない(@ref{Text
Representations}を参照)。rawで正確な結果が必要なら、エンコードして文字列をユニバイトにすること(@ref{Explicit
Encoding}を参照)。
@end defun

@defun assoc-string key alist &optional case-fold
この関数は@code{assoc}と同様に機能するが、@var{key}は文字列かシンボルでなければならず、比較は@code{compare-strings}を使用して行なわれる。テストする前にシンボルは文字列に変換される。@var{case-fold}が非@code{nil}なら、@var{key}と@var{alist}の要素は比較前に大文字に変換される。@code{assoc}とは異なり、この関数はコンスではない文字列またはシンボルのalist要素もマッチできる。特に@var{alist}は実際のalistではなく、文字列またはリストでも可。@ref{Association
Lists}を参照のこと。
@end defun

  バッファー内のテキストを比較する方法として、@ref{Comparing
Text}の関数@code{compare-buffer-substrings}も参照してください。文字列にたいして正規表現のマッチを行なう関数@code{string-match}も、ある種の文字列比較に使用することができます。@ref{Regexp
Search}を参照してください。

@node String Conversion
@section 文字および文字列の変換
@cindex conversion of strings

  このセクションでは文字、文字列、整数の間で変換を行なう関数を説明します。@code{format} (@ref{Formatting
Strings}を参照)と@code{prin1-to-string} (@ref{Output
Functions}を参照)もLispオブジェクトを文字列に変換できます。@code{read-from-string} (@ref{Input
Functions}を参照)は、Lispオブジェクトの文字列表現をオブジェクトに``変換''できます。関数@code{string-to-multibyte}と@code{string-to-unibyte}は、テキスト表現を文字列に変換します(@ref{Converting
Representations}を参照)。

  テキスト文字と一般的なインプットイベントにたいするテキスト記述を生成する関数(@code{single-key-description}と@code{text-char-description})については、@ref{Documentation}を参照してください。これらの関数は主にヘルプメッセージを作成するために使用されます。

@defun number-to-string number
@cindex integer to string
@cindex integer to decimal
この関数は@var{number}の10進プリント表現からなる文字列をリターンする。引数が負ならリターン値はマイナス記号から開始される。

@example
(number-to-string 256)
     @result{} "256"
@group
(number-to-string -23)
     @result{} "-23"
@end group
(number-to-string -23.5)
     @result{} "-23.5"
@end example

@cindex @code{int-to-string}
@code{int-to-string}はこの関数にたいする半ば廃れたエイリアスである。

@ref{Formatting Strings}の関数@code{format}も参照されたい。
@end defun

@defun string-to-number string &optional base
@cindex string to number
この関数は@var{string}内の文字の数値的な値をリターンする。@var{base}が非@code{nil}なら値は2以上16以下でなければならず、整数はその基数に変換される。@var{base}が@code{nil}なら基数に10が使用される。浮動小数点数の変換は基数が10のときだけ機能する。わたしたちは浮動小数点数にたいして他の基数を実装しない。なぜならこれには多くの作業を要し、その割にその機能が有用には思えないからだ。

パースでは@var{string}の先頭にあるスペースとタブはスキップして、与えられた基数で数字として解釈できるところまで@var{string}を読み取る(スペースとタブだけではなく先頭にある他の空白文字を無視するシステムもある)。@var{string}を数字として解釈できなければこの関数は0をリターンする。

@example
(string-to-number "256")
     @result{} 256
(string-to-number "25 is a perfect square.")
     @result{} 25
(string-to-number "X256")
     @result{} 0
(string-to-number "-4.5")
     @result{} -4.5
(string-to-number "1e5")
     @result{} 100000.0
@end example
@end defun

@defun char-to-string character
@cindex character to string
この関数は1つの文字@var{character}を含む新しい文字列をリターンする。関数@code{string}のほうがより一般的であり、この関数は半ば廃れている。@ref{Creating
Strings}を参照のこと。
@end defun

@defun string-to-char string
  この関数は@var{string}の最初の文字をリターンする。これはほとんど@w{@code{(aref string
0)}}と同じで、例外は文字列が空のときに0をリターンすること(文字列の最初の文字が@acronym{ASCII}コード0のヌル文字のときも0をリターンする)。この関数は残すのに充分なほど有用と思えなければ、将来削除されるかもしれない。
@end defun

  以下は文字列へ／からの変換に使用できるその他の関数です:

@table @code
@item concat
この関数はベクターまたはリストから文字列に変換する。@ref{Creating Strings}を参照のこと。

@item vconcat
この関数は文字列をベクターに変換する。@ref{Vector Functions}を参照のこと。

@item append
この関数は文字列をリストに変換する。@ref{Building Lists}を参照のこと。

@item byte-to-string
この関数は文字データのバイトをユニバイト文字列に変換する。@ref{Converting Representations}を参照のこと。
@end table

@node Formatting Strings
@section 文字列のフォーマット
@cindex formatting strings
@cindex strings, formatting them

  @dfn{フォーマット(formatting)}とは、定数文字列内のさまざまな場所を計算された値で置き換えることにより、文字列を構築することを意味します。この定数文字列は他の値がどのようにプリントされるか、およびどこに表示するかを制御します。これは@dfn{フォーマット文字列(format
string)}と呼ばれます。

  表示されるメッセージを計算するためにフォーマットが便利なことがしばしばあります。実際に関数@code{message}と@code{error}は、ここで説明する機能と同じフォーマットを提供します。これらの関数と@code{format-message}の違いはフォーマットされた結果を使用する方法だけです。

@defun format string &rest objects
この関数は@var{string}のすべてのフォーマット仕様を、対応する@var{objects}を復号化したものと置換したものと等しい文字列をリターンする。引数@var{objects}はフォーマットされる計算値。

(もしあれば)@var{string}内のフォーマット仕様以外の文字はテキストプロパティを含めて出力に直接コピーされる。フォーマット仕様のすべてのテキストプロパティは引数@var{objects}を表現する生成された文字列にコピーされる。

出力される文字列は新規に割り当てられる必要はない。たとえば@code{x}が文字列@code{"foo"}なら@code{(eq x (format
x))}と@code{(eq x (format "%s" x))}はいずれも@code{t}となるだろう。
@end defun

@defun format-message string &rest objects
@cindex curved quotes, in formatted messages
@cindex curly quotes, in formatted messages
この関数は@code{format}と同様に機能するが、@var{string}内のすべてのグレイブアクセント(@t{`})とアポストロフィー(@t{'})を@code{text-quoting-style}の各値に応じて変換する点が異なる。

フォーマット内のグレイブアクセントとアポストロフィーはマッチするcurved quotesに変換される(@t{"Missing
`%s'"}は@t{"Missing ‘foo’"}という結果になる)この変換の影響と回避については@ref{Text Quoting
Style}を参照のこと。
@end defun

@cindex @samp{%} in format
@cindex format specification
  フォーマット仕様(format
specification)は@samp{%}で始まる文字シーケンスです。したがって@var{string}内に@samp{%d}があると@code{format}はそれを、フォーマットされる値の1つ(引数@var{objects}のうちの1つ)にたいするプリント表現で置き換えます。たとえば:

@example
@group
(format "The value of fill-column is %d." fill-column)
     @result{} "The value of fill-column is 72."
@end group
@end example

  @code{format}は文字@samp{%}をフォーマット仕様と解釈するので、@emph{決して}最初の引数に不定な文字列(arbitrary
string)を渡すべきではありません。これは特に何らかのLispコードが生成した文字列の場合に当てはまります。その文字列が決して文字@samp{%}を含まないと@emph{確信}できないならば、以下で説明するように最初の引数に@code{"%s"}を渡して、その不定な文字列を2番目の引数として渡します:

@example
  (format "%s" @var{arbitrary-string})
@end example

  ある種のフォーマット仕様は特定の型の値を要求します。その要求に適合しない値を与えた場合にはエラーがシグナルされます。

  以下は有効なフォーマット仕様のテーブルです:

@table @samp
@item %s
フォーマット仕様を、クォートなしのオブジェクトのプリント表現で置き換える(つまり@code{prin1}ではなく@code{princ}を使用して置き換える。@ref{Output
Functions}を参照されたい)。したがって文字列は@samp{"}文字なしの文字列内容だけが表示され、シンボルは@samp{\}文字なしで表される。

オブジェクトが文字列なら文字列のプロパティは出力にコピーされる。@samp{%s}のテキストプロパティ自身もコピーされるが、オブジェクトのテキストプロパティが優先される。

@item %S
フォーマット仕様を、クォートありのオブジェクトのプリント表現で置き換える(つまり@code{prin1}を使用して変換する。@ref{Output
Functions}を参照されたい)。したがって文字列は@samp{"}文字で囲まれ、必要となる特別文字の前に@samp{\}文字が表示される。

@item %o
@cindex integer to octal
フォーマット仕様を整数の8進表現に置き換える。負の整数はプラットフォーム依存の方法でフォーマットされる。オブジェクトは浮動小数点数(小数部分を切り捨てて整数にフォーマット)でもよい。

@item %d
フォーマット仕様を10進表現の符号つき整数で置き換える。オブジェクトは浮動小数点数(小数部分を切り捨てて整数にフォーマット)でもよい。

@item %x
@itemx %X
@cindex integer to hexadecimal
フォーマット仕様を16進表現の整数で置き換える。負の整数はプラットフォーム依存の方法でフォーマットされる。@samp{%x}なら小文字、@samp{%X}なら大文字が使用される。オブジェクトは小数部分を切り捨てて整数にフォーマットされた浮動小数点数でもよい。

@item %c
フォーマット仕様を与えられた値の文字で置き換える。

@item %e
フォーマット仕様を浮動小数点数の指数表現で置き換える。

@item %f
フォーマット仕様を浮動小数点数にたいする10進小数表記で置き換える。

@item %g
指数表記か小数点表記のいずれかを使用してフォーマット仕様を浮動小数点数にたいする表記に置き換える。指数が@minus{}4未満または精度(デフォルトは6)以上なら指数表記を使用する。デフォルトでは結果の小数部の末尾の0は削除されて、小数点が現れるのは後に数字が続く場合のみ。

@item %%
フォーマット仕様を1つの@samp{%}で置き換える。このフォーマット仕様は唯一のフォームが素の@samp{%%}であり値を使用しないという点で特殊。たとえば@code{(format
"%% %d" 30)}は@code{"% 30"}をリターンする。
@end table

  他のフォーマット文字は@samp{Invalid format operation}エラーとなります。

  以下は典型的な@code{text-quoting-style}のセッティングを想定した場合の例です:

@example
@group
(format "The octal value of %d is %o,
         and the hex value is %x." 18 18 18)
     @result{} "The octal value of 18 is 22,
         and the hex value is 12."

(format-message
 "The name of this buffer is ‘%s’." (buffer-name))
     @result{} "The name of this buffer is ‘strings-ja.texi’."

(format-message
 "The buffer object prints as `%s'." (current-buffer))
     @result{} "The buffer object prints as ‘strings-ja.texi’."
@end group
@end example

  フォーマット仕様はデフォルトでは@var{objects}から連続して値を引き当てます。つまり@var{string}内の1番目のフォーマット仕様は1番目の値、2番目のフォーマット仕様は2番目の値、...を使用します。余分なフォーマット仕様(対応する値がない場合)にはエラーとなります。フォーマットされる値が余分にある場合には無視されます。

@cindex field numbers in format spec
  フォーマット仕様は@dfn{フィールド番号(field
number)}をもつことができます。これは最初の@samp{%}の直後に10進数字、その後にドル記号@samp{$}が続きます。これにより次の引数ではなく与えられた番号の引数をフォーマット仕様に変換させることができます。フィールド番号は1から始まります。フォーマットのフォーマット仕様が番号を含むことも含まないことも可能ですが、両方を含むことはできません。ただし例外は@samp{%%}であり、これは番号付きのフォーマット仕様と混交できます。

@example
(format "%2$s, %3$s, %%, %1$s" "x" "y" "z")
     @result{} "y, z, %, x"
@end example

@cindex flags in format specifications
  @samp{%}とすべてのフィールド番号の後に@dfn{フラグ文字(flag characters)}を配置できます。

  フラグ@samp{+}は非負の数の前にプラス符号を挿入するので、数には常に符号がつきます。フラグとしてスペースを指定すると、非負の数の前に1つのスペースが挿入されます(それ以外は非負の数は最初の数字から開始される)。これらのフラグは非負の数と負数にたいして確実に同じ列数を使用させるために有用です。これらは@samp{%d}、@samp{%e}、@samp{%f}、@samp{%g}以外では無視され、両方が指定された場合は@samp{+}が優先されます。

  フラグ@samp{#}は代替形式(alternate
form)を指定します。これは使用するフォーマットに依存します。@samp{%o}にたいしては結果を@samp{0}で開始させます。@samp{%x}と@samp{%X}にたいしては非0の結果のプレフィクスは@samp{0x}または@samp{0X}になります。@samp{%e}、@samp{%f}にたいしての@samp{#}フラグは、小数部が0のときにも小数点が含まれることを意味します。@samp{%g}にたいしては常に小数点が含まれるとともに、それ以外なら削除される小数点の後の末尾のすべての0も強制的に残されます。

  フラグ@samp{0}はスペースの代わりに文字@samp{0}でパディングします。このフラグは@samp{%s}、@samp{%S}、@samp{%c}のような非数値のフォーマット仕様文字では無視されます。これらのフォーマット仕様文字で@samp{0}フラグを指定できますが、それでも@emph{スペース}でパディングされます。

  フラグ@samp{-}はフィールド幅指定子により挿入されるすべてのパディングに作用して、もしパディングが指定された場合には左側ではなく右側にパディングされます。@samp{-}と@samp{0}の両方が指定されると@samp{0}フラグは無視されます。

@example
@group
(format "%06d is padded on the left with zeros" 123)
     @result{} "000123 is padded on the left with zeros"

(format "'%-6d' is padded on the right" 123)
     @result{} "'123   ' is padded on the right"

(format "The word '%-7s' actually has %d letters in it."
        "foo" (length "foo"))
     @result{} "The word 'foo    ' actually has 3 letters in it."
@end group
@end example

@cindex field width
@cindex padding
  フォーマット仕様は@dfn{フィールド幅(width)}をもつことができます。これはすべてのフィールド番号とフラグの後にある10進の数字です。オブジェクトのプリント表現がこのフィールド幅より少ない文字を含む場合には、@code{format}はパディングによりフィールド幅に拡張します。フォーマット仕様@samp{%%}ではフィールド幅の指定は無視されます。フィールド幅指定子により行なわれるパディングは、通常は左側に挿入されるスペースで構成されます:

@example
(format "%5d is padded on the left with spaces" 123)
     @result{} "  123 is padded on the left with spaces"
@end example

@noindent
フィールド幅が小さすぎる場合でも@code{format}はオブジェクトのプリント表現を切り詰めません。したがって情報を失う危険を犯すことなく、フィールドの最小幅を指定することができます。以下の2つの例では@samp{%7s}は最小幅に7を指定します。1番目の例では@samp{%7s}に挿入される文字列は3文字だけなので、4つのブランクスペースによりパディングされます。2番目の例では文字列@code{"specification"}は13文字ですが切り詰めはされません。

@example
@group
(format "The word '%7s' has %d letters in it."
        "foo" (length "foo"))
     @result{} "The word '    foo' has 3 letters in it."
(format "The word '%7s' has %d letters in it."
        "specification" (length "specification"))
     @result{} "The word 'specification' has 13 letters in it."
@end group
@end example

@cindex precision in format specifications
  すべてのフォーマット仕様文字にはフィールド番号、フラグ、フィールド幅の後にオプションで@dfn{精度(precision)}を指定できます。精度は小数点@samp{.}と、その後に桁文字列(digit-string)を指定します。浮動小数点数のフォーマット仕様(@samp{%e}と@samp{%f})では、精度は表示する小数点以下の桁数を指定します。0なら小数点も省略されます。%gの精度が0か未指定なら1として扱われます。@samp{%s}と@samp{%S}では精度として与えられた幅に文字列が切り詰められるので、@samp{%.3s}では@var{object}の表現の最初の3文字だけが表示されます。その他の仕様文字では、@code{printf}ファミリーのローカルライブラリーが生成する精度の効果が表れます。

@samp{%s}と@samp{%S}にたいしては、文字列を精度で指定された幅に切り詰めます。したがって@samp{%.3s}では、@var{object}にたいするプリント表現の最初の3文字だけが表示されます。他のフォーマット仕様文字にたいしては、精度の効果はローカルライブラリーの@code{printf}関数ファミリーが生成する効果となります。

@cindex formatting numbers for rereading later
  フォーマット済みの値のコピーを取得するために後で@code{read}を使用する予定なら、@code{read}が値を再構築する仕様を使用してください。この逆手順で数値をフォーマットするには@samp{%s}と@samp{%S}、整数だけなら@samp{%d}、非負の整数なら@samp{#x%x}と@samp{#o%o}も使用できます。その他のフォーマットでは問題があるかもしれません。たとえば@samp{%d}と@samp{%g}はNaNを誤って処理したり精度や型を失うかもしれず、@samp{#x%x}と@samp{#o%o}は負の整数を誤って処理するかもしれません。@ref{Input
Functions}を参照してください。

このセクションでは仕様文字の固定セットを受け取る関数を説明します。次のセクションでは@samp{%a}や@samp{%z}のようなカスタム仕様文字を受け取ることができる関数@code{format-spec}を説明します。

@node Custom Format Strings
@section カスタムフォーマット文字列
@cindex custom format string
@cindex custom @samp{%}-sequence in format

ユーザーやLispプログラムが、カスタムフォーマットの制御文字列を介して特定のテキストが生成される方法を制御できるようにすると便利な場合があります。たとえばフォーマット文字列は人の姓や名、emailアドレスを表示する方法を制御できます。前のセクションで説明した関数@code{format}を使用することにより、フォーマット文字列は@w{@code{"%s
%s <%s>"}}のようになるかもしれません。しかしこのアプローチはどの仕様文字がどの情報に対応するかが不明瞭なのですぐに非実用的になります。

そのような場合には@w{@code{"%f %l
<%e>"}}のようなフォーマット文字列のほうが便利かもしれません。このフォーマット文字列では仕様文字それぞれがより意味的な情報をもち、他の仕様文字に関連して簡単に再配置できるので、このようなフォーマット文字列はユーザーにより簡単にカスタマイズできます。

このセクションで説明する関数@code{format-spec}は@code{format}と同様の機能を処理しますが、任意の仕様文字を使用するフォーマットコントロール文字列を処理する点が異なります。

@defun format-spec template spec-alist &optional ignore-missing split
この関数は@var{spec-alist}で指定された変換にしたがってフォーマット文字列@var{template}から生成された文字列をリターンする。@var{spec-alist}は@w{@code{(@var{letter}
. @var{replacement})}}という形式のalist(@ref{Association
Lists}を参照)。@var{template}内の仕様@code{%@var{letter}}はそれぞれ結果文字列のフォーマット時に置換される。

(もしあれば)@var{template}内のフォーマット仕様以外の文字はテキストプロパティを含めて出力に直接コピーされる。フォーマット仕様のすべてのテキストプロパティは置換先にコピーされる。

変換の指定にalistを使用することによって有用な特性がいくつか生成される:

@itemize @bullet
@item
@var{template}内に存在する一意な仕様文字より多くの一意な@var{letter}キーが@var{spec-alist}に含まれていると、使用されないキーは単に無視される。
@item
同じ@var{letter}にたいして複数の連想値が@var{spec-alist}に含まれていると、リスト先頭にもっとも近いものを使用する。
@item
@var{template}に同じ仕様文字が複数個含まれている場合には、その文字のすべての置換の基礎として@var{spec-alist}内で見つけた@var{replacement}を使用する。
@item
@var{template}内の仕様の順序は、@var{spec-alist}内の連想値の順序に対応する必要はない。
@end itemize

REPLACEMENTは引数なしで呼び出されて置換に用いる文字列をリターンする関数でもよい。この関数はTEMPLATEで対応するLETTERが使用された際にのみ呼び出される。これはたとえば必要なとき以外は入力を求めるプロンプトの表示を避ける場合に役に立つかもしれない。

オプション引数@var{ignore-missing}は、@var{spec-alist}で見つからない@var{template}内の仕様文字の処理方法を示す。@code{nil}か省略なら、関数はエラーをシグナルする。@code{ignore}ならこれらのフォーマット仕様は(もしあれば)テキストプロパティも含めてそのまま出力する。@code{delete}ならこれらのフォーマット仕様は出力から取り除かれる。これら以外の非@code{nil}値は@code{ignore}と同様に処理されるが、出力中に@samp{%%}があればそのまま残される。

オプション引数@var{split}が非@code{nil}なら、@code{format-spec}は単一文字列のかわりに置換場所を基準に結果を文字列リストに分割してリターンする。たとえば:

@example
(format-spec "foo %b bar" '((?b . "zot")) nil t)
     @result{} ("foo " "zot" " bar")
@end example
@end defun

@code{format-spec}が受け取るフォーマット仕様の構文は@code{format}が受け取るフォーマット仕様と似ていますが同一ではありません。いずれの場合でもフォーマット仕様は@samp{%}で始まり@samp{s}のようなアルファベット文字で終わる文字シーケンスです。

仕様文字の固定セットに特定の意味を割り当てる@code{format}とは異なり、@code{format-spec}は任意の仕様文字を受け取ってそれらをすべて等しく扱います。たとえば:

@example
@group
(setq my-site-info
      (list (cons ?s system-name)
            (cons ?t (symbol-name system-type))
            (cons ?c system-configuration)
            (cons ?v emacs-version)
            (cons ?e invocation-name)
            (cons ?p (number-to-string (emacs-pid)))
            (cons ?a user-mail-address)
            (cons ?n user-full-name)))

(format-spec "%e %v (%c)" my-site-info)
     @result{} "emacs 27.1 (x86_64-pc-linux-gnu)"

(format-spec "%n <%a>" my-site-info)
     @result{} "Emacs Developers <emacs-devel@@gnu.org>"
@end group
@end example

フォーマット仕様には置換の様相を変更するために、@samp{%}の直後に任意個数のフラグ文字を含めることができます。

@table @samp
@item 0
このフラグは指定された幅のパディングをスペースのかわりに@samp{0}で構成する。

@item -
このフラグは指定された幅のパディングを左側ではなく右側に挿入する。

@item <
このフラグはもし幅と精度が指定されたら置換の左側を切り捨てる。

@item >
このフラグはもし幅と精度が指定されたら置換の右側を切り捨てる。

@item ^
このフラグは置換されるテキストを大文字に変換する(@ref{Case Conversion}を参照)。

@item _@r{ (アンダースコアー)}
このフラグは置換されるテキストを小文字に変換する(@ref{Case Conversion}を参照)。
@end table

矛盾したフラグ(たとえば大文字と小文字)を使用した場合の結果は未定義です。

@code{format}の場合と同様に幅(任意のフラグの後の10進数値)、精度(任意のフラグと幅の後の小数点@samp{.}に続く10進数)をフォーマット仕様に含めることができます。

指定した幅より置換の文字が少なければ左側がパディングされます。

@example
@group
(format-spec "%8a is padded on the left with spaces"
             '((?a . "alpha")))
     @result{} "   alpha is padded on the left with spaces"
@end group
@end example

指定した精度より置換の文字が多ければ右側が切り詰められます。

@example
@group
(format-spec "%.2a is truncated on the right"
             '((?a . "alpha")))
     @result{} "al is truncated on the right"
@end group
@end example

以下は前述の機能をいくつか組み合わせたより複雑な例です:

@example
@group
(setq my-battery-info
      (list (cons ?p "73")      ; パーセント表示
            (cons ?L "Battery") ; 状態
            (cons ?t "2:23")    ; 残り時間
            (cons ?c "24330")   ; 容量
            (cons ?r "10.6")))  ; 放電率

(format-spec "%>^-3L : %3p%% (%05t left)" my-battery-info)
     @result{} "BAT :  73% (02:23 left)"

(format-spec "%>^-3L : %3p%% (%05t left)"
             (cons (cons ?L "AC")
                   my-battery-info))
     @result{} "AC  :  73% (02:23 left)"
@end group
@end example

このセクションの例で示したように、@code{format-spec}はさまざまな情報の断片を選択的にフォーマットするために頻繁に使用されます。これはプログラムが可能にする情報のサブセットだけをユーザーが通常の構文で望む順序で選択できるように、ユーザーにカスタマイズ可能なフォーマット文字列を提供するプログラムにとって有用です。

@node Case Conversion
@section Lispでの大文字小文字変換
@cindex upper case
@cindex lower case
@cindex character case
@cindex case conversion in Lisp

  case変換関数(character case
functions)は、1つの文字または文字列中の大文字小文字を変換します。関数は通常、アルファベット文字(英字@samp{A}から@samp{Z}と@samp{a}から@samp{z}、同様に非@acronym{ASCII}の英字)だけを変換し、それ以外の文字は変換しません。caseテーブル(case
table。@ref{Case Tables}を参照されたい)で指定することにより、caseの変換に異なるマッピングを指定できます。

  これらの関数は引数として渡された文字列は変更しません。

  以下の例では文字@samp{X}と@samp{x}を使用します。これらの@acronym{ASCII}コードは88と120です。

@defun downcase string-or-char
この関数は@var{string-or-char}(文字か文字列)を小文字に変換する。

@var{string-or-char}が文字列なら、この関数は引数の大文字を小文字に変換した新しい文字列をリターンする。@var{string-or-char}が文字なら、この関数は対応する小文字(整数)をリターンする。元の文字が小文字か非英字ならリターン値は元の文字と同じ。

@example
(downcase "The cat in the hat")
     @result{} "the cat in the hat"

(downcase ?X)
     @result{} 120
@end example
@end defun

@defun upcase string-or-char
この関数は@var{string-or-char}(文字か文字列)を大文字に変換する。

@var{string-or-char}が文字列なら、この関数は引数の小文字を大文字に変換した新しい文字列をリターンする。@var{string-or-char}が文字なら、この関数は対応する大文字(整数)をリターンする。元の文字が大文字か非英字ならリターン値は元の文字と同じ。

@example
(upcase "The cat in the hat")
     @result{} "THE CAT IN THE HAT"

(upcase ?x)
     @result{} 88
@end example
@end defun

@defun capitalize string-or-char
@cindex capitalization
この関数は文字列や文字をキャピタライズ(capitalize:
先頭が大文字で残りは小文字)する。この関数は@var{string-or-char}が文字列なら@var{string-or-char}の各単語をキャピタライズした新たなコピーをリターンする。これは各単語の最初の文字が大文字に変換され、残りは小文字に変換されることを意味する。

@vindex case-symbols-as-words
The definition of a word is any sequence of consecutive characters that are
assigned to the word constituent syntax class in the current syntax table
(@pxref{Syntax Class Table}); if @code{case-symbols-as-words} is
non-@code{nil}, characters assigned to the symbol constituent syntax class
are also considered as word constituent.

@var{string-or-char}が文字ならこの関数は@code{upcase}と同じことを行なう。

@example
@group
(capitalize "The cat in the hat")
     @result{} "The Cat In The Hat"
@end group

@group
(capitalize "THE 77TH-HATTED CAT")
     @result{} "The 77th-Hatted Cat"
@end group

@group
(capitalize ?x)
     @result{} 88
@end group
@end example
@end defun

@defun upcase-initials string-or-char
この関数は@var{string-or-char}が文字列なら、@var{string-or-char}の中の単語の頭文字をキャピタライズして、頭文字以外の文字は変更しない。この関数は@var{string-or-char}の各単語の頭文字が大文字に変換された新しいコピーをリターンする。

この関数における単語の定義は上述した@code{capitalize}での定義に準ずる。@code{case-symbols-as-words}が単語構成文字に及ぼす効果も同様。

@code{upcase-initials}の引数が文字なら、@code{upcase-initials}の結果は@code{upcase}と同じ。

@example
@group
(upcase-initials "The CAT in the hAt")
     @result{} "The CAT In The HAt"
@end group
@end example
@end defun

  case変換コードポイントを1対1でマップするものではなく、結果の文字列長は引数の文字列長と異なるかもしれません。さらに文字を渡すことによりリターンされる型にも文字が強制されるので、関数は正しい置換を行えずに1文字の文字列を処理する場合とは結果が異なるかもしれません。たとえば:

@ifnottex
@example
@group
(upcase "ﬁ")  ; 注意: 1文字の合字 "fi"
     @result{} "FI"
@end group
@group
(upcase ?ﬁ)
     @result{} 64257  ; つまり ?ﬁ
@end group
@end example
@end ifnottex
@iftex
@example
@group
(upcase "@r{fi}")  ; 注意: 1文字の合字 "fi"
     @result{} "FI"
@end group
@group
(upcase ?@r{fi})
     @result{} 64257  ; つまり ?@r{fi}
@end group
@end example
@end iftex

  これを避けるためにはcase関数のいずれかに文字を渡す前に@code{string}関数を使用して文字列に変換しなければなりません。もちろん結果の長さについて仮定はできません。

  このような特殊ケースのマッピングは@code{special-uppercase}、@code{special-lowercase}、@code{special-titlecase}から取得されます。@ref{Character
Properties}を参照してください。

  文字列を比較する関数(caseの違いを無視するものや、オプションでcaseの違いを無視できるもの)については、@ref{Text
Comparison}を参照されたい。

@node Case Tables
@section caseテーブル

  特別な@dfn{caseテーブル(case
table)}をインストールすることにより、caseの変換をカスタマイズできます。caseテーブルは大文字と小文字の間のマッピングを指定します。caseテーブルはLispオブジェクトにたいするcase変換関数(前のセクションを参照)と、バッファー内のテキストに適用される関数の両方に影響します。それぞれのバッファーにはcaseテーブルがあります。新しいバッファーのcaseテーブルを初期化するために使用される、標準のcaseテーブル(standard
case table)もあります。

  caseテーブルは、サブタイプが@code{case-table}の文字テーブル(char-table。@ref{Char-Tables}を参照)です。この文字テーブルはそれぞれの文字を対応する小文字にマップします。caseテーブルは、関連するテーブルを保持する3つの余分なスロットをもちます:

@table @var
@item upcase
upcase(大文字)テーブルはそれぞれの文字を対応する大文字にマップする。
@item canonicalize
canonicalize(正準化)テーブルは、caseに関連する文字セットのすべてを、その文字セットの特別なメンバーにマップする。
@item equivalences
equivalence(同値)テーブルは、大文字・小文字に関連した文字セットのそれぞれを、そのセットの次の文字にマップする。
@end table

  単純な例では、小文字へのマッピングを指定することだけが必要です。3つの関連するテーブルは、このマッピングから自動的に計算されます。

  大文字と小文字が1対1で対応しない言語もいくつかあります。これらの言語では、2つの異なる小文字が同じ大文字にマップされます。このような場合、大文字と小文字の両方にたいするマップを指定する必要があります。

  追加の@var{canonicalize}テーブルは、それぞれの文字を正準化された等価文字にマップします。caseに関連する任意の2文字は、同じ正準等価文字(canonical
equivalent
character)をもちます。たとえば@samp{a}と@samp{A}はcase変換に関係があるので、これらの文字は同じ正準等価文字(両方の文字が@samp{a}、または両方の文字が@samp{A})をもつべきです。

  追加の@var{equivalences}テーブルは、等価クラスの文字(同じ正準等価文字をもつ文字)それぞれを循環的にマップします(通常の@acronym{ASCII}では、これは@samp{a}を@samp{A}に@samp{A}を@samp{a}にマップし、他の等価文字セットにたいしても同様にマップする)。

  caseテーブルを構築する際は、@var{canonicalize}に@code{nil}を指定できます。この場合、Emacsは大文字と小文字のマッピングでこのスロットを充填します。@var{equivalences}にたいして@code{nil}を指定することもできます。この場合、Emacsは@var{canonicalize}からこのスロットを充填します。実際に使用されるcaseテーブルでは、これらのコンポーネントは非@code{nil}です。@var{canonicalize}を指定せずに@var{equivalences}を指定しないでください。

  以下はcaseテーブルに作用する関数です:

@defun case-table-p object
この述語は、@var{object}が有効なcaseテーブルなら非@code{nil}をリターンする。
@end defun

@defun set-standard-case-table table
この関数は@var{table}を標準caseテーブルにして、これ以降に作成される任意のバッファーにたいしてこのテーブルが使用されるようにする。
@end defun

@defun standard-case-table
これは標準caseテーブル(standard case table)をリターンする。
@end defun

@defun current-case-table
この関数はカレントバッファーのcaseテーブルをリターンする。
@end defun

@defun set-case-table table
これはカレントバッファーのcaseテーブルを@var{table}にセットする。
@end defun

@defmac with-case-table table body@dots{}
@code{with-case-table}マクロはカレントcaseテーブルを保存してから、@var{table}をカレントcaseテーブルにセットし、その後に@var{body}フォームを評価してから、最後にcaseテーブルをリストアします。リターン値は、@var{body}の最後のフォームの値です。@code{throw}かエラー(@ref{Nonlocal
Exits}を参照)により異常終了した場合でも、caseテーブルはリストアされます。
@end defmac

  @acronym{ASCII}文字のcase変換を変更する言語環境(language
environment)がいくつかあります。たとえばトルコ語の言語環境では、@acronym{ASCII}の大文字@samp{I}にたいする小文字は、トルコ語のドットがないi(@samp{ı})です。これは(@acronym{ASCII}ベースのネットワークプロトコル実装のような)@acronym{ASCII}の通常のcase変換を要求するコードに干渉する可能性があります。このような場合には、変数@var{ascii-case-table}にたいして@code{with-case-table}マクロを使用してください。これにより変更されていない@acronym{ASCII}文字セットのcaseテーブルが保存されます。

@defvar ascii-case-table
@acronym{ASCII}文字セットにたいするcaseテーブル。すべての言語環境セッティングにおいて、これを変更するべきではない。
@end defvar

  以下の3つの関数は、非@acronym{ASCII}文字セットを定義するパッケージにたいして便利なサブルーチンです。これらは@var{case-table}に指定されたcaseテーブルを変更します。これは標準構文テーブルも変更します。@ref{Syntax
Tables}を参照してください。通常これらの関数は、標準caseテーブルを変更するために使用されます。

@defun set-case-syntax-pair uc lc case-table
この関数は対応する文字のペアー(一方は大文字でもう一方は小文字)を指定する。
@end defun

@defun set-case-syntax-delims l r case-table
この関数は文字@var{l}と@var{r}を、case不変区切り(case-invariant delimiter)のマッチングペアーとする。
@end defun

@defun set-case-syntax char syntax case-table
この関数は@var{char}を構文@var{syntax}のcase不変(case-invariant)とする。
@end defun

@deffn Command describe-buffer-case-table
このコマンドはカレントバッファーのcaseテーブルの内容にたいする説明を表示する。
@end deffn
