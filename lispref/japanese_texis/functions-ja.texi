@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*- mode: texinfo; coding: utf-8 -*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990--1995, 1998--1999, 2001--2024 Free Software
@c Foundation, Inc.
@c See the file elisp-ja.texi for copying conditions.
@node Functions
@chapter 関数

  Lispプログラムは主にLisp関数で構成されます。このチャプターはで関数とは何か、引数を受け取る方法、そして関数を定義する方法を説明します。

@menu
* What Is a Function::       Lisp関数 
                               vs. プリミティブ。専門用語。
* Lambda Expressions::       関数がLispオブジェクトとして表現される方法。
* Function Names::           シンボルは関数を命名できる。
* Defining Functions::       関数定義のためのLisp式。
* Calling Functions::        既存の関数を使う方法。
* Mapping Functions::        リストの各要素などに関数を適用する。
* Anonymous Functions::      ラムダ式、それは無名の関数。
* Generic Functions::        Emacsスタイルのポリモーフィズム。
* Function Cells::           シンボルの関数定義へのアクセスとセット。
* Closures::                 レキシカル環境に囲まれた関数。
* OClosures::                Function objects with meta-data.
* Advising Functions::       関数の定義への追加。
* Obsolete Functions::       関数を陳腐と宣言する。
* Inline Functions::         コンパイラーによりインライン展開される関数。
* Declare Form::             関数についての補足的な情報の追加。
* Declaring Functions::      関数が定義されていることをコンパイラーに知らせる。
* Function Safety::          呼び出しても安全な関数なのか判断する。
* Related Topics::           関数が動作する方法において特別な意味をもつ、特定のLispプリミティブのクロスリファレンス。
@end menu

@node What Is a Function
@section 関数とは?

@cindex return value
@cindex value of function
@cindex argument
@cindex pure function
  一般的な意味では関数とは@dfn{引数(arguments)}と呼ばれる与えられた入力値の計算を担うルールです。計算の結果は関数の@dfn{値(value)}、または@dfn{return値(return
value)}と呼ばれます。計算は変数の値やデータ構造の内容を変更する等の副作用をもつこともできます(@ref{Definition of side
effect}を参照)。@dfn{純粋関数(pure
function)}とは、それらに加えて副作用をもたず、機種別やシステム状態のような外部要因とは無関係に同じ条件の引数にたいして常に同一の値をリターンする関数のことです。

  ほとんどのコンピューター言語では、関数はそれぞれ名前をもちます。しかしLispでは厳密な意味において関数は名前をもちません。関数はオブジェクトであり、関数の名前の役割を果たすシンボルに関連づけることができますが(たとえば@code{car})、それは@emph{オプション}です。@ref{Function
Names}を参照してください。関数が名前を与えられたとき、通常はそのシンボルを``関数''として参照します(たとえば関数@code{car}のように参照する)。このマニュアルでは、関数名と関数オブジェクト自身との間の区別は通常は重要ではありませんが、それが意味をもつような場合には注記します。

  @dfn{スペシャルフォーム(special
form)}、@dfn{マクロ(macro)}と呼ばれる関数likeなオブジェクトがいくつかあり、それらも引数を受け取って計算を行います。しかし以下で説明するようにEmacs
Lispではこれらは関数とはみなされません。

  以下は関数と関数likeなオブジェクトにたいする重要な条件です:

@table @dfn
@item lambda expression
Lispで記述された関数(厳密には関数オブジェクト)。これらについては以降のセクションで説明します。
@ifnottex
@ref{Lambda Expressions}を参照のこと。
@end ifnottex

@item primitive
@cindex primitive
@cindex subr
@cindex built-in function
Lispから呼び出すことができるが実際にはCで記述されている。プリミティブは@dfn{ビルトイン関数(built-in
functions)}とか@dfn{サブルーチン(subr)}のようにも呼ばれる。それらの例には関数likeな@code{car}や@code{append}が含まれる。加えてすべてのスペシャルフォーム(以下参照)もプリミティブとみなされる。

関数はLispの基礎となる部分(たとえば@code{car})であり、オペレーティングシステムのサービスにたいして低レベルのインターフェースを与え、高速に実行される必要があるために、通常はプリミティブとして実装されている。Lispで定義された関数と異なり、プリミティブの修正や追加には、Cソースの変更とEmacsのリコンパイルが必要となる。@ref{Writing
Emacs Primitives}を参照のこと。

@item special form
プリミティブは関数と似ているが、すべての引数が通常の方法で評価されない。いくつかの引数だけが評価されるかもしれず、通常ではない順序で評価されるか、複数回評価されるかもしれない。プリミティブの例には@code{if}、@code{and}、@code{while}が含まれる。@ref{Special
Forms}を参照のこと。

@item macro
@cindex macro
あるLisp式をオリジナルの式のかわりに評価される別の式に変換する、関数とは別のLispで定義された構文。マクロはスペシャルフォームが行う一連のことを、Lispプログラマーが行うのを可能にする。@ref{Macros}を参照のこと。

@item command
@cindex command
プリミティブ@code{command-execute}を通じて呼び出すことができるオブジェクトで、通常はそのコマンドに@dfn{バインド}されたキーシーケンスをユーザーがタイプすることにより呼び出される。@ref{Interactive
Call}を参照のこと。コマンドは通常は関数である。その関数がLispで記述されていれば、関数の定義内の@code{interactive}フォームによってコマンドとなる(@ref{Defining
Commands}を参照)。関数であるコマンドは他の関数と同様、Lisp式から呼び出すこともできる。

キーボードマクロ(文字列かベクター)は関数ではないが、これらもコマンドである。@ref{Keyboard
Macros}を参照のこと。シンボルの関数セルにコマンドが含まれてれば、わたしたちはそのシンボルをコマンドと言う(@ref{Symbol
Components}を参照)。そのような@dfn{名前つきコマンド(named command)}は@kbd{M-x}で呼び出すことができる。

@item closure
ラムダ式とよく似た関数オブジェクトだが、クロージャはレキシカル変数バインディングの環境にも囲われている。@ref{Closures}を参照のこと。

@item byte-code function
バイトコンパイラーによりコンパイル済みの関数。@ref{Closure Type}を参照のこと。

@item autoload object
@cindex autoload object
実際の関数のプレースホルダー。autoloadオブジェクトが呼び出されると、Emacsは実際の関数の定義を含むファイルをロードした後に実際の関数を呼び出す。@ref{Autoload}を参照のこと。
@end table

  関数@code{functionp}を使用して、あるオブジェクトが関数かどうかテストできます:

@defun functionp object
この関数は@var{object}が任意の種類の関数(@code{funcall}に渡すことができる)なら@code{t}をリターンする。@code{functionp}は関数を名づけるシンボルにたいしては@code{t}、マクロやスペシャルフォームにたいしては@code{nil}をリターンすることに注意。

@var{object}は関数でなければ、この関数は通常は@code{nil}をリターンする。ただし関数オブジェクトの表現は複雑なので、効率上の理由により@var{object}がたとえ関数でなくてもこの関数が@code{t}をリターンするときが稀にある。
@end defun

  任意の関数が期待する引数の個数を調べることもできます:

@defun func-arity function
この関数は指定された@var{function}の引数リストに関する情報を提供する。リターン値は@w{@code{(@var{min}
.
@var{max})}}という形式のコンスセル。ここで@var{min}は引数の最小個数、@var{max}は引数の最大個数、または@code{&rest}引数をもつ関数では@code{many}、@var{function}がスペシャルフォームならシンボル@code{unevalled}。

以下のようにある状況下ではこの関数は不正確な結果をリターンすることに注意:

@itemize @minus
@item
@code{apply-partially}を使用して定義された関数(@ref{Calling Functions,
apply-partially}を参照)。

@item
@code{advice-add}を使用して定義された関数(@ref{Advising Named Functions}を参照)。

@item
コードの一部として引数リストを直接判断する関数。
@end itemize

@end defun

@noindent
@code{functionp}と異なり、以下の関数はシンボルをそれの関数定義としては@emph{扱いません}。

@defun subrp object
この関数は@var{object}がビルトイン関数(たとえばLispプリミティブ)なら@code{t}をリターンする。

@example
@group
(subrp 'message)            ; @r{@code{message}はシンボルであり、}
     @result{} nil                 ;   @r{subrオブジェクトではない}
@end group
@group
(subrp (symbol-function 'message))
     @result{} t
@end group
@end example
@end defun

@defun byte-code-function-p object
この関数は@var{object}がバイトコード関数なら@code{t}をリターンする。たとえば:

@example
@group
(byte-code-function-p (symbol-function 'next-line))
     @result{} t
@end group
@end example
@end defun

@defun compiled-function-p object
この関数は@var{object}がELispソースコード形式ではなくても、何らかのマシンコードやバイトコードなら@code{t}をリターンする。より正しくは、ビルドイン関数(別名``プリミティブ(primitive)''。@ref{What
Is a Function}を参照)、バイトコンパイル済み関数(@ref{Byte
Compilation}を参照)、ネイティブコンパイル済み関数(@ref{Native
Compilation}を参照)、またはダイナミックモジュールからロードされた関数(@ref{Dynamic
Modules}を参照)の場合に@code{t}をリターンする。
@end defun

@defun interpreted-function-p object
この関数は@var{object}がインタープリターによって解釈される関数なら@code{t}をリターンする。たとえば:
@end defun

@defun closurep object
この関数は@var{object}がクロージャ(特殊な関数オブジェクト)なら@code{t}をリターンする。現在のところすべてのバイトコード関数、およびインタープリターに解釈されるすべての関数にたいしてクロージャが使用されている。
@end defun

@defun subr-arity subr
これは@code{func-arity}と同様だがシンボルインダイレクションなしのビルトイン関数にたいしてのみ機能する。非ビルトイン関数にたいしてはエラーをシグナルする。かわりに@code{func-arity}の使用を推奨する。
@end defun

@defun cl-functionp object
この関数は@code{functionp}と似ているが、リストとシンボルにたいして@code{nil}リターンする点が異なる。
@end defun

@findex subr-primitive-p
@defun primitive-function-p object
この関数は@var{object}がCで記述されたビルトインのプリミティブ(@ref{Primitive Function
Type}を参照)であれば@code{t}をリターンする。スペシャルフォームは関数ではないので、明確に除外されることに注意。スペシャルフォームも同じように認識したければ、@code{subr-primitive-p}を使うこと。
@end defun


@node Lambda Expressions
@section ラムダ式
@cindex lambda expression

  ラムダ式(lambda expression)はLispで記述された関数オブジェクトです。以下は例です:

@example
(lambda (x)
  "Xの双曲線コサインをreturnする"
  (* 0.5 (+ (exp x) (exp (- x)))))
@end example

@noindent
Emacs Lispではこのようなリストは、関数オブジェクトに評価される有効な式です。

  ラムダ式自身は名前をもたない@dfn{無名関数(anonymous
function)}です。ラムダ式をこの方法で使用できますが(@ref{Anonymous
Functions}を参照)、@dfn{名前付き関数(named
functions)}を作成するためにシンボルに関連付けられる方が一般的です(@ref{Function
Names}を参照)。これらの詳細に触れる前に以下のサブセクションではラムダ式の構成要素と、それらが行うことについて説明します。

@menu
* Lambda Components::        ラムダ式のパーツ。
* Simple Lambda::            シンプルな例。
* Argument List::            引数リストの詳細と特別な機能。
* Function Documentation::   関数内にドキュメントを記述する方法。
@end menu

@node Lambda Components
@subsection ラムダ式の構成要素

  ラムダ式は以下のようなリストです:

@example
(lambda (@var{arg-variables}@dots{})
  [@var{documentation-string}]
  [@var{interactive-declaration}]
  @var{body-forms}@dots{})
@end example

@cindex lambda list
  ラムダ式の1番目の要素は常にシンボル@code{lambda}です。これはそのリストが関数を表すことを示します。@code{lambda}で関数定義を開始する理由は、別の目的での使用が意図された他のリストが、意図せずに関数として評価されないようにするためです。

  2番目の要素はシンボル --- 引数変数名のリストです(@ref{Argument List}を参照)。これは@dfn{ラムダリスト(lambda
list)}と呼ばれます。Lisp関数が呼び出されたとき、引数値はラムダリスト内の変数と対応付けされます。ラムダリストには、与えられた値にたいするローカルバインディングが付与されます。@ref{Local
Variables}を参照してください。

  ドキュメント文字列(documentation string)はEmacs
Lispのヘルプ機能にたいして、その関数を説明する関数定義に配されたLispの文字列オブジェクトです。@ref{Function
Documentation}を参照してください。

  インタラクティブ宣言(interactive declaration)は、@code{(interactive
@var{code-string})}という形式のリストです。これはこの関数が対話的に使用された場合に引数を提供する方法を宣言します。この宣言をもつ関数は、@dfn{コマンド(command)}と呼ばれます。コマンドは@kbd{M-x}を使用したり、キーにバインドして呼び出すことができます。この方法で呼び出されることを意図しない関数は、インタラクティブ宣言を持つべきではありません。インタラクティブ定義を記述する方法は、@ref{Defining
Commands}を参照してください。

@cindex body of function
  残りの要素はその関数の@dfn{body(本体)} ---
その関数が処理を行うためのLispコード(Lispプログラマーは``評価されるLispフォームのリスト''と言うだろう)です。この関数からリターンされる値は、bodyの最後の要素によりリターンされる値です。

@node Simple Lambda
@subsection 単純なラムダ式の例

  以下の例を考えてみてください:

@example
(lambda (a b c) (+ a b c))
@end example

@noindent
以下のように@code{funcall}に渡すことにより、この関数を呼び出すことができます:

@example
@group
(funcall (lambda (a b c) (+ a b c))
         1 2 3)
@end group
@end example

@noindent
この呼び出しは変数@code{a}に1、@code{b}に2、@code{c}に3をバインドして、ラムダ式のbodyを評価します。bodyの評価によってこれら3つの数が加算されて、6が結果として生成されます。したがってこの関数呼び出しにより6がリターンされます。

  以下のように引数は他の関数の結果であってもよいことに注意してください:

@example
@group
(funcall (lambda (a b c) (+ a b c))
         1 (* 2 3) (- 5 4))
@end group
@end example

@noindent
これは引数@code{1}、@code{(* 2 3)}、@code{(- 5
4)}を左から右に評価します。その後ラムダ式に引数1、6、1を適用して値8が生成されます。

  これらの例が示すように、ローカル変数を作成してそれらに値を与えるフォームとして、@sc{car}がラムダ式であるようなフォームを使用することができます。古い時代のLispでは、この方法がローカル変数をバインドして初期化する唯一の方法でした。しかし現在ではこの目的にはフォーム@code{let}を使用するほうが明解です(@ref{Local
Variables}を参照)。ラムダ式は主に他の関数の引数として渡される無名関数(@ref{Anonymous
Functions}を参照)として、あるいは名前つき関数(@ref{Function
Names}を参照)を生成するためにシンボルの関数定義に格納するために使用されます。

@node Argument List
@subsection 引数リストの機能
@kindex wrong-number-of-arguments
@cindex argument binding
@cindex binding arguments
@cindex argument lists, features

  シンプルなサンプル関数@code{(lambda (a b c) (+ a b
c))}は3つの引数変数を指定しているので、3つの引数で呼び出されなければなりません。引数を2つしか指定しなかったり4つ指定した場合には@code{wrong-number-of-arguments}エラーとなります(@ref{Errors}を参照)。

  特定の引数を省略できる関数を記述できると便利なこともあります。たとえば関数@code{substring}は3つの引数 ---
文字列、開始インデックス、終了インデックス ---
を受け取りますが、3つ目の引数を省略すると、デフォルトでその文字列の@var{length}となります。関数@code{list}や@code{+}が行うように、特定の関数にたいして不定個の引数を指定できると便利なときもあります。

@cindex optional arguments
@cindex rest arguments
@kindex &optional
@kindex &rest
  関数が呼び出されるとき省略されるかもしれないオプションの引数を指定するには、オプションの引数の前にキーワード@code{&optional}を含めるだけです。0個以上の追加引数のリストを指定するには、最後の引数の前にキーワード@code{&rest}を含めます。

  したがって引数リストの完全な構文は以下のようになります:

@example
@group
(@var{required-vars}@dots{}
 @r{[}&optional @r{[}@var{optional-vars}@dots{}@r{]}@r{]}
 @r{[}&rest @var{rest-var}@r{]})
@end group
@end example

@noindent
角カッコ(square bracket)は@code{&optional}と@code{&rest}、およびそれらに続く変数が省略できることを示します。

  この関数の呼び出しでは@var{required-vars}のそれぞれにたいして、実際の引数が要求されます。0個以上の@var{optional-vars}にたいして実際の引数があるかもしれませんが、ラムダ式が@code{&rest}を使用していなければ、その個数を超えて実際の引数を記述することはできません。@code{&rest}が記述されていれば、追加で任意の個数の実際の引数があるかもしれません。

  optionalやrest変数にたいして実際の引数が省略されると、それらのデフォルトは常に@code{nil}になります。関数にたいして引数に明示的に@code{nil}が使用されたのか、引数が省略されたのかを区別することはできません。しかし関数のbodyが、@code{nil}を他の有意な値が省略されたと判断することは自由です。@code{substring}はこれを行います。@code{substring}の3つ目の引数が@code{nil}なら、それは文字列の長さを使用することを意味します。

@cindex CL note---default optional arg
@quotation
@b{Common Lispに関する注意:} Common Lispではオプションの引数が省略されたときに使用するデフォルト値を指定できる。Emacs
Lispでは、引数が明示的に渡されたかを調べる@code{supplied-p}変数はサポートされない。
@end quotation

  例えば引数リストは以下のようになります:

@example
(a b &optional c d &rest e)
@end example

@noindent
これは@code{a}と@code{b}は最初の2つの実引数となり、これらは必須です。さらに1つまたは2つの引数が指定された場合には、それらは順番に@code{c}と@code{d}にバインドされます。1つ目から4つ目の引数の後の引数はリストにまとめられて、@code{e}にそのリストがバインドされます。したがって2つしか引数が指定されなかった場合には@code{c}、@code{d}、@code{e}は@code{nil}になります。2つまたは3つの引数の場合には@code{d}と@code{e}は@code{nil}です。引数が4つ以下の場合には、@code{e}は@code{nil}になります。正確に5つの引数に明示的に@code{nil}が指定された場合には、@code{e}にたいして他の単一値が与えられたときのように、引数の@code{nil}が1要素のリスト@code{(nil)}として@code{e}に与えられます。

  オプションの引数の後ろに必須の引数を指定する方法はありません ---
これは意味を成さないからです。なぜそうなるかは、この例で@code{c}がオプションで@code{d}が必須な場合を考えてみてください。実際に3つの引数が与えられたとします。3番めの引数は何を指定したのでしょうか?
この引数は@var{c}なのでしょうか、それとも@var{d}に使用されるのでしょうか?
両方の場合が考えられます。同様に@code{&rest}引数の後に、さらに引数(必須またはオプション)をもつことも意味を成しません。

  以下に引数リストと、それを正しく呼び出す例をいくつか示します:

@example
(funcall (lambda (n) (1+ n))        ; @r{1つの必須:}
         1)                         ; @r{これは正確に1つの引数を要求する}
     @result{} 2
(funcall (lambda (n &optional n1)   ; @r{1つは必須で、1つはオプション:}
           (if n1 (+ n n1) (1+ n))) ; @r{1つまたは2つの引数}
         1 2)
     @result{} 3
(funcall (lambda (n &rest ns)       ; @r{1つは必須で、後は残り:}
           (+ n (apply '+ ns)))     ; @r{1つ以上の引数}
         1 2 3 4 5)
     @result{} 15
@end example

@node Function Documentation
@subsection 関数のドキュメント文字列
@cindex documentation string of function
@cindex function's documentation string

  ラムダ式はラムダリストの直後に、オプションで@dfn{ドキュメント文字列(documentation
string)}をもつことができます。この文字列は、その関数の実行に影響を与えません。これはコメントの一種ですがLisp機構に内在するシステム化されたコメントであり。Emacsのヘルプ機能で使用できます。ドキュメント文字列にアクセスする方法は、@ref{Documentation}を参照してください。

  たとえその関数があなたのプログラム内だけで呼び出される関数だとしても、すべての関数にドキュメント文字列を与えるのはよいアイデアです。ドキュメント文字列はコメントと似ていますが、コメントより簡単にアクセスできます。

  ドキュメント文字列の1行目は、関数自体にもとづくものであるべきです。なぜなら@code{apropos}は、最初の1行目だけを表示するからです。ドキュメント文字列の1行目は、その関数の目的を要約する1つか2つの完全なセンテンスで構成されるべきです。

  ドキュメント文字列の開始は通常、ソースファイル内ではインデントされていますが、ドキュメント文字列の開始のダブルクォート文字の前にインデントのスペースがあるので、インデントはドキュメント文字列の一部にはなりません。ドキュメント文字列の残りの行がプログラムソース内で揃うようにインデントする人がいます。@emph{これは間違いです}。後続の行のインデントは文字列の内部にあります。これはソースコード内での見栄えはよくなりますが、ヘルプコマンドで表示したとき見栄えが悪くなります。

  ドキュメント文字列は常に少なくとも1つのLisp式の後に続けて記述しなければなりません。そうしないとそれはドキュメント文字列ではなくbodyの単独の式であり、リターン値として使用されることになります。関数からリターンするべき有意義な値が存在しない場合には、ドキュメント文字列の後に@code{nil}を付加してリターンするのが標準的な方法です。

  ドキュメント文字列の最後の行には、実際の関数引数とは異なる呼び出し規約を指定できます。これは以下のようなテキストを記述します

@example
\(fn @var{arglist})
@end example

@noindent
そのテキストの後に空行を配置して、テキスト自身は行頭から記述、ドキュメント文字列内でこのテキストの後に改行が続かないように記述します(@samp{\}はEmacsの移動コマンドが混乱するのを避けるために使用する)。この方法で指定された呼び出し規約は、ヘルプメッセージ内で関数の実引数から生成される呼び出し例と同じ場所に表示されます。

  マクロ定義内に記述された引数は、ユーザーがマクロ呼び出しの一部だと考える方法とは合致しない場合がしばしばあるので、この機能はマクロ定義で特に有用です。

  呼び出し規約を廃止して上記の仕様で示す規約を公開したければ、この機能を使用してはなりません。かわりに廃止された呼び出し規約を使用するLispプログラムのバイトコンパイル時に警告メッセージを発する宣言@code{advertised-calling-convention}
(@ref{Declare Form}を参照)か@code{set-advertised-calling-convention}
(@ref{Obsolete Functions}を参照)を使用してください。

@ifnottex
@code{(fn)}機能が使用される典型的な状況には以下が考えられます:

@itemize @minus
@item マクロまたは関数の引数と目的の詳細な説明。たとえば:

@example
(defmacro lambda (&rest cdr)
  "@dots{}
\(fn ARGS [DOCSTRING] [INTERACTIVE] BODY)"@dots{})
@end example

@item 定義されるマクロの詳細な説明と引数名。たとえば:

@example
(defmacro macroexp--accumulate (var+list &rest body)
  "@dots{}
\(fn (VAR LIST) BODY@dots{})"
  (declare (indent 1))
  (let ((var (car var+list))
	  (list (cadr var+list))
@dots{})))
@end example

@item @code{defalias}の目的についてのより詳細な説明。たとえば:

@example
(defalias 'abbrev-get 'get
  "@dots{}
\(fn ABBREV PROP)")
@end example
@end itemize
@end ifnottex

@cindex computed documentation string
@kindex :documentation
ドキュメント文字列は通常だと静的ですが、動的な生成を要するときもあるかもしれません。コンパイル時にドキュメント文字列と一緒に関数コードを生成するマクロを記述することでこれを達成できる場合もあります。しかしドキュメント文字列のかわりに@code{(:documentation
@var{form})}を記述することで、doc文字列を動的に生成することもできます。これは実行時に関数が定義されると@var{form}を評価して、それをドキュメント文字列として使用します@footnote{@code{lexical-binding}を用いたコードでのみ機能します。}。関数のシンボルの@code{function-documentation}プロパティに文字列に評価されるLispフォームをセットすれば、オンザフライでドキュメント文字列を算出することもできます。

たとえば:
@example
@group
(defun adder (x)
  (lambda (y)
    (:documentation (format "Add %S to the argument Y." x))
    (+ x y)))
(defalias 'adder5 (adder 5))
(documentation 'adder5)
    @result{} "Add 5 to the argument Y."
@end group

@group
(put 'adder5 'function-documentation
     '(concat (documentation (symbol-function 'adder5) 'raw)
              "  Consulted at " (format-time-string "%H:%M:%S")))
(documentation 'adder5)
    @result{} "Add 5 to the argument Y.  Consulted at 15:52:13"
(documentation 'adder5)
    @result{} "Add 5 to the argument Y.  Consulted at 15:52:18"
@end group
@end example

@node Function Names
@section 関数の命名
@cindex function definition
@cindex named function
@cindex function name

  シンボルは関数の名前となることができます。これはそのシンボルの@dfn{関数セル(function cell}: @ref{Symbol
Components}を参照)が、関数オブジェクト(たとえばラムダ式)を含むときに起こります。するとそのシンボル自身が呼び出し可能な有効な関数、つまりそのシンボルの関数セルの関数と等価になります。

  関数セルの内容はそのシンボルの@dfn{関数定義(function
definition)}と呼ぶこともできます。そのシンボルのかわりにシンボルの関数定義を使う手続きのことを@dfn{シンボル関数インダイレクション(symbol
function indirection)}と呼びます。@ref{Function
Indirection}を参照。与えられたシンボルに関数定義がなければシンボルの関数セルは@dfn{void}と呼ばれ、それを関数として使用することはできません。

  実際のところほとんどすべての関数は名前をもち、その名前により参照されます。ラムダ式を定義することで名前つきのLisp関数を作成、それを関数セル(@ref{Function
Cells}を参照)に置くことができます。しかしより一般的なのは@code{defun}マクロ(次のセクションで説明)を使う方法です。
@ifnottex
@ref{Defining Functions}を参照してください。
@end ifnottex

  わたしたちが関数に名前を与えるのは、Lisp式内で関数を名前で参照するのが便利だからです。また名前つきの関数は簡単に自分自身を ---
再帰的(recursive)に参照することができます。さらにプリミティブはテキスト的な名前だけで参照することができます。なぜならプリミティブ関数は入力構文(read
syntax)をもたないオブジェクトだからです(@ref{Primitive Function Type}を参照)。

  関数が一意な名前をもつ必要はありません。与えられた関数オブジェクトは@emph{通常}は1つのシンボルの関数セルだけに存在しますが、これは単に慣習的なものです。@code{fset}を使用すれば関数を複数のシンボルに格納するのは簡単です。それらのシンボルはそれぞれ、同じ関数にたいする有効な名前となります。

  関数として使用しているシンボルを、変数としても利用できることに注意してください。シンボルのこれら2つの利用法は独立しており、競合はしません(これはSchemaのような他のいくつかのLisp方言には当てはまらない)。

  慣例により関数のシンボルが@samp{--}で分割される2つの名前で構成される場合には、その関数は内部的な使用を意図しており、名前の最初の部分は関数を定義するファイルです。たとえば@code{vc-git--rev-parse}という名前の関数は@file{vc-git.el}で定義される内部関数です。Cで記述された内部関数は@code{bury-buffer-internal}のように名前が@samp{-internal}で終わります。2018年より前に貢献されたEmacsコードは内部的な使用にたいして別の命名規約を使用するかもしれませんが、これらは徐々に廃止されます。

@node Defining Functions
@section 関数の定義
@cindex defining a function

  わたしたちは通常は関数を最初に作成したときに名前を与えます。これは@dfn{関数の定義(defining a
function)}と呼ばれており、通常は@code{defun}マクロにより行われます。このセクションでは関数を定義する別の方法も説明します。

@defmac defun name args [doc] [declare] [interactive] body@dots{}
@code{defun}は新たなLisp関数を定義する通常の方法である。これは引数リスト@var{args}、および@var{body}により与えられるbodyフォームとともに、シンボル@var{name}を関数として定義する(@ref{Argument
List}を参照)。@var{name}と@var{args}をクォートする必要はない。

@var{doc}が与えられたら、それはその関数のドキュメント文字列を指定する文字列であること(@ref{Function
Documentation}を参照)。@var{declare}が与えられたら、それは関数のメタデータを指定する@code{declare}フォームであること(@ref{Declare
Form}を参照)。@var{interactive}が与えられたら、それは関数が対話的に呼び出される方法を指定する@code{interactive}フォームであるこ(@ref{Interactive
Call}を参照)。

@code{defun}のリターン値は定義されていません。

以下にいくつか例を示す:

@example
@group
(defun foo () 5)
(foo)
     @result{} 5
@end group

@group
(defun bar (a &optional b &rest c)
    (list a b c))
(bar 1 2 3 4 5)
     @result{} (1 2 (3 4 5))
@end group
@group
(bar 1)
     @result{} (1 nil nil)
@end group
@group
(bar)
@error{} Wrong number of arguments.
@end group

@group
(defun capitalize-backwards ()
  "Upcase the last letter of the word at point."
  (interactive)
  (backward-word 1)
  (forward-word 1)
  (backward-char 1)
  (capitalize-word 1))
@end group
@end example

@cindex defining functions dynamically
Emacsの関数のほとんどはLispプログラムのソースコードの一部であり、実行前にEmacs
Lispリーダーがプログラムソースを読み込んだ際に定義される。しかし実行時にダイナミックに関数を定義することもできる(プログラムのコード実行時に@code{defun}呼び出しを生成する)。関数の定義にジャンプするボタンを@file{*Help*}バッファーに表示する@kbd{C-h
f}のようなEmacsのヘルプコマンドが、ソースコードを発見できないかもしれないので、これを行う際には注意を要する。なぜなら関数のダイナミックな生成は、@code{defun}にたいする通常の静的な呼び出しと比べて普通は非常に異なって見えるからである。このような関数を生成するコードを見つける作業を容易にするために@code{definition-name}プロパティを用いることができる。@ref{Standard
Properties}を参照のこと。

@cindex override existing functions
@cindex redefine existing functions
意図せず既存の関数を再定義しないように注意されたい。@code{defun}は@code{car}のようなプリミティブ関数でさえ、問い合わせせずに躊躇なく再定義する。Emacsがこれを妨げることはない。なぜなら関数の再定義は故意に行われることがあり、そのような意図した再定義を、意図しない再定義と見分ける方法はがないからである。
@end defmac

@cindex function aliases
@cindex alias, for functions
@defun defalias name definition &optional doc
@anchor{Definition of defalias}
この関数は定義が@var{definition}であるような関数としてシンボル@var{name}を定義する。@var{definition}には有効な任意のLisp関数、マクロ、スペシャルフォーム(@ref{Special
Forms}を参照)、キーマップ(@ref{Keymaps}を参照)、ベクター、文字列(キーボードマクロ)を指定できる。@code{defalias}のリターン値は@emph{未定義}。

@var{doc}が非@code{nil}なら、それは関数@var{name}のドキュメントとなる。それ以外なら@var{definition}により提供されるドキュメントが使用される。

@cindex defalias-fset-function property
内部的には@code{defalias}は、通常は定義のセットに@code{fset}を使用する。しかし@var{name}が@code{defalias-fset-function}プロパティをもつなら、@code{fset}を呼び出すかわりにそれに割り当てられた値を使用する。

@code{defalias}を使う正しい場所は、特定の関数やマクロの名前が正に定義される場所 ---
特にソースファイルがロードされるときに明示的にその名前が出現する場所である。これは@code{defalias}が@code{defun}と同じように、どれが関数を定義するファイルなのか記録するからである(@ref{Unloading}を参照)。

それとは対照的に他の目的のために関数を操作するプログラムでは、そのような記録を保持しない@code{fset}を使用するほうがよいだろう。@ref{Function
Cells}を参照のこと。

結果として得られた関数定義のチェーンが循環している場合には、Emacsは@code{cyclic-function-indirection}エラーをシグナルする。
@end defun

@defun function-alias-p object
@var{object}が関数のエイリアス(alias: 別名)かどうかをチェックする。エイリアスならその関数のエイリアスのチェーン(chain:
連鎖)を表すシンボルのリスト、エイリアスでなければ@code{nil}をリターンする。たとえば@code{a}が@code{b}のエイリアスで、@code{b}が@code{c}のエイリアスなら:

@example
(function-alias-p 'a)
    @result{} (b c)
@end example

2つ目のオプション引数も存在するが廃止されており効果はない。
@end defun

  @code{defun}や@code{defalias}で新たなプリミティブ関数を作成することはできませんが、任意の関数定義を変更するのに使用することができ、通常の定義がプリミティブである@code{car}や@code{x-popup-menu}のような関数でさえ変更することができます。しかしこれは危険なことです。たとえばLispの完全性を損なうことなく、@code{car}を再定義するのはほとんど不可能だからです。それほど有名ではない@code{x-popup-menu}のような関数の再定義では、危険は減少しますが、それでも期待したとおりに機能しないかもしれません。Cコードにそのプリミティブの呼び出しがあれば、それは直接そのプリミティブのC定義を呼び出すので、シンボル定義を変更してもそれらに影響はありません。

  @code{defsubst}も参照してください。これは@code{defun}のように関数を定義して、それのインライン展開を処理するようLispコンパイラーに指示します。@ref{Inline
Functions}を参照してください。

  関数名を未定義にするには@code{fmakunbound}を使用します。@ref{Function Cells}を参照してください。

@node Calling Functions
@section 関数の呼び出し
@cindex function invocation
@cindex calling a function

  関数を定義しただけでは半分しか終わっていません。関数はそれを@dfn{呼び出す(call)} ---
たとえば実行(run)するまでは何も行いません。関数のcallは@dfn{invocation}としても知られています。

  関数を呼び出すもっとも一般的な方法は、リストの評価によるものです。たとえばリスト@code{(concat "a"
"b")}を評価することにより、関数@code{concat}が引数@code{"a"}と@code{"b"}で呼び出されます。評価については@ref{Evaluation}を参照してください。

  プログラム内で式としてリストを記述するときは、プログラム内にテキストでどの関数を呼び出すか、いくつの引数を与えるかを指定します。通常はこれが行いたいことです。どの関数を呼び出すかを実行時に計算する必要がある場合もあります。これを行うには関数@code{funcall}を使用します。実行時にいくつの引数を渡すか決定する必要があるときは@code{apply}を使用します。

@defun funcall function &rest arguments
@code{funcall}は関数@var{function}を引数@var{arguments}で呼び出して、@var{function}がリターンした値をリターンする。

@code{funcall}は関数なので、@var{function}を含むすべての引数は@code{funcall}の呼び出し前に評価される。これは呼び出される関数を得るために任意の式を使用できることを意味している。また@code{funcall}が@var{arguments}に記述した式ではなく、その値だけを見ることを意味している。これらの値は@var{function}呼び出し中では、2回目は@emph{評価されない}。@code{funcall}の処理は関数の通常の呼び出し手続きと似ており、すでに評価された引数は評価されない。

引数@var{function}はLisp関数かプリミティブ関数でなければならない。つまりスペシャルフォームやマクロは、未評価の引数式を与えられたときだけ意味があるので、指定することはできない。上述したように最初の場所で@code{funcall}がそれらを知らないので、@code{funcall}がそれらを提供することはできない。

コマンドの呼び出しに@code{funcall}を使用して、それがインタラクティブに呼び出されたように振る舞うようにする必要があるなら、@code{funcall-interactively}を使用すること(@ref{Interactive
Call}を参照)。

@example
@group
(setq f 'list)
     @result{} list
@end group
@group
(funcall f 'x 'y 'z)
     @result{} (x y z)
@end group
@group
(funcall f 'x 'y '(z))
     @result{} (x y (z))
@end group
@group
(funcall 'and t nil)
@error{} Invalid function: #<subr and>
@end group
@end example

これらの例を@code{apply}の例と比較されたい。
@end defun

@defun apply function &rest arguments
@code{apply}は関数@var{function}を引数@var{arguments}で呼び出す。これは@code{funcall}と同様だが1つ違いがある。@var{arguments}の最後はオブジェクトのリストである。これは1つのリストではなく、個別の引数として@var{function}に渡される。わたしたちはこれを、@code{apply}がこのリストを@dfn{展開(spread)}(個々の要素が引数となるので)すると言う。

単一の引数での@code{apply}は特別である。引数(非空のリスト)の最初の要素は、残りの要素を個別の引数に関数として呼び出される。2つ以上の引数を渡すほうが早くなるだろう。

@code{apply}は@var{function}を呼び出した結果をリターンする。@code{funcall}と同様、@var{function}はLisp関数かプリミティブ関数でなければならない。つまりスペシャルフォームやマクロは@code{apply}では意味をもたない。

@example
@group
(setq f 'list)
     @result{} list
@end group
@group
(apply f 'x 'y 'z)
@error{} Wrong type argument: listp, z
@end group
@group
(apply '+ 1 2 '(3 4))
     @result{} 10
@end group
@group
(apply '+ '(1 2 3 4))
     @result{} 10
@end group

@group
(apply 'append '((a b c) nil (x y z) nil))
     @result{} (a b c x y z)
@end group

@group
(apply '(+ 3 4))
     @result{} 7
@end group
@end example

@code{apply}を使用した興味深い例は@ref{Definition of mapcar}を参照のこと。
@end defun

@cindex partial application of functions
@cindex currying
  ある関数にたいして、その関数のある引数を特定の値に固定して、他の引数は実際に呼びだされたときの値にできれば便利なことがあります。関数のいくつかの引数を固定することは、その関数の@dfn{部分適用(partial
application)}と呼ばれます@footnote{これは@dfn{カリー化(currying)}と関連しますが異なる機能です。カーリングは複数の引数を受け取る関数を、関数チェーンとして呼び出せるような１つの引数を取る個々の関数に変換するような方法です。}。これの結果は残りの引数をとる新たな関数で、すべての引数を合わせて元の関数を呼び出します。

  Emacs Lispで部分適用を行う方法を示します:

@defun apply-partially func &rest args
この関数は新たな関数をリターンする。この新しい関数は呼びだされたときに@var{args}、および呼び出し時に指定された追加の引数から成る引数リストで@var{func}を呼び出す関数である。@var{func}に@var{n}個の引数を指定できる場合、@w{@code{@var{m}
< @var{n}}}個の引数で@code{apply-partially}を呼び出すと、@w{@code{@var{n} -
@var{m}}}個の新たな関数を生成する@footnote{@var{func}が受け取ることができる引数の個数に制限がない場合には、新たな関数が受け取ることができる引数の個数も無制限になるので、このようなケースでは@code{apply-partially}は新たな関数が受け取ることができる引数の個数を減らしません。}。

以下はビルトイン関数@code{1+}が存在しないものとして、@code{apply-partially}と他のビルトイン関数@code{+}を使用して@code{1+}を定義する例である@footnote{ビルトイン関数とは異なり、このバージョンでは任意個数の引数を許容することに注意してください。}:

@example
@group
(defalias '1+ (apply-partially '+ 1)
  "Increment argument by one.")
@end group
@group
(1+ 10)
     @result{} 11
@end group
@end example
@end defun

@cindex functionals
  引数として関数を受け取ったり、データ構造(特にフック変数やプロパティリスト)から関数を探す関数はLispでは一般的で、それらは@code{funcall}や@code{apply}を使用してそれらの関数を呼び出します。引数として関数をとる関数は、@dfn{ファンクショナル(functional)}と呼ばれるときもあります。

  ファンクショナルを呼び出すとき、引数としてno-op関数(何も行わない関数)を指定できると便利なときがあります。以下に3つの異なるno-op関数を示します:

@defun identity argument
この関数は@var{argument}をリターンする。副作用はない。
@end defun

@defun ignore &rest arguments
この関数はすべての@var{arguments}を無視して@code{nil}をリターンする。
@end defun

@defun always &rest arguments
この関数はすべての@var{arguments}を無視して@code{t}をリターンする。
@end defun

  関数のいくつかはユーザーに可視な@dfn{コマンド}で、これらは(通常はキーシーケンスを介して)対話的に呼び出すことができます。そのようなコマンドは、@code{call-interactively}関数を使用することにより、対話的に呼びだされたときと同様に呼び出すことができます。@ref{Interactive
Call}を参照してください。

@node Mapping Functions
@section 関数のマッピング
@cindex mapping functions

  @dfn{マップ関数(mapping
function)}は与えられた関数(スペシャルフォームやマクロでは@emph{ない})をリストや他のコレクションの各要素に適用します。Emacs
Lispにはそのような関数がいくつかあります。このセクションではリストにたいしてマッピングを行う@code{mapcar}、@code{mapc}、@code{mapconcat}、@code{mapcan}を説明します。obarray内のシンボルにたいしてマッピングを行う関数@code{mapatoms}は@ref{Definition
of
mapatoms}を参照してください。ハッシュテーブル内のkey/value関係にたいしてマッピングを行う関数@code{maphash}は@ref{Definition
of maphash}を参照してください。

  これらのマップ関数は文字テーブル(char-table)には適用されません。なぜなら文字テーブルは非常に広い範囲の疎な配列だからです。疎な配列であるという性質に適う方法で文字テーブルにマッピングするには、関数@code{map-char-table}を使用します(@ref{Char-Tables}を参照)。

@defun mapcar function sequence
@anchor{Definition of mapcar}
@code{mapcar}は関数@var{function}を@var{sequence}の各要素にたいして順番に適用して、その結果をリストでリターンする。

引数@var{sequence}には、文字テーブルを除く任意の種類のシーケンス ---
つまりリスト、ベクター、ブールベクター、文字列を指定できる。結果は常にリストになる。結果の長さは@var{sequence}の長さと同じ。たとえば:

@example
@group
(mapcar #'car '((a b) (c d) (e f)))
     @result{} (a c e)
(mapcar #'1+ [1 2 3])
     @result{} (2 3 4)
(mapcar #'string "abc")
     @result{} ("a" "b" "c")
@end group

@group
;; @r{@code{my-hooks}内の各関数を呼び出す}
(mapcar 'funcall my-hooks)
@end group

@group
(defun mapcar* (function &rest args)
  "Apply FUNCTION to successive cars of all ARGS.
Return the list of results."
  ;; @r{リストが消費されていなければ}
  (if (not (memq nil args))
      ;; @r{@sc{car}に関数を適用する}
      (cons (apply function (mapcar #'car args))
            (apply #'mapcar* function
                   ;; @r{残りの要素のための再帰}
                   (mapcar 'cdr args)))))
@end group

@group
(mapcar* #'cons '(a b c) '(1 2 3 4))
     @result{} ((a . 1) (b . 2) (c . 3))
@end group
@end example
@end defun

@defun mapcan function sequence
この関数は@code{mapcar}のように@var{sequence}の各要素に@var{function}を適用するが、結果をリストに収集するかわりに結果を変更(@code{nconc}を使用。@pxref{Rearrangement}を参照)して結果のすべての要素を単一のリストでリターンする。@code{mapcar}と同様に@var{sequence}には文字テーブルを除く任意のタイプのシーケンスを指定できる。

@example
@group
;; @r{以下と:}
(mapcar #'list '(a b c d))
     @result{} ((a) (b) (c) (d))
;; @r{以下を比較してみよ:}
(mapcan #'list '(a b c d))
     @result{} (a b c d)
@end group
@end example
@end defun

@defun mapc function sequence
@code{mapc}は@code{mapcar}と似ているが、@var{function}は副作用のためだけに使用される ---
つまり@var{function}がリターンする値は無視されてリストに収集されない。@code{mapc}は常に@var{sequence}をリターンする。
@end defun

@defun mapconcat function sequence &optional separator
@code{mapconcat}は@var{sequence}のそれぞれの要素に@var{function}を適用する。結果は文字のシーケンス(文字列、ベクター、リスト)でなければならず、単一の文字列に結合されてリターン値となる。@code{mapconcat}は結果シーケーンスの各ペアの間に@var{separator}の文字を挿入する。これも文字列、または文字のベクターかリストでなければならない。@code{nil}値は空文字列として扱われる。@ref{Sequences
Arrays Vectors}を参照のこと。

引数@var{function}は1つの引数を受け取り文字のシーケンス、すなわち文字列、ベクター、リストのいずれかをリターンする。引数@var{sequence}は文字テーブル以外の任意の種類のシーケンス、すなわちリスト、ベクター、ブールベクター、または文字列を指定できる。

@example
@group
(mapconcat #'symbol-name
           '(The cat in the hat)
           " ")
     @result{} "The cat in the hat"
@end group

@group
(mapconcat (lambda (x) (format "%c" (1+ x)))
           "HAL-8000")
     @result{} "IBM.9111"
@end group
@end example
@end defun

@node Anonymous Functions
@section 無名関数
@cindex anonymous function

  関数は通常は@code{defun}により定義されて、同時に名前が与えられますが、明示的にラムダ式を使う --- @dfn{無名関数(anonymous
function)}のほうが便利なときもあります。無名関数は名前つき関数が有効な場所ならどこでも有効です。無名関数は変数や関数の引数に割り当てられることがよくあります。たとえばある関数をリストの各要素に適用する@code{mapcar}の@var{function}引数に渡すかもしれません(@ref{Mapping
Functions}を参照)。現実的な例は@ref{describe-symbols example}を参照してください。

  無名関数として使用するためのラムダ式を定義するとき通常はマクロ@code{lambda}、スペシャルフォーム@code{function}、または入力構文@code{#'}を使用するべきです。

@defmac lambda args [doc] [interactive] body@dots{}
このマクロは引数リスト@var{args}、(もしあれば)ドキュメント文字列@var{doc}、(もしあれば)インタラクティブ指定@var{interactive}、および@var{body}で与えられるbodyフォームをもつ無名関数をリターンする。

たとえばこのマクロは@code{lambda}フォームをほとんど自己クォートする。@sc{car}が@code{lambda}であるようなフォームはほとんどフォーム自身のような値を得る:

@example
(lambda (x) (* x x))
     @result{} #f(lambda (x) :dynbind (* x x))
@end example

レキシカルバインディングの下で評価した際には、結果は@code{:dynbind}マーカーをキャプチャーした変数に置き換えた、クロージャに似たオブジェクトになることに注意(@ref{Closures}を参照)。

@code{lambda}フォームは別の1つの効果をもつ。このマクロは@code{function}(以下参照)をサブルーチンとして使用することにより、Emacs評価機能(Emacs
evaluator)とバイトコンパイラーに、その引数が関数であることを告げる。
@end defmac

@defspec function function-object
@cindex function quoting
このスペシャルフォームは評価を行わずに@var{function-object}の関数値をリターンする。多くの点において@code{quote}(@ref{Quoting}を参照)と似ている。しかし@code{quote}とは異なり、Emacs評価機能とバイトコンパイラーに、これを関数として使用する意図を告げる役割をもつ。@var{function-object}が有効なラムダ式と仮定すると、これは２つの効果をもつ:

@itemize
@item
そのコードがバイトコンパイルされているとき、@var{function-object}はバイトコード関数オブジェクトにコンパイルされる(@ref{Byte
Compilation}を参照)。

@item
レキシカルバインドが有効なら@var{function-object}はクロージャに変換される。@ref{Closures}を参照のこと。
@end itemize

@var{function-object}がシンボルかつバイトコンパイル済みコードの場合には、その関数が未定義、あるいは実行時に認識されていなければバイトコンパイラーは警告を発する。
@end defspec

@cindex @samp{#'} syntax
入力構文@code{#'}は@code{function}の使用の略記です。以下のフォームは等価です:

@example
(lambda (x) (* x x))
(function (lambda (x) (* x x)))
#'(lambda (x) (* x x))
@end example

  以下の例では3つ目の引数に関数をとる@code{change-property}関数を定義して、その後の@code{change-property}で無名関数を渡してこれを使用しています:

@example
@group
(defun change-property (symbol prop function)
  (let ((value (get symbol prop)))
    (put symbol prop (funcall function value))))
@end group

@group
(defun double-property (symbol prop)
  (change-property symbol prop (lambda (x) (* 2 x))))
@end group
@end example

@noindent
@code{lambda}フォームをクォートしていないことに注意してください。

   上記のコードをコンパイルすると無名関数もコンパイルされます。リストをクォートすることにより無名関数を構築した場合にはコンパイルはされません。

@c Do not unquote this lambda!
@example
@group
(defun double-property (symbol prop)
  (change-property symbol prop '(lambda (x) (* 2 x))))
@end group
@end example

@noindent
この場合、無名関数はコンパイルされたコード内のラムダ式に保持されます。バイトコンパイラーは@code{change-property}が関数としての使用を意図していることを知ることができないので、たとえこの関数が関数のように見えるとしても、このリストが関数であると決め込むことができません。

@node Generic Functions
@section ジェネリック関数
@cindex generic functions
@cindex polymorphism

  @code{defun}を使用して定義された関数は、その引数の型と期待する値に関して、ハードコードされた一連の仮定をもちます。たとえば数字か数字のリストを引数値として処理するようにデザインされた関数は、ベクターや文字列のような他の型の値で呼び出されると失敗したりエラーをシグナルするでしょう。これはその関数実装が、デザイン時に想定した以外の型に対応しないために発生します。

  対照的に@dfn{多相型関数(polymorphic
functions)}を使用したオブジェクト指向プログラムでは、同一の名前をもつ一連の特化した関数のそれぞれが、特定の引数型セットにたいして記述されます。どの関数が実際に呼び出されるかは、実際の引数の型にもとづいて実行時に決定されます。

@cindex CLOS
  Emacsはポリモーフィズム(polymorphism)にたいするサポートを提供します。他のLisp環境、特にCommon LispとCommon
Lispオブジェクトシステム(@acronym{CLOS})と同じように、このサポートは@dfn{ジェネリック関数(generic
functions)}を基礎としています。Emacsのジェネリック関数は同一名の使用を含む@acronym{CLOS}に密接にしたがっているので、@acronym{CLOS}の経験があればこのセクションの残りの部分は非常に身近に感じるでしょう。

  ジェネリック関数は、その名前と引数のリストを指定して、(通常は)実装されていない抽象操作(abstract
operation)を指定します。引数のいくつかの固有クラスにたいする実際の実装は@dfn{メソッド(methods)}により提供され、これは個別に定義されるべきです。ジェネリック関数を実装するそれぞれのメソッドはジェネリック関数としてとして同じ名前をもちますが、そのジェネリック関数で定義された引数の@dfn{スペシャライジング(specializing)}により、メソッドの定義はどの種類の引数を処理可能かを示します。これらの@dfn{引数スペシャライザー(argument
specializers)}は多少の差はあれ特化したものにできます。たとえば@code{string}型は@code{sequence}のようなより一般的な型より特化した型です。

  C@t{++}やSimulaのようなメッセージベースのOO言語と異なり、ジェネリック関数を実装するメソッドはクラスに属さずに、それらが実装するジェネリック関数に属することに注意してください。

  ジェネリック関数が呼び出されると、呼び出し側に渡された実際の引数と各メソッドの引数スペシャライザーを比較することにより、適用可能なメソッドを呼び出します。その呼び出しの実際の引数がメソッドのスペシャライザーと互換性があれば、そのメソッドが適用可能です。複数のメソッドが適用可能ならば、それらは以下で説明する特定のルールにより合成されて、その組み合わせが呼び出しを処理します。

@defmac cl-defgeneric name arguments [documentation] [options-and-methods@dots{}] &rest body
このマクロは指定した@var{name}と@var{arguments}でジェネリック関数を定義する。@var{body}が与えられたなら、それは実装のデフォルトを与える。(常に与えられるべきであるが)@var{documentation}が与えられたなら、それは@code{(:documentation
@var{docstring})}の形式でそのジェネリック関数のドキュメント文字列を指定する。オプションの@var{options-and-methods}は以下のフォームのいずれかを指定できる:

@table @code
@item (declare @var{declarations})
@ref{Declare Form}で説明するようなdeclareフォーム。
@item (:argument-precedence-order &rest @var{args})
このフォームは適用可能なメソッド合成にたいするソート順に影響を与える。合成において2つのメソッドを比較する際、メソッドの引数は通常は左から右に試験されて、引数スペシャライザーがより特化した最初のメソッドが他のメソッドより前になる。このフォームで定義された順序はそれをオーバーライドして、左から右ではなくこのフォームの順に応じて試験される。
@item (:method [@var{qualifiers}@dots{}] args &rest body)
このメソッドは@code{cl-defmethod}が行うようなメソッドを定義する。
@end table
@end defmac

@defmac cl-defmethod name [extra] [qualifier] arguments [&context (expr spec)@dots{}] &rest [docstring] body
このマクロは@var{name}と呼ばれるジェネリック関数の、特定の実装を定義する。実装コードは@var{body}で与えられる。もし与えられたら@var{docstring}はそのメソッドのドキュメント文字列である。リスト@var{arguments}はジェネリック関数を実装するすべてのメソッドで等しく、その関数の引数リストとマッチしなければならず、@code{(@var{arg}
@var{spec})}という形式の引数スペシャライザーを提供する。ここで@var{arg}は@code{cl-defgeneric}呼び出しで指定された引数名、@var{spec}は以下のスペシャライザーフォームのいずれかであること:

@table @code
@item @var{type}
このスペシャライザーは、引数が@var{type}のいずれかであることを要求する。@var{type}は以下で説明する型ヒエラルキーのいずれかの型である。
@item (eql @var{object})
このスペシャライザーは、引数が@var{object}と@code{eql}であることを要求する。
@item (head @var{object})
引数は@code{car}が@var{object}と@code{eql}であるようなコンスセルでなければならない。
@item @var{struct-type}
引数は@code{cl-defstruct} (@ref{Structures,,, cl, Common Lisp Extensions for
GNU Emacs
Lisp}を参照)で定義された@var{struct-type}という名前のクラス、またはその子クラスのインスタンスでなければならない。
@end table

メソッド定義は新たな引数リストのキーワード@code{&context}を使用できる。これはメソッド実行時に環境をテストする余分なスペシャライザーを導入する。このキーワードは必須の引数リストの後、かつすべての@code{&rest}と@code{&optional}キーワードの前に記述すること。@code{&context}スペシャライザーは正規の引数スペシャライザー(@var{expr}
@var{spec})と非常によく似ているが、@var{expr}はカレントコンテキストで評価される式であり、@var{spec}は比較対象となる値となる。たとえば@code{&context
(overwrite-mode (eql
t))}は、メソッドを@code{overwrite-mode}がオンのときだけ適用可能にする。@code{&context}キーワードの後には任意個数のコンテキストスペシャライザーを続けることができる。コンテキストスペシャライザーはジェネリック関数の引数signatureの一部ではないので、これらを必要としないメソッドでは省略できる。

型スペシャライザー@code{(@var{arg} @var{type})}は以下のリストの@dfn{システム型(system
types)}のいずれかを指定できる。親の型が指定されたときは、型がより特化した子型、孫型、曾孫型、...のいずれかであるような任意の引数も互換となるだろう。

@table @code
@item integer
親型: @code{number}。
@item number
@item null
親型: @code{symbol}。
@item symbol
@item string
親型: @code{array}。
@item array
親型: @code{sequence}。
@item cons
親型: @code{list}。
@item list
親型: @code{sequence}。
@item marker
@item overlay
@item float
親型: @code{number}。
@item window-configuration
@item process
@item window
@item subr
@item compiled-function
@item buffer
@item char-table
親型: @code{array}。
@item bool-vector
親型: @code{array}。
@item vector
親型: @code{array}。
@item frame
@item hash-table
@item font-spec
@item font-entity
@item font-object
@end table

@samp{:extra
@var{string}}として表されるオプション要素@var{extra}によって、同一のspecializerとqualifierにたいして、@var{string}で区別されるメソッドを追加できる。

オプションの@var{qualifier}は複数の適用可能なメソッドの合成を許容する。与えられなければ定義されるメソッドは@dfn{primary(主)}メソッドとなり、スペシャライズされた引数にたいする主要な実装の提供に責任を有する。@var{qualifier}として以下の値のいずれかを使用して@dfn{auxiliary(副)}メソッドも定義できる:

@table @code
@item :before
このauxiliaryメソッドはprimaryメソッドの前に実行される。より正確にはすべての@code{:before}メソッドは、より特化したメソッドが最初になる順で、primaryメソッドの前に実行される。
@item :after
このauxiliaryメソッドはprimaryメソッドの後に実行される。より正確にはすべてのこの類のメソッドは、より特化したメソッドが最後になる順で、primaryメソッドの後に実行される。
@item :around
このauxiliaryメソッドはprimaryメソッドの@emph{代替え}として実行される。この類のメソッドでもっとも特化したものが他のメソッドより前に実行される。このようなメソッドは他のauxiliaryメソッドやprimaryメソッドを呼び出すために、通常は以下で説明する@code{cl-call-next-method}を使用する。
@end table

@code{cl-defmethod}を使用して定義した関数をインタラクティブにすることはできない。つまり@code{interactive}フォームを追加してコマンドにすることはできない(@ref{Defining
Commands}を参照)。多相型コマンド(polymorphic
command)が必要なら、@code{cl-defgeneric}と@code{cl-defmethod}を通じて定義した多相型関数(polymorphic
function)を呼び出す通常のコマンドを定義することを推奨する。
@end defmac

@cindex dispatch of methods for generic function
@cindex multiple-dispatch methods
ジェネリック関数が呼び出されると、毎回その関数にたいして定義された適用可能なメソッドを合成することによってその呼び出しを処理する@dfn{effectiveメソッド(effective
method)}を構築します。適用可能なメソッドを探してeffectiveメソッドを生成するプロセスは@dfn{dispatch}と呼ばれます。その呼び出しの実際の引数と互換性があるスペシャライザーをもつすべてのメソッドが、互換性のあるメソッドです。すべての引数がスペシャライザーと互換でなければならないので、それらはすべてメソッドが適用可能かどうか判定します。複数の引数に明示的に特化したメソッドを@dfn{multiple-dispatchメソッド(multiple-dispatch
methods)}と呼びます。

適用可能なメソッドはそれらが合成される順にソートされます。最左の引数スペシャライザーがもっとも特化したものであるようなメソッドが、順序の最初になります(上述したように@code{cl-defmethod}の一部として@code{:argument-precedence-order}を指定することによりこれをオーバーライドできる)。そのメソッドのbodyが@code{cl-call-next-method}を呼び出すと、もっとも特化した次のメソッドが実行されます。適用可能な@code{:around}メソッドがあれば、それらのうちもっとも特化したメソッドが実行されます。そのメソッドはより特化していない任意の@code{:around}メソッドを実行するために、@code{cl-call-next-method}を呼び出すべきです。次に@code{:before}メソッドがその特化した順に、その後にspecificityメソッドが実行されます。そして後に@code{:after}メソッドがその特化した順と逆順で実行されます。

@defun cl-call-next-method &rest args
primaryメソッドか@code{:around}
auxiliaryメソッド内のレキシカルbody内で呼び出されると、同じジェネリック関数にたいして適用可能な次のメソッドを呼び出す。通常これは引数なしで呼び出され、これは次の適用可能なメソッドを呼び出すメソッドが、呼び出されたときと同じ引数で次のメソッドを呼び出すことを意味する。それ以外ならかわりに指定された引数が使用される。
@end defun

@defun cl-next-method-p
primaryメソッドか@code{:around}
auxiliaryメソッドのレキシカルbody内からこの関数を呼び出したときに、呼び出す次のメソッドが存在すれば非@code{nil}をリターンする。
@end defun


@node Function Cells
@section 関数セルの内容へのアクセス

  シンボルの@dfn{関数定義(function
definition)}とは、そのシンボルの関数セルに格納されたオブジェクトのことです。ここではシンボルの関数セルへのアクセスやテスト、それをセットする関数を説明します。

  @ref{Definition of indirect-function}の関数@code{indirect-function}も参照してください。

@defun symbol-function symbol
@kindex void-function
これは@var{symbol}の関数セル内のオブジェクトをリターンする。これはリターンされたオブジェクトが本物の関数であるかチェックしない。

関数セルがvoidならリターン値は@code{nil}。関数セルがvoidのときと@code{nil}がセットされているときを区別するには@code{fboundp}(以下参照)を使用する。

@example
@group
(defun bar (n) (+ n 2))
(symbol-function 'bar)
     @result{} #f(lambda (n) [t] (+ n 2))
@end group
@group
(fset 'baz 'bar)
     @result{} bar
@end group
@group
(symbol-function 'baz)
     @result{} bar
@end group
@end example
@end defun

@cindex void function cell
  シンボルに何の関数定義も与えていなければ、そのシンボルの関数セルは@dfn{void}だと言います。言い換えると、その関数セルはどんなLispオブジェクトも保持しません。そのシンボルを関数として呼びだそうとすると、Emacsは@code{void-function}エラーをシグナルします。

  voidは@code{nil}やシンボル@code{void}とは異なることに注意してください。シンボル@code{nil}と@code{void}はLispオブジェクトであり、他のオブジェクトと同じように関数セルに格納することができます(@code{defun}で定義すれば@code{void}は有効な関数足り得る)。voidであるような関数セルは、どのようなオブジェクトも含んでいません。

  @code{fboundp}を使用して任意のシンボルの関数定義がvoidかどうかテストすることができます。シンボルに関数定義を与えた後は、@code{fmakunbound}を使用して再びvoidにすることができます。

@defun fboundp symbol
この関数はそのシンボルが関数セルにオブジェクトをもっていれば@code{t}、それ以外は@code{nil}をリターンする。これはそのオブジェクトが本物の関数であるかチェックしない。
@end defun

@defun fmakunbound symbol
この関数は@var{symbol}の関数セルをvoidにする。そのためこれ以降に関数セルへのアクセスを試みると、@code{void-function}エラーが発生する。これは@var{symbol}をリターンします(@ref{Void
Variables}の@code{makunbound}も参照)。

@example
@group
(defun foo (x) x)
(foo 1)
     @result{}1
@end group
@group
(fmakunbound 'foo)
     @result{} foo
@end group
@group
(foo 1)
@error{} Symbol's function definition is void: foo
@end group
@end example
@end defun

@defun fset symbol definition
この関数は@var{symbol}の関数セルに@var{definition}を格納する。結果は@var{definition}。@var{definition}は通常は関数か関数の名前であるべきだが、これはチェックされない。引数@var{symbol}は通常のどおり評価される引数である。

この関数は主に関数を定義したり変更して構築を行う、@code{defun}や@code{advice-add}のようなものからサブルーチンとして使用される。たとえばキーボードマクロ(@ref{Keyboard
Macros}を参照)のような、関数ではない関数定義をシンボルに与えるためにも使用することができる:

@example
;; @r{名前つきのキーボードマクロを定義する。}
(fset 'kill-two-lines "\^u2\^k")
     @result{} "\^u2\^k"
@end example

関数にたいして別の名前を作成するために@code{fset}を使いたいなら、かわりに@code{defalias}の使用を考慮すること。@ref{Definition
of defalias}を参照。

結果として得られた関数定義のチェーンが循環している場合には、Emacsは@code{cyclic-function-indirection}エラーをシグナルする。
@end defun

@node Closures
@section クロージャー

  @ref{Variable
Scoping}で説明したように、Emacsはオプションで変数のレキシカルバインディングを有効にできます。レキシカルバインディングが有効な場合は、(たとえば@code{defun}などで)作成したすべての名前つき関数、同様に@code{lambda}マクロや@code{function}スペシャルフォーム、@code{#'}構文を使用して作成したすべての無名関数(@ref{Anonymous
Functions}を参照)が、自動的に@dfn{クロージャ(closure)}に変換されます。

@cindex closure
  クロージャとはその関数が定義されたときに存在したレキシカル環境の記録をあわせもつ関数です。クロージャが呼び出されたとき、定義内のレキシカル変数の参照には、その保持されたレキシカル環境が使用されます。他のすべての点では、クロージャは通常の関数と同様に振る舞います。特にクロージャは通常の関数と同じ方法で呼び出すことができます。

  クロージャを使用する例は@ref{Lexical Binding}を参照してください。

  現在のところEmacs
Lispのクロージャオブジェクトは、1つ目の要素にシンボル@code{closure}をもつリストとして表現されます。そのリストは2つ目の要素としてレキシカル環境、残りの要素で引数リストとbodyフォームを表します:

@example
;; @r{レキシカルバインディングが有効}
(lambda (x) (* x x))
     @result{} #f(lambda (x) [t] (* x x))
@end example

@noindent
しかし実際にはクロージャの内部構造は、内部的な実装の詳細と判断される残りのLisp界を晒け出すものだと言えます。この理由により、クロージャオブジェクトの構造を直接調べたり変更することは推奨しません。

@node OClosures
@section オープンクロージャ
@cindex oclosures
@cindex open closures

  関数とは伝統的には呼び出し以外の機能を提供しない不透明なオブジェクトです。(Emacs
Lisp関数はdoc文字列や引数リスト、interactive仕様のようないくつかの情報を抽出できるので完全に不透明という訳ではないが、そのほとんどは依然として不透明である)。これはわたしたちの要望を通常は満たしていますが、関数自体に関する情報をもう少し公開する必要がある場合もあるでしょう。

  @dfn{オープンクロージャ(Open
closure)}、略して@dfn{OClosure}は追加のタイプ情報をもった関数オブジェクトであり、アクセッサ関数を通じてアクセス可能なスロット形式で自身の情報の一部を公開します。

 OClosureは2つのステップから定義されます。まず@code{oclosure-define}を使ってそのタイプのOClosuresがもつスロットを指定することにより新たなOClosureタイプを定義します。それから@code{oclosure-lambda}を使用して与えられたタイプのOClosureオブジェクトを作成するのです。

たとえばキーボードマクロ、すなわちキーイベントのシーケンスを再実行するインタラクティブな関数を定義したいとします(@ref{Keyboard
Macros}を参照)。これは以下のような普通の関数で行うことができます:

@example
(defun kbd-macro (key-sequence)
  (lambda (&optional arg)
    (interactive "P")
    (execute-kbd-macro key-sequence arg)))
@end example

@noindent
しかしこのような定義では関数から@var{key-sequence}を抽出して、たとえばプリントするといったようなことを簡単に行う方法はありません。

この問題は以下のようなOClosureを使えば解決できます。まずはキーボードマクロのタイプを定義します(ついでに@code{counter}スロットを追加することにします):

@example
(oclosure-define kbd-macro
  "Keyboard macro."
  keys (counter :mutable t))
@end example

@noindent
その後に@code{kbd-macro}関数の定義を書き換えることができます:

@example
(defun kbd-macro (key-sequence)
  (oclosure-lambda (kbd-macro (keys key-sequence) (counter 0))
      (&optional arg)
    (interactive "P")
    (execute-kbd-macro keys arg)
    (setq counter (1+ counter))))
@end example

@noindent
ご覧のとおり、このOClosureのスロット@code{keys}と@code{counter}には、OClosureのbodyからローカル変数としてアクセスすることができます。しかしOClosureのbody外部からもアクセスできるようになったのです。たとえばキーボードマクロをdescribeする関数は:

@example
(defun describe-kbd-macro (km)
  (if (not (eq 'kbd-macro (oclosure-type km)))
      (message "Not a keyboard macro")
    (let ((keys    (kbd-macro--keys km))
          (counter (kbd-macro--counter km)))
      (message "Keys=%S, called %d times" keys counter))))
@end example

@noindent
ここで@code{kbd-macro--keys}と@code{kbd-macro--counter}はタイプが@code{kbd-macro}であるようなoclosureのために、@code{oclosure-define}マクロによって生成されたアクセッサ関数です。

@defmac oclosure-define oname &optional docstring &rest slots
このマクロは@var{slots}のアクセッサ関数とともに、新たなOClosureタイプを定義する。@var{oname}はシンボル(新たなタイプの名前)、または@w{@code{(@var{oname}
.
@var{type-props})}}という形式のリスト。この場合の@var{type-props}はこのoclosureタイプの追加プロパティのリストである。@var{slots}はスロットを記述するリストであり、スロットはそれぞれシンボル(スロットの名前)、または@w{@code{(@var{slot-name}
.
@var{slot-props})}}という形式を指定できる。ここで@var{slot-props}は対応するスロット@var{slot-name}のプロパティリストである。@var{type-props}で指定するOClosureタイプのプロパティには以下を含めることができる:

@table @code
@item (:predicate @var{pred-name})
@var{pred-name}という名前の述語関数の作成をリクエストする。その関数はタイプ@var{oname}のOClosureの識別に使用される。このタイプのプロパティが未指定なら、@code{oclosure-define}はその述語にたいするデフォルト名を生成する。
@item (:parent @var{otype})
@c FIXME: Is the above description of :parent correct?
タイプ@var{otype}のOClosureをタイプ@var{oname}の親にする。タイプ@var{oname}のOClosureは親タイプで定義された@var{slots}を継承する。
@item (:copier @var{copier-name} @var{copier-args})
@dfn{copier}と呼ばれる機能更新関数を定義する。1つ目の引数にタイプ@var{oname}のOClosureを受け取り、@var{copier-args}という名前のスロット(@var{copier-name}の実際の呼び出し時には対応するはそれぞれ引数に渡された値が含まれるように変更される)をもつコピーをリターンする。
@end table

@code{oclosure-define}マクロが@var{slots}内のスロットそれぞれにたいして、@code{@var{oname}--@var{slot-name}}という名前で、スロットの値へのアクセスに使用できるアクセッサ関数を定義する。@var{slots}でのそれぞれのスロットの定義では、以下のスロットのプロパティを指定できる:

@table @code
@item :mutable @var{val}
@c FIXME: Some rationale and meaning of immutable slot is probably in
@c order here.
デフォルトではスロットはimmutable(変更不可、不変)だが、@code{:mutable}プロパティに非@code{nil}を指定すれば、たとえば@code{setf}
(@ref{Setting Generalized Variables}を参照)でスロットを変更できるようにmutable(変更可能)になる。
@item :type @var{val-type}
@c FIXME: What will happen if the value is of a different type? error?
そのスロットに期待される値のタイプを指定する。
@end table
@end defmac

@defmac oclosure-lambda (type . slots) arglist &rest body
このマクロはタイプ@var{type}の無名OClosureを作成する。@var{type}は@code{oclosure-define}によって定義されていること。@var{slots}は@w{@code{(@var{slot-name}
@var{expr})}}という形式の要素からなるリスト。実行時には@var{expr}が順に評価された後に、その結果の値によってスロットが初期化されたOClosureが作成される。

関数として呼び出された場合には(@ref{Calling
Functions}を参照)、このマクロによって作成されたOClosureは@var{arglist}に応じた引数を受け取り、@var{body}のコードを実行する。@var{body}からはあたかも静的スコープにキャプチャされたローカル変数のように任意のスロットの値を直接参照できる。
@end defmac

@defun oclosure-type object
この関数は@var{object}がOClosureであればそのOClosureタイプ(シンボル)そうでなければ@code{nil}をリターンする。
@end defun

他にもOClosureに関連する関数として@code{oclosure-interactive-form}があります。これは一部のOClosureタイプにたいしてダイナミックなinteractiveフォームの算出を可能にする関数です。@ref{Using
Interactive, oclosure-interactive-form}を参照してください。


@node Advising Functions
@section Emacs Lisp関数にたいするアドバイス
@cindex advising functions
@cindex piece of advice

他のライブラリーの関数定義を変更する必要があるとき、および@code{@var{foo}-function}oのようなフックやプロセスフィルター(process
filter)や、関数を値としてもつ任意の変数やオブジェクトを変更する必要があるときには、名前つきの関数には@code{fset}か@code{defun}、フック変数には@code{setq}、プロセスフィルターには@code{set-process-filter}のように、適切なセッター関数(setter
function)を使用することができます。しかしこれらが以前の値を完全に破棄してしまうのが好ましくない場合もあります。

  @dfn{アドバイス(advice)}機能によって@dfn{関数にアドバイス}することにより、既存の関数定義に機能を追加できます。これは関数全体を再定義するより明解な手法です。

Emacsのアドバイスシステムは2つのプリミティブセットを提供します。コアとなるセットは変数やオブジェクトのフィールドに保持された関数値にたいするものです(対応するプリミティブは@code{add-function}と@code{remove-function})。もう1つのセットは名前つき関数の最上位のレイヤーとなるものです(主要なプリミティブは@code{advice-add}と@code{advice-remove})。

簡単な例として、以下は関数の呼び出し時に毎回リターン値を変更するアドバイスを追加する方法です:

@example
(defun my-double (x)
  (* x 2))
(defun my-increase (x)
  (+ x 1))
(advice-add 'my-double :filter-return #'my-increase)
@end example

このアドバイスの追加後に@samp{3}で@code{my-double}を呼び出すとリターン値は@samp{7}になるでしょう。このアドバイスを削除するには、以下のようにします

@example
(advice-remove 'my-double #'my-increase)
@end example

より高度な例として、以下はプロセス@var{proc}のプロセスフィルターの呼び出しをトレースする例です:

@example
(defun my-tracing-function (proc string)
  (message "Proc %S received %S" proc string))

(add-function :before (process-filter @var{proc}) #'my-tracing-function)
@end example

これによりそのプロセスの出力は元のプロセスフィルターに渡される前に、@code{my-tracing-function}に渡されるようになります。@code{my-tracing-function}は元の関数と同じ引数を受け取ります。これを行えば以下のようにしてトレースを行う前の振る舞いにリバートすることができます。

@example
(remove-function (process-filter @var{proc}) #'my-tracing-function)
@end example

同様に@code{display-buffer}という名前つきの関数の実行をトレースしたいなら以下を使用できます:

@example
(defun his-tracing-function (orig-fun &rest args)
  (message "display-buffer called with args %S" args)
  (let ((res (apply orig-fun args)))
    (message "display-buffer returned %S" res)
    res))

(advice-add 'display-buffer :around #'his-tracing-function)
@end example

ここで@code{his-tracing-function}は元の関数のかわりに呼び出されて、元の関数(に加えてその関数の引数)を引数として受け取るので、必要な場合はそれを呼び出すことができます。出力を確認し終えたら、以下のようにしてトレースを行う前の振る舞いにリバートできます:

@example
(advice-remove 'display-buffer #'his-tracing-function)
@end example

上記の例で使用されている引数@code{:before}と@code{:around}は、2つの関数が構成される方法を指定します(これを行う多くの方法があるから)。追加された関数も@emph{アドバイス(advice)}と呼ばれます。

@menu
* Core Advising Primitives::  アドバイスを扱うプリミティブ。
* Advising Named Functions::  名前つき関数のアドバイス。
* Advice Combinators::       アドバイスを構成する方法。
* Porting Old Advice::       古いdefadviceを使用したコードの改良。
* Advice and Byte Code::     アドバイスできない関数。
@end menu

@node Core Advising Primitives
@subsection アドバイスを操作するためのプリミティブ
@cindex advice, add and remove

@defmac add-function where place function &optional props
このマクロは@var{place}(@ref{Generalized
Variables}を参照)に格納された関数に、アドバイス@var{function}を追加する手軽な方法である。

@var{where}は既存の関数のどこ --- たとえば元の関数の前や後 ---
に@var{function}が構成されるかを決定する。2つの関数を構成するために利用可能な方法のリストは、@ref{Advice
Combinators}を参照のこと。

(通常は名前が@code{-function}で終わる)変数を変更するときには、@var{function}がグローバルに使用されるか、あるいはカレントバッファーだけに使用されるか選ぶことができる。@var{place}が単にシンボルなら@var{function}は@var{place}のグローバル値に追加される。@var{place}が@code{(local
@var{symbol})}というフォームなら、@var{symbol}はその変数の名前をリターンする式なので、@var{function}はカレントバッファーだけに追加される。最後にレキシカル変数を変更したければ、@code{(var
@var{variable})}を使用する必要があるだろう。

@code{add-function}で追加されたすべての関数は、自動的にプロパティ@var{props}の連想リストに加えることができる。現在のところ特別な意味をもつのは以下の2つのプロパティのみ:

@table @code
@item name
これはアドバイスの名前を与える。この名前は@code{remove-function}が取り除く関数を識別するのに使用できます。これは通常は@var{function}が無名関数のときに使用されます。

@item depth
これは複数のアドバイスが与えられたときにアドバイスを順番づける方法を指定します。depthのデフォルト0です。depthが100のときにはアドバイスが可能な限りの深さを保持すべきことを、-100のときは最外のアドバイスに留めることを意味します。同じdepthで2つのアドバイスが指定された場合には、もっとも最近に追加されたアドバイスが最外になります。

@code{:before}アドバイスにたいしては、最外(outermost)になるということは、このアドバイスが他のすべてのアドバイスの前、つまり1番目に実行されることを意味し、最内(innermost)とは元の関数が実行される直前、すなわちこのアドバイスと元の関数の間に実行されるアドバイスは存在しないことを意味する。同様に@code{:after}アドバイスにたいしては、最内とは元の関数の直後、つまりこの元の関数とアドバイスの間に実行される他のアドバイスは存在せず、最外とは他のすべてのアドバイスが実行された直後にこのアドバイスが実行されることを意味する。@code{:override}の最内アドバイスは、元の関数だけをオーバーライドし、他のアドバイスはそれに適用されるが、@code{:override}の最外アドバイスは元の関数だけではなく、その他すべての適用済みのアドバイスをも同様にオーバーライドする。
@end table

@var{function}がインタラクティブでなければ合成された関数は、(もしあれば)元の関数のインタラクティブ仕様(interactive
spec)を継承します。それ以外なら合成された関数はインタラクティブとなり@var{function}のインタラクティブ仕様を使用します。1つ例外があります。@var{function}のインタラクティブ仕様が関数(式や文字列ではない@code{lambda}式や@code{fbound}シンボル)なら、合成される関数のインタラクティブ仕様は、元の関数のインタラクティブ仕様を唯一の引数とする、その関数の呼び出しとなります。引数として受け取ったインタラクティブ仕様を解釈するためには@code{advice-eval-interactive-spec}を使用します。

注意:
@var{function}のインタラクティブ指定は結合された関数に適用されるべきであり、@var{function}ではなく結合された関数の呼び出し規約にしたがうこと。これらは多くの場合には等しいので差異は生じないが、@var{place}に格納されたオリジナルの関数とは異なる引数を受け取る@var{function}では@code{:around}、@code{:filter-args}、@code{:filter-return}では重要になる。
@end defmac

@defmac remove-function place function
このマクロは@var{place}に格納された関数から@var{function}を取り除く。これは@code{add-function}を使用して@var{function}が@var{place}に追加されたときだけ機能する。

@var{function}は@var{place}に追加された関数にたいして、ラムダ式にたいしても機能するように@code{equal}を使用して比較を試みる。これは追加で@var{place}に追加された関数の@code{name}プロパティも比較する。これは@code{equal}を使用してラムダ式を比較するより信頼性がある。
@end defmac

@defun advice-function-member-p advice function-def
@var{advice}がすでに@var{function-def}内にあれば非@code{nil}をリターンする。上記の@code{remove-function}と同様、実際の関数@var{advice}のかわりにアドバイスの@code{name}も使用できる。
@end defun

@defun advice-function-mapc f function-def
@var{function-def}に追加されたすべてのアドバイスにたいして、関数@var{f}を呼び出す。@var{f}は2つの引数 ---
アドバイス関数とそれのプロパティで呼びだされる。
@end defun

@defun advice-eval-interactive-spec spec
そのようなインタラクティブ仕様で関数がインタラクティブに呼び出されたように@var{spec}を評価して、構築された引数のリストに対応するリストをリターンする。たとえば@code{(advice-eval-interactive-spec
"r\nP")}はリージョンの境界、カレントプレフィクス引数を含む、3つの要素からなるリストをリターンする。

たとえば@kbd{C-x m}
(@code{compose-mail})コマンドに@samp{From:}ヘッダーの入力を求めるさせるようにするには、以下のようにすればよい:

@example
(defun my-compose-mail-advice (orig &rest args)
  "Read From: address interactively."
  (interactive
   (lambda (spec)
     (let* ((user-mail-address
             (completing-read "From: "
                              '("one.address@@example.net"
                                "alternative.address@@example.net")))
            (from (message-make-from user-full-name
                                     user-mail-address))
            (spec (advice-eval-interactive-spec spec)))
       ;; Put the From header into the OTHER-HEADERS argument.
       (push (cons 'From from) (nth 2 spec))
       spec)))
  (apply orig args))

(advice-add 'compose-mail :around #'my-compose-mail-advice)
@end example
@end defun

@node Advising Named Functions
@subsection 名前つき関数にたいするアドバイス
@cindex advising named functions

アドバイスは名前つき関数やマクロにたいして使用するのが一般的な使い方です。これは単に@code{add-function}を使用して以下のように行うことができます:

@example
(add-function :around (symbol-function '@var{fun}) #'his-tracing-function)
@end example

  しかしかわりに@code{advice-add}と@code{advice-remove}を使うべきです。この異なる関数セットは名前つき関数に適用されるアドバイスを操作するためのもので、@code{add-function}と比較して以下の追加機能があります。まずこれらはマクロとオートロードされた関数を扱う方法を知っています。次に@code{describe-function}にたいして追加されたアドバイスと同様に、元のドキュメント文字列を維持します。さらに関数が定義される前でも、アドバイスの追加と削除ができます。

  既存の関数全体を再定義せずに既存の呼び出しを変更するために、@code{advice-add}が有用になります。しかしその関数の既存の呼び出し元は古い振る舞いを前提としているかもしれず、アドバイスによりその振る舞いが変更されたときに正しく機能しないかもしれないので、バグの原因になり得ます。デバッグを行う人はその関数がアドバイスにより変更されたことに気づかなかったり失念していたりすると、アドバイスはデバッグでの混乱の原因になる可能性もあります。

  問題はアドバイス自体ではなく、名前つき関数への変更行為であることに注意してください。@code{fset}、@code{defalias}、@code{cl-letf}のような低レベルのプリミティブを通じて名前つき関数を変更すれば、さらに問題が起こるかもしれません。この観点からアドバイスは変更を追跡して、変更をリストしたりアンドゥできるので、名前つき関数を変更するにはよりよい方法といえるでしょう。

  名前つき関数への変更は、他の方法ではEmacsの振る舞いを変更できないような場合に備えるために控えるべきです。フックを通じて同じことが行えるならフック(@ref{Hooks}を参照)の使用が望ましい方法です。特定のキーが行う何かを変更したいだけなら、新しいコマンドを記述して、古いコマンドのキーバインドを新しいコマンドにリマップ(@ref{Remapping
Commands}を参照)するのが、おそらくより優れた方法です。

  他の人が使用するリリース用のコードを記述する場合には、アドバイスを含めることを避けるよう試みてください。アドバイスしたい関数にその処理を行うフックがなければ、適切なフックの追加についてEmacs開発者に相談してください。特にEmacs自身のソースファイルでは、Emacs関数にアドバイスを配置するべきではありません(現在のところこの慣習にたいするいくつかの例外があるが修正する予定)。一般的には@code{foo}にアドバイスとして@code{bar}を配置するよりも、@code{foo}内に新たなフックを作成して@code{bar}にそのフックを使用させるほうが明快です。

  スペシャルフォーム(@ref{Special
Forms}を参照)はアドバイスできませんが、マクロは関数と同じ方法でアドバイスできます。もちろんこれはすでにマクロ展開されたコードには影響しないため、マクロ展開前にアドバイスが確実にインストールされる必要があります。

  プリミティブ(@ref{What Is a
Function}を参照)にアドバイスするのは可能ですが、2つの理由により通常は@emph{行うべきではありません}。1つ目の理由はいくつかのプリミティブがアドバイスのメカニズム内で使用されているため、それらにたいしてアドバイスを行うと無限再帰が発生するからです。2つ目の理由は多くのプリミティブがCから直接呼び出されていて、そのような呼び出しはアドバイスを無視するからです。したがってプリミティブにたいしてアドバイスの使用を控えることにより、ある呼び出しはアドバイスにしたがい(Lispコードから呼びだされたため)、他の呼び出しではアドバイスにしたがわない(Cコードから呼び出されたため)という混乱した状況を解決できます。

@defmac define-advice symbol (where lambda-list &optional name depth) &rest body
このマクロはアドバイスを定義して@var{symbol}という名前の関数に追加する。@var{name}が非@code{nil}ならそのアドバイスの名前は@code{@var{symbol}@@@var{name}}となり、@var{name}という名前でインストールされる。それ以外の場合にはアドバイスは無名。他の引数についての説明は@code{advice-add}を参照のこと。
@end defmac

@defun advice-add symbol where function &optional props
名前つき関数@var{symbol}にアドバイス@var{function}を追加する。@var{where}と@var{props}は@code{add-function}(@ref{Core
Advising Primitives}を参照)のときと同じ意味をもつ。
@end defun

@deffn Command advice-remove symbol function
名前つき関数@var{symbol}からアドバイス@var{function}を取り除く。@var{function}にアドバイスの@code{name}を指定することもできる。インタラクティブに呼び出されるとアドバイスされた@var{function}、削除するアドバイスの両方の入力を求める。
@end deffn

@defun advice-member-p function symbol
名前つき関数@var{symbol}内にすでにアドバイス@var{function}があれば非@code{nil}をリターンする。@var{function}にアドバイスの@code{name}を指定することもできる。
@end defun

@defun advice-mapc function symbol
名前つき関数@var{symbol}にすでに追加されたすべての関数にたいして@var{function}を呼び出す。@var{function}はアドバイス関数とそのプロパティという2つの引数で呼び出される。
@end defun

@node Advice Combinators
@subsection アドバイスの構築方法

以下は@code{add-function}と@code{advice-add}の@var{where}引数に可能な値であり、そのアドバイス@var{function}と元の関数が構成される方法を指定します。

@table @code
@item :before
古い関数の前に@var{function}を呼び出す。関数は両方とも同じ引数を受け取り、2つの関数の結合のリターン値は古い関数のリターン値である。より正確に言うと2つの関数の結合は以下のように振る舞う:
@example
(lambda (&rest r) (apply @var{function} r) (apply @var{oldfun} r))
@end example
@code{(add-function :before @var{funvar}
@var{function})}はノーマルフックにたいする@code{(add-hook '@var{hookvar}
@var{function})}のような1関数のフックと同等。

@item :after
古い関数の後に@var{function}を呼び出す。関数は両方とも同じ引数を受け取り、2つの関数の結合のリターン値は古い関数のリターン値である。より正確に言うと2つの関数の結合は以下のように振る舞う:
@example
(lambda (&rest r) (prog1 (apply @var{oldfun} r) (apply @var{function} r)))
@end example
@code{(add-function :after @var{funvar}
@var{function})}はノーマルフックにたいする@code{(add-hook '@var{hookvar} @var{function}
'append)}のような1関数のフックと同等。

@item :override
これは古い関数を新しい関数に完全に置き換える。もちろん@code{remove-function}を呼び出した後に古い関数が復元される。

@item :around
古い関数のかわりに@var{function}を呼び出すが、古い関数は@var{function}の追加の引数になる。これはもっとも柔軟な結合である。たとえば古い関数を異なる引数で呼び出したり、複数回呼び出したり、letバインディングで呼び出したり、あるときは古い関数に処理を委譲し、またあるときは完全にオーバーライドすることが可能になる。より正確に言うと2つの関数の結合は以下のように振る舞う:
@example
(lambda (&rest r) (apply @var{function} @var{oldfun} r))
@end example

@item :before-while
古い関数の前に@var{function}を呼び出し、@var{function}が@code{nil}をリターンしたら古い関数を呼び出さない。関数は両方とも同じ引数を受け取り、2つの関数の結合のリターン値は古い関数のリターン値である。より正確に言うと2つの関数の結合は以下のように振る舞う:
@example
(lambda (&rest r) (and (apply @var{function} r) (apply @var{oldfun} r)))
@end example
@code{(add-function :before-while @var{funvar}
@var{function})}は@code{run-hook-with-args-until-failure}を通じて@var{hookvar}が実行されたときの@code{(add-hook
'@var{hookvar} @var{function})}のような1関数のフックと同等。

@item :before-until
古い関数の前に@var{function}を呼び出し、@var{function}が@code{nil}をリターンした場合だけ古い関数を呼び出す。より正確に言うと2つの関数の結合は以下のように振る舞う:
@example
(lambda (&rest r) (or (apply @var{function} r) (apply @var{oldfun} r)))
@end example
@code{(add-function :before-until @var{funvar}
@var{function})}は@code{run-hook-with-args-until-success}を通じて@var{hookvar}が実行されたときの@code{(add-hook
'@var{hookvar} @var{function})}のような1関数のフックと同等。

@item :after-while
古い関数が非@code{nil}をリターンした場合だけ、古い関数の後に@var{function}を呼び出す。関数は両方とも同じ引数を受け取り、2つの関数の結合のリターン値は@var{function}のリターン値である。より正確に言うと2つの関数の結合は以下のように振る舞う:
@example
(lambda (&rest r) (and (apply @var{oldfun} r) (apply @var{function} r)))
@end example
@code{(add-function :after-while @var{funvar}
@var{function})}は@code{run-hook-with-args-until-failure}を通じて@var{hookvar}が実行されたときの@code{(add-hook
'@var{hookvar} @var{function} 'append)}のような1関数のフックと同等。

@item :after-until
古い関数が@code{nil}をリターンした場合だけ、古い関数の後に@var{function}を呼び出す。より正確に言うと2つの関数の結合は以下のように振る舞う:
@example
(lambda (&rest r) (or  (apply @var{oldfun} r) (apply @var{function} r)))
@end example
@code{(add-function :after-until @var{funvar}
@var{function})}は@code{run-hook-with-args-until-success}を通じて@var{hookvar}が実行されたときの@code{(add-hook
'@var{hookvar} @var{function} 'append)}のような1関数のフックと同等。

@item :filter-args
最初に@var{function}を呼び出し、その結果(リスト)を新たな引数として古い関数に渡す。より正確に言うと2つの関数の結合は以下のように振る舞う:
@example
(lambda (&rest r) (apply @var{oldfun} (funcall @var{function} r)))
@end example

@item :filter-return
最初に古い関数を呼び出し、その結果を@var{function}に渡す。より正確に言うと2つの関数の結合は以下のように振る舞う:
@example
(lambda (&rest r) (funcall @var{function} (apply @var{oldfun} r)))
@end example
@end table


@node Porting Old Advice
@subsection 古いdefadviceを使用するコードの改良
@cindex old advices, porting
@c NB: The following index entries deliberately avoid ``old'',
@c an adjective that does not come to mind for those who grew up
@c on ‘defadvice’ et al.  For those folks, that way is ``current''.
@c They discover its oldness reading this node.
@cindex advices, porting from @code{defadvice}
@findex defadvice
@findex ad-activate

多くのコードは古い@code{defadvice}メカニズムを使用しており、これらは@code{advice-add}によって陳腐化しました。@code{advice-add}の実装とセマンティックは非常にシンプルです。

古いアドバイスは以下のようなものです:

@example
(defadvice previous-line (before next-line-at-end
                                 (&optional arg try-vscroll))
  "Insert an empty line when moving up from the top line."
  (if (and next-line-add-newlines (= arg 1)
           (save-excursion (beginning-of-line) (bobp)))
      (progn
        (beginning-of-line)
        (newline))))
@end example

新しいアドバイスメカニズムを使用すれば、これを通常の関数に変換できます:

@example
(defun previous-line--next-line-at-end (&optional arg try-vscroll)
  "Insert an empty line when moving up from the top line."
  (if (and next-line-add-newlines (= arg 1)
           (save-excursion (beginning-of-line) (bobp)))
      (progn
        (beginning-of-line)
        (newline))))
@end example

これが実際の@code{previous-line}を変更しないことは明確です。古いアドバイスには以下が必要です:
@example
(ad-activate 'previous-line)
@end example
一方、新しいアドバイスメカニズムでは以下が必要です:
@example
(advice-add 'previous-line :before #'previous-line--next-line-at-end)
@end example

@code{ad-activate}はグローバルな効果をもつことに注意してください。これは指定された関数にたいして、アドバイスのすべてを有効にします。特定のアドバイスだけをアクティブ、または非アクティブにしたいなら、@code{ad-enable-advice}か@code{ad-disable-advice}でアドバイスを@emph{有効}か@emph{無効}にする必要があります。新しいメカニズムではこの区別はなくなりました。

以下のようなaroundのアドバイスがあるとします:

@example
(defadvice foo (around foo-around)
  "Ignore case in `foo'."
  (let ((case-fold-search t))
    ad-do-it))
(ad-activate 'foo)
@end example

これは以下のように変換できます:

@example
(defun foo--foo-around (orig-fun &rest args)
  "Ignore case in `foo'."
  (let ((case-fold-search t))
    (apply orig-fun args)))
(advice-add 'foo :around #'foo--foo-around)
@end example

アドバイスの@emph{クラス}について、新たな@code{:before}は古い@code{before}は完全に等価ではないことに注意してください。なぜなら古いアドバイス内では、(たとえば@code{ad-set-arg}を使って)その関数の引数を変更でき、それは元の関数が参照する引数値に影響します。しかし新しい@code{:before}は、@code{setq}を通じてアドバイス内の引数を変更して、その変更は元の関数からの参照に影響しません。この振る舞いにもとづいて@code{before}アドバイスを移行するときは、代わりにそれを新たなアドバイス@code{:around}か@code{:filter-args}に変更する必要があるでしょう。

同様に古い@code{after}アドバイスは、@code{ad-return-value}を変更することによりリターン値を変更できますが、新しい@code{:after}は変更できないので、そのような@code{after}を移行するときは、かわりにそれらを新しいアドバイス@code{:around}か@code{:filter-return}に変更する必要があるでしょう。

@c This is its own node because we link to it from *Help* buffers.
@node Advice and Byte Code
@subsection アドバイスとバイトコード
@cindex compiler macros, advising
@cindex @code{byte-compile} and  @code{byte-optimize}, advising

  すべての関数にたいして信頼性をもってアドバイスできる訳ではありません。バイトコンパイラーが関数の呼び出しを、あなたが変更したい関数を呼び出さない命令シーケンスに置き換えることを選択するかもしれないからです。

これは通常は以下の3つのメカニズムのいずれかのために発生します:

@table @asis
@item @code{byte-compile}プロパティ
ある関数のシンボルに@code{byte-compile}プロパティがあると、シンボルの関数定義のかわりにそのプロパティが使用される。@ref{Compilation
Functions}を参照のこと。

@item @code{byte-optimize}プロパティ
ある関数のシンボルに@code{byte-optimize}プロパティがあると、バイトコンパイラーが関数の引数を書き換えたり、まったく別の関数の使用を決断するかもしれない。

@item declareフォーム@code{compiler-macro}
関数は定義内に特別な@code{declare}フォームである@code{compiler-macro}をもつことができる(@ref{Declare
Form}を参照)。これは関数のコンパイル時に呼び出す@dfn{expander}を定義する。その場合にはexpanderが元の関数を呼び出さないバイトコードを生成するかもしれない。
@end table

@node Obsolete Functions
@section 関数の陳腐化の宣言
@cindex obsolete functions

  名前つき関数を@dfn{陳腐化している(obsolete)}とマークすることができます。これはその関数が将来のある時点で削除されるかもしれないことを意味します。陳腐化しているとマークされた関数を含むコードをバイトコンパイルしたとき、Emacsは警告を発します。またその関数のヘルプドキュメントは表示されなくなります。他の点では陳腐化した関数は他の任意の関数と同様に振る舞います。

  関数を陳腐化しているとマークするもっとも簡単な方法は、その関数の@code{defun}定義に@code{(declare (obsolete
@dots{}))}を配置することです。@ref{Declare
Form}を参照してください。かわりに以下で説明している@code{make-obsolete}関数を使うこともできます。

  @code{make-obsolete}を使用してマクロ(@ref{Macros}を参照)を陳腐化しているとマークすることもできます。これは関数のときと同じ効果をもちます。関数やマクロにたいするエイリアスも、陳腐化しているとマークできます。これはエイリアス自身をマークするのであって、名前解決される関数やマクロにたいしてではありません。

@defun make-obsolete obsolete-name current-name when
この関数は@var{obsolete-name}を陳腐化しているとマークする。@var{obsolete-name}には関数かマクロを命名するシンボル、または関数やマクロにたいするエイリアスを指定する。

@var{current-name}がシンボルなら@var{obsolete-name}のかわりに@var{current-name}の使用を促す警告メッセージになる。@var{current-name}が@var{obsolete-name}のエイリアスである必要はない。似たような機能をもつ別の関数かもしれない。@var{current-name}には警告メッセージとなる文字列も指定できる。メッセージは小文字で始まりピリオドで終わること。@code{nil}も指定でき、この場合には警告メッセージに追加の詳細は提供されない。

引数@var{when}は最初にその関数が陳腐化する時期を示す文字列 --- たとえば日付やリリース番号を指定する。
@end defun

@defmac define-obsolete-function-alias obsolete-name current-name when &optional doc
この便利なマクロは関数@var{obsolete-name}を陳腐化しているとマークして、それを関数@var{current-name}のエイリアスにする。これは以下と等価:

@example
(defalias @var{obsolete-name} @var{current-name} @var{doc})
(make-obsolete @var{obsolete-name} @var{current-name} @var{when})
@end example
@end defmac

加えて陳腐化した関数にたいする特定の呼び出し規約をマークできます。

@defun set-advertised-calling-convention function signature when
この関数は@var{function}を呼び出す正しい方法として、引数リスト@var{signature}を指定する。これによりEmacs
Lispプログラムが他の方法で@var{function}を呼び出していたら、Emacsのバイトコンパイラーが警告を発する(それでもコードはバイトコンパイルされる)。@var{when}にはその変数が最初に陳腐化するときを示す文字列(通常はバージョン番号)を指定する。

たとえば古いバージョンのEmacsでは、@code{sit-for}には以下のように3つの引数を指定していた

@example
  (sit-for seconds milliseconds nodisp)
@end example

この関数は以降期間中は3つの引数を許容するものの、古い呼び出し規約は以下のように廃止される:

@example
(set-advertised-calling-convention
  'sit-for '(seconds &optional nodisp) "22.1")
@end example

@noindent
この関数の代替えとなるのが@code{advertised-calling-convention}におけるspecの@code{declare}です。@ref{Declare
Form}を参照してください。
@end defun

@node Inline Functions
@section インライン関数Inli
@cindex inline functions

  @dfn{インライン関数(inline
function)}は関数と同様に機能しますが、1つ例外があります。その関数の呼び出しがバイトコンパイルされると(@ref{Byte
Compilation}を参照)、その関数の定義が呼び出し側に展開されます。

  インライン関数を定義するには、@code{defun}のかわりに@code{defsubst}を記述するのがシンプルな方法です。定義の残りの部分は同一に見えますが、@code{defsubst}の使用によりバイトコンパイルにそれをインラインにするように指示します。

@defmac defsubst name args [doc] [declare] [interactive] body@dots{}
このマクロはインライン関数を定義する。マクロの構文は@code{defun}とまったく同じ(@ref{Defining Functions}を参照)。
@end defmac

  関数をインラインにすることにより、その関数の呼び出しが高速になる場合があります、が欠点もありその1つは柔軟性の減少です。その関数の定義を変更すると、すでにインライン化された呼び出しは、リコンパイルを行うまで古い定義を使用することになります。

  もう1つの欠点は、大きな関数をインライン化することにより、コンパイルされたコードのファイル上およびメモリー上のサイズが増大することです。スピード面でのインライン化の有利性は小さい関数で顕著なので、一般的に大きな関数をインライン化するべきではありません。

  インライン関数はデバッグ、トレース、アドバイス(@ref{Advising
Functions}を参照)に際してうまく機能しません。デバッグの容易さと関数の再定義の柔軟さはEmacsの重要な機能なので、スピードがとても重要であって@code{defun}の使用が実際に性能の面で問題となるのか検証するためにすでにコードをチューニングしたのでなければ、たとえその関数が小さくてもインライン化するべきではありません。

  インライン関数を定義した後そのインライン展開はマクロ同様、同じファイル内の後の部分で処理されます。

  インライン関数が実行するのと同じコードに展開されるマクロ(@ref{Macros}を参照してください)を定義するために@code{defmacro}を使用できます。しかし式内でのマクロの直接の使用には制限があります
---
@code{apply}、@code{mapcar}などでマクロを呼び出すことはできません。通常の関数からマクロへの変換には余分な作業が必要になります。通常の関数をインライン関数に変換するのは簡単です。@code{defun}を@code{defsubst}に置き換えるだけです。インライン関数の引数はそれぞれ正確に1回評価されるので、マクロのときのようにbodyで引数を何回使用するかを心配する必要はありません。

  かわりにコンパイラーマクロとしてインライン展開されるコードを記述することにより関数を定義できます(@ref{Declare
Form}を参照)。以下のマクロがこれを可能にします。

@c FIXME: Can define-inline use the interactive spec?
@defmac define-inline name args [doc] [declare] body@dots{}
自身をインライン化するコードを提供することにより、コンパイラーマクロとして関数@var{name}を定義する。この関数は引数リスト@var{args}を受け取り、指定された@var{body}をもつ。

@var{doc}が与えられたなら、それは関数のドキュメント文字列であること(@ref{Function
Documentation}を参照)。@var{declare}が与えられたなら、それは関数のメタデータを指定する@code{declare}フォームであること(@ref{Declare
Form}を参照)。
@end defmac

@code{define-inline}で定義された関数は、@code{defsubst}や@code{defmacro}で定義されたマクロにたいして複数の利点をもちます。

@itemize @minus
@item
@code{mapcar}に渡すことができる(@ref{Mapping Functions}を参照)。

@item
より効率的である。

@item
値を格納するための@dfn{placeフォーム(place forms)}として使用できる(@ref{Generalized
Variables}を参照)。

@item
@code{cl-defsubst}より予測可能な方法で振る舞う(@ref{Argument Lists,,, cl, Common Lisp
Extensions for GNU Emacs Lisp}を参照)。
@end itemize

@code{defmacro}と同様に、@code{define-inline}でインライン化された関数は、呼び出し側からダイナミックかレキシカルいずれかのスコーピングルールを継承します。@ref{Variable
Scoping}を参照してください。

以下のマクロは@code{define-inline}で定義された関数のbody内で使用する必要があります。

@defmac inline-quote expression
@code{define-inline}にたいして@var{expression}をクォートする。これはバッククォート(@ref{Backquote}を参照)と似ているが、コードをクォートして@code{,}だけを受け入れ、@code{,@@}は受け入れない。
@end defmac

@defmac inline-letevals (bindings@dots{}) body@dots{}
インライン関数の引数が正確に一度評価されて、ローカル変数を作成することを保証する便利な手段を提供する。

これは@code{let} (@ref{Local
Variables}を参照)と似ている。これは@var{bindings}で指定されたようにローカル変数をセットアップしてから、それらのバインディングの効力の下に@var{body}を評価する。

@var{bindings}の各要素はシンボル、または@w{@code{(@var{var}
@var{expr})}}という形式のリストであること。これは@var{expr}を評価して結果を@var{var}にバインドする。しかし@var{bindings}の要素がシンボル@var{var}だけなら、@var{var}の評価結果は@var{var}に再バインドされる(これは@code{let}の挙動と大きく異なる)。

@var{bindings}の終端は@code{nil}、または引数リストを保持するシンボル。シンボルの場合には各引数を評価して、結果のリストがシンボルにバインドされる。
@end defmac

@defmac inline-const-p expression
@var{expression}の値が既知なら非@code{nil}をリターンする。
@end defmac

@defmac inline-const-val expression
@var{expression}の値をリターンする。
@end defmac

@defmac inline-error format &rest args
@var{format}に応じて@var{args}をフォーマットしてエラーをシグナルする。
@end defmac

以下は@code{define-inline}を使用した例です:

@lisp
(define-inline myaccessor (obj)
  (inline-letevals (obj)
    (inline-quote (if (foo-p ,obj) (aref (cdr ,obj) 3) (aref ,obj 2)))))
@end lisp

@noindent
これは以下と等価です

@lisp
(defsubst myaccessor (obj)
  (if (foo-p obj) (aref (cdr obj) 3) (aref obj 2)))
@end lisp

@node Declare Form
@section @code{declare}フォーム
@findex declare

  @code{declare}(宣言)は特別なマクロで、関数やマクロにメタプロパティを追加するために使用できます。たとえば陳腐化しているとマークしたり、Emacs
Lispモード内の特別な@key{TAB}インデント規約を与えることができます。

@anchor{Definition of declare}
@defmac declare specs@dots{}
このマクロは引数を無視して@code{nil}として評価されるので、実行時の効果はない。しかし@code{defun}や@code{defsubst}(@ref{Defining
Functions}を参照)、または@code{defmacro}マクロ(@ref{Defining
Macros}を参照)の定義の@var{declare}引数に@code{declare}フォームがある場合は、@var{specs}で指定されたプロパティを関数またはマクロに追加します。これは@code{defun}、@code{defsubst}、@code{defmacro}により特別に処理される。

@var{specs}内の各要素は@code{(@var{property}
@var{args}@dots{})}というフォームをもつこと。またそれらをクォートしないこと。これらは以下の効果をもつ:

@table @code
@cindex @code{advertised-calling-convention} (@code{declare} spec)
@item (advertised-calling-convention @var{signature} @var{when})
これは@code{set-advertised-calling-convention}(@ref{Obsolete
Functions}を参照)の呼び出しと同じように振る舞う。@var{signature}にはその関数(またはマクロ)にたいする正しい引数リスト、@var{when}には古い引数リストが最初に陳腐化する時期を示す文字列を指定する。

@item (debug @var{edebug-form-spec})
これはマクロだけに有効である。Edebugでそのマクロ入ったときに、@var{edebug-form-spec}を使用する。@ref{Instrumenting
Macro Calls}を参照のこと。

@item (doc-string @var{n})
自身が関数やマクロ、変数のようなエンティティーを定義するために使用されるような関数やマクロを定義するときにこれが使用される。これは@var{n}番目の引数というこを示し、もしそれがあれば、それはドキュメント文字列とみなされる。

@item (indent @var{indent-spec})
この関数(かマクロ)にたいするインデント呼び出しは、@var{indent-spec}にしたがう。これは関数でも機能するが、通常はマクロで使用される。@ref{Indenting
Macros}を参照のこと。

@item (interactive-only @var{value})
その関数の@code{interactive-only}プロパティに@var{value}をセットする。@ref{The
interactive-only property}を参照のこと。

@cindex @code{obsolete} (@code{declare} spec)
@item (obsolete @var{current-name} @var{when})
@code{make-obsolete}(@ref{Obsolete
Functions}を参照)と同様に、関数(かマクロ)が陳腐化しているとマークする。@var{current-name}にはシンボル(かわりにこのシンボルを使うことを促す警告メッセージになる)、文字列(警告メッセージを指定)、または@code{nil}(警告メッセージには追加の詳細が含まれない)を指定すること。@var{when}にはその関数(かマクロ)が最初に陳腐化する時期を示す文字列を指定すること。

@cindex compiler macro
@item (compiler-macro @var{expander})
これは関数だけに使用でき、最適化関数(optimization
function)として@var{expander}を使用するようコンパイラーに告げる。@code{(@var{function}
@var{args}@dots{})}のようなその関数への呼び出しフォームに出会うと、マクロ展開機能(macro
expander)は@var{args}@dots{}と同様のフォームで@var{expander}を呼び出す。@var{expander}はその関数呼び出しのかわりに使用するための新しい式、または変更されていないフォーム(その関数呼び出しを変更しないことを示す)のどちらかをリターンすることができる。

@var{expander}がlambdaフォームなら、(@code{(lambda (@var{arg})
@var{body})}のように)単一の引数をもつフォームとして記述すること。関数の正規引数はlambdaの引数リストに自動的に追加されるため。

@item (gv-expander @var{expander})
@var{expander}が@code{gv-define-expander}と同様、ジェネリック変数としてマクロ(か関数)にたいする呼び出しを処理する関数であることを宣言する。@var{expander}はシンボルかフォーム@code{(lambda
(@var{arg}) @var{body})}を指定できる。フォームなら、その関数は追加でそのマクロ(か関数)の引数にアクセスできる。

@item (gv-setter @var{setter})
@var{setter}がジェネリック変数としてマクロ(か関数)にたいする呼び出しを処理する関数であることを宣言する。@var{setter}はシンボルかフォームを指定できる。シンボルなら、そのシンボルは@code{gv-define-simple-setter}に渡される。フォームなら@code{(lambda
(@var{arg})
@var{body})}という形式で、その関数は追加でマクロ(か関数)の引数にアクセスでき、それは@code{gv-define-setter}に渡される。

@item @var{extra}
@kbd{M-x}での補完にたいして入力を求める際に、関数のシンボルを関数リストに含めるかどうかを決定する関数として@var{completion-predicate}を宣言する。この述語関数は@code{read-extended-command-predicate}が@code{command-completion-default-include-p}にカスタマイズされているときだけ呼び出される。@code{read-extended-command-predicate}のデフォルトの値は@code{nil}
(@ref{Interactive Call,
execute-extended-command}を参照)。述語@var{completion-predicate}は関数のシンボル、カレントバッファーという2つの引数で呼び出される。

@item (modes @var{modes})
指定された@var{modes}にのみ適用されることを意図したコマンドであることを指定する。

@item (interactive-args @var{arg} ...)
@code{repeat-command}用に格納されるべき引数を指定する。@var{arg}はそれぞれ@code{@var{argument-name}
@var{form}}という形式。

@item (pure @var{val})
@var{val}が非@code{nil}なら、その関数は@dfn{純粋(pure)}である(@ref{What Is a
Function}を参照)。これは関数のシンボルの@code{pure}プロパティと同じ(@ref{Standard Properties}を参照)。

@item (side-effect-free @var{val})
@var{val}が非@code{nil}ならこの関数には副作用がないので、関数の値を無視するような呼び出しをバイトコンパイラーは無視できる。これは関数のシンボルの@code{side-effect-free}プロパティと同じ。@ref{Standard
Properties}を参照のこと。

@item (important-return-value @var{val})
@var{val}が非@code{nil}ならバイトコンパイラーはこの関数呼び出しがリターン値を使用しないことについて警告を発する。これは関数のシンボルの@code{important-return-value}プロパティと同じである。@ref{Standard
Properties}を参照のこと。

@item (speed @var{n})
この関数のネイティブコンパイルにたいして有効な@code{native-comp-speed}の値を指定する(@ref{Native-Compilation
Variables}を参照)。これによりその関数に発行されるネイティブコードに用いる最適化レベルを関数レベルで制御できるようになる。特に@var{n}が@minus{}1の場合には、その関数のネイティブコンパイルによってその関数にたいするネイティブコードではなくバイトコードが発行される。

@item (safety @var{n})
この関数に有効な@code{compilation-safety}の値を指定する。これにより、その関数に発行されるコードにたいする安全レベルを、関数のレベルで制御できるようになる(@ref{Native-Compilation
Variables}を参照)。

@item (ftype @var{type} &optional @var{function})
この関数のタイプを@var{type}と宣言する。@code{describe-function}によるドキュメント化で使用。コード生成の改善やタイプ宣言なしで他の関数のタイプをより正確に取得するためにネイティブコンパイラー(@ref{Native
Compilation}を参照)によって使用されることもあり得る。

@var{type}は@w{@code{(function (ARG-1-TYPE ... ARG-N-TYPE)
RETURN-TYPE)}}という形式のタイプ識別子。引数タイプには関数の引数(@ref{Argument
List}を参照)とマッチするように@code{&optional}、@code{&rest}のシンボルを差し込むことができる。

@var{function}が与えられる場合には、定義される関数の名前であること。

以下はタイプ@var{number}の引数を受け取り@var{boolean}をリターンする関数@code{positive-p}を宣言する@code{declare}の内部に@code{ftype}を使用する例:

@lisp
@group
(defun positive-p (x)
  (declare (ftype (function (number) boolean)))
  (when (> x 0)
    t))
@end group
@end lisp

同様に、以下は1つ目の引数が@var{cons}か@var{number}、2つ目がタイプ@var{string}のオプション引数で@code{is-cons}あ@code{is-number}いずれかのシンボルをリターンする関数@code{cons-or-number}を宣言する例:

@lisp
@group
(defun cons-or-number (x &optional err-msg)
  (declare (ftype (function ((or cons number) &optional string)
			    (member is-cons is-number))))
  (if (consp x)
      'is-cons
    (if (numberp x)
	'is-number
      (error (or err-msg "Unexpected input")))))
@end group
@end lisp

他のタイプについての説明については@ref{Lisp Data Types})を参照のこと。

不正なタイプの関数を宣言することにより未定義の動作、期待しない結果、コードがネイティブコンパイルされたコードがロードされていて、それが@code{compilation-safety}レベル0でコンパイルされたコードならEmacsのクラッシュさえ引き起こしかねない(@ref{compilation-safety}を参照)。この種の未定義の動作を避けるためには、タイプ宣言された関数の再定義(またはアドバイス)においては元のシグネチャーにしたがって置換を行うことにも注意を要する。

@item no-font-lock-keyword
これはマクロにたいしてのみ有効。この宣言をもつマクロは特にマクロとしてではなく、通常の関数としてfont-lockによりハイライトされる(@ref{Font
Lock Mode}を参照)。
@end table

@end defmac

@node Declaring Functions
@section コンパイラーへの定義済み関数の指示
@cindex function declaration
@cindex declaring functions
@findex declare-function

あるファイルをバイトコンパイルするとき、コンパイラーが知らない関数について警告が生成されるときがあります(@ref{Compiler
Errors}を参照してください)。実際に問題がある場合もありますが、問題となっている関数がそのコードの実行時にロードされる他のファイルで定義されている場合が通常です。たとえば以前は@file{simple.el}をバイトコンパイルすると以下のような警告が出ていました:

@example
simple.el:8727:1:Warning: the function ‘shell-mode’ is not known to be
    defined.
@end example

実際のところ@code{shell-mode}は@code{(require
'shell)}を実行する関数内の@code{shell-mode}を呼び出す前でのみ使用されるので、@code{shell-mode}は実行時に正しく定義されるでしょう。そのような警告が実際には問題を示さないことを知っているときには警告を抑制したほうがよいでしょう。そうすれば実際に問題があることを示す新しい警告の識別性が良くなります。これは@code{declare-function}を使用して行うことができます。

必要なのは問題となっている関数を最初に使用する前に@code{declare-function}命令を追加するだけです:

@example
(declare-function shell-mode "shell" ())
@end example

これは@code{shell-mode}が@file{shell.el}
(@samp{.el}は省略可)の中で定義していることを告げます。コンパイラーは関数がそのファイルで実際に定義されているとみなしてチェックを行いません。

  3つ目の引数はオプションであり@code{shell-mode}の引数リストを指定します。この例では引数はありません(@code{nil}と値を指定しないのは異なる)。それ以外の場合には@code{(file
&optional
overwrite)}のようになります。引数リストを指定する必要はありませんが、指定すればコンパイラーはその呼び出しが宣言と合致するかチェックできます。

@defmac declare-function function file &optional arglist fileonly
ファイル@var{file}内で@var{function}が定義されているとみなすようにバイトコンパイラーに告げる。オプションの3つ目の引数@var{arglist}は@code{t}
(引数リストが未指定という意味)、または@code{defun}と同スタイルな正式パラメーターリスト(カッコを含む)のいずれか。@var{arglist}を省略した際のデフォルトは@code{nil}ではなく@code{t}。これは引数省略時の非定形な挙動であり、3つ目の引数を指定せずに4つ目引数を与える場合には通常の@code{nil}のかわりに3つ目の引数のプレースホルダーに@code{t}を指定しなければならないことを意味する。オプションの4つ目の引数@var{fileonly}が非@code{nil}なら実際に@var{function}が定義されているかではなく@var{file}の存在だけをチェックすることを意味する。
@end defmac

@findex check-declare-file
@findex check-declare-directory
  これらの関数が@code{declare-function}が告げる場所で実際に宣言されているかどうかを検証するには、@code{check-declare-file}を使用して1つのソースファイル中のすべての@code{declare-function}呼び出しをチェックするか、@code{check-declare-directory}を使用して特定のディレクトリー配下のすべてのファイルをチェックする。

  これらのコマンドは、@code{locate-library}で使用する関数の定義を含むはずのファイルを探す。ファイルが見つからなければ、これらのコマンドは@code{declare-function}の呼び出しを含むファイルがあるディレクトリーからの相対ファイル名に、定義ファイル名を展開する。

  @samp{.c}や@samp{.m}で終わるファイル名を指定することにより、プリミティブ関数を指定することもできる。これが有用なのは特定のシステムだけで定義されるプリミティブを呼び出す場合だけである。ほとんどのプリミティブは常に定義されているので、それらについて警告を受け取ることはありえないはずである。

  あるファイルがオプションとして外部のパッケージの関数を使う場合もある。@code{declare-function}命令内のファイル名のプレフィクスを@samp{ext:}にすると、そのファイルが見つかった場合はチェックして、見つからない場合はエラーとせずにスキップする。

  @samp{check-declare}が理解しない関数定義もいくつか存在する(たとえば@code{defstruct}やその他いくつかのマクロ)。そのような場合は@code{declare-function}の@var{fileonly}引数に非@code{nil}を渡すことができる。これはファイルの存在だけをチェックして、その関数の実際の定義はチェックしないことを意味する。これを行うなら引数リストを指定する必要はないが、@var{arglist}引数には@code{t}をセットする必要があることに注意(なぜなら@code{nil}は引数リストが指定されなかったという意味ではなく空の引数リストを意味するため)。

@node Function Safety
@section 安全に関数を呼び出せるかどうかの判断
@cindex function safety
@cindex safety of functions

SESのようないくつかのメジャーモードは、ユーザーファイル内に格納された関数を呼び出します(SESの詳細は@ref{Top, Simple Emacs
Spreadsheet,,ses}を参照)。 ユーザーファイルは素性があやふやな場合があります ---
初対面の人から受け取ったスプレッドシートかもしれず、会ったことのない誰かから受け取ったeメールかもしれません。そのためユーザーファイルに格納されたソースコードの関数を呼び出すのは、それが安全だと決定されるすまでは危険です。

@defun unsafep form &optional unsafep-vars
@var{form}が@dfn{安全(safe)}なLisp式なら@code{nil}、危険ならなぜその式が危険かもしれないのか説明するリストをリターンする。引数@var{unsafep-vars}は、この時点で一時的なバインドだと判っているシンボルのリスト。これは主に内部的な再帰呼び出しで使用される。カレントバッファーは暗黙の引数になり、これはバッファーローカルなバインディングのリストを提供する。
@end defun

高速かつシンプルにするために、@code{unsafep}は非常に軽量な分析を行うので、実際には安全な多くのLisp式を拒絶します。安全ではない式にたいして@code{unsafep}が@code{nil}をリターンするケースは確認されていません。しかし安全なLisp式は@code{display}プロパティと一緒に文字列をリターンでき、これはその文字列がバッファーに挿入された後に実行される、割り当てられたLisp式を含むことができます。割り当てられた式はウィルスかもしれません。安全であるためにはバッファーへ挿入する前に、ユーザーコードで計算されたすべての文字列からプロパティを削除しなければなりません。

@ignore
What is a safe Lisp expression?  Basically, it's an expression that
calls only built-in functions with no side effects (or only innocuous
ones).  Innocuous side effects include displaying messages and
altering non-risky buffer-local variables (but not global variables).

@table @dfn
@item Safe expression
@itemize
@item
An atom or quoted thing.
@item
A call to a safe function (see below), if all its arguments are
safe expressions.
@item
One of the special forms @code{and}, @code{catch}, @code{cond},
@code{if}, @code{or}, @code{prog1}, @code{prog2}, @code{progn},
@code{while}, and @code{unwind-protect}], if all its arguments are
safe.
@item
A form that creates temporary bindings (@code{condition-case},
@code{dolist}, @code{dotimes}, @code{lambda}, @code{let}, or
@code{let*}), if all args are safe and the symbols to be bound are not
explicitly risky (@pxref{File Local Variables}).
@item
An assignment using @code{add-to-list}, @code{setq}, @code{push}, or
@code{pop}, if all args are safe and the symbols to be assigned are
not explicitly risky and they already have temporary or buffer-local
bindings.
@item
One of [apply, mapc, mapcar, mapconcat] if the first argument is a
safe explicit lambda and the other args are safe expressions.
@end itemize

@item Safe function
@itemize
@item
A lambda containing safe expressions.
@item
A symbol on the list @code{safe-functions}, so the user says it's safe.
@item
A symbol with a non-@code{nil} @code{side-effect-free} property.
@item
A symbol with a non-@code{nil} @code{safe-function} property.  The
value @code{t} indicates a function that is safe but has innocuous
side effects.  Other values will someday indicate functions with
classes of side effects that are not always safe.
@end itemize

The @code{side-effect-free} and @code{safe-function} properties are
provided for built-in functions and for low-level functions and macros
defined in @file{subr.el}.  You can assign these properties for the
functions you write.
@end table
@end ignore

@node Related Topics
@section 関数に関するその他トピック

  以下のテーブルは関数呼び出しと関数定義に関連したことを行ういくつかの関数です。これらは別の場所で説明されているので、ここではクロスリファレンスを提供します。

@table @code
@item apply
@ref{Calling Functions}を参照のこと。

@item autoload
@ref{Autoload}を参照のこと。

@item call-interactively
@ref{Interactive Call}を参照のこと。

@item called-interactively-p
@ref{Distinguish Interactive}を参照のこと。

@item commandp
@ref{Interactive Call}を参照のこと。

@item documentation
@ref{Accessing Documentation}を参照のこと。

@item eval
@ref{Eval}を参照のこと。

@item funcall
@ref{Calling Functions}を参照のこと。

@item function
@ref{Anonymous Functions}を参照のこと。

@item ignore
@ref{Calling Functions}を参照のこと。

@item indirect-function
@ref{Function Indirection}を参照のこと。

@item interactive
@ref{Using Interactive}を参照のこと。

@item interactive-p
@ref{Distinguish Interactive}を参照のこと。

@item mapatoms
@ref{Creating Symbols}を参照のこと。

@item mapcar
@ref{Mapping Functions}を参照のこと。

@item map-char-table
@ref{Char-Tables}を参照のこと。

@item mapconcat
@ref{Mapping Functions}を参照のこと。

@item undefined
@ref{Functions for Key Lookup}を参照のこと。
@end table
