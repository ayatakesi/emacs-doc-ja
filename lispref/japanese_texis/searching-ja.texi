@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================

@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990--1995, 1998--1999, 2001--2024 Free Software
@c Foundation, Inc.
@c See the file elisp-ja.texi for copying conditions.
@node Searching and Matching
@chapter 検索とマッチング
@cindex searching

  GNU Emacsはバッファーから指定されたテキストを検索するために2つの手段を提供します。それは文字列の正確一致検索(exact string
search)と正規表現検索(regular expression
search)です。正規表現検索の後で、マッチしたテキストが正規表現全体にマッチしたのか、それとも正規表現のさまざまな部分に一致したかを判断するために@dfn{マッチデータ(match
data)}を調べることができます。

@menu
* String Search::            正確なマッチの検索。
* Searching and Case::       case-independentまたはcase-significantな検索。
* Regular Expressions::      文字列クラスの記述。
* Regexp Search::            regexpにたいするマッチの検索。
* Longest Match::            最長マッチの検索。
* Match Data::               文字列またはregexp検索後にテキストがマッチした部分を見つける。
* Search and Replace::       検索と置換を繰り返すコマンド。
* Standard Regexps::         センテンスやページ等を探すために有用なregexp。
* POSIX Regexps::            Emacsのregexp vs POSIXのregexp。
@end menu

  @samp{skip-chars@dots{}}関連の関数もある種の検索を行います。@ref{Skipping
Characters}を参照してください。文字プロパティ内の変更の検索は@ref{Property Search}を参照してください。

@node String Search
@section 文字列の検索
@cindex string search

  バッファー内のテキストを検索するためのプリミティブ関数が存在します。これらはプログラム内での使用を意図したものですがインタラクティブに呼び出すこともできます。これらをインタラクティブに呼び出すと検索文字列の入力を求めて、引数@var{limit}と@var{noerror}は@code{nil}、@var{repeat}は1になります。インタラクティブ検索に関するより詳細な情報は@ref{Search,,
Searching and Replacement, emacs, The GNU Emacs Manual}を参照してください。

  以下の検索関数はバッファーがマルチバイトバッファーならマルチバイト、ユニバイトバッファーならユニバイトに検索文字列を変換します。@ref{Text
Representations}を参照してください。

@deffn Command search-forward string &optional limit noerror count
この関数は@var{string}にたいする正確なマッチをポイントから前方に検索する。成功したら見つかったマッチの終端にポイントをセットしてポイントの新たな値をリターンする。マッチが見つからない場合の値と副作用は@var{noerror}
(以下参照)に依存する。

以下の例ではポイントは最初は行の先頭にある。その後の@code{(search-forward
"fox")}によってポイントは@samp{fox}の最後の文字の後に移動する:

@example
@group
---------- Buffer: foo ----------
@point{}The quick brown fox jumped over the lazy dog.
---------- Buffer: foo ----------
@end group

@group
(search-forward "fox")
     @result{} 20

---------- Buffer: foo ----------
The quick brown fox@point{} jumped over the lazy dog.
---------- Buffer: foo ----------
@end group
@end example

引数@var{limit}は検索の境界を指定するもので、それはカレントバッファー内の位置であること。その位置を超えるようなマッチは受け入れられない。@var{limit}が省略または@code{nil}の場合のデフォルトは、そのバッファーのアクセス可能範囲の終端。

@kindex search-failed
@c I see no prospect of this ever changing, and frankly the current
@c behavior seems better, so there seems no need to mention this.
検索失敗時に何が起こるかは@var{noerror}の値に依存する。@var{noerror}が@code{nil}なら@code{search-failed}はエラーをシグナルする。@var{noerror}が@code{t}なら@code{search-forward}は@code{nil}をリターンして何も行わない。@var{noerror}が@code{nil}と@code{t}いずれでもなければ、@code{search-forward}はポイントを境界上限に移動して@code{nil}をリターンする。
@ignore
(It would be more consistent now to return the new position of point
in that case, but some existing programs may depend on a value of
@code{nil}.)
@end ignore

引数@var{noerror}はマッチに失敗した有効な検索だけに影響する。無効な引数は@var{noerror}とは無関係にエラーとなる。

@var{count}が正の数@var{n}なら、それは繰り返し回数の役目をもつ。検索は@var{n}回繰り返され、前回のマッチの終端から毎回検索が開始される。これらの連続する検索が成功した場合、関数は成功となりポイントを移動して新たな値をリターンする。それ以外は検索失敗となり、上述したように結果は@var{noerror}の値に依存する。@var{count}が負の数
@minus{}@var{n}なら、それは逆方向(後方)への検索の繰り返し回数@var{n}としての役目をもつ。
@end deffn

@deffn Command search-backward string &optional limit noerror count
この関数はポイントから後方に@var{string}を検索する。これは@code{search-forward}と似ているが、前方ではなく後方に検索する点が異なる。後方への検索ではポイントはマッチの先頭に残される。
@end deffn

@deffn Command word-search-forward string &optional limit noerror count
この関数はポイントから前方に@var{string}にたいする単語(word)のマッチを検索する。マッチが見つかったら見つかったマッチの終端にポイントをセットしてポイントの新たな値をリターンする。

単語マッチは@var{string}を単語のシーケンスとみなし、それらを分割する句読点は無視する。これはバッファーから同じ単語シーケンスを検索する。単語はそれぞれバッファー内で明確に区別されていなければならない(単語@samp{ball}の検索は単語@samp{balls}にマッチしない)が、句読点やスペース等の細部は無視される(@samp{ball
boy}を検索すると@samp{ball.  Boy!}にマッチする)。

以下の例ではポイントは最初バッファー先頭にある。検索によりポイントは@samp{y}と@samp{!}の間に残される。

@example
@group
---------- Buffer: foo ----------
@point{}He said "Please!  Find
the ball boy!"
---------- Buffer: foo ----------
@end group

@group
(word-search-forward "Please find the ball, boy.")
     @result{} 39

---------- Buffer: foo ----------
He said "Please!  Find
the ball boy@point{}!"
---------- Buffer: foo ----------
@end group
@end example

@var{limit}が非@code{nil}なら、それはカレントバッファー内の位置であること。これはその検索の境界上限を指定する。見つかったマッチはその位置を超えてはならない。

@var{noerror}が@code{nil}なら@code{word-search-forward}はエラーをシグナルする。@var{noerror}が@code{t}なら、エラーをシグナルするかわりに@code{nil}をリターンする。@var{noerror}が@code{nil}と@code{t}いずれでもなければ、ポイントを@var{limit}(またはバッファーのアクセス可能範囲の終端)に移動して@code{nil}をリターンする。

@var{count}が正の数なら、それは連続して検索する回数を指定する。ポイントは最後のマッチの終端に配置される。@var{count}が負の数なら、逆方向に検索してポイントは最後のマッチの先頭に配置される。

@findex word-search-regexp
@code{word-search-forward}および関連する関数は、@var{string}から句読点を無視した正規表現に変換するために、内部的には関数@code{word-search-regexp}を使用する。
@end deffn

@deffn Command word-search-forward-lax string &optional limit noerror count
このコマンドは@code{word-search-forward}と同じだが、@var{string}が空白で開始か終了していなければ、@var{string}の先頭か終端が単語境界にマッチする必要がない点が異なる。たとえば@samp{ball
boy}の検索は@samp{ball boyee}にはマッチするが、@samp{balls boy}にはマッチしない。
@end deffn

@deffn Command word-search-backward string &optional limit noerror count
この関数はポイントから後方へ@var{string}にマッチする単語を検索する。この関数は@code{word-search-forward}と同様だが、後方に検索して通常はマッチの先頭にポイントを残す点が異なる。
@end deffn

@deffn Command word-search-backward-lax string &optional limit noerror count
このコマンドは@code{word-search-backward}と同じだが、文字列が空白で開始か終了していなければ、@var{string}の先頭か終端が単語境界にマッチする必要がない点が異なる。
@end deffn

@node Searching and Case
@section 検索と大文字小文字
@cindex searching and case

  デフォルトのEmacs検索では検索するテキストのcase(大文字と小文字)は無視されます。検索対象に@samp{FOO}を指定すると、@samp{Foo}や@samp{foo}もマッチとみなされます。これは正規表現にも適用されます。つまり@samp{[aB]}は@samp{a}、@samp{A}、@samp{b}、@samp{B}にもマッチするでしょう。

  この機能が望ましくなければ変数@code{case-fold-search}に@code{nil}をセットしてください。その場合にはすべての文字はcaseを含めて正確にマッチしなければなりません。これはバッファーローカル変数です。この変数の変更はカレントバッファーだけに影響を与えます(@ref{Intro
to
Buffer-Local}を参照)。かわりにデフォルト値を変更することもできます。Lispコードでは@code{let}を使用して@code{case-fold-search}を望む値にバインドするほうが、より一般的でしょう。

  ユーザーレベルのインクリメンタル検索機能ではcaseの区別が異なることに注意してください。検索文字列に含まれるのが小文字だけなら検索はcaseを無視しますが、検索文字列に1つ以上の大文字が含まれれば検索はcaseを区別するようになります。しかしLispコード内で使用される検索関数では、これは何も行いません。@ref{Incremental
Search,,, emacs, The GNU Emacs Manual}を参照してください。

@defopt case-fold-search
このバッファーローカル変数は検索がcaseを無視するべきかどうかを決定する。この変数が@code{nil}なら検索はcaseを無視しない。それ以外(とデフォルト)ではcaseを無視する。
@end defopt

@defopt case-replace
この変数は高レベルの置換関数がcaseを保持するべきかどうかを決定する。この変数が@code{nil}なら、それは置換テキストをそのまま使用することを意味する。非@code{nil}値は置換されるテキストに応じて、置換テキストのcaseを変換することを意味する。

この変数は関数@code{replace-match}の引数として渡すことにより使用される。@ref{Replacing Match}を参照のこと。
@end defopt

@node Regular Expressions
@section 正規表現
@cindex regular expression
@cindex regexp

  @dfn{正規表現(regular
expression)}、略して@dfn{regexp}は文字列の(もしかしたら無限の)セットを表すパターンのことです。regexpにたいするマッチの検索はとても強力な処理です。このセクションではregexpの記述方法、それ以降のセクションではそれらを検索する方法を示します。

@findex re-builder
@cindex regular expressions, developing
  正規表現を対話的に開発するために@kbd{M-x
re-builder}コマンドを使用できます。このコマンドは別のバッファーに即座に視覚的なフィードバックを表示することにより、正規表現を作成するための便利なインターフェースを提供します。regexp編集とともにターゲットとなるバッファーのすべてのマッチがハイライトされます。カッコで括られたregexpの部分式(sub-expression)は別のフェイスで表示され、非常に複雑なregexpを簡単に検証することが可能になります。

  Emacsの検索はデフォルトではcase(大文字小文字)を区別しないことに注意してください(@ref{Searching and
Case}を参照)。caseを区別したregexpの検索とマッチを有効にするには、区別したいコードの前後で@code{case-fold-search}に@code{nil}をバインドしてください。

@menu
* Syntax of Regexps::        正規表現の記述ルール。
* Regexp Example::           正規表現構文の説明。
@ifnottex
* Rx Notation:: 構造化regexpによる代替表記。
@end ifnottex
* Regexp Functions::         正規表現を操作する関数。
* Regexp Problems::          いくつかの問題点とその回避策。
@end menu

@node Syntax of Regexps
@subsection 正規表現の構文
@cindex regexp syntax
@cindex syntax of regular expressions

  正規表現は少数の文字が特別な構成要素であり、残りは@dfn{通常}の文字であるような構文をもちます。通常の文字はその文字自身だけにマッチするシンプルな正規表現です。特別な文字は@samp{.}、@samp{*}、@samp{+}、@samp{?}、@samp{[}、@samp{^}、@samp{$}、および@samp{\}です。将来に新たなスペシャル文字が定義されることはないでしょう。ブラケット式(bracket
expression: ブラケット表現;
後述)で終わる場合には@samp{]}はスペシャル文字です。ブラケット式の間では@samp{-}はスペシャル文字です。@samp{[:}と対応する@samp{:]}はブラケット式の内の文字クラスです。正規表現内に出現する他の文字は@samp{\}が前置されていない限り通常の文字です。

  たとえば@samp{f}はスペシャル文字ではなく通常文字なので、@samp{f}は文字列@samp{f}にマッチして他の文字にはマッチしない正規表現です(これは文字列@samp{fg}には@emph{マッチしない}が、その文字列の@emph{部分}にマッチする)。同様に@samp{o}は@samp{o}だけにマッチします。

  任意の2つの正規表現@var{a}と@var{b}を結合することができます。結合した結果は文字列の先頭からある長さの文字列が@var{a}にマッチして、残りの文字列が@var{b}にマッチするような文字列にマッチする正規表現になります。

  単純な例として文字列@samp{fo}だけにマッチする正規表現の構成要素@samp{fo}を取得するために正規表現@samp{f}と@samp{o}を結合できます。

@menu
* Regexp Special::           正規表現内のスペシャル文字。
* Char Classes::             正規表現内で使用される文字クラス。
* Regexp Backslash::         正規表現内のバックスラッシュシーケンス。
@end menu

@node Regexp Special
@subsubsection 正規表現内の特殊文字
@cindex regexp, special characters in

  以下は正規表現内で特別な文字のリストです:

@need 800
@table @asis
@item @samp{.}@: @r{(Period)}
@cindex @samp{.} in regexp
これは改行を除く1文字にマッチするスペシャル文字。結合を使用して@samp{a.b}のような正規表現を作成できる。これは@samp{a}で始まり@samp{b}で終わる3文字の文字列にマッチする。

@item @samp{*}
@cindex @samp{*} in regexp
これはそれ自身が構成要素ではない。これは前置された正規表現を可能な限り繰り返したものにマッチすることを意味する後置演算子である。したがって@samp{o*}は任意の個数の@samp{o}にマッチする(@samp{o}を含まない場合にもマッチする)。

@samp{*}は常に前置された表現の@emph{最小}の表現に適用される。つまり@samp{fo*}は@samp{o}の繰り返しであり@samp{fo}の繰り返しではない。これは@samp{f}、@samp{fo}、@samp{foo}、...にマッチする。

@cindex backtracking and regular expressions
マッチを行う処理は構成要素@samp{*}をマッチングにより即座に見つけ得る回数分処理して、その後にパターンの残りを継続する。これが失敗したら残りのパターンのマッチが可能になるかもしれないという期待のもとに、@samp{*}の変更された構成のうちいくつかのマッチを破棄することでバックトラッキングが発生する。たとえば文字列@samp{caaar}にたいして@samp{ca*ar}をマッチングすると、@samp{a*}はまず3つすべての@samp{a}へのマッチを試みる。しかし残りのパターンは@samp{ar}であり、マッチ対象に残されているのは@samp{r}だけなので試みは失敗する。@samp{a*}にたいする次の代替策は、2つの@samp{a}だけへのマッチである。この選択では残りのregexpのマッチは成功する。

@item @samp{+}
@cindex @samp{+} in regexp
これは@samp{*}のような後置演算子だが前置された表現に少なくとも1回マッチしなければならない点が異なる。たとえば@samp{ca+r}は文字列@samp{car}や@samp{caaaar}にマッチするが文字列@samp{cr}にはマッチせず、その一方で@samp{ca*r}はこれら3つすべての文字列にマッチする。

@item @samp{?}
@cindex @samp{?} in regexp
これは@samp{*}のような後置演算子だが前置された表現に1回、またはマッチしないかのいずれかでなければならない点が異なる。例えば@samp{ca?r}は@samp{car}と@samp{cr}にマッチするが他にはマッチしない。

@anchor{Non-greedy repetition}
@item @samp{*?}, @samp{+?}, @samp{??}
@cindex non-greedy repetition characters in regexp
演算子
@samp{*}、@samp{+}、@samp{?}の@dfn{非欲張り(non-greedy)}な変種。これらの演算子が可能な最長の部分文字列(含まれる表現全体へのマッチと等しい)とマッチするのにたいして、非欲張りな変種は可能な最短の部分文字列(含まれる表現全体と等しい)にマッチする。

たとえば正規表現@samp{c[ad]*a}を文字列@samp{cdaaada}に適用すると文字列全体にマッチするが、正規表現@samp{c[ad]*?a}を同じ文字列に適用すると@samp{cda}だけにマッチする(ここでマッチが許された表現全体にたいする@samp{[ad]*?}の可能な最短マッチは@samp{d})。

@item @samp{[ @dots{} ]}
@cindex bracket expression (in regexp)
@cindex character alternative (in regexp)
@cindex @samp{[} in regexp
@cindex @samp{]} in regexp
これは@samp{[}で始まり@samp{]}で終端される@dfn{ブラケット式(bracket
expression)}。(@dfn{文字候補(character alternative)}とも呼ばれる。)
もっとも単純なケースでは、この２つのカッコ(brackets)の間にある文字が、このブラケット式がマッチ可能な文字。

したがって@samp{[ad]}は1つの@samp{a}と1つの@samp{d}の両方にマッチし、@samp{[ad]*}は@samp{a}と@samp{d}だけで構成された任意の文字列(空文字列を含む)にマッチする。つまり@samp{c[ad]*r}は@samp{cr}、@samp{car}、@samp{cdr}、@samp{caddaar}等にマッチする。

開始文字と終了文字の間に@samp{-}を記述することによりブラケット式内に文字範囲を含めることができる。つまり@samp{[a-z]}は小文字の@acronym{ASCII}アルファベット文字にマッチする。範囲は@samp{[a-z$%.]}のように個別の文字と自由に組み合わせることができる。これは任意の@acronym{ASCII}小文字アルファベットと@samp{$}、@samp{%}、またはピリオドとマッチする。しかし1つの範囲の終端文字が別の範囲の開始文字ではないこと。たとえば@samp{[a-m-z]}は使用しないこと。

ブラケット式には名前付き文字クラスも指定できる(@ref{Char
Classes}を参照)。たとえば@samp{[[:ascii:]]}は任意の@acronym{ASCII}文字にマッチする。文字クラスの使用は、そのクラス内すべての文字を記述するのと等しい。しかし異なる文字数千を含むクラスもあるので後者は実際は実現不可能。文字クラス範囲の上側や下側の境界に出現するべきではない。

ブラケット式の内部では、通常のregexpスペシャル文字ではスペシャルではない。完全に異なる文字セット@samp{]}、@samp{-}、@samp{^}がスペシャルになる。ブラケット式に@samp{]}を含めるには、それを先頭に配置する。@samp{^}を含めるには、それを先頭以外の場所に配置する。@samp{-}を含めるには、それを最後に配置する。したがって@samp{[]^-]}は、これら3つのスペシャル文字すべてにマッチする。ここでは@samp{\}はスペシャルではないので、これら3つの文字のエスケープに@samp{\}は使用できない。

以下の範囲にたいする側面はEmacs固有であり、POSIXはこの振る舞いを許容はするが必須ではなく、Emacs以外のプログラムは異なる振る舞いをするかもしれない。

@enumerate
@item
@code{case-fold-search}が非@code{nil}なら@samp{[a-z]}は大文字にもマッチする。

@item
範囲はlocaleの照合順の影響を受けない。範囲は常にその範囲の境界間に存在するコードポイントを文字セットで表現されるので、たとえCやPOSIXのlocale外部でも@samp{[a-z]}がマッチするのはASCII文字のみ。

@item
範囲の下側境界が上側境界より大きければ範囲は空であり何の文字も表現しない。したがって@samp{[z-a]}は常にマッチに失敗するし、@samp{[^z-a]}は改行を含む任意の文字にマッチする。ただし逆転した範囲はtypoでないことを明確にするために、常に文字@samp{z}から文字@samp{a}にすること。たとえば@samp{[+-*/]}は意図した4つの文字ではなく、@samp{/}だけにマッチするので避けること。

@item
範囲の終端が8ビットrawバイト(@ref{Text
Representations}を参照)、あるいは(@samp{[a-\377]}のように)先頭がASCIIで終端がrawバイトなら、その範囲はASCII文字および8ビットrawバイトだけにマッチして、非ASCII文字にはマッチしない。この機能はユニバイトのバッファーおよび文字列におけるテキスト検索を意図している。
@end enumerate

ある種のブラケット式は、たとえそれらがEmacs内において明確に定義された意味をもっているとしても最良のスタイルとならない。これらには以下が含まれる:

@enumerate
@item
ほとんどすべての文字を範囲の境界にできるとはいえ、文字コードテーブルを記憶している人はほとんどいないので、ASCII文字や数字の自然な順序を守るほうがよいスタイルである。たとえば@samp{[.-9]}は@samp{[./0-9]}、@samp{[`-~]}は@samp{[`a-z@{|@}~]}より明確さに劣る。ここではUnicodeの文字エスケープが助けとなる。たとえばほとんどのプログラマーにとっては@samp{[ก-ฺ฿-๛]}より@samp{[\u0E01-\u0E3A\u0E3F-\u0E5B]}のほうが明確だろう。

@item
ブラケット式に重複を含めることができたとしても、それを避けるほうがよいスタイルである。たとえば@samp{[XYa-yYb-zX]}は@samp{[XYa-z]}より明確さに劣る。

@item
範囲を単に1文字、2文字、あるいは3文字で表せたとしても、文字をリストするほうがシンプルである。たとえば@samp{[a-a0]}は@samp{[a0]}、@samp{[i-j]}は@samp{[ij]}、@samp{[i-k]}は@samp{[ijk]}より明確さに劣る。

@item
たとえブラケット式の先頭や範囲の上側境界として@samp{-}を配置できるとしても、ブラケット式の最後に@samp{-}そのものを配置するほうがよいスタイルである。たとえば@samp{[-a-z]}が有効であっても@samp{[a-z-]}のほうがよいスタイルであり、@samp{[*--]}が有効だとしても@samp{[*+,-]}のほうが明確である。
@end enumerate

@item @samp{[^ @dots{} ]}
@cindex @samp{^} in regexp
@samp{[^}は@dfn{補集合のブラケット式(complemented bracket
expression)}を開始する。(@dfn{補集合の文字候補(complemented character
alternative)}とも呼ばれる。)
これは指定された以外の任意の文字とマッチする。つまり@samp{[^a-z0-9A-Z]}はASCII文字と数字@emph{以外}の、すべての文字にマッチする。

@samp{^}はブラケット式内では先頭に記述されない限り特別ではない。@samp{^}に続く文字は、あたかもそれが先頭にあるかのように扱われる(言い換えると@samp{-}や@samp{]}はここでは特別ではない)。

マッチしない文字の1つとして改行が記述されていなければ、補集合のブラケット式は改行にマッチできる。これは@code{grep}のようなプログラム内でのregexpの扱いとは対照的である。

ブラケット式のように名前付き文字クラスを指定できる。たとえば@samp{[^[:ascii:]]}は任意の非@acronym{ASCII}文字にマッチする。@ref{Char
Classes}を参照のこと。

@item @samp{^}
@cindex beginning of line in regexp
バッファーのマッチングの際には@samp{^}は空文字列、ただしマッチ対象のテキスト内にある行の先頭(またはバッファーのアクセス可能範囲の先頭)だけにマッチする。それ以外のマッチはすべて失敗する。つまり@samp{^foo}は行の先頭に出現する@samp{foo}にマッチする。

バッファーではなく文字列とマッチする際には、@samp{^}は文字列の先頭か改行文字の後にマッチする。

歴史的な互換性により@samp{^}は正規表現の先頭、または@samp{\(}、@samp{\(?:}、@samp{\|}の後にある場合のみ特別に扱われる。通常の文字のように@samp{^}が扱われる他のコンテキストにおいても、@samp{\\^}を用いるのはよい習慣である。

@item @samp{$}
@cindex @samp{$} in regexp
@cindex end of line in regexp
これは@samp{^}と似ているが、行の終端(またはバッファーのアクセス可能範囲の終端)だけにマッチする。つまり@samp{x+$}は行末にある1つ以上の@samp{x}からなる文字列にマッチする。

バッファーではなく文字列とマッチする際には、@samp{$}は文字列の終端か改行文字の前にマッチする。

歴史的な互換性により@samp{$}は正規表現の終端、または@samp{\)}、@samp{\|}の前でのみ特別に扱われる。通常の文字のように@samp{$}が扱われる他のコンテキストにおいても、@samp{\\$}を用いるのはよい習慣である。

@item @samp{\}
@cindex @samp{\} in regexp
これはスペシャル文字(@samp{\}を含む)のクォートと、追加のスペシャル文字の導入という2つの機能をもつ。

@samp{\}はスペシャル文字をクォートするので@samp{\$}は@samp{$}、@samp{\[}は@samp{[}だけにマッチする正規表現のようになる。

@samp{\}はLisp文字列(@ref{String Type}を参照)の入力構文(read
syntax)内でも特別な意味をもち、@samp{\}でクォートしなければならないことに注意。たとえば文字@samp{\}にマッチする正規表現は@samp{\\}。文字@samp{\\}を含むLisp文字列を記述するには、別の@samp{\}で@samp{\}をクォートすることをLisp構文は要求する。したがって@samp{\}にマッチする正規表現にたいする入力構文は@code{"\\\\"}となる。
@end table

歴史的な互換性のために、繰り返し演算子は正規表現の先頭または@samp{^}、@samp{\`}、@samp{\(}、@samp{\(?:}、@samp{\|}.の後にある場合のみ特別に扱われます。たとえば@samp{*foo}は@samp{\*foo}、@samp{two\|^\@{2\@}}は@samp{two\|^@{2@}}として扱われます。この挙動に頼るのは悪い習慣です。繰り返し演算子のある場所に関わらず、どこでも適切なバックスラッシュでエスケープするべきです。

ブラケット式内で@samp{\}は何ら特別ではないので@samp{-}、@samp{^}、@samp{]}がもつ特別な意味を取り除くことは決してありません。特別な意味をもたないような場合に、これらの文字をクォートするべきではありません。それによって何かが明確になる訳ではありません。なぜならバックスラッシュ以外の任意の1文字にマッチする@samp{[^\]}
(Lisp文字列構文では@code{"[^\\]"})の内部のように、これらの文字が@emph{特別な意味}をもつ箇所では、これらの文字にバックスラッシュを問題なく前置できるからです。

実際には正規表現内に出現する@samp{]}はブラケット式に近接しており、それ故そのほとんどがスペシャル文字です。しかしリテラルの@samp{[}と@samp{]}の複雑なパターンにたいしてマッチを試みることも時にはあるかもしれません。そのような状況ではブラケット式を囲う角カッコがどれなのかを判断するために、regexpを最初から注意深く解析することが必要なときもあるかもしれません。たとえば@samp{[^][]]}は補集合のブラケット式@samp{[^][]}
(角カッコ以外の任意の1文字とマッチする)と、その後のリテラルの@samp{]}により構成されます。

厳密にはregexp先頭の@samp{[}は特別で、@samp{]}は特別ではないというのがルールです。これはクォートされていない最初の@samp{[}で終わり、その後はブラケット式になります。(文字クラス開始を除き)@samp{[}はもはや特別ではありませんが、@samp{]}は直後にスペシャル文字@samp{[}があるか、その@samp{[}の後に@samp{^}がある場合を除いて特別です。これは文字クラス終了ではない次のスペシャル文字@samp{]}まで続きます。これはブラケット式を終了させて、通常の正規表現の構文をリストアします。クォートされていない@samp{[}は再び特別となり、@samp{]}は特別ではなくなります。

@node Char Classes
@subsubsection 文字クラス
@cindex character classes in regexp
@cindex ascii character class, regexp
@cindex alnum character class, regexp
@cindex alpha character class, regexp
@cindex xdigit character class, regexp

  以下はブラケット式(@ref{Regexp Special, bracket
expression}を参照)の中で使用できるクラスと意味のテーブルです。クラス名を囲む@samp{[}と@samp{]}の文字は名前の一部なので、これらのクラスを使用する正規表現では1つ余分にカッコ(brackets)が必要になります。たとえば1つ以上のアルファベットか数字のシーケンスにマッチする正規表現は、@samp{[:alnum:]+}ではなく@samp{[[:alnum:]]+}です。

@table @samp
@item [:ascii:]
これは任意の@acronym{ASCII}文字(コード0 -- 127)にマッチする。
@item [:alnum:]
これは任意の英数字にマッチする。マルチバイト文字では、アルファベット文字か数字であることを示すUnicodeプロパティ@samp{general-category}
(@ref{Character Properties}を参照)をもつ文字にマッチする。
@item [:alpha:]
これは任意のアルファベットにマッチする。マルチバイト文字では、アルファベット文字であることを示すUnicodeプロパティ@samp{general-category}
(@ref{Character Properties}を参照)をもつ文字にマッチする。
@item [:blank:]
これは Unicode Technical Standard #18のAnnex Cで定義される水平の空白文字(horizontal
whitespace)にマッチする。特にスペース、タブ、およびスペース区切りであることをUnicodeの@samp{general-category}プロパティ(@ref{Character
Properties}を参照)が示す他の文字にマッチする。
@item [:cntrl:]
これはコードが1から31の範囲にあるすべての文字にマッチする。
@item [:digit:]
これは@samp{0}から@samp{9}までにマッチする。つまり@samp{[-+[:digit:]]}は@samp{+}と@samp{-}、同様に任意の数にマッチする。
@item [:graph:]
これはUnicodeの@samp{general-category}プロパティで示されるようなグラフィック文字(スペース文字、@acronym{ASCII}と非@acronym{ASCII}の制御文字、サロゲートコードポイント、Unicodeで未割り当てのコードポイントを除くすべて)にマッチする(@ref{Character
Properties}を参照)。
@item [:lower:]
これはカレントのcaseテーブル(@ref{Case
Tables}を参照)で小文字と判断される文字すべてにマッチする。@code{case-fold-search}が非@code{nil}なら大文字にもマッチする。バッファーはデフォルトとは異なるローカルのcaseテーブルを独自にもてることに注意。
@item [:multibyte:]
これは任意のマルチバイト文字にマッチする(@ref{Text Representations}を参照)。
@item [:nonascii:]
これは非@acronym{ASCII}文字にマッチする。
@item [:print:]
これは任意のプリント文字(スペース文字か@samp{[:graph:]}でマッチされるグラフィック文字のいずれか)にマッチする。
@item [:punct:]
これは任意の句読点文字(punctuation
character)にマッチする(現在のところマルチバイト文字では単語構文以外のすべてにマッチするが、文字の構文はメジャーモード次第なのでメジャーモードごとに正確な定義は様々である)。
@item [:space:]
空白文字の構文(@ref{Syntax Class
Table}を参照)をもつ任意の文字にマッチする。文字の構文、すなわち何の文字を``空白''とみなすかはメジャーモード次第だということに注意。
@item [:unibyte:]
これは任意のユニバイト文字(@ref{Text Representations}を参照)にマッチする。
@item [:upper:]
これはカレントのcaseテーブル(@ref{Case
Tables}を参照)で大文字と判断される文字すべてにマッチする。@code{case-fold-search}が非@code{nil}ならこれは小文字にもマッチする。バッファーはデフォルトとは異なるローカルのcaseテーブルを独自にもてることに注意。
@item [:word:]
単語の構文(@ref{Syntax Class
Table}を参照)をもつ任意の文字にマッチする。文字の構文、すなわち何の文字を``単語の構成文字''とみなすかはメジャーモード次第だということに注意。
@item [:xdigit:]
これは16進数の数字@samp{0}から@samp{9}、@samp{a}から@samp{f}と@samp{A}から@samp{F}にマッチする。
@end table

@samp{[:space:]}、@samp{[:word:]}、@samp{[:punct:]}はカレントバッファーの構文テーブルを使用するクラスですが、オーバーライドする構文のテキストプロパティには使用しません(@ref{Syntax
Properties}を参照)。

@node Regexp Backslash
@subsubsection 正規表現内のバッククラッシュ構文
@cindex backslash in regular expressions

  ほとんどの場合では、@samp{\}の後の任意の文字はその文字だけにマッチします。しかし例外もいくつかあります。@samp{\}で始まる特定のシーケンスには、特別な意味をもつものがあります。以下は特別な@samp{\}構成要素のテーブルです。

@table @samp
@item \|
@cindex @samp{|} in regexp
@cindex regexp alternative
これは選択肢を指定する。2つの正規表現@var{a}と@var{b}、その間にある@samp{\|}により、@var{a}か@var{b}のいずれかにマッチする表現が形成される。

つまり@samp{foo\|bar}は、@samp{foo}か@samp{bar}のいずれかにマッチして他の文字列にはマッチしない。

@samp{\|}は周囲の適用可能な最大の表現に適用される。@samp{\|}を取り囲む@samp{\( @dots{}
\)}でグループ化することによりグループ化の効力を制限できる。

複数の@samp{\|}の処理するための完全なバックトラッキング互換が必要なら、POSIX正規表現関数を使用すること(@ref{POSIX
Regexps}を参照)。

@item \@{@var{m}\@}
これは前のパターンを正確に@var{m}回繰り返す後置演算子。つまり@samp{x\@{5\@}}は文字列@samp{xxxxx}にマッチして、それ以外にはマッチしない。@samp{c[ad]\@{3\@}r}は@samp{caaar}、@samp{cdddr}、@samp{cadar}等にマッチする。

@item \@{@var{m},@var{n}\@}
これは最小で@var{m}回、最大で@var{n}回繰り返すより一般的な後置演算子。@var{m}省略時の最小は0、@var{n}省略時の最大は存在しない。いずれの形式でも@var{m}や@var{n}が指定された場合には、
@ifnottex
2**16 @minus{} 1
@end ifnottex
@tex
@math{2^{16}-1}
@end tex
より大きくなることはない。

たとえば@samp{c[ad]\@{1,2\@}r}は文字列@samp{car}、@samp{cdr}、@samp{caar}、@samp{cadr}、@samp{cdar}、@samp{cddr}にマッチして、それ以外にはマッチしない。@*@samp{\@{0,1\@}}や@samp{\@{,1\@}}は@samp{?}と同じ。@*@samp{\@{0,\@}}や@samp{\@{,\@}}は@samp{*}と同じ。@*@samp{\@{1,\@}}は@samp{+}と同じ。

@item \( @dots{} \)
@cindex @samp{(} in regexp
@cindex @samp{)} in regexp
@cindex regexp grouping
これは以下の3つの目的を果たす役目をもつグループ化構成要素:

@enumerate
@item
他の操作のために一連の@samp{\|}選択肢を囲う。つまり正規表現@samp{\(foo\|bar\)x}は、@samp{foox}か@samp{barx}のいずれかにマッチする。

@item
後置演算子@samp{*}、@samp{+}、@samp{?}による複雑な表現を囲う。つまり@samp{ba\(na\)*}は@samp{ba}、@samp{bana}、@samp{banana}、@samp{bananana}、...等の任意の数(0以上)の文字列@samp{na}にマッチする。

@item
@samp{\@var{digit}} (以下参照)による将来の参照にたいして、マッチする部分文字列を記録する。
@end enumerate

この最後の目的はカッコによるグループ化というアイデアによるものではない。これは同じ構成要素@samp{\( @dots{}
\)}にたいする2つ目の目的に割当てられた別の機能だが、実際のところ2つの意味は衝突しない。しかし稀に衝突が発生することがあり、それが内気(shy)なグループの導入をもたらした。

@item \(?: @dots{} \)
@cindex shy groups
@cindex non-capturing group
@cindex unnumbered group
@cindex @samp{(?:} in regexp
これは@dfn{内気なグループ(shy
group)}の構成要素。内気なグループは通常のグループの最初の2つの役目(他の演算子のネスト制御)を果たすが、これは番号を取得せず@samp{\@var{digit}}でその値を後方参照できない。内気なグループは通常の非内気なグループを変更することなく自動的に追加できるので、機械的に正規表現を構築するのに特に適している。

内気なグループ化は@dfn{非キャプチャリング(non-capturing)}、@dfn{番号なしグループ(unnumbered
groups)}とも呼ばれる。

@item \(?@var{num}: @dots{} \)
これは@dfn{明示的番号付きグループ(explicitly numbered
group)}の構成要素。通常のグループ化では位置をもとに番号が暗黙で取得されるが、これが不便な場合もあるだろう。この構成要素により特定のグループに番号を強制できる。番号の付与に特別な制限はなく、複数のグループに同じ番号を付与でき、その場合は最後の1つ(もっとも右のマッチ)がマッチとして採用される。暗黙に番号付けされたグループは、常に前のグループより大きい最小の整数となる番号を取得する。

@item \@var{digit}
これはグループ構成要素(@samp{\( @dots{} \)})の@var{digit}番目にマッチしたテキストと同じテキストにマッチする。

言い換えると最後のグループの後に、マッチ処理はそのグループによりマッチされたテキストの開始と終了を記憶する。その正規表現の先の箇所で@samp{\}とその後に@var{digit}を使用すれば、それが何であれ同じテキストにマッチさせることができる。

検索やマッチングを行う関数に渡される正規表現全体の中で、最初の9つのグループ化構成要素にマッチする文字列には、その正規表現内で開カッコが出現する順に1から9までの番号が割り当てられる。したがって@samp{\1}から@samp{\9}までを使用して、対応するグループ化構成要素によりマッチされたテキストを参照できる。

たとえば@samp{\(.*\)\1}は、一方がもう一方と等しいような2つの文字列から構成される、改行を含まない任意の文字列にマッチする。@samp{\(.*\)}は前半分にマッチし、これは何でもよいが、それに続く@samp{\1}はそれと同じテキストに正確にマッチしなければならない。

構成要素@samp{\( @dots{}
\)}が2回以上マッチする場合(これはたとえば後に@samp{*}をしたがえるとき発生し得る)には最後のマッチだけが記録される。

正規表現内の特定のグループ化構成要素がマッチしなかった場合には、たとえばそれが使用されない選択肢内にあったり、回数が0回の繰り返しの内部にあるなら、それに対応する@samp{\@var{digit}}構文は何にもマッチしない。作為的な例を用いると@samp{\(foo\(b*\)\|lose\)\2}は@samp{lose}にマッチできない。外側のグループ内の2つ目の選択肢がマッチするが、@samp{\2}が未定義となり何にたいしてもマッチできない。しかし@samp{foobb}にたいしては、1つ目の選択肢が@samp{foob}にマッチして、@samp{\2}が@samp{b}にマッチするのでマッチが可能になる。

@item \w
@cindex @samp{\w} in regexp
これは任意の単語構成文字にマッチする。エディターの構文テーブルが、どの文字が単語構成文字かを決定する。@ref{Syntax
Tables}を参照のこと。

@item \W
@cindex @samp{\W} in regexp
これは任意の非単語構成文字にマッチする。

@item \s@var{code}
@cindex @samp{\s} in regexp
これは構文が@var{code}であるような任意の文字にマッチする。ここで@var{code}は、構文コードを表す文字。@samp{w}は単語構成要素、@samp{-}は空白文字、@samp{(}は開カッコ、...等。空白文字構文を表すには、@samp{-}かスペース文字のいずれかを使用する。構文コードとそれらを意味する文字のリストは@ref{Syntax
Class Table}を参照のこと。

@item \S@var{code}
@cindex @samp{\S} in regexp
これは構文が@var{code}でないような任意の文字にマッチする。

@cindex category, regexp search for
@item \c@var{code}
これはカテゴリーが@var{code}であるような任意の文字にマッチする。ここで@var{code}はカテゴリーを表す文字。たとえば標準カテゴリーテーブルでは@samp{c}はChinese(中国語)、@samp{g}はGreek(ギリシャ語)の文字を表す。@w{@kbd{M-x
describe-categories
@key{RET}}}で現在定義済みの全カテゴリーのリストを確認できる。@code{define-category}関数を使用すれば、標準カテゴリーに加えて独自カテゴリーを定義することもできる(@ref{Categories}を参照)。

@item \C@var{code}
これはカテゴリーが@var{code}ではない任意の文字にマッチする。
@end table

  以下は空文字列にマッチします(つまり文字を何も消費しない)が、マッチするかどうかがコンテキストに依存するような正規表現を構築します。これらすべてにたいして、そのバッファーのアクセス可能範囲の先頭と終端は、あたかもそのバッファーの実際の先頭と終端のように扱われます。

@table @samp
@item \`
@cindex @samp{\`} in regexp
これは空文字列、ただしバッファー先頭またはマッチ対象の文字列の先頭だけにマッチする。

@item \'
@cindex @samp{\'} in regexp
これは空文字列、ただしバッファー終端またはマッチ対象の文字列の終端だけにマッチする。

@item \=
@cindex @samp{\=} in regexp
これは空文字列、ただしポイント位置だけにマッチする(この構成要素はマッチ対象が文字列なら定義されない)。

@item \b
@cindex @samp{\b} in regexp
これは空文字列、ただし単語の先頭だけにマッチする。つまり@samp{\bfoo\b}は個別の単語として出現する@samp{foo}だけにマッチする。@samp{\bballs?\b}は、個別の単語として@samp{ball}か@samp{balls}にマッチする。

@samp{\b}は、隣接するテキストが何であるかと無関係に、バッファー(か文字列)の先頭または終端にマッチする。

@item \B
@cindex @samp{\B} in regexp
これは空文字列、単語の先頭や終端、またはバッファー(か文字列)の先頭や終端@emph{以外}にマッチする。

@item \<
@cindex @samp{\<} in regexp
これは空文字列、ただし単語の先頭だけにマッチする。@samp{\<}は後に単語構成文字が続く場合のみバッファー(か文字列)の先頭にマッチする。

@item \>
@cindex @samp{\>} in regexp
これは空文字列、ただし単語の終端だけにマッチする。@samp{\<}はコンテンツが単語構成文字で終わる場合のみバッファー(か文字列)の終端にマッチする。

@item \_<
@cindex @samp{\_<} in regexp
これは空文字列、ただしシンボルの先頭だけにマッチする。シンボルとは1つ以上の単語かシンボル構成文字のシーケンス。@samp{\_<}は後にシンボル構成文字が続く場合のみバッファー(か文字列)の先頭にマッチする。

@item \_>
@cindex @samp{\_>} in regexp
これは空文字列、ただし単語の終端だけにマッチする。@samp{\_>}はコンテンツがシンボル構成文字で終わる場合のみバッファー(か文字列)の終端にマッチする。
@end table

@kindex invalid-regexp
  すべての文字列が、有効な正規表現な訳ではありません。たとえば終端の@samp{]}がないブラケット式の内側で終わる文字列は無効であり、単一の@samp{\}で終わる文字列も同様です。いずれかの検索関数にたいして無効な正規表現が渡されると@code{invalid-regexp}エラーがシグナルされます。

@node Regexp Example
@subsection 正規表現の複雑な例

  以下は後続の空白文字とともにセンテンスの終わりを認識するために、以前のEmacsで使用されていた複雑な正規表現の例です(現在のEmacsは関数@code{sentence-end}により構築される、同様のより複雑なregexpを使用する。@ref{Standard
Regexps}を参照)。

  以下ではまず、(スペースとタブ文字を区別するために)Lisp構文の文字列としてregexpを示して、それを評価した結果を示します。文字列定数の開始と終了はダブルクォーテーションです。@samp{\"}は文字列の一部としてのダブルクォーテーション、@samp{\\}は文字列の一部としてのバックスラッシュ、@samp{\t}はタブ、@samp{\n}は改行を意味します。

@example
@group
"[.?!][]\"')@}]*\\($\\| $\\|\t\\|@ @ \\)[ \t\n]*"
     @result{} "[.?!][]\"')@}]*\\($\\| $\\|  \\|@ @ \\)[
]*"
@end group
@end example

@noindent
改行とタブは、それら自身として出力されます。

  この正規表現は連続する4つのパートを含み、以下のように解読できます:

@table @code
@item [.?!]
この正規表現の1つ目のパートはピリオド、疑問符、感嘆符の3つのうちいずれか1つにマッチするブラケット式。マッチはこれら3つの文字のいずれかで開始されなければならない(これは旧正規表現とEmacsが使用する新たなデフォルトregexpが異なる1つのポイントである。新たな値は後続の空白文字なしでセンテンスを終端する、いくつかの非@acronym{ASCII}文字を許容する)。

@item []\"')@}]*
パターンの2つ目のパートは任意の0個以上の閉カッコとクォーテーションマークであり、その後にピリオド、疑問符、感嘆符があるかもしれない。@code{\"}は文字列内でのダブルクォーテーションマークにたいするLisp構文。最後の@samp{*}は直前の正規表現(この場合はブラケット式)の0回以上の繰り返しを示す。

@item \\($\\|@ $\\|\t\\|@ @ \\)
パターンの3つ目のパートはセンテンスの後の空白文字、すなわち行の終端(スペースがあっても可)、タブ、または2つのスペースにマッチする。2連バックスラッシュはカッコと垂直バーを正規表現構文としてマークする。すなわちカッコはグループを句切り、垂直バーは選択肢を区別する。ダラー記号は行の終端へのマッチに使用される。

@item [ \t\n]*
最後にパターンの最終パートはセンテンスを終端させるために必要とされる以上の、余分な空白文字にマッチする。
@end table

@ifnottex
@code{rx} (@ref{Rx Notation}を参照)表記では以下のようにregexpを記述できます

@example
@group
(rx (any ".?!")                    ; センテンスを終端する区切り文字
    (zero-or-more (any "\"')]@}"))  ; 終わりのクォートやカッコ
    (or line-end
        (seq " " line-end)
        "\t"
        "  ")                      ; 2つのスペース
    (zero-or-more (any "\t\n ")))  ; オプションの余分な空白文字
@end group
@end example

@code{rx}によるregexpsは単なるS式なので、このように整形してコメントを付することができるのです。
@end ifnottex

@ifnottex
@node Rx Notation
@subsection @code{rx}構造化Rgexp表記
@cindex rx
@cindex regexp syntax

  文字ベースの構文にたいする代替えとして、EmacsはLispのS式にもとづく構造化された@code{rx}表記を提供します。この表記により通常はregexp文字列をより簡単に読解、記述、保守することができ、自由にインデントしてコメントを記述できます。regexp関数が期待するのは文字列形式なので変換が必要になりますが、この変換はregexpを使用するLispコードの実行時ではなく、通常はバイトコンパイルの間に行われます。

  以下はCプログラム言語のブロックコメントにマッチする@code{rx}のregexpです@footnote{これは非欲張りな演算子でもっと簡単に記述できるかもしれませんが(どうやって?)、例が面白くなくなるでしょう。}。

@example
@group
(rx "/*"                          ; 始まりの/*
    (zero-or-more
     (or (not (any "*"))          ;  非*
         (seq "*"                 ;  または
              (not (any "/")))))  ;  /が後置されていない*
    (one-or-more "*")             ; 少なくとも1つの*
    "/")                          ; と終わりの/
@end group
@end example

@noindent
短いシノニムを使用してより簡潔に記述すると、

@example
@group
(rx "/*"
    (* (| (not "*")
          (: "*" (not "/"))))
    (+ "*") "/")
@end group
@end example

@noindent
従来の文字列構文では以下のような記述になります

@example
"/\\*\\(?:[^*]\\|\\*[^/]\\)*\\*+/"
@end example

@code{rx}表記は主にLispコード内で有用です。@code{query-replace-regexp}の実行時や変数のカスタマイゼーションのように、regexpが要求されるインタラクティブな状況下では使用することができません。

@menu
* Rx Constructs::            rxフォームで有効な構成。
* Rx Functions::             rxフォームを使用する関数とマクロ。
* Extending Rx::             独自のrxフォームを定義する方法。
@end menu

@node Rx Constructs
@subsubsection @code{rx}によるregexpの構築

@code{rx}のregexpsにおける種々のフォームを以下で説明します。省略形式として使用する@var{rx}は任意の@var{rx}フォームを表します。@var{rx}@dots{}は0個以上の@var{rx}フォームを表し、特に明記しないかぎりこれらのフォームは@code{(seq
@dots{})}というサブフォームで括られているかのように順にマッチします。

以下はすべて@code{rx}マクロにたいする有効な引数です。これらのフォームはすべて記述のされ方によって定義されます。それぞれに記述されている文字列regexpは、単に理解を容易にするために提供されています。(適切なカッコで括られた)@var{A}、@var{B}、@dots{}は、それらの部分式における文字列regexpを意味します。

@subsubheading リテラル

@table @asis
@item @code{"some-string"}
文字列@samp{some-string}にリテラル(文字通り)にマッチする。文字列regexpsとは異なり特別な意味をもつ文字はない。

@item @code{?C}
文字@samp{C}にリテラルにマッチする。
@end table

@subsubheading シーケンスと候補

@table @asis
@item @code{(seq @var{rx}@dots{})}
@cindex @code{seq} in rx
@itemx @code{(sequence @var{rx}@dots{})}
@cindex @code{sequence} in rx
@itemx @code{(: @var{rx}@dots{})}
@cindex @code{:} in rx
@itemx @code{(and @var{rx}@dots{})}
@cindex @code{and} in rx
順に@var{rx}をマッチする。引数なしなら、その式は空文字列にマッチする。@*対応する文字列regexpは@samp{@var{A}@var{B}@dots{}}
(シーケンス内の部分式)。

@item @code{(or @var{rx}@dots{})}
@cindex @code{or} in rx
@itemx @code{(| @var{rx}@dots{})}
@cindex @code{|} in rx
@var{rx}のうちのいずれか1つに正確にマッチする。すべての引数が文字列か文字、またはそのような@code{or}フォームなら、可能な最長マッチを常に使用する。それ以外なら最長のマッチ、または(L2R順で)最初のマッチのいずれかを使用する。引数なしなら、その式は何にもマッチすることはない。@*対応する文字列regexpは@samp{@var{A}\|@var{B}\|@dots{}}。

@item @code{unmatchable}
@cindex @code{unmatchable} in rx
すべてのマッチを拒絶する。@code{(or)}と等価。@ref{regexp-unmatchable}を参照のこと。
@end table

@subsubheading 繰り返し

繰り返しフォームは通常は可能なかぎり多数回のマッチを試みるので欲張り(greedy)です。いくつかのフォームは可能なかぎり少数回のマッチを試みるので非欲張り(non-greedy)です(@ref{Non-greedy
repetition}を参照)。

@table @code
@item (zero-or-more @var{rx}@dots{})
@cindex @code{zero-or-more} in rx
@itemx (0+ @var{rx}@dots{})
@cindex @code{0+} in rx
@var{rx}に0回以上マッチする。デフォルトでは欲張り。@*対応する文字列regexpは@samp{@var{A}*}
(欲張り)、@samp{@var{A}*?} (非欲張り)。

@item (one-or-more @var{rx}@dots{})
@cindex @code{one-or-more} in rx
@itemx (1+ @var{rx}@dots{})
@cindex @code{1+} in rx
@var{rx}に1回以上マッチする。デフォルトでは欲張り。@*対応する文字列regexpは@samp{@var{A}+}
(欲張り)、@samp{@var{A}+?} (非欲張り)。

@item (zero-or-one @var{rx}@dots{})
@cindex @code{zero-or-one} in rx
@itemx (optional @var{rx}@dots{})
@cindex @code{optional} in rx
@itemx (opt @var{rx}@dots{})
@cindex @code{opt} in rx
@var{rx}に1回、または空文字列にマッチする。デフォルトでは欲張り。@*対応する文字列regexpは@samp{@var{A}?}
(欲張り)、@samp{@var{A}??} (非欲張り)。

@item (* @var{rx}@dots{})
@cindex @code{*} in rx
@var{rx}に0回以上マッチする。欲張り。@*対応する文字列regexpは@samp{@var{A}*}。

@item (+ @var{rx}@dots{})
@cindex @code{+} in rx
@var{rx}に1回以上マッチする。欲張り。@*対応する文字列regexpは@samp{@var{A}+}。

@item (? @var{rx}@dots{})
@cindex @code{?} in rx
@var{rx}に1回、または空文字列にマッチする。欲張り。@*対応する文字列regexpは@samp{@var{A}?}。

@item (*? @var{rx}@dots{})
@cindex @code{*?} in rx
@var{rx}に0回以上マッチする。非欲張り。@*対応する文字列regexpは@samp{@var{A}*?}。

@item (+? @var{rx}@dots{})
@cindex @code{+?} in rx
@var{rx}に1回以上マッチする。非欲張り。@*対応する文字列regexpは@samp{@var{A}+?}。

@item (?? @var{rx}@dots{})
@cindex @code{??} in rx
@var{rx}、または空文字列にマッチする。非欲張り。@*対応する文字列regexpは@samp{@var{A}??}。

@item (= @var{n} @var{rx}@dots{})
@cindex @code{=} in rx
@itemx (repeat @var{n} @var{rx})
@var{rx}に正確に@var{n}回マッチする。@*対応する文字列regexpは@samp{@var{A}\@{@var{n}\@}}。

@item (>= @var{n} @var{rx}@dots{})
@cindex @code{>=} in rx
@var{rx}に@var{n}回以上マッチする。欲張り。@*対応する文字列regexpは@samp{@var{A}\@{@var{n},\@}}。

@item (** @var{n} @var{m} @var{rx}@dots{})
@cindex @code{**} in rx
@itemx (repeat @var{n} @var{m} @var{rx}@dots{})
@cindex @code{repeat} in rx
@var{rx}に少なくとも@var{n}回、ただし@var{m}回を超えない回数マッチする。欲張り。@*対応する文字列regexpは@samp{@var{A}\@{@var{n},@var{m}\@}}。
@end table

いくつかの繰り返しフォームの欲張りの度合いは以下の構文を使用して制御できます。しかしそのようなマッチングが要求される際には、通常は上述した明示的な非欲張りフォームを使用するほうがよいでしょう。

@table @code
@item (minimal-match @var{rx})
@cindex @code{minimal-match} in rx
非欲張りなマッチングを使用して@code{zero-or-more}、@code{0+}、@code{one-or-more}、@code{1+}、@code{zero-or-one}、@code{opt}、@code{optional}により@var{rx}をマッチする。

@item (maximal-match @var{rx})
@cindex @code{maximal-match} in rx
欲張りなマッチングを使用して@code{zero-or-more}、@code{0+}、@code{one-or-more}、@code{1+}、@code{zero-or-one}、@code{opt}、@code{optional}により@var{rx}をマッチする。これがデフォルト。
@end table

@subsubheading 単一文字のマッチ

@table @asis
@item @code{(any @var{set}@dots{})}
@cindex @code{any} in rx
@itemx @code{(char @var{set}@dots{})}
@cindex @code{char} in rx
@itemx @code{(in @var{set}@dots{})}
@cindex @code{in} in rx
@cindex character class in rx
@var{set}のいずれかより1文字をマッチする。@var{set}はそれぞれ文字、それ自身が文字セットを表す文字列、範囲、または文字クラス(以下参照)。範囲は@code{"A-Z"}のようにハイフンで区切られた文字列、または@code{(?A
. ?Z)}のようなコンスセル。

この構文における文字列内のハイフン(@code{-})は範囲区切りとして振る舞うのでスペシャル。ハイフンを含めるには区切り文字か単一文字の文字列として追加する。@*対応する文字列regexpは@samp{[@dots{}]}。

@item @code{(not @var{charspec})}
@cindex @code{not} in rx
@var{charspec}に含まれない文字にマッチする。@var{charspec}は文字、単一文字の文字列、フォーム@code{any}、@code{not}、@code{or}、@code{intersection}、@code{syntax}、@code{category}、または文字クラス。@var{charspec}が@code{or}フォームなら、その引数には@code{intersection}の引数と同じ制限がある。以下参照。@*対応する文字列regexpは@samp{[^@dots{}]}、@samp{\S@var{code}}、@samp{\C@var{code}}。

@item @code{(intersection @var{charset}@dots{})}
@cindex @code{intersection} in rx
@var{charset}に含まれるすべての文字にマッチする。@var{charset}はそれぞれ文字、単一文字の文字列、文字クラスなしの@code{any}フォーム、または引数が@var{charset}であるような@code{intersection}、@code{or}、@code{not}フォーム。

@item @code{not-newline}、@code{nonl}
@cindex @code{not-newline} in rx
@cindex @code{nonl} in rx
改行を除くすべての文字にマッチする。@*対応する文字列regexpは@samp{.} (ドット)。

@item @code{anychar}、@code{anything}
@cindex @code{anychar} in rx
@cindex @code{anything} in rx
すべての文字にマッチする。@*対応する文字列regexpはたとえば@samp{.\|\n}。

@item 文字クラス
@cindex character class in rx
以下の名前つき文字クラスの文字にマッチする:

@table @asis
@item @code{alpha}、@code{alphabetic}、@code{letter}
アルファベット文字にマッチする。より正確には、Unicodeの@samp{general-category}プロパティがアルファベット文字であることを示すような文字にマッチする。

@item @code{alnum}、@code{alphanumeric}
アルファベット文字と数字にマッチする。より正確には、Unicodeの@samp{general-category}プロパティがアルファベット文字か10進数字であることを示すような文字にマッチする。

@item @code{digit}、@code{numeric}、@code{num}
@samp{0}から@samp{9}の数字にマッチする。

@item @code{xdigit}、@code{hex-digit}、@code{hex}
@samp{0}から@samp{9}、@samp{A}から@samp{F}および@samp{a}から@samp{f}の16進数字にマッチする。

@item @code{cntrl}、@code{control}
コードが0から31の範囲の任意の文字にマッチする。

@item @code{blank}
水平空白文字(horizontal
whitespace)にマッチする。より正確には、Unicodeの@samp{general-category}プロパティがスペース区切り文字(spacing
separators)であることを示すような文字にマッチする。

@item @code{space}、@code{whitespace}、@code{white}
空白文字構文をもつすべての文字にマッチする(@ref{Syntax Class Table}を参照)。

@item @code{lower}、@code{lower-case}
カレントのcaseテーブルで小文字として判断されるすべての文字にマッチする。@code{case-fold-search}が非@code{nil}ならすべての大文字にもマッチする。

@item @code{upper}、@code{upper-case}
カレントのcaseテーブルで大文字として判断されるすべての文字にマッチする。@code{case-fold-search}が非@code{nil}ならすべての小文字にもマッチする。

@item @code{graph}、@code{graphic}
Unicodeの@samp{general-category}プロパティで示されるような空白文字、@acronym{ASCII}と非@acronym{ASCII}の制御文字、サロゲートコードポイント、Unicodeで未割り当てのコードポイントを除くすべての文字にマッチする。

@item @code{print}、@code{printing}
空白文字か@code{graph}にマッチする文字にマッチする。

@item @code{punct}、@code{punctuation}
任意の句読点文字(punctuation character)にマッチする(現在のところマルチバイト文字では非単語構文のすべてにマッチする)。

@item @code{word}、@code{wordchar}
単語構文(@ref{Syntax Class Table}を参照)をもつ任意の文字にマッチする。

@item @code{ascii}
任意の@acronym{ASCII}文字(コード0から127)にマッチする。

@item @code{nonascii}
非@acronym{ASCII}文字(ただしrawバイト以外)にマッチする。
@end table

@code{space}、@code{word}、@code{punct}はカレントバッファーの構文テーブルを使用するクラスですが、オーバーライドする構文のテキストプロパティには使用しない(@ref{Syntax
Properties}を参照)。@* 対応する文字列regexp: @samp{[[:@var{class}:]]}

@item @code{(syntax @var{syntax})}
@cindex @code{syntax} in rx
以下の名前のいずれかの構文@var{syntax}の文字にマッチする。

@multitable {@code{close-parenthesis}} {Syntax character}
@headitem 構文名          @tab 構文文字
@item @code{whitespace}        @tab @code{-}
@item @code{punctuation}       @tab @code{.}
@item @code{word}              @tab @code{w}
@item @code{symbol}            @tab @code{_}
@item @code{open-parenthesis}  @tab @code{(}
@item @code{close-parenthesis} @tab @code{)}
@item @code{expression-prefix} @tab @code{'}
@item @code{string-quote}      @tab @code{"}
@item @code{paired-delimiter}  @tab @code{$}
@item @code{escape}            @tab @code{\}
@item @code{character-quote}   @tab @code{/}
@item @code{comment-start}     @tab @code{<}
@item @code{comment-end}       @tab @code{>}
@item @code{string-delimiter}  @tab @code{|}
@item @code{comment-delimiter} @tab @code{!}
@end multitable

詳細は@ref{Syntax Class Table}を参照のこと。@code{(syntax
punctuation)}は文字クラス@code{punctuation}と@emph{等価ではない}ことに注意してほしい。@*対応する文字列regexpは@samp{\s@var{char}}
(@var{char}は構文文字)。

@item @code{(category @var{category})}
@cindex @code{category} in rx
以下のカテゴリー名かカテゴリー文字のいずれかであるようなカテゴリー@var{category}の文字にマッチする.

@multitable {@code{vowel-modifying-diacritical-mark}} {Category character}
@headitem カテゴリー名                       @tab カテゴリー文字
@item @code{space-for-indent}                 @tab スペース
@item @code{base}                             @tab @code{.}
@item @code{consonant}                        @tab @code{0}
@item @code{base-vowel}                       @tab @code{1}
@item @code{upper-diacritical-mark}           @tab @code{2}
@item @code{lower-diacritical-mark}           @tab @code{3}
@item @code{tone-mark}                        @tab @code{4}
@item @code{symbol}                           @tab @code{5}
@item @code{digit}                            @tab @code{6}
@item @code{vowel-modifying-diacritical-mark} @tab @code{7}
@item @code{vowel-sign}                       @tab @code{8}
@item @code{semivowel-lower}                  @tab @code{9}
@item @code{not-at-end-of-line}               @tab @code{<}
@item @code{not-at-beginning-of-line}         @tab @code{>}
@item @code{alpha-numeric-two-byte}           @tab @code{A}
@item @code{chinese-two-byte}                 @tab @code{C}
@item @code{greek-two-byte}                   @tab @code{G}
@item @code{japanese-hiragana-two-byte}       @tab @code{H}
@item @code{indian-two-byte}                  @tab @code{I}
@item @code{japanese-katakana-two-byte}       @tab @code{K}
@item @code{strong-left-to-right}             @tab @code{L}
@item @code{korean-hangul-two-byte}           @tab @code{N}
@item @code{strong-right-to-left}             @tab @code{R}
@item @code{cyrillic-two-byte}                @tab @code{Y}
@item @code{combining-diacritic}              @tab @code{^}
@item @code{ascii}                            @tab @code{a}
@item @code{arabic}                           @tab @code{b}
@item @code{chinese}                          @tab @code{c}
@item @code{ethiopic}                         @tab @code{e}
@item @code{greek}                            @tab @code{g}
@item @code{korean}                           @tab @code{h}
@item @code{indian}                           @tab @code{i}
@item @code{japanese}                         @tab @code{j}
@item @code{japanese-katakana}                @tab @code{k}
@item @code{latin}                            @tab @code{l}
@item @code{lao}                              @tab @code{o}
@item @code{tibetan}                          @tab @code{q}
@item @code{japanese-roman}                   @tab @code{r}
@item @code{thai}                             @tab @code{t}
@item @code{vietnamese}                       @tab @code{v}
@item @code{hebrew}                           @tab @code{w}
@item @code{cyrillic}                         @tab @code{y}
@item @code{can-break}                        @tab @code{|}
@end multitable

カレントで定義されているカテゴリーに関する情報は、コマンド@kbd{M-x describe-categories
@key{RET}}を実行する。新たなカテゴリーを定義する方法については@ref{Categories}を参照のこと。@*対応する文字列regexpは@samp{\c@var{char}}
(@var{char}はカテゴリー文字)。
@end table

@subsubheading 0幅アサーション

これらはすべて空文字列、ただし特定箇所箇所だけにマッチします。

@table @asis
@item @code{line-start}、@code{bol}
@cindex @code{line-start} in rx
@cindex @code{bol} in rx
行の先頭にマッチする。@*対応する文字列regexpは@samp{^}。

@item @code{line-end}、@code{eol}
@cindex @code{line-end} in rx
@cindex @code{eol} in rx
行の終端にマッチする。@*対応する文字列regexpは@samp{$}。

@item @code{string-start}、@code{bos}、@code{buffer-start}、@code{bot}
@cindex @code{string-start} in rx
@cindex @code{bos} in rx
@cindex @code{buffer-start} in rx
@cindex @code{bot} in rx
マッチする文字列かバッファーの先頭にマッチする。@*対応する文字列regexpは@samp{\`}。

@item @code{string-end}、@code{eos}、@code{buffer-end}、@code{eot}
@cindex @code{string-end} in rx
@cindex @code{eos} in rx
@cindex @code{buffer-end} in rx
@cindex @code{eot} in rx
マッチする文字列かバッファーの終端にマッチする。@*対応する文字列regexpは@samp{\'}。

@item @code{point}
@cindex @code{point} in rx
ポイントにマッチする。@*対応する文字列regexpは@samp{\=}。

@item @code{word-start}、@code{bow}
@cindex @code{word-start} in rx
@cindex @code{bow} in rx
単語の先頭にマッチする。@*対応する文字列regexpは@samp{\<}。

@item @code{word-end}、@code{eow}
@cindex @code{word-end} in rx
@cindex @code{eow} in rx
単語の終端にマッチする。@*対応する文字列regexpは@samp{\>}。

@item @code{word-boundary}
@cindex @code{word-boundary} in rx
単語の先頭か終端にマッチする。@*対応する文字列regexpは@samp{\b}。

@item @code{not-word-boundary}
@cindex @code{not-word-boundary} in rx
単語の先頭と終端以外のすべての箇所にマッチする。@*対応する文字列regexpは@samp{\B}。

@item @code{symbol-start}
@cindex @code{symbol-start} in rx
シンボルの先頭にマッチする。@*対応する文字列regexpは@samp{\_<}。

@item @code{symbol-end}
@cindex @code{symbol-end} in rx
シンボルの終端にマッチする。@*対応する文字列regexpは@samp{\_>}。
@end table

@subsubheading キャプチャーグループ

@table @code
@item (group @var{rx}@dots{})
@cindex @code{group} in rx
@itemx (submatch @var{rx}@dots{})
@cindex @code{submatch} in rx
マッチデータ内でマッチしたテキストと位置にアクセスできるように@var{rx}をマッチする。regexpの1つ目のグループは番号1、それ以降のグループはパターン内でそれ以前に最大の番号が付与されたグループより1つ大きい番号が付与される。@*対応する文字列regexpは@samp{\(@dots{}\)}。

@item (group-n @var{n} @var{rx}@dots{})
@cindex @code{group-n} in rx
@itemx (submatch-n @var{n} @var{rx}@dots{})
@cindex @code{submatch-n} in rx
@code{group}と同様だがグループ番号@var{n}を明示的に割り当てる。@var{n}は正でなければならない。@*対応する文字列regexpは@samp{\(?@var{n}:@dots{}\)}。

@item (backref @var{n})
@cindex @code{backref} in rx
前にグループ番号@var{n}でマッチされたテキストにマッチする。@var{n}は1から9の範囲になければならない。@*対応する文字列regexpは@samp{\@var{n}}。
@end table

@subsubheading 動的インクルージョン

@table @code
@item (literal @var{expr})
@cindex @code{literal} in rx
Lisp式@var{expr}を評価した結果であるリテラル文字列とマッチする。評価はカレントのレキシカル環境で呼び出し時に行われる。

@item (regexp @var{expr})
@cindex @code{regexp} in rx
@itemx (regex @var{expr})
@cindex @code{regex} in rx
Lisp式@var{expr}を評価した結果であるregexpとマッチする。評価はカレントのレキシカル環境で呼び出し時に行われる。

@item (eval @var{expr})
@cindex @code{eval} in rx
Lisp式@var{expr}を評価した結果であるrxとマッチする。評価は@code{rx-to-string}呼び出しの際のマクロ展開時に、カレントのグローバル環境で行われる。
@end table

@node Rx Functions
@subsubsection @code{rx}のregexpを使用する関数とマクロ

@defmac rx rx-form@dots{}
@var{rx-form}があたかも@code{(seq
@dots{})}フォームのbodyであるかのように文字列regexpに変換する。@code{rx}マクロは文字列定数、または@code{literal}か@code{regexp}フォームが使用されていたら文字列に評価されるLisp式に展開される。たとえば:

@example
@group
(rx (+ alpha) "=" (+ digit))
  @result{} "[[:alpha:]]+=[[:digit:]]+"
@end group
@end example
@end defmac

@defun rx-to-string rx-expr &optional no-group
@var{rx-expr}をリターンされる文字列regexpに変換する。@var{no-group}が省略または@code{nil}の場合には、後に付加する後置演算子が式全体に適用されるために、必要なら結果を非キャプチャリンググループ@samp{\(?:@dots{}\)}としてカッコで括る。たとえば:

@example
@group
(rx-to-string '(seq (+ alpha) "=" (+ digit)) t)
  @result{} "[[:alpha:]]+=[[:digit:]]+"
@end group
@end example

@var{rx-expr}内のフォーム@code{literal}および@code{regexp}にたいする引数は、文字列リテラルでなければならない。
@end defun

@code{pcase}マクロはパターンとして直接@code{rx}式を使用できます。@ref{rx in pcase}を参照してください。

@code{rx}表記へのユーザー定義の拡張メカニズムについては、@ref{Extending Rx}を参照してください。

@node Extending Rx
@subsubsection 新たな@code{rx}フォームの定義

新たなシンボル他の@code{rx}式にたいしてパラメーター化されたフォームを定義することにより、@code{rx}表記を拡張できます。これにより手軽にパーツを複数のregexp間で共有して、より小さな断片を互いに組み合わせて、複雑なregexpをより簡単に構築、理解することができます。

たとえば@code{(one-or-more letter)}を意味する@code{name}や、任意の@var{x}にたいして@code{(seq
?' @var{x} ?')}を意味する@code{(quoted
@var{x})}を定義できます。これらのフォームは他の@code{rx}式と同様に使用できます。@code{(rx (quoted
name))}はシングルクォート内の非空の文字シーケンスにマッチするでしょう。

以下のLispマクロは定義にたいして名前を構築する別の手段を提供します。以下のルールはこれらすべてにたいして共通です:

@itemize
@item
@code{digit}や@code{group}のようなビルトインの@code{rx}フォームは再定義不可。

@item
定義ははLisp変数のネームスペースから分離された、自身のネームスペース内でのみ有効。したがって名前に@code{-regexp}のようなサフィックスを付加する必要はない。これらが他と衝突することはあり得ない。

@item
直接か間接かを問わず、定義は自身を再帰的に参照できない。これを行う必要があることを見い出したなら、あなたが望むのは正規表現ではなくパーサーである。

@item
定義は定義マクロに存在するだけでは展開されず、@code{rx}や@code{rx-to-string}の呼び出し内でのみ展開される。これはたとえ定義が互いを参照している際でも定義の順序は問題ではなく、定義の構文エラーは定義時ではなく使用時のみ顕現することを意味する。

@item
@code{rx}式が期待される任意の箇所でユーザー定義フォームが許される。たとえば@code{zero-or-one}フォームのbody内では許されるが、@code{any}や@code{category}のフォーム内では許されない。これらは@code{not}および@code{intersection}のフォーム内でも許される。
@end itemize

@defmac rx-define name [arglist] rx-form
すべての後続する@code{rx}および@code{rx-to-string}呼び出しにおいて、グローバルに@var{name}を定義する。@var{arglist}を省略すると、@var{name}は@var{rx-form}で置き換えられるプレーンシンボルとして定義される。たとえば:

@example
@group
(rx-define haskell-comment (seq "--" (zero-or-more nonl)))
(rx haskell-comment)
     @result{} "--.*"
@end group
@end example

@var{arglist}が与えられた場合には0個以上の引数名のリストでなければならず、その場合には@var{name}はパラメーター化されたフォームとして定義される。@code{(@var{name}
@var{arg}@dots{})}として@code{rx}式内で使用時には、@var{arg}はそれぞれ@var{rx-form}内部の対応する引数名に置き換えられる。

@var{arglist}は@code{&rest}と残りのパラメーターを示す最後の引数名で終わる場合がある。残りのパラメーターは@var{arglist}内の他のパラメーターにマッチしないすべての追加引数の実際の値に展開されて、@var{rx-form}の出現箇所へとスプライスされる。たとえば:

@example
@group
(rx-define moan (x y &rest r) (seq x (one-or-more y) r "!"))
(rx (moan "MOO" "A" "MEE" "OW"))
     @result{} "MOOA+MEEOW!"
@end group
@end example

定義はグローバルなので、@var{name}には非ローカルな変数や関数を通常命名する際のように、別の場所の定義名との競合を避けるためにパッケージプレフィックスを付与することを推奨する。

この方法で定義したフォームは単純なテンプレート置換だけを行う。計算を任意で行うには@code{rx}フォームの@code{eval}、@code{regexp}、@code{literal}とともに使用すること。たとえば:

@example
@group
(defun n-tuple-rx (n element)
  `(seq "<"
        (group-n 1 ,element)
        ,@@(mapcar (lambda (i) `(seq ?, (group-n ,i ,element)))
                  (number-sequence 2 n))
        ">"))
(rx-define n-tuple (n element) (eval (n-tuple-rx n 'element)))
(rx (n-tuple 3 (+ (in "0-9"))))
  @result{} "<\\(?1:[0-9]+\\),\\(?2:[0-9]+\\),\\(?3:[0-9]+\\)>"
@end group
@end example
@end defmac

@defmac rx-let (bindings@dots{}) body@dots{}
@var{body}内の@code{rx}マクロ呼び出しで@var{bindings}内の@code{rx}をローカルに使用可能にしてから評価する。

@var{bindings}の各要素は@w{@code{(@var{name} [@var{arglist}]
@var{rx-form})}}という形式をもち、各パーツは上述の@code{rx-define}の場合と同じ意味をもつ。たとえば:

@example
@group
(rx-let ((comma-separated (item) (seq item (0+ "," item)))
         (number (1+ digit))
         (numbers (comma-separated number)))
  (re-search-forward (rx "(" numbers ")")))
@end group
@end example

定義は@var{body}のマクロ展開の間だけ利用可能であり、したがってコンパイル済みコードの実行の間は存在しない。

@code{rx-let}は関数内部だけではなく、@code{rx}フォームの共通セットの共有を要するグローバルな変数および関数に含めるためにトップレベルでも使用できる。名前は@var{body}内部でローカルなので、何のパッケージプレフィックスも必要としない。たとえば:

@example
@group
(rx-let ((phone-number (seq (opt ?+) (1+ (any digit ?-)))))
  (defun find-next-phone-number ()
    (re-search-forward (rx phone-number)))
  (defun phone-number-p (string)
    (string-match-p (rx bos phone-number eos) string)))
@end group
@end example

@code{rx-let}のスコープはレキシカルであり、これはたとえ@var{body}から呼び出される関数であってみ、@var{body}自身の外部からは不可視であることを意味する。
@end defmac

@defmac rx-let-eval bindings body@dots{}
@code{rx-let}のように@var{bindings}をバインディングのリストに評価して、@code{rx-to-string}呼び出しに有効なこれらバインディングによって@var{body}を評価する。

このマクロは@code{rx-let}と同様だが、@var{bindings}を評価して(したがってリストリテラルならクォート要)、定義が実行時(@code{rx-to-string}が機能するために必要)に置換される点が異なる。たとえば:

@example
@group
(rx-let-eval
    '((ponder (x) (seq "Where have all the " x " gone?")))
  (looking-at (rx-to-string
               '(ponder (or "flowers" "young girls"
                            "left socks")))))
@end group
@end example

他に@code{rx-let}と異なるのは、@var{bindings}はダイナミックにスコープされるので、@var{body}から呼び出される関数内でも利用可能なことである。しかし@var{body}内で定義される関数の内部では不可視。
@end defmac

@end ifnottex

@node Regexp Functions
@subsection 正規表現の関数

  以下の関数は正規表現を扱います。

@cindex quote special characters in regexp
@defun regexp-quote string
この関数は@var{string}だけに正確にマッチするような正規表現をリターンする。@code{looking-at}内でこの正規表現を使用すると、そのバッファー内の次の文字が@var{string}のときだけ成功するだろう。検索関数でのこの正規表現の使用は、検索されるテキストが@var{string}を含むなら成功するだろう。@ref{Regexp
Search}を参照のこと。

これにより、その正規表現を求める関数呼び出し時に正確な文字列マッチや検索を要求できる。

@example
@group
(regexp-quote "^The cat$")
     @result{} "\\^The cat\\$"
@end group
@end example

正規表現として記述されたコンテキストにおいて、正確な文字列マッチを結合することが@code{regexp-quote}の1つの使い方である。たとえば以下は空白文で囲まれた@var{string}の値であるような文字列を検索する:

@example
@group
(re-search-forward
 (concat "\\s-" (regexp-quote string) "\\s-"))
@end group
@end example

スペシャル文字を何も含まなければ、リターンされる文字列は@var{string}自身となるだろう。
@end defun

@cindex optimize regexp
@defun regexp-opt strings &optional paren
@c E.g., see https://debbugs.gnu.org/2816
この関数はリスト@var{strings}の文字列だけにマッチする効果的な正規表現をリターンする。これはマッチングや検索を可能な限り高速にする必要があるとき、たとえばFont
Lockモードで有用である@footnote{@code{regexp-opt}の結果が絶対的にもっとも効率的であるという保証はないことに注意してください。手作業でチューニングした正規表現のほうがわずかに効率的なこともありますが、これに努力する価値はほとんどないでしょう。}。

@var{strings}が空リストなら、リターン値は何にもマッチすることはないregexpとなる。

オプション引数@var{paren}には以下のいずれかを指定できる:

@table @asis
@item 文字列
結果となるregexpの前に@var{paren}、後に@samp{\)}が付加される。たとえば@samp{"\\(?1:"}を使用すると番号付きのグループを明示的に生成する。

@item @code{words}
結果となるregexpは@samp{\<\(}と@samp{\)\>}で括られる。

@item @code{symbols}
結果となるregexpは@samp{\_<\(}と@samp{\)\_>}で括られる(これはプログラミング言語のキーワードの類のマッチング時にしばしば適している)。

@item 非@code{nil}
結果となるregexpは@samp{\(}と@samp{\)}で括られる。

@item @code{nil}
後に付加する後置演算子が式全体に適用されるために必要なら、結果となるregexpは@samp{\(?:}と@samp{\)}で括られる。
@end table

リターンされるregexpは可能な最長文字列に常にマッチする方法の順序に整列される。

再整列されるまで@code{regexp-opt}の結果regexpはその単純化されたバージョンと等価だが、通常はより効果的である。

@example
(defun simplified-regexp-opt (strings &optional paren)
 (let ((parens
        (cond
         ((stringp paren)       (cons paren "\\)"))
         ((eq paren 'words)    '("\\<\\(" . "\\)\\>"))
         ((eq paren 'symbols) '("\\_<\\(" . "\\)\\_>"))
         ((null paren)          '("\\(?:" . "\\)"))
         (t                       '("\\(" . "\\)")))))
   (concat (car parens)
           (mapconcat 'regexp-quote strings "\\|")
           (cdr parens))))
@end example
@end defun

@defun regexp-opt-depth regexp
この関数は@var{regexp}内のグループ化された構成要素(カッコで囲まれた正規表現)の総数をリターンする。これには内気なグループは含まれない(@ref{Regexp
Backslash}を参照)。
@end defun

@c Supposedly an internal regexp-opt function, but table.el uses it at least.
@defun regexp-opt-charset chars
この関数は文字リスト@var{chars}内の文字にマッチする正規表現をリターンする。

@example
(regexp-opt-charset '(?a ?b ?c ?d ?e))
     @result{} "[a-e]"
@end example
@end defun

@c Internal functions: regexp-opt-group

@anchor{regexp-unmatchable}
@defvar regexp-unmatchable
この変数はすべての文字列にマッチしないことが保証されたregexpを含む。これは実際に何かとマッチするようにセットされ得る変数用のデフォルト値として特に有用。
@end defvar

@node Regexp Problems
@subsection 正規表現にまつわるトラブル
@cindex regular expression problems
@cindex regexp stack overflow
@cindex stack overflow in regexp

Emacsのregexp実装は他の多くの類似する実装と同じように概ね堅牢ですが、2つの問題のいずれかを引き起こすことがあります。それはマッチングが内部スタックスペースを使い果たしてエラーをシグナルしたり、完了まで長時間を要するかもしれないという問題です。以下のアドバイスはこれらの症状を軽減して、発生する問題を緩和する助けとなるでしょう。

@itemize
@item
ゼロ幅アサーション(@samp{^}および@code{\`})の使用による行、文字列、あるいはバッファー先頭のアンカーregexp。これは実装内部の高速パスを利用して、無駄なマッチングの試行を回避できる。これら以外のゼロ幅アサーションでも、早期にマッチを失敗させることによる利益が得られるかもしれない。

@item
orパターンを避けてブラケット式を使う(@samp{a\|b}のかわりに@samp{[ab]}と記述する)。@samp{\s-}および@samp{\sw}はそれぞれ、@samp{[[:space:]]}および@samp{[[:word:]]}とほとんどの場合には等価であることを思い出してほしい。

@item
orパターン最後の分岐はバックトラックポイントをスタックに追加しないので、もっともマッチしそうなパターンを最後に配置するよう検討する。たとえば@samp{^\(?:a\|.b\)*c}は@samp{a}からなる非常に長い文字列へのマッチを試みるとスタックを使い果たすだろうが、これと等価な@samp{^\(?:.b\|a\)*c}ならそのようなことはない。

(これはトレードオフである。マッチに成功するorパターンは、もっとも頻繁にマッチするパターンを最初にすると実行が高速になる。)

@item
テキストの任意の部分がただ1つの方法でのみマッチするよう試みる。たとえば@samp{a*a*}は同じ文字列セット@samp{a*}にマッチするだろうが、前者は多くの方法でマッチを行うので、そのマッチが後で失敗すると低速なバックトラッキングを引き起こすだろう。可能ならorパターンの分岐を互いに排他にすることによって、そのマッチが失敗する前に2つ以上先の分岐には進まなくなる。

ネストした繰り返しには特に注意。曖昧さが存在すると、それらのマッチングが非常に低速になるのは容易である。たとえば@samp{\(?:a*b*\)+c}は@samp{a}からなる適切な長さの文字列にたいするマッチ試行でも、失敗までに長時間を要するだろう。これと等価な@samp{\(?:a\|b\)*c}はより高速であり、@samp{[ab]*c}は更に良い。

@item
本当に必要でないならキャプチャリングを使用しない。つまりカッコで括るのが目的なら@samp{\(@dots{}\)}のかわりに@samp{\(?:@dots{}\)}を使用する。

@ifnottex
@item
@code{rx}の使用を検討する(@ref{Rx
Notation}を参照)。これはいくつかのorパターンを自動的に最適化するとともに、明示的に要求されなければキャプチャリンググループを決して導入しない。
@end ifnottex
@end itemize

上記アドバイスにしたがってなおregexpがスタックオーバーフローするようなら、ためらうことなくマッチングを複数の関数呼び出しで行い、それぞれの関数呼び出しではバックトラッキングが容易に含まれるように単純なregexpを使ってください。

@defun re--describe-compiled regexp &optional raw
regexpやregexpエンジン自体の問題の診断を助けるために、この関数はコンパイルされた形式の@var{regexp}を記述する文字列をリターンする。これを理解するためには最低限、Emacsのソースコードのファイル@code{src/regex-emacs.c}にあるタイプ@code{re_opcode_t}の説明を読解できる必要があるかもしれない。

現在のところは@code{--enable-checking}を指定してEmacsをビルドした場合のみ、意味のある記述を得ることができる。
@end defun

@node Regexp Search
@section 正規表現の検索
@cindex regular expression searching
@cindex regexp searching
@cindex searching for regexp

  GNU Emacsではインクリメンタルと非インクリメンタルの両方で正規表現(@ref{Syntax of
Regexps}を参照)にたいする次のマッチを検索できます。インクリメンタル検索コマンドについては@ref{Regexp Search, ,
Regular Expression Search, emacs, The GNU Emacs
Manual}を参照してください。ここではプログラム内で有用な検索関数だけを説明します。重要な関数は@code{re-search-forward}です。

  これらの検索関数はバッファーがマルチバイトならルチバイト、ユニバイトならユニバイトに正規表現を変換します。@ref{Text
Representations}を参照してください。

@deffn Command re-search-forward regexp &optional limit noerror count
この関数はカレントバッファー内で、正規表現@var{regexp}にマッチするテキスト文字列を前方へ検索する。この関数は@var{regexp}にマッチしない任意の量のテキストをスキップして、見つかった最初のマッチの終端にポイントを残す。これはポイントの新たな値をリターンする。

引数@var{limit}は検索の境界を指定し、それはカレントバッファー内の位置であること。@var{limit}が非@code{nil}ならカレントバッファー内の位置でなければならない。これは検索の上限位置を指定するその位置を超えるようなマッチは、受け入れられない。@var{limit}が省略または@code{nil}の場合のデフォルトは、そのバッファーのアクセス可能範囲の終端である。

検索失敗時に@code{re-search-forward}が何を行うかは@var{noerror}の値に依存する。

@table @asis
@item @code{nil}
@code{search-failed}エラーをシグナルする。
@item @code{t}
何もせず@code{nil}をリターンする。
@item その他
ポイントを@var{limit} (またはバッファーのアクセス可能範囲の終端)に移動して@code{nil}をリターンする。
@end table

引数@var{noerror}はマッチに失敗した有効な検索だけに影響する。無効な引数は@var{noerror}とは無関係にエラーとなる。

@var{count}が正の数@var{n}なら、それは繰り返し回数の役目をもつ。検索は@var{n}回繰り返され、前回のマッチの終端から毎回検索が開始される。これらの連続する検索が成功した場合、関数は成功となりポイントを移動して新たな値をリターンする。それ以外は検索失敗となり、上述したように結果は@var{noerror}の値に依存する。@var{count}が負の数
@minus{}@var{n}なら、それは逆方向(後方)への検索の繰り返し回数@var{n}としての役目をもつ。

以下の例ではポイントは最初は@samp{T}の前にある。この検索を評価することにより、その行の終端(
@samp{hat}の@samp{t}と改行の間)にポイントは移動する。

@example
@group
---------- Buffer: foo ----------
I read "@point{}The cat in the hat
comes back" twice.
---------- Buffer: foo ----------
@end group

@group
(re-search-forward "[a-z]+" nil t 5)
     @result{} 27

---------- Buffer: foo ----------
I read "The cat in the hat@point{}
comes back" twice.
---------- Buffer: foo ----------
@end group
@end example
@end deffn

@c This anchor is referenced by re-search-backward's docstring.
@anchor{re-search-backward}
@deffn Command re-search-backward regexp &optional limit noerror count
この関数はカレントバッファー内で正規表現@var{regexp}にマッチするテキスト文字列を後方へ検索して、見つかった最初のマッチの先頭にポイントを残す。

この関数は@code{re-search-forward}と似ているが単なるミラーイメージ(mirror-image:
鏡像)ではない。@code{re-search-forward}は先頭が開始ポイントと可能な限り近いマッチを探す。@code{re-search-backward}が完全なミラーイメージなら終端が可能な限り近いマッチを探すだろう。しかし実際には先頭が可能な限り近い(かつ開始ポイントの前で終わる)マッチを探す。これは与えられた位置にたいする正規表現マッチングが常に正規表現の先頭から終端に機能して、指定された開始位置から開始されることが理由。

@code{re-search-forward}の真のミラーイメージには、正規表現を終端から先頭へマッチする特別な機能が要求されるだろう。それを実装することによる問題と比較して、値する価値はない。
@end deffn

@defun string-match regexp string &optional start inhibit-modify
この関数は@var{string}内で正規表現@var{regexp}にたいする最初のマッチの開始位置のインデックスをリターンする。@var{string}内のそのインデックスから検索が開始される。

たとえば、

@example
@group
(string-match
 "quick" "The quick brown fox jumped quickly.")
     @result{} 4
@end group
@group
(string-match
 "quick" "The quick brown fox jumped quickly." 8)
     @result{} 27
@end group
@end example

@noindent
文字列の最初の文字のインデックスは1、2文字目は2、...となる。

この関数がマッチを見つけたら、デフォルトではそのマッチの先の最初の文字のインデックスは@code{(match-end
0)}で利用できる。@ref{Match
Data}を参照のこと。@var{inhibit-modify}が非@code{nil}なら、マッチデータを変更しない。

@example
@group
(string-match
 "quick" "The quick brown fox jumped quickly." 8)
     @result{} 27
@end group

@group
(match-end 0)
     @result{} 32
@end group
@end example
@end defun

@defun string-match-p regexp string &optional start
この述語関数は@code{string-match}と同じことを行うが、マッチデータの変更を避ける。
@end defun

@defun looking-at regexp &optional inhibit-modify
この関数はカレントバッファー内のポイント直後のテキストが正規表現@var{regexp}にマッチするかどうかを判断する。``直後''の正確な意味は、その検索が``固定''されていて、ポイントの後の最初の文字からマッチが開始する場合のみ成功するということ。成功なら結果は@code{t}、それ以外は@code{nil}。

この関数はポイントを移動しないが、@var{inhibit-modify}が@code{nil}か省略(デフォルト)ならマッチデータは更新する。@ref{Match
Data}を参照のこと。利便性のために、@var{inhibit-modify}引数のかわりに、下記の@code{looking-at-p}を使うことができる。

以下の例ではポイントは@samp{T}の直前にある。それ以外の場所にあれば結果は@code{nil}になるだろう。

@example
@group
---------- Buffer: foo ----------
I read "@point{}The cat in the hat
comes back" twice.
---------- Buffer: foo ----------

(looking-at "The cat in the hat$")
     @result{} t
@end group
@end example
@end defun

@defun looking-back regexp limit &optional greedy
この関数はポイントの直前の(ポイントで終わる)テキストが@var{regexp}とマッチしたら@code{t}、それ以外は@code{nil}をリターンする。

正規表現マッチングは前方だけに機能するので、ポイントで終わるマッチをポイントから後方へ検索するように実装された。長い距離を検索する必要がある場合には、これは極めて低速になり得る。非@code{nil}値を@var{limit}を指定してその前を検索しないよう告げることにより、検索に要する時間を制限できる。この場合には、マッチデータは@var{limit}かその後で始まらなければならない。以下は例:

@example
@group
---------- Buffer: foo ----------
I read "@point{}The cat in the hat
comes back" twice.
---------- Buffer: foo ----------

(looking-back "read \"" 3)
     @result{} t
(looking-back "read \"" 4)
     @result{} nil
@end group
@end example

@var{greedy}が非@code{nil}なら、この関数は可能な限り後方へマッチを拡張して、前方の1文字が@var{regexp}がマッチの一部とならなければ停止する。マッチが拡張されたときには、マッチ開始位置が@var{limit}の前にあっても許される。

@c https://debbugs.gnu.org/5689
一般的に@code{looking-back}は低速なので、可能な限り使用を避けることを推奨する。この理由により@code{looking-back-p}の追加は計画されていない。
@end defun

@defun looking-at-p regexp
この述語関数は@code{looking-at}と同様に機能するがマッチデータを更新しない。
@end defun

@defvar search-spaces-regexp
この変数が非@code{nil}なら、それは空白文字を検索する方法を告げる正規表現であること。この場合には検索される正規表現内のすべてのスペース属は、この正規表現を使用することを意味する。しかし@samp{[@dots{}]}、@samp{*}@samp{+}、@samp{?}のような構文要素内のスペースは@code{search-spaces-regexp}の影響を受けない。

Since this variable affects all regular expression search and match
constructs, you should bind it temporarily for as small as possible a part
of the code, and only where the Lisp code affected by the binding performs
searches whose regexp was produced from interactive user input.  In other
words, this variable should only be used to tell regexp search primitives
how to interpret whitespace typed by the user.
@end defvar

@node Longest Match
@section 正規表現のマッチにたいする最長マッチの検索

@cindex backtracking and POSIX regular expressions
  通常の正規表現関数は、@samp{\|}や繰り返しの構文要素を処理するために必要なときだけバックトラッキングを行いますが、@emph{何らか}のマッチが見つかるまでの間だけこれを継続します。そして成功した後に見つかった最初のマッチを報告します。

  このセクションでは正規表現にたいしてPOSIX標準で指定された完全なバックトラッキングを処理する他の検索関数を説明します。これらはPOSIXが要求する最長マッチを報告できるようにすべての可能なマッチを試みて、すべてのマッチが見つかるまでバックトラッキングを継続します。これは非常に低速なので、本当に最長マッチが必要なときだけこれらの関数を使用してください。

  名前とは裏腹にPOSIXの検索とマッチ関数は、POSIXではなくEmacsの正規表現を使用しています。@ref{POSIX
Regexps}を参照してください。さらにこれらの正規表現は非欲張りな繰り返し演算子(@ref{Regexp Special,
non-greedy}を参照)を正しくサポートしていません。これはPOSIXのバックトラッキングが非欲張りな繰り返しのセマンチックと競合するからです。

@deffn Command posix-search-forward regexp &optional limit noerror count
これは@code{re-search-forward}と似ているが、正規表現マッチングにたいしてPOSIX標準が指定する完全なバックトラッキングを行う点が異なる。
@end deffn

@deffn Command posix-search-backward regexp &optional limit noerror count
これは@code{re-search-backward}と似ているが、正規表現マッチングにたいしてPOSIX標準が指定する完全なバックトラッキングを行う点が異なる。
@end deffn

@defun posix-looking-at regexp &optional inhibit-modify
これは@code{looking-at}と似ているが、正規表現マッチングにたいしてPOSIX標準が指定する完全なバックトラッキングを行う点が異なる。
@end defun

@defun posix-string-match regexp string &optional start inhibit-modify
これは@code{string-match}と似ているが、正規表現にたいしてPOSIX標準が指定する完全なバックトラッキングを行う点が異なる。
@end defun

@node Match Data
@section マッチデータ
@cindex match data

  Emacsは検索の間に見つかったテキスト片の開始と終了の位置を追跡します。これは@dfn{マッチデータ(match
data)}と呼ばれます。このマッチデータのおかげで、メールメッセージ内のデータのような複雑なパターンを検索した後に、そのパターンの制御下でマッチ部分を抽出できるのです。

  マッチデータには通常はもっとも最近の検索だけが記述されるので、後で参照したい検索とそのマッチデータの使用の間に誤って別の検索を行わないように注意しなければなりません。誤って別の検索を避けるのが不可能な場合には、マッチデータの上書きを防ぐために前後でマッチデータの保存とリストアを行わなければなりません。

  上書きを行わないと明記されていない限り、すべての関数は上書きを許されていることに注意してください。結果としてバックグラウンド(@ref{Timers}と@ref{Idle
Timers}を参照)で暗黙に実行される関数は、おそらく明示的にマッチデータの保存とリストアを行うべきでしょう。

@menu
* Replacing Match::          マッチされた部分文字列の置換。
* Simple Match Data::        特定の部分式開始箇所のようなマッチデータの単一アイテムへのアクセス。
* Entire Match Data::        リストとしてマッチデータ全体に一度にアクセスする。
* Saving Match Data::        マッチデータの保存とリストア。
@end menu

@node Replacing Match
@subsection マッチしたテキストの置換
@cindex replace matched text

  以下の関数は、最後の検索でマッチされたテキストのすべて、または一部を置換します。これはマッチデータにより機能します。

@cindex case in replacements
@defun replace-match replacement &optional fixedcase literal string subexp
この関数はバッファーや文字列にたいして置換処理を行う。

あるバッファーで最後の検索を行った場合には、@var{string}引数を省略または@code{nil}を指定すること。また最後に検索を行ったバッファーがカレントバッファーであることを確認すること。その場合には、この関数はマッチしたテキストを@var{replacement}で置換することにより、そのバッファーを編集する。これは置換したテキスト終端にポイントを残す。

文字列にたいして最後の検索を行った場合には、同じ文字列が@var{string}に渡される。その場合には、この関数はマッチしたテキストが@var{replacement}に置き換えられた新たなテキストをリターンする。

@var{fixedcase}が非@code{nil}なら@code{replace-match}は大文字小文字を変更せずに置換テキストを使用して、それ以外は置換されるテキストがcapitalize(先頭が大文字)されているかどうかに応じて、置換テキストを変換する。元のテキストがすべて大文字なら置換テキストを大文字に変換する。元のテキストの単語すべてがcapitalizeされていたら置換テキストのすべての単語をcapitalizeする。すべての単語が1文字かつ大文字なら、それらはすべて大文字の単語ではなくcapitalizeされた単語として扱われる。

@var{literal}が非@code{nil}なら@var{replacement}はそのまま挿入されるが、必要に応じてcaseの変更だけが行われる。これが@code{nil}(デフォルト)なら文字@samp{\}は特別に扱われる。@var{replacement}内に@samp{\}が出現した場合には、それは以下のシーケンスのいずれかの一部でなければならない:

@table @asis
@item @samp{\&}
@cindex @samp{&} in replacement
これは置換されるテキスト全体を意味する。

@item @samp{\@var{n}} （@var{n}は数字)
@cindex @samp{\@var{n}} in replacement
これは元のregexpの@var{n}番目の部分式にマッチするテキストを意味する。この部分式とは@samp{\(@dots{}\)}の内部にグループかされた式のこと。@var{n}番目のマッチがなければ空文字列が代用される。

@item @samp{\\}
@cindex @samp{\} in replacement
これは置換テキスト内で単一の@samp{\}を意味する。

@item @samp{\?}
これはそれ自身を意味する(@code{replace-regexp}と関連するコマンドの互換用。@ref{Regexp Replace,,,
emacs, The GNU Emacs Manual}を参照)。
@end table

@noindent
これら以外の@samp{\}に続く文字はエラーをシグナルする。

@samp{\&}や@samp{\@var{n}}により行われる代替えは、もしあればcase変換の後に発生する。したがって代替えする文字列は決してcase変換されない。

@var{subexp}が非@code{nil}なら、それは全体のマッチではなくマッチされたregexpの部分式番号@var{subexp}だけを置換することを指定する。たとえば@samp{foo
\(ba*r\)}のマッチング後に@code{replace-match}を呼び出すと、@var{subexp}が1なら@samp{\(ba*r\)}にマッチしたテキストだけを置換することを意味する。
@end defun

@defun match-substitute-replacement replacement &optional fixedcase literal string subexp
この関数は@code{replace-match}によりバッファーに挿入されるであろうテキストをリターンするがバッファーを変更しない。これは@samp{\@var{n}}や@samp{\&}のような構文要素をマッチしたグループで置き換えた実際の結果をユーザーに示したいとき有用。引数@var{replacement}、およびオプションの@var{fixedcase}、@var{literal}、@var{string}、@var{subexp}は@code{replace-match}のときと同じ意味をもつ。
@end defun

@node Simple Match Data
@subsection 単純なマッチデータへのアクセス

  このセクションでは最後の検索やマッチング操作で、それが成功した場合に何がマッチされたのかを調べるために、マッチデータを使用する方法について説明します。

  マッチしたテキスト全体または正規表現のカッコで括られた特定の部分式にたいして問い合わせることができます。以下の関数では、@var{count}によりどの部分式かを指定できます。@var{count}が0ならマッチ全体、@var{count}が正なら望む部分式を指定します。

  正規表現での部分式とは、エスケープされたカッコ@samp{\(@dots{}\)}でグループ化された表現だったことを思い出してください。@var{count}番目の部分式は正規表現全体の先頭から@samp{\(}を数えることで見つけられます。最初の部分式が1、2つ目が2、...となります。正規表現だけが部分式をもつことができ、単純な文字列検索の後で利用できるのはマッチ全体の情報だけです。

  成功したすべての検索はマッチデータをセットします。したがって検索後は別の検索を行うかもしれない関数を呼び出す前に、検索の直後にマッチデータを問い合わせるべきです。別の検索を呼び出すかもしれない関数の前後で、かわりにマッチデータの保存とリストアすることもできます(@ref{Saving
Match Data}を参照)。または@code{string-match-p}のようなマッチデータを変更しないと明示されている関数を使用してください。

@c This is an old comment and presumably there is no prospect of this
@c changing now.  But still the advice stands.
  検索が成功しようと失敗しようとマッチデータは変更されます。現在はこのように実装されていますが、これは将来変更されるかもしれません。失敗した後のマッチデータを信用しないでください。

@defun match-string count &optional in-string
この関数は最後の検索やマッチ処理でマッチしたテキストを文字列としてリターンする。これは@var{count}が0ならテキスト全体、@var{count}が正なら@var{count}番目のカッコで括られた部分式に対応する部分だけをリターンする。

そのような最後の処理が文字列にたいする@code{string-match}呼び出しなら、引数@var{in-string}には同じ文字列を渡すこと。バッファーの検索やマッチの後は、@var{in-string}を省略するか@code{nil}を渡すこと。しかし最後に検索やマッチを行ったバッファーが、@code{match-string}呼び出し時にカレントバッファーであることを確認すること。このアドバイスにしたがわなければ誤った結果となるだろう。

@var{count}が範囲外、@samp{\|}選択肢内部の部分式が使用されない、または0回の繰り返しなら値は@code{nil}。
@end defun

@defun match-string-no-properties count &optional in-string
この関数は@code{match-string}と似ているが結果がテキストプロパティをもたない点が異なる。
@end defun

@defun match-beginning count
最後の正規表現検索がマッチを見つけたら、この関数はマッチしたテキストか部分式の開始位置をリターンする。

@var{count}が0なら値はマッチ全体の開始位置。それ以外なら@var{count}は正規表現内の部分式を指定するので、この関数の値はその部分式にたいするマッチの開始位置。

使用されない、あるいは0回の繰り返しであるような@samp{\|}選択肢内部の部分式にたいしての値は@code{nil}。
@end defun

@defun match-end count
この関数は@code{match-beginning}と似ているがマッチの開始ではなく終了位置である点が異なる。
@end defun

  以下はマッチデータを使用する例です。コメントの数字はテキスト内での位置を示しています:

@example
@group
(string-match "\\(qu\\)\\(ick\\)"
              "The quick fox jumped quickly.")
              ;0123456789
     @result{} 4
@end group

@group
(match-string 0 "The quick fox jumped quickly.")
     @result{} "quick"
(match-string 1 "The quick fox jumped quickly.")
     @result{} "qu"
(match-string 2 "The quick fox jumped quickly.")
     @result{} "ick"
@end group

@group
(match-beginning 1)       ; @r{@samp{qu}にたいするマッチ先頭の}
     @result{} 4                 ;   @r{インデックスは4}
@end group

@group
(match-beginning 2)       ; @r{@samp{ick}にたいするマッチ先頭の}
     @result{} 6                 ;   @r{インデックスは6}
@end group

@group
(match-end 1)             ; @r{@samp{qu}にたいするマッチ終端の}
     @result{} 6                 ;   @r{インデックスは6}

(match-end 2)             ; @r{@samp{ick}にたいするマッチ終端の}
     @result{} 9                 ;   @r{インデックスは9}
@end group
@end example

  別の例を以下に示します。ポイントは最初は行の先頭にあります。検索の後はポイントはスペースと単語@samp{in}の間にあります。マッチ全体の先頭はバッファーの9つ目の文字@samp{T}、1つ目の部分式にたいするマッチの先頭は13番目の文字@samp{c}です。

@example
@group
(list
  (re-search-forward "The \\(cat \\)")
  (match-beginning 0)
  (match-beginning 1))
    @result{} (17 9 13)
@end group

@group
---------- Buffer: foo ----------
I read "The cat @point{}in the hat comes back" twice.
        ^   ^
        9  13
---------- Buffer: foo ----------
@end group
@end example

@noindent
(この場合にはリターンされるインデックスはバッファー位置であり、バッファーの1つ目の文字を1と数える。)

@node Entire Match Data
@subsection マッチデータ全体へのアクセス

  関数@code{match-data}と@code{set-match-data}は、マッチデータ全体にたいして一度に読み取り、または書き込みを行います。

@defun match-data &optional integers reuse reseat
この関数は最後の検索によりマッチしたテキストのすべての情報を記録する位置(マーカーか整数)をリターンする。要素0は正規表現全体にたいするマッチの先頭の位置。要素1はその正規表現にたいするマッチの終端の位置。次の2つの要素は1つ目の部分式にたいするマッチの先頭と終了、...となる。一般的に要素番号
@ifnottex
2@var{n}
@end ifnottex
@tex
{\mathsurround=0pt $2n$}
@end tex
は@code{(match-beginning @var{n})}、要素番号
@ifnottex
2@var{n} + 1
@end ifnottex
@tex
{\mathsurround=0pt $2n+1$}
@end tex
は@code{(match-end @var{n})}に対応する。

すべての要素は通常はマーカーか@code{nil}だが、もし@var{integers}が非@code{nil}ならマーカーのかわりに整数を使用することを意味する(この場合にはマッチデータの完全なリストアを容易にするために、リストの最後の要素としてバッファー自身が追加される)。最後の検索が@code{string-match}により文字列にたいして行われた場合には、マーカーは文字列の内部をポイントできないので常に整数が使用される。

@var{reuse}が非@code{nil}なら、それはリストであること。この場合には、@code{match-data}はマッチデータを@var{reuse}内に格納する。つまり@var{reuse}は破壊的に変更される。@var{reuse}が正しい長さである必要はない。特定のマッチデータにたいして長さが十分でなければリストは拡張される。@var{reuse}が長過ぎる場合には、長さはそのままで使用しない要素に@code{nil}がセットされる。この機能にはガベージコレクションの必要頻度を減らす目的がある。

@var{reseat}が非@code{nil}なら、@var{reuse}リスト内のすべてのマーカーは存在しない場所を指すよう再設定される。

他の場合と同じように検索関数とその検索のマッチデータへのアクセスを意図する@code{match-data}呼び出しの間に介入するような検索があってはならない。

@example
@group
(match-data)
     @result{}  (#<marker at 9 in foo>
          #<marker at 17 in foo>
          #<marker at 13 in foo>
          #<marker at 17 in foo>)
@end group
@end example
@end defun

@defun set-match-data match-list &optional reseat
この関数は@var{match-list}の要素からマッチデータをセットする。@var{match-list}は前の@code{match-data}呼び出しの値であるようなリストであること(正確には同じフォーマットなら他のものでも機能するだろう)。

@var{match-list}が存在しないバッファーを参照する場合でもエラーとはならない。これは無意味だが害のない方法でマッチデータをセットする。

@var{reseat}が非@code{nil}なら、リスト@var{match-list}内のすべてのマーカーは存在しない場所を指すよう再設定される。

@c TODO Make it properly obsolete.
@findex store-match-data
@code{store-match-data}は@code{set-match-data}の半ば時代遅れなエイリアス。
@end defun

@node Saving Match Data
@subsection マッチデータの保存とリストア

  以前に行った検索にたいするマッチデータを後で使用するために保護する必要があるなら、検索を行うかもしれない関数の呼び出し時に呼び出しの前後でマッチデータの保存とリストアを行う必要があるでしょう。以下はマッチデータ保存に失敗した場合に発生する問題を示す例です:

@example
@group
(re-search-forward "The \\(cat \\)")
     @result{} 48
(foo)                   ; @r{@code{foo}が他の検索を行うと}
(match-end 0)
     @result{} 61              ; @r{結果は期待する48と異なる!}
@end group
@end example

  @code{save-match-data}でマッチデータの保存とリストアができます:

@defmac save-match-data body@dots{}
このマクロは@var{body}を実行して、その前後のマッチデータの保存とリストアを行う。リターン値は@var{body}内の最後のフォームの値。
@end defmac

  @code{set-match-data}と@code{match-data}を一緒に使用して、@code{save-match-data}の効果を模倣することができます。以下はその方法です:

@example
@group
(let ((data (match-data)))
  (unwind-protect
      @dots{}   ; @r{元のマッチデータを変更してもOK}
    (set-match-data data)))
@end group
@end example

  プロセスフィルター関数(@ref{Filter
Functions}を参照)、およびプロセスセンチネル(@ref{Sentinels}を参照)の実行時には、Emacsが自動的にマッチデータの保存とリストアを行います。

@ignore
  Here is a function which restores the match data provided the buffer
associated with it still exists.

@smallexample
@group
@c It is incorrect to split the first line of a doc string.
@c If there's a problem here, it should be solved in some other way.
(defun restore-match-data (data)
  "Restore the match data DATA unless the buffer is missing."
  (catch 'foo
    (let ((d data))
@end group
      (while d
        (and (car d)
             (null (marker-buffer (car d)))
@group
             ;; @file{match-data} @r{buffer is deleted.}
             (throw 'foo nil))
        (setq d (cdr d)))
      (set-match-data data))))
@end group
@end smallexample
@end ignore

@node Search and Replace
@section 検索と置換
@cindex replacement after search
@cindex searching and replacing

  バッファーのある部分でregexpにたいするすべてのマッチを見つけてそれらを置換したい場合には、以下のように@code{re-search-forward}と@code{replace-match}を使用して明示的なループを記述するのがもっともフレキシブルな方法です:

@example
(while (re-search-forward "foo[ \t]+bar" nil t)
  (replace-match "foobar"))
@end example

@noindent
@code{replace-match}の説明は@ref{Replacing Match,, Replacing the Text that
Matched}を参照してください。

  特定のリージョンに置換を限定すれば、より便利かもしれません。関数@code{replace-regexp-in-region}はこれを行います。

@defun replace-regexp-in-region regexp replacement &optional start end
この関数はバッファーの@var{start}から@var{end}のテキストリージョンにあるすべての@var{regexp}を@var{replacement}に置換する。@var{start}のデフォルトはポイント位置、@var{end}のデフォルトはバッファーのアクセス可能範囲の終端。@var{regexp}にたいする検索はcase(大文字小文字)を区別し、@var{replacement}は文字のcaseを変更せずに挿入される。@var{replacement}文字列には@code{replace-match}で使用するような、同じ@samp{\}で始まる特殊要素を使用できる。この関数は置換した個数、@var{regexp}が見つからなければ@code{nil}をリターンする。この関数はポイント位置を維持する。

@example
(replace-regexp-in-region "foo[ \t]+bar" "foobar")
@end example
@end defun

@defun replace-string-in-region string replacement &optional start end
  この関数は@code{replace-regexp-in-region}と同様に機能するが、正規表現のかわりにリテラルの@var{string}の検索と置換を行う。
@end defun

  Emacsには文字列内でマッチを置換する特別な関数もあります。

@defun replace-regexp-in-string regexp rep string &optional fixedcase literal subexp start
この関数は@var{string}をコピーして@var{regexp}にたいするマッチを検索、それらを@var{rep}に置き換える。これは変更されたコピーをリターンする。@var{start}が非@code{nil}ならマッチにたいする検索は@var{string}内のそのインデックスから開始されて、リターン値には@var{string}の最初の@var{start}文字は含まれない。置き換え後の文字列全体を取得するには、@var{string}の最初の@var{start}文字とリターン値を結合すること。

この関数は置換を行うためにオプション引数@var{fixedcase}、@var{literal}、@var{subexp}を渡して@code{replace-match}を使用する。

@var{rep}は文字列のかわりに関数でもよい。この場合には@code{replace-regexp-in-string}はそれぞれのマッチにたいして、そのテキストを単一の引数として@var{rep}を呼び出す。これは@var{rep}がリターンする値を収集して、それを置換文字列として@code{replace-match}に渡す。この時点でのマッチデータは@var{string}の部分文字列にたいする@var{regexp}のマッチ結果。
@end defun

@defun string-replace from-string to-string in-string
この関数は@var{in-string}内に出現するすべての@var{from-string}を@var{to-string}に置換して、その結果をリターンする。引数のいずれかを変更せずに、文字列定数が新たな文字列をリターンするかもしれない。case(大文字小文字)には意味があるが、テキストプロパティは無視する。
@end defun

  @code{query-replace}の行に関するコマンドを記述したい場合には、@code{perform-replace}を使用してこれを行うことができます。

@defun perform-replace from-string replacements query-flag regexp-flag delimited-flag &optional repeat-count map start end backward region-noncontiguous-p
これは@code{query-replace}および関連するコマンドの根幹となる関数である。これは位置@var{start}と@var{end}の間にあるテキスト内に出現する@var{from-string}の一部またはすべてを置換する。@var{start}が@code{nil}
(または省略)ならかわりにポイントを、@var{end}にはそのバッファーのアクセス可能範囲の終端が使用される(オピション引数@var{backward}が非@code{nil}なら検索は@var{end}から後方に開始される)。

@var{query-flag}が@code{nil}ならすべてのマッチを置換する。それ以外なら、それぞれにたいしてユーザーにたいして何をすべきか問い合わせる。

@var{regexp-flag}が非@code{nil}なら@var{from-string}は正規表現、それ以外はリテラルとしてマッチしなければならない。@var{delimited-flag}が非@code{nil}なら単語境界に囲まれた置換だけが考慮される。

引数@var{replacements}はマッチを何で置き換えるかを指定する。文字列ならその文字列を使用する。サイクル順に使用される文字列リストでもよい。

@var{replacements}がコンスセル@w{@code{(@var{function}
.
@var{data})}}なら、置換テキストを取得するためにそれぞれのマッチ後に@var{function}を呼び出すことを意味する。この関数は@var{data}とすでに置換された個数という、2つの引数で呼び出される。

@var{repeat-count}が非@code{nil}なら、それは整数であること。その場合にはサイクルを次に進める前に、@var{replacements}リスト内の各文字列を何度使用するかを指定する。

@var{from-string}が大文字アルファベットを含む場合には、@code{perform-replace}は@code{case-fold-search}を@code{nil}にバインドして大文字小文字を変換せずに@var{replacements}を使用する。

キーマップ@code{query-replace-map}は通常は問い合わせにたいして可能なユーザー応答を定義する。引数@var{map}が非@code{nil}なら、それは@code{query-replace-map}のかわりに使用するキーマップを指定する。

@var{region-noncontiguous-p}が非@code{nil}なら、@var{start}と@var{end}の間のリージョンは非連続部分から構成されることを意味する。これのもっとも一般的な例は部分が開業文字で区切られた矩形リージョンである。

この関数は@var{from-string}の次のマッチを検索するために2つの関数のうちいずれか1つを使用する。これらの関数は2つの変数@code{replace-re-search-function}と@code{replace-search-function}により指定される。引数@var{regexp-flag}が非@code{nil}なら前者、@code{nil}なら後者が呼び出される。
@end defun

@defvar query-replace-map
この変数は@code{perform-replace}にたいする有効なユーザー応答を定義するスペシャルキーマップを保持して、コマンドは@code{y-or-n-p}や@code{map-y-or-n-p}と同様にそれを使用する。このマップは2つの点において普通のマップと異なる。

@itemize @bullet
@item
キーバインディングはコマンドではなく、このマップを使用する関数にとって意味のある単なるシンボルであること。

@item
プレフィクスキーはサポートされない。各キーバインディングは単一イベントキーシーケンスでなければならない。この関数は入力を取得するために単一イベントを読み取って、それを``手動''で照合するので@code{read-key-sequence}を使用しないからである。
@end itemize
@end defvar

@code{query-replace-map}にたいして意味をもつバインディングがあります。それらのうちいくつかは@code{query-replace}とその同族にたいしてのみ意味をもちます。

@table @code
@item act
判断している対象にたいしてアクションを起こす(言い換えると``yes'')。

@item skip
この問いにたいしてアクションを起こさない(言い換えると``no'')。

@item exit
この問いにたいして``no''を答えて、さらに一連の問いすべてにたいして``no''が応答されたとみなして問い合わせをあきらめる。

@item exit-prefix
@code{exit}と似ているが、@code{unread-command-events}にたいして押下されたキーを追加する(@ref{Event
Input Misc}を参照)。

@item act-and-exit
この問いにたいして``yes''を答えて、さらに一連の問いすべてにたいして後続の問いに``no''が応答されるとみなして問い合わせをあきらめる。

@item act-and-show
この問いに``yes''を答えるが、結果を表示してまだ次の問いへ進まない。

@item automatic
これ以上のユーザーとの対話を行わず、この問いと後続の問いにたいして``yes''を答える。

@item backup
前に問い合わせた以前の場所に戻る。

@item undo
最後の置換をアンドゥして置換が行われた位置に戻る。

@item undo-all
すべての置換をアンドゥして最初に置換が行われた位置に戻る。

@item edit
この問いに対処するために、通常とられるアクションのかわりに再帰編集にエンターする。

@item edit-replacement
ミニバッファー内で、この問いにたいする置換を編集する。

@item delete-and-edit
検討中のテキストを削除して、それを置換するために再帰編集にエンターする。

@item recenter
@itemx scroll-up
@itemx scroll-down
@itemx scroll-other-window
@itemx scroll-other-window-down
指定されたウィンドウスクロール操作を行って同じ問いを再度尋ねる。この問いには@code{y-or-n-p}と関連する関数だけが使用される。

@item quit
即座にquitを行う。この問いには@code{y-or-n-p}と関連する関数だけが使用される。

@item help
ヘルプを表示して再度尋ねる。
@end table

@defvar multi-query-replace-map
この変数はマルチバッファー置換で有用な追加キーバインディングを提供することにより@code{query-replace-map}を拡張するキーマップを保持する。追加されるバインディングは以下のとおり:

@table @code
@item automatic-all
残りすべてのバッファーにたいして、それ以上の対話をせずその問いと後続のすべての問いに``yes''を答える。

@item exit-current
この問いに``no''を答えてカレントバッファーにたいする一連の問いすべてをあきらめる。そしてシーケンス内の次のバッファーへ問いを継続する。
@end table
@end defvar

@defvar replace-search-function
この変数は置換する次の文字列を検索するために@code{perform-replace}が呼び出す関数を指定する。デフォルト値は@code{search-forward}。それ以外の値の場合には@code{search-forward}の最初の3つの引数を引数とする関数を指定すること(@ref{String
Search}を参照)。
@end defvar

@defvar replace-re-search-function
この変数は置換する次のregexpを検索するために@code{perform-replace}が呼び出す関数を指定する。デフォルト値は@code{re-search-forward}。それ以外の値の場合には@code{re-search-forward}の最初の3つの引数を引数とする関数を指定すること(@ref{Regexp
Search}を参照)。
@end defvar

@node Standard Regexps
@section 編集で使用される標準的な正規表現
@cindex regexps used standardly in editing
@cindex standard regexps used in editing

  このセクションでは、編集において特定の目的のために使用される正規表現を保持するいくつかの変数を説明します。

@defopt page-delimiter
これはページを分割する行開始を記述する正規表現。デフォルト値は@code{"^\014"}
(@code{"^^L"}または@code{"^\C-l"})。これはフォームフィード文字(改頁文字)で始まる行とマッチする。
@end defopt

  以下の2つの正規表現が、常に行頭からマッチが始まる正規表現とみなすべきでは@emph{ありません}。これらを@samp{^}にマッチするアンカーとして使用するべきではありません。ほとんどの場合では、パラグラフコマンドは行頭にたいしてのみマッチのチェックを行うので、これは@samp{^}が不要であることを意味します。非0の左マージンが存在する場合には、これらは左マージンの後から始まるマッチに適用されます。その場合には、@samp{^}は不適切でしょう。しかし左マージンを決して使用しないモードでは@samp{^}は無害でしょう。

@defopt paragraph-separate
これはパラグラフを分割する行の開始を認識する正規表現(これを変更する場合は@code{paragraph-start}も変更する必要があるかもしれない)。デフォルト値は@w{@code{"[@
\t\f]*$"}}であり、これは(左マージン以降)すべてがスペース、タブ、フォームフィードで構成される行とマッチする。
@end defopt

@defopt paragraph-start
これはパラグラフを開始@emph{または}分割する行の開始を認識する正規表現。デフォルト値は@w{@code{"\f\\|[
\t]*$"}}であり、これは(左マージン以降)すべてが空白文字で構成される行やフォームフィードで始まる行とマッチする。
@end defopt

@defopt sentence-end
非@code{nil}なら、以降に続く空白文字を含めてセンテンスの終わりを記述する正規表現であること(これとは無関係にパラグラフ境界もセンテンスを終了させる)。

値が@code{nil}
(デフォルト)なら、関数@code{sentence-end}がregexpを構築する。センテンス終端の認識に使用するregexpを得るために常に関数@code{sentence-end}を使用するべきなのはこれが理由。
@end defopt

@defun sentence-end
この関数は変数@code{sentence-end}が非@code{nil}ならその値をリターンする。それ以外なら変数@code{sentence-end-double-space}
(@ref{Definition of
sentence-end-double-space}を参照)、@code{sentence-end-without-period}、@code{sentence-end-without-space}にもとづくデフォルト値をリターンする。
@end defun

@node POSIX Regexps
@section Emacsの正規表現 vs POSIXの正規表現
@cindex POSIX regular expressions

正規表現の構文はコンピュータープログラムによって大きく異なります。他のプログラムで使うための正規表現を生成するようなElispコードを記述する際には、その変種では正規表現の構文がどのように異なるかを知っていると役に立ちます。その変種にたいする感触を掴めるように、このセクションではPOSIX標準の2つの変種であるBRE(basic
regular expressions: 基本正規表現)とERE(extended regular expressions:
拡張正規表現)が、Emacsの正規表現とどのように異なるかについて議論します。BREはプレーンな@command{grep}、EREは@samp{grep
-E}で使用されています。

Emacsの正規表現は拡張の一部においてBREよりEREに近い構文をもっています。以下にPOSIXのBREとEREが、Emacsの正規表現とどのように異なるかをまとめました。

@itemize @bullet
@item
POSIXのBREでは@samp{+}と@samp{?}は特別ではない。バックスラッシュがエスケープシーケンスとなるのは@samp{\(@dots{}\)}、@samp{\@{@dots{}\@}}、@samp{\1}から@samp{\9}、それに特別な文字をエスケープする@samp{\$}、@samp{\*}、@samp{\.}、@samp{\[}、@samp{\\}、@samp{\^}のみ。したがって@samp{\(?:}は@samp{\([?]:}のように機能する。POSIXのBREは他にたいするエスケープがどのように振る舞うかが定義していない。たとえばGNU版の@command{grep}はEmacsと同様に@samp{\|}を扱うものの、Emacsのすべてのエスケープがサポートされている訳ではない。

@item
POSIXのBREでは@samp{\(}の後の@samp{^}を特別に扱うか否かは実装のオプションとなっている。GNU版の@command{grep}の場合はEmacsと同様に扱われる。POSIXのEREではブラケット式の外側では@samp{^}は常に特別であり、これはEREでは@samp{x^}は決してマッチしないことを意味する。Emacsの正規表現における@samp{^}は正規表現の先頭もしくは@samp{\(}、@samp{\(?:}、@samp{\|}の後でのみ特別に扱われる。

@item
POSIXのBREでは@samp{\)}の前の@samp{$}を特別に扱うか否かは実装のオプションとなっている。POSIXのEREではブラケット式(@ref{Regexp
Special, bracket
expressions}を参照)の外側では@samp{$}は常に特別であり、これはEREでは@samp{$x}は決してマッチしないことを意味する。Emacsの正規表現における@samp{$}は正規表現の最後、もしくは@samp{\)}ｋ@samp{\|}の前でのみ特別に扱われる。

@item
POSIXのEREでは@samp{@{}、@samp{(}、@samp{|}は特別であり、@samp{)}は先行する@samp{(}とマッチする場合のみ特別に扱われる。これらのスペシャル文字の使用ではバックスラッシュを前置しない。@samp{(?}は未定義の結果をもたらす。バックスラッシュのエスケープシーケンスは@samp{\$}、@samp{\(}、@samp{\)}、@samp{\*}、@samp{\+}、@samp{\.}、@samp{\?}、@samp{\[}、@samp{\\}、@samp{\^}、@samp{\@{}、@samp{\|}というエスケープされたスペシャル文字だけである。POSIXではその他のEREエスケープがどのように振る舞うか定義されていない。たとえばGNU版の@samp{grep
-E}はEmacsと同じように@samp{\1}を扱うものの、Emacsのすべてのエスケープがサポートされている訳ではない。

@item
BREDE繰り返し演算子@samp{*}がEmacsの場合と同じように振る舞うことを除き、POSIXのBREとEREでは正規表現か部分式(@samp{^}が前置されているかもしれない)の開始にある繰り返し演算子が生成する結果は未定義である。Emacsではこれらの演算子は通常通り扱われる。

@item
BREとEREでは連続する2つの繰り返し演算子が生成する結果は未定義である。Emacsではこれらの動作は明確に定義されている(たとえば@samp{a**}は@samp{a*}と等価)。

@item
BREとEREでは空の正規表現や部分式が生成する結果は未定義である。Emacsではこれらの動作は明確に定義されている(たとえば@samp{\(\)*}は空文字列にマッチする)。

@item
BREとEREでは名前つき文字クラス@samp{[:ascii:]}、@samp{[:multibyte:]}、@samp{[:nonascii:]}、@samp{[:unibyte:]}、@samp{[:word:]}が生成する結果は未定義である。

@item
BREとEREのブラケット式の内側に、@samp{[[.ch.]d[=a=]]}のように照合シンボル(collating
symbols)および等価クラス式(equivalence class
expressions)を含むことができる。Emacsの正規表現ではこれはサポートされていない。

@item
BREs、EREおよび文字列のマッチにエンコーディングエラーやNULバイトを含めることはできない。Emacsでは単にそれら自身にマッチする。

@item
BREとEREは常に最長のマッチを探す。Emacsのデフォルトではそのように行う必要はない。@ref{Longest Match}を参照のこと。
@end itemize
