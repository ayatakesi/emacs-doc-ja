@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990--1994, 2001--2021 Free Software Foundation, Inc.
@c See the file elisp-ja.texi for copying conditions.
@node Byte Compilation
@chapter バイトコンパイル
@cindex byte compilation
@cindex byte-code
@cindex compilation (Emacs Lisp)

  Emacs
LispにはLispで記述された関数をより効率的に実行できる、@dfn{バイトコード(byte-code)}と呼ばれる特別な表現に翻訳する@dfn{コンパイラー(compiler)}があります。コンパイラーはLispの関数定義をバイトコードに置き換えます。バイトコード関数が呼び出されたとき、その定義は@dfn{バイトコードインタープリター(byte-code
interpreter)}により評価されます。

  バイトコンパイルされたコードは、(本当のコンパイル済みコードのように)そのマシンのハードウェアによって直接実行されるのではなく、バイトコンパイラーによって評価されるため、バイトコードはリコンパイルしなくてもマシン間での完全な可搬性を有します。しかし本当にコンパイルされたコードほど高速ではありません。

  一般的に任意のバージョンのEmacsはそれ以前のバージョンのEmacsにより生成されたバイトコンパイル済みコードを実行できますが、その逆は成り立ちません。

@vindex no-byte-compile
  あるLispファイルを常にコンパイルせずに実行したい場合は、以下のように@code{no-byte-compile}をバインドするファイルローカル変数を配置します:

@example
;; -*-no-byte-compile: t; -*-
@end example

@menu
* Speed of Byte-Code::       バイトコンパイルによるスピードアップ例。
* Compilation Functions::    バイトコンパイル関数。
* Docs and Compilation::     ドキュメント文字列のダイナミックロード。
* Dynamic Loading::          個々の関数のダイナミックロード。
* Eval During Compile::      コンパイル時に評価されるコード。
* Compiler Errors::          コンパイラーのエラーメッセージの扱い。
* Byte-Code Objects::        バイトコンパイル済み関数に使用されるデータ型。
* Disassembly::              バイトコードの逆アセンブル; 
                               バイトコードの読み方。
@end menu

@node Speed of Byte-Code
@section バイトコンパイル済みコードのパフォーマンス

  バイトコンパイルされた関数はCで記述されたプリミティブ関数ほど効率的ではありませんが、Lispで記述されたバージョンよりは高速に実行されます。以下は例です:

@example
@group
(defun silly-loop (n)
  "Return the time, in seconds, to run N iterations of a loop."
  (let ((t1 (float-time)))
    (while (> (setq n (1- n)) 0))
    (- (float-time) t1)))
@result{} silly-loop
@end group

@group
(silly-loop 50000000)
@result{} 10.235304117202759
@end group

@group
(byte-compile 'silly-loop)
@result{} @r{[コンパイルされたコードは表示されない]}
@end group

@group
(silly-loop 50000000)
@result{} 3.705854892730713
@end group
@end example

  この例ではインタープリターによる実行には10秒を要しますが、バイトコンパイルされたコードは4秒未満です。これは典型的な結果例ですが、実際の結果はさまざまでしょう。

@node Compilation Functions
@section バイトコンパイル関数
@cindex compilation functions

  @code{byte-compile}により、関数やマクロを個別にバイトコンパイルできます。@code{byte-compile-file}でファイル全体、@code{byte-recompile-directory}または@code{batch-byte-compile}で複数ファイルをコンパイルできます。

@vindex byte-compile-debug
  バイトコンパイラーが警告および/またはエラーメッセージを生成することもあります(詳細は@ref{Compiler
Errors}を参照)。これらのメッセージは通常はCompilationモードが使用する@file{*Compile-Log*}と呼ばれるバッファーに記録されます。@ref{Compilation
Mode,,,emacs, The GNU Emacs
Manual}を参照してください。しかし変数@code{byte-compile-debug}が非@code{nil}ならエラーメッセージはLispエラーとしてシグナルされます(@ref{Errors}を参照)。

@cindex macro compilation
  バイトコンパイルを意図したファイル内にマクロ呼び出しを記述する際には注意が必要です。マクロ呼び出しはコンパイル時に展開されるので、そのマクロはEmacsにロードされる必要があります(さもないとバイトコンパイラーが正しく処理しないだろう)。これを処理する通常の方法は、必要なマクロ定義を含むファイルを@code{require}フォームで指定することです。バイトコンパイラーは通常はコンパイルするコードを評価しませんが、@code{require}フォームは指定されたライブラリーをロードすることにより特別に扱われます。誰かがコンパイルされたプログラムを@emph{実行}する際にマクロ定義ファイルのロードを回避するためには、@code{require}呼び出しの周囲に@code{eval-when-compile}を記述します(@ref{Eval
During Compile}を参照)。詳細は@ref{Compiling Macros}を参照してください。

  インライン関数(@code{defsubst})はこれほど面倒ではありません。定義が判明する前にそのような関数呼び出しをコンパイルした場合でも、その呼び出しは低速になるだけで正しく機能するでしょう。

@defun byte-compile symbol
この関数は@var{symbol}の関数定義をバイトコンパイルして、以前の定義をコンパイルされた定義に置き換える。@var{symbol}の関数定義は、その関数にたいする実際のコードでなければならない。@code{byte-compile}はインダイレクト関数を処理しない。リターン値は、@var{symbol}のコンパイルされた定義であるようなバイトコード関数ブジェクト(@ref{Byte-Code
Objects}を参照)。

@example
@group
(defun factorial (integer)
  "INTEGERの階乗を計算する。"
  (if (= 1 integer) 1
    (* integer (factorial (1- integer)))))
@result{} factorial
@end group

@group
(byte-compile 'factorial)
@result{}
#[(integer)
  "^H\301U\203^H^@@\301\207\302^H\303^HS!\"\207"
  [integer 1 * factorial]
  4 "Compute factorial of INTEGER."]
@end group
@end example

@var{symbol}の定義がバイトコード関数オブジェクトなら、@code{byte-compile}は何も行わず@code{nil}をリターンする。そのシンボルの関数セル内の(コンパイルされていない)オリジナルのコードはすでにバイトコンパイルされたコードに置き換えられているので、シンボルの定義の再コンパイルはしない。

@code{byte-compile}の引数として@code{lambda}式も指定できる。この場合、関数は対応するコンパイル済みコードをリターンするが、それはどこにも格納されない。
@end defun

@deffn Command compile-defun &optional arg
このコマンドはポイントを含むdefunを読み取りそれをコンパイルして結果を評価する。実際に関数定義であるようなdefunでこれを使用した場合には、その関数のコンパイル済みバージョンをインストールする効果がある。

@code{compile-defun}は通常は評価した結果をエコーエリアに表示するが、@var{arg}が非@code{nil}ならフォームをコンパイルした後にカレントバッファーに結果を挿入する。
@end deffn

@deffn Command byte-compile-file filename
この関数は@var{filename}という名前のLispコードファイルを、バイトコードのファイルにコンパイルする。出力となるファイルの名前は、サフィックス@samp{.el}を@samp{.elc}に変更することにより作成される。@var{filename}が@samp{.el}で終了しない場合には、@samp{.elc}を@var{filename}の最後に付け足す。

コンパイルは入力ファイルから1つのフォームを逐次読み取ることにより機能する。フォームが関数かマクロなら、コンパイル済みの関数かマクロが書き込まれる。それ以外のフォームはまとめられて、まとめられたものごとにコンパイルされて、そのファイルが読まれたとき実行されるようにコンパイルされたコードが書き込まれる。入力ファイルを読み取る際には、すべてのコメントは無視される。

このコマンドはエラーがなければ@code{t}、それ以外は@code{nil}をリターンする。インタラクティブに呼び出されたときは、ファイル名の入力をもとめる。

@example
@group
$ ls -l push*
-rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el
@end group

@group
(byte-compile-file "~/emacs/push.el")
     @result{} t
@end group

@group
$ ls -l push*
-rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el
-rw-rw-rw- 1 lewis lewis 638 Oct  8 20:25 push.elc
@end group
@end example
@end deffn

@deffn Command byte-recompile-directory directory &optional flag force follow-symlinks
@cindex library compilation
このコマンドは@var{directory}(またはそのサブディレクトリー)内の、リコンパイルを要するすべての@samp{.el}ファイルをリコンパイルする。@samp{.elc}ファイルが存在して、それが@samp{.el}より古いファイルは、リコンパイルが必要となる。

@samp{.el}ファイルに対応する@samp{.elc}ファイルが存在しない場合に何を行うかを@var{flag}で指定する。@code{nil}なら、このコマンドはこれらのファイルを無視する。@var{flag}が0なら、それらをコンパイルする。@code{nil}と0以外なら、それらのファイルをコンパイルするかユーザーに尋ねて、同様にそれぞれのサブディレクトリーについても尋ねる。

インタラクティブに呼び出されると、@code{byte-recompile-directory}は@var{directory}の入力を求めて、@var{flag}はプレフィクス引数となる。

@var{force}が非@code{nil}なら、このコマンドは@samp{.elc}ファイルが存在するすべての@samp{.el}ファイルをリコンパイルする。

このコマンドは通常はシンボリックリンクであるような@samp{.el}ファイルをコンパイルしない。オプションの@var{follow-symlink}パラメーターが非@code{nil}なら、シンボリックリンクされた@samp{.el}もコンパイルされる。

リターン値は不定。
@end deffn

@defun batch-byte-compile &optional noforce
この関数はコマンドラインで指定されたファイルにたいして@code{byte-compile-file}を実行する。この関数は処理が完了するとEmacsをkillするので、Emacsのバッチ実行でのみ使用しなければならない。1つのファイルでエラーが発生しても、それによって後続のファイルにたいする処理が妨げられることはないが、そのファイルにたいする出力ファイルは生成されず、Emacsプロセスは0以外のステータスコードで終了する。

@var{noforce}が非@code{nil}なら、この関数は最新の@samp{.elc}ファイルがあるファイルをリコンパイルしない。

@example
$ emacs -batch -f batch-byte-compile *.el
@end example
@end defun

@node Docs and Compilation
@section ドキュメント文字列とコンパイル
@cindex dynamic loading of documentation

  Emacsがバイトコンパイルされたファイルから関数や変数をロードする際、通常はメモリー内にそれらのドキュメント文字列をロードしません。それぞれのドキュメント文字列は、必要なときだけバイトコンパイルされたファイルからダイナミック(dynamic:
動的)にロードされます。ドキュメント文字列の処理をスキップすることにより、メモリーが節約されてロードが高速になります。

  この機能には欠点があります。コンパイル済みのファイルを削除や移動、または(新しいバージョンのコンパイル等で)変更した場合、Emacsは以前にロードした関数や変数のドキュメント文字列にアクセスできなくなるでしょう。このような問題は通常なら、あなた自身がEmacsをビルドしたときに、そのLispファイルを編集および/またはリコンパイルしたときだけ発生します。この問題は、リコンパイル後にそれぞれのファイルをリロードするだけで解決します。

  バイトコンパイルされたファイルからのドキュメント文字列のダイナミックロードは、バイトコンパイルされたファイルごとにコンパイル時に解決されます。これはオプション@code{byte-compile-dynamic-docstrings}で無効にできます。

@defopt byte-compile-dynamic-docstrings
これが非@code{nil}なら、バイトコンパイラーはドキュメント文字列をダイナミックロードするようにセットアップしたコンパイル済みファイルを生成する。

特定のファイルでダイナミックロード機能を無効にするには、以下のようにヘッダー行でこのオプションに@code{nil}をセットする(@ref{File
Variables, , Local Variables in Files, emacs, The GNU Emacs Manual}を参照)。

@smallexample
-*-byte-compile-dynamic-docstrings: nil;-*-
@end smallexample

これは主として、あるファイルを変更しようとしていて、そのファイルをすでにロード済みのEmacsセッションがファイルを変更した際にも正しく機能し続けることを望む場合に有用である。
@end defopt

@cindex @samp{#@@@var{count}}
@cindex @samp{#$}
内部的にはドキュメント文字列のダイナミックロードは、特殊なLispリーダー構文@samp{#@@@var{count}}とともにコンパイル済みファイルに書き込むことによって達成される。この構文は次の@var{count}文字をスキップする。さらに@samp{#$}構文も使用され、これはこのファイルの名前(文字列)を意味する。これらの構文をLispソースファイル内で使用しないこと。これらは人間がファイルを読む際に明確であるようにデザインされていない。

@node Dynamic Loading
@section 個々の関数のダイナミックロード

@cindex dynamic loading of functions
@cindex lazy loading
  ファイルをコンパイルするとき、オプションで@dfn{ダイナミック関数ロード(dynamic function
loading)}機能(@dfn{laxyロード(lazy
loading)とも呼ばれる})を有効にできます。ダイナミック関数ロードでは、ファイルのロードでファイル内の関数定義は完全には読み込まれません。かわりに各関数定義にはそのファイルを参照するプレースホルダーが含まれます。それぞれ関数が最初に呼び出されるときにそのプレースホルダーを置き換えるために、ファイルから完全な定義が読み込まれます。

  ファイルのロードがより高速になるだろうというのがダイナミック関数ロードの利点です。ユーザーが呼び出せる関数を多く含むファイルにとって、それらの関数のうち1つを使用したら多分残りの関数も使用するというのでなければ、これは利点になります。多くのキーボードコマンドを提供する特化したモードは、このパターンの使い方をする場合があります。ユーザーはそのモードを呼び出すかもしれませんが、使用するのはそのモードが提供するコマンドのわずか一部です。

  ダイナミックロード機能には不利な点がいくつかあります:

@itemize @bullet
@item
ロード後にコンパイル済みファイルの削除や移動を行うと、Emacsはまだロードされていない残りの関数定義をロードできなくなる。

@item
(新しいバージョンのコンパイル等で)コンパイル済みファイルを変更した場合に、まだロードされていない関数のロードを試みると通常は無意味な結果となる。
@end itemize

  このような問題は通常の状況でインストールされたEmacsファイルでは決して発生しません。しかしあなたが変更したLispファイルでは発生し得ます。それぞれのファイルをリコンパイルしたらすぐに新たなコンパイル済みファイルをリロードするのが、これらの問題を回避する一番簡単な方法です。

  @emph{ダイナミックな関数ロードの使用により提供される利点がほとんど計測できないという経験から、この機能はEmacs 27.1以降は廃止されます。}

  コンパイル時に変数@code{byte-compile-dynamic}が非@code{nil}なら、バイトコンパイラーはダイナミック関数ロード機能を使用します。ダイナミックロードが望ましいのは特定のファイルにたいしてだけなので、この変数をグローバルにセットしないでください。そのかわりに、特定のソースファイルのファイルローカル変数でこの機能を有効にしてください。たとえばソースファイルの最初の行に以下のテキストを記述することにより、これを行うことができます:

@example
-*-byte-compile-dynamic: t;-*-
@end example

@defvar byte-compile-dynamic
これが非@code{nil}なら、バイトコンパイラーはダイナミック関数ロード用にセットアップされたコンパイル済みファイルを生成する。
@end defvar

@defun fetch-bytecode function
@var{function}がバイトコード関数オブジェクトなら、それがまだ完全にロードされていなければ、バイトコンパイル済みのファイルからの@var{function}のバイトコードのロードを完了させる。それ以外なら何も行わない。この関数は常に@var{function}をリターンする。
@end defun

@node Eval During Compile
@section コンパイル中の評価
@cindex eval during compilation

  これらの機能によりプログラムのコンパイル中に評価されるコードを記述できます。

@defmac eval-and-compile body@dots{}
このフォームはそれを含むコードがコンパイルされるとき、および(コンパイルされているかいないかに関わらず)実行されるときの両方で@var{body}が評価されるようにマークする。

@var{body}を別のファイルに配置して、そのファイルを@code{require}で参照すれば同様の結果が得られる。これは@var{body}が大きいときに望ましい方法である。事実上、@code{require}は自動的に@code{eval-and-compile}されて、そのパッケージはコンパイル時と実行時の両方でロードされる。

@code{autoload}も実際は@code{eval-and-compile}される。これはコンパイル時に認識されるので、そのような関数の使用により警告``not
known to be defined''は生成されない。

ほとんどの@code{eval-and-compile}の使用は、完全に妥当であると言えよう。

あるマクロがマクロの結果を構築するためのヘルパー関数をもち、そのマクロがそのパッケージにたいしてローカルと外部の両方で使用される場合には、コンパイル時と後の実行時にそのヘルパー関数を取得するために@code{eval-and-compile}を使用すること。

これは関数がプログラム的に(@code{fset}で)定義されている場合には、コンパイル時と実行時にプログラム的な定義を行わせてそれらの関数の呼び出しをチェックするためにも使用できる(``not
known to be defined''の警告は抑制される)。
@end defmac

@defmac eval-when-compile body@dots{}
このフォームは@var{body}がコンパイル時に評価され、コンパイルされたプログラムがロードされるときは評価されないようにマークする。コンパイラーによる評価の結果はコンパイル済みのプログラム内の定数となる。ソースファイルをコンパイルではなくロードすると、@var{body}は通常どおり評価される。

@cindex compile-time constant
生成するために何らかの計算が必要な定数があるなら、@code{eval-when-compile}はコンパイル時にそれを行なうことができる。たとえば、

@lisp
(defvar my-regexp
  (eval-when-compile (regexp-opt '("aaa" "aba" "abb"))))
@end lisp

@cindex macros, at compile time
他のパッケージを使用しているが、そのパッケージのマクロ(バイトコンパイラーはそれらを展開します)だけが必要なら、それらを実行せずにコンパイル用にロードさせるために@code{eval-when-compile}を使用できる。たとえば、

@lisp
(eval-when-compile
  (require 'my-macro-package))
@end lisp

これらの事項は、マクロと@code{defsubst}関数がローカルに定義されていて、そのファイル内だけで使用されることを要求する。これらはそのファイルのコンパイルに必要だが、コンパイル済みファイルの実行には、ほとんどの場合必要ない。たとえば、

@lisp
(eval-when-compile
  (unless (fboundp 'some-new-thing)
    (defmacro 'some-new-thing ()
      (compatibility code))))
@end lisp

@noindent
これは大抵は他のバージョンのEmacsとの互換性の保証のためのコードにたいしてのみ有用である。

@strong{Common Lispに関する注意:} トップレベルでは、@code{eval-when-compile}はCommon
Lispのイディオム@code{(eval-when (compile eval) @dots{})}に類似する。トップレベル以外では、Common
Lispのリーダーマクロ@samp{#.}(ただし解釈時を除く)が、@code{eval-when-compile}と近いことを行う。
@end defmac

@node Compiler Errors
@section コンパイラーのエラー
@cindex compiler errors
@cindex byte-compiler errors

  バイトコンパイルのエラーメッセージと警告メッセージは、@file{*Compile-Log*}という名前のバッファーにプリントされます。これらのメッセージには、問題となる箇所を示すファイル名と行番号が含まれます。これらのメッセージにたいして、コンパイラー出力を操作する通常のEmacsコマンドが使用できます。

  あるエラーがプログラムのシンタックスに由来する場合、バイトコンパイラーはエラーの正確な位置の取得に際して混乱するかもしれません。バッファー@w{@file{
*Compiler Input*}}.にスイッチするのは、これを調べ1つの方法です(このバッファー名はスペースで始まるので、Buffer
Menuに表示されない)。このバッファーにはコンパイルされたプログラムと、バイトコンパイラーが読み取った箇所からポイントがどれほど離れているかが含まれ、エラーの原因はその近傍の可能性があります。シンタックスエラーを見つけるヒントについては、@ref{Syntax
Errors}を参照してください。

@cindex byte-compiler warnings
@cindex free variable, byte-compiler warning
@cindex reference to free variable, compilation warning
@cindex function not known to be defined, compilation warning
  定義されていない関数や変数の使用は、バイトコンパイラーにより報告される警告のタイプとしては一般的です。そのような警告では、定義されていない関数や変数を使用した位置ではなく、そのファイルの最後の行の行番号が報告されるので、それを見つけるには手作業で検索しなければなりません。

  定義のない関数や変数の警告が間違いだと確信できる場合には、警告を抑制する方法がいくつかあります:

@itemize @bullet
@item
関数@var{func}への特定の呼び出しにたいする警告は、それを条件式@code{fboundp}でテストすることで抑制できる:

@example
(if (fboundp '@var{func}) ...(@var{func} ...)...)
@end example

@noindent
@var{func}への呼び出しは@code{if}文の@var{then-form}内になければならず、@var{func}は@code{fboundp}呼び出し内でクォートされていなければならない(この機能は@code{cond}でも同様に機能する)。

@item
同じように、変数@var{variable}の特定の使用についの警告を、条件式内の@code{boundp}テストで抑制できる:

@example
(if (boundp '@var{variable}) ...@var{variable}...)
@end example

@noindent
@var{variable}への参照は@code{if}文の@var{then-form}内になければならず、@var{variable}は@code{boundp}呼び出し内でクォートされていなければならない。

@item
コンパイラーに関数が@code{declare-function}を使用して定義されていると告げることができる。@ref{Declaring
Functions}を参照のこと。

@item
同じように変数が初期値なしの@code{defvar}を使用して定義されているとコンパイラーに告げることができる(カレントレキシカルスコープ、またはトップレベルにあればファイルでのみダイナミックにバインドされているとして変数を特別な変数としてマークすることに注意。@ref{Defining
Variables}を参照のこと。
@end itemize

  @code{with-suppressed-warnings}マクロを使用して特定の式にたいするコンパイラーの警告を抑制することもできます:

@defspec with-suppressed-warnings warnings body@dots{}
これは実行においては@code{(progn
@var{body}...)}と等価だが、コンパイラーは@var{body}内の指定したコンディションにたいする警告を発しない。@var{warnings}は警告シンボルと、それらを適用する関数/変数シンボルの連想リスト。たとえば@code{foo}という時代遅れ(obsolete)の関数を呼び出したいがコンパイル時の警告を抑止したければ、以下のようにする:

@lisp
(with-suppressed-warnings ((obsolete foo))
  (foo ...))
@end lisp
@end defspec

コンパイラー警告の抑制をより粗く行うには@code{with-no-warnings}構文を使用できます:

@c This is implemented with a defun, but conceptually it is
@c a special form.

@defspec with-no-warnings body@dots{}
これは実行時には@code{(progn
@var{body}...)}と等価だが、コンパイラーは@var{body}の中で起こるいかなる事項にたいしても警告を発しない。

わたしたちはかわりに@code{with-suppressed-warnings}の使用を推奨するが、この構文を使用する場合には、あなたが抑制したいと意図する警告以外の警告を失わないようにするために、可能な限り小さいコード断片にたいしてこの構文を使用すること。
@end defspec

  変数@code{byte-compile-warnings}をセットすることにより、コンパイラーの警告をより詳細に制御できます。詳細は変数のドキュメント文字列を参照してください。

@vindex byte-compile-error-on-warn
  @code{error}を使用してバイトコンパイラーの警告が報告されることを望む場合があるかもしれません。そのような場合には@code{byte-compile-error-on-warn}を非@code{nil}値にセットしてください。

@node Byte-Code Objects
@section バイトコード関数オブジェクト
@cindex compiled function
@cindex byte-code function
@cindex byte-code object

  バイトコンパイルされた関数は、@dfn{バイトコード関数オブジェクト(byte-code function
objects)}という特別なデータ型をもちます。関数呼び出しとしてそのようなオブジェクトが出現したとき、Emacsはそのバイトコードを実行するために、常にバイトコードインタープリターを使用します。

  内部的にはバイトコード関数オブジェクトはベクターとよく似ています。バイトコード関数オブジェクトの要素には@code{aref}を通じてアクセスできます。バイトコード関数オブジェクトのプリント表現(printed
representation)はベクターと似ていて、開き@samp{[}の前に@samp{#}が追加されます。バイト関数オブジェクトは少なくとも4つの要素をもたねばならず、その要素数に上限はありません。しかし通常使用されるのは最初の6要素です。これらは:

@table @var
@item argdesc
引数の記述子(descriptor)。これは@ref{Argument
List}で説明されるような引数のリスト、または要求される引数の個数をエンコードする整数のいずれかである。後者の場合、その記述子の値は0ビットから6ビットで引数の最小個数、8ビットから14ビットで引数の最大個数を指定する。引数リストが@code{&rest}を使用するなら7ビットがセットされて、それい以外ならクリアーされる。

@var{argdesc}がリストなら、そのバイトコード実行前に引数はダイナミックにバインドされる。@var{argdesc}が整数なら、引数リストはそのバイトコード実行前にバイトコーピンタープリンターのスタックにpushされる。

@item byte-code
バイトコード命令を含む文字列。

@item constants
バイトコードにより参照されるLispオブジェクトのベクター。関数名と変数名に使用されるシンボルが含まれる。

@item stacksize
この関数が要するスタックの最大サイズ。

@item docstring
(もしあれば)ドキュメント文字列。それ以外は@code{nil}。ドキュメント文字列がファイルに格納されている場合、値は数字かリストかもしれない。本当のドキュメント文字列の取得には、関数@code{documentation}を使用する(@ref{Accessing
Documentation}を参照)。

@item interactive
(もしあれば)インタラクティブ仕様。文字列かLisp式。インタラクティブでない関数では@code{nil}。
@end table

以下はバイトコード関数オブジェクトのプリント表現の例です。これはコマンド@code{backward-sexp}の定義です。

@example
#[256
  "\211\204^G^@@\300\262^A\301^A[!\207"
  [1 forward-sexp]
  3
  1793299
  "^p"]
@end example

  バイトコードオブジェクトを作成するプリミティブな方法は@code{make-byte-code}です:

@defun make-byte-code &rest elements
この関数は@var{elements}を要素とするバイトコードオブジェクトを構築してリターンする。
@end defun

  あなた自身で要素を収集してバイトコード関数を構築しないでください。それらが矛盾する場合、その関数の呼び出しによりEmacsがクラッシュするかもしれません。これらのオブジェクトの作成は常にバイトコンパイラーにまかせてください。(願わくば)バイトコンパイラーは要素を矛盾なく構築します。

@node Disassembly
@section 逆アセンブルされたバイトコード
@cindex disassembled byte-code

  人はバイトコードを記述しません。それはバイトコンパイラーの仕事です。しかし好奇心を満たすために、わたしたちはディスアセンブラを提供しています。ディスアセンブラはバイトコードを人間が読めるフォームに変換します。

  バイトコードインタープリターは、シンプルなスタックマシンとして実装されています。これは値を自身のスタックにpushして、計算で使用するためにそれらをpopして取り出し、その結果を再びそのスタックにpushして戻します。バイトコード関数がリターンするときは、スタックから値をpopして取り出し、その関数の値としてリターンします。

  それに加えてスタックとバイトコード関数は、値を変数とスタック間で転送することにより、普通のLisp変数を使用したり、バインドやセットを行うことができます。

@deffn Command disassemble object &optional buffer-or-name
このコマンドは@var{object}にたいするディスアセンブルされたコードを表示する。インタラクティブに使用した場合、または@var{buffer-or-name}が@code{nil}か省略された場合は、@file{*Disassemble*}という名前のバッファーに出力します。@var{buffer-or-name}が非@code{nil}なら、それはバッファーもしくは既存のバッファーの名前でなければならない。その場合は、そのバッファーのポイント位置に出力され、ポイントは出力の前に残りされる。

引数@var{object}には関数名、ラムダ式(@ref{Lambda
Expressions}を参照)、またはバイトコードオブジェクト(@ref{Byte-Code
Objects}を参照)を指定できる。ラムダ式なら@code{disassemble}はそれをコンパイルしてから、そのコンパイル済みコードをディスアセンブルする。
@end deffn

  以下に@code{disassemble}関数を使用した例を2つ示します。バイトコードとLispソースを関連付ける助けとなるように、説明的なコメントを追加してあります。これらのコメントは@code{disassemble}の出力にはありません。

@example
@group
(defun factorial (integer)
  "Compute factorial of an integer."
  (if (= 1 integer) 1
    (* integer (factorial (1- integer)))))
     @result{} factorial
@end group

@group
(factorial 4)
     @result{} 24
@end group

@group
(disassemble 'factorial)
     @print{} byte-code for factorial:
 doc: Compute factorial of an integer.
 args: (integer)
@end group

@group
0   varref   integer      ; @r{@code{integer}の値を取得して}
                          ;   @r{それをスタック上にpushする}
1   constant 1            ; @r{スタック上に1をpushする}
@end group
@group
2   eqlsign               ; @r{2つの値をスタックからpopして取り出し、}
                          ;   @r{それらを比較して結果をスタック上にpushする}
@end group
@group
3   goto-if-nil 1         ; @r{スタックのトップをpopしてテストする}
                          ;   @r{@code{nil}なら1へ、それ以外はcontinue}
6   constant 1            ; @r{スタックのトップに1をpushする}
7   return                ; @r{スタックのトップの要素をリターンする}
@end group
@group
8:1 varref   integer      ; @r{@code{integer}の値をスタック上にpushする}
9   constant factorial    ; @r{@code{factorial}をスタック上にpushする}
10  varref   integer      ; @r{@code{integer}の値をスタック上にpushする}
11  sub1                  ; @r{@code{integer}をpopして値をデクリメントする}
                          ;   @r{スタック上に新しい値をpushする}
12  call     1            ; @r{スタックの最初(トップ)の要素を引数として}
                          ;   @r{関数@code{factorial}を呼び出す}
                          ;   @r{リターン値をスタック上にpushする}
@end group
@group
13 mult                   ; @r{スタックのトップ2要素をpopして取り出し乗じ}
                          ;   @r{結果をスタック上にpushする}
14 return                 ; @r{スタックのトップ要素をリターンする}
@end group
@end example

@code{silly-loop}は幾分複雑です:

@example
@group
(defun silly-loop (n)
  "Return time before and after N iterations of a loop."
  (let ((t1 (current-time-string)))
    (while (> (setq n (1- n))
              0))
    (list t1 (current-time-string))))
     @result{} silly-loop
@end group

@group
(disassemble 'silly-loop)
     @print{} byte-code for silly-loop:
 doc: Return time before and after N iterations of a loop.
 args: (n)
@end group

@group
0   constant current-time-string  ; @r{@code{current-time-string}を}
                                  ;   @r{スタック上のトップにpushする}
@end group
@group
1   call     0            ; @r{引数なしで@code{current-time-string}を呼び出し}
                          ;   @r{結果をスタック上にpushする}
@end group
@group
2   varbind  t1           ; @r{スタックをpopして@code{t1}にpopされた値をバインドする}
@end group
@group
3:1 varref   n            ; @r{環境から@code{n}の値を取得して}
                          ;   @r{その値をスタック上にpushする}
4   sub1                  ; @r{スタックのトップから1を減ずる}
@end group
@group
5   dup                   ; @r{スタックのトップを複製する}
                          ;   @r{たとえばスタックのトップをコピーしてスタック上にpushする}
6   varset   n            ; @r{スタックのトップをpopして}
                          ;   @r{@code{n}をその値にバインドする}

;; @r{(要はシーケンス@code{dup varset}はpopせずに}
;; @r{ スタックのトップを@code{n}の値にコピーする)}
@end group

@group
7   constant 0            ; @r{スタック上に0をpushする}
8   gtr                   ; @r{スタックのトップ2値をpopして取り出し}
                          ;   @r{@var{n}が0より大かテストし}
                          ;   @r{結果をスタック上にpushする}
@end group
@group
9   goto-if-not-nil 1     ; @r{@code{n} > 0なら1へ}
                          ;   @r{(これはwhile-loopを継続する)}
                          ;   @r{それ以外はcontinue}
@end group
@group
12  varref   t1           ; @r{@code{t1}の値をスタック上にpushする}
13  constant current-time-string  ; @r{@code{current-time-string}を}
                                  ;   @r{スタックのトップにpushする}
14  call     0            ; @r{再度@code{current-time-string}を呼び出す}
@end group
@group
15  unbind   1            ; @r{ローカル環境の@code{t1}をアンバインドする}
16  list2                 ; @r{スタックのトップ2要素をpopして取り出し}
                          ;   @r{それらのリストを作りスタック上にpushする}
17  return                ; @r{スタックのトップの値をリターンする}
@end group
@end example

@node Native Compilation
@chapter Compilation of Lisp to Native Code
@cindex native compilation
@cindex compilation to native code (Emacs Lisp)

@cindex native code
  In addition to the byte-compilation, described in @ref{Byte Compilation, the
previous chapter}, Emacs can also optionally compile Lisp function
definitions into a true compiled code, known as @dfn{native code}.  This
feature uses the @file{libgccjit} library, which is part of the GCC
distribution, and requires that Emacs be built with support for using that
library.  It also requires to have GCC and Binutils (the assembler and
linker) available on your system for you to be able to native-compile Lisp
code.

@vindex native-compile@r{, a Lisp feature}
  To determine whether the current Emacs process can produce and load
natively-compiled Lisp code, test whether the @code{native-compile} feature
is available (@pxref{Named Features}).  Alternatively, call
@code{native-comp-available-p} (@pxref{Native-Compilation Functions}).

  Unlike byte-compiled code, natively-compiled Lisp code is executed directly
by the machine's hardware, and therefore runs at full speed that the host
CPU can provide.  The resulting speedup generally depends on what the Lisp
code does, but is usually 2.5 to 5 times faster than the corresponding
byte-compiled code.

  Since native code is generally incompatible between different systems, the
natively-compiled code is @emph{not} transportable from one machine to
another, it can only be used on the same machine where it was produced or on
very similar ones (having the same CPU and run-time libraries).  The
transportability of natively-compiled code is the same as that of shared
libraries (@file{.so} or @file{.dll} files).

  Libraries of natively-compiled code include crucial dependencies on Emacs
Lisp primitives (@pxref{What Is a Function}) and their calling conventions,
and thus Emacs usually won't load natively-compiled code produced by earlier
or later Emacs versions; native compilation of the same Lisp code by a
different Emacs version will usually produce a natively-compiled library
under a unique file name that only that version of Emacs will be able to
load.  However, the use of unique file names allows to have in the same
directory several versions of the same Lisp library natively-compiled by
several different versions of Emacs.

@vindex no-native-compile
  A non-@code{nil} file-local variable binding of @code{no-byte-compile}
(@pxref{Byte Compilation}) also disables the native compilation of that
file.  In addition, a similar variable @code{no-native-compile} disables
just the native compilation of the file.  If both @code{no-byte-compile} and
@code{no-native-compile} are specified, the former takes precedence.

@menu
* Native-Compilation Functions::  Functions to natively-compile Lisp.
* Native-Compilation Variables::  Variables controlling native compilation.
@end menu

@node Native-Compilation Functions
@section Native-Compilation Functions
@cindex native-compilation functions

   Native-Compilation is implemented as a side effect of byte-compilation
(@pxref{Byte Compilation}).  Thus, compiling Lisp code natively always
produces its byte code as well, and therefore all the rules and caveats of
preparing Lisp code for byte compilation (@pxref{Compilation Functions}) are
valid for native-compilation as well.

   You can natively-compile either a single function or macro definition, or a
whole file of Lisp code, with the @code{native-compile} function.
Natively-compiling a file will produce both the corresponding @file{.elc}
file with byte code and the @file{.eln} file with native code.

@findex native-comp-limple-mode
@vindex native-comp-verbose
  Native compilation might produce warning or error messages; these are
normally recorded in the buffer called @file{*Native-compile-Log*}.  In
interactive sessions, it uses the special LIMPLE mode
(@code{native-comp-limple-mode}), which sets up @code{font-lock} as
appropriate for this log, and is otherwise the same as Fundamental mode.
Logging of messages resulting from native-compilation can be controlled by
the @code{native-comp-verbose} variable (@pxref{Native-Compilation
Variables}).

  When Emacs is run non-interactively, messages produced by native-compilation
are reported by calling @code{message} (@pxref{Displaying Messages}), and
are usually displayed on the standard error stream of the terminal from
which Emacs was invoked.

@defun native-compile function-or-file &optional output
This function compiles @var{function-or-file} into native code.  The
argument @var{function-or-file} can be a function symbol, a Lisp form, or a
name (a string) of the file which contains the Emacs Lisp source code to
compile.  If the optional argument @var{output} is provided, it must be a
string specifying the name of the file to write the compiled code into.
Otherwise, if @var{function-or-file} is a function or a Lisp form, this
function returns the compiled object, and if @var{function-or-file} is a
file name, the function returns the full absolute name of the file it
created for the compiled code.  The output file is by default given the
@file{.eln} extension.

This function runs the final phase of the native compilation, which invokes
GCC via @file{libgccjit}, in a separate subprocess, which invokes the same
Emacs executable as the process that called this function.
@end defun

@defun batch-native-compile
This function runs native-compilation on files specified on the Emacs
command line in batch mode.  It must be used only in a batch execution of
Emacs, as it kills Emacs upon completion of the compilation.  If one or more
of the files fail to compile, the Emacs process will attempt to compile all
the other files, and will terminate with a non-zero status code.
@end defun

Native compilation can be run entirely asynchronously, in a subprocess of
the main Emacs process.  This leaves the main Emacs process free to use
while the compilation runs in the background.  This is the method used by
Emacs to natively-compile any Lisp file or byte-compiled Lisp file that is
loaded into Emacs, when no natively-compiled file for it is available.

@defun native-compile-async files &optional recursively load selector
This function compiles the named @var{files} asynchronously.  The argument
@var{files} should be a single file name (a string) or a list of one or more
file and/or directory names.  If directories are present in the list, the
optional argument @var{recursively} should be non-@code{nil} to cause the
compilation to recurse into those directories.  If @var{load} is
non-@code{nil}, Emacs will load each file that it succeeded to compile.  The
optional argument @var{selector} allows control of which of @var{files} will
be compiled; it can have one of the following values:

@table @asis
@item @code{nil} or omitted
Select all the files and directories in @var{files}.
@item a regular expression string
Select the files and directories whose names match the regexp.
@item a function
A predicate function, which will be called with each file and directory in
@var{files}, and should return non-@code{nil} if the file or the directory
should be selected for compilation.
@end table

On systems with multiple CPU execution units, when @var{files} names more
than one file, this function will normally start several compilation
subprocesses in parallel, under the control of
@code{native-comp-async-jobs-number} (@pxref{Native-Compilation Variables}).
@end defun

  The following function allows Lisp programs to test whether
native-compilation is available at runtime.

@defun native-comp-available-p
This function returns non-@code{nil} if the running Emacs process has the
native-compilation support compiled into it.  On systems that load
@file{libgccjit} dynamically, it also makes sure that library is available
and can be loaded.  Lisp programs that need to know up front whether
native-compilation is available should use this predicate.
@end defun

@node Native-Compilation Variables
@section Native-Compilation Variables
@cindex native-compilation variables

  This section documents the variables that control native-compilation.

@defopt native-comp-speed
This variable specifies the optimization level for native compilation.  Its
value should be a number between @minus{}1 and 3.  Values between 0 and 3
specify the optimization levels equivalent to the corresponding compiler
@option{-O0}, @option{-O1}, etc.@: command-line options of the compiler.
The value @minus{}1 means disable native-compilation; functions and files
will be only byte-compiled.  The default value is 2.
@end defopt

@defopt native-comp-debug
This variable specifies the level of debugging information produced by
native-compilation.  Its value should be a number between zero and 3, with
the following meaning:

@table @asis
@item 0
No debugging output.  This is the default.
@item 1
Emit debugging symbols with the native code.  This allows easier debugging
of the native code with debuggers such as @command{gdb}.
@item 2
Like 1, and in addition dump pseudo-C code.
@item 3
Like 2, and in addition dump the GCC intermediate passes and
@file{libgccjit} log file.
@end table
@end defopt

@defopt native-comp-verbose
This variable controls the verbosity of native-compilation by suppressing
some or all of the log messages emitted by it.  If its value is zero, the
default, all of the log messages are suppressed.  Setting it to a value
between 1 and 3 will allow logging of the messages whose level is above the
value.  The values have the following interpretations:

@table @asis
@item 0
No logging.  This is the default.
@item 1
Log the final @acronym{LIMPLE} representation of the code.
@item 2
Log the @acronym{LAP}, the final @acronym{LIMPLE}, and some additional pass
info.
@item 3
Maximum verbosity: log everything.
@end table
@end defopt

@defopt native-comp-async-jobs-number
This variable determines the maximum number of native-compilation
subprocesses that will be started simultaneously.  It should be a
non-negative number.  The default value is zero, which means use half the
number of the CPU execution units, or 1 if the CPU has only one execution
unit.
@end defopt

@defopt native-comp-async-report-warnings-errors
If this variable's value is non-@code{nil}, warnings and errors from
asynchronous native-compilation subprocesses are reported in the main Emacs
session in a buffer named @file{*Warnings*}.  The default value @code{t}
means display the resulting buffer.  To log warnings without popping up the
@file{*Warnings*} buffer, set this variable to @code{silent}.
@end defopt

@defopt native-comp-async-query-on-exit
If this variable's value is non-nil, Emacs will query upon exiting whether
to exit and kill any asynchronous native-compilation subprocesses that are
still running, thus preventing the corresponding @file{.eln} files from
being written.  If the value is @code{nil}, the default, Emacs will kill
these subprocesses without querying.
@end defopt
