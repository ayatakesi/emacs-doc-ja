@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990--1994, 2001--2020 Free Software Foundation, Inc.
@c See the file elisp-ja.texi for copying conditions.
@node Byte Compilation
@chapter バイトコンパイル
@cindex byte compilation
@cindex byte-code
@cindex compilation (Emacs Lisp)

  Emacs
LispにはLispで記述された関数をより効率的に実行できる、@dfn{バイトコード(byte-code)}と呼ばれる特別な表現に翻訳する@dfn{コンパイラー(compiler)}があります。コンパイラーはLispの関数定義をバイトコードに置き換えます。バイトコード関数が呼び出されたとき、その定義は@dfn{バイトコードインタープリター(byte-code
interpreter)}により評価されます。

  バイトコンパイルされたコードは、(本当のコンパイル済みコードのように)そのマシンのハードウェアによって直接実行されるのではなく、バイトコンパイラーによって評価されるため、バイトコードはリコンパイルしなくてもマシン間での完全な可搬性を有します。しかし本当にコンパイルされたコードほど高速ではありません。

  一般的に任意のバージョンのEmacsはそれ以前のバージョンのEmacsにより生成されたバイトコンパイル済みコードを実行できますが、その逆は成り立ちません。

@vindex no-byte-compile
  あるLispファイルを常にコンパイルせずに実行したい場合は、以下のように@code{no-byte-compile}をバインドするファイルローカル変数を配置します:

@example
;; -*-no-byte-compile: t; -*-
@end example

@menu
* Speed of Byte-Code::       バイトコンパイルによるスピードアップ例。
* Compilation Functions::    バイトコンパイル関数。
* Docs and Compilation::     ドキュメント文字列のダイナミックロード。
* Dynamic Loading::          個々の関数のダイナミックロード。
* Eval During Compile::      コンパイル時に評価されるコード。
* Compiler Errors::          コンパイラーのエラーメッセージの扱い。
* Byte-Code Objects::        バイトコンパイル済み関数に使用されるデータ型。
* Disassembly::              バイトコードの逆アセンブル; 
                               バイトコードの読み方。
@end menu

@node Speed of Byte-Code
@section バイトコンパイル済みコードのパフォーマンス

  バイトコンパイルされた関数はCで記述されたプリミティブ関数ほど効率的ではありませんが、Lispで記述されたバージョンよりは高速に実行されます。以下は例です:

@example
@group
(defun silly-loop (n)
  "Return the time, in seconds, to run N iterations of a loop."
  (let ((t1 (float-time)))
    (while (> (setq n (1- n)) 0))
    (- (float-time) t1)))
@result{} silly-loop
@end group

@group
(silly-loop 50000000)
@result{} 10.235304117202759
@end group

@group
(byte-compile 'silly-loop)
@result{} @r{[コンパイルされたコードは表示されない]}
@end group

@group
(silly-loop 50000000)
@result{} 3.705854892730713
@end group
@end example

  この例ではインタープリターによる実行には10秒を要しますが、バイトコンパイルされたコードは4秒未満です。これは典型的な結果例ですが、実際の結果はさまざまでしょう。

@node Compilation Functions
@section バイトコンパイル関数
@cindex compilation functions

  @code{byte-compile}により、関数やマクロを個別にバイトコンパイルできます。@code{byte-compile-file}でファイル全体、@code{byte-recompile-directory}または@code{batch-byte-compile}で複数ファイルをコンパイルできます。

@vindex byte-compile-debug
  バイトコンパイラーが警告および/またはエラーメッセージを生成することもあります(詳細は@ref{Compiler
Errors}を参照)。これらのメッセージは通常はCompilationモードが使用する@file{*Compile-Log*}と呼ばれるバッファーに記録されます。@ref{Compilation
Mode,,,emacs, The GNU Emacs
Manual}を参照してください。しかし変数@code{byte-compile-debug}が非@code{nil}ならエラーメッセージはLispエラーとしてシグナルされます(@ref{Errors}を参照)。

@cindex macro compilation
  バイトコンパイルを意図したファイル内にマクロ呼び出しを記述する際には注意が必要です。マクロ呼び出しはコンパイル時に展開されるので、そのマクロはEmacsにロードされる必要があります(さもないとバイトコンパイラーが正しく処理しないだろう)。これを処理する通常の方法は、必要なマクロ定義を含むファイルを@code{require}フォームで指定することです。バイトコンパイラーは通常はコンパイルするコードを評価しませんが、@code{require}フォームは指定されたライブラリーをロードすることにより特別に扱われます。誰かがコンパイルされたプログラムを@emph{実行}する際にマクロ定義ファイルのロードを回避するためには、@code{require}呼び出しの周囲に@code{eval-when-compile}を記述します(@ref{Eval
During Compile}を参照)。詳細は@ref{Compiling Macros}を参照してください。

  インライン関数(@code{defsubst})はこれほど面倒ではありません。定義が判明する前にそのような関数呼び出しをコンパイルした場合でも、その呼び出しは低速になるだけで正しく機能するでしょう。

@defun byte-compile symbol
この関数は@var{symbol}の関数定義をバイトコンパイルして、以前の定義をコンパイルされた定義に置き換える。@var{symbol}の関数定義は、その関数にたいする実際のコードでなければならない。@code{byte-compile}はインダイレクト関数を処理しない。リターン値は、@var{symbol}のコンパイルされた定義であるようなバイトコード関数ブジェクト(@ref{Byte-Code
Objects}を参照)。

@example
@group
(defun factorial (integer)
  "INTEGERの階乗を計算する。"
  (if (= 1 integer) 1
    (* integer (factorial (1- integer)))))
@result{} factorial
@end group

@group
(byte-compile 'factorial)
@result{}
#[(integer)
  "^H\301U\203^H^@@\301\207\302^H\303^HS!\"\207"
  [integer 1 * factorial]
  4 "Compute factorial of INTEGER."]
@end group
@end example

@var{symbol}の定義がバイトコード関数オブジェクトなら、@code{byte-compile}は何も行わず@code{nil}をリターンする。そのシンボルの関数セル内の(コンパイルされていない)オリジナルのコードはすでにバイトコンパイルされたコードに置き換えられているので、シンボルの定義の再コンパイルはしない。

@code{byte-compile}の引数として@code{lambda}式も指定できる。この場合、関数は対応するコンパイル済みコードをリターンするが、それはどこにも格納されない。
@end defun

@deffn Command compile-defun &optional arg
このコマンドはポイントを含むdefunを読み取りそれをコンパイルして結果を評価する。実際に関数定義であるようなdefunでこれを使用した場合には、その関数のコンパイル済みバージョンをインストールする効果がある。

@code{compile-defun}は通常は評価した結果をエコーエリアに表示するが、@var{arg}が非@code{nil}ならフォームをコンパイルした後にカレントバッファーに結果を挿入する。
@end deffn

@deffn Command byte-compile-file filename
この関数は@var{filename}という名前のLispコードファイルを、バイトコードのファイルにコンパイルする。出力となるファイルの名前は、サフィックス@samp{.el}を@samp{.elc}に変更することにより作成される。@var{filename}が@samp{.el}で終了しない場合には、@samp{.elc}を@var{filename}の最後に付け足す。

コンパイルは入力ファイルから1つのフォームを逐次読み取ることにより機能する。フォームが関数かマクロなら、コンパイル済みの関数かマクロが書き込まれる。それ以外のフォームはまとめられて、まとめられたものごとにコンパイルされて、そのファイルが読まれたとき実行されるようにコンパイルされたコードが書き込まれる。入力ファイルを読み取る際には、すべてのコメントは無視される。

このコマンドはエラーがなければ@code{t}、それ以外は@code{nil}をリターンする。インタラクティブに呼び出されたときは、ファイル名の入力をもとめる。

@example
@group
$ ls -l push*
-rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el
@end group

@group
(byte-compile-file "~/emacs/push.el")
     @result{} t
@end group

@group
$ ls -l push*
-rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el
-rw-rw-rw- 1 lewis lewis 638 Oct  8 20:25 push.elc
@end group
@end example
@end deffn

@deffn Command byte-recompile-directory directory &optional flag force follow-symlinks
@cindex library compilation
このコマンドは@var{directory}(またはそのサブディレクトリー)内の、リコンパイルを要するすべての@samp{.el}ファイルをリコンパイルする。@samp{.elc}ファイルが存在して、それが@samp{.el}より古いファイルは、リコンパイルが必要となる。

@samp{.el}ファイルに対応する@samp{.elc}ファイルが存在しない場合に何を行うかを@var{flag}で指定する。@code{nil}なら、このコマンドはこれらのファイルを無視する。@var{flag}が0なら、それらをコンパイルする。@code{nil}と0以外なら、それらのファイルをコンパイルするかユーザーに尋ねて、同様にそれぞれのサブディレクトリーについても尋ねる。

インタラクティブに呼び出されると、@code{byte-recompile-directory}は@var{directory}の入力を求めて、@var{flag}はプレフィクス引数となる。

@var{force}が非@code{nil}なら、このコマンドは@samp{.elc}ファイルが存在するすべての@samp{.el}ファイルをリコンパイルする。

このコマンドは通常はシンボリックリンクであるような@samp{.el}ファイルをコンパイルしない。オプションの@var{follow-symlink}パラメーターが非@code{nil}なら、シンボリックリンクされた@samp{.el}もコンパイルされる。

リターン値は不定。
@end deffn

@defun batch-byte-compile &optional noforce
この関数はコマンドラインで指定されたファイルにたいして@code{byte-compile-file}を実行する。この関数は処理が完了するとEmacsをkillするので、Emacsのバッチ実行でのみ使用しなければならない。1つのファイルでエラーが発生しても、それによって後続のファイルにたいする処理が妨げられることはないが、そのファイルにたいする出力ファイルは生成されず、Emacsプロセスは0以外のステータスコードで終了する。

@var{noforce}が非@code{nil}なら、この関数は最新の@samp{.elc}ファイルがあるファイルをリコンパイルしない。

@example
$ emacs -batch -f batch-byte-compile *.el
@end example
@end defun

@node Docs and Compilation
@section ドキュメント文字列とコンパイル
@cindex dynamic loading of documentation

  Emacsがバイトコンパイルされたファイルから関数や変数をロードする際、通常はメモリー内にそれらのドキュメント文字列をロードしません。それぞれのドキュメント文字列は、必要なときだけバイトコンパイルされたファイルからダイナミック(dynamic:
動的)にロードされます。ドキュメント文字列の処理をスキップすることにより、メモリーが節約されてロードが高速になります。

  この機能には欠点があります。コンパイル済みのファイルを削除や移動、または(新しいバージョンのコンパイル等で)変更した場合、Emacsは以前にロードした関数や変数のドキュメント文字列にアクセスできなくなるでしょう。このような問題は通常なら、あなた自身がEmacsをビルドしたときに、そのLispファイルを編集および/またはリコンパイルしたときだけ発生します。この問題は、リコンパイル後にそれぞれのファイルをリロードするだけで解決します。

  バイトコンパイルされたファイルからのドキュメント文字列のダイナミックロードは、バイトコンパイルされたファイルごとにコンパイル時に解決されます。これはオプション@code{byte-compile-dynamic-docstrings}で無効にできます。

@defopt byte-compile-dynamic-docstrings
これが非@code{nil}なら、バイトコンパイラーはドキュメント文字列をダイナミックロードするようにセットアップしたコンパイル済みファイルを生成する。

特定のファイルでダイナミックロード機能を無効にするには、以下のようにヘッダー行でこのオプションに@code{nil}をセットする(@ref{File
Variables, , Local Variables in Files, emacs, The GNU Emacs Manual}を参照)。

@smallexample
-*-byte-compile-dynamic-docstrings: nil;-*-
@end smallexample

これは主として、あるファイルを変更しようとしていて、そのファイルをすでにロード済みのEmacsセッションがファイルを変更した際にも正しく機能し続けることを望む場合に有用である。
@end defopt

@cindex @samp{#@@@var{count}}
@cindex @samp{#$}
内部的にはドキュメント文字列のダイナミックロードは、特殊なLispリーダー構文@samp{#@@@var{count}}とともにコンパイル済みファイルに書き込むことによって達成される。この構文は次の@var{count}文字をスキップする。さらに@samp{#$}構文も使用され、これはこのファイルの名前(文字列)を意味する。これらの構文をLispソースファイル内で使用しないこと。これらは人間がファイルを読む際に明確であるようにデザインされていない。

@node Dynamic Loading
@section 個々の関数のダイナミックロード

@cindex dynamic loading of functions
@cindex lazy loading
  ファイルをコンパイルするとき、オプションで@dfn{ダイナミック関数ロード(dynamic function
loading)}機能(@dfn{laxyロード(lazy
loading)とも呼ばれる})を有効にできます。ダイナミック関数ロードでは、ファイルのロードでファイル内の関数定義は完全には読み込まれません。かわりに各関数定義にはそのファイルを参照するプレースホルダーが含まれます。それぞれ関数が最初に呼び出されるときにそのプレースホルダーを置き換えるために、ファイルから完全な定義が読み込まれます。

  ファイルのロードがより高速になるだろうというのがダイナミック関数ロードの利点です。ユーザーが呼び出せる関数を多く含むファイルにとって、それらの関数のうち1つを使用したら多分残りの関数も使用するというのでなければ、これは利点になります。多くのキーボードコマンドを提供する特化したモードは、このパターンの使い方をする場合があります。ユーザーはそのモードを呼び出すかもしれませんが、使用するのはそのモードが提供するコマンドのわずか一部です。

  ダイナミックロード機能には不利な点がいくつかあります:

@itemize @bullet
@item
ロード後にコンパイル済みファイルの削除や移動を行うと、Emacsはまだロードされていない残りの関数定義をロードできなくなる。

@item
(新しいバージョンのコンパイル等で)コンパイル済みファイルを変更した場合に、まだロードされていない関数のロードを試みると通常は無意味な結果となる。
@end itemize

  このような問題は通常の状況でインストールされたEmacsファイルでは決して発生しません。しかしあなたが変更したLispファイルでは発生し得ます。それぞれのファイルをリコンパイルしたらすぐに新たなコンパイル済みファイルをリロードするのが、これらの問題を回避する一番簡単な方法です。

  @emph{ダイナミックな関数ロードの使用により提供される利点がほとんど計測できないという経験から、この機能はEmacs 27.1以降は廃止されます。}

  コンパイル時に変数@code{byte-compile-dynamic}が非@code{nil}なら、バイトコンパイラーはダイナミック関数ロード機能を使用します。ダイナミックロードが望ましいのは特定のファイルにたいしてだけなので、この変数をグローバルにセットしないでください。そのかわりに、特定のソースファイルのファイルローカル変数でこの機能を有効にしてください。たとえばソースファイルの最初の行に以下のテキストを記述することにより、これを行うことができます:

@example
-*-byte-compile-dynamic: t;-*-
@end example

@defvar byte-compile-dynamic
これが非@code{nil}なら、バイトコンパイラーはダイナミック関数ロード用にセットアップされたコンパイル済みファイルを生成する。
@end defvar

@defun fetch-bytecode function
@var{function}がバイトコード関数オブジェクトなら、それがまだ完全にロードされていなければ、バイトコンパイル済みのファイルからの@var{function}のバイトコードのロードを完了させる。それ以外なら何も行わない。この関数は常に@var{function}をリターンする。
@end defun

@node Eval During Compile
@section コンパイル中の評価
@cindex eval during compilation

  これらの機能によりプログラムのコンパイル中に評価されるコードを記述できます。

@defspec eval-and-compile body@dots{}
このフォームはそれを含むコードがコンパイルされるとき、および(コンパイルされているかいないかに関わらず)実行されるときの両方で@var{body}が評価されるようにマークする。

@var{body}を別のファイルに配置して、そのファイルを@code{require}で参照すれば同様の結果が得られる。これは@var{body}が大きいときに望ましい方法である。事実上、@code{require}は自動的に@code{eval-and-compile}されて、そのパッケージはコンパイル時と実行時の両方でロードされる。

@code{autoload}も実際は@code{eval-and-compile}される。これはコンパイル時に認識されるので、そのような関数の使用により警告``not
known to be defined''は生成されない。

ほとんどの@code{eval-and-compile}の使用は、完全に妥当であると言えよう。

あるマクロがマクロの結果を構築するためのヘルパー関数をもち、そのマクロがそのパッケージにたいしてローカルと外部の両方で使用される場合には、コンパイル時と後の実行時にそのヘルパー関数を取得するために@code{eval-and-compile}を使用すること。

これは関数がプログラム的に(@code{fset}で)定義されている場合には、コンパイル時と実行時にプログラム的な定義を行わせてそれらの関数の呼び出しをチェックするためにも使用できる(``not
known to be defined''の警告は抑制される)。
@end defspec

@defspec eval-when-compile body@dots{}
このフォームは@var{body}がコンパイル時に評価され、コンパイルされたプログラムがロードされるときは評価されないようにマークする。コンパイラーによる評価の結果はコンパイル済みのプログラム内の定数となる。ソースファイルをコンパイルではなくロードすると、@var{body}は通常どおり評価される。

@cindex compile-time constant
生成するために何らかの計算が必要な定数があるなら、@code{eval-when-compile}はコンパイル時にそれを行なうことができる。たとえば、

@lisp
(defvar my-regexp
  (eval-when-compile (regexp-opt '("aaa" "aba" "abb"))))
@end lisp

@cindex macros, at compile time
他のパッケージを使用しているが、そのパッケージのマクロ(バイトコンパイラーはそれらを展開します)だけが必要なら、それらを実行せずにコンパイル用にロードさせるために@code{eval-when-compile}を使用できる。たとえば、

@lisp
(eval-when-compile
  (require 'my-macro-package))
@end lisp

これらの事項は、マクロと@code{defsubst}関数がローカルに定義されていて、そのファイル内だけで使用されることを要求する。これらはそのファイルのコンパイルに必要だが、コンパイル済みファイルの実行には、ほとんどの場合必要ない。たとえば、

@lisp
(eval-when-compile
  (unless (fboundp 'some-new-thing)
    (defmacro 'some-new-thing ()
      (compatibility code))))
@end lisp

@noindent
これは大抵は他のバージョンのEmacsとの互換性の保証のためのコードにたいしてのみ有用である。

@strong{Common Lispに関する注意:} トップレベルでは、@code{eval-when-compile}はCommon
Lispのイディオム@code{(eval-when (compile eval) @dots{})}に類似する。トップレベル以外では、Common
Lispのリーダーマクロ@samp{#.}(ただし解釈時を除く)が、@code{eval-when-compile}と近いことを行う。
@end defspec

@node Compiler Errors
@section コンパイラーのエラー
@cindex compiler errors
@cindex byte-compiler errors

  バイトコンパイルのエラーメッセージと警告メッセージは、@file{*Compile-Log*}という名前のバッファーにプリントされます。これらのメッセージには、問題となる箇所を示すファイル名と行番号が含まれます。これらのメッセージにたいして、コンパイラー出力を操作する通常のEmacsコマンドが使用できます。

  あるエラーがプログラムのシンタックスに由来する場合、バイトコンパイラーはエラーの正確な位置の取得に際して混乱するかもしれません。バッファー@w{@file{
*Compiler Input*}}.にスイッチするのは、これを調べ1つの方法です(このバッファー名はスペースで始まるので、Buffer
Menuに表示されない)。このバッファーにはコンパイルされたプログラムと、バイトコンパイラーが読み取った箇所からポイントがどれほど離れているかが含まれ、エラーの原因はその近傍の可能性があります。シンタックスエラーを見つけるヒントについては、@ref{Syntax
Errors}を参照してください。

@cindex byte-compiler warnings
@cindex free variable, byte-compiler warning
@cindex reference to free variable, compilation warning
@cindex function not known to be defined, compilation warning
  定義されていない関数や変数の使用は、バイトコンパイラーにより報告される警告のタイプとしては一般的です。そのような警告では、定義されていない関数や変数を使用した位置ではなく、そのファイルの最後の行の行番号が報告されるので、それを見つけるには手作業で検索しなければなりません。

  定義のない関数や変数の警告が間違いだと確信できる場合には、警告を抑制する方法がいくつかあります:

@itemize @bullet
@item
関数@var{func}への特定の呼び出しにたいする警告は、それを条件式@code{fboundp}でテストすることで抑制できる:

@example
(if (fboundp '@var{func}) ...(@var{func} ...)...)
@end example

@noindent
@var{func}への呼び出しは@code{if}文の@var{then-form}内になければならず、@var{func}は@code{fboundp}呼び出し内でクォートされていなければならない(この機能は@code{cond}でも同様に機能する)。

@item
同じように、変数@var{variable}の特定の使用についの警告を、条件式内の@code{boundp}テストで抑制できる:

@example
(if (boundp '@var{variable}) ...@var{variable}...)
@end example

@noindent
@var{variable}への参照は@code{if}文の@var{then-form}内になければならず、@var{variable}は@code{boundp}呼び出し内でクォートされていなければならない。

@item
コンパイラーに関数が@code{declare-function}を使用して定義されていると告げることができる。@ref{Declaring
Functions}を参照のこと。

@item
同じように変数が初期値なしの@code{defvar}を使用して定義されているとコンパイラーに告げることができる(カレントレキシカルスコープ、またはトップレベルにあればファイルでのみダイナミックにバインドされているとして変数を特別な変数としてマークすることに注意。@ref{Defining
Variables}を参照のこと。
@end itemize

  @code{with-suppressed-warnings}マクロを使用して特定の式にたいするコンパイラーの警告を抑制することもできます:

@defspec with-suppressed-warnings warnings body@dots{}
これは実行においては@code{(progn
@var{body}...)}と等価だが、コンパイラーは@var{body}内の指定したコンディションにたいする警告を発しない。@var{warnings}は警告シンボルと、それらを適用する関数/変数シンボルの連想リスト。たとえば@code{foo}という時代遅れ(obsolete)の関数を呼び出したいがコンパイル時の警告を抑止したければ、以下のようにする:

@lisp
(with-suppressed-warnings ((obsolete foo))
  (foo ...))
@end lisp
@end defspec

コンパイラー警告の抑制をより粗く行うには@code{with-no-warnings}構文を使用できます:

@c This is implemented with a defun, but conceptually it is
@c a special form.

@defspec with-no-warnings body@dots{}
これは実行時には@code{(progn
@var{body}...)}と等価だが、コンパイラーは@var{body}の中で起こるいかなる事項にたいしても警告を発しない。

わたしたちはかわりに@code{with-suppressed-warnings}の使用を推奨するが、この構文を使用する場合には、あなたが抑制したいと意図する警告以外の警告を失わないようにするために、可能な限り小さいコード断片にたいしてこの構文を使用すること。
@end defspec

  変数@code{byte-compile-warnings}をセットすることにより、コンパイラーの警告をより詳細に制御できます。詳細は変数のドキュメント文字列を参照してください。

@vindex byte-compile-error-on-warn
  @code{error}を使用してバイトコンパイラーの警告が報告されることを望む場合があるかもしれません。そのような場合には@code{byte-compile-error-on-warn}を非@code{nil}値にセットしてください。

@node Byte-Code Objects
@section バイトコード関数オブジェクト
@cindex compiled function
@cindex byte-code function
@cindex byte-code object

  バイトコンパイルされた関数は、@dfn{バイトコード関数オブジェクト(byte-code function
objects)}という特別なデータ型をもちます。関数呼び出しとしてそのようなオブジェクトが出現したとき、Emacsはそのバイトコードを実行するために、常にバイトコードインタープリターを使用します。

  内部的にはバイトコード関数オブジェクトはベクターとよく似ています。バイトコード関数オブジェクトの要素には@code{aref}を通じてアクセスできます。バイトコード関数オブジェクトのプリント表現(printed
representation)はベクターと似ていて、開き@samp{[}の前に@samp{#}が追加されます。バイト関数オブジェクトは少なくとも4つの要素をもたねばならず、その要素数に上限はありません。しかし通常使用されるのは最初の6要素です。これらは:

@table @var
@item argdesc
引数の記述子(descriptor)。これは@ref{Argument
List}で説明されるような引数のリスト、または要求される引数の個数をエンコードする整数のいずれかである。後者の場合、その記述子の値は0ビットから6ビットで引数の最小個数、8ビットから14ビットで引数の最大個数を指定する。引数リストが@code{&rest}を使用するなら7ビットがセットされて、それい以外ならクリアーされる。

@var{argdesc}がリストなら、そのバイトコード実行前に引数はダイナミックにバインドされる。@var{argdesc}が整数なら、引数リストはそのバイトコード実行前にバイトコーピンタープリンターのスタックにpushされる。

@item byte-code
バイトコード命令を含む文字列。

@item constants
バイトコードにより参照されるLispオブジェクトのベクター。関数名と変数名に使用されるシンボルが含まれる。

@item stacksize
この関数が要するスタックの最大サイズ。

@item docstring
(もしあれば)ドキュメント文字列。それ以外は@code{nil}。ドキュメント文字列がファイルに格納されている場合、値は数字かリストかもしれない。本当のドキュメント文字列の取得には、関数@code{documentation}を使用する(@ref{Accessing
Documentation}を参照)。

@item interactive
(もしあれば)インタラクティブ仕様。文字列かLisp式。インタラクティブでない関数では@code{nil}。
@end table

以下はバイトコード関数オブジェクトのプリント表現の例です。これはコマンド@code{backward-sexp}の定義です。

@example
#[256
  "\211\204^G^@@\300\262^A\301^A[!\207"
  [1 forward-sexp]
  3
  1793299
  "^p"]
@end example

  バイトコードオブジェクトを作成するプリミティブな方法は@code{make-byte-code}です:

@defun make-byte-code &rest elements
この関数は@var{elements}を要素とするバイトコードオブジェクトを構築してリターンする。
@end defun

  あなた自身で要素を収集してバイトコード関数を構築しないでください。それらが矛盾する場合、その関数の呼び出しによりEmacsがクラッシュするかもしれません。これらのオブジェクトの作成は常にバイトコンパイラーにまかせてください。(願わくば)バイトコンパイラーは要素を矛盾なく構築します。

@node Disassembly
@section 逆アセンブルされたバイトコード
@cindex disassembled byte-code

  人はバイトコードを記述しません。それはバイトコンパイラーの仕事です。しかし好奇心を満たすために、わたしたちはディスアセンブラを提供しています。ディスアセンブラはバイトコードを人間が読めるフォームに変換します。

  バイトコードインタープリターは、シンプルなスタックマシンとして実装されています。これは値を自身のスタックにpushして、計算で使用するためにそれらをpopして取り出し、その結果を再びそのスタックにpushして戻します。バイトコード関数がリターンするときは、スタックから値をpopして取り出し、その関数の値としてリターンします。

  それに加えてスタックとバイトコード関数は、値を変数とスタック間で転送することにより、普通のLisp変数を使用したり、バインドやセットを行うことができます。

@deffn Command disassemble object &optional buffer-or-name
このコマンドは@var{object}にたいするディスアセンブルされたコードを表示する。インタラクティブに使用した場合、または@var{buffer-or-name}が@code{nil}か省略された場合は、@file{*Disassemble*}という名前のバッファーに出力します。@var{buffer-or-name}が非@code{nil}なら、それはバッファーもしくは既存のバッファーの名前でなければならない。その場合は、そのバッファーのポイント位置に出力され、ポイントは出力の前に残りされる。

引数@var{object}には関数名、ラムダ式(@ref{Lambda
Expressions}を参照)、またはバイトコードオブジェクト(@ref{Byte-Code
Objects}を参照)を指定できる。ラムダ式なら@code{disassemble}はそれをコンパイルしてから、そのコンパイル済みコードをディスアセンブルする。
@end deffn

  以下に@code{disassemble}関数を使用した例を2つ示します。バイトコードとLispソースを関連付ける助けとなるように、説明的なコメントを追加してあります。これらのコメントは@code{disassemble}の出力にはありません。

@example
@group
(defun factorial (integer)
  "Compute factorial of an integer."
  (if (= 1 integer) 1
    (* integer (factorial (1- integer)))))
     @result{} factorial
@end group

@group
(factorial 4)
     @result{} 24
@end group

@group
(disassemble 'factorial)
     @print{} byte-code for factorial:
 doc: Compute factorial of an integer.
 args: (integer)
@end group

@group
0   varref   integer      ; @r{@code{integer}の値を取得して}
                          ;   @r{それをスタック上にpushする}
1   constant 1            ; @r{スタック上に1をpushする}
@end group
@group
2   eqlsign               ; @r{2つの値をスタックからpopして取り出し、}
                          ;   @r{それらを比較して結果をスタック上にpushする}
@end group
@group
3   goto-if-nil 1         ; @r{スタックのトップをpopしてテストする}
                          ;   @r{@code{nil}なら1へ、それ以外はcontinue}
6   constant 1            ; @r{スタックのトップに1をpushする}
7   return                ; @r{スタックのトップの要素をリターンする}
@end group
@group
8:1 varref   integer      ; @r{@code{integer}の値をスタック上にpushする}
9   constant factorial    ; @r{@code{factorial}をスタック上にpushする}
10  varref   integer      ; @r{@code{integer}の値をスタック上にpushする}
11  sub1                  ; @r{@code{integer}をpopして値をデクリメントする}
                          ;   @r{スタック上に新しい値をpushする}
12  call     1            ; @r{スタックの最初(トップ)の要素を引数として}
                          ;   @r{関数@code{factorial}を呼び出す}
                          ;   @r{リターン値をスタック上にpushする}
@end group
@group
13 mult                   ; @r{スタックのトップ2要素をpopして取り出し乗じ}
                          ;   @r{結果をスタック上にpushする}
14 return                 ; @r{スタックのトップ要素をリターンする}
@end group
@end example

@code{silly-loop}は幾分複雑です:

@example
@group
(defun silly-loop (n)
  "Return time before and after N iterations of a loop."
  (let ((t1 (current-time-string)))
    (while (> (setq n (1- n))
              0))
    (list t1 (current-time-string))))
     @result{} silly-loop
@end group

@group
(disassemble 'silly-loop)
     @print{} byte-code for silly-loop:
 doc: Return time before and after N iterations of a loop.
 args: (n)
@end group

@group
0   constant current-time-string  ; @r{@code{current-time-string}を}
                                  ;   @r{スタック上のトップにpushする}
@end group
@group
1   call     0            ; @r{引数なしで@code{current-time-string}を呼び出し}
                          ;   @r{結果をスタック上にpushする}
@end group
@group
2   varbind  t1           ; @r{スタックをpopして@code{t1}にpopされた値をバインドする}
@end group
@group
3:1 varref   n            ; @r{環境から@code{n}の値を取得して}
                          ;   @r{その値をスタック上にpushする}
4   sub1                  ; @r{スタックのトップから1を減ずる}
@end group
@group
5   dup                   ; @r{スタックのトップを複製する}
                          ;   @r{たとえばスタックのトップをコピーしてスタック上にpushする}
6   varset   n            ; @r{スタックのトップをpopして}
                          ;   @r{@code{n}をその値にバインドする}

;; @r{(要はシーケンス@code{dup varset}はpopせずに}
;; @r{ スタックのトップを@code{n}の値にコピーする)}
@end group

@group
7   constant 0            ; @r{スタック上に0をpushする}
8   gtr                   ; @r{スタックのトップ2値をpopして取り出し}
                          ;   @r{@var{n}が0より大かテストし}
                          ;   @r{結果をスタック上にpushする}
@end group
@group
9   goto-if-not-nil 1     ; @r{@code{n} > 0なら1へ}
                          ;   @r{(これはwhile-loopを継続する)}
                          ;   @r{それ以外はcontinue}
@end group
@group
12  varref   t1           ; @r{@code{t1}の値をスタック上にpushする}
13  constant current-time-string  ; @r{@code{current-time-string}を}
                                  ;   @r{スタックのトップにpushする}
14  call     0            ; @r{再度@code{current-time-string}を呼び出す}
@end group
@group
15  unbind   1            ; @r{ローカル環境の@code{t1}をアンバインドする}
16  list2                 ; @r{スタックのトップ2要素をpopして取り出し}
                          ;   @r{それらのリストを作りスタック上にpushする}
17  return                ; @r{スタックのトップの値をリターンする}
@end group
@end example
