# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Emacs 26.1\n"
"POT-Creation-Date: 2020-08-02 05:43+0900\n"
"PO-Revision-Date: 2020-07-14 00:30+0900\n"
"Last-Translator: Takeshi Ayanokoji <takeshi.ayanokoji@gmail.com>\n"
"Language-Team: Japanese <takeshi.ayanokoji@gmail.com>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: original_texis/functions.texi:6 original_texis/functions.texi:7
#, no-wrap
msgid "Functions"
msgstr "Functions"

#. type: Plain text
#: original_texis/functions.texi:12
msgid "A Lisp program is composed mainly of Lisp functions.  This chapter explains what functions are, how they accept arguments, and how to define them."
msgstr "Lispプログラムは主にLisp関数で構成されます。このチャプターはで関数とは何か、引数を受け取る方法、そして関数を定義する方法を説明します。"

#. type: node
#: original_texis/functions.texi:33 original_texis/functions.texi:35
#, no-wrap
msgid "What Is a Function"
msgstr "What Is a Function"

#. type: menuentry
#: original_texis/functions.texi:33
msgid "Lisp functions vs. primitives; terminology."
msgstr "Lisp関数 vs. プリミティブ。専門用語。"

#. type: section
#: original_texis/functions.texi:33 original_texis/functions.texi:220
#: original_texis/functions.texi:221
#, no-wrap
msgid "Lambda Expressions"
msgstr "Lambda Expressions"

#. type: menuentry
#: original_texis/functions.texi:33
msgid "How functions are expressed as Lisp objects."
msgstr "関数がLispオブジェクトとして表現される方法。"

#. type: node
#: original_texis/functions.texi:33 original_texis/functions.texi:519
#, no-wrap
msgid "Function Names"
msgstr "Function Names"

#. type: menuentry
#: original_texis/functions.texi:33
msgid "A symbol can serve as the name of a function."
msgstr "シンボルは関数を命名できる。"

#. type: section
#: original_texis/functions.texi:33 original_texis/functions.texi:574
#: original_texis/functions.texi:575
#, no-wrap
msgid "Defining Functions"
msgstr "Defining Functions"

#. type: menuentry
#: original_texis/functions.texi:33
msgid "Lisp expressions for defining functions."
msgstr "関数定義のためのLisp式。"

#. type: section
#: original_texis/functions.texi:33 original_texis/functions.texi:689
#: original_texis/functions.texi:690
#, no-wrap
msgid "Calling Functions"
msgstr "Calling Functions"

#. type: menuentry
#: original_texis/functions.texi:33
msgid "How to use an existing function."
msgstr "既存の関数を使う方法。"

#. type: section
#: original_texis/functions.texi:33 original_texis/functions.texi:860
#: original_texis/functions.texi:861
#, no-wrap
msgid "Mapping Functions"
msgstr "Mapping Functions"

#. type: menuentry
#: original_texis/functions.texi:33
msgid "Applying a function to each element of a list, etc."
msgstr "リストの各要素などに関数を適用する。"

#. type: section
#: original_texis/functions.texi:33 original_texis/functions.texi:981
#: original_texis/functions.texi:982
#, no-wrap
msgid "Anonymous Functions"
msgstr "Anonymous Functions"

#. type: menuentry
#: original_texis/functions.texi:33
msgid "Lambda expressions are functions with no names."
msgstr "ラムダ式、それは無名の関数。"

#. type: section
#: original_texis/functions.texi:33 original_texis/functions.texi:1095
#: original_texis/functions.texi:1096
#, no-wrap
msgid "Generic Functions"
msgstr "Generic Functions"

#. type: menuentry
#: original_texis/functions.texi:33
msgid "Polymorphism, Emacs-style."
msgstr "Emacsスタイルのポリモーフィズム。"

#. type: node
#: original_texis/functions.texi:33 original_texis/functions.texi:1331
#, no-wrap
msgid "Function Cells"
msgstr "Function Cells"

#. type: menuentry
#: original_texis/functions.texi:33
msgid "Accessing or setting the function definition of a symbol."
msgstr "シンボルの関数定義へのアクセスとセット。"

#. type: section
#: original_texis/functions.texi:33 original_texis/functions.texi:1435
#: original_texis/functions.texi:1436
#, no-wrap
msgid "Closures"
msgstr "Closures"

#. type: menuentry
#: original_texis/functions.texi:33
msgid "Functions that enclose a lexical environment."
msgstr "レキシカル環境に囲まれた関数。"

#. type: node
#: original_texis/functions.texi:33 original_texis/functions.texi:1473
#, no-wrap
msgid "Advising Functions"
msgstr "Advising Functions"

#. type: menuentry
#: original_texis/functions.texi:33
msgid "Adding to the definition of a function."
msgstr "関数の定義への追加。"

#. type: node
#: original_texis/functions.texi:33 original_texis/functions.texi:1985
#, no-wrap
msgid "Obsolete Functions"
msgstr "Obsolete Functions"

#. type: menuentry
#: original_texis/functions.texi:33
msgid "Declaring functions obsolete."
msgstr "関数を陳腐と宣言する。"

#. type: section
#: original_texis/functions.texi:33 original_texis/functions.texi:2065
#: original_texis/functions.texi:2066
#, no-wrap
msgid "Inline Functions"
msgstr "Inline Functions"

#. type: menuentry
#: original_texis/functions.texi:33
msgid "Functions that the compiler will expand inline."
msgstr "コンパイラーによりインライン展開される関数。"

#. type: node
#: original_texis/functions.texi:33 original_texis/functions.texi:2205
#, no-wrap
msgid "Declare Form"
msgstr "Declare Form"

#. type: menuentry
#: original_texis/functions.texi:33
msgid "Adding additional information about a function."
msgstr "関数についての補足的な情報の追加。"

#. type: node
#: original_texis/functions.texi:33 original_texis/functions.texi:2296
#, no-wrap
msgid "Declaring Functions"
msgstr "Declaring Functions"

#. type: menuentry
#: original_texis/functions.texi:33
msgid "Telling the compiler that a function is defined."
msgstr "関数が定義されていることをコンパイラーに知らせる。"

#. type: node
#: original_texis/functions.texi:33 original_texis/functions.texi:2381
#, no-wrap
msgid "Function Safety"
msgstr "Function Safety"

#. type: menuentry
#: original_texis/functions.texi:33
msgid "Determining whether a function is safe to call."
msgstr "呼び出しても安全な関数なのか判断する。"

#. type: node
#: original_texis/functions.texi:33 original_texis/functions.texi:2468
#, no-wrap
msgid "Related Topics"
msgstr "Related Topics"

#. type: menuentry
#: original_texis/functions.texi:33
msgid "Cross-references to specific Lisp primitives that have a special bearing on how functions work."
msgstr "関数が動作する方法において特別な意味をもつ、特定のLispプリミティブのクロスリファレンス。"

#. type: section
#: original_texis/functions.texi:36
#, no-wrap
msgid "What Is a Function?"
msgstr "What Is a Function?"

#. type: cindex
#: original_texis/functions.texi:38
#, no-wrap
msgid "return value"
msgstr "return value"

#. type: cindex
#: original_texis/functions.texi:39
#, no-wrap
msgid "value of function"
msgstr "value of function"

#. type: cindex
#: original_texis/functions.texi:40
#, no-wrap
msgid "argument"
msgstr "argument"

#. type: cindex
#: original_texis/functions.texi:41
#, no-wrap
msgid "pure function"
msgstr "pure function"

#. type: Plain text
#: original_texis/functions.texi:51
msgid "In a general sense, a function is a rule for carrying out a computation given input values called @dfn{arguments}.  The result of the computation is called the @dfn{value} or @dfn{return value} of the function.  The computation can also have side effects, such as lasting changes in the values of variables or the contents of data structures (@pxref{Definition of side effect}).  A @dfn{pure function} is a function which, in addition to having no side effects, always returns the same value for the same combination of arguments, regardless of external factors such as machine type or system state."
msgstr "一般的な意味では関数とは@dfn{引数(arguments)}と呼ばれる与えられた入力値の計算を担うルールです。計算の結果は関数の@dfn{値(value)}、または@dfn{return値(return value)}と呼ばれます。計算は変数の値やデータ構造の内容を変更する等の副作用をもつこともできます(@ref{Definition of side effect}を参照)。@dfn{純粋関数(pure function)}とは、それらに加えて副作用をもたず、機種別やシステム状態のような外部要因とは無関係に同じ条件の引数にたいして常に同一の値をリターンする関数のことです。"

#. type: Plain text
#: original_texis/functions.texi:61
msgid "In most computer languages, every function has a name.  But in Lisp, a function in the strictest sense has no name: it is an object which can @emph{optionally} be associated with a symbol (e.g., @code{car})  that serves as the function name.  @xref{Function Names}.  When a function has been given a name, we usually also refer to that symbol as a ``function'' (e.g., we refer to ``the function @code{car}'').  In this manual, the distinction between a function name and the function object itself is usually unimportant, but we will take note wherever it is relevant."
msgstr "ほとんどのコンピューター言語では、関数はそれぞれ名前をもちます。しかしLispでは厳密な意味において関数は名前をもちません。関数はオブジェクトであり、関数の名前の役割を果たすシンボルに関連づけることができますが(たとえば@code{car})、それは@emph{オプション}です。@ref{Function Names}を参照してください。関数が名前を与えられたとき、通常はそのシンボルを``関数''として参照します(たとえば関数@code{car}のように参照する)。このマニュアルでは、関数名と関数オブジェクト自身との間の区別は通常は重要ではありませんが、それが意味をもつような場合には注記します。"

#. type: Plain text
#: original_texis/functions.texi:66
msgid "Certain function-like objects, called @dfn{special forms} and @dfn{macros}, also accept arguments to carry out computations.  However, as explained below, these are not considered functions in Emacs Lisp."
msgstr "@dfn{スペシャルフォーム(special form)}、@dfn{マクロ(macro)}と呼ばれる関数likeなオブジェクトがいくつかあり、それらも引数を受け取って計算を行います。しかし以下で説明するようにEmacs Lispではこれらは関数とはみなされません。"

#. type: Plain text
#: original_texis/functions.texi:68
msgid "Here are important terms for functions and function-like objects:"
msgstr "以下は関数と関数likeなオブジェクトにたいする重要な条件です:"

#. type: cindex
#: original_texis/functions.texi:70 original_texis/functions.texi:222
#, no-wrap
msgid "lambda expression"
msgstr "lambda expression"

#. type: table
#: original_texis/functions.texi:73
msgid "A function (in the strict sense, i.e., a function object) which is written in Lisp.  These are described in the following section."
msgstr "Lispで記述された関数(厳密には関数オブジェクト)。これらについては以降のセクションで説明します。"

#. type: ifnottex
#: original_texis/functions.texi:75
msgid "@xref{Lambda Expressions}."
msgstr "@ref{Lambda Expressions}を参照のこと。"

#. type: cindex
#: original_texis/functions.texi:77 original_texis/functions.texi:78
#, no-wrap
msgid "primitive"
msgstr "primitive"

#. type: item
#: original_texis/functions.texi:79 original_texis/functions.texi:1239
#, no-wrap
msgid "subr"
msgstr "subr"

#. type: cindex
#: original_texis/functions.texi:80
#, no-wrap
msgid "built-in function"
msgstr "built-in function"

#. type: table
#: original_texis/functions.texi:86
msgid "A function which is callable from Lisp but is actually written in C@.  Primitives are also called @dfn{built-in functions}, or @dfn{subrs}.  Examples include functions like @code{car} and @code{append}.  In addition, all special forms (see below) are also considered primitives."
msgstr "Lispから呼び出すことができるが実際にはCで記述されている。プリミティブは@dfn{ビルトイン関数(built-in functions)}とか@dfn{サブルーチン(subr)}のようにも呼ばれる。それらの例には関数likeな@code{car}や@code{append}が含まれる。加えてすべてのスペシャルフォーム(以下参照)もプリミティブとみなされる。"

#. type: table
#: original_texis/functions.texi:93
msgid "Usually, a function is implemented as a primitive because it is a fundamental part of Lisp (e.g., @code{car}), or because it provides a low-level interface to operating system services, or because it needs to run fast.  Unlike functions defined in Lisp, primitives can be modified or added only by changing the C sources and recompiling Emacs.  See @ref{Writing Emacs Primitives}."
msgstr "関数はLispの基礎となる部分(たとえば@code{car})であり、オペレーティングシステムのサービスにたいして低レベルのインターフェースを与え、高速に実行される必要があるために、通常はプリミティブとして実装されている。Lispで定義された関数と異なり、プリミティブの修正や追加には、Cソースの変更とEmacsのリコンパイルが必要となる。@ref{Writing Emacs Primitives}を参照のこと。"

#. type: item
#: original_texis/functions.texi:94
#, no-wrap
msgid "special form"
msgstr "special form"

#. type: table
#: original_texis/functions.texi:100
msgid "A primitive that is like a function but does not evaluate all of its arguments in the usual way.  It may evaluate only some of the arguments, or may evaluate them in an unusual order, or several times.  Examples include @code{if}, @code{and}, and @code{while}.  @xref{Special Forms}."
msgstr "プリミティブは関数と似ているが、すべての引数が通常の方法で評価されない。いくつかの引数だけが評価されるかもしれず、通常ではない順序で評価されるか、複数回評価されるかもしれない。プリミティブの例には@code{if}、@code{and}、@code{while}が含まれる。@ref{Special Forms}を参照のこと。"

#. type: cindex
#: original_texis/functions.texi:101 original_texis/functions.texi:102
#, no-wrap
msgid "macro"
msgstr "macro"

#. type: table
#: original_texis/functions.texi:108
msgid "A construct defined in Lisp, which differs from a function in that it translates a Lisp expression into another expression which is to be evaluated instead of the original expression.  Macros enable Lisp programmers to do the sorts of things that special forms can do.  @xref{Macros}."
msgstr "あるLisp式をオリジナルの式のかわりに評価される別の式に変換する、関数とは別のLispで定義された構文。マクロはスペシャルフォームが行う一連のことを、Lispプログラマーが行うのを可能にする。@ref{Macros}を参照のこと。"

#. type: cindex
#: original_texis/functions.texi:109 original_texis/functions.texi:110
#, no-wrap
msgid "command"
msgstr "command"

#. type: table
#: original_texis/functions.texi:118
msgid "An object which can be invoked via the @code{command-execute} primitive, usually due to the user typing in a key sequence @dfn{bound} to that command.  @xref{Interactive Call}.  A command is usually a function; if the function is written in Lisp, it is made into a command by an @code{interactive} form in the function definition (@pxref{Defining Commands}).  Commands that are functions can also be called from Lisp expressions, just like other functions."
msgstr "プリミティブ@code{command-execute}を通じて呼び出すことができるオブジェクトで、通常はそのコマンドに@dfn{バインド}されたキーシーケンスをユーザーがタイプすることにより呼び出される。@ref{Interactive Call}を参照のこと。コマンドは通常は関数である。その関数がLispで記述されていれば、関数の定義内の@code{interactive}フォームによってコマンドとなる(@ref{Defining Commands}を参照)。関数であるコマンドは他の関数と同様、Lisp式から呼び出すこともできる。"

#. type: table
#: original_texis/functions.texi:124
msgid "Keyboard macros (strings and vectors) are commands also, even though they are not functions.  @xref{Keyboard Macros}.  We say that a symbol is a command if its function cell contains a command (@pxref{Symbol Components}); such a @dfn{named command} can be invoked with @kbd{M-x}."
msgstr "キーボードマクロ(文字列かベクター)は関数ではないが、これらもコマンドである。@ref{Keyboard Macros}を参照のこと。シンボルの関数セルにコマンドが含まれてれば、わたしたちはそのシンボルをコマンドと言う(@ref{Symbol Components}を参照)。そのような@dfn{名前つきコマンド(named command)}は@kbd{M-x}で呼び出すことができる。"

#. type: cindex
#: original_texis/functions.texi:125 original_texis/functions.texi:1446
#, no-wrap
msgid "closure"
msgstr "closure"

#. type: table
#: original_texis/functions.texi:129
msgid "A function object that is much like a lambda expression, except that it also encloses an environment of lexical variable bindings.  @xref{Closures}."
msgstr "ラムダ式とよく似た関数オブジェクトだが、クロージャーはレキシカル変数バインディングの環境にも囲われている。@ref{Closures}を参照のこと。"

#. type: item
#: original_texis/functions.texi:130
#, no-wrap
msgid "byte-code function"
msgstr "byte-code function"

#. type: table
#: original_texis/functions.texi:133
msgid "A function that has been compiled by the byte compiler.  @xref{Byte-Code Type}."
msgstr "バイトコンパイラーによりコンパイル済みの関数。@ref{Byte-Code Type}を参照のこと。"

#. type: cindex
#: original_texis/functions.texi:134 original_texis/functions.texi:135
#, no-wrap
msgid "autoload object"
msgstr "autoload object"

#. type: table
#: original_texis/functions.texi:139
msgid "A place-holder for a real function.  If the autoload object is called, Emacs loads the file containing the definition of the real function, and then calls the real function.  @xref{Autoload}."
msgstr "実際の関数のプレースホルダー。autoloadオブジェクトが呼び出されると、Emacsは実際の関数の定義を含むファイルをロードした後に実際の関数を呼び出す。@ref{Autoload}を参照のこと。"

#. type: Plain text
#: original_texis/functions.texi:143
msgid "You can use the function @code{functionp} to test if an object is a function:"
msgstr "関数@code{functionp}を使用して、あるオブジェクトが関数かどうかテストできます:"

#. type: defun
#: original_texis/functions.texi:144
#, no-wrap
msgid "functionp object"
msgstr "functionp object"

#. type: defun
#: original_texis/functions.texi:149
msgid "This function returns @code{t} if @var{object} is any kind of function, i.e., can be passed to @code{funcall}.  Note that @code{functionp} returns @code{t} for symbols that are function names, and returns @code{nil} for special forms."
msgstr "この関数は@var{object}が任意の種類の関数(@code{funcall}に渡すことができる)なら@code{t}をリターンする。@code{functionp}は関数を名づけるシンボルにたいしては@code{t}、スペシャルフォームにたいしては@code{nil}をリターンすることに注意。"

#. type: Plain text
#: original_texis/functions.texi:153
msgid "It is also possible to find out how many arguments an arbitrary function expects:"
msgstr "任意の関数が期待する引数の個数を調べることもできます:"

#. type: defun
#: original_texis/functions.texi:154
#, no-wrap
msgid "func-arity function"
msgstr "func-arity function"

#. type: defun
#: original_texis/functions.texi:162
msgid "This function provides information about the argument list of the specified @var{function}.  The returned value is a cons cell of the form @w{@code{(@var{min} . @var{max})}}, where @var{min} is the minimum number of arguments, and @var{max} is either the maximum number of arguments, or the symbol @code{many} for functions with @code{&rest} arguments, or the symbol @code{unevalled} if @var{function} is a special form."
msgstr "この関数は指定された@var{function}の引数リストに関する情報を提供する。リターン値は@w{@code{(@var{min} . @var{max})}}という形式のコンスセル。ここで@var{min}は引数の最小個数、@var{max}は引数の最大個数、または@code{&rest}引数をもつ関数では@code{many}、@var{function}がスペシャルフォームならシンボル@code{unevalled}。"

#. type: defun
#: original_texis/functions.texi:165
msgid "Note that this function might return inaccurate results in some situations, such as the following:"
msgstr "以下のようにある状況下ではこの関数は不正確な結果をリターンすることに注意:"

#. type: itemize
#: original_texis/functions.texi:170
msgid "Functions defined using @code{apply-partially} (@pxref{Calling Functions, apply-partially})."
msgstr "@code{apply-partially}を使用して定義された関数(@ref{Calling Functions, apply-partially}を参照)。"

#. type: itemize
#: original_texis/functions.texi:174
msgid "Functions that are advised using @code{advice-add} (@pxref{Advising Named Functions})."
msgstr "@code{advice-add}を使用して定義された関数(@ref{Advising Named Functions}を参照)。"

#. type: itemize
#: original_texis/functions.texi:178
msgid "Functions that determine the argument list dynamically, as part of their code."
msgstr "コードの一部として引数リストを直接判断する関数。"

#. type: Plain text
#: original_texis/functions.texi:185
msgid "Unlike @code{functionp}, the next three functions do @emph{not} treat a symbol as its function definition."
msgstr "@code{functionp}と異なり、以下の3つの関数はシンボルをそれの関数定義としては@emph{扱いません}。"

#. type: defun
#: original_texis/functions.texi:186
#, no-wrap
msgid "subrp object"
msgstr "subrp object"

#. type: defun
#: original_texis/functions.texi:189
msgid "This function returns @code{t} if @var{object} is a built-in function (i.e., a Lisp primitive)."
msgstr "この関数は@var{object}がビルトイン関数(たとえばLispプリミティブ)なら@code{t}をリターンする。"

#. type: group
#: original_texis/functions.texi:194
#, no-wrap
msgid ""
"(subrp 'message)            ; @r{@code{message} is a symbol,}\n"
"     @result{} nil                 ;   @r{not a subr object.}\n"
msgstr ""
"(subrp 'message)            ; @r{@code{message}はシンボルであり、}\n"
"     @result{} nil                 ;   @r{subrオブジェクトではない}\n"

#. type: group
#: original_texis/functions.texi:198
#, no-wrap
msgid ""
"(subrp (symbol-function 'message))\n"
"     @result{} t\n"
msgstr ""
"(subrp (symbol-function 'message))\n"
"     @result{} t\n"

#. type: defun
#: original_texis/functions.texi:202
#, no-wrap
msgid "byte-code-function-p object"
msgstr "byte-code-function-p object"

#. type: defun
#: original_texis/functions.texi:205
msgid "This function returns @code{t} if @var{object} is a byte-code function.  For example:"
msgstr "この関数は@var{object}がバイトコード関数なら@code{t}をリターンする。たとえば:"

#. type: group
#: original_texis/functions.texi:210
#, no-wrap
msgid ""
"(byte-code-function-p (symbol-function 'next-line))\n"
"     @result{} t\n"
msgstr ""
"(byte-code-function-p (symbol-function 'next-line))\n"
"     @result{} t\n"

#. type: defun
#: original_texis/functions.texi:214
#, no-wrap
msgid "subr-arity subr"
msgstr "subr-arity subr"

#. type: defun
#: original_texis/functions.texi:218
msgid "This works like @code{func-arity}, but only for built-in functions and without symbol indirection.  It signals an error for non-built-in functions.  We recommend to use @code{func-arity} instead."
msgstr "これは@code{func-arity}と同様だがシンボルインダイレクションなしのビルトイン関数にたいしてのみ機能する。非ビルトイン関数にたいしてはエラーをシグナルする。かわりに@code{func-arity}の使用を推奨する。"

#. type: Plain text
#: original_texis/functions.texi:226
msgid "A lambda expression is a function object written in Lisp.  Here is an example:"
msgstr "ラムダ式(lambda expression)はLispで記述された関数オブジェクトです。以下は例です:"

#. type: example
#: original_texis/functions.texi:231
#, no-wrap
msgid ""
"(lambda (x)\n"
"  \"Return the hyperbolic cosine of X.\"\n"
"  (* 0.5 (+ (exp x) (exp (- x)))))\n"
msgstr ""
"(lambda (x)\n"
"  \"Xの双曲線コサインをreturnする\"\n"
"  (* 0.5 (+ (exp x) (exp (- x)))))\n"

#. type: Plain text
#: original_texis/functions.texi:236
msgid "In Emacs Lisp, such a list is a valid expression which evaluates to a function object."
msgstr "Emacs Lispではこのようなリストは、関数オブジェクトに評価される有効な式です。"

#. type: Plain text
#: original_texis/functions.texi:243
msgid "A lambda expression, by itself, has no name; it is an @dfn{anonymous function}.  Although lambda expressions can be used this way (@pxref{Anonymous Functions}), they are more commonly associated with symbols to make @dfn{named functions} (@pxref{Function Names}).  Before going into these details, the following subsections describe the components of a lambda expression and what they do."
msgstr "ラムダ式自身は名前をもたない@dfn{無名関数(anonymous function)}です。ラムダ式をこの方法で使用できますが(@ref{Anonymous Functions}を参照)、@dfn{名前付き関数(named functions)}を作成するためにシンボルに関連付けられる方が一般的です(@ref{Function Names}を参照)。これらの詳細に触れる前に以下のサブセクションではラムダ式の構成要素と、それらが行うことについて説明します。"

#. type: node
#: original_texis/functions.texi:249 original_texis/functions.texi:251
#, no-wrap
msgid "Lambda Components"
msgstr "Lambda Components"

#. type: menuentry
#: original_texis/functions.texi:249
msgid "The parts of a lambda expression."
msgstr "ラムダ式のパーツ。"

#. type: node
#: original_texis/functions.texi:249 original_texis/functions.texi:294
#, no-wrap
msgid "Simple Lambda"
msgstr "Simple Lambda"

#. type: menuentry
#: original_texis/functions.texi:249
msgid "A simple example."
msgstr "シンプルな例。"

#. type: node
#: original_texis/functions.texi:249 original_texis/functions.texi:344
#, no-wrap
msgid "Argument List"
msgstr "Argument List"

#. type: menuentry
#: original_texis/functions.texi:249
msgid "Details and special features of argument lists."
msgstr "引数リストの詳細と特別な機能。"

#. type: node
#: original_texis/functions.texi:249 original_texis/functions.texi:454
#, no-wrap
msgid "Function Documentation"
msgstr "Function Documentation"

#. type: menuentry
#: original_texis/functions.texi:249
msgid "How to put documentation in a function."
msgstr "関数内にドキュメントを記述する方法。"

#. type: subsection
#: original_texis/functions.texi:252
#, no-wrap
msgid "Components of a Lambda Expression"
msgstr "Components of a Lambda Expression"

#. type: Plain text
#: original_texis/functions.texi:255
msgid "A lambda expression is a list that looks like this:"
msgstr "ラムダ式は以下のようなリストです:"

#. type: example
#: original_texis/functions.texi:261
#, no-wrap
msgid ""
"(lambda (@var{arg-variables}@dots{})\n"
"  [@var{documentation-string}]\n"
"  [@var{interactive-declaration}]\n"
"  @var{body-forms}@dots{})\n"
msgstr ""
"(lambda (@var{arg-variables}@dots{})\n"
"  [@var{documentation-string}]\n"
"  [@var{interactive-declaration}]\n"
"  @var{body-forms}@dots{})\n"

#. type: cindex
#: original_texis/functions.texi:263
#, no-wrap
msgid "lambda list"
msgstr "lambda list"

#. type: Plain text
#: original_texis/functions.texi:269
msgid "The first element of a lambda expression is always the symbol @code{lambda}.  This indicates that the list represents a function.  The reason functions are defined to start with @code{lambda} is so that other lists, intended for other uses, will not accidentally be valid as functions."
msgstr "ラムダ式の1番目の要素は常にシンボル@code{lambda}です。これはそのリストが関数を表すことを示します。@code{lambda}で関数定義を開始する理由は、別の目的での使用が意図された他のリストが、意図せずに関数として評価されないようにするためです。"

#. type: Plain text
#: original_texis/functions.texi:275
msgid "The second element is a list of symbols---the argument variable names.  This is called the @dfn{lambda list}.  When a Lisp function is called, the argument values are matched up against the variables in the lambda list, which are given local bindings with the values provided.  @xref{Local Variables}."
msgstr "2番目の要素はシンボル --- 引数変数名のリストです。これは@dfn{ラムダリスト(lambda list)}と呼ばれます。Lisp関数が呼び出されたとき、引数値はラムダリスト内の変数と対応付けされます。ラムダリストには、与えられた値にたいするローカルバインディングが付与されます。@ref{Local Variables}を参照してください。"

#. type: Plain text
#: original_texis/functions.texi:279
msgid "The documentation string is a Lisp string object placed within the function definition to describe the function for the Emacs help facilities.  @xref{Function Documentation}."
msgstr "ドキュメント文字列(documentation string)はEmacs Lispのヘルプ機能にたいして、その関数を説明する関数定義に配されたLispの文字列オブジェクトです。@ref{Function Documentation}を参照してください。"

#. type: Plain text
#: original_texis/functions.texi:287
msgid "The interactive declaration is a list of the form @code{(interactive @var{code-string})}.  This declares how to provide arguments if the function is used interactively.  Functions with this declaration are called @dfn{commands}; they can be called using @kbd{M-x} or bound to a key.  Functions not intended to be called in this way should not have interactive declarations.  @xref{Defining Commands}, for how to write an interactive declaration."
msgstr "インタラクティブ宣言(interactive declaration)は、@code{(interactive @var{code-string})}という形式のリストです。これはこの関数が対話的に使用された場合に引数を提供する方法を宣言します。この宣言をもつ関数は、@dfn{コマンド(command)}と呼ばれます。コマンドは@kbd{M-x}を使用したり、キーにバインドして呼び出すことができます。この方法で呼び出されることを意図しない関数は、インタラクティブ宣言を持つべきではありません。インタラクティブ定義を記述する方法は、@ref{Defining Commands}を参照してください。"

#. type: cindex
#: original_texis/functions.texi:288
#, no-wrap
msgid "body of function"
msgstr "body of function"

#. type: Plain text
#: original_texis/functions.texi:293
msgid "The rest of the elements are the @dfn{body} of the function: the Lisp code to do the work of the function (or, as a Lisp programmer would say, ``a list of Lisp forms to evaluate'').  The value returned by the function is the value returned by the last element of the body."
msgstr "残りの要素はその関数の@dfn{body(本体)} --- その関数が処理を行うためのLispコード(Lispプログラマーは``評価されるLispフォームのリスト''と言うだろう)です。この関数からリターンされる値は、bodyの最後の要素によりリターンされる値です。"

#. type: subsection
#: original_texis/functions.texi:295
#, no-wrap
msgid "A Simple Lambda Expression Example"
msgstr "A Simple Lambda Expression Example"

#. type: Plain text
#: original_texis/functions.texi:298
msgid "Consider the following example:"
msgstr "以下の例を考えてみてください:"

#. type: example
#: original_texis/functions.texi:301
#, no-wrap
msgid "(lambda (a b c) (+ a b c))\n"
msgstr "(lambda (a b c) (+ a b c))\n"

#. type: Plain text
#: original_texis/functions.texi:305
msgid "We can call this function by passing it to @code{funcall}, like this:"
msgstr "以下のように@code{funcall}に渡すことにより、この関数を呼び出すことができます:"

#. type: group
#: original_texis/functions.texi:310
#, no-wrap
msgid ""
"(funcall (lambda (a b c) (+ a b c))\n"
"         1 2 3)\n"
msgstr ""
"(funcall (lambda (a b c) (+ a b c))\n"
"         1 2 3)\n"

#. type: Plain text
#: original_texis/functions.texi:318
msgid "This call evaluates the body of the lambda expression with the variable @code{a} bound to 1, @code{b} bound to 2, and @code{c} bound to 3.  Evaluation of the body adds these three numbers, producing the result 6; therefore, this call to the function returns the value 6."
msgstr "この呼び出しは変数@code{a}に1、@code{b}に2、@code{c}に3をバインドして、ラムダ式のbodyを評価します。bodyの評価によってこれら3つの数が加算されて、6が結果として生成されます。したがってこの関数呼び出しにより6がリターンされます。"

#. type: Plain text
#: original_texis/functions.texi:321
msgid "Note that the arguments can be the results of other function calls, as in this example:"
msgstr "以下のように引数は他の関数の結果であってもよいことに注意してください:"

#. type: group
#: original_texis/functions.texi:326
#, no-wrap
msgid ""
"(funcall (lambda (a b c) (+ a b c))\n"
"         1 (* 2 3) (- 5 4))\n"
msgstr ""
"(funcall (lambda (a b c) (+ a b c))\n"
"         1 (* 2 3) (- 5 4))\n"

#. type: Plain text
#: original_texis/functions.texi:333
msgid "This evaluates the arguments @code{1}, @code{(* 2 3)}, and @code{(- 5 4)} from left to right.  Then it applies the lambda expression to the argument values 1, 6 and 1 to produce the value 8."
msgstr "これは引数@code{1}、@code{(* 2 3)}、@code{(- 5 4)}を左から右に評価します。その後ラムダ式に引数1、6、1を適用して値8が生成されます。"

#. type: Plain text
#: original_texis/functions.texi:343
msgid "As these examples show, you can use a form with a lambda expression as its @sc{car} to make local variables and give them values.  In the old days of Lisp, this technique was the only way to bind and initialize local variables.  But nowadays, it is clearer to use the special form @code{let} for this purpose (@pxref{Local Variables}).  Lambda expressions are mainly used as anonymous functions for passing as arguments to other functions (@pxref{Anonymous Functions}), or stored as symbol function definitions to produce named functions (@pxref{Function Names})."
msgstr "これらの例が示すように、ローカル変数を作成してそれらに値を与えるフォームとして、@sc{car}がラムダ式であるようなフォームを使用することができます。古い時代のLispでは、この方法がローカル変数をバインドして初期化する唯一の方法でした。しかし現在ではこの目的にはフォーム@code{let}を使用するほうが明解です(@ref{Local Variables}を参照)。ラムダ式は主に他の関数の引数として渡される無名関数(@ref{Anonymous Functions}を参照)として、あるいは名前つき関数(@ref{Function Names}を参照)を生成するためにシンボルの関数定義に格納するために使用されます。"

#. type: subsection
#: original_texis/functions.texi:345
#, no-wrap
msgid "Other Features of Argument Lists"
msgstr "Other Features of Argument Lists"

#. type: kindex
#: original_texis/functions.texi:346
#, no-wrap
msgid "wrong-number-of-arguments"
msgstr "wrong-number-of-arguments"

#. type: cindex
#: original_texis/functions.texi:347
#, no-wrap
msgid "argument binding"
msgstr "argument binding"

#. type: cindex
#: original_texis/functions.texi:348
#, no-wrap
msgid "binding arguments"
msgstr "binding arguments"

#. type: cindex
#: original_texis/functions.texi:349
#, no-wrap
msgid "argument lists, features"
msgstr "argument lists, features"

#. type: Plain text
#: original_texis/functions.texi:356
msgid "Our simple sample function, @code{(lambda (a b c) (+ a b c))}, specifies three argument variables, so it must be called with three arguments: if you try to call it with only two arguments or four arguments, you get a @code{wrong-number-of-arguments} error (@pxref{Errors})."
msgstr "シンプルなサンプル関数@code{(lambda (a b c) (+ a b c))}は3つの引数変数を指定しているので、3つの引数で呼び出されなければなりません。引数を2つしか指定しなかったり4つ指定した場合には@code{wrong-number-of-arguments}エラーとなります(@ref{Errors}を参照)。"

#. type: Plain text
#: original_texis/functions.texi:364
msgid "It is often convenient to write a function that allows certain arguments to be omitted.  For example, the function @code{substring} accepts three arguments---a string, the start index and the end index---but the third argument defaults to the @var{length} of the string if you omit it.  It is also convenient for certain functions to accept an indefinite number of arguments, as the functions @code{list} and @code{+} do."
msgstr "特定の引数を省略できる関数を記述できると便利なこともあります。たとえば関数@code{substring}は3つの引数 --- 文字列、開始インデックス、終了インデックス --- を受け取りますが、3つ目の引数を省略すると、デフォルトでその文字列の@var{length}となります。関数@code{list}や@code{+}が行うように、特定の関数にたいして不定個の引数を指定できると便利なときもあります。"

#. type: cindex
#: original_texis/functions.texi:365
#, no-wrap
msgid "optional arguments"
msgstr "optional arguments"

#. type: cindex
#: original_texis/functions.texi:366
#, no-wrap
msgid "rest arguments"
msgstr "rest arguments"

#. type: kindex
#: original_texis/functions.texi:367
#, no-wrap
msgid "&optional"
msgstr "&optional"

#. type: kindex
#: original_texis/functions.texi:368
#, no-wrap
msgid "&rest"
msgstr "&rest"

#. type: Plain text
#: original_texis/functions.texi:373
msgid "To specify optional arguments that may be omitted when a function is called, simply include the keyword @code{&optional} before the optional arguments.  To specify a list of zero or more extra arguments, include the keyword @code{&rest} before one final argument."
msgstr "関数が呼び出されるとき省略されるかもしれないオプションの引数を指定するには、オプションの引数の前にキーワード@code{&optional}を含めるだけです。0個以上の追加引数のリストを指定するには、最後の引数の前にキーワード@code{&rest}を含めます。"

#. type: Plain text
#: original_texis/functions.texi:375
msgid "Thus, the complete syntax for an argument list is as follows:"
msgstr "したがって引数リストの完全な構文は以下のようになります:"

#. type: group
#: original_texis/functions.texi:381
#, fuzzy, no-wrap
#| msgid ""
#| "(@var{required-vars}@dots{}\n"
#| " @r{[}&optional @var{optional-vars}@dots{}@r{]}\n"
#| " @r{[}&rest @var{rest-var}@r{]})\n"
msgid ""
"(@var{required-vars}@dots{}\n"
" @r{[}&optional @r{[}@var{optional-vars}@dots{}@r{]}@r{]}\n"
" @r{[}&rest @r{[}@var{rest-var}@r{]}@r{]})\n"
msgstr ""
"(@var{required-vars}@dots{}\n"
" @r{[}&optional @var{optional-vars}@dots{}@r{]}\n"
" @r{[}&rest @var{rest-var}@r{]})\n"

#. type: Plain text
#: original_texis/functions.texi:387
msgid "The square brackets indicate that the @code{&optional} and @code{&rest} clauses, and the variables that follow them, are optional."
msgstr "角カッコ(square bracket)は@code{&optional}と@code{&rest}、およびそれらに続く変数が省略できることを示します。"

#. type: Plain text
#: original_texis/functions.texi:393
msgid "A call to the function requires one actual argument for each of the @var{required-vars}.  There may be actual arguments for zero or more of the @var{optional-vars}, and there cannot be any actual arguments beyond that unless the lambda list uses @code{&rest}.  In that case, there may be any number of extra actual arguments."
msgstr "この関数の呼び出しでは@var{required-vars}のそれぞれにたいして、実際の引数が要求されます。0個以上の@var{optional-vars}にたいして実際の引数があるかもしれませんが、ラムダ式が@code{&rest}を使用していなければ、その個数を超えて実際の引数を記述することはできません。@code{&rest}が記述されていれば、追加で任意の個数の実際の引数があるかもしれません。"

#. type: Plain text
#: original_texis/functions.texi:401
msgid "If actual arguments for the optional and rest variables are omitted, then they always default to @code{nil}.  There is no way for the function to distinguish between an explicit argument of @code{nil} and an omitted argument.  However, the body of the function is free to consider @code{nil} an abbreviation for some other meaningful value.  This is what @code{substring} does; @code{nil} as the third argument to @code{substring} means to use the length of the string supplied."
msgstr "optionaやrest変数にたいして実際の引数が省略されると、それらのデフォルトは常に@code{nil}になります。関数にたいして引数に明示的に@code{nil}が使用されたのか、引数が省略されたのかを区別することはできません。しかし関数のbodyが、@code{nil}を他の有意な値が省略されたと判断することは自由です。@code{substring}はこれを行います。@code{substring}の3つ目の引数が@code{nil}なら、それは文字列の長さを使用することを意味します。"

#. type: cindex
#: original_texis/functions.texi:402
#, no-wrap
msgid "CL note---default optional arg"
msgstr "CL note---default optional arg"

#. type: quotation
#: original_texis/functions.texi:408
msgid "@b{Common Lisp note:} Common Lisp allows the function to specify what default value to use when an optional argument is omitted; Emacs Lisp always uses @code{nil}.  Emacs Lisp does not support @code{supplied-p} variables that tell you whether an argument was explicitly passed."
msgstr "@b{Common Lispに関する注意:} Common Lispではオプションの引数が省略されたときに使用するデフォルト値を指定できる。Emacs Lispでは、引数が明示的に渡されたかを調べる@code{supplied-p}変数はサポートされない。"

#. type: Plain text
#: original_texis/functions.texi:411
msgid "For example, an argument list that looks like this:"
msgstr "例えば引数リストは以下のようになります:"

#. type: example
#: original_texis/functions.texi:414
#, no-wrap
msgid "(a b &optional c d &rest e)\n"
msgstr "(a b &optional c d &rest e)\n"

#. type: Plain text
#: original_texis/functions.texi:428
msgid "binds @code{a} and @code{b} to the first two actual arguments, which are required.  If one or two more arguments are provided, @code{c} and @code{d} are bound to them respectively; any arguments after the first four are collected into a list and @code{e} is bound to that list.  Thus, if there are only two arguments, @code{c}, @code{d} and @code{e} are @code{nil}; if two or three arguments, @code{d} and @code{e} are @code{nil}; if four arguments or fewer, @code{e} is @code{nil}.  Note that exactly five arguments with an explicit @code{nil} argument provided for @code{e} will cause that @code{nil} argument to be passed as a list with one element, @code{(nil)}, as with any other single value for @code{e}."
msgstr "これは@code{a}と@code{b}は最初の2つの実引数となり、これらは必須です。さらに1つまたは2つの引数が指定された場合には、それらは順番に@code{c}と@code{d}にバインドされます。1つ目から4つ目の引数の後の引数はリストにまとめられて、@code{e}にそのリストがバインドされます。したがって2つしか引数が指定されなかった場合には@code{c}、@code{d}、@code{e}は@code{nil}になります。2つまたは3つの引数の場合には@code{d}と@code{e}は@code{nil}です。引数が4つ以下の場合には、@code{e}は@code{nil}になります。正確に5つの引数に明示的に@code{nil}が指定された場合には、@code{e}にたいして他の単一値が与えられたときのように、引数の@code{nil}が1要素のリスト@code{(nil)}として@code{e}に与えられます。"

#. type: Plain text
#: original_texis/functions.texi:437
msgid "There is no way to have required arguments following optional ones---it would not make sense.  To see why this must be so, suppose that @code{c} in the example were optional and @code{d} were required.  Suppose three actual arguments are given; which variable would the third argument be for? Would it be used for the @var{c}, or for @var{d}? One can argue for both possibilities.  Similarly, it makes no sense to have any more arguments (either required or optional)  after a @code{&rest} argument."
msgstr "オプションの引数の後ろに必須の引数を指定する方法はありません --- これは意味を成さないからです。なぜそうなるかは、この例で@code{c}がオプションで@code{d}が必須な場合を考えてみてください。実際に3つの引数が与えられたとします。3番めの引数は何を指定したのでしょうか? この引数は@var{c}なのでしょうか、それとも@var{d}に使用されるのでしょうか? 両方の場合が考えられます。同様に@code{&rest}引数の後に、さらに引数(必須またはオプション)をもつことも意味を成しません。"

#. type: Plain text
#: original_texis/functions.texi:439
msgid "Here are some examples of argument lists and proper calls:"
msgstr "以下に引数リストと、それを正しく呼び出す例をいくつか示します:"

#. type: example
#: original_texis/functions.texi:452
#, no-wrap
msgid ""
"(funcall (lambda (n) (1+ n))        ; @r{One required:}\n"
"         1)                         ; @r{requires exactly one argument.}\n"
"     @result{} 2\n"
"(funcall (lambda (n &optional n1)   ; @r{One required and one optional:}\n"
"           (if n1 (+ n n1) (1+ n))) ; @r{1 or 2 arguments.}\n"
"         1 2)\n"
"     @result{} 3\n"
"(funcall (lambda (n &rest ns)       ; @r{One required and one rest:}\n"
"           (+ n (apply '+ ns)))     ; @r{1 or more arguments.}\n"
"         1 2 3 4 5)\n"
"     @result{} 15\n"
msgstr ""
"(funcall (lambda (n) (1+ n))        ; @r{1つの必須:}\n"
"         1)                         ; @r{これは正確に1つの引数を要求する}\n"
"     @result{} 2\n"
"(funcall (lambda (n &optional n1)   ; @r{1つは必須で、1つはオプション:}\n"
"           (if n1 (+ n n1) (1+ n))) ; @r{1つまたは2つの引数}\n"
"         1 2)\n"
"     @result{} 3\n"
"(funcall (lambda (n &rest ns)       ; @r{1つは必須で、後は残り:}\n"
"           (+ n (apply '+ ns)))     ; @r{1つ以上の引数}\n"
"         1 2 3 4 5)\n"
"     @result{} 15\n"

#. type: subsection
#: original_texis/functions.texi:455
#, no-wrap
msgid "Documentation Strings of Functions"
msgstr "Documentation Strings of Functions"

#. type: cindex
#: original_texis/functions.texi:456
#, fuzzy, no-wrap
#| msgid "Documentation Strings of Functions"
msgid "documentation string of function"
msgstr "Documentation Strings of Functions"

#. type: cindex
#: original_texis/functions.texi:457
#, fuzzy, no-wrap
#| msgid "Function Documentation"
msgid "function's documentation string"
msgstr "Function Documentation"

#. type: Plain text
#: original_texis/functions.texi:465
msgid "A lambda expression may optionally have a @dfn{documentation string} just after the lambda list.  This string does not affect execution of the function; it is a kind of comment, but a systematized comment which actually appears inside the Lisp world and can be used by the Emacs help facilities.  @xref{Documentation}, for how the documentation string is accessed."
msgstr "ラムダ式はラムダリストの直後に、オプションで@dfn{ドキュメント文字列(documentation string)}をもつことができます。この文字列は、その関数の実行に影響を与えません。これはコメントの一種ですがLisp機構に内在するシステム化されたコメントであり。Emacsのヘルプ機能で使用できます。ドキュメント文字列にアクセスする方法は、@ref{Documentation}を参照してください。"

#. type: Plain text
#: original_texis/functions.texi:470
msgid "It is a good idea to provide documentation strings for all the functions in your program, even those that are called only from within your program.  Documentation strings are like comments, except that they are easier to access."
msgstr "たとえその関数があなたのプログラム内だけで呼び出される関数だとしても、すべての関数にドキュメント文字列を与えるのはよいアイデアです。ドキュメント文字列はコメントと似ていますが、コメントより簡単にアクセスできます。"

#. type: Plain text
#: original_texis/functions.texi:474
msgid "The first line of the documentation string should stand on its own, because @code{apropos} displays just this first line.  It should consist of one or two complete sentences that summarize the function's purpose."
msgstr "ドキュメント文字列の1行目は、関数自体にもとづくものであるべきです。なぜなら@code{apropos}は、最初の1行目だけを表示するからです。ドキュメント文字列の1行目は、その関数の目的を要約する1つか2つの完全なセンテンスで構成されるべきです。"

#. type: Plain text
#: original_texis/functions.texi:483
msgid "The start of the documentation string is usually indented in the source file, but since these spaces come before the starting double-quote, they are not part of the string.  Some people make a practice of indenting any additional lines of the string so that the text lines up in the program source.  @emph{That is a mistake.} The indentation of the following lines is inside the string; what looks nice in the source code will look ugly when displayed by the help commands."
msgstr "ドキュメント文字列の開始は通常、ソースファイル内ではインデントされていますが、ドキュメント文字列の開始のダブルクォート文字の前にインデントのスペースがあるので、インデントはドキュメント文字列の一部にはなりません。ドキュメント文字列の残りの行がプログラムソース内で揃うようにインデントする人がいます。@emph{これは間違いです}。後続の行のインデントは文字列の内部にあります。これはソースコード内での見栄えはよくなりますが、ヘルプコマンドで表示したとき見栄えが悪くなります。"

#. type: Plain text
#: original_texis/functions.texi:491
msgid "You may wonder how the documentation string could be optional, since there are required components of the function that follow it (the body).  Since evaluation of a string returns that string, without any side effects, it has no effect if it is not the last form in the body.  Thus, in practice, there is no confusion between the first form of the body and the documentation string; if the only body form is a string then it serves both as the return value and as the documentation."
msgstr "ドキュメント文字列がなぜオプションになるのか不思議に思うかもしれません。なぜならドキュメント文字列の後には必須となる関数の構成要素であるbodyが続くからです。文字列を評価するとその文字列自身がリターンされるので、それがbody内の最後のフォームでない限りなんの効果もありません。したがって実際はbodyの1行目とドキュメント文字列で混乱が生じることはありません。bodyの唯一のフォームが文字列なら、それはリターン値とドキュメントの両方の役目を果たします。"

#. type: Plain text
#: original_texis/functions.texi:495
msgid "The last line of the documentation string can specify calling conventions different from the actual function arguments.  Write text like this:"
msgstr "ドキュメント文字列の最後の行には、実際の関数引数とは異なる呼び出し規約を指定できます。これは以下のようなテキストを記述します"

#. type: example
#: original_texis/functions.texi:498
#, no-wrap
msgid "\\(fn @var{arglist})\n"
msgstr "\\(fn @var{arglist})\n"

#. type: Plain text
#: original_texis/functions.texi:506
msgid "following a blank line, at the beginning of the line, with no newline following it inside the documentation string.  (The @samp{\\} is used to avoid confusing the Emacs motion commands.)  The calling convention specified in this way appears in help messages in place of the one derived from the actual arguments of the function."
msgstr "そのテキストの後に空行を配置して、テキスト自身は行頭から記述、ドキュメント文字列内でこのテキストの後に改行が続かないように記述します(@samp{\\}はEmacsの移動コマンドが混乱するのを避けるために使用する)。この方法で指定された呼び出し規約は、ヘルプメッセージ内で関数の実引数から生成される呼び出し例と同じ場所に表示されます。"

#. type: Plain text
#: original_texis/functions.texi:510
msgid "This feature is particularly useful for macro definitions, since the arguments written in a macro definition often do not correspond to the way users think of the parts of the macro call."
msgstr "マクロ定義内に記述された引数は、ユーザーがマクロ呼び出しの一部だと考える方法とは合致しない場合がしばしばあるので、この機能はマクロ定義で特に有用です。"

#. type: Plain text
#: original_texis/functions.texi:518
msgid "Do not use this feature if you want to deprecate the calling convention and favor the one you advertise by the above specification.  Instead, use the @code{advertised-calling-convention} declaration (@pxref{Declare Form}) or @code{set-advertised-calling-convention} (@pxref{Obsolete Functions}), because these two will cause the byte compiler emit a warning message when it compiles Lisp programs which use the deprecated calling convention."
msgstr "呼び出し規約を廃止して上記の仕様で示す規約を公開したければ、この機能を使用してはなりません。かわりに廃止された呼び出し規約を使用するLispプログラムのバイトコンパイル時に警告メッセージを発する宣言@code{advertised-calling-convention} (@ref{Declare Form}を参照)か@code{set-advertised-calling-convention} (@ref{Obsolete Functions}を参照)を使用してください。"

#. type: section
#: original_texis/functions.texi:520
#, no-wrap
msgid "Naming a Function"
msgstr "Naming a Function"

#. type: cindex
#: original_texis/functions.texi:521
#, no-wrap
msgid "function definition"
msgstr "function definition"

#. type: cindex
#: original_texis/functions.texi:522
#, no-wrap
msgid "named function"
msgstr "named function"

#. type: cindex
#: original_texis/functions.texi:523
#, no-wrap
msgid "function name"
msgstr "function name"

#. type: Plain text
#: original_texis/functions.texi:530
msgid "A symbol can serve as the name of a function.  This happens when the symbol's @dfn{function cell} (@pxref{Symbol Components}) contains a function object (e.g., a lambda expression).  Then the symbol itself becomes a valid, callable function, equivalent to the function object in its function cell."
msgstr "シンボルは関数の名前となることができます。これはそのシンボルの@dfn{関数セル(function cell}: @ref{Symbol Components}を参照)が、関数オブジェクト(たとえばラムダ式)を含むときに起こります。するとそのシンボル自身が呼び出し可能な有効な関数、つまりそのシンボルの関数セルの関数と等価になります。"

#. type: Plain text
#: original_texis/functions.texi:537
msgid "The contents of the function cell are also called the symbol's @dfn{function definition}.  The procedure of using a symbol's function definition in place of the symbol is called @dfn{symbol function indirection}; see @ref{Function Indirection}.  If you have not given a symbol a function definition, its function cell is said to be @dfn{void}, and it cannot be used as a function."
msgstr "関数セルの内容はそのシンボルの@dfn{関数定義(function definition)}と呼ぶこともできます。そのシンボルのかわりにシンボルの関数定義を使う手続きのことを@dfn{シンボル関数インダイレクション(symbol function indirection)}と呼びます。@ref{Function Indirection}を参照。与えられたシンボルに関数定義がなければシンボルの関数セルは@dfn{void}と呼ばれ、それを関数として使用することはできません。"

#. type: Plain text
#: original_texis/functions.texi:543
msgid "In practice, nearly all functions have names, and are referred to by their names.  You can create a named Lisp function by defining a lambda expression and putting it in a function cell (@pxref{Function Cells}).  However, it is more common to use the @code{defun} special form, described in the next section."
msgstr "実際のところほとんどすべての関数は名前をもち、その名前により参照されます。ラムダ式を定義することで名前つきのLisp関数を作成、それを関数セル(@ref{Function Cells}を参照)に置くことができます。しかしより一般的なのは@code{defun}スペシャルフォーム(次のセクションで説明)を使う方法です。"

#. type: ifnottex
#: original_texis/functions.texi:545
msgid "@xref{Defining Functions}."
msgstr "@ref{Defining Functions}を参照してください。"

#. type: Plain text
#: original_texis/functions.texi:553
msgid "We give functions names because it is convenient to refer to them by their names in Lisp expressions.  Also, a named Lisp function can easily refer to itself---it can be recursive.  Furthermore, primitives can only be referred to textually by their names, since primitive function objects (@pxref{Primitive Function Type}) have no read syntax."
msgstr "わたしたちが関数に名前を与えるのは、Lisp式内で関数を名前で参照するのが便利だからです。また名前つきの関数は簡単に自分自身を --- 再帰的(recursive)に参照することができます。さらにプリミティブはテキスト的な名前だけで参照することができます。なぜならプリミティブ関数は入力構文(read syntax)をもたないオブジェクトだからです(@ref{Primitive Function Type}を参照)。"

#. type: Plain text
#: original_texis/functions.texi:559
msgid "A function need not have a unique name.  A given function object @emph{usually} appears in the function cell of only one symbol, but this is just a convention.  It is easy to store it in several symbols using @code{fset}; then each of the symbols is a valid name for the same function."
msgstr "関数が一意な名前をもつ必要はありません。与えられた関数オブジェクトは@emph{通常}は1つのシンボルの関数セルだけに存在しますが、これは単に慣習的なものです。@code{fset}を使用すれば関数を複数のシンボルに格納するのは簡単です。それらのシンボルはそれぞれ、同じ関数にたいする有効な名前となります。"

#. type: Plain text
#: original_texis/functions.texi:564
msgid "Note that a symbol used as a function name may also be used as a variable; these two uses of a symbol are independent and do not conflict.  (This is not the case in some dialects of Lisp, like Scheme.)"
msgstr "関数として使用しているシンボルを、変数としても利用できることに注意してください。シンボルのこれら2つの利用法は独立しており、競合はしません(これはSchemaのような他のいくつかのLisp方言には当てはまらない)。"

#. type: Plain text
#: original_texis/functions.texi:573
msgid "By convention, if a function's symbol consists of two names separated by @samp{--}, the function is intended for internal use and the first part names the file defining the function.  For example, a function named @code{vc-git--rev-parse} is an internal function defined in @file{vc-git.el}.  Internal-use functions written in C have names ending in @samp{-internal}, e.g., @code{bury-buffer-internal}.  Emacs code contributed before 2018 may follow other internal-use naming conventions, which are being phased out."
msgstr "慣例により関数のシンボルが@samp{--}で分割される2つの名前で構成される場合には、その関数は内部的な使用を意図しており、名前の最初の部分は関数を定義するファイルです。たとえば@code{vc-git--rev-parse}という名前の関数は@file{vc-git.el}で定義される内部関数です。Cで記述された内部関数は@code{bury-buffer-internal}のように名前が@samp{-internal}で終わります。2018年より前に貢献されたEmacsコードは内部的な使用にたいして別の命名規約を使用するかもしれませんが、これらは徐々に廃止されます。"

#. type: cindex
#: original_texis/functions.texi:576
#, no-wrap
msgid "defining a function"
msgstr "defining a function"

#. type: Plain text
#: original_texis/functions.texi:582
#, fuzzy
#| msgid "We usually give a name to a function when it is first created.  This is called @dfn{defining a function}, and it is done with the @code{defun} macro."
msgid "We usually give a name to a function when it is first created.  This is called @dfn{defining a function}, and we usually do it with the @code{defun} macro.  This section also describes other ways to define a function."
msgstr "わたしたちは通常は関数を最初に作成したときに名前を与えます。これは@dfn{関数の定義(defining a function)}と呼ばれ、@code{defun}マクロにより行われます。"

#. type: defmac
#: original_texis/functions.texi:583
#, no-wrap
msgid "defun name args [doc] [declare] [interactive] body@dots{}"
msgstr "defun name args [doc] [declare] [interactive] body@dots{}"

#. type: defmac
#: original_texis/functions.texi:588
msgid "@code{defun} is the usual way to define new Lisp functions.  It defines the symbol @var{name} as a function with argument list @var{args} and body forms given by @var{body}.  Neither @var{name} nor @var{args} should be quoted."
msgstr "@code{defun}は新たなLisp関数を定義する通常の方法である。これは引数リスト@var{args}、および@var{body}により与えられるbodyフォームとともに、シンボル@var{name}を関数として定義する。@var{name}と@var{args}をクォートする必要はない。"

#. type: defmac
#: original_texis/functions.texi:595
msgid "@var{doc}, if present, should be a string specifying the function's documentation string (@pxref{Function Documentation}).  @var{declare}, if present, should be a @code{declare} form specifying function metadata (@pxref{Declare Form}).  @var{interactive}, if present, should be an @code{interactive} form specifying how the function is to be called interactively (@pxref{Interactive Call})."
msgstr "@var{doc}が与えられたら、それはその関数のドキュメント文字列を指定する文字列であること(@ref{Function Documentation}を参照)。@var{declare}が与えられたら、それは関数のメタデータを指定する@code{declare}フォームであること(@ref{Declare Form}を参照)。@var{interactive}が与えられたら、それは関数が対話的に呼び出される方法を指定する@code{interactive}フォームであるこ(@ref{Interactive Call}を参照)。"

#. type: defmac
#: original_texis/functions.texi:597
msgid "The return value of @code{defun} is undefined."
msgstr "@code{defun}のリターン値は定義されていません。"

#. type: defmac
#: original_texis/functions.texi:599
msgid "Here are some examples:"
msgstr "以下にいくつか例を示す:"

#. type: group
#: original_texis/functions.texi:605
#, no-wrap
msgid ""
"(defun foo () 5)\n"
"(foo)\n"
"     @result{} 5\n"
msgstr ""
"(defun foo () 5)\n"
"(foo)\n"
"     @result{} 5\n"

#. type: group
#: original_texis/functions.texi:612
#, no-wrap
msgid ""
"(defun bar (a &optional b &rest c)\n"
"    (list a b c))\n"
"(bar 1 2 3 4 5)\n"
"     @result{} (1 2 (3 4 5))\n"
msgstr ""
"(defun bar (a &optional b &rest c)\n"
"    (list a b c))\n"
"(bar 1 2 3 4 5)\n"
"     @result{} (1 2 (3 4 5))\n"

#. type: group
#: original_texis/functions.texi:616
#, no-wrap
msgid ""
"(bar 1)\n"
"     @result{} (1 nil nil)\n"
msgstr ""
"(bar 1)\n"
"     @result{} (1 nil nil)\n"

#. type: group
#: original_texis/functions.texi:620
#, no-wrap
msgid ""
"(bar)\n"
"@error{} Wrong number of arguments.\n"
msgstr ""
"(bar)\n"
"@error{} Wrong number of arguments.\n"

#. type: group
#: original_texis/functions.texi:630
#, no-wrap
msgid ""
"(defun capitalize-backwards ()\n"
"  \"Upcase the last letter of the word at point.\"\n"
"  (interactive)\n"
"  (backward-word 1)\n"
"  (forward-word 1)\n"
"  (backward-char 1)\n"
"  (capitalize-word 1))\n"
msgstr ""
"(defun capitalize-backwards ()\n"
"  \"Upcase the last letter of the word at point.\"\n"
"  (interactive)\n"
"  (backward-word 1)\n"
"  (forward-word 1)\n"
"  (backward-char 1)\n"
"  (capitalize-word 1))\n"

#. type: cindex
#: original_texis/functions.texi:633
#, no-wrap
msgid "override existing functions"
msgstr "override existing functions"

#. type: cindex
#: original_texis/functions.texi:634
#, no-wrap
msgid "redefine existing functions"
msgstr "既存の関数の再定義。"

#. type: defmac
#: original_texis/functions.texi:641
msgid "Be careful not to redefine existing functions unintentionally.  @code{defun} redefines even primitive functions such as @code{car} without any hesitation or notification.  Emacs does not prevent you from doing this, because redefining a function is sometimes done deliberately, and there is no way to distinguish deliberate redefinition from unintentional redefinition."
msgstr "意図せず既存の関数を再定義しないように注意されたい。@code{defun}は@code{car}のようなプリミティブ関数でさえ、問い合わせせずに躊躇なく再定義する。Emacsがこれを妨げることはない。なぜなら関数の再定義は故意に行われることがあり、そのような意図した再定義を、意図しない再定義と見分ける方法はがないからである。"

#. type: cindex
#: original_texis/functions.texi:643
#, no-wrap
msgid "function aliases"
msgstr "function aliases"

#. type: cindex
#: original_texis/functions.texi:644
#, no-wrap
msgid "alias, for functions"
msgstr "alias, for functions"

#. type: defun
#: original_texis/functions.texi:645
#, no-wrap
msgid "defalias name definition &optional doc"
msgstr "defalias name definition &optional doc"

#. type: anchor{#1}
#: original_texis/functions.texi:650
msgid "Definition of defalias"
msgstr "Definition of defalias"

#. type: defun
#: original_texis/functions.texi:650
msgid "This function defines the symbol @var{name} as a function, with definition @var{definition} (which can be any valid Lisp function).  Its return value is @emph{undefined}."
msgstr "この関数は定義@var{definition}(任意の有効なLisp関数)とともに、シンボル@var{name}を関数として定義する。この関数のリターン値は@emph{未定義}。"

#. type: defun
#: original_texis/functions.texi:654
msgid "If @var{doc} is non-@code{nil}, it becomes the function documentation of @var{name}.  Otherwise, any documentation provided by @var{definition} is used."
msgstr "@var{doc}が非@code{nil}なら、それは関数@var{name}のドキュメントとなる。それ以外なら@var{definition}により提供されるドキュメントが使用される。"

#. type: cindex
#: original_texis/functions.texi:655
#, no-wrap
msgid "defalias-fset-function property"
msgstr "defalias-fset-function property"

#. type: defun
#: original_texis/functions.texi:659
msgid "Internally, @code{defalias} normally uses @code{fset} to set the definition.  If @var{name} has a @code{defalias-fset-function} property, however, the associated value is used as a function to call in place of @code{fset}."
msgstr "内部的には@code{defalias}は、通常は定義のセットに@code{fset}を使用する。しかし@var{name}が@code{defalias-fset-function}プロパティーをもつなら、@code{fset}を呼び出すかわりにそれに割り当てられた値を使用する。"

#. type: defun
#: original_texis/functions.texi:665
msgid "The proper place to use @code{defalias} is where a specific function name is being defined---especially where that name appears explicitly in the source file being loaded.  This is because @code{defalias} records which file defined the function, just like @code{defun} (@pxref{Unloading})."
msgstr "@code{defalias}を使う正しい場所は、特定の関数名が正に定義される場所 --- 特にソースファイルがロードされるとき明示的にその名前が出現する場所である。これは@code{defalias}が@code{defun}と同じように、どれが関数を定義するファイルなのか記録するからである(@ref{Unloading}を参照)。"

#. type: defun
#: original_texis/functions.texi:669
msgid "By contrast, in programs that manipulate function definitions for other purposes, it is better to use @code{fset}, which does not keep such records.  @xref{Function Cells}."
msgstr "それとは対象的に他の目的のために関数を操作するプログラムでは、そのような記録を保持しない@code{fset}を使用するほうがよいだろう。@ref{Function Cells}を参照のこと。"

#. type: Plain text
#: original_texis/functions.texi:681
msgid "You cannot create a new primitive function with @code{defun} or @code{defalias}, but you can use them to change the function definition of any symbol, even one such as @code{car} or @code{x-popup-menu} whose normal definition is a primitive.  However, this is risky: for instance, it is next to impossible to redefine @code{car} without breaking Lisp completely.  Redefining an obscure function such as @code{x-popup-menu} is less dangerous, but it still may not work as you expect.  If there are calls to the primitive from C code, they call the primitive's C definition directly, so changing the symbol's definition will have no effect on them."
msgstr "@code{defun}や@code{defalias}で新たなプリミティブ関数を作成することはできませんが、任意の関数定義を変更するのに使用することができ、通常の定義がプリミティブである@code{car}や@code{x-popup-menu}のような関数でさえ変更することができます。しかしこれは危険なことです。たとえばLispの完全性を損なうことなく、@code{car}を再定義するのはほとんど不可能だからです。それほど有名ではない@code{x-popup-menu}のような関数の再定義では、危険は減少しますが、それでも期待したとおりに機能しないかもしれません。Cコードにそのプリミティブの呼び出しがあれば、それは直接そのプリミティブのC定義を呼び出すので、シンボル定義を変更してもそれらに影響はありません。"

#. type: Plain text
#: original_texis/functions.texi:685
msgid "See also @code{defsubst}, which defines a function like @code{defun} and tells the Lisp compiler to perform inline expansion on it.  @xref{Inline Functions}."
msgstr "@code{defsubst}も参照してください。これは@code{defun}のように関数を定義して、それのインライン展開を処理するようLispコンパイラーに指示します。@ref{Inline Functions}を参照してください。"

#. type: Plain text
#: original_texis/functions.texi:688
msgid "To undefine a function name, use @code{fmakunbound}.  @xref{Function Cells}."
msgstr ""

#. type: cindex
#: original_texis/functions.texi:691
#, no-wrap
msgid "function invocation"
msgstr "function invocation"

#. type: cindex
#: original_texis/functions.texi:692
#, no-wrap
msgid "calling a function"
msgstr "calling a function"

#. type: Plain text
#: original_texis/functions.texi:697
msgid "Defining functions is only half the battle.  Functions don't do anything until you @dfn{call} them, i.e., tell them to run.  Calling a function is also known as @dfn{invocation}."
msgstr "関数を定義しただけでは半分しか終わっていません。関数はそれを@dfn{呼び出す(call)} --- たとえば実行(run)するまでは何も行いません。関数のcallは@dfn{invocation}としても知られています。"

#. type: Plain text
#: original_texis/functions.texi:702
msgid "The most common way of invoking a function is by evaluating a list.  For example, evaluating the list @code{(concat \"a\" \"b\")} calls the function @code{concat} with arguments @code{\"a\"} and @code{\"b\"}.  @xref{Evaluation}, for a description of evaluation."
msgstr "関数を呼び出すもっとも一般的な方法は、リストの評価によるものです。たとえばリスト@code{(concat \"a\" \"b\")}を評価することにより、関数@code{concat}が引数@code{\"a\"}と@code{\"b\"}で呼び出されます。評価については@ref{Evaluation}を参照してください。"

#. type: Plain text
#: original_texis/functions.texi:709
msgid "When you write a list as an expression in your program, you specify which function to call, and how many arguments to give it, in the text of the program.  Usually that's just what you want.  Occasionally you need to compute at run time which function to call.  To do that, use the function @code{funcall}.  When you also need to determine at run time how many arguments to pass, use @code{apply}."
msgstr "プログラム内で式としてリストを記述するときは、プログラム内にテキストでどの関数を呼び出すか、いくつの引数を与えるかを指定します。通常はこれが行いたいことです。どの関数を呼び出すかを実行時に計算する必要がある場合もあります。これを行うには関数@code{funcall}を使用します。実行時にいくつの引数を渡すか決定する必要があるときは@code{apply}を使用します。"

#. type: defun
#: original_texis/functions.texi:710
#, no-wrap
msgid "funcall function &rest arguments"
msgstr "funcall function &rest arguments"

#. type: defun
#: original_texis/functions.texi:713
msgid "@code{funcall} calls @var{function} with @var{arguments}, and returns whatever @var{function} returns."
msgstr "@code{funcall}は関数@var{function}を引数@var{arguments}で呼び出して、@var{function}がリターンした値をリターンする。"

#. type: defun
#: original_texis/functions.texi:723
msgid "Since @code{funcall} is a function, all of its arguments, including @var{function}, are evaluated before @code{funcall} is called.  This means that you can use any expression to obtain the function to be called.  It also means that @code{funcall} does not see the expressions you write for the @var{arguments}, only their values.  These values are @emph{not} evaluated a second time in the act of calling @var{function}; the operation of @code{funcall} is like the normal procedure for calling a function, once its arguments have already been evaluated."
msgstr "@code{funcall}は関数なので、@var{function}を含むすべての引数は@code{funcall}の呼び出し前に評価される。これは呼び出される関数を得るために任意の式を使用できることを意味している。また@code{funcall}が@var{arguments}に記述した式ではなく、その値だけを見ることを意味している。これらの値は@var{function}呼び出し中では、2回目は@emph{評価されない}。@code{funcall}の処理は関数の通常の呼び出し手続きと似ており、すでに評価された引数は評価されない。"

#. type: defun
#: original_texis/functions.texi:729
msgid "The argument @var{function} must be either a Lisp function or a primitive function.  Special forms and macros are not allowed, because they make sense only when given the unevaluated argument expressions.  @code{funcall} cannot provide these because, as we saw above, it never knows them in the first place."
msgstr "引数@var{function}はLisp関数かプリミティブ関数でなければならない。つまりスペシャルフォームやマクロは、未評価の引数式を与えられたときだけ意味があるので、指定することはできない。上述したように最初の場所で@code{funcall}がそれらを知らないので、@code{funcall}がそれらを提供することはできない。"

#. type: defun
#: original_texis/functions.texi:733
msgid "If you need to use @code{funcall} to call a command and make it behave as if invoked interactively, use @code{funcall-interactively} (@pxref{Interactive Call})."
msgstr "コマンドの呼び出しに@code{funcall}を使用して、それがインタラクティブに呼び出されたように振る舞うようにする必要があるなら、@code{funcall-interactively}を使用すること(@ref{Interactive Call}を参照)。"

#. type: group
#: original_texis/functions.texi:738 original_texis/functions.texi:773
#, no-wrap
msgid ""
"(setq f 'list)\n"
"     @result{} list\n"
msgstr ""
"(setq f 'list)\n"
"     @result{} list\n"

#. type: group
#: original_texis/functions.texi:742
#, no-wrap
msgid ""
"(funcall f 'x 'y 'z)\n"
"     @result{} (x y z)\n"
msgstr ""
"(funcall f 'x 'y 'z)\n"
"     @result{} (x y z)\n"

#. type: group
#: original_texis/functions.texi:746
#, no-wrap
msgid ""
"(funcall f 'x 'y '(z))\n"
"     @result{} (x y (z))\n"
msgstr ""
"(funcall f 'x 'y '(z))\n"
"     @result{} (x y (z))\n"

#. type: group
#: original_texis/functions.texi:750
#, no-wrap
msgid ""
"(funcall 'and t nil)\n"
"@error{} Invalid function: #<subr and>\n"
msgstr ""
"(funcall 'and t nil)\n"
"@error{} Invalid function: #<subr and>\n"

#. type: defun
#: original_texis/functions.texi:754
msgid "Compare these examples with the examples of @code{apply}."
msgstr "これらの例を@code{apply}の例と比較されたい。"

#. type: defun
#: original_texis/functions.texi:756
#, no-wrap
msgid "apply function &rest arguments"
msgstr "apply function &rest arguments"

#. type: defun
#: original_texis/functions.texi:763
msgid "@code{apply} calls @var{function} with @var{arguments}, just like @code{funcall} but with one difference: the last of @var{arguments} is a list of objects, which are passed to @var{function} as separate arguments, rather than a single list.  We say that @code{apply} @dfn{spreads} this list so that each individual element becomes an argument."
msgstr "@code{apply}は関数@var{function}を引数@var{arguments}で呼び出す。これは@code{funcall}と同様だが1つ違いがある。@var{arguments}の最後はオブジェクトのリストである。これは1つのリストではなく、個別の引数として@var{function}に渡される。わたしたちはこれを、@code{apply}がこのリストを@dfn{展開(spread)}(個々の要素が引数となるので)すると言う。"

#. type: defun
#: original_texis/functions.texi:768
msgid "@code{apply} returns the result of calling @var{function}.  As with @code{funcall}, @var{function} must either be a Lisp function or a primitive function; special forms and macros do not make sense in @code{apply}."
msgstr "@code{apply}は@var{function}を呼び出した結果をリターンする。@code{funcall}と同様、@var{function}はLisp関数かプリミティブ関数でなければならない。つまりスペシャルフォームやマクロは@code{apply}では意味をもたない。"

#. type: group
#: original_texis/functions.texi:777
#, no-wrap
msgid ""
"(apply f 'x 'y 'z)\n"
"@error{} Wrong type argument: listp, z\n"
msgstr ""
"(apply f 'x 'y 'z)\n"
"@error{} Wrong type argument: listp, z\n"

#. type: group
#: original_texis/functions.texi:781
#, no-wrap
msgid ""
"(apply '+ 1 2 '(3 4))\n"
"     @result{} 10\n"
msgstr ""
"(apply '+ 1 2 '(3 4))\n"
"     @result{} 10\n"

#. type: group
#: original_texis/functions.texi:785
#, no-wrap
msgid ""
"(apply '+ '(1 2 3 4))\n"
"     @result{} 10\n"
msgstr ""
"(apply '+ '(1 2 3 4))\n"
"     @result{} 10\n"

#. type: group
#: original_texis/functions.texi:790
#, no-wrap
msgid ""
"(apply 'append '((a b c) nil (x y z) nil))\n"
"     @result{} (a b c x y z)\n"
msgstr ""
"(apply 'append '((a b c) nil (x y z) nil))\n"
"     @result{} (a b c x y z)\n"

#. type: defun
#: original_texis/functions.texi:795
msgid "For an interesting example of using @code{apply}, see @ref{Definition of mapcar}."
msgstr "@code{apply}を使用した興味深い例は@ref{Definition of mapcar}を参照のこと。"

#. type: cindex
#: original_texis/functions.texi:797
#, no-wrap
msgid "partial application of functions"
msgstr "partial application of functions"

#. type: cindex
#: original_texis/functions.texi:798
#, no-wrap
msgid "currying"
msgstr "currying"

#. type: Plain text
#: original_texis/functions.texi:810
msgid "Sometimes it is useful to fix some of the function's arguments at certain values, and leave the rest of arguments for when the function is actually called.  The act of fixing some of the function's arguments is called @dfn{partial application} of the function@footnote{ This is related to, but different from @dfn{currying}, which transforms a function that takes multiple arguments in such a way that it can be called as a chain of functions, each one with a single argument.}.  The result is a new function that accepts the rest of arguments and calls the original function with all the arguments combined."
msgstr "ある関数にたいして、その関数のある引数を特定の値に固定して、他の引数は実際に呼びだされたときの値にできれば便利なことがあります。関数のいくつかの引数を固定することは、その関数の@dfn{部分適用(partial application)}と呼ばれます@footnote{これは@dfn{カリー化(currying)}と関連しますが異なる機能です。カーリングは複数の引数を受け取る関数を、関数チェーンとして呼び出せるような１つの引数を取る個々の関数に変換するような方法です。}。これの結果は残りの引数をとる新たな関数で、すべての引数を合わせて元の関数を呼び出します。"

#. type: Plain text
#: original_texis/functions.texi:812
msgid "Here's how to do partial application in Emacs Lisp:"
msgstr "Emacs Lispで部分適用を行う方法を示します:"

#. type: defun
#: original_texis/functions.texi:813
#, no-wrap
msgid "apply-partially func &rest args"
msgstr "apply-partially func &rest args"

#. type: defun
#: original_texis/functions.texi:820
msgid "This function returns a new function which, when called, will call @var{func} with the list of arguments composed from @var{args} and additional arguments specified at the time of the call.  If @var{func} accepts @var{n} arguments, then a call to @code{apply-partially} with @w{@code{@var{m} < @var{n}}} arguments will produce a new function of @w{@code{@var{n} - @var{m}}} arguments."
msgstr "この関数は新たな関数をリターンする。この新しい関数は呼びだされたときに@var{args}、および呼び出し時に指定された追加の引数から成る引数リストで@var{func}を呼び出す関数である。@var{func}に@var{n}個の引数を指定できる場合、@w{@code{@var{m} < @var{n}}}個の引数で@code{apply-partially}を呼び出すと、@w{@code{@var{n} - @var{m}}}個の新たな関数を生成する。"

#. type: defun
#: original_texis/functions.texi:824
msgid "Here's how we could define the built-in function @code{1+}, if it didn't exist, using @code{apply-partially} and @code{+}, another built-in function:"
msgstr "以下はビルトイン関数@code{1+}が存在しないものとして、@code{apply-partially}と他のビルトイン関数@code{+}を使用して@code{1+}を定義する例である:"

#. type: group
#: original_texis/functions.texi:829
#, no-wrap
msgid ""
"(defalias '1+ (apply-partially '+ 1)\n"
"  \"Increment argument by one.\")\n"
msgstr ""
"(defalias '1+ (apply-partially '+ 1)\n"
"  \"Increment argument by one.\")\n"

#. type: group
#: original_texis/functions.texi:833
#, no-wrap
msgid ""
"(1+ 10)\n"
"     @result{} 11\n"
msgstr ""
"(1+ 10)\n"
"     @result{} 11\n"

#. type: cindex
#: original_texis/functions.texi:837
#, no-wrap
msgid "functionals"
msgstr "functionals"

#. type: Plain text
#: original_texis/functions.texi:842
msgid "It is common for Lisp functions to accept functions as arguments or find them in data structures (especially in hook variables and property lists) and call them using @code{funcall} or @code{apply}.  Functions that accept function arguments are often called @dfn{functionals}."
msgstr "引数として関数を受け取ったり、データ構造(特にフック変数やプロパティーリスト)から関数を探す関数はLispでは一般的で、それらは@code{funcall}や@code{apply}を使用してそれらの関数を呼び出します。引数として関数をとる関数は、@dfn{ファンクショナル(functional)}と呼ばれるときもあります。"

#. type: Plain text
#: original_texis/functions.texi:846
msgid "Sometimes, when you call a functional, it is useful to supply a no-op function as the argument.  Here are two different kinds of no-op function:"
msgstr "ファンクショナルを呼び出すとき、引数としてno-op関数(何も行わない関数)を指定できると便利なときがあります。以下に２つの異なるno-op関数を示します:"

#. type: defun
#: original_texis/functions.texi:847
#, fuzzy, no-wrap
#| msgid "identity arg"
msgid "identity argument"
msgstr "identity arg"

#. type: defun
#: original_texis/functions.texi:849
#, fuzzy
#| msgid "This function returns @var{arg} and has no side effects."
msgid "This function returns @var{argument} and has no side effects."
msgstr "この関数は@var{arg}をリターンする。副作用はない。"

#. type: defun
#: original_texis/functions.texi:851
#, fuzzy, no-wrap
#| msgid "ignore &rest args"
msgid "ignore &rest arguments"
msgstr "ignore &rest args"

#. type: defun
#: original_texis/functions.texi:853
#, fuzzy
#| msgid "This function ignores any arguments and returns @code{nil}."
msgid "This function ignores any @var{arguments} and returns @code{nil}."
msgstr "この関数はすべての引数を無視して@code{nil}をリターンする。"

#. type: Plain text
#: original_texis/functions.texi:859
msgid "Some functions are user-visible @dfn{commands}, which can be called interactively (usually by a key sequence).  It is possible to invoke such a command exactly as though it was called interactively, by using the @code{call-interactively} function.  @xref{Interactive Call}."
msgstr "関数のいくつかはユーザーに可視な@dfn{コマンド}で、これらは(通常はキーシーケンスを介して)対話的に呼び出すことができます。そのようなコマンドは、@code{call-interactively}関数を使用することにより、対話的に呼びだされたときと同様に呼び出すことができます。@ref{Interactive Call}を参照してください。"

#. type: cindex
#: original_texis/functions.texi:862
#, no-wrap
msgid "mapping functions"
msgstr "mapping functions"

#. type: Plain text
#: original_texis/functions.texi:872
msgid "A @dfn{mapping function} applies a given function (@emph{not} a special form or macro) to each element of a list or other collection.  Emacs Lisp has several such functions; this section describes @code{mapcar}, @code{mapc}, @code{mapconcat}, and @code{mapcan}, which map over a list.  @xref{Definition of mapatoms}, for the function @code{mapatoms} which maps over the symbols in an obarray.  @xref{Definition of maphash}, for the function @code{maphash} which maps over key/value associations in a hash table."
msgstr "@dfn{マップ関数(mapping function)}は与えられた関数(スペシャルフォームやマクロでは@emph{ない})をリストや他のコレクションの各要素に適用します。Emacs Lispにはそのような関数がいくつかあります。このセクションではリストにたいしてマッピングを行う@code{mapcar}、@code{mapc}、@code{mapconcat}、@code{mapcan}を説明します。obarray内のシンボルにたいしてマッピングを行う関数@code{mapatoms}は@ref{Definition of mapatoms}を参照してください。ハッシュテーブル内のkey/value関係にたいしてマッピングを行う関数@code{maphash}は@ref{Definition of maphash}を参照してください。"

#. type: Plain text
#: original_texis/functions.texi:877
msgid "These mapping functions do not allow char-tables because a char-table is a sparse array whose nominal range of indices is very large.  To map over a char-table in a way that deals properly with its sparse nature, use the function @code{map-char-table} (@pxref{Char-Tables})."
msgstr "これらのマップ関数は文字テーブル(char-table)には適用されません。なぜなら文字テーブルは非常に広い範囲の疎な配列だからです。疎な配列であるという性質に適う方法で文字テーブルにマッピングするには、関数@code{map-char-table}を使用します(@ref{Char-Tables}を参照)。"

#. type: defun
#: original_texis/functions.texi:878
#, no-wrap
msgid "mapcar function sequence"
msgstr "mapcar function sequence"

#. type: anchor{#1}
#: original_texis/functions.texi:882
msgid "Definition of mapcar"
msgstr "Definition of mapcar"

#. type: defun
#: original_texis/functions.texi:882
msgid "@code{mapcar} applies @var{function} to each element of @var{sequence} in turn, and returns a list of the results."
msgstr "@code{mapcar}は関数@var{function}を@var{sequence}の各要素にたいして順番に適用して、その結果をリストでリターンする。"

#. type: defun
#: original_texis/functions.texi:887
msgid "The argument @var{sequence} can be any kind of sequence except a char-table; that is, a list, a vector, a bool-vector, or a string.  The result is always a list.  The length of the result is the same as the length of @var{sequence}.  For example:"
msgstr "引数@var{sequence}には、文字テーブルを除く任意の種類のシーケンス --- つまりリスト、ベクター、ブールベクター、文字列を指定できる。結果は常にリストになる。結果の長さは@var{sequence}の長さと同じ。たとえば:"

#. type: group
#: original_texis/functions.texi:896
#, no-wrap
msgid ""
"(mapcar 'car '((a b) (c d) (e f)))\n"
"     @result{} (a c e)\n"
"(mapcar '1+ [1 2 3])\n"
"     @result{} (2 3 4)\n"
"(mapcar 'string \"abc\")\n"
"     @result{} (\"a\" \"b\" \"c\")\n"
msgstr ""
"(mapcar 'car '((a b) (c d) (e f)))\n"
"     @result{} (a c e)\n"
"(mapcar '1+ [1 2 3])\n"
"     @result{} (2 3 4)\n"
"(mapcar 'string \"abc\")\n"
"     @result{} (\"a\" \"b\" \"c\")\n"

#. type: group
#: original_texis/functions.texi:901
#, no-wrap
msgid ""
";; @r{Call each function in @code{my-hooks}.}\n"
"(mapcar 'funcall my-hooks)\n"
msgstr ""
";; @r{@code{my-hooks}内の各関数を呼び出す}\n"
"(mapcar 'funcall my-hooks)\n"

#. type: group
#: original_texis/functions.texi:914
#, no-wrap
msgid ""
"(defun mapcar* (function &rest args)\n"
"  \"Apply FUNCTION to successive cars of all ARGS.\n"
"Return the list of results.\"\n"
"  ;; @r{If no list is exhausted,}\n"
"  (if (not (memq nil args))\n"
"      ;; @r{apply function to @sc{car}s.}\n"
"      (cons (apply function (mapcar 'car args))\n"
"            (apply 'mapcar* function\n"
"                   ;; @r{Recurse for rest of elements.}\n"
"                   (mapcar 'cdr args)))))\n"
msgstr ""
"(defun mapcar* (function &rest args)\n"
"  \"Apply FUNCTION to successive cars of all ARGS.\n"
"Return the list of results.\"\n"
"  ;; @r{リストが消費されていなければ}\n"
"  (if (not (memq nil args))\n"
"      ;; @r{@sc{car}に関数を適用する}\n"
"      (cons (apply function (mapcar 'car args))\n"
"            (apply 'mapcar* function\n"
"                   ;; @r{残りの要素のための再帰}\n"
"                   (mapcar 'cdr args)))))\n"

#. type: group
#: original_texis/functions.texi:919
#, no-wrap
msgid ""
"(mapcar* 'cons '(a b c) '(1 2 3 4))\n"
"     @result{} ((a . 1) (b . 2) (c . 3))\n"
msgstr ""
"(mapcar* 'cons '(a b c) '(1 2 3 4))\n"
"     @result{} ((a . 1) (b . 2) (c . 3))\n"

#. type: defun
#: original_texis/functions.texi:923
#, no-wrap
msgid "mapcan function sequence"
msgstr "mapcan function sequence"

#. type: defun
#: original_texis/functions.texi:930
msgid "This function applies @var{function} to each element of @var{sequence}, like @code{mapcar}, but instead of collecting the results into a list, it returns a single list with all the elements of the results (which must be lists), by altering the results (using @code{nconc}; @pxref{Rearrangement}).  Like with @code{mapcar}, @var{sequence} can be of any type except a char-table."
msgstr "この関数は@code{mapcar}のように@var{sequence}の各要素に@var{function}を適用するが、結果をリストに収集するかわりに結果を変更(@code{nconc}を使用。@pxref{Rearrangement}を参照)して結果のすべての要素を単一のリストでリターンする。@code{mapcar}と同様に@var{sequence}には文字テーブルを除く任意のタイプのシーケンスを指定できる。"

#. type: group
#: original_texis/functions.texi:939
#, no-wrap
msgid ""
";; @r{Contrast this:}\n"
"(mapcar 'list '(a b c d))\n"
"     @result{} ((a) (b) (c) (d))\n"
";; @r{with this:}\n"
"(mapcan 'list '(a b c d))\n"
"     @result{} (a b c d)\n"
msgstr ""
";; @r{以下と:}\n"
"(mapcar 'list '(a b c d))\n"
"     @result{} ((a) (b) (c) (d))\n"
";; @r{以下を比較してみよ:}\n"
"(mapcan 'list '(a b c d))\n"
"     @result{} (a b c d)\n"

#. type: defun
#: original_texis/functions.texi:943
#, no-wrap
msgid "mapc function sequence"
msgstr "mapc function sequence"

#. type: defun
#: original_texis/functions.texi:947
msgid "@code{mapc} is like @code{mapcar} except that @var{function} is used for side-effects only---the values it returns are ignored, not collected into a list.  @code{mapc} always returns @var{sequence}."
msgstr "@code{mapc}は@code{mapcar}と似ているが、@var{function}は副作用のためだけに使用される --- つまり@var{function}がリターンする値は無視されてリストに収集されない。@code{mapc}は常に@var{sequence}をリターンする。"

#. type: defun
#: original_texis/functions.texi:949
#, no-wrap
msgid "mapconcat function sequence separator"
msgstr "mapconcat function sequence separator"

#. type: defun
#: original_texis/functions.texi:957
msgid "@code{mapconcat} applies @var{function} to each element of @var{sequence}; the results, which must be sequences of characters (strings, vectors, or lists), are concatenated into a single string return value.  Between each pair of result sequences, @code{mapconcat} inserts the characters from @var{separator}, which also must be a string, or a vector or list of characters.  @xref{Sequences Arrays Vectors}."
msgstr "@code{mapconcat}は@var{sequence}のそれぞれの要素に@var{function}を適用する。結果は文字のシーケンス(文字列、ベクター、リスト)でなければならず、単一の文字列に結合されてリターン値となる。@code{mapconcat}は結果シーケーンスの各ペアの間に@var{separator}の文字を挿入する。これも文字列、または文字のベクターかリストでなければならない。@ref{Sequences Arrays Vectors}を参照のこと。"

#. type: defun
#: original_texis/functions.texi:963
msgid "The argument @var{function} must be a function that can take one argument and returns a sequence of characters: a string, a vector, or a list.  The argument @var{sequence} can be any kind of sequence except a char-table; that is, a list, a vector, a bool-vector, or a string."
msgstr "引数@var{function}は1つの引数を受け取り文字のシーケンス、すなわち文字列、ベクター、リストのいずれかをリターンする。引数@var{sequence}は文字テーブル以外の任意の種類のシーケンス、すなわちリスト、ベクター、ブールベクター、または文字列を指定できる。"

#. type: group
#: original_texis/functions.texi:970
#, no-wrap
msgid ""
"(mapconcat 'symbol-name\n"
"           '(The cat in the hat)\n"
"           \" \")\n"
"     @result{} \"The cat in the hat\"\n"
msgstr ""
"(mapconcat 'symbol-name\n"
"           '(The cat in the hat)\n"
"           \" \")\n"
"     @result{} \"The cat in the hat\"\n"

#. type: group
#: original_texis/functions.texi:977
#, fuzzy, no-wrap
#| msgid ""
#| "(mapconcat (function (lambda (x) (format \"%c\" (1+ x))))\n"
#| "           \"HAL-8000\"\n"
#| "           \"\")\n"
#| "     @result{} \"IBM.9111\"\n"
msgid ""
"(mapconcat (lambda (x) (format \"%c\" (1+ x)))\n"
"           \"HAL-8000\"\n"
"           \"\")\n"
"     @result{} \"IBM.9111\"\n"
msgstr ""
"(mapconcat (function (lambda (x) (format \"%c\" (1+ x))))\n"
"           \"HAL-8000\"\n"
"           \"\")\n"
"     @result{} \"IBM.9111\"\n"

#. type: cindex
#: original_texis/functions.texi:983
#, no-wrap
msgid "anonymous function"
msgstr "anonymous function"

#. type: Plain text
#: original_texis/functions.texi:994
msgid "Although functions are usually defined with @code{defun} and given names at the same time, it is sometimes convenient to use an explicit lambda expression---an @dfn{anonymous function}.  Anonymous functions are valid wherever function names are.  They are often assigned as variable values, or as arguments to functions; for instance, you might pass one as the @var{function} argument to @code{mapcar}, which applies that function to each element of a list (@pxref{Mapping Functions}).  @xref{describe-symbols example}, for a realistic example of this."
msgstr "関数は通常は@code{defun}により定義されて、同時に名前が与えられますが、明示的にラムダ式を使う --- @dfn{無名関数(anonymous function)}のほうが便利なときもあります。無名関数は名前つき関数が有効な場所ならどこでも有効です。無名関数は変数や関数の引数に割り当てられることがよくあります。たとえばある関数をリストの各要素に適用する@code{mapcar}の@var{function}引数に渡すかもしれません(@ref{Mapping Functions}を参照)。現実的な例は@ref{describe-symbols example}を参照してください。"

#. type: Plain text
#: original_texis/functions.texi:999
msgid "When defining a lambda expression that is to be used as an anonymous function, you can in principle use any method to construct the list.  But typically you should use the @code{lambda} macro, or the @code{function} special form, or the @code{#'} read syntax:"
msgstr "無名関数として使用するためのラムダ式を定義するとき、原則的にはリストを構築する任意の手法を使用できます。しかし通常はマクロ@code{lambda}、スペシャルフォーム@code{function}、または入力構文@code{#'}を使用するべきです。"

#. type: defmac
#: original_texis/functions.texi:1000
#, no-wrap
msgid "lambda args [doc] [interactive] body@dots{}"
msgstr "lambda args [doc] [interactive] body@dots{}"

#. type: defmac
#: original_texis/functions.texi:1004
msgid "This macro returns an anonymous function with argument list @var{args}, documentation string @var{doc} (if any), interactive spec @var{interactive} (if any), and body forms given by @var{body}."
msgstr "このマクロは引数リスト@var{args}、(もしあれば)ドキュメント文字列@var{doc}、(もしあれば)インタラクティブ指定@var{interactive}、および@var{body}で与えられるbodyフォームをもつ無名関数をリターンする。"

#. type: defmac
#: original_texis/functions.texi:1008
msgid "Under dynamic binding, this macro effectively makes @code{lambda} forms self-quoting: evaluating a form whose @sc{car} is @code{lambda} yields the form itself:"
msgstr "ダイナミックバインディングの下では、このマクロは@code{lambda}フォームを効果的に``自己クォート(self-quoting)''する。つまり@sc{car}が@code{lambda}であるようなフォームはフォーム自身を得る。"

#. type: example
#: original_texis/functions.texi:1012
#, no-wrap
msgid ""
"(lambda (x) (* x x))\n"
"     @result{} (lambda (x) (* x x))\n"
msgstr ""
"(lambda (x) (* x x))\n"
"     @result{} (lambda (x) (* x x))\n"

#. type: defmac
#: original_texis/functions.texi:1016
msgid "Note that when evaluating under lexical binding the result is a closure object (@pxref{Closures})."
msgstr "レキシカルバインディングの下で評価した際には、結果はクロージャオブジェクトになることに注意(@ref{Closures}を参照)。"

#. type: defmac
#: original_texis/functions.texi:1020
msgid "The @code{lambda} form has one other effect: it tells the Emacs evaluator and byte-compiler that its argument is a function, by using @code{function} as a subroutine (see below)."
msgstr "@code{lambda}フォームは別の1つの効果をもつ。このマクロは@code{function}(以下参照)をサブルーチンとして使用することにより、Emacs評価機能(Emacs evaluator)とバイトコンパイラーに、その引数が関数であることを告げる。"

#. type: defspec
#: original_texis/functions.texi:1022
#, no-wrap
msgid "function function-object"
msgstr "function function-object"

#. type: cindex
#: original_texis/functions.texi:1023
#, no-wrap
msgid "function quoting"
msgstr "function quoting"

#. type: defspec
#: original_texis/functions.texi:1030
msgid "This special form returns @var{function-object} without evaluating it.  In this, it is similar to @code{quote} (@pxref{Quoting}).  But unlike @code{quote}, it also serves as a note to the Emacs evaluator and byte-compiler that @var{function-object} is intended to be used as a function.  Assuming @var{function-object} is a valid lambda expression, this has two effects:"
msgstr "このスペシャルフォームは評価を行わずに@var{function-object}をリターンする。この点では@code{quote}(@ref{Quoting}を参照)と似ている。しかし@code{quote}とは異なり、Emacs評価機能とバイトコンパイラーに、これを関数として使用する意図を告げる役割をもつ。@var{function-object}が有効なラムダ式と仮定すると、これは２つの効果をもつ:"

#. type: itemize
#: original_texis/functions.texi:1035
msgid "When the code is byte-compiled, @var{function-object} is compiled into a byte-code function object (@pxref{Byte Compilation})."
msgstr "そのコードがバイトコンパイルされているとき、@var{function-object}はバイトコード関数オブジェクトにコンパイルされる(@ref{Byte Compilation}を参照)。"

#. type: itemize
#: original_texis/functions.texi:1039
msgid "When lexical binding is enabled, @var{function-object} is converted into a closure.  @xref{Closures}."
msgstr "レキシカルバインドが有効なら@var{function-object}はクロージャーに変換される。@ref{Closures}を参照のこと。"

#. type: defspec
#: original_texis/functions.texi:1044
msgid "When @var{function-object} is a symbol and the code is byte compiled, the byte-compiler will warn if that function is not defined or might not be known at run time."
msgstr ""

#. type: cindex
#: original_texis/functions.texi:1046
#, no-wrap
msgid "@samp{#'} syntax"
msgstr "@samp{#'} syntax"

#. type: Plain text
#: original_texis/functions.texi:1049
msgid "The read syntax @code{#'} is a short-hand for using @code{function}.  The following forms are all equivalent:"
msgstr "入力構文@code{#'}は@code{function}の使用の略記です。以下のフォームは等価です:"

#. type: example
#: original_texis/functions.texi:1054
#, no-wrap
msgid ""
"(lambda (x) (* x x))\n"
"(function (lambda (x) (* x x)))\n"
"#'(lambda (x) (* x x))\n"
msgstr ""
"(lambda (x) (* x x))\n"
"(function (lambda (x) (* x x)))\n"
"#'(lambda (x) (* x x))\n"

#. type: Plain text
#: original_texis/functions.texi:1060
msgid "In the following example, we define a @code{change-property} function that takes a function as its third argument, followed by a @code{double-property} function that makes use of @code{change-property} by passing it an anonymous function:"
msgstr "以下の例では3つ目の引数に関数をとる@code{change-property}関数を定義して、その後の@code{change-property}で無名関数を渡してこれを使用しています:"

#. type: group
#: original_texis/functions.texi:1066
#, no-wrap
msgid ""
"(defun change-property (symbol prop function)\n"
"  (let ((value (get symbol prop)))\n"
"    (put symbol prop (funcall function value))))\n"
msgstr ""
"(defun change-property (symbol prop function)\n"
"  (let ((value (get symbol prop)))\n"
"    (put symbol prop (funcall function value))))\n"

#. type: group
#: original_texis/functions.texi:1071
#, no-wrap
msgid ""
"(defun double-property (symbol prop)\n"
"  (change-property symbol prop (lambda (x) (* 2 x))))\n"
msgstr ""
"(defun double-property (symbol prop)\n"
"  (change-property symbol prop (lambda (x) (* 2 x))))\n"

#. type: Plain text
#: original_texis/functions.texi:1076
msgid "Note that we do not quote the @code{lambda} form."
msgstr "@code{lambda}フォームをクォートしていないことに注意してください。"

#. type: Plain text
#: original_texis/functions.texi:1080
msgid "If you compile the above code, the anonymous function is also compiled.  This would not happen if, say, you had constructed the anonymous function by quoting it as a list:"
msgstr " 上記のコードをコンパイルすると無名関数もコンパイルされます。リストをクォートすることにより無名関数を構築した場合にはコンパイルはされません。"

#. type: group
#: original_texis/functions.texi:1086
#, no-wrap
msgid ""
"(defun double-property (symbol prop)\n"
"  (change-property symbol prop '(lambda (x) (* 2 x))))\n"
msgstr ""
"(defun double-property (symbol prop)\n"
"  (change-property symbol prop '(lambda (x) (* 2 x))))\n"

#. type: Plain text
#: original_texis/functions.texi:1094
msgid "In that case, the anonymous function is kept as a lambda expression in the compiled code.  The byte-compiler cannot assume this list is a function, even though it looks like one, since it does not know that @code{change-property} intends to use it as a function."
msgstr "この場合、無名関数はコンパイルされたコード内のラムダ式に保持されます。バイトコンパイラーは@code{change-property}が関数としての使用を意図していることを知ることができないので、たとえこの関数が関数のように見えるとしても、このリストが関数であると決め込むことができません。"

#. type: cindex
#: original_texis/functions.texi:1097
#, no-wrap
msgid "generic functions"
msgstr "generic functions"

#. type: cindex
#: original_texis/functions.texi:1098
#, no-wrap
msgid "polymorphism"
msgstr "polymorphism"

#. type: Plain text
#: original_texis/functions.texi:1108
msgid "Functions defined using @code{defun} have a hard-coded set of assumptions about the types and expected values of their arguments.  For example, a function that was designed to handle values of its argument that are either numbers or lists of numbers will fail or signal an error if called with a value of any other type, such as a vector or a string.  This happens because the implementation of the function is not prepared to deal with types other than those assumed during the design."
msgstr "@code{defun}を使用して定義された関数は、その引数の型と期待する値に関して、ハードコードされた一連の仮定をもちます。たとえば数字か数字のリストを引数値として処理するようにデザインされた関数は、ベクターや文字列のような他の型の値で呼び出されると失敗したりエラーをシグナルするでしょう。これはその関数実装が、デザイン時に想定した以外の型に対応しないために発生します。"

#. type: Plain text
#: original_texis/functions.texi:1114
msgid "By contrast, object-oriented programs use @dfn{polymorphic functions}: a set of specialized functions having the same name, each one of which was written for a certain specific set of argument types.  Which of the functions is actually called is decided at run time based on the types of the actual arguments."
msgstr "対照的に@dfn{多相型関数(polymorphic functions)}を使用したオブジェクト指向プログラムでは、同一の名前をもつ一連の特化した関数のそれぞれが、特定の引数型セットにたいして記述されます。どの関数が実際に呼び出されるかは、実際の引数の型にもとづいて実行時に決定されます。"

#. type: cindex
#: original_texis/functions.texi:1115
#, no-wrap
msgid "CLOS"
msgstr "CLOS"

#. type: Plain text
#: original_texis/functions.texi:1122
msgid "Emacs provides support for polymorphism.  Like other Lisp environments, notably Common Lisp and its Common Lisp Object System (@acronym{CLOS}), this support is based on @dfn{generic functions}.  The Emacs generic functions closely follow @acronym{CLOS}, including use of similar names, so if you have experience with @acronym{CLOS}, the rest of this section will sound very familiar."
msgstr "Emacsはポリモーフィズム(polymorphism)にたいするサポートを提供します。他のLisp環境、特にCommon LispとCommon Lispオブジェクトシステム(@acronym{CLOS})と同じように、このサポートは@dfn{ジェネリック関数(generic functions)}を基礎としています。Emacsのジェネリック関数は同一名の使用を含む@acronym{CLOS}に密接にしたがっているので、@acronym{CLOS}の経験があればこのセクションの残りの部分は非常に身近に感じるでしょう。"

#. type: Plain text
#: original_texis/functions.texi:1133
msgid "A generic function specifies an abstract operation, by defining its name and list of arguments, but (usually) no implementation.  The actual implementation for several specific classes of arguments is provided by @dfn{methods}, which should be defined separately.  Each method that implements a generic function has the same name as the generic function, but the method's definition indicates what kinds of arguments it can handle by @dfn{specializing} the arguments defined by the generic function.  These @dfn{argument specializers} can be more or less specific; for example, a @code{string} type is more specific than a more general type, such as @code{sequence}."
msgstr "ジェネリック関数は、その名前と引数のリストを指定して、(通常は)実装されていない抽象操作(abstract operation)を指定します。引数のいくつかの固有クラスにたいする実際の実装は@dfn{メソッド(methods)}により提供され、これは個別に定義されるべきです。ジェネリック関数を実装するそれぞれのメソッドはジェネリック関数としてとして同じ名前をもちますが、そのジェネリック関数で定義された引数の@dfn{スペシャライジング(specializing)}により、メソッドの定義はどの種類の引数を処理可能かを示します。これらの@dfn{引数スペシャライザー(argument specializers)}は多少の差はあれ特化したものにできます。たとえば@code{string}型は@code{sequence}のようなより一般的な型より特化した型です。"

#. type: Plain text
#: original_texis/functions.texi:1137
msgid "Note that, unlike in message-based OO languages, such as C@t{++} and Simula, methods that implement generic functions don't belong to a class, they belong to the generic function they implement."
msgstr "C@t{++}やSimulaのようなメッセージベースのOO言語と異なり、ジェネリック関数を実装するメソッドはクラスに属さずに、それらが実装するジェネリック関数に属することに注意してください。"

#. type: Plain text
#: original_texis/functions.texi:1145
msgid "When a generic function is invoked, it selects the applicable methods by comparing the actual arguments passed by the caller with the argument specializers of each method.  A method is applicable if the actual arguments of the call are compatible with the method's specializers.  If more than one method is applicable, they are combined using certain rules, described below, and the combination then handles the call."
msgstr "ジェネリック関数が呼び出されると、呼び出し側に渡された実際の引数と各メソッドの引数スペシャライザーを比較することにより、適用可能なメソッドを呼び出します。その呼び出しの実際の引数がメソッドのスペシャライザーと互換性があれば、そのメソッドが適用可能です。複数のメソッドが適用可能ならば、それらは以下で説明する特定のルールにより合成されて、その組み合わせが呼び出しを処理します。"

#. type: defmac
#: original_texis/functions.texi:1146
#, no-wrap
msgid "cl-defgeneric name arguments [documentation] [options-and-methods@dots{}] &rest body"
msgstr "cl-defgeneric name arguments [documentation] [options-and-methods@dots{}] &rest body"

#. type: defmac
#: original_texis/functions.texi:1153
msgid "This macro defines a generic function with the specified @var{name} and @var{arguments}.  If @var{body} is present, it provides the default implementation.  If @var{documentation} is present (it should always be), it specifies the documentation string for the generic function, in the form @code{(:documentation @var{docstring})}.  The optional @var{options-and-methods} can be one of the following forms:"
msgstr "このマクロは指定した@var{name}と@var{arguments}でジェネリック関数を定義する。@var{body}が与えられたなら、それは実装のデフォルトを与える。(常に与えられるべきであるが)@var{documentation}が与えられたなら、それは@code{(:documentation @var{docstring})}の形式でそのジェネリック関数のドキュメント文字列を指定する。オプションの@var{options-and-methods}は以下のフォームのいずれかを指定できる:"

#. type: item
#: original_texis/functions.texi:1155
#, no-wrap
msgid "(declare @var{declarations})"
msgstr "(declare @var{declarations})"

#. type: table
#: original_texis/functions.texi:1157
msgid "A declare form, as described in @ref{Declare Form}."
msgstr "@ref{Declare Form}で説明するようなdeclareフォーム。"

#. type: item
#: original_texis/functions.texi:1157
#, no-wrap
msgid "(:argument-precedence-order &rest @var{args})"
msgstr "(:argument-precedence-order &rest @var{args})"

#. type: table
#: original_texis/functions.texi:1164
msgid "This form affects the sorting order for combining applicable methods.  Normally, when two methods are compared during combination, method arguments are examined left to right, and the first method whose argument specializer is more specific will come before the other one.  The order defined by this form overrides that, and the arguments are examined according to their order in this form, and not left to right."
msgstr "このフォームは適用可能なメソッド合成にたいするソート順に影響を与える。合成において2つのメソッドを比較する際、メソッドの引数は通常は左から右に試験されて、引数スペシャライザーがより特化した最初のメソッドが他のメソッドより前になる。このフォームで定義された順序はそれをオーバーライドして、左から右ではなくこのフォームの順に応じて試験される。"

#. type: item
#: original_texis/functions.texi:1164
#, no-wrap
msgid "(:method [@var{qualifiers}@dots{}] args &rest body)"
msgstr "(:method [@var{qualifiers}@dots{}] args &rest body)"

#. type: table
#: original_texis/functions.texi:1166
msgid "This form defines a method like @code{cl-defmethod} does."
msgstr "このメソッドは@code{cl-defmethod}が行うようなメソッドを定義する。"

#. type: defmac
#: original_texis/functions.texi:1169
#, fuzzy, no-wrap
#| msgid "cl-defmethod name [qualifier] arguments &rest [docstring] body"
msgid "cl-defmethod name [qualifier] arguments [&context (expr spec)@dots{}] &rest [docstring] body"
msgstr "cl-defmethod name [qualifier] arguments &rest [docstring] body"

#. type: defmac
#: original_texis/functions.texi:1179
msgid "This macro defines a particular implementation for the generic function called @var{name}.  The implementation code is given by @var{body}.  If present, @var{docstring} is the documentation string for the method.  The @var{arguments} list, which must be identical in all the methods that implement a generic function, and must match the argument list of that function, provides argument specializers of the form @code{(@var{arg} @var{spec})}, where @var{arg} is the argument name as specified in the @code{cl-defgeneric} call, and @var{spec} is one of the following specializer forms:"
msgstr "このマクロは@var{name}と呼ばれるジェネリック関数の、特定の実装を定義する。実装コードは@var{body}で与えられる。もし与えられたら@var{docstring}はそのメソッドのドキュメント文字列である。リスト@var{arguments}はジェネリック関数を実装するすべてのメソッドで等しく、その関数の引数リストとマッチしなければならず、@code{(@var{arg} @var{spec})}という形式の引数スペシャライザーを提供する。ここで@var{arg}は@code{cl-defgeneric}呼び出しで指定された引数名、@var{spec}は以下のスペシャライザーフォームのいずれかであること:"

#. type: var{#1}
#: original_texis/functions.texi:1181
#, no-wrap
msgid "type"
msgstr "type"

#. type: table
#: original_texis/functions.texi:1184
msgid "This specializer requires the argument to be of the given @var{type}, one of the types from the type hierarchy described below."
msgstr "このスペシャライザーは、引数が@var{type}のいずれかであることを要求する。@var{type}は以下で説明する型ヒエラルキーのいずれかの型である。"

#. type: item
#: original_texis/functions.texi:1184
#, no-wrap
msgid "(eql @var{object})"
msgstr "(eql @var{object})"

#. type: table
#: original_texis/functions.texi:1187
msgid "This specializer requires the argument be @code{eql} to the given @var{object}."
msgstr "このスペシャライザーは、引数が@var{object}と@code{eql}であることを要求する。"

#. type: item
#: original_texis/functions.texi:1187
#, no-wrap
msgid "(head @var{object})"
msgstr "(head @var{object})"

#. type: table
#: original_texis/functions.texi:1190
msgid "The argument must be a cons cell whose @code{car} is @code{eql} to @var{object}."
msgstr "引数は@code{car}が@var{object}と@code{eql}であるようなコンスセルでなければならない。"

#. type: var{#1}
#: original_texis/functions.texi:1190
#, no-wrap
msgid "struct-type"
msgstr "struct-type"

#. type: table
#: original_texis/functions.texi:1194
msgid "The argument must be an instance of a class named @var{struct-type} defined with @code{cl-defstruct} (@pxref{Structures,,, cl, Common Lisp Extensions for GNU Emacs Lisp}), or of one of its child classes."
msgstr "引数は@code{cl-defstruct} (@ref{Structures,,, cl, Common Lisp Extensions for GNU Emacs Lisp}を参照)で定義された@var{struct-type}という名前のクラス、またはその子クラスのインスタンスでなければならない。"

#. type: defmac
#: original_texis/functions.texi:1210
msgid "Method definitions can make use of a new argument-list keyword, @code{&context}, which introduces extra specializers that test the environment at the time the method is run.  This keyword should appear after the list of required arguments, but before any @code{&rest} or @code{&optional} keywords.  The @code{&context} specializers look much like regular argument specializers---(@var{expr} @var{spec})---except that @var{expr} is an expression to be evaluated in the current context, and the @var{spec} is a value to compare against.  For example, @code{&context (overwrite-mode (eql t))} will make the method applicable only when @code{overwrite-mode} is turned on.  The @code{&context} keyword can be followed by any number of context specializers.  Because the context specializers are not part of the generic function's argument signature, they may be omitted in methods that don't require them."
msgstr ""

#. type: defmac
#: original_texis/functions.texi:1216
msgid "The type specializer, @code{(@var{arg} @var{type})}, can specify one of the @dfn{system types} in the following list.  When a parent type is specified, an argument whose type is any of its more specific child types, as well as grand-children, grand-grand-children, etc. will also be compatible."
msgstr "型スペシャライザー@code{(@var{arg} @var{type})}は以下のリストの@dfn{システム型(system types)}のいずれかを指定できる。親の型が指定されたときは、型がより特化した子型、孫型、曾孫型、...のいずれかであるような任意の引数も互換となるだろう。"

#. type: item
#: original_texis/functions.texi:1218
#, no-wrap
msgid "integer"
msgstr "integer"

#. type: table
#: original_texis/functions.texi:1220 original_texis/functions.texi:1236
msgid "Parent type: @code{number}."
msgstr "親型: @code{number}。"

#. type: item
#: original_texis/functions.texi:1220
#, no-wrap
msgid "number"
msgstr "number"

#. type: item
#: original_texis/functions.texi:1221
#, no-wrap
msgid "null"
msgstr "null"

#. type: table
#: original_texis/functions.texi:1223
msgid "Parent type: @code{symbol}"
msgstr "親型: @code{symbol}。"

#. type: item
#: original_texis/functions.texi:1223
#, no-wrap
msgid "symbol"
msgstr "symbol"

#. type: item
#: original_texis/functions.texi:1224
#, no-wrap
msgid "string"
msgstr "string"

#. type: table
#: original_texis/functions.texi:1226 original_texis/functions.texi:1244
#: original_texis/functions.texi:1246 original_texis/functions.texi:1248
msgid "Parent type: @code{array}."
msgstr "親型: @code{array}。"

#. type: item
#: original_texis/functions.texi:1226
#, no-wrap
msgid "array"
msgstr "array"

#. type: table
#: original_texis/functions.texi:1228 original_texis/functions.texi:1232
msgid "Parent type: @code{sequence}."
msgstr "親型: @code{sequence}。"

#. type: item
#: original_texis/functions.texi:1228
#, no-wrap
msgid "cons"
msgstr "cons"

#. type: table
#: original_texis/functions.texi:1230
msgid "Parent type: @code{list}."
msgstr "親型: @code{list}。"

#. type: item
#: original_texis/functions.texi:1230
#, no-wrap
msgid "list"
msgstr "list"

#. type: item
#: original_texis/functions.texi:1232
#, no-wrap
msgid "marker"
msgstr "marker"

#. type: item
#: original_texis/functions.texi:1233
#, no-wrap
msgid "overlay"
msgstr "overlay"

#. type: item
#: original_texis/functions.texi:1234
#, no-wrap
msgid "float"
msgstr "float"

#. type: item
#: original_texis/functions.texi:1236
#, no-wrap
msgid "window-configuration"
msgstr "window-configuration"

#. type: item
#: original_texis/functions.texi:1237
#, no-wrap
msgid "process"
msgstr "process"

#. type: item
#: original_texis/functions.texi:1238
#, no-wrap
msgid "window"
msgstr "window"

#. type: item
#: original_texis/functions.texi:1240
#, no-wrap
msgid "compiled-function"
msgstr "compiled-function"

#. type: item
#: original_texis/functions.texi:1241
#, no-wrap
msgid "buffer"
msgstr "buffer"

#. type: item
#: original_texis/functions.texi:1242
#, no-wrap
msgid "char-table"
msgstr "char-table"

#. type: item
#: original_texis/functions.texi:1244
#, no-wrap
msgid "bool-vector"
msgstr "bool-vector"

#. type: item
#: original_texis/functions.texi:1246
#, no-wrap
msgid "vector"
msgstr "vector"

#. type: item
#: original_texis/functions.texi:1248
#, no-wrap
msgid "frame"
msgstr "frame"

#. type: item
#: original_texis/functions.texi:1249
#, no-wrap
msgid "hash-table"
msgstr "hash-table"

#. type: item
#: original_texis/functions.texi:1250
#, no-wrap
msgid "font-spec"
msgstr "font-spec"

#. type: item
#: original_texis/functions.texi:1251
#, no-wrap
msgid "font-entity"
msgstr "font-entity"

#. type: item
#: original_texis/functions.texi:1252
#, no-wrap
msgid "font-object"
msgstr "font-object"

#. type: defmac
#: original_texis/functions.texi:1261
msgid "The optional @var{qualifier} allows combining several applicable methods.  If it is not present, the defined method is a @dfn{primary} method, responsible for providing the primary implementation of the generic function for the specialized arguments.  You can also define @dfn{auxiliary methods}, by using one of the following values as @var{qualifier}:"
msgstr "オプションの@var{qualifier}は複数の適用可能なメソッドの合成を許容する。与えられなければ定義されるメソッドは@dfn{primary(主)}メソッドとなり、スペシャライズされた引数にたいする主要な実装の提供に責任を有する。@var{qualifier}として以下の値のいずれかを使用して@dfn{auxiliary(副)}メソッドも定義できる:"

#. type: item
#: original_texis/functions.texi:1263 original_texis/functions.texi:1790
#, no-wrap
msgid ":before"
msgstr ":before"

#. type: table
#: original_texis/functions.texi:1267
msgid "This auxiliary method will run before the primary method.  More accurately, all the @code{:before} methods will run before the primary, in the most-specific-first order."
msgstr "このauxiliaryメソッドはprimaryメソッドの前に実行される。より正確にはすべての@code{:before}メソッドは、より特化したメソッドが最初になる順で、primaryメソッドの前に実行される。"

#. type: item
#: original_texis/functions.texi:1267 original_texis/functions.texi:1802
#, no-wrap
msgid ":after"
msgstr ":after"

#. type: table
#: original_texis/functions.texi:1271
msgid "This auxiliary method will run after the primary method.  More accurately, all such methods will run after the primary, in the most-specific-last order."
msgstr "このauxiliaryメソッドはprimaryメソッドの後に実行される。より正確にはすべてのこの類のメソッドは、より特化したメソッドが最後になる順で、primaryメソッドの後に実行される。"

#. type: item
#: original_texis/functions.texi:1271 original_texis/functions.texi:1818
#, no-wrap
msgid ":around"
msgstr ":around"

#. type: table
#: original_texis/functions.texi:1276
msgid "This auxiliary method will run @emph{instead} of the primary method.  The most specific of such methods will be run before any other method.  Such methods normally use @code{cl-call-next-method}, described below, to invoke the other auxiliary or primary methods."
msgstr "このauxiliaryメソッドはprimaryメソッドの@emph{代替え}として実行される。この類のメソッドでもっとも特化したものが他のメソッドより前に実行される。このようなメソッドは他のauxiliaryメソッドやprimaryメソッドを呼び出すために、通常は以下で説明する@code{cl-call-next-method}を使用する。"

#. type: item
#: original_texis/functions.texi:1276
#, no-wrap
msgid ":extra @var{string}"
msgstr ":extra @var{string}"

#. type: table
#: original_texis/functions.texi:1279
msgid "This allows you to add more methods, distinguished by @var{string}, for the same specializers and qualifiers."
msgstr "これにより同一のspecializerとqualifierにたいして、@var{string}で区別されるメソッドを追加できる。"

#. type: defmac
#: original_texis/functions.texi:1287
msgid "Functions defined using @code{cl-defmethod} cannot be made interactive, i.e.@: commands (@pxref{Defining Commands}), by adding the @code{interactive} form to them.  If you need a polymorphic command, we recommend defining a normal command that calls a polymorphic function defined via @code{cl-defgeneric} and @code{cl-defmethod}."
msgstr "@code{cl-defmethod}を使用して定義した関数をインタラクティブにすることはできない。つまり@code{interactive}フォームを追加してコマンドにすることはできない(@ref{Defining Commands}を参照)。多相型コマンド(polymorphic command)が必要なら、@code{cl-defgeneric}と@code{cl-defmethod}を通じて定義した多相型関数(polymorphic function)を呼び出す通常のコマンドを定義することを推奨する。"

#. type: cindex
#: original_texis/functions.texi:1289
#, no-wrap
msgid "dispatch of methods for generic function"
msgstr "dispatch of methods for generic function"

#. type: cindex
#: original_texis/functions.texi:1290
#, no-wrap
msgid "multiple-dispatch methods"
msgstr "multiple-dispatch methods"

#. type: Plain text
#: original_texis/functions.texi:1301
msgid "Each time a generic function is called, it builds the @dfn{effective method} which will handle this invocation by combining the applicable methods defined for the function.  The process of finding the applicable methods and producing the effective method is called @dfn{dispatch}.  The applicable methods are those all of whose specializers are compatible with the actual arguments of the call.  Since all of the arguments must be compatible with the specializers, they all determine whether a method is applicable.  Methods that explicitly specialize more than one argument are called @dfn{multiple-dispatch methods}."
msgstr "ジェネリック関数が呼び出されると、毎回その関数にたいして定義された適用可能なメソッドを合成することによってその呼び出しを処理する@dfn{effectiveメソッド(effective method)}を構築します。適用可能なメソッドを探してeffectiveメソッドを生成するプロセスは@dfn{dispatch}と呼ばれます。その呼び出しの実際の引数と互換性があるスペシャライザーをもつすべてのメソッドが、互換性のあるメソッドです。すべての引数がスペシャライザーと互換でなければならないので、それらはすべてメソッドが適用可能かどうか判定します。複数の引数に明示的に特化したメソッドを@dfn{multiple-dispatchメソッド(multiple-dispatch methods)}と呼びます。"

#. type: Plain text
#: original_texis/functions.texi:1314
msgid "The applicable methods are sorted into the order in which they will be combined.  The method whose left-most argument specializer is the most specific one will come first in the order.  (Specifying @code{:argument-precedence-order} as part of @code{cl-defmethod} overrides that, as described above.)  If the method body calls @code{cl-call-next-method}, the next most-specific method will run.  If there are applicable @code{:around} methods, the most-specific of them will run first; it should call @code{cl-call-next-method} to run any of the less specific @code{:around} methods.  Next, the @code{:before} methods run in the order of their specificity, followed by the primary method, and lastly the @code{:after} methods in the reverse order of their specificity."
msgstr "適用可能なメソッドはそれらが合成される順にソートされます。最左の引数スペシャライザーがもっとも特化したものであるようなメソッドが、順序の最初になります(上述したように@code{cl-defmethod}の一部として@code{:argument-precedence-order}を指定することによりこれをオーバーライドできる)。そのメソッドのbodyが@code{cl-call-next-method}を呼び出すと、もっとも特化した次のメソッドが実行されます。適用可能な@code{:around}メソッドがあれば、それらのうちもっとも特化したメソッドが実行されます。そのメソッドはより特化していない任意の@code{:around}メソッドを実行するために、@code{cl-call-next-method}を呼び出すべきです。次に@code{:before}メソッドがその特化した順に、その後にspecificityメソッドが実行されます。そして後に@code{:after}メソッドがその特化した順と逆順で実行されます。"

#. type: defun
#: original_texis/functions.texi:1315
#, no-wrap
msgid "cl-call-next-method &rest args"
msgstr "cl-call-next-method &rest args"

#. type: defun
#: original_texis/functions.texi:1322
msgid "When invoked from within the lexical body of a primary or an @code{:around} auxiliary method, call the next applicable method for the same generic function.  Normally, it is called with no arguments, which means to call the next applicable method with the same arguments that the calling method was invoked.  Otherwise, the specified arguments are used instead."
msgstr "primaryメソッドか@code{:around} auxiliaryメソッド内のレキシカルbody内で呼び出されると、同じジェネリック関数にたいして適用可能な次のメソッドを呼び出す。通常これは引数なしで呼び出され、これは次の適用可能なメソッドを呼び出すメソッドが、呼び出されたときと同じ引数で次のメソッドを呼び出すことを意味する。それ以外ならかわりに指定された引数が使用される。"

#. type: defun
#: original_texis/functions.texi:1324
#, no-wrap
msgid "cl-next-method-p"
msgstr "cl-next-method-p"

#. type: defun
#: original_texis/functions.texi:1328
msgid "This function, when called from within the lexical body of a primary or an @code{:around} auxiliary method, returns non-@code{nil} if there is a next method to call."
msgstr "primaryメソッドか@code{:around} auxiliaryメソッドのレキシカルbody内からこの関数を呼び出したときは、呼び出す次のメソッドが存在すれば非@code{nil}をリターンする。"

#. type: section
#: original_texis/functions.texi:1332
#, no-wrap
msgid "Accessing Function Cell Contents"
msgstr "Accessing Function Cell Contents"

#. type: Plain text
#: original_texis/functions.texi:1337
msgid "The @dfn{function definition} of a symbol is the object stored in the function cell of the symbol.  The functions described here access, test, and set the function cell of symbols."
msgstr "シンボルの@dfn{関数定義(function definition)}とは、そのシンボルの関数セルに格納されたオブジェクトのことです。ここではシンボルの関数セルへのアクセスやテスト、それをセットする関数を説明します。"

#. type: Plain text
#: original_texis/functions.texi:1340
msgid "See also the function @code{indirect-function}.  @xref{Definition of indirect-function}."
msgstr "@ref{Definition of indirect-function}の関数@code{indirect-function}も参照してください。"

#. type: defun
#: original_texis/functions.texi:1341
#, no-wrap
msgid "symbol-function symbol"
msgstr "symbol-function symbol"

#. type: kindex
#: original_texis/functions.texi:1342
#, no-wrap
msgid "void-function"
msgstr "void-function"

#. type: defun
#: original_texis/functions.texi:1345
msgid "This returns the object in the function cell of @var{symbol}.  It does not check that the returned object is a legitimate function."
msgstr "これは@var{symbol}の関数セル内のオブジェクトをリターンする。これはリターンされたオブジェクトが本物のの関数であるかチェックしない。"

#. type: defun
#: original_texis/functions.texi:1349
msgid "If the function cell is void, the return value is @code{nil}.  To distinguish between a function cell that is void and one set to @code{nil}, use @code{fboundp} (see below)."
msgstr "関数セルがvoidならリターン値は@code{nil}。関数セルがvoidのときと@code{nil}がセットされているときを区別するには@code{fboundp}(以下参照)を使用する。"

#. type: group
#: original_texis/functions.texi:1355
#, no-wrap
msgid ""
"(defun bar (n) (+ n 2))\n"
"(symbol-function 'bar)\n"
"     @result{} (lambda (n) (+ n 2))\n"
msgstr ""
"(defun bar (n) (+ n 2))\n"
"(symbol-function 'bar)\n"
"     @result{} (lambda (n) (+ n 2))\n"

#. type: group
#: original_texis/functions.texi:1359
#, no-wrap
msgid ""
"(fset 'baz 'bar)\n"
"     @result{} bar\n"
msgstr ""
"(fset 'baz 'bar)\n"
"     @result{} bar\n"

#. type: group
#: original_texis/functions.texi:1363
#, no-wrap
msgid ""
"(symbol-function 'baz)\n"
"     @result{} bar\n"
msgstr ""
"(symbol-function 'baz)\n"
"     @result{} bar\n"

#. type: cindex
#: original_texis/functions.texi:1367
#, no-wrap
msgid "void function cell"
msgstr "void function cell"

#. type: Plain text
#: original_texis/functions.texi:1372
msgid "If you have never given a symbol any function definition, we say that that symbol's function cell is @dfn{void}.  In other words, the function cell does not have any Lisp object in it.  If you try to call the symbol as a function, Emacs signals a @code{void-function} error."
msgstr "シンボルに何の関数定義も与えていなければ、そのシンボルの関数セルは@dfn{void}だと言います。言い換えると、その関数セルはどんなLispオブジェクトも保持しません。そのシンボルを関数として呼びだそうとすると、Emacsは@code{void-function}エラーをシグナルします。"

#. type: Plain text
#: original_texis/functions.texi:1378
msgid "Note that void is not the same as @code{nil} or the symbol @code{void}.  The symbols @code{nil} and @code{void} are Lisp objects, and can be stored into a function cell just as any other object can be (and they can be valid functions if you define them in turn with @code{defun}).  A void function cell contains no object whatsoever."
msgstr "voidは@code{nil}やシンボル@code{void}とは異なることに注意してください。シンボル@code{nil}と@code{void}はLispオブジェクトであり、他のオブジェクトと同じように関数セルに格納することができます(これらのシンボルは@code{defun}を使用して有効な関数になることができる)。voidであるような関数セルは、どのようなオブジェクトも含んでいません。"

#. type: Plain text
#: original_texis/functions.texi:1382
msgid "You can test the voidness of a symbol's function definition with @code{fboundp}.  After you have given a symbol a function definition, you can make it void once more using @code{fmakunbound}."
msgstr "@code{fboundp}を使用して任意のシンボルの関数定義がvoidかどうかテストすることができます。シンボルに関数定義を与えた後は、@code{fmakunbound}を使用して再びvoidにすることができます。"

#. type: defun
#: original_texis/functions.texi:1383
#, no-wrap
msgid "fboundp symbol"
msgstr "fboundp symbol"

#. type: defun
#: original_texis/functions.texi:1387
msgid "This function returns @code{t} if the symbol has an object in its function cell, @code{nil} otherwise.  It does not check that the object is a legitimate function."
msgstr "この関数はそのシンボルが関数セルにオブジェクトをもっていれば@code{t}、それ以外は@code{nil}をリターンする。これはそのオブジェクトが本物の関数であるかチェックしない。"

#. type: defun
#: original_texis/functions.texi:1389
#, no-wrap
msgid "fmakunbound symbol"
msgstr "fmakunbound symbol"

#. type: defun
#: original_texis/functions.texi:1394
msgid "This function makes @var{symbol}'s function cell void, so that a subsequent attempt to access this cell will cause a @code{void-function} error.  It returns @var{symbol}.  (See also @code{makunbound}, in @ref{Void Variables}.)"
msgstr "この関数は@var{symbol}の関数セルをvoidにする。そのためこれ以降に関数セルへのアクセスを試みると、@code{void-function}エラーが発生する。これは@var{symbol}をリターンします(@ref{Void Variables}の@code{makunbound}も参照)。"

#. type: group
#: original_texis/functions.texi:1400
#, no-wrap
msgid ""
"(defun foo (x) x)\n"
"(foo 1)\n"
"     @result{}1\n"
msgstr ""
"(defun foo (x) x)\n"
"(foo 1)\n"
"     @result{}1\n"

#. type: group
#: original_texis/functions.texi:1404
#, no-wrap
msgid ""
"(fmakunbound 'foo)\n"
"     @result{} foo\n"
msgstr ""
"(fmakunbound 'foo)\n"
"     @result{} foo\n"

#. type: group
#: original_texis/functions.texi:1408
#, no-wrap
msgid ""
"(foo 1)\n"
"@error{} Symbol's function definition is void: foo\n"
msgstr ""
"(foo 1)\n"
"@error{} Symbol's function definition is void: foo\n"

#. type: defun
#: original_texis/functions.texi:1412
#, no-wrap
msgid "fset symbol definition"
msgstr "fset symbol definition"

#. type: defun
#: original_texis/functions.texi:1418
msgid "This function stores @var{definition} in the function cell of @var{symbol}.  The result is @var{definition}.  Normally @var{definition} should be a function or the name of a function, but this is not checked.  The argument @var{symbol} is an ordinary evaluated argument."
msgstr "この関数は@var{symbol}の関数セルに@var{definition}を格納する。結果は@var{definition}。@var{definition}は通常は関数か関数の名前であるべきだが、これはチェックされない。引数@var{symbol}は通常のどおり評価される引数である。"

#. type: defun
#: original_texis/functions.texi:1423
msgid "The primary use of this function is as a subroutine by constructs that define or alter functions, like @code{defun} or @code{advice-add} (@pxref{Advising Functions}).  You can also use it to give a symbol a function definition that is not a function, e.g., a keyboard macro (@pxref{Keyboard Macros}):"
msgstr "この関数は主に関数を定義したり変更して構築を行う、@code{defun}や@code{advice-add}のようなものからサブルーチンとして使用される。たとえばキーボードマクロ(@ref{Keyboard Macros}を参照)のような、関数ではない関数定義をシンボルに与えるためにも使用することができる:"

#. type: example
#: original_texis/functions.texi:1428
#, no-wrap
msgid ""
";; @r{Define a named keyboard macro.}\n"
"(fset 'kill-two-lines \"\\^u2\\^k\")\n"
"     @result{} \"\\^u2\\^k\"\n"
msgstr ""
";; @r{名前つきのキーボードマクロを定義する。}\n"
"(fset 'kill-two-lines \"\\^u2\\^k\")\n"
"     @result{} \"\\^u2\\^k\"\n"

#. type: defun
#: original_texis/functions.texi:1433
msgid "It you wish to use @code{fset} to make an alternate name for a function, consider using @code{defalias} instead.  @xref{Definition of defalias}."
msgstr "関数にたいして別の名前を作成するために@code{fset}を使いたいなら、かわりに@code{defalias}の使用を考慮すること。@ref{Definition of defalias}を参照。"

#. type: Plain text
#: original_texis/functions.texi:1445
msgid "As explained in @ref{Variable Scoping}, Emacs can optionally enable lexical binding of variables.  When lexical binding is enabled, any named function that you create (e.g., with @code{defun}), as well as any anonymous function that you create using the @code{lambda} macro or the @code{function} special form or the @code{#'} syntax (@pxref{Anonymous Functions}), is automatically converted into a @dfn{closure}."
msgstr "@ref{Variable Scoping}で説明したように、Emacsはオプションで変数のレキシカルバインディングを有効にできます。レキシカルバインディングが有効な場合は、(たとえば@code{defun}などで)作成したすべての名前つき関数、同様に@code{lambda}マクロや@code{function}スペシャルフォーム、@code{#'}構文を使用して作成したすべての無名関数(@ref{Anonymous Functions}を参照)が、自動的に@dfn{クロージャー(closure)}に変換されます。"

#. type: Plain text
#: original_texis/functions.texi:1453
msgid "A closure is a function that also carries a record of the lexical environment that existed when the function was defined.  When it is invoked, any lexical variable references within its definition use the retained lexical environment.  In all other respects, closures behave much like ordinary functions; in particular, they can be called in the same way as ordinary functions."
msgstr "クロージャーとはその関数が定義されたどときに存在したレキシカル環境の記録をあわせもつ関数です。クロージャーが呼び出されたとき、定義内のレキシカル変数の参照には、その保持されたレキシカル環境が使用されます。他のすべての点では、クロージャーは通常の関数と同様に振る舞います。特にクロージャーは通常の関数と同じ方法で呼び出すことができます。"

#. type: Plain text
#: original_texis/functions.texi:1455
msgid "@xref{Lexical Binding}, for an example of using a closure."
msgstr "クロージャー使用する例は@ref{Lexical Binding}を参照してください。"

#. type: Plain text
#: original_texis/functions.texi:1460
msgid "Currently, an Emacs Lisp closure object is represented by a list with the symbol @code{closure} as the first element, a list representing the lexical environment as the second element, and the argument list and body forms as the remaining elements:"
msgstr "現在のところEmacs Lispのクロージャーオブジェクトは、1つ目の要素にシンボル@code{closure}をもつリストとして表現されます。そのリストは2つ目の要素としてレキシカル環境、残りの要素で引数リストとbodyフォームを表します:"

#. type: example
#: original_texis/functions.texi:1465
#, no-wrap
msgid ""
";; @r{lexical binding is enabled.}\n"
"(lambda (x) (* x x))\n"
"     @result{} (closure (t) (x) (* x x))\n"
msgstr ""
";; @r{レキシカルバインディングが有効}\n"
"(lambda (x) (* x x))\n"
"     @result{} (closure (t) (x) (* x x))\n"

#. type: Plain text
#: original_texis/functions.texi:1472
msgid "However, the fact that the internal structure of a closure is exposed to the rest of the Lisp world is considered an internal implementation detail.  For this reason, we recommend against directly examining or altering the structure of closure objects."
msgstr "しかし実際にはクロージャーの内部構造は、内部的な実装の詳細と判断される残りのLisp界を晒け出すものだと言えます。この理由により、クロージャーオブジェクトの構造を直接調べたり変更することは推奨しません。"

#. type: section
#: original_texis/functions.texi:1474
#, no-wrap
msgid "Advising Emacs Lisp Functions"
msgstr "Advising Emacs Lisp Functions"

#. type: cindex
#: original_texis/functions.texi:1475
#, no-wrap
msgid "advising functions"
msgstr "advising functions"

#. type: cindex
#: original_texis/functions.texi:1476
#, no-wrap
msgid "piece of advice"
msgstr "piece of advice"

#. type: Plain text
#: original_texis/functions.texi:1485
msgid "When you need to modify a function defined in another library, or when you need to modify a hook like @code{@var{foo}-function}, a process filter, or basically any variable or object field which holds a function value, you can use the appropriate setter function, such as @code{fset} or @code{defun} for named functions, @code{setq} for hook variables, or @code{set-process-filter} for process filters, but those are often too blunt, completely throwing away the previous value."
msgstr "他のライブラリーの関数定義を変更する必要があるとき、および@code{@var{foo}-function}oのようなフックやプロセスフィルター(process filter)や、関数を値としてもつ任意の変数やオブジェクトを変更する必要があるときには、名前つきの関数には@code{fset}か@code{defun}、フック変数には@code{setq}、プロセスフィルターには@code{set-process-filter}のように、適切なセッター関数(setter function)を使用することができます。しかしこれらが以前の値を完全に破棄してしまうのが好ましくない場合もあります。"

#. type: Plain text
#: original_texis/functions.texi:1489
msgid "The @dfn{advice} feature lets you add to the existing definition of a function, by @dfn{advising the function}.  This is a cleaner method than redefining the whole function."
msgstr "@dfn{アドバイス(advice)}機能によって@dfn{関数にアドバイス}することにより、既存の関数定義に機能を追加できます。これは関数全体を再定義するより明解な手法です。"

#. type: Plain text
#: original_texis/functions.texi:1495
msgid "Emacs's advice system provides two sets of primitives for that: the core set, for function values held in variables and object fields (with the corresponding primitives being @code{add-function} and @code{remove-function}) and another set layered on top of it for named functions (with the main primitives being @code{advice-add} and @code{advice-remove})."
msgstr "Emacsのアドバイスシステムは2つのプリミティブセットを提供します。コアとなるセットは変数やオブジェクトのフィールドに保持された関数値にたいするものです(対応するプリミティブは@code{add-function}と@code{remove-function})。もう1つのセットは名前つき関数の最上位のレイヤーとなるものです(主要なプリミティブは@code{advice-add}と@code{advice-remove})。"

#. type: Plain text
#: original_texis/functions.texi:1498
msgid "As a trivial example, here's how to add advice that'll modify the return value of a function every time it's called:"
msgstr ""

#. type: example
#: original_texis/functions.texi:1505
#, no-wrap
msgid ""
"(defun my-double (x)\n"
"  (* x 2))\n"
"(defun my-increase (x)\n"
"  (+ x 1))\n"
"(advice-add 'my-double :filter-return #'my-increase)\n"
msgstr ""

#. type: Plain text
#: original_texis/functions.texi:1509
msgid "After adding this advice, if you call @code{my-double} with @samp{3}, the return value will be @samp{7}.  To remove this advice, say"
msgstr ""

#. type: example
#: original_texis/functions.texi:1512
#, fuzzy, no-wrap
#| msgid "(advice-remove 'display-buffer #'his-tracing-function)\n"
msgid "(advice-remove 'my-double #'my-increase)\n"
msgstr "(advice-remove 'display-buffer #'his-tracing-function)\n"

#. type: Plain text
#: original_texis/functions.texi:1516
#, fuzzy
#| msgid "For example, in order to trace the calls to the process filter of a process @var{proc}, you could use:"
msgid "A more advanced example would be to trace the calls to the process filter of a process @var{proc}:"
msgstr "たとえばプロセス@var{proc}のプロセスフィルターの呼び出しをトレースするために以下を使用できます:"

#. type: example
#: original_texis/functions.texi:1520
#, no-wrap
msgid ""
"(defun my-tracing-function (proc string)\n"
"  (message \"Proc %S received %S\" proc string))\n"
"\n"
msgstr ""
"(defun my-tracing-function (proc string)\n"
"  (message \"Proc %S received %S\" proc string))\n"
"\n"

#. type: example
#: original_texis/functions.texi:1522
#, no-wrap
msgid "(add-function :before (process-filter @var{proc}) #'my-tracing-function)\n"
msgstr "(add-function :before (process-filter @var{proc}) #'my-tracing-function)\n"

#. type: Plain text
#: original_texis/functions.texi:1528
msgid "This will cause the process's output to be passed to @code{my-tracing-function} before being passed to the original process filter.  @code{my-tracing-function} receives the same arguments as the original function.  When you're done with it, you can revert to the untraced behavior with:"
msgstr "これによりそのプロセスの出力は元のプロセスフィルターに渡される前に、@code{my-tracing-function}に渡されるようになります。@code{my-tracing-function}は元の関数と同じ引数を受け取ります。これを行えば以下のようにしてトレースを行う前の振る舞いにリバートすることができます。"

#. type: example
#: original_texis/functions.texi:1531
#, no-wrap
msgid "(remove-function (process-filter @var{proc}) #'my-tracing-function)\n"
msgstr "(remove-function (process-filter @var{proc}) #'my-tracing-function)\n"

#. type: Plain text
#: original_texis/functions.texi:1535
msgid "Similarly, if you want to trace the execution of the function named @code{display-buffer}, you could use:"
msgstr "同様に@code{display-buffer}という名前つきの関数の実行をトレースしたいなら以下を使用できます:"

#. type: example
#: original_texis/functions.texi:1542
#, no-wrap
msgid ""
"(defun his-tracing-function (orig-fun &rest args)\n"
"  (message \"display-buffer called with args %S\" args)\n"
"  (let ((res (apply orig-fun args)))\n"
"    (message \"display-buffer returned %S\" res)\n"
"    res))\n"
"\n"
msgstr ""
"(defun his-tracing-function (orig-fun &rest args)\n"
"  (message \"display-buffer called with args %S\" args)\n"
"  (let ((res (apply orig-fun args)))\n"
"    (message \"display-buffer returned %S\" res)\n"
"    res))\n"
"\n"

#. type: example
#: original_texis/functions.texi:1544
#, no-wrap
msgid "(advice-add 'display-buffer :around #'his-tracing-function)\n"
msgstr "(advice-add 'display-buffer :around #'his-tracing-function)\n"

#. type: Plain text
#: original_texis/functions.texi:1551
msgid "Here, @code{his-tracing-function} is called instead of the original function and receives the original function (additionally to that function's arguments)  as argument, so it can call it if and when it needs to.  When you're tired of seeing this output, you can revert to the untraced behavior with:"
msgstr "ここで@code{his-tracing-function}は元の関数のかわりに呼び出されて、元の関数(に加えてその関数の引数)を引数として受け取るので、必要な場合はそれを呼び出すことができます。出力を確認し終えたら、以下のようにしてトレースを行う前の振る舞いにリバートできます:"

#. type: example
#: original_texis/functions.texi:1554
#, no-wrap
msgid "(advice-remove 'display-buffer #'his-tracing-function)\n"
msgstr "(advice-remove 'display-buffer #'his-tracing-function)\n"

#. type: Plain text
#: original_texis/functions.texi:1559
msgid "The arguments @code{:before} and @code{:around} used in the above examples specify how the two functions are composed, since there are many different ways to do it.  The added function is also called a piece of @emph{advice}."
msgstr "上記の例で使用されている引数@code{:before}と@code{:around}は、2つの関数が構成される方法を指定します(これを行う多くの方法があるから)。追加された関数も@emph{アドバイス(advice)}と呼ばれます。"

#. type: node
#: original_texis/functions.texi:1565 original_texis/functions.texi:1567
#, no-wrap
msgid "Core Advising Primitives"
msgstr "Core Advising Primitives"

#. type: menuentry
#: original_texis/functions.texi:1565
msgid "Primitives to manipulate advice."
msgstr "アドバイスを扱うプリミティブ。"

#. type: subsection
#: original_texis/functions.texi:1565 original_texis/functions.texi:1696
#: original_texis/functions.texi:1697
#, no-wrap
msgid "Advising Named Functions"
msgstr "Advising Named Functions"

#. type: menuentry
#: original_texis/functions.texi:1565
msgid "Advising named functions."
msgstr "名前つき関数のアドバイス。"

#. type: node
#: original_texis/functions.texi:1565 original_texis/functions.texi:1782
#, fuzzy, no-wrap
#| msgid "Advice combinators"
msgid "Advice Combinators"
msgstr "Advice combinators"

#. type: menuentry
#: original_texis/functions.texi:1565
msgid "Ways to compose advice."
msgstr "アドバイスを構成する方法。"

#. type: node
#: original_texis/functions.texi:1565 original_texis/functions.texi:1895
#, fuzzy, no-wrap
#| msgid "Porting old advice"
msgid "Porting Old Advice"
msgstr "Porting old advice"

#. type: menuentry
#: original_texis/functions.texi:1565
msgid "Adapting code using the old defadvice."
msgstr "古いdefadviceを使用したコードの改良。"

#. type: subsection
#: original_texis/functions.texi:1568
#, no-wrap
msgid "Primitives to manipulate advices"
msgstr "Primitives to manipulate advices"

#. type: cindex
#: original_texis/functions.texi:1569
#, no-wrap
msgid "advice, add and remove"
msgstr "advice, add and remove"

#. type: defmac
#: original_texis/functions.texi:1571
#, no-wrap
msgid "add-function where place function &optional props"
msgstr "add-function where place function &optional props"

#. type: defmac
#: original_texis/functions.texi:1574
msgid "This macro is the handy way to add the advice @var{function} to the function stored in @var{place} (@pxref{Generalized Variables})."
msgstr "このマクロは@var{place}(@ref{Generalized Variables}を参照)に格納された関数に、アドバイス@var{function}を追加する手軽な方法である。"

#. type: defmac
#: original_texis/functions.texi:1579
#, fuzzy
#| msgid "@var{where} determines how @var{function} is composed with the existing function, e.g., whether @var{function} should be called before, or after the original function.  @xref{Advice combinators}, for the list of available ways to compose the two functions."
msgid "@var{where} determines how @var{function} is composed with the existing function, e.g., whether @var{function} should be called before, or after the original function.  @xref{Advice Combinators}, for the list of available ways to compose the two functions."
msgstr "@var{where}は既存の関数のどこ --- たとえば元の関数の前や後 --- に@var{function}が構成されるかを決定する。2つの関数を構成するために利用可能な方法のリストは、@ref{Advice combinators}を参照のこと。"

#. type: defmac
#: original_texis/functions.texi:1588
msgid "When modifying a variable (whose name will usually end with @code{-function}), you can choose whether @var{function} is used globally or only in the current buffer: if @var{place} is just a symbol, then @var{function} is added to the global value of @var{place}.  Whereas if @var{place} is of the form @code{(local @var{symbol})}, where @var{symbol} is an expression which returns the variable name, then @var{function} will only be added in the current buffer.  Finally, if you want to modify a lexical variable, you will have to use @code{(var @var{variable})}."
msgstr "(通常は名前が@code{-function}で終わる)変数を変更するときには、@var{function}がグローバルに使用されるか、あるいはカレントバッファーだけに使用されるか選ぶことができる。@var{place}が単にシンボルなら@var{function}は@var{place}のグローバル値に追加される。@var{place}が@code{(local @var{symbol})}というフォームなら、@var{symbol}はその変数の名前をリターンする式なので、@var{function}はカレントバッファーだけに追加される。最後にレキシカル変数を変更したければ、@code{(var @var{variable})}を使用する必要があるだろう。"

#. type: defmac
#: original_texis/functions.texi:1592
msgid "Every function added with @code{add-function} can be accompanied by an association list of properties @var{props}.  Currently only two of those properties have a special meaning:"
msgstr "@code{add-function}で追加されたすべての関数は、自動的にプロパティー@var{props}の連想リストに加えることができる。現在のところ特別な意味をもつのは以下の2つのプロパティーのみ:"

#. type: item
#: original_texis/functions.texi:1594
#, no-wrap
msgid "name"
msgstr "name"

#. type: table
#: original_texis/functions.texi:1598
msgid "This gives a name to the advice, which @code{remove-function} can use to identify which function to remove.  Typically used when @var{function} is an anonymous function."
msgstr "これはアドバイスの名前を与える。この名前は@code{remove-function}が取り除く関数を識別するのに使用できます。これは通常は@var{function}が無名関数のときに使用されます。"

#. type: item
#: original_texis/functions.texi:1599
#, no-wrap
msgid "depth"
msgstr "depth"

#. type: table
#: original_texis/functions.texi:1606
msgid "This specifies how to order the advice, should several pieces of advice be present.  By default, the depth is 0.  A depth of 100 indicates that this piece of advice should be kept as deep as possible, whereas a depth of @minus{}100 indicates that it should stay as the outermost piece.  When two pieces of advice specify the same depth, the most recently added one will be outermost."
msgstr "これは複数のアドバイスが与えられたときにアドバイスを順番づける方法を指定します。depthのデフォルト0です。depthが100のときにはアドバイスが可能な限りの深さを保持すべきことを、-100のときは最外のアドバイスに留めることを意味します。同じdepthで2つのアドバイスが指定された場合には、もっとも最近に追加されたアドバイスが最外になります。"

#. type: table
#: original_texis/functions.texi:1619
msgid "For @code{:before} advice, being outermost means that this advice will be run first, before any other advice, whereas being innermost means that it will run right before the original function, with no other advice run between itself and the original function.  Similarly, for @code{:after} advice innermost means that it will run right after the original function, with no other advice run in between, whereas outermost means that it will be run right at the end after all other advice.  An innermost @code{:override} piece of advice will only override the original function and other pieces of advice will apply to it, whereas an outermost @code{:override} piece of advice will override not only the original function but all other advice applied to it as well."
msgstr "@code{:before}アドバイスにたいしては、最外(outermost)になるということは、このアドバイスが他のすべてのアドバイスの前、つまり1番目に実行されることを意味し、最内(innermost)とは元の関数が実行される直前、すなわちこのアドバイスと元の関数の間に実行されるアドバイスは存在しないことを意味する。同様に@code{:after}アドバイスにたいしては、最内とは元の関数の直後、つまりこの元の関数とアドバイスの間に実行される他のアドバイスは存在せず、最外とは他のすべてのアドバイスが実行された直後にこのアドバイスが実行されることを意味する。@code{:override}の最内アドバイスは、元の関数だけをオーバーライドし、他のアドバイスはそれに適用されるが、@code{:override}の最外アドバイスは元の関数だけではなく、その他すべての適用済みのアドバイスをも同様にオーバーライドする。"

#. type: defmac
#: original_texis/functions.texi:1630
#, fuzzy
#| msgid "If @var{function} is not interactive, then the combined function will inherit the interactive spec, if any, of the original function.  Else, the combined function will be interactive and will use the interactive spec of @var{function}.  One exception: if the interactive spec of @var{function} is a function (rather than an expression or a string), then the interactive spec of the combined function will be a call to that function with as sole argument the interactive spec of the original function.  To interpret the spec received as argument, use @code{advice-eval-interactive-spec}."
msgid "If @var{function} is not interactive, then the combined function will inherit the interactive spec, if any, of the original function.  Else, the combined function will be interactive and will use the interactive spec of @var{function}.  One exception: if the interactive spec of @var{function} is a function (i.e., a @code{lambda} expression or an @code{fbound} symbol rather than an expression or a string), then the interactive spec of the combined function will be a call to that function with as sole argument the interactive spec of the original function.  To interpret the spec received as argument, use @code{advice-eval-interactive-spec}."
msgstr "@var{function}がインタラクティブでなければ合成された関数は、(もしあれば)元の関数のインタラクティブ仕様(interactive spec)を継承します。それ以外なら合成された関数はインタラクティブとなり@var{function}のインタラクティブ仕様を使用します。1つ例外があります。@var{function}のインタラクティブ仕様が(式や文字列ではない)関数なら、元の関数のインタラクティブ仕様を唯一の引数としてその関数を呼び出して、それが合成された関数のインタラクティブ指定になります。引数として受け取ったインタラクティブ仕様を解釈するためには@code{advice-eval-interactive-spec}を使用します。"

#. type: defmac
#: original_texis/functions.texi:1638
msgid "Note: The interactive spec of @var{function} will apply to the combined function and should hence obey the calling convention of the combined function rather than that of @var{function}.  In many cases, it makes no difference since they are identical, but it does matter for @code{:around}, @code{:filter-args}, and @code{:filter-return}, where @var{function} receives different arguments than the original function stored in @var{place}."
msgstr "注意: @var{function}のインタラクティブ指定は結合された関数に適用されるべきであり、@var{function}ではなく結合された関数の呼び出し規約にしたがうこと。これらは多くの場合には等しいので差異は生じないが、@var{place}に格納されたオリジナルの関数とは異なる引数を受け取る@var{function}では@code{:around}、@code{:filter-args}、@code{:filter-return}では重要になる。"

#. type: defmac
#: original_texis/functions.texi:1640
#, no-wrap
msgid "remove-function place function"
msgstr "remove-function place function"

#. type: defmac
#: original_texis/functions.texi:1644
msgid "This macro removes @var{function} from the function stored in @var{place}.  This only works if @var{function} was added to @var{place} using @code{add-function}."
msgstr "このマクロは@var{place}に格納された関数から@var{function}を取り除く。これは@code{add-function}を使用して@var{function}が@var{place}に追加されたときだけ機能する。"

#. type: defmac
#: original_texis/functions.texi:1650
msgid "@var{function} is compared with functions added to @var{place} using @code{equal}, to try and make it work also with lambda expressions.  It is additionally compared also with the @code{name} property of the functions added to @var{place}, which can be more reliable than comparing lambda expressions using @code{equal}."
msgstr "@var{function}は@var{place}に追加された関数にたいして、ラムダ式にたいしても機能するように@code{equal}を使用して比較を試みる。これは追加で@var{place}に追加された関数の@code{name}プロパティーも比較する。これは@code{equal}を使用してラムダ式を比較するより信頼性がある。"

#. type: defun
#: original_texis/functions.texi:1652
#, no-wrap
msgid "advice-function-member-p advice function-def"
msgstr "advice-function-member-p advice function-def"

#. type: defun
#: original_texis/functions.texi:1656
msgid "Return non-@code{nil} if @var{advice} is already in @var{function-def}.  Like for @code{remove-function} above, instead of @var{advice} being the actual function, it can also be the @code{name} of the piece of advice."
msgstr "@var{advice}がすでに@var{function-def}内にあれば非@code{nil}をリターンする。上記の@code{remove-function}と同様、実際の関数@var{advice}のかわりにアドバイスの@code{name}も使用できる。"

#. type: defun
#: original_texis/functions.texi:1658
#, no-wrap
msgid "advice-function-mapc f function-def"
msgstr "advice-function-mapc f function-def"

#. type: defun
#: original_texis/functions.texi:1662
msgid "Call the function @var{f} for every piece of advice that was added to @var{function-def}.  @var{f} is called with two arguments: the advice function and its properties."
msgstr "@var{function-def}に追加されたすべてのアドバイスにたいして、関数@var{f}を呼び出す。@var{f}は2つの引数 --- アドバイス関数とそれのプロパティーで呼びだされる。"

#. type: defun
#: original_texis/functions.texi:1664
#, no-wrap
msgid "advice-eval-interactive-spec spec"
msgstr "advice-eval-interactive-spec spec"

#. type: defun
#: original_texis/functions.texi:1670
msgid "Evaluate the interactive @var{spec} just like an interactive call to a function with such a spec would, and then return the corresponding list of arguments that was built.  E.g., @code{(advice-eval-interactive-spec \"r\\nP\")} will return a list of three elements, containing the boundaries of the region and the current prefix argument."
msgstr "そのようなインタラクティブ仕様で関数がインタラクティブに呼び出されたように@var{spec}を評価して、構築された引数のリストに対応するリストをリターンする。たとえば@code{(advice-eval-interactive-spec \"r\\nP\")}はリージョンの境界、カレントプレフィクス引数を含む、3つの要素からなるリストをリターンする。"

#. type: defun
#: original_texis/functions.texi:1674
msgid "For instance, if you want to make the @kbd{C-x m} (@code{compose-mail}) command prompt for a @samp{From:} header, you could say something like this:"
msgstr ""

#. type: example
#: original_texis/functions.texi:1691
#, no-wrap
msgid ""
"(defun my-compose-mail-advice (orig &rest args)\n"
"  \"Read From: address interactively.\"\n"
"  (interactive\n"
"   (lambda (spec)\n"
"     (let* ((user-mail-address\n"
"             (completing-read \"From: \"\n"
"                              '(\"one.address@@example.net\"\n"
"                                \"alternative.address@@example.net\")))\n"
"            (from (message-make-from user-full-name\n"
"                                     user-mail-address))\n"
"            (spec (advice-eval-interactive-spec spec)))\n"
"       ;; Put the From header into the OTHER-HEADERS argument.\n"
"       (push (cons 'From from) (nth 2 spec))\n"
"       spec)))\n"
"  (apply orig args))\n"
"\n"
msgstr ""

#. type: example
#: original_texis/functions.texi:1693
#, no-wrap
msgid "(advice-add 'compose-mail :around #'my-compose-mail-advice)\n"
msgstr ""

#. type: cindex
#: original_texis/functions.texi:1698
#, no-wrap
msgid "advising named functions"
msgstr "advising named functions"

#. type: Plain text
#: original_texis/functions.texi:1702
msgid "A common use of advice is for named functions and macros.  You could just use @code{add-function} as in:"
msgstr "アドバイスは名前つき関数やマクロにたいして使用するのが一般的な使い方です。これは単に@code{add-function}を使用して以下のように行うことができます:"

#. type: example
#: original_texis/functions.texi:1705
#, no-wrap
msgid "(add-function :around (symbol-function '@var{fun}) #'his-tracing-function)\n"
msgstr "(add-function :around (symbol-function '@var{fun}) #'his-tracing-function)\n"

#. type: Plain text
#: original_texis/functions.texi:1714
msgid "But you should use @code{advice-add} and @code{advice-remove} for that instead.  This separate set of functions to manipulate pieces of advice applied to named functions, offers the following extra features compared to @code{add-function}: they know how to deal with macros and autoloaded functions, they let @code{describe-function} preserve the original docstring as well as document the added advice, and they let you add and remove advice before a function is even defined."
msgstr "しかしかわりに@code{advice-add}と@code{advice-remove}を使うべきです。この異なる関数セットは名前つき関数に適用されるアドバイスを操作するためのもので、@code{add-function}と比較して以下の追加機能があります。まずこれらはマクロとオートロードされた関数を扱う方法を知っています。次に@code{describe-function}にたいして追加されたアドバイスと同様に、元のドキュメント文字列を維持します。さらに関数が定義される前でも、アドバイスの追加と削除ができます。"

#. type: Plain text
#: original_texis/functions.texi:1722
msgid "@code{advice-add} can be useful for altering the behavior of existing calls to an existing function without having to redefine the whole function.  However, it can be a source of bugs, since existing callers to the function may assume the old behavior, and work incorrectly when the behavior is changed by advice.  Advice can also cause confusion in debugging, if the person doing the debugging does not notice or remember that the function has been modified by advice."
msgstr "既存の関数全体を再定義せずに既存の呼び出しを変更するために、@code{advice-add}が有用になります。しかしその関数の既存の呼び出し元は古い振る舞いを前提としているかもしれず、アドバイスによりその振る舞いが変更されたときに正しく機能しないかもしれないので、これはソー内スのバグにもなり得ます。アドバイスはデバッグを難しくする可能性もあります。デバッグを行う人はその関数がアドバイスにより変更されたことに気づかなかったり、失念しているかもしれません。"

#. type: Plain text
#: original_texis/functions.texi:1729
#, fuzzy
#| msgid "For these reasons, advice should be reserved for the cases where you cannot modify a function's behavior in any other way.  If it is possible to do the same thing via a hook, that is preferable (@pxref{Hooks}).  If you simply want to change what a particular key does, it may be better to write a new command, and remap the old command's key bindings to the new one (@pxref{Remapping Commands}).  In particular, Emacs's own source files should not put advice on functions in Emacs.  (There are currently a few exceptions to this convention, but we aim to correct them.)"
msgid "For these reasons, advice should be reserved for the cases where you cannot modify a function's behavior in any other way.  If it is possible to do the same thing via a hook, that is preferable (@pxref{Hooks}).  If you simply want to change what a particular key does, it may be better to write a new command, and remap the old command's key bindings to the new one (@pxref{Remapping Commands})."
msgstr "これらの理由により、他の方法で関数の振る舞いを変更できない場合に備えるために、アドバイスの使用は控えるべきです。フックを通じて同じことが行えるならフック(@ref{Hooks}を参照)の使用が望ましい方法です。特定のキーが行う何かを変更したいだけなら、新しいコマンドを記述して、古いコマンドのキーバインドを新しいコマンドにリマップ(@ref{Remapping Commands}を参照)するのが、おそらくより良い方法です。特にEmacs自身のソースファイルは、Emacs内の関数をアドバイスするべきではありません(現在のところこの慣習にはいくつかの例外があるが、わたしたちはこれを改善しようと思っている)。"

#. type: Plain text
#: original_texis/functions.texi:1738
msgid "If you are writing code for release, for others to use, try to avoid including advice in it.  If the function you want to advise has no hook to do the job, please talk with the Emacs developers about adding a suitable hook.  Especially, Emacs's own source files should not put advice on functions in Emacs.  (There are currently a few exceptions to this convention, but we aim to correct them.)  It is generally cleaner to create a new hook in @code{foo}, and make @code{bar} use the hook, than to have @code{bar} put advice in @code{foo}."
msgstr ""

#. type: Plain text
#: original_texis/functions.texi:1743
msgid "Special forms (@pxref{Special Forms}) cannot be advised, however macros can be advised, in much the same way as functions.  Of course, this will not affect code that has already been macro-expanded, so you need to make sure the advice is installed before the macro is expanded."
msgstr "スペシャルフォーム(@ref{Special Forms}を参照)はアドバイスできませんが、マクロは関数と同じ方法でアドバイスできます。もちろんこれはすでにマクロ展開されたコードには影響しないため、マクロ展開前にアドバイスが確実にインストールされる必要があります。"

#. type: Plain text
#: original_texis/functions.texi:1751
msgid "It is possible to advise a primitive (@pxref{What Is a Function}), but one should typically @emph{not} do so, for two reasons.  Firstly, some primitives are used by the advice mechanism, and advising them could cause an infinite recursion.  Secondly, many primitives are called directly from C, and such calls ignore advice; hence, one ends up in a confusing situation where some calls (occurring from Lisp code) obey the advice and other calls (from C code) do not."
msgstr "プリミティブ(@ref{What Is a Function}を参照)にアドバイスするのは可能ですが、2つの理由により通常は@emph{行うべきではありません}。1つ目の理由はいくつかのプリミティブがアドバイスのメカニズム内で使用されているため、それらにたいしてアドバイスを行うと無限再帰が発生するからです。2つ目の理由は多くのプリミティブがCから直接呼び出されていて、そのような呼び出しはアドバイスを無視するからです。したがってプリミティブにたいしてアドバイスの使用を控えることにより、ある呼び出しはアドバイスにしたがい(Lispコードから呼びだされたため)、他の呼び出しではアドバイスにしたがわない(Cコードから呼び出されたため)という混乱した状況を解決できます。"

#. type: defmac
#: original_texis/functions.texi:1752
#, no-wrap
msgid "define-advice symbol (where lambda-list &optional name depth) &rest body"
msgstr "define-advice symbol (where lambda-list &optional name depth) &rest body"

#. type: defmac
#: original_texis/functions.texi:1757
msgid "This macro defines a piece of advice and adds it to the function named @var{symbol}.  The advice is an anonymous function if @var{name} is @code{nil} or a function named @code{symbol@@name}.  See @code{advice-add} for explanation of other arguments."
msgstr "このマクロはアドバイスを定義して@var{symbol}という名前の関数に追加する。@var{name}が@code{nil}か@code{symbol@@name}という名前の関数ならアドバイスは無名関数。他の引数についての説明は@code{advice-add}を参照のこと。"

#. type: defun
#: original_texis/functions.texi:1759
#, no-wrap
msgid "advice-add symbol where function &optional props"
msgstr "advice-add symbol where function &optional props"

#. type: defun
#: original_texis/functions.texi:1763
msgid "Add the advice @var{function} to the named function @var{symbol}.  @var{where} and @var{props} have the same meaning as for @code{add-function} (@pxref{Core Advising Primitives})."
msgstr "名前つき関数@var{symbol}にアドバイス@var{function}を追加する。@var{where}と@var{props}は@code{add-function}(@ref{Core Advising Primitives}を参照)のときと同じ意味をもつ。"

#. type: defun
#: original_texis/functions.texi:1765
#, no-wrap
msgid "advice-remove symbol function"
msgstr "advice-remove symbol function"

#. type: defun
#: original_texis/functions.texi:1768
msgid "Remove the advice @var{function} from the named function @var{symbol}.  @var{function} can also be the @code{name} of a piece of advice."
msgstr "名前つき関数@var{symbol}からアドバイス@var{function}を取り除く。@var{function}にアドバイスの@code{name}を指定することもできる。"

#. type: defun
#: original_texis/functions.texi:1770
#, no-wrap
msgid "advice-member-p function symbol"
msgstr "advice-member-p function symbol"

#. type: defun
#: original_texis/functions.texi:1774
msgid "Return non-@code{nil} if the advice @var{function} is already in the named function @var{symbol}.  @var{function} can also be the @code{name} of a piece of advice."
msgstr "名前つき関数@var{symbol}内にすでにアドバイス@var{function}があれば非@code{nil}をリターンする。@var{function}にアドバイスの@code{name}を指定することもできる。"

#. type: defun
#: original_texis/functions.texi:1776
#, no-wrap
msgid "advice-mapc function symbol"
msgstr "advice-mapc function symbol"

#. type: defun
#: original_texis/functions.texi:1780
msgid "Call @var{function} for every piece of advice that was added to the named function @var{symbol}.  @var{function} is called with two arguments: the advice function and its properties."
msgstr "名前つき関数@var{symbol}にすでに追加されたすべての関数にたいして@var{function}を呼び出す。@var{function}はアドバイス関数とそのプロパティーという2つの引数で呼び出される。"

#. type: subsection
#: original_texis/functions.texi:1783
#, no-wrap
msgid "Ways to compose advice"
msgstr "Ways to compose advice"

#. type: Plain text
#: original_texis/functions.texi:1788
msgid "Here are the different possible values for the @var{where} argument of @code{add-function} and @code{advice-add}, specifying how the advice @var{function} and the original function should be composed."
msgstr "以下は@code{add-function}と@code{advice-add}の@var{where}引数に可能な値であり、そのアドバイス@var{function}と元の関数が構成される方法を指定します。"

#. type: table
#: original_texis/functions.texi:1795
msgid "Call @var{function} before the old function.  Both functions receive the same arguments, and the return value of the composition is the return value of the old function.  More specifically, the composition of the two functions behaves like:"
msgstr "古い関数の前に@var{function}を呼び出す。関数は両方とも同じ引数を受け取り、2つの関数の結合のリターン値は古い関数のリターン値である。より正確に言うと2つの関数の結合は以下のように振る舞う:"

#. type: example
#: original_texis/functions.texi:1797
#, no-wrap
msgid "(lambda (&rest r) (apply @var{function} r) (apply @var{oldfun} r))\n"
msgstr "(lambda (&rest r) (apply @var{function} r) (apply @var{oldfun} r))\n"

#. type: table
#: original_texis/functions.texi:1801
msgid "@code{(add-function :before @var{funvar} @var{function})} is comparable for single-function hooks to @code{(add-hook '@var{hookvar} @var{function})} for normal hooks."
msgstr "@code{(add-function :before @var{funvar} @var{function})}はノーマルフックにたいする@code{(add-hook '@var{hookvar} @var{function})}のような1関数のフックと同等。"

#. type: table
#: original_texis/functions.texi:1807
msgid "Call @var{function} after the old function.  Both functions receive the same arguments, and the return value of the composition is the return value of the old function.  More specifically, the composition of the two functions behaves like:"
msgstr "古い関数の後に@var{function}を呼び出す。関数は両方とも同じ引数を受け取り、2つの関数の結合のリターン値は古い関数のリターン値である。より正確に言うと2つの関数の結合は以下のように振る舞う:"

#. type: example
#: original_texis/functions.texi:1809
#, no-wrap
msgid "(lambda (&rest r) (prog1 (apply @var{oldfun} r) (apply @var{function} r)))\n"
msgstr "(lambda (&rest r) (prog1 (apply @var{oldfun} r) (apply @var{function} r)))\n"

#. type: table
#: original_texis/functions.texi:1813
msgid "@code{(add-function :after @var{funvar} @var{function})} is comparable for single-function hooks to @code{(add-hook '@var{hookvar} @var{function} 'append)} for normal hooks."
msgstr "@code{(add-function :after @var{funvar} @var{function})}はノーマルフックにたいする@code{(add-hook '@var{hookvar} @var{function} 'append)}のような1関数のフックと同等。"

#. type: item
#: original_texis/functions.texi:1814
#, no-wrap
msgid ":override"
msgstr ":override"

#. type: table
#: original_texis/functions.texi:1817
msgid "This completely replaces the old function with the new one.  The old function can of course be recovered if you later call @code{remove-function}."
msgstr "これは古い関数を新しい関数に完全に置き換える。もちろん@code{remove-function}を呼び出した後に古い関数が復元される。"

#. type: table
#: original_texis/functions.texi:1825
msgid "Call @var{function} instead of the old function, but provide the old function as an extra argument to @var{function}.  This is the most flexible composition.  For example, it lets you call the old function with different arguments, or many times, or within a let-binding, or you can sometimes delegate the work to the old function and sometimes override it completely.  More specifically, the composition of the two functions behaves like:"
msgstr "古い関数のかわりに@var{function}を呼び出すが、古い関数は@var{function}の追加の引数になる。これはもっとも柔軟な結合である。たとえば古い関数を異なる引数で呼び出したり、複数回呼び出したり、letバインディングで呼び出したり、あるときは古い関数に処理を委譲し、またあるときは完全にオーバーライドすることが可能になる。より正確に言うと2つの関数の結合は以下のように振る舞う:"

#. type: example
#: original_texis/functions.texi:1827
#, no-wrap
msgid "(lambda (&rest r) (apply @var{function} @var{oldfun} r))\n"
msgstr "(lambda (&rest r) (apply @var{function} @var{oldfun} r))\n"

#. type: item
#: original_texis/functions.texi:1829
#, no-wrap
msgid ":before-while"
msgstr ":before-while"

#. type: table
#: original_texis/functions.texi:1835
msgid "Call @var{function} before the old function and don't call the old function if @var{function} returns @code{nil}.  Both functions receive the same arguments, and the return value of the composition is the return value of the old function.  More specifically, the composition of the two functions behaves like:"
msgstr "古い関数の前に@var{function}を呼び出し、@var{function}が@code{nil}をリターンしたら古い関数を呼び出さない。関数は両方とも同じ引数を受け取り、2つの関数の結合のリターン値は古い関数のリターン値である。より正確に言うと2つの関数の結合は以下のように振る舞う:"

#. type: example
#: original_texis/functions.texi:1837
#, no-wrap
msgid "(lambda (&rest r) (and (apply @var{function} r) (apply @var{oldfun} r)))\n"
msgstr "(lambda (&rest r) (and (apply @var{function} r) (apply @var{oldfun} r)))\n"

#. type: table
#: original_texis/functions.texi:1841
msgid "@code{(add-function :before-while @var{funvar} @var{function})} is comparable for single-function hooks to @code{(add-hook '@var{hookvar} @var{function})} when @var{hookvar} is run via @code{run-hook-with-args-until-failure}."
msgstr "@code{(add-function :before-while @var{funvar} @var{function})}は@code{run-hook-with-args-until-failure}を通じて@var{hookvar}が実行されたときの@code{(add-hook '@var{hookvar} @var{function})}のような1関数のフックと同等。"

#. type: item
#: original_texis/functions.texi:1842
#, no-wrap
msgid ":before-until"
msgstr ":before-until"

#. type: table
#: original_texis/functions.texi:1846
msgid "Call @var{function} before the old function and only call the old function if @var{function} returns @code{nil}.  More specifically, the composition of the two functions behaves like:"
msgstr "古い関数の前に@var{function}を呼び出し、@var{function}が@code{nil}をリターンした場合だけ古い関数を呼び出す。より正確に言うと2つの関数の結合は以下のように振る舞う:"

#. type: example
#: original_texis/functions.texi:1848
#, no-wrap
msgid "(lambda (&rest r) (or (apply @var{function} r) (apply @var{oldfun} r)))\n"
msgstr "(lambda (&rest r) (or (apply @var{function} r) (apply @var{oldfun} r)))\n"

#. type: table
#: original_texis/functions.texi:1852
msgid "@code{(add-function :before-until @var{funvar} @var{function})} is comparable for single-function hooks to @code{(add-hook '@var{hookvar} @var{function})} when @var{hookvar} is run via @code{run-hook-with-args-until-success}."
msgstr "@code{(add-function :before-until @var{funvar} @var{function})}は@code{run-hook-with-args-until-success}を通じて@var{hookvar}が実行されたときの@code{(add-hook '@var{hookvar} @var{function})}のような1関数のフックと同等。"

#. type: item
#: original_texis/functions.texi:1853
#, no-wrap
msgid ":after-while"
msgstr ":after-while"

#. type: table
#: original_texis/functions.texi:1858
msgid "Call @var{function} after the old function and only if the old function returned non-@code{nil}.  Both functions receive the same arguments, and the return value of the composition is the return value of @var{function}.  More specifically, the composition of the two functions behaves like:"
msgstr "古い関数が非@code{nil}をリターンした場合だけ、古い関数の後に@var{function}を呼び出す。関数は両方とも同じ引数を受け取り、2つの関数の結合のリターン値は@var{function}のリターン値である。より正確に言うと2つの関数の結合は以下のように振る舞う:"

#. type: example
#: original_texis/functions.texi:1860
#, no-wrap
msgid "(lambda (&rest r) (and (apply @var{oldfun} r) (apply @var{function} r)))\n"
msgstr "(lambda (&rest r) (and (apply @var{oldfun} r) (apply @var{function} r)))\n"

#. type: table
#: original_texis/functions.texi:1865
msgid "@code{(add-function :after-while @var{funvar} @var{function})} is comparable for single-function hooks to @code{(add-hook '@var{hookvar} @var{function} 'append)} when @var{hookvar} is run via @code{run-hook-with-args-until-failure}."
msgstr "@code{(add-function :after-while @var{funvar} @var{function})}は@code{run-hook-with-args-until-failure}を通じて@var{hookvar}が実行されたときの@code{(add-hook '@var{hookvar} @var{function} 'append)}のような1関数のフックと同等。"

#. type: item
#: original_texis/functions.texi:1866
#, no-wrap
msgid ":after-until"
msgstr ":after-until"

#. type: table
#: original_texis/functions.texi:1870
msgid "Call @var{function} after the old function and only if the old function returned @code{nil}.  More specifically, the composition of the two functions behaves like:"
msgstr "古い関数が@code{nil}をリターンした場合だけ、古い関数の後に@var{function}を呼び出す。より正確に言うと2つの関数の結合は以下のように振る舞う:"

#. type: example
#: original_texis/functions.texi:1872
#, no-wrap
msgid "(lambda (&rest r) (or  (apply @var{oldfun} r) (apply @var{function} r)))\n"
msgstr "(lambda (&rest r) (or  (apply @var{oldfun} r) (apply @var{function} r)))\n"

#. type: table
#: original_texis/functions.texi:1877
msgid "@code{(add-function :after-until @var{funvar} @var{function})} is comparable for single-function hooks to @code{(add-hook '@var{hookvar} @var{function} 'append)} when @var{hookvar} is run via @code{run-hook-with-args-until-success}."
msgstr "@code{(add-function :after-until @var{funvar} @var{function})}は@code{run-hook-with-args-until-success}を通じて@var{hookvar}が実行されたときの@code{(add-hook '@var{hookvar} @var{function} 'append)}のような1関数のフックと同等。"

#. type: item
#: original_texis/functions.texi:1878
#, no-wrap
msgid ":filter-args"
msgstr ":filter-args"

#. type: table
#: original_texis/functions.texi:1882
msgid "Call @var{function} first and use the result (which should be a list) as the new arguments to pass to the old function.  More specifically, the composition of the two functions behaves like:"
msgstr "最初に@var{function}を呼び出し、その結果(リスト)を新たな引数として古い関数に渡す。より正確に言うと2つの関数の結合は以下のように振る舞う:"

#. type: example
#: original_texis/functions.texi:1884
#, no-wrap
msgid "(lambda (&rest r) (apply @var{oldfun} (funcall @var{function} r)))\n"
msgstr "(lambda (&rest r) (apply @var{oldfun} (funcall @var{function} r)))\n"

#. type: item
#: original_texis/functions.texi:1886
#, no-wrap
msgid ":filter-return"
msgstr ":filter-return"

#. type: table
#: original_texis/functions.texi:1889
msgid "Call the old function first and pass the result to @var{function}.  More specifically, the composition of the two functions behaves like:"
msgstr "最初に古い関数を呼び出し、その結果を@var{function}に渡す。より正確に言うと2つの関数の結合は以下のように振る舞う:"

#. type: example
#: original_texis/functions.texi:1891
#, no-wrap
msgid "(lambda (&rest r) (funcall @var{function} (apply @var{oldfun} r)))\n"
msgstr "(lambda (&rest r) (funcall @var{function} (apply @var{oldfun} r)))\n"

#. type: subsection
#: original_texis/functions.texi:1896
#, no-wrap
msgid "Adapting code using the old defadvice"
msgstr "Adapting code using the old defadvice"

#. type: cindex
#: original_texis/functions.texi:1897
#, no-wrap
msgid "old advices, porting"
msgstr "old advices, porting"

#. type: cindex
#: original_texis/functions.texi:1902
#, no-wrap
msgid "advices, porting from @code{defadvice}"
msgstr "advices, porting from @code{defadvice}"

#. type: findex
#: original_texis/functions.texi:1903
#, no-wrap
msgid "defadvice"
msgstr "defadvice"

#. type: findex
#: original_texis/functions.texi:1904
#, no-wrap
msgid "ad-activate"
msgstr "ad-activate"

#. type: Plain text
#: original_texis/functions.texi:1909
msgid "A lot of code uses the old @code{defadvice} mechanism, which is largely made obsolete by the new @code{advice-add}, whose implementation and semantics is significantly simpler."
msgstr "多くのコードは古い@code{defadvice}メカニズムを使用しており、これらの大半は@code{advice-add}によって陳腐化しました。@code{advice-add}の実装とセマンティックは非常にシンプルです。"

#. type: Plain text
#: original_texis/functions.texi:1911
msgid "An old piece of advice such as:"
msgstr "古いアドバイスは以下のようなものです:"

#. type: example
#: original_texis/functions.texi:1921
#, no-wrap
msgid ""
"(defadvice previous-line (before next-line-at-end\n"
"                                 (&optional arg try-vscroll))\n"
"  \"Insert an empty line when moving up from the top line.\"\n"
"  (if (and next-line-add-newlines (= arg 1)\n"
"           (save-excursion (beginning-of-line) (bobp)))\n"
"      (progn\n"
"        (beginning-of-line)\n"
"        (newline))))\n"
msgstr ""
"(defadvice previous-line (before next-line-at-end\n"
"                                 (&optional arg try-vscroll))\n"
"  \"Insert an empty line when moving up from the top line.\"\n"
"  (if (and next-line-add-newlines (= arg 1)\n"
"           (save-excursion (beginning-of-line) (bobp)))\n"
"      (progn\n"
"        (beginning-of-line)\n"
"        (newline))))\n"

#. type: Plain text
#: original_texis/functions.texi:1924
msgid "could be translated in the new advice mechanism into a plain function:"
msgstr "新しいアドバイスメカニズムを使用すれば、これを通常の関数に変換できます:"

#. type: example
#: original_texis/functions.texi:1933
#, no-wrap
msgid ""
"(defun previous-line--next-line-at-end (&optional arg try-vscroll)\n"
"  \"Insert an empty line when moving up from the top line.\"\n"
"  (if (and next-line-add-newlines (= arg 1)\n"
"           (save-excursion (beginning-of-line) (bobp)))\n"
"      (progn\n"
"        (beginning-of-line)\n"
"        (newline))))\n"
msgstr ""
"(defun previous-line--next-line-at-end (&optional arg try-vscroll)\n"
"  \"Insert an empty line when moving up from the top line.\"\n"
"  (if (and next-line-add-newlines (= arg 1)\n"
"           (save-excursion (beginning-of-line) (bobp)))\n"
"      (progn\n"
"        (beginning-of-line)\n"
"        (newline))))\n"

#. type: Plain text
#: original_texis/functions.texi:1937
msgid "Obviously, this does not actually modify @code{previous-line}.  For that the old advice needed:"
msgstr "これが実際の@code{previous-line}を変更しないことは明確です。古いアドバイスには以下が必要です:"

#. type: example
#: original_texis/functions.texi:1939
#, no-wrap
msgid "(ad-activate 'previous-line)\n"
msgstr "(ad-activate 'previous-line)\n"

#. type: Plain text
#: original_texis/functions.texi:1941
msgid "whereas the new advice mechanism needs:"
msgstr "一方、新しいアドバイスメカニズムでは以下が必要です:"

#. type: example
#: original_texis/functions.texi:1943
#, no-wrap
msgid "(advice-add 'previous-line :before #'previous-line--next-line-at-end)\n"
msgstr "(advice-add 'previous-line :before #'previous-line--next-line-at-end)\n"

#. type: Plain text
#: original_texis/functions.texi:1950
msgid "Note that @code{ad-activate} had a global effect: it activated all pieces of advice enabled for that specified function.  If you wanted to only activate or deactivate a particular piece, you needed to @emph{enable} or @emph{disable} it with @code{ad-enable-advice} and @code{ad-disable-advice}.  The new mechanism does away with this distinction."
msgstr "@code{ad-activate}はグローバルな効果をもつことに注意してください。これは指定された関数にたいして、アドバイスのすべてを有効にします。特定のアドバイスだけをアクティブ、または非アクティブにしたいなら、@code{ad-enable-advice}か@code{ad-disable-advice}でアドバイスを@emph{有効}か@emph{無効}にする必要があります。新しいメカニズムではこの区別はなくなりました。"

#. type: Plain text
#: original_texis/functions.texi:1952
msgid "Around advice such as:"
msgstr "以下のようなaroundのアドバイスがあるとします:"

#. type: example
#: original_texis/functions.texi:1959
#, no-wrap
msgid ""
"(defadvice foo (around foo-around)\n"
"  \"Ignore case in `foo'.\"\n"
"  (let ((case-fold-search t))\n"
"    ad-do-it))\n"
"(ad-activate 'foo)\n"
msgstr ""
"(defadvice foo (around foo-around)\n"
"  \"Ignore case in `foo'.\"\n"
"  (let ((case-fold-search t))\n"
"    ad-do-it))\n"
"(ad-activate 'foo)\n"

#. type: Plain text
#: original_texis/functions.texi:1962
msgid "could translate into:"
msgstr "これは以下のように変換できます:"

#. type: example
#: original_texis/functions.texi:1969
#, no-wrap
msgid ""
"(defun foo--foo-around (orig-fun &rest args)\n"
"  \"Ignore case in `foo'.\"\n"
"  (let ((case-fold-search t))\n"
"    (apply orig-fun args)))\n"
"(advice-add 'foo :around #'foo--foo-around)\n"
msgstr ""
"(defun foo--foo-around (orig-fun &rest args)\n"
"  \"Ignore case in `foo'.\"\n"
"  (let ((case-fold-search t))\n"
"    (apply orig-fun args)))\n"
"(advice-add 'foo :around #'foo--foo-around)\n"

#. type: Plain text
#: original_texis/functions.texi:1979
msgid "Regarding the advice's @emph{class}, note that the new @code{:before} is not quite equivalent to the old @code{before}, because in the old advice you could modify the function's arguments (e.g., with @code{ad-set-arg}), and that would affect the argument values seen by the original function, whereas in the new @code{:before}, modifying an argument via @code{setq} in the advice has no effect on the arguments seen by the original function.  When porting @code{before} advice which relied on this behavior, you'll need to turn it into new @code{:around} or @code{:filter-args} advice instead."
msgstr "アドバイスの@emph{クラス}について、新たな@code{:before}は古い@code{before}は完全に等価ではないことに注意してください。なぜなら古いアドバイス内では、(たとえば@code{ad-set-arg}を使って)その関数の引数を変更でき、それは元の関数が参照する引数値に影響します。しかし新しい@code{:before}は、@code{setq}を通じてアドバイス内の引数を変更して、その変更は元の関数からの参照に影響しません。この振る舞いにもとづいて@code{before}アドバイスを移行するときは、代わりにそれを新たなアドバイス@code{:around}か@code{:filter-args}に変更する必要があるでしょう。"

#. type: Plain text
#: original_texis/functions.texi:1984
msgid "Similarly old @code{after} advice could modify the returned value by changing @code{ad-return-value}, whereas new @code{:after} advice cannot, so when porting such old @code{after} advice, you'll need to turn it into new @code{:around} or @code{:filter-return} advice instead."
msgstr "同様に古い@code{after}アドバイスは、@code{ad-return-value}を変更することによりリターン値を変更できますが、新しい@code{:after}は変更できないので、そのような@code{after}を移行するときは、かわりにそれらを新しいアドバイス@code{:around}か@code{:filter-return}に変更する必要があるでしょう。"

#. type: section
#: original_texis/functions.texi:1986
#, no-wrap
msgid "Declaring Functions Obsolete"
msgstr "Declaring Functions Obsolete"

#. type: cindex
#: original_texis/functions.texi:1987
#, no-wrap
msgid "obsolete functions"
msgstr "obsolete functions"

#. type: Plain text
#: original_texis/functions.texi:1995
msgid "You can mark a named function as @dfn{obsolete}, meaning that it may be removed at some point in the future.  This causes Emacs to warn that the function is obsolete whenever it byte-compiles code containing that function, and whenever it displays the documentation for that function.  In all other respects, an obsolete function behaves like any other function."
msgstr "名前つき関数を@dfn{陳腐化している(obsolete)}とマークすることができます。これはその関数が将来のある時点で削除されるかもしれないことを意味します。陳腐化しているとマークされた関数を含むコードをバイトコンパイルしたとき、Emacsは警告を発します。またその関数のヘルプドキュメントは表示されなくなります。他の点では陳腐化した関数は他の任意の関数と同様に振る舞います。"

#. type: Plain text
#: original_texis/functions.texi:2000
msgid "The easiest way to mark a function as obsolete is to put a @code{(declare (obsolete @dots{}))} form in the function's @code{defun} definition.  @xref{Declare Form}.  Alternatively, you can use the @code{make-obsolete} function, described below."
msgstr "関数を陳腐化しているとマークするもっとも簡単な方法は、その関数の@code{defun}定義に@code{(declare (obsolete @dots{}))}を配置することです。@ref{Declare Form}を参照してください。かわりに以下で説明している@code{make-obsolete}関数を使うこともできます。"

#. type: Plain text
#: original_texis/functions.texi:2006
msgid "A macro (@pxref{Macros}) can also be marked obsolete with @code{make-obsolete}; this has the same effects as for a function.  An alias for a function or macro can also be marked as obsolete; this makes the alias itself obsolete, not the function or macro which it resolves to."
msgstr "@code{make-obsolete}を使用してマクロ(@ref{Macros}を参照)を陳腐化しているとマークすることもできます。これは関数のときと同じ効果をもちます。関数やマクロにたいするエイリアスも、陳腐化しているとマークできます。これはエイリアス自身をマークするのであって、名前解決される関数やマクロにたいしてではありません。"

#. type: defun
#: original_texis/functions.texi:2007
#, fuzzy, no-wrap
#| msgid "make-obsolete obsolete-name current-name &optional when"
msgid "make-obsolete obsolete-name current-name when"
msgstr "make-obsolete obsolete-name current-name &optional when"

#. type: defun
#: original_texis/functions.texi:2011
msgid "This function marks @var{obsolete-name} as obsolete.  @var{obsolete-name} should be a symbol naming a function or macro, or an alias for a function or macro."
msgstr "この関数は@var{obsolete-name}を陳腐化しているとマークする。@var{obsolete-name}には関数かマクロを命名するシンボル、または関数やマクロにたいするエイリアスを指定する。"

#. type: defun
#: original_texis/functions.texi:2020
msgid "If @var{current-name} is a symbol, the warning message says to use @var{current-name} instead of @var{obsolete-name}.  @var{current-name} does not need to be an alias for @var{obsolete-name}; it can be a different function with similar functionality.  @var{current-name} can also be a string, which serves as the warning message.  The message should begin in lower case, and end with a period.  It can also be @code{nil}, in which case the warning message provides no additional details."
msgstr "@var{current-name}がシンボルなら@var{obsolete-name}のかわりに@var{current-name}の使用を促す警告メッセージになる。@var{current-name}が@var{obsolete-name}のエイリアスである必要はない。似たような機能をもつ別の関数かもしれない。@var{current-name}には警告メッセージとなる文字列も指定できる。メッセージは小文字で始まりピリオドで終わること。@code{nil}も指定でき、この場合には警告メッセージに追加の詳細は提供されない。"

#. type: defun
#: original_texis/functions.texi:2023
#, fuzzy
#| msgid "If provided, @var{when} should be a string indicating when the function was first made obsolete---for example, a date or a release number."
msgid "The argument @var{when} should be a string indicating when the function was first made obsolete---for example, a date or a release number."
msgstr "@var{when}が与えられたら、それは最初にその関数が陳腐化する時期を示す文字列 --- たとえば日付やリリース番号を指定する。"

#. type: defmac
#: original_texis/functions.texi:2025
#, fuzzy, no-wrap
#| msgid "define-obsolete-function-alias obsolete-name current-name &optional when doc"
msgid "define-obsolete-function-alias obsolete-name current-name when &optional doc"
msgstr "define-obsolete-function-alias obsolete-name current-name &optional when doc"

#. type: defmac
#: original_texis/functions.texi:2029
msgid "This convenience macro marks the function @var{obsolete-name} obsolete and also defines it as an alias for the function @var{current-name}.  It is equivalent to the following:"
msgstr "この便利なマクロは関数@var{obsolete-name}を陳腐化しているとマークして、それを関数@var{current-name}のエイリアスにする。これは以下と等価:"

#. type: example
#: original_texis/functions.texi:2033
#, no-wrap
msgid ""
"(defalias @var{obsolete-name} @var{current-name} @var{doc})\n"
"(make-obsolete @var{obsolete-name} @var{current-name} @var{when})\n"
msgstr ""
"(defalias @var{obsolete-name} @var{current-name} @var{doc})\n"
"(make-obsolete @var{obsolete-name} @var{current-name} @var{when})\n"

#. type: Plain text
#: original_texis/functions.texi:2038
msgid "In addition, you can mark a particular calling convention for a function as obsolete:"
msgstr "加えて陳腐化した関数にたいする特定の呼び出し規約をマークできます。"

#. type: defun
#: original_texis/functions.texi:2039
#, no-wrap
msgid "set-advertised-calling-convention function signature when"
msgstr "set-advertised-calling-convention function signature when"

#. type: defun
#: original_texis/functions.texi:2047
msgid "This function specifies the argument list @var{signature} as the correct way to call @var{function}.  This causes the Emacs byte compiler to issue a warning whenever it comes across an Emacs Lisp program that calls @var{function} any other way (however, it will still allow the code to be byte compiled).  @var{when} should be a string indicating when the variable was first made obsolete (usually a version number string)."
msgstr "この関数は@var{function}を呼び出す正しい方法として、引数リスト@var{signature}を指定する。これによりEmacs Lispプログラムが他の方法で@var{function}を呼び出していたら、Emacsのバイトコンパイラーが警告を発する(それでもコードはバイトコンパイルされる)。@var{when}にはその変数が最初に陳腐化するときを示す文字列(通常はバージョン番号)を指定する。"

#. type: defun
#: original_texis/functions.texi:2050
msgid "For instance, in old versions of Emacs the @code{sit-for} function accepted three arguments, like this"
msgstr "たとえば古いバージョンのEmacsでは、@code{sit-for}には以下のように3つの引数を指定していた"

#. type: example
#: original_texis/functions.texi:2053
#, no-wrap
msgid "  (sit-for seconds milliseconds nodisp)\n"
msgstr "  (sit-for seconds milliseconds nodisp)\n"

#. type: defun
#: original_texis/functions.texi:2058
msgid "However, calling @code{sit-for} this way is considered obsolete (@pxref{Waiting}).  The old calling convention is deprecated like this:"
msgstr "しかしこの方法による@code{sit-for}の呼び出しは陳腐化していると判断される(@ref{Waiting}を参照)。以下のように古い呼び出し規約は推奨されない:"

#. type: example
#: original_texis/functions.texi:2062
#, no-wrap
msgid ""
"(set-advertised-calling-convention\n"
"  'sit-for '(seconds &optional nodisp) \"22.1\")\n"
msgstr ""
"(set-advertised-calling-convention\n"
"  'sit-for '(seconds &optional nodisp) \"22.1\")\n"

#. type: cindex
#: original_texis/functions.texi:2067
#, no-wrap
msgid "inline functions"
msgstr "inline functions"

#. type: Plain text
#: original_texis/functions.texi:2073
#, fuzzy
#| msgid "An @dfn{inline function} is a function that works just like an ordinary function, except for one thing: when you byte-compile a call to the function (@pxref{Byte Compilation}), the function's definition is expanded into the caller.  To define an inline function, use @code{defsubst} instead of @code{defun}."
msgid "An @dfn{inline function} is a function that works just like an ordinary function, except for one thing: when you byte-compile a call to the function (@pxref{Byte Compilation}), the function's definition is expanded into the caller."
msgstr "@dfn{インライン関数(inline function)}は関数と同様に機能しますが、1つ例外があります。その関数の呼び出しがバイトコンパイルされると(@ref{Byte Compilation}を参照)、その関数の定義が呼び出し側に展開されます。インライン関数を定義するには、@code{defun}のかわりに@code{defsubst}を使用します。"

#. type: Plain text
#: original_texis/functions.texi:2078
msgid "The simple way to define an inline function, is to write @code{defsubst} instead of @code{defun}.  The rest of the definition looks just the same, but using @code{defsubst} says to make it inline for byte compilation."
msgstr ""

#. type: defmac
#: original_texis/functions.texi:2079
#, no-wrap
msgid "defsubst name args [doc] [declare] [interactive] body@dots{}"
msgstr "defsubst name args [doc] [declare] [interactive] body@dots{}"

#. type: defmac
#: original_texis/functions.texi:2082
msgid "This macro defines an inline function.  Its syntax is exactly the same as @code{defun} (@pxref{Defining Functions})."
msgstr "このマクロはインライン関数を定義する。マクロの構文は@code{defun}とまったく同じ(@ref{Defining Functions}を参照)。"

#. type: Plain text
#: original_texis/functions.texi:2088
msgid "Making a function inline often makes its function calls run faster.  But it also has disadvantages.  For one thing, it reduces flexibility; if you change the definition of the function, calls already inlined still use the old definition until you recompile them."
msgstr "関数をインラインにすることにより、その関数の呼び出しが高速になる場合があります、が欠点もありその1つは柔軟性の減少です。その関数の定義を変更すると、すでにインライン化された呼び出しは、リコンパイルを行うまで古い定義を使用することになります。"

#. type: Plain text
#: original_texis/functions.texi:2093
msgid "Another disadvantage is that making a large function inline can increase the size of compiled code both in files and in memory.  Since the speed advantage of inline functions is greatest for small functions, you generally should not make large functions inline."
msgstr "もう1つの欠点は、大きな関数をインライン化することにより、コンパイルされたコードのファイル上およびメモリー上のサイズが増大することです。スピード面でのインライン化の有利性は小さい関数で顕著なので、一般的に大きな関数をインライン化するべきではありません。"

#. type: Plain text
#: original_texis/functions.texi:2100
msgid "Also, inline functions do not behave well with respect to debugging, tracing, and advising (@pxref{Advising Functions}).  Since ease of debugging and the flexibility of redefining functions are important features of Emacs, you should not make a function inline, even if it's small, unless its speed is really crucial, and you've timed the code to verify that using @code{defun} actually has performance problems."
msgstr "インライン関数はデバッグ、トレース、アドバイス(@ref{Advising Functions}を参照)に際してうまく機能しません。デバッグの容易さと関数の再定義の柔軟さはEmacsの重要な機能なので、スピードがとても重要であって@code{defun}の使用が実際に性能の面で問題となるのか検証するためにすでにコードをチューニングしたのでなければ、たとえその関数が小さくてもインライン化するべきではありません。"

#. type: Plain text
#: original_texis/functions.texi:2103
msgid "After an inline function is defined, its inline expansion can be performed later on in the same file, just like macros."
msgstr "インライン関数を定義した後そのインライン展開はマクロ同様、同じファイル内の後の部分で処理されます。"

#. type: Plain text
#: original_texis/functions.texi:2114
msgid "It's possible to use @code{defmacro} to define a macro to expand into the same code that an inline function would execute (@pxref{Macros}).  But the macro would be limited to direct use in expressions---a macro cannot be called with @code{apply}, @code{mapcar} and so on.  Also, it takes some work to convert an ordinary function into a macro.  To convert it into an inline function is easy; just replace @code{defun} with @code{defsubst}.  Since each argument of an inline function is evaluated exactly once, you needn't worry about how many times the body uses the arguments, as you do for macros."
msgstr "インライン関数が実行するのと同じコードに展開されるマクロ(@ref{Macros}を参照してください)を定義するために@code{defmacro}を使用できます。しかし式内でのマクロの直接の使用には制限があります --- @code{apply}、@code{mapcar}などでマクロを呼び出すことはできません。通常の関数からマクロへの変換には余分な作業が必要になります。通常の関数をインライン関数に変換するのは簡単です。@code{defun}を@code{defsubst}に置き換えるだけです。インライン関数の引数はそれぞれ正確に1回評価されるので、マクロのときのようにbodyで引数を何回使用するかを心配する必要はありません。"

#. type: Plain text
#: original_texis/functions.texi:2118
msgid "Alternatively, you can define a function by providing the code which will inline it as a compiler macro.  The following macros make this possible."
msgstr "かわりにコンパイラーマクロとしてインライン展開されるコードを記述することにより関数を定義できます。以下のマクロがこれを可能にします。"

#. type: defmac
#: original_texis/functions.texi:2120
#, no-wrap
msgid "define-inline name args [doc] [declare] body@dots{}"
msgstr "define-inline name args [doc] [declare] body@dots{}"

#. type: defmac
#: original_texis/functions.texi:2124
msgid "Define a function @var{name} by providing code that does its inlining, as a compiler macro.  The function will accept the argument list @var{args} and will have the specified @var{body}."
msgstr "自身をインライン化するコードを提供することにより、コンパイラーマクロとして関数@var{name}を定義する。この関数は引数リスト@var{args}を受け取り、指定された@var{body}をもつ。"

#. type: defmac
#: original_texis/functions.texi:2129
msgid "If present, @var{doc} should be the function's documentation string (@pxref{Function Documentation}); @var{declare}, if present, should be a @code{declare} form (@pxref{Declare Form}) specifying the function's metadata."
msgstr "@var{doc}が与えられたなら、それは関数のドキュメント文字列であること(@ref{Function Documentation}を参照)。@var{declare}が与えられたなら、それは関数のメタデータを指定する@code{declare}フォームであること(@ref{Declare Form}を参照)。"

#. type: Plain text
#: original_texis/functions.texi:2133
msgid "Functions defined via @code{define-inline} have several advantages with respect to macros defined by @code{defsubst} or @code{defmacro}:"
msgstr "@code{define-inline}で定義された関数は、@code{defsubst}や@code{defmacro}で定義されたマクロにたいして複数の利点をもちます。"

#. type: itemize
#: original_texis/functions.texi:2137
msgid "They can be passed to @code{mapcar} (@pxref{Mapping Functions})."
msgstr "@code{mapcar}に渡すことができる(@ref{Mapping Functions}を参照)。"

#. type: itemize
#: original_texis/functions.texi:2140
msgid "They are more efficient."
msgstr "より効率的である。"

#. type: itemize
#: original_texis/functions.texi:2144
msgid "They can be used as @dfn{place forms} to store values (@pxref{Generalized Variables})."
msgstr "値を格納するための@dfn{placeフォーム(place forms)}として使用できる(@ref{Generalized Variables}を参照)。"

#. type: itemize
#: original_texis/functions.texi:2149
msgid "They behave in a more predictable way than @code{cl-defsubst} (@pxref{Argument Lists,,, cl, Common Lisp Extensions for GNU Emacs Lisp})."
msgstr "@code{cl-defsubst}より予測可能な方法で振る舞う(@ref{Argument Lists,,, cl, Common Lisp Extensions for GNU Emacs Lisp}を参照)。"

#. type: Plain text
#: original_texis/functions.texi:2154
msgid "Like @code{defmacro}, a function inlined with @code{define-inline} inherits the scoping rules, either dynamic or lexical, from the call site.  @xref{Variable Scoping}."
msgstr "@code{defmacro}と同様に、@code{define-inline}でインライン化された関数は、呼び出し側からダイナミックかレキシカルいずれかのスコーピングルールを継承します。@ref{Variable Scoping}を参照してください。"

#. type: Plain text
#: original_texis/functions.texi:2157
msgid "The following macros should be used in the body of a function defined by @code{define-inline}."
msgstr "以下のマクロは@code{define-inline}で定義された関数のbody内で使用する必要があります。"

#. type: defmac
#: original_texis/functions.texi:2158
#, no-wrap
msgid "inline-quote expression"
msgstr "inline-quote expression"

#. type: defmac
#: original_texis/functions.texi:2162
msgid "Quote @var{expression} for @code{define-inline}.  This is similar to the backquote (@pxref{Backquote}), but quotes code and accepts only @code{,}, not @code{,@@}."
msgstr "@code{define-inline}にたいして@var{expression}をクォートする。これはバッククォート(@ref{Backquote}を参照)と似ているが、コードをクォートして@code{,}だけを受け入れ、@code{,@@}は受け入れない。"

#. type: defmac
#: original_texis/functions.texi:2164
#, no-wrap
msgid "inline-letevals (bindings@dots{}) body@dots{}"
msgstr "inline-letevals (bindings@dots{}) body@dots{}"

#. type: defmac
#: original_texis/functions.texi:2174
msgid "This is similar to @code{let} (@pxref{Local Variables}): it sets up local variables as specified by @var{bindings}, and then evaluates @var{body} with those bindings in effect.  Each element of @var{bindings} should be either a symbol or a list of the form @w{@code{(@var{var} @var{expr})}}; the result is to evaluate @var{expr} and bind @var{var} to the result.  The tail of @var{bindings} can be either @code{nil} or a symbol which should hold a list of arguments, in which case each argument is evaluated, and the symbol is bound to the resulting list."
msgstr "これは@code{let} (@ref{Local Variables}を参照)と似ている。@var{bindings}で指定されたローカル変数をセットアップしてから、その効力の下で@var{body}を評価する。@var{bindings}の要素はそれぞれシンボルか@w{@code{(@var{var} @var{expr})}}という形式のリストであること。@var{expr}を評価した結果を@var{var}にバインドしたものが結果となる。@var{bindings}の終端の要素は@code{nil}か引数リストを保持するシンボルが可能。シンボルなら引数はそれぞれ評価されて結果となるリストにシンボルがバインドされる。"

#. type: defmac
#: original_texis/functions.texi:2176
#, no-wrap
msgid "inline-const-p expression"
msgstr "inline-const-p expression"

#. type: defmac
#: original_texis/functions.texi:2179
msgid "Return non-@code{nil} if the value of @var{expression} is already known."
msgstr "@var{expression}の値が既知なら非@code{nil}をリターンする。"

#. type: defmac
#: original_texis/functions.texi:2181
#, no-wrap
msgid "inline-const-val expression"
msgstr "inline-const-val expression"

#. type: defmac
#: original_texis/functions.texi:2183
msgid "Return the value of @var{expression}."
msgstr "@var{expression}の値をリターンする。"

#. type: defmac
#: original_texis/functions.texi:2185
#, no-wrap
msgid "inline-error format &rest args"
msgstr "inline-error format &rest args"

#. type: defmac
#: original_texis/functions.texi:2187
msgid "Signal an error, formatting @var{args} according to @var{format}."
msgstr "@var{format}に応じて@var{args}をフォーマットしてエラーをシグナルする。"

#. type: Plain text
#: original_texis/functions.texi:2190
msgid "Here's an example of using @code{define-inline}:"
msgstr "以下は@code{define-inline}を使用した例です:"

#. type: lisp
#: original_texis/functions.texi:2195
#, no-wrap
msgid ""
"(define-inline myaccessor (obj)\n"
"  (inline-letevals (obj)\n"
"    (inline-quote (if (foo-p ,obj) (aref (cdr ,obj) 3) (aref ,obj 2)))))\n"
msgstr ""
"(define-inline myaccessor (obj)\n"
"  (inline-letevals (obj)\n"
"    (inline-quote (if (foo-p ,obj) (aref (cdr ,obj) 3) (aref ,obj 2)))))\n"

#. type: Plain text
#: original_texis/functions.texi:2199
msgid "This is equivalent to"
msgstr "これは以下と等価です"

#. type: lisp
#: original_texis/functions.texi:2203
#, no-wrap
msgid ""
"(defsubst myaccessor (obj)\n"
"  (if (foo-p obj) (aref (cdr obj) 3) (aref obj 2)))\n"
msgstr ""
"(defsubst myaccessor (obj)\n"
"  (if (foo-p obj) (aref (cdr obj) 3) (aref obj 2)))\n"

#. type: section
#: original_texis/functions.texi:2206
#, no-wrap
msgid "The @code{declare} Form"
msgstr "The @code{declare} Form"

#. type: findex
#: original_texis/functions.texi:2207
#, no-wrap
msgid "declare"
msgstr "declare"

#. type: Plain text
#: original_texis/functions.texi:2213
msgid "@code{declare} is a special macro which can be used to add meta properties to a function or macro: for example, marking it as obsolete, or giving its forms a special @key{TAB} indentation convention in Emacs Lisp mode."
msgstr "@code{declare}(宣言)は特別なマクロで、関数やマクロにメタプロパティーを追加するために使用できます。たとえば陳腐化しているとマークしたり、Emacs Lispモード内の特別な@key{TAB}インデント規約を与えることができます。"

#. type: anchor{#1}
#: original_texis/functions.texi:2215
msgid "Definition of declare"
msgstr "Definition of declare"

#. type: defmac
#: original_texis/functions.texi:2215
#, no-wrap
msgid "declare specs@dots{}"
msgstr "declare specs@dots{}"

#. type: defmac
#: original_texis/functions.texi:2224
msgid "This macro ignores its arguments and evaluates to @code{nil}; it has no run-time effect.  However, when a @code{declare} form occurs in the @var{declare} argument of a @code{defun} or @code{defsubst} function definition (@pxref{Defining Functions}) or a @code{defmacro} macro definition (@pxref{Defining Macros}), it appends the properties specified by @var{specs} to the function or macro.  This work is specially performed by @code{defun}, @code{defsubst}, and @code{defmacro}."
msgstr "このマクロは引数を無視して@code{nil}として評価されるので、実行時の効果はない。しかし@code{defun}や@code{defsubst}(@ref{Defining Functions}を参照)、または@code{defmacro}マクロ(@ref{Defining Macros}を参照)の定義の@var{declare}引数に@code{declare}フォームがある場合は、@var{specs}で指定されたプロパティーを関数またはマクロに追加します。これは@code{defun}、@code{defsubst}、@code{defmacro}により特別に処理される。"

#. type: defmac
#: original_texis/functions.texi:2228
msgid "Each element in @var{specs} should have the form @code{(@var{property} @var{args}@dots{})}, which should not be quoted.  These have the following effects:"
msgstr "@var{specs}内の各要素は@code{(@var{property} @var{args}@dots{})}というフォームをもつこと。またそれあをクォートしないこと。これらは以下の効果をもつ:"

#. type: item
#: original_texis/functions.texi:2230
#, no-wrap
msgid "(advertised-calling-convention @var{signature} @var{when})"
msgstr "(advertised-calling-convention @var{signature} @var{when})"

#. type: table
#: original_texis/functions.texi:2235
msgid "This acts like a call to @code{set-advertised-calling-convention} (@pxref{Obsolete Functions}); @var{signature} specifies the correct argument list for calling the function or macro, and @var{when} should be a string indicating when the old argument list was first made obsolete."
msgstr "これは@code{set-advertised-calling-convention}(@ref{Obsolete Functions}を参照)の呼び出しと同じように振る舞う。@var{signature}にはその関数(またはマクロ)にたいする正しい引数リスト、@var{when}には古い引数リストが最初に陳腐化する時期を示す文字列を指定する。"

#. type: item
#: original_texis/functions.texi:2236
#, no-wrap
msgid "(debug @var{edebug-form-spec})"
msgstr "(debug @var{edebug-form-spec})"

#. type: table
#: original_texis/functions.texi:2239
msgid "This is valid for macros only.  When stepping through the macro with Edebug, use @var{edebug-form-spec}.  @xref{Instrumenting Macro Calls}."
msgstr "これはマクロだけに有効である。Edebugでそのマクロ入ったときに、@var{edebug-form-spec}を使用する。@ref{Instrumenting Macro Calls}を参照のこと。"

#. type: item
#: original_texis/functions.texi:2240
#, no-wrap
msgid "(doc-string @var{n})"
msgstr "(doc-string @var{n})"

#. type: table
#: original_texis/functions.texi:2245
msgid "This is used when defining a function or macro which itself will be used to define entities like functions, macros, or variables.  It indicates that the @var{n}th argument, if any, should be considered as a documentation string."
msgstr "自身が関数やマクロ、変数のようなエンティティーを定義するために使用されるような関数やマクロを定義するときにこれが使用される。これは@var{n}番目の引数というこを示し、もしそれがあれば、それはドキュメント文字列とみなされる。"

#. type: item
#: original_texis/functions.texi:2246
#, no-wrap
msgid "(indent @var{indent-spec})"
msgstr "(indent @var{indent-spec})"

#. type: table
#: original_texis/functions.texi:2250
msgid "Indent calls to this function or macro according to @var{indent-spec}.  This is typically used for macros, though it works for functions too.  @xref{Indenting Macros}."
msgstr "この関数(かマクロ)にたいするインデント呼び出しは、@var{indent-spec}にしたがう。これは関数でも機能するが、通常はマクロで使用される。@ref{Indenting Macros}を参照のこと。"

#. type: item
#: original_texis/functions.texi:2251
#, no-wrap
msgid "(interactive-only @var{value})"
msgstr "(interactive-only @var{value})"

#. type: table
#: original_texis/functions.texi:2254
msgid "Set the function's @code{interactive-only} property to @var{value}.  @xref{The interactive-only property}."
msgstr "その関数の@code{interactive-only}プロパティに@var{value}をセットする。@ref{The interactive-only property}を参照のこと。"

#. type: item
#: original_texis/functions.texi:2255
#, no-wrap
msgid "(obsolete @var{current-name} @var{when})"
msgstr "(obsolete @var{current-name} @var{when})"

#. type: table
#: original_texis/functions.texi:2263
msgid "Mark the function or macro as obsolete, similar to a call to @code{make-obsolete} (@pxref{Obsolete Functions}).  @var{current-name} should be a symbol (in which case the warning message says to use that instead), a string (specifying the warning message), or @code{nil} (in which case the warning message gives no extra details).  @var{when} should be a string indicating when the function or macro was first made obsolete."
msgstr "@code{make-obsolete}(@ref{Obsolete Functions}を参照)と同様に、関数(かマクロ)が陳腐化しているとマークする。@var{current-name}にはシンボル(かわりにこのシンボルを使うことを促す警告メッセージになる)、文字列(警告メッセージを指定)、または@code{nil}(警告メッセージには追加の詳細が含まれない)を指定すること。@var{when}にはその関数(かマクロ)が最初に陳腐化する時期を示す文字列を指定すること。"

#. type: item
#: original_texis/functions.texi:2264
#, no-wrap
msgid "(compiler-macro @var{expander})"
msgstr "(compiler-macro @var{expander})"

#. type: table
#: original_texis/functions.texi:2276
msgid "This can only be used for functions, and tells the compiler to use @var{expander} as an optimization function.  When encountering a call to the function, of the form @code{(@var{function} @var{args}@dots{})}, the macro expander will call @var{expander} with that form as well as with @var{args}@dots{}, and @var{expander} can either return a new expression to use instead of the function call, or it can return just the form unchanged, to indicate that the function call should be left alone.  @var{expander} can be a symbol, or it can be a form @code{(lambda (@var{arg}) @var{body})} in which case @var{arg} will hold the original function call expression, and the (unevaluated) arguments to the function can be accessed using the function's formal arguments."
msgstr "これは関数だけに使用でき、最適化関数(optimization function)として@var{expander}を使用するようコンパイラーに告げる。@code{(@var{function} @var{args}@dots{})}のようなその関数への呼び出しフォームに出会うと、マクロ展開機能(macro expander)は@var{args}@dots{}と同様のフォームで@var{expander}を呼び出す。@var{expander}はその関数呼び出しのかわりに使用するための新しい式、または変更されていないフォーム(その関数呼び出しを変更しないことを示す)のどちらかをリターンすることができる。@var{expander}にはシンボルかフォーム@code{(lambda (@var{arg}) @var{body})}を指定できる。フォームなら@var{arg}は元の関数呼び出し式を保持して、その関数の形式に適う引数を使用することにより、その関数にたいする(評価されていない)引数にアクセスができる。"

#. type: item
#: original_texis/functions.texi:2277
#, no-wrap
msgid "(gv-expander @var{expander})"
msgstr "(gv-expander @var{expander})"

#. type: table
#: original_texis/functions.texi:2283
msgid "Declare @var{expander} to be the function to handle calls to the macro (or function) as a generalized variable, similarly to @code{gv-define-expander}.  @var{expander} can be a symbol or it can be of the form @code{(lambda (@var{arg}) @var{body})} in which case that function will additionally have access to the macro (or function)'s arguments."
msgstr "@var{expander}が@code{gv-define-expander}と同様、ジェネリック変数としてマクロ(か関数)にたいする呼び出しを処理する関数であることを宣言する。@var{expander}はシンボルかフォーム@code{(lambda (@var{arg}) @var{body})}を指定できる。フォームなら、その関数は追加でそのマクロ(か関数)の引数にアクセスできる。"

#. type: item
#: original_texis/functions.texi:2284
#, no-wrap
msgid "(gv-setter @var{setter})"
msgstr "(gv-setter @var{setter})"

#. type: table
#: original_texis/functions.texi:2291
#, fuzzy
#| msgid "Declare @var{setter} to be the function to handle calls to the macro (or function) as a generalized variable.  @var{setter} can be a symbol in which case it will be passed to @code{gv-define-simple-setter}, or it can be of the form @code{(lambda (@var{arg}) @var{body})} in which case that function will additionally have access to the macro (or function)'s arguments and it will passed to @code{gv-define-setter}."
msgid "Declare @var{setter} to be the function to handle calls to the macro (or function) as a generalized variable.  @var{setter} can be a symbol in which case it will be passed to @code{gv-define-simple-setter}, or it can be of the form @code{(lambda (@var{arg}) @var{body})} in which case that function will additionally have access to the macro (or function)'s arguments and it will be passed to @code{gv-define-setter}."
msgstr "@var{setter}がジェネリック変数としてマクロ(か関数)にたいする呼び出しを処理する関数であることを宣言する。@var{setter}はシンボルかフォームを指定できる。シンボルなら、そのシンボルは@code{gv-define-simple-setter}に渡される。フォームなら@code{(lambda (@var{arg}) @var{body})}という形式で、その関数は追加でマクロ(か関数)の引数にアクセスでき、それは@code{gv-define-setter}に渡される。"

#. type: section
#: original_texis/functions.texi:2297
#, no-wrap
msgid "Telling the Compiler that a Function is Defined"
msgstr "Telling the Compiler that a Function is Defined"

#. type: cindex
#: original_texis/functions.texi:2298
#, no-wrap
msgid "function declaration"
msgstr "function declaration"

#. type: cindex
#: original_texis/functions.texi:2299
#, no-wrap
msgid "declaring functions"
msgstr "declaring functions"

#. type: findex
#: original_texis/functions.texi:2300
#, no-wrap
msgid "declare-function"
msgstr "declare-function"

#. type: Plain text
#: original_texis/functions.texi:2307
msgid "Byte-compiling a file often produces warnings about functions that the compiler doesn't know about (@pxref{Compiler Errors}).  Sometimes this indicates a real problem, but usually the functions in question are defined in other files which would be loaded if that code is run.  For example, byte-compiling @file{simple.el} used to warn:"
msgstr "あるファイルをバイトコンパイルするとき、コンパイラーが知らない関数について警告が生成されるときがあります(@ref{Compiler Errors}を参照してください)。実際に問題がある場合もありますが、問題となっている関数がそのコードの実行時にロードされる他のファイルで定義されている場合が通常です。たとえば以前は@file{simple.el}をバイトコンパイルすると以下のような警告が出ていました:"

#. type: example
#: original_texis/functions.texi:2311
#, no-wrap
msgid ""
"simple.el:8727:1:Warning: the function ‘shell-mode’ is not known to be\n"
"    defined.\n"
msgstr ""
"simple.el:8727:1:Warning: the function ‘shell-mode’ is not known to be\n"
"    defined.\n"

#. type: Plain text
#: original_texis/functions.texi:2319
msgid "In fact, @code{shell-mode} is used only in a function that executes @code{(require 'shell)} before calling @code{shell-mode}, so @code{shell-mode} will be defined properly at run-time.  When you know that such a warning does not indicate a real problem, it is good to suppress the warning.  That makes new warnings which might mean real problems more visible.  You do that with @code{declare-function}."
msgstr "実際のところ@code{shell-mode}は@code{(require 'shell)}を実行する関数内の@code{shell-mode}を呼び出す前でのみ使用されるので、@code{shell-mode}は実行時に正しく定義されるでしょう。そのような警告が実際には問題を示さないことを知っているときには警告を抑制したほうがよいでしょう。そうすれば実際に問題があることを示す新しい警告の識別性が良くなります。これは@code{declare-function}を使用して行うことができます。"

#. type: Plain text
#: original_texis/functions.texi:2322
msgid "All you need to do is add a @code{declare-function} statement before the first use of the function in question:"
msgstr "必要なのは問題となっている関数を最初に使用する前に@code{declare-function}命令を追加するだけです:"

#. type: example
#: original_texis/functions.texi:2325
#, no-wrap
msgid "(declare-function shell-mode \"shell\" ())\n"
msgstr "(declare-function shell-mode \"shell\" ())\n"

#. type: Plain text
#: original_texis/functions.texi:2330
msgid "This says that @code{shell-mode} is defined in @file{shell.el} (the @samp{.el} can be omitted).  The compiler takes for granted that that file really defines the function, and does not check."
msgstr "これは@code{shell-mode}が@file{shell.el} (@samp{.el}は省略可)の中で定義していることを告げます。コンパイラーは関数がそのファイルで実際に定義されているとみなしてチェックを行いません。"

#. type: Plain text
#: original_texis/functions.texi:2337
msgid "The optional third argument specifies the argument list of @code{shell-mode}.  In this case, it takes no arguments (@code{nil} is different from not specifying a value).  In other cases, this might be something like @code{(file &optional overwrite)}.  You don't have to specify the argument list, but if you do the byte compiler can check that the calls match the declaration."
msgstr "3つ目の引数はオプションであり@code{shell-mode}の引数リストを指定します。この例では引数はありません(@code{nil}と値を指定しないのは異なる)。それ以外の場合には@code{(file &optional overwrite)}のようになります。引数リストを指定する必要はありませんが、指定すればコンパイラーはその呼び出しが宣言と合致するかチェックできます。"

#. type: defmac
#: original_texis/functions.texi:2338
#, no-wrap
msgid "declare-function function file &optional arglist fileonly"
msgstr "declare-function function file &optional arglist fileonly"

#. type: defmac
#: original_texis/functions.texi:2349
msgid "Tell the byte compiler to assume that @var{function} is defined in the file @var{file}.  The optional third argument @var{arglist} is either @code{t}, meaning the argument list is unspecified, or a list of formal parameters in the same style as @code{defun}.  An omitted @var{arglist} defaults to @code{t}, not @code{nil}; this is atypical behavior for omitted arguments, and it means that to supply a fourth but not third argument one must specify @code{t} for the third-argument placeholder instead of the usual @code{nil}.  The optional fourth argument @var{fileonly} non-@code{nil} means check only that @var{file} exists, not that it actually defines @var{function}."
msgstr "ファイル@var{file}内で@var{function}が定義されているとみなすようにバイトコンパイラーに告げる。オプションの3つ目の引数@var{arglist}は@code{t} (引数リストが未指定という意味)、または@code{defun}と同スタイルな正式パラメーターリストのいずれか。@var{arglist}を省略した際のデフォルトは@code{nil}ではなく@code{t}。これは引数省略時の非定形な挙動であり、3つ目の引数を指定せずに4つ目引数を与える場合には通常の@code{nil}のかわりに3つ目の引数のプレースホルダーに@code{t}を指定しなければならないことを意味する。オプションの4つ目の引数@var{fileonly}が非@code{nil}なら実際に@var{function}が定義されているかではなく@var{file}の存在だけをチェックすることを意味する。"

#. type: Plain text
#: original_texis/functions.texi:2356
msgid "To verify that these functions really are declared where @code{declare-function} says they are, use @code{check-declare-file} to check all @code{declare-function} calls in one source file, or use @code{check-declare-directory} check all the files in and under a certain directory."
msgstr "これらの関数が@code{declare-function}が告げる場所で実際に宣言されているかどうかを検証するには、@code{check-declare-file}を使用して1つのソースファイル中のすべての@code{declare-function}呼び出しをチェックするか、@code{check-declare-directory}を使用して特定のディレクトリー配下のすべてのファイルをチェックする。"

#. type: Plain text
#: original_texis/functions.texi:2361
msgid "These commands find the file that ought to contain a function's definition using @code{locate-library}; if that finds no file, they expand the definition file name relative to the directory of the file that contains the @code{declare-function} call."
msgstr "これらのコマンドは、@code{locate-library}で使用する関数の定義を含むはずのファイルを探す。ファイルが見つからなければ、これらのコマンドは@code{declare-function}の呼び出しを含むファイルがあるディレクトリーからの相対ファイル名に、定義ファイル名を展開する。"

#. type: Plain text
#: original_texis/functions.texi:2366
msgid "You can also say that a function is a primitive by specifying a file name ending in @samp{.c} or @samp{.m}.  This is useful only when you call a primitive that is defined only on certain systems.  Most primitives are always defined, so they will never give you a warning."
msgstr "@samp{.c}や@samp{.m}で終わるファイル名を指定することにより、プリミティブ関数を指定することもできる。これが有用なのは特定のシステムだけで定義されるプリミティブを呼び出す場合だけである。ほとんどのプリミティブは常に定義されているので、それらについて警告を受け取ることはありえないはずである。"

#. type: Plain text
#: original_texis/functions.texi:2371
msgid "Sometimes a file will optionally use functions from an external package.  If you prefix the filename in the @code{declare-function} statement with @samp{ext:}, then it will be checked if it is found, otherwise skipped without error."
msgstr "あるファイルがオプションとして外部のパッケージの関数を使う場合もある。@code{declare-function}命令内のファイル名のプレフィクスを@samp{ext:}にすると、そのファイルが見つかった場合はチェックして、見つからない場合はエラーとせずにスキップする。"

#. type: Plain text
#: original_texis/functions.texi:2380
msgid "There are some function definitions that @samp{check-declare} does not understand (e.g., @code{defstruct} and some other macros).  In such cases, you can pass a non-@code{nil} @var{fileonly} argument to @code{declare-function}, meaning to only check that the file exists, not that it actually defines the function.  Note that to do this without having to specify an argument list, you should set the @var{arglist} argument to @code{t} (because @code{nil} means an empty argument list, as opposed to an unspecified one)."
msgstr "@samp{check-declare}が理解しない関数定義もいくつか存在する(たとえば@code{defstruct}やその他いくつかのマクロ)。そのような場合は@code{declare-function}の@var{fileonly}引数に非@code{nil}を渡すことができる。これはファイルの存在だけをチェックして、その関数の実際の定義はチェックしないことを意味する。これを行うなら引数リストを指定する必要はないが、@var{arglist}引数には@code{t}をセットする必要があることに注意(なぜなら@code{nil}は引数リストが指定されなかったという意味ではなく空の引数リストを意味するため)。"

#. type: section
#: original_texis/functions.texi:2382
#, no-wrap
msgid "Determining whether a Function is Safe to Call"
msgstr "Determining whether a Function is Safe to Call"

#. type: cindex
#: original_texis/functions.texi:2383
#, no-wrap
msgid "function safety"
msgstr "function safety"

#. type: cindex
#: original_texis/functions.texi:2384
#, no-wrap
msgid "safety of functions"
msgstr "safety of functions"

#. type: Plain text
#: original_texis/functions.texi:2392
msgid "Some major modes, such as SES, call functions that are stored in user files.  (@inforef{Top, ,ses}, for more information on SES@.)  User files sometimes have poor pedigrees---you can get a spreadsheet from someone you've just met, or you can get one through email from someone you've never met.  So it is risky to call a function whose source code is stored in a user file until you have determined that it is safe."
msgstr "SESのようないくつかのメジャーモードは、ユーザーファイル内に格納された関数を呼び出します(SESの詳細は@inforef{Top, ,ses}を参照)。 ユーザーファイルは素性があやふやな場合があります --- 初対面の人から受け取ったスプレッドシートかもしれず、会ったことのない誰かから受け取ったeメールかもしれません。そのためユーザーファイルに格納されたソースコードの関数を呼び出すのは、それが安全だと決定されるすまでは危険です。"

#. type: defun
#: original_texis/functions.texi:2393
#, no-wrap
msgid "unsafep form &optional unsafep-vars"
msgstr "unsafep form &optional unsafep-vars"

#. type: defun
#: original_texis/functions.texi:2400
msgid "Returns @code{nil} if @var{form} is a @dfn{safe} Lisp expression, or returns a list that describes why it might be unsafe.  The argument @var{unsafep-vars} is a list of symbols known to have temporary bindings at this point; it is mainly used for internal recursive calls.  The current buffer is an implicit argument, which provides a list of buffer-local bindings."
msgstr "@var{form}が@dfn{安全(safe)}なLisp式なら@code{nil}、危険ならなぜその式が危険かもしれないのか説明するリストをリターンする。引数@var{unsafep-vars}は、この時点で一時的なバインドだと判っているシンボルのリスト。これは主に内部的な再帰呼び出しで使用される。カレントバッファーは暗黙の引数になり、これはバッファーローカルなバインディングのリストを提供する。"

#. type: Plain text
#: original_texis/functions.texi:2411
msgid "Being quick and simple, @code{unsafep} does a very light analysis and rejects many Lisp expressions that are actually safe.  There are no known cases where @code{unsafep} returns @code{nil} for an unsafe expression.  However, a safe Lisp expression can return a string with a @code{display} property, containing an associated Lisp expression to be executed after the string is inserted into a buffer.  This associated expression can be a virus.  In order to be safe, you must delete properties from all strings calculated by user code before inserting them into buffers."
msgstr "高速かつシンプルにするために、@code{unsafep}は非常に軽量な分析を行うので、実際には安全な多くのLisp式を拒絶します。安全ではない式にたいして@code{unsafep}が@code{nil}をリターンするケースは確認されていません。しかし安全なLisp式は@code{display}プロパティーと一緒に文字列をリターンでき、これはその文字列がバッファーに挿入された後に実行される、割り当てられたLisp式を含むことができます。割り当てられた式はウィルスかもしれません。安全であるためにはバッファーへ挿入する前に、ユーザーコードで計算されたすべての文字列からプロパティーを削除しなければなりません。"

# grouped by @ignore.
#. type: item
#: original_texis/functions.texi:2419
#, no-wrap
msgid "Safe expression"
msgstr "Safe expression"

# grouped by @ignore.
#. type: itemize
#: original_texis/functions.texi:2423
#, no-wrap
msgid "An atom or quoted thing.\n"
msgstr "An atom or quoted thing.\n"

# grouped by @ignore.
#. type: itemize
#: original_texis/functions.texi:2426
#, no-wrap
msgid ""
"A call to a safe function (see below), if all its arguments are\n"
"safe expressions.\n"
msgstr ""
"A call to a safe function (see below), if all its arguments are\n"
"safe expressions.\n"

# grouped by @ignore.
#. type: itemize
#: original_texis/functions.texi:2431
#, no-wrap
msgid ""
"One of the special forms @code{and}, @code{catch}, @code{cond},\n"
"@code{if}, @code{or}, @code{prog1}, @code{prog2}, @code{progn},\n"
"@code{while}, and @code{unwind-protect}], if all its arguments are\n"
"safe.\n"
msgstr ""
"One of the special forms @code{and}, @code{catch}, @code{cond},\n"
"@code{if}, @code{or}, @code{prog1}, @code{prog2}, @code{progn},\n"
"@code{while}, and @code{unwind-protect}], if all its arguments are\n"
"safe.\n"

# grouped by @ignore.
#. type: itemize
#: original_texis/functions.texi:2436
#, no-wrap
msgid ""
"A form that creates temporary bindings (@code{condition-case},\n"
"@code{dolist}, @code{dotimes}, @code{lambda}, @code{let}, or\n"
"@code{let*}), if all args are safe and the symbols to be bound are not\n"
"explicitly risky (@pxref{File Local Variables}).\n"
msgstr ""
"A form that creates temporary bindings (@code{condition-case},\n"
"@code{dolist}, @code{dotimes}, @code{lambda}, @code{let}, or\n"
"@code{let*}), if all args are safe and the symbols to be bound are not\n"
"explicitly risky (@pxref{File Local Variables}).\n"

# grouped by @ignore.
#. type: itemize
#: original_texis/functions.texi:2441
#, no-wrap
msgid ""
"An assignment using @code{add-to-list}, @code{setq}, @code{push}, or\n"
"@code{pop}, if all args are safe and the symbols to be assigned are\n"
"not explicitly risky and they already have temporary or buffer-local\n"
"bindings.\n"
msgstr ""
"An assignment using @code{add-to-list}, @code{setq}, @code{push}, or\n"
"@code{pop}, if all args are safe and the symbols to be assigned are\n"
"not explicitly risky and they already have temporary or buffer-local\n"
"bindings.\n"

# grouped by @ignore.
#. type: itemize
#: original_texis/functions.texi:2444
#, no-wrap
msgid ""
"One of [apply, mapc, mapcar, mapconcat] if the first argument is a\n"
"safe explicit lambda and the other args are safe expressions.\n"
msgstr ""
"One of [apply, mapc, mapcar, mapconcat] if the first argument is a\n"
"safe explicit lambda and the other args are safe expressions.\n"

# grouped by @ignore.
#. type: item
#: original_texis/functions.texi:2446
#, no-wrap
msgid "Safe function"
msgstr "Safe function"

# grouped by @ignore.
#. type: itemize
#: original_texis/functions.texi:2450
#, no-wrap
msgid "A lambda containing safe expressions.\n"
msgstr "A lambda containing safe expressions.\n"

# grouped by @ignore.
#. type: itemize
#: original_texis/functions.texi:2452
#, no-wrap
msgid "A symbol on the list @code{safe-functions}, so the user says it's safe.\n"
msgstr "A symbol on the list @code{safe-functions}, so the user says it's safe.\n"

# grouped by @ignore.
#. type: itemize
#: original_texis/functions.texi:2454
#, no-wrap
msgid "A symbol with a non-@code{nil} @code{side-effect-free} property.\n"
msgstr "A symbol with a non-@code{nil} @code{side-effect-free} property.\n"

# grouped by @ignore.
#. type: itemize
#: original_texis/functions.texi:2459
#, no-wrap
msgid ""
"A symbol with a non-@code{nil} @code{safe-function} property.  The\n"
"value @code{t} indicates a function that is safe but has innocuous\n"
"side effects.  Other values will someday indicate functions with\n"
"classes of side effects that are not always safe.\n"
msgstr ""
"A symbol with a non-@code{nil} @code{safe-function} property.  The\n"
"value @code{t} indicates a function that is safe but has innocuous\n"
"side effects.  Other values will someday indicate functions with\n"
"classes of side effects that are not always safe.\n"

# grouped by @ignore.
#. type: table
#: original_texis/functions.texi:2465
#, no-wrap
msgid ""
"The @code{side-effect-free} and @code{safe-function} properties are\n"
"provided for built-in functions and for low-level functions and macros\n"
"defined in @file{subr.el}.  You can assign these properties for the\n"
"functions you write.\n"
msgstr ""
"The @code{side-effect-free} and @code{safe-function} properties are\n"
"provided for built-in functions and for low-level functions and macros\n"
"defined in @file{subr.el}.  You can assign these properties for the\n"
"functions you write.\n"

#. type: section
#: original_texis/functions.texi:2469
#, no-wrap
msgid "Other Topics Related to Functions"
msgstr "Other Topics Related to Functions"

#. type: Plain text
#: original_texis/functions.texi:2474
msgid "Here is a table of several functions that do things related to function calling and function definitions.  They are documented elsewhere, but we provide cross references here."
msgstr "以下のテーブルは関数呼び出しと関数定義に関連したことを行ういくつかの関数です。これらは別の場所で説明されているので、ここではクロスリファレンスを提供します。"

#. type: item
#: original_texis/functions.texi:2476
#, no-wrap
msgid "apply"
msgstr "apply"

#. type: table
#: original_texis/functions.texi:2478 original_texis/functions.texi:2499
#: original_texis/functions.texi:2505
msgid "See @ref{Calling Functions}."
msgstr "@ref{Calling Functions}を参照のこと。"

#. type: item
#: original_texis/functions.texi:2479
#, no-wrap
msgid "autoload"
msgstr "autoload"

#. type: table
#: original_texis/functions.texi:2481
msgid "See @ref{Autoload}."
msgstr "@ref{Autoload}を参照のこと。"

#. type: item
#: original_texis/functions.texi:2482
#, no-wrap
msgid "call-interactively"
msgstr "call-interactively"

#. type: table
#: original_texis/functions.texi:2484 original_texis/functions.texi:2490
msgid "See @ref{Interactive Call}."
msgstr "@ref{Interactive Call}を参照のこと。"

#. type: item
#: original_texis/functions.texi:2485
#, no-wrap
msgid "called-interactively-p"
msgstr "called-interactively-p"

#. type: table
#: original_texis/functions.texi:2487 original_texis/functions.texi:2514
msgid "See @ref{Distinguish Interactive}."
msgstr "@ref{Distinguish Interactive}を参照のこと。"

#. type: item
#: original_texis/functions.texi:2488
#, no-wrap
msgid "commandp"
msgstr "commandp"

#. type: item
#: original_texis/functions.texi:2491
#, no-wrap
msgid "documentation"
msgstr "documentation"

#. type: table
#: original_texis/functions.texi:2493
msgid "See @ref{Accessing Documentation}."
msgstr "@ref{Accessing Documentation}を参照のこと。"

#. type: item
#: original_texis/functions.texi:2494
#, no-wrap
msgid "eval"
msgstr "eval"

#. type: table
#: original_texis/functions.texi:2496
msgid "See @ref{Eval}."
msgstr "@ref{Eval}を参照のこと。"

#. type: item
#: original_texis/functions.texi:2497
#, no-wrap
msgid "funcall"
msgstr "funcall"

#. type: item
#: original_texis/functions.texi:2500
#, no-wrap
msgid "function"
msgstr "function"

#. type: table
#: original_texis/functions.texi:2502
msgid "See @ref{Anonymous Functions}."
msgstr "@ref{Anonymous Functions}を参照のこと。"

#. type: item
#: original_texis/functions.texi:2503
#, no-wrap
msgid "ignore"
msgstr "ignore"

#. type: item
#: original_texis/functions.texi:2506
#, no-wrap
msgid "indirect-function"
msgstr "indirect-function"

#. type: table
#: original_texis/functions.texi:2508
msgid "See @ref{Function Indirection}."
msgstr "@ref{Function Indirection}を参照のこと。"

#. type: item
#: original_texis/functions.texi:2509
#, no-wrap
msgid "interactive"
msgstr "interactive"

#. type: table
#: original_texis/functions.texi:2511
msgid "See @ref{Using Interactive}."
msgstr "@ref{Using Interactive}を参照のこと。"

#. type: item
#: original_texis/functions.texi:2512
#, no-wrap
msgid "interactive-p"
msgstr "interactive-p"

#. type: item
#: original_texis/functions.texi:2515
#, no-wrap
msgid "mapatoms"
msgstr "mapatoms"

#. type: table
#: original_texis/functions.texi:2517
msgid "See @ref{Creating Symbols}."
msgstr "@ref{Creating Symbols}を参照のこと。"

#. type: item
#: original_texis/functions.texi:2518
#, no-wrap
msgid "mapcar"
msgstr "mapcar"

#. type: table
#: original_texis/functions.texi:2520 original_texis/functions.texi:2526
msgid "See @ref{Mapping Functions}."
msgstr "@ref{Mapping Functions}を参照のこと。"

#. type: item
#: original_texis/functions.texi:2521
#, no-wrap
msgid "map-char-table"
msgstr "map-char-table"

#. type: table
#: original_texis/functions.texi:2523
msgid "See @ref{Char-Tables}."
msgstr "@ref{Char-Tables}を参照のこと。"

#. type: item
#: original_texis/functions.texi:2524
#, no-wrap
msgid "mapconcat"
msgstr "mapconcat"

#. type: item
#: original_texis/functions.texi:2527
#, no-wrap
msgid "undefined"
msgstr "undefined"

#. type: table
#: original_texis/functions.texi:2529
msgid "See @ref{Functions for Key Lookup}."
msgstr "@ref{Functions for Key Lookup}を参照のこと。"
