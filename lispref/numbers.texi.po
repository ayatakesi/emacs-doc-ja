# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2019-10-14 22:49+0900\n"
"PO-Revision-Date: 2019-10-17 20:34+0900\n"
"Last-Translator: Takeshi Ayanokoji <takeshi.ayanokoji@gmail.com>\n"
"Language-Team: Japanese <takeshi.ayanokoji@gmail.com>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: original_texis/numbers.texi:6 original_texis/numbers.texi:7
#, no-wrap
msgid "Numbers"
msgstr "Numbers"

#. type: cindex
#: original_texis/numbers.texi:8
#, no-wrap
msgid "integers"
msgstr "integers"

#. type: cindex
#: original_texis/numbers.texi:9
#, no-wrap
msgid "numbers"
msgstr "numbers"

#. type: Plain text
#: original_texis/numbers.texi:20
msgid "GNU Emacs supports two numeric data types: @dfn{integers} and @dfn{floating-point numbers}.  Integers are whole numbers such as @minus{}3, 0, 7, 13, and 511.  Floating-point numbers are numbers with fractional parts, such as @minus{}4.5, 0.0, and 2.71828.  They can also be expressed in exponential notation: @samp{1.5e2} is the same as @samp{150.0}; here, @samp{e2} stands for ten to the second power, and that is multiplied by 1.5.  Integer computations are exact, though they may overflow.  Floating-point computations often involve rounding errors, as the numbers have a fixed amount of precision."
msgstr "GNU Emacsは2つの数値データ型 --- @dfn{整数(integers)}と@dfn{浮動小数点数(floating-point numbers)}をサポートします。整数は@minus{}3、0、7、13、511などの整数です。浮動小数点数は@minus{}4.5、0.0、2.71828などの小数部をもちます。これらは指数記数法でも表現できます --- @samp{1.5e2}は@samp{150.0}と同じです。ここで@samp{e2}は10の2乗を表し、それに1.5を乗じるという意味です。整数計算はオーバーフローするときもありますが正確です。浮動小数点数の計算にでは、数値は固定された精度をもつので、しばしば丸め誤差(rounding errors)が発生します。"

#. type: section
#: original_texis/numbers.texi:32 original_texis/numbers.texi:34
#: original_texis/numbers.texi:35
#, no-wrap
msgid "Integer Basics"
msgstr "Integer Basics"

#. type: menuentry
#: original_texis/numbers.texi:32
msgid "Representation and range of integers."
msgstr "整数の表現と範囲。"

#. type: node
#: original_texis/numbers.texi:32 original_texis/numbers.texi:196
#, no-wrap
msgid "Float Basics"
msgstr "Float Basics"

#. type: menuentry
#: original_texis/numbers.texi:32
msgid "Representation and range of floating point."
msgstr "浮動少数の表現と範囲。"

#. type: node
#: original_texis/numbers.texi:32 original_texis/numbers.texi:297
#, no-wrap
msgid "Predicates on Numbers"
msgstr "Predicates on Numbers"

#. type: menuentry
#: original_texis/numbers.texi:32
msgid "Testing for numbers."
msgstr "数にたいするテスト。"

#. type: section
#: original_texis/numbers.texi:32 original_texis/numbers.texi:341
#: original_texis/numbers.texi:342
#, no-wrap
msgid "Comparison of Numbers"
msgstr "Comparison of Numbers"

#. type: menuentry
#: original_texis/numbers.texi:32
msgid "Equality and inequality predicates."
msgstr "同一性と非同一性の述語。"

#. type: section
#: original_texis/numbers.texi:32 original_texis/numbers.texi:458
#: original_texis/numbers.texi:459
#, no-wrap
msgid "Numeric Conversions"
msgstr "Numeric Conversions"

#. type: menuentry
#: original_texis/numbers.texi:32
msgid "Converting float to integer and vice versa."
msgstr "浮動小数点数から整数の変換と逆変換。"

#. type: section
#: original_texis/numbers.texi:32 original_texis/numbers.texi:553
#: original_texis/numbers.texi:554
#, no-wrap
msgid "Arithmetic Operations"
msgstr "Arithmetic Operations"

#. type: menuentry
#: original_texis/numbers.texi:32
msgid "How to add, subtract, multiply and divide."
msgstr "加減乗除の方法。"

#. type: section
#: original_texis/numbers.texi:32 original_texis/numbers.texi:783
#: original_texis/numbers.texi:784
#, no-wrap
msgid "Rounding Operations"
msgstr "Rounding Operations"

#. type: menuentry
#: original_texis/numbers.texi:32
msgid "Explicitly rounding floating-point numbers."
msgstr "浮動小数点数の明示的な丸め。"

#. type: node
#: original_texis/numbers.texi:32 original_texis/numbers.texi:815
#, no-wrap
msgid "Bitwise Operations"
msgstr "Bitwise Operations"

#. type: menuentry
#: original_texis/numbers.texi:32
msgid "Logical and, or, not, shifting."
msgstr "論理的なand、or、not、shift。"

#. type: node
#: original_texis/numbers.texi:32 original_texis/numbers.texi:1114
#, no-wrap
msgid "Math Functions"
msgstr "Math Functions"

#. type: menuentry
#: original_texis/numbers.texi:32
msgid "Trig, exponential and logarithmic functions."
msgstr "三角関数、指数、対数関数。"

#. type: section
#: original_texis/numbers.texi:32 original_texis/numbers.texi:1218
#: original_texis/numbers.texi:1219
#, no-wrap
msgid "Random Numbers"
msgstr "Random Numbers"

#. type: menuentry
#: original_texis/numbers.texi:32
msgid "Obtaining random integers, predictable or not."
msgstr "予測可能または不可能な乱数の取得。"

#. type: Plain text
#: original_texis/numbers.texi:39
msgid "The range of values for an integer depends on the machine.  The minimum range is @minus{}536,870,912 to 536,870,911 (30 bits; i.e.,"
msgstr "整数の値の範囲はマシンに依存します。最小の範囲は@minus{}536,870,912から536,870,911(30ビット長の"

#. type: ifnottex
#: original_texis/numbers.texi:41 original_texis/numbers.texi:178
msgid "@minus{}2**29"
msgstr "@minus{}2**29"

#. type: tex
#: original_texis/numbers.texi:44 original_texis/numbers.texi:181
#, no-wrap
msgid "@math{-2^{29}}\n"
msgstr "@math{-2^{29}}\n"

#. type: Plain text
#: original_texis/numbers.texi:46
msgid "to"
msgstr "から"

#. type: ifnottex
#: original_texis/numbers.texi:48
msgid "2**29 @minus{} 1),"
msgstr "2**29 @minus{} 1)"

#. type: tex
#: original_texis/numbers.texi:51
#, no-wrap
msgid "@math{2^{29}-1}),\n"
msgstr "@math{2^{29}-1})\n"

#. type: Plain text
#: original_texis/numbers.texi:54
msgid "but many machines provide a wider range.  Many examples in this chapter assume the minimum integer width of 30 bits."
msgstr "ですが、多くのマシンはこれより広い範囲を提供します。このチャプターの例の多くは、最小の整数が30ビット長であると仮定します。"

#. type: cindex
#: original_texis/numbers.texi:54
#, no-wrap
msgid "overflow"
msgstr "overflow"

#. type: Plain text
#: original_texis/numbers.texi:59
msgid "The Lisp reader reads an integer as a sequence of digits with optional initial sign and optional final period.  An integer that is out of the Emacs range is treated as a floating-point number."
msgstr "Lispリーダーは、数字のシーケンス(オプションで最初の符号記号と最後のピリオドをともなう)として整数を読み取ります。Emacsの範囲を超える整数は浮動小数点数として扱われます。"

#. type: example
#: original_texis/numbers.texi:69
#, no-wrap
msgid ""
" 1               ; @r{The integer 1.}\n"
" 1.              ; @r{The integer 1.}\n"
"+1               ; @r{Also the integer 1.}\n"
"-1               ; @r{The integer @minus{}1.}\n"
" 9000000000000000000\n"
"                 ; @r{The floating-point number 9e18.}\n"
" 0               ; @r{The integer 0.}\n"
"-0               ; @r{The integer 0.}\n"
msgstr ""
" 1               ; @r{整数1}\n"
" 1.              ; @r{整数1}\n"
"+1               ; @r{これも整数1}\n"
"-1               ; @r{整数@minus{}1}\n"
" 9000000000000000000\n"
"                 ; @r{浮動小数点数9e18}\n"
" 0               ; @r{整数0}\n"
"-0               ; @r{整数0}\n"

#. type: cindex
#: original_texis/numbers.texi:71
#, no-wrap
msgid "integers in specific radix"
msgstr "integers in specific radix"

#. type: cindex
#: original_texis/numbers.texi:72
#, no-wrap
msgid "radix for reading an integer"
msgstr "radix for reading an integer"

#. type: cindex
#: original_texis/numbers.texi:73
#, no-wrap
msgid "base for reading an integer"
msgstr "base for reading an integer"

#. type: cindex
#: original_texis/numbers.texi:74
#, no-wrap
msgid "hex numbers"
msgstr "hex numbers"

#. type: cindex
#: original_texis/numbers.texi:75
#, no-wrap
msgid "octal numbers"
msgstr "octal numbers"

#. type: cindex
#: original_texis/numbers.texi:76
#, no-wrap
msgid "reading numbers in hex, octal, and binary"
msgstr "reading numbers in hex, octal, and binary"

#. type: Plain text
#: original_texis/numbers.texi:85
msgid "The syntax for integers in bases other than 10 uses @samp{#} followed by a letter that specifies the radix: @samp{b} for binary, @samp{o} for octal, @samp{x} for hex, or @samp{@var{radix}r} to specify radix @var{radix}.  Case is not significant for the letter that specifies the radix.  Thus, @samp{#b@var{integer}} reads @var{integer} in binary, and @samp{#@var{radix}r@var{integer}} reads @var{integer} in radix @var{radix}.  Allowed values of @var{radix} run from 2 to 36.  For example:"
msgstr "基数が10以外の整数の構文では@samp{#}の後に基数を指定する文字 --- 2進は@samp{b}、8進は@samp{o}、16進は@samp{x}、@samp{@var{radix}r}は基数@var{radix} --- を記述します。基数を指定する文字のcaseは区別されません。したがって@samp{#b@var{integer}}は@var{integer}を2進として読み取り、@samp{#@var{radix}r@var{integer}}は@var{integer}を基数@var{radix}として読み取ります。@var{radix}に指定できる値は2から36です。たとえば:"

#. type: example
#: original_texis/numbers.texi:91
#, no-wrap
msgid ""
"#b101100 @result{} 44\n"
"#o54 @result{} 44\n"
"#x2c @result{} 44\n"
"#24r1k @result{} 44\n"
msgstr ""
"#b101100 @result{} 44\n"
"#o54 @result{} 44\n"
"#x2c @result{} 44\n"
"#24r1k @result{} 44\n"

#. type: Plain text
#: original_texis/numbers.texi:96
msgid "To understand how various functions work on integers, especially the bitwise operators (@pxref{Bitwise Operations}), it is often helpful to view the numbers in their binary form."
msgstr "整数にたいして処理を行なうさまざまな関数、特にビット演算(@ref{Bitwise Operations}を参照)を理解するためには、数を2進形式で見ることが助けになることがよくあります。"

#. type: Plain text
#: original_texis/numbers.texi:98
msgid "In 30-bit binary, the decimal integer 5 looks like this:"
msgstr "30ビットの2進では10進数の整数5は以下のようになります:"

#. type: example
#: original_texis/numbers.texi:101
#, no-wrap
msgid "0000...000101 (30 bits total)\n"
msgstr "0000...000101 (全部で30ビット)\n"

#. type: Plain text
#: original_texis/numbers.texi:107
msgid "(The @samp{...} stands for enough bits to fill out a 30-bit word; in this case, @samp{...} stands for twenty 0 bits.  Later examples also use the @samp{...} notation to make binary integers easier to read.)"
msgstr "(@samp{...}は30ビットのワードを満たすのに充分なビットを意味しており、この場合の@samp{...}は12個の0ビットを意味する。以下の例でも2進の整数を読みやすくするために、@samp{...}の表記を使用している。)"

#. type: Plain text
#: original_texis/numbers.texi:109
msgid "The integer @minus{}1 looks like this:"
msgstr "整数の@minus{}1は以下のようになります:"

#. type: example
#: original_texis/numbers.texi:112
#, no-wrap
msgid "1111...111111 (30 bits total)\n"
msgstr "1111...111111 (全部で30ビット)\n"

#. type: cindex
#: original_texis/numbers.texi:115
#, no-wrap
msgid "two's complement"
msgstr "two's complement"

#. type: Plain text
#: original_texis/numbers.texi:118
msgid "@minus{}1 is represented as 30 ones.  (This is called @dfn{two's complement} notation.)"
msgstr "@minus{}1は30個の1で表現されます(@dfn{2の補数}表記と呼ばれる)。"

#. type: Plain text
#: original_texis/numbers.texi:122
msgid "Subtracting 4 from @minus{}1 returns the negative integer @minus{}5.  In binary, the decimal integer 4 is 100.  Consequently, @minus{}5 looks like this:"
msgstr "@minus{}1から4を減じることで負の整数@minus{}5が得られます。10進の整数4は2進では100です。したがって@minus{}5は以下のようになります:"

#. type: example
#: original_texis/numbers.texi:125
#, no-wrap
msgid "1111...111011 (30 bits total)\n"
msgstr "1111...111011 (全部で30ビット)\n"

#. type: Plain text
#: original_texis/numbers.texi:129
msgid "In this implementation, the largest 30-bit binary integer is 536,870,911 in decimal.  In binary, it looks like this:"
msgstr "この実装では、0ビットの2進の最大は10進の536,870,911です。これは2進では以下のようになります:"

#. type: example
#: original_texis/numbers.texi:132
#, no-wrap
msgid "0111...111111 (30 bits total)\n"
msgstr "0111...111111 (全部で30ビット)\n"

#. type: Plain text
#: original_texis/numbers.texi:137
msgid "Since the arithmetic functions do not check whether integers go outside their range, when you add 1 to 536,870,911, the value is the negative integer @minus{}536,870,912:"
msgstr "算術関数は整数が範囲外かどうかをチェックしないので、536,870,911に1を加えるとその値は負の整数@minus{}536,870,912になります:"

#. type: example
#: original_texis/numbers.texi:142
#, no-wrap
msgid ""
"(+ 1 536870911)\n"
"     @result{} -536870912\n"
"     @result{} 1000...000000 (30 bits total)\n"
msgstr ""
"(+ 1 536870911)\n"
"     @result{} -536870912\n"
"     @result{} 1000...000000 (全部で30ビット)\n"

#. type: Plain text
#: original_texis/numbers.texi:149
msgid "Many of the functions described in this chapter accept markers for arguments in place of numbers.  (@xref{Markers}.)  Since the actual arguments to such functions may be either numbers or markers, we often give these arguments the name @var{number-or-marker}.  When the argument value is a marker, its position value is used and its buffer is ignored."
msgstr "このチャプターで説明する多くの関数は、数字の位置として引数にマーカー(@ref{Markers}を参照)を受け取ります。そのような関数にたいする実際の引数は数字かマーカーなので、わたしたちはこれらの引数に@var{number-or-marker}という名前を与えることがあります。引数の値がマーカーならマーカーの位置が使用され、マーカーのバッファーは無視されます。"

#. type: cindex
#: original_texis/numbers.texi:150
#, no-wrap
msgid "largest Lisp integer"
msgstr "largest Lisp integer"

#. type: cindex
#: original_texis/numbers.texi:151
#, no-wrap
msgid "maximum Lisp integer"
msgstr "maximum Lisp integer"

#. type: defvar
#: original_texis/numbers.texi:152
#, no-wrap
msgid "most-positive-fixnum"
msgstr "most-positive-fixnum"

#. type: defvar
#: original_texis/numbers.texi:155
msgid "The value of this variable is the largest integer that Emacs Lisp can handle.  Typical values are"
msgstr "この変数の値はEmacs Lispが扱える整数の最大値。典型的な値は32ビットでは"

#. type: ifnottex
#: original_texis/numbers.texi:157
msgid "2**29 @minus{} 1"
msgstr "2**29 @minus{} 1"

#. type: tex
#: original_texis/numbers.texi:160
#, no-wrap
msgid "@math{2^{29}-1}\n"
msgstr "@math{2^{29}-1}\n"

#. type: defvar
#: original_texis/numbers.texi:162 original_texis/numbers.texi:183
msgid "on 32-bit and"
msgstr "、64ビットでは"

#. type: ifnottex
#: original_texis/numbers.texi:164
msgid "2**61 @minus{} 1"
msgstr "2**61 @minus{} 1"

#. type: tex
#: original_texis/numbers.texi:167
#, no-wrap
msgid "@math{2^{61}-1}\n"
msgstr "@math{2^{61}-1}\n"

#. type: defvar
#: original_texis/numbers.texi:169 original_texis/numbers.texi:190
msgid "on 64-bit platforms."
msgstr "。"

#. type: cindex
#: original_texis/numbers.texi:171
#, no-wrap
msgid "smallest Lisp integer"
msgstr "smallest Lisp integer"

#. type: cindex
#: original_texis/numbers.texi:172
#, no-wrap
msgid "minimum Lisp integer"
msgstr "minimum Lisp integer"

#. type: defvar
#: original_texis/numbers.texi:173
#, no-wrap
msgid "most-negative-fixnum"
msgstr "most-negative-fixnum"

#. type: defvar
#: original_texis/numbers.texi:176
msgid "The value of this variable is the smallest integer that Emacs Lisp can handle.  It is negative.  Typical values are"
msgstr "この変数の値はEmacs Lispが扱える最小の整数。これは負の整数になる。典型的な値は32ビットでは"

#. type: ifnottex
#: original_texis/numbers.texi:185
msgid "@minus{}2**61"
msgstr "@minus{}2**61、"

#. type: tex
#: original_texis/numbers.texi:188
#, no-wrap
msgid "@math{-2^{61}}\n"
msgstr "@math{-2^{61}}、\n"

#. type: Plain text
#: original_texis/numbers.texi:195
msgid "In Emacs Lisp, text characters are represented by integers.  Any integer between zero and the value of @code{(max-char)}, inclusive, is considered to be valid as a character.  @xref{Character Codes}."
msgstr "Emacs Lispでは、テキスト文字は整数により表現されます。0から@code{(max-char)}までの整数は、有効な文字として判断されます。@ref{Character Codes}を参照してください。"

#. type: section
#: original_texis/numbers.texi:197
#, no-wrap
msgid "Floating-Point Basics"
msgstr "Floating-Point Basics"

#. type: cindex
#: original_texis/numbers.texi:199
#, no-wrap
msgid "@acronym{IEEE} floating point"
msgstr "@acronym{IEEE} floating point"

#. type: Plain text
#: original_texis/numbers.texi:205
msgid "Floating-point numbers are useful for representing numbers that are not integral.  The range of floating-point numbers is the same as the range of the C data type @code{double} on the machine you are using.  On all computers currently supported by Emacs, this is double-precision @acronym{IEEE} floating point."
msgstr "浮動小数点数は整数ではない数を表現するのに有用です。浮動小数点数の範囲は、使用しているマシンでのCデータ型の@code{double}と同じ範囲です。Emacsで現在サポートされているすべてのコンピューターでは、これは倍精度の@acronym{IEEE}浮動小数点数です。"

#. type: Plain text
#: original_texis/numbers.texi:214
msgid "The read syntax for floating-point numbers requires either a decimal point, an exponent, or both.  Optional signs (@samp{+} or @samp{-})  precede the number and its exponent.  For example, @samp{1500.0}, @samp{+15e2}, @samp{15.0e+2}, @samp{+1500000e-3}, and @samp{.15e4} are five ways of writing a floating-point number whose value is 1500.  They are all equivalent.  Like Common Lisp, Emacs Lisp requires at least one digit after any decimal point in a floating-point number; @samp{1500.} is an integer, not a floating-point number."
msgstr "浮動小数点数にたいする入力構文は、小数点と指数のどちらか1つ、または両方が必要とします。オプションの符号(@samp{+}か@samp{-})は、その数字と指数の前に記述します。たとえば@samp{1500.0}、@samp{+15e2}、@samp{15.0e+2}、@samp{+1500000e-3}、@samp{.15e4}は値が1500の浮動小数点数を記述する5つの方法です。これらはすべて等価です。Common Lispと同様、Emacs Lispは浮動小数点数の小数点の後に少なくとも1つの数字を必要とします。@samp{1500.}は整数であって浮動小数点数ではありません。"

#. type: Plain text
#: original_texis/numbers.texi:220
msgid "Emacs Lisp treats @code{-0.0} as numerically equal to ordinary zero with respect to @code{equal} and @code{=}.  This follows the @acronym{IEEE} floating-point standard, which says @code{-0.0} and @code{0.0} are numerically equal even though other operations can distinguish them."
msgstr "Emacs Lispは@code{equal}と@code{=}に関して、@code{-0.0}を通常の0と数学的に同じものとして扱います。これは、(他の処理がこれらを区別にしても@code{-0.0}と@code{0.0}は数学的に等しいとする)@acronym{IEEE}浮動小数点数規格にしたがっています。"

#. type: cindex
#: original_texis/numbers.texi:221
#, no-wrap
msgid "positive infinity"
msgstr "positive infinity"

#. type: cindex
#: original_texis/numbers.texi:222
#, no-wrap
msgid "negative infinity"
msgstr "negative infinity"

#. type: item
#: original_texis/numbers.texi:223 original_texis/numbers.texi:236
#, no-wrap
msgid "infinity"
msgstr "infinity"

#. type: cindex
#: original_texis/numbers.texi:224
#, no-wrap
msgid "NaN"
msgstr "NaN"

#. type: Plain text
#: original_texis/numbers.texi:232
msgid "The @acronym{IEEE} floating-point standard supports positive infinity and negative infinity as floating-point values.  It also provides for a class of values called NaN, or ``not a number''; numerical functions return such values in cases where there is no correct answer.  For example, @code{(/ 0.0 0.0)} returns a NaN@.  Although NaN values carry a sign, for practical purposes there is no other significant difference between different NaN values in Emacs Lisp."
msgstr "@acronym{IEEE}浮動小数点数規格は浮動小数点数として、正の無限大と負の無限大をサポートします。この規格はNaNまたは``not a number(数字ではない)''と呼ばれる値クラスも提供します。正しい答えが存在しないような場合に、数学関数はこのような値をリターンします。たとえば@code{(/ 0.0 0.0)}はNaNをリターンします。実用に際し、たとえNaN値に符号がついていたとしても、Emacs Lispでは異なるNaN値に有意な差はありません。"

#. type: Plain text
#: original_texis/numbers.texi:234
msgid "Here are read syntaxes for these special floating-point values:"
msgstr "以下は、これらの特別な浮動小数点数にたいする入力構文です:"

#. type: table
#: original_texis/numbers.texi:238
msgid "@samp{1.0e+INF} and @samp{-1.0e+INF}"
msgstr "@samp{1.0e+INF}と@samp{-1.0e+INF}"

#. type: item
#: original_texis/numbers.texi:238
#, no-wrap
msgid "not-a-number"
msgstr "not-a-number"

#. type: table
#: original_texis/numbers.texi:240
msgid "@samp{0.0e+NaN} and @samp{-0.0e+NaN}"
msgstr "@samp{0.0e+NaN}と@samp{-0.0e+NaN}"

#. type: Plain text
#: original_texis/numbers.texi:244
msgid "The following functions are specialized for handling floating-point numbers:"
msgstr "以下の関数は浮動小数点数を扱うために特化したものです:"

#. type: defun
#: original_texis/numbers.texi:245
#, no-wrap
msgid "isnan x"
msgstr "isnan x"

#. type: defun
#: original_texis/numbers.texi:248
msgid "This predicate returns @code{t} if its floating-point argument is a NaN, @code{nil} otherwise."
msgstr "この述語は浮動小数引数がNaNなら@code{t}、それ以外は@code{nil}をリターンする。"

#. type: defun
#: original_texis/numbers.texi:250
#, no-wrap
msgid "frexp x"
msgstr "frexp x"

#. type: defun
#: original_texis/numbers.texi:254
msgid "This function returns a cons cell @code{(@var{s} . @var{e})}, where @var{s} and @var{e} are respectively the significand and exponent of the floating-point number @var{x}."
msgstr "この関数はコンスセル@code{(@var{s} . @var{e})}をリターンする。ここで@var{s}と@var{e}は、浮動小数点数の仮数(浮動小数点数を2の指数表現したときの仮数)と指数である。"

#. type: defun
#: original_texis/numbers.texi:257
msgid "If @var{x} is finite, then @var{s} is a floating-point number between 0.5 (inclusive) and 1.0 (exclusive), @var{e} is an integer, and"
msgstr "@var{x}が有限なら@var{s}は0.5以上1.0未満の浮動小数点数、@var{e}は整数で、"

#. type: ifnottex
#: original_texis/numbers.texi:259
msgid "@var{x} = @var{s} * 2**@var{e}."
msgstr "@var{x} = @var{s} * 2**@var{e}となる。"

#. type: tex
#: original_texis/numbers.texi:262
#, no-wrap
msgid "@math{x = s 2^e}.\n"
msgstr "@math{x = s 2^e}となる。\n"

#. type: defun
#: original_texis/numbers.texi:266
msgid "If @var{x} is zero or infinity, then @var{s} is the same as @var{x}.  If @var{x} is a NaN, then @var{s} is also a NaN@.  If @var{x} is zero, then @var{e} is 0."
msgstr "@var{x}が0または無限なら@var{s}は@var{x}と等しくなる。@var{x}がNaNなら@var{s}もNaN。@var{x}が0なら@var{e}は0。"

#. type: defun
#: original_texis/numbers.texi:268
#, no-wrap
msgid "ldexp s e"
msgstr "ldexp s e"

#. type: defun
#: original_texis/numbers.texi:271
msgid "Given a numeric significand @var{s} and an integer exponent @var{e}, this function returns the floating point number"
msgstr "数値の仮数@var{s}と整数の指数@var{e}を与えられると、この関数は浮動小数点数"

#. type: ifnottex
#: original_texis/numbers.texi:273
msgid "@var{s} * 2**@var{e}."
msgstr "@var{s} * 2**@var{e}をリターンする。"

#. type: tex
#: original_texis/numbers.texi:276
#, no-wrap
msgid "@math{s 2^e}.\n"
msgstr "@math{s 2^e}をリターンする。\n"

#. type: defun
#: original_texis/numbers.texi:279
#, no-wrap
msgid "copysign x1 x2"
msgstr "copysign x1 x2"

#. type: defun
#: original_texis/numbers.texi:282
msgid "This function copies the sign of @var{x2} to the value of @var{x1}, and returns the result.  @var{x1} and @var{x2} must be floating point."
msgstr "この関数は@var{x2}の符号を@var{x1}の値にコピーして結果をリターンする。@var{x1}と@var{x2}は浮動小数でなければならない。"

#. type: defun
#: original_texis/numbers.texi:284
#, no-wrap
msgid "logb x"
msgstr "logb x"

#. type: defun
#: original_texis/numbers.texi:288
msgid "This function returns the binary exponent of @var{x}.  More precisely, the value is the logarithm base 2 of @math{|x|}, rounded down to an integer."
msgstr "この関数は@var{x}の2進指数をリターンする。より正確には、これは@math{|x|}の2を底とする対数を整数に切り下げた値。"

#. type: example
#: original_texis/numbers.texi:294
#, no-wrap
msgid ""
"(logb 10)\n"
"     @result{} 3\n"
"(logb 10.0e20)\n"
"     @result{} 69\n"
msgstr ""
"(logb 10)\n"
"     @result{} 3\n"
"(logb 10.0e20)\n"
"     @result{} 69\n"

#. type: section
#: original_texis/numbers.texi:298
#, no-wrap
msgid "Type Predicates for Numbers"
msgstr "Type Predicates for Numbers"

#. type: cindex
#: original_texis/numbers.texi:299
#, no-wrap
msgid "predicates for numbers"
msgstr "predicates for numbers"

#. type: Plain text
#: original_texis/numbers.texi:307
msgid "The functions in this section test for numbers, or for a specific type of number.  The functions @code{integerp} and @code{floatp} can take any type of Lisp object as argument (they would not be of much use otherwise), but the @code{zerop} predicate requires a number as its argument.  See also @code{integer-or-marker-p} and @code{number-or-marker-p}, in @ref{Predicates on Markers}."
msgstr "このセクションの関数は数値や、特定の数値型にたいしてテストを行ないます。関数@code{integerp}と@code{floatp}は、引数として任意のLispオブジェクト型をとることができます(でなければ、あまり使用する機会ない)。しかし述語@code{zerop}は引数として数値を要求します。@ref{Predicates on Markers}の@code{integer-or-marker-p}、@code{number-or-marker-p}も参照してください。"

#. type: defun
#: original_texis/numbers.texi:308
#, no-wrap
msgid "floatp object"
msgstr "floatp object"

#. type: defun
#: original_texis/numbers.texi:311
msgid "This predicate tests whether its argument is floating point and returns @code{t} if so, @code{nil} otherwise."
msgstr "この述語は引数が浮動小数かどうかをテストしてもしそうなら@code{t}、それ以外は@code{nil}をリターンする。"

#. type: defun
#: original_texis/numbers.texi:313
#, no-wrap
msgid "integerp object"
msgstr "integerp object"

#. type: defun
#: original_texis/numbers.texi:316
msgid "This predicate tests whether its argument is an integer, and returns @code{t} if so, @code{nil} otherwise."
msgstr "この述語は引数が整数かどうかをテストしてもしそうなら@code{t}、それ以外は@code{nil}をリターンする。"

#. type: defun
#: original_texis/numbers.texi:318
#, no-wrap
msgid "numberp object"
msgstr "numberp object"

#. type: defun
#: original_texis/numbers.texi:321
msgid "This predicate tests whether its argument is a number (either integer or floating point), and returns @code{t} if so, @code{nil} otherwise."
msgstr "この述語は引数が数(整数か浮動小数)かどうかをテストしてもしそうなら@code{t}、それ以外は@code{nil}をリターンする。"

#. type: defun
#: original_texis/numbers.texi:323
#, no-wrap
msgid "natnump object"
msgstr "natnump object"

#. type: cindex
#: original_texis/numbers.texi:324
#, no-wrap
msgid "natural numbers"
msgstr "natural numbers"

#. type: defun
#: original_texis/numbers.texi:329
msgid "This predicate (whose name comes from the phrase ``natural number'')  tests to see whether its argument is a nonnegative integer, and returns @code{t} if so, @code{nil} otherwise.  0 is considered non-negative."
msgstr "この述語は引数が正の整数かどうかをテストしてもしそうなら@code{t}、それ以外は@code{nil}をリターンする(名前は``natural numberl: 自然数''が由来)。0は整数と判断される。"

#. type: findex
#: original_texis/numbers.texi:330
#, no-wrap
msgid "wholenump"
msgstr "wholenump"

#. type: defun
#: original_texis/numbers.texi:332
msgid "@code{wholenump} is a synonym for @code{natnump}."
msgstr "@code{wholenump}は@code{natnump}のシノニム。"

#. type: defun
#: original_texis/numbers.texi:334
#, no-wrap
msgid "zerop number"
msgstr "zerop number"

#. type: defun
#: original_texis/numbers.texi:337
msgid "This predicate tests whether its argument is zero, and returns @code{t} if so, @code{nil} otherwise.  The argument must be a number."
msgstr "この述語は引数が0かどうかをテストしてもしそうなら@code{t}、それ以外は@code{nil}をリターンする。引数は数でなければならない。"

#. type: defun
#: original_texis/numbers.texi:339
msgid "@code{(zerop x)} is equivalent to @code{(= x 0)}."
msgstr "@code{(zerop x)}は@code{(= x 0)}と等価。"

#. type: cindex
#: original_texis/numbers.texi:343
#, no-wrap
msgid "number comparison"
msgstr "number comparison"

#. type: cindex
#: original_texis/numbers.texi:344
#, no-wrap
msgid "comparing numbers"
msgstr "comparing numbers"

#. type: Plain text
#: original_texis/numbers.texi:352
msgid "To test numbers for numerical equality, you should normally use @code{=}, not @code{eq}.  There can be many distinct floating-point objects with the same numeric value.  If you use @code{eq} to compare them, then you test whether two values are the same @emph{object}.  By contrast, @code{=} compares only the numeric values of the objects."
msgstr "数が数値的に等しいかのテストには、@code{eq}ではなく通常は@code{=}を使用するべきです。同じ数値をもつ多くの浮動小数オブジェクトが存在するかもしれません。これらを比較するのに@code{eq}を使用する場合、これは2つの値が同じオブジェクトかどうかをテストすることになります。対照的に@code{=}はオブジェクトの数値的な値だけを比較します。"

#. type: Plain text
#: original_texis/numbers.texi:361
msgid "In Emacs Lisp, each integer is a unique Lisp object.  Therefore, @code{eq} is equivalent to @code{=} where integers are concerned.  It is sometimes convenient to use @code{eq} for comparing an unknown value with an integer, because @code{eq} does not report an error if the unknown value is not a number---it accepts arguments of any type.  By contrast, @code{=} signals an error if the arguments are not numbers or markers.  However, it is better programming practice to use @code{=} if you can, even for comparing integers."
msgstr "Emacs Lispでは、それぞれの整数は一意なLispオブジェクトです。したがって整数に関しては@code{eq}は@code{=}と同じです。未知の整数の値の比較に、@code{eq}を使用する方が便利な場合があります。なぜなら未知の値が数でない場合でも@code{eq}はエラーを報告しないからです。対照的に引数が数でもマーカーでもない場合、@code{=}はエラーをシグナルします。しかし整数の比較においてさえ、使用できる場合は@code{=}を使用するのがよいプログラミング習慣です。"

#. type: Plain text
#: original_texis/numbers.texi:367
msgid "Sometimes it is useful to compare numbers with @code{equal}, which treats two numbers as equal if they have the same data type (both integers, or both floating point) and the same value.  By contrast, @code{=} can treat an integer and a floating-point number as equal.  @xref{Equality Predicates}."
msgstr "数の比較において、2つの数が同じデータ型(どちらも整数か浮動小数)では、同じ値の場合は等しい数として扱う@code{equal}のほうが便利なときもあります。対照的に@code{=}は整数と浮動小数点数を等しい数と扱うことができます。@ref{Equality Predicates}を参照してください。"

#. type: Plain text
#: original_texis/numbers.texi:372
msgid "There is another wrinkle: because floating-point arithmetic is not exact, it is often a bad idea to check for equality of floating-point values.  Usually it is better to test for approximate equality.  Here's a function to do this:"
msgstr "他の欠点もあります。浮動小数演算は正確ではないので、浮動小数値を比較するのが悪いアイデアとなるときがよくあります。通常は近似的に等しいことをテストするほうがよいでしょう。以下はこれを行なう関数です:"

#. type: example
#: original_texis/numbers.texi:380
#, no-wrap
msgid ""
"(defvar fuzz-factor 1.0e-6)\n"
"(defun approx-equal (x y)\n"
"  (or (= x y)\n"
"      (< (/ (abs (- x y))\n"
"            (max (abs x) (abs y)))\n"
"         fuzz-factor)))\n"
msgstr ""
"(defvar fuzz-factor 1.0e-6)\n"
"(defun approx-equal (x y)\n"
"  (or (= x y)\n"
"      (< (/ (abs (- x y))\n"
"            (max (abs x) (abs y)))\n"
"         fuzz-factor)))\n"

#. type: cindex
#: original_texis/numbers.texi:382
#, no-wrap
msgid "CL note---integers vrs @code{eq}"
msgstr "CL note---integers vrs @code{eq}"

#. type: quotation
#: original_texis/numbers.texi:389
msgid "@b{Common Lisp note:} Comparing numbers in Common Lisp always requires @code{=} because Common Lisp implements multi-word integers, and two distinct integer objects can have the same numeric value.  Emacs Lisp can have just one integer object for any given value because it has a limited range of integers."
msgstr "@b{Common Lispに関する注意: }Common Lispは複数ワード整数を実装していて、2つの別の整数オブジェクトが同じ数値的な値をもつことができるので、Common Lispでの数の比較はには常に@code{=}が要求されます。Emacs Lispの整数は範囲が制限されているため、与えられた値に対応する整数オブジェクトは1つだけです。"

#. type: defun
#: original_texis/numbers.texi:391
#, no-wrap
msgid "= number-or-marker &rest number-or-markers"
msgstr "= number-or-marker &rest number-or-markers"

#. type: defun
#: original_texis/numbers.texi:394
msgid "This function tests whether all its arguments are numerically equal, and returns @code{t} if so, @code{nil} otherwise."
msgstr "この関数はすべての引数が数値的に等しいかどうかをテストしてもしそうなら@code{t}、それ以外は@code{nil}をリターンする。"

#. type: defun
#: original_texis/numbers.texi:396
#, no-wrap
msgid "eql value1 value2"
msgstr "eql value1 value2"

#. type: defun
#: original_texis/numbers.texi:401
msgid "This function acts like @code{eq} except when both arguments are numbers.  It compares numbers by type and numeric value, so that @code{(eql 1.0 1)} returns @code{nil}, but @code{(eql 1.0 1.0)} and @code{(eql 1 1)} both return @code{t}."
msgstr "この関数は@code{eq}と同様に振る舞うが引数が両方とも数のときを除く。これは数を型と数値的な値により比較するので、@code{(eql 1.0 1)}は@code{nil}をリターンするが、@code{(eql 1.0 1.0)}と@code{(eql 1 1)}は@code{t}をリターンする。"

#. type: defun
#: original_texis/numbers.texi:403
#, no-wrap
msgid "/= number-or-marker1 number-or-marker2"
msgstr "/= number-or-marker1 number-or-marker2"

#. type: defun
#: original_texis/numbers.texi:406
msgid "This function tests whether its arguments are numerically equal, and returns @code{t} if they are not, and @code{nil} if they are."
msgstr "この関数は引数が数値的に等しいかどうかをテストして、もし異なる場合は@code{t}、等しい場合は@code{nil}をリターンする。"

#. type: defun
#: original_texis/numbers.texi:408
#, no-wrap
msgid "<  number-or-marker &rest number-or-markers"
msgstr "<  number-or-marker &rest number-or-markers"

#. type: defun
#: original_texis/numbers.texi:411
msgid "This function tests whether each argument is strictly less than the following argument.  It returns @code{t} if so, @code{nil} otherwise."
msgstr "この関数は、各引数それぞれを後の引数より小さいかどうかをテストしてもしそうなら@code{t}、それ以外は@code{nil}をリターンする。"

#. type: defun
#: original_texis/numbers.texi:413
#, no-wrap
msgid "<= number-or-marker &rest number-or-markers"
msgstr "<= number-or-marker &rest number-or-markers"

#. type: defun
#: original_texis/numbers.texi:416
msgid "This function tests whether each argument is less than or equal to the following argument.  It returns @code{t} if so, @code{nil} otherwise."
msgstr "この関数は、各引数それぞれが後の引数以下かどうかをテストしてもしそうなら@code{t}、それ以外は@code{nil}をリターンする。"

#. type: defun
#: original_texis/numbers.texi:418
#, no-wrap
msgid "> number-or-marker &rest number-or-markers"
msgstr "> number-or-marker &rest number-or-markers"

#. type: defun
#: original_texis/numbers.texi:421
msgid "This function tests whether each argument is strictly greater than the following argument.  It returns @code{t} if so, @code{nil} otherwise."
msgstr "この関数は、各引数それぞれが後の引数より大きいかどうかをテストしてもしそうなら@code{t}、それ以外は@code{nil}をリターンする。"

#. type: defun
#: original_texis/numbers.texi:423
#, no-wrap
msgid ">= number-or-marker &rest number-or-markers"
msgstr ">= number-or-marker &rest number-or-markers"

#. type: defun
#: original_texis/numbers.texi:426
msgid "This function tests whether each argument is greater than or equal to the following argument.  It returns @code{t} if so, @code{nil} otherwise."
msgstr "この関数は、各引数それぞれが後の引数以上かどうかをテストしてもしそうなら@code{t}、それ以外は@code{nil}をリターンする。"

#. type: defun
#: original_texis/numbers.texi:428
#, no-wrap
msgid "max number-or-marker &rest numbers-or-markers"
msgstr "max number-or-marker &rest numbers-or-markers"

#. type: defun
#: original_texis/numbers.texi:432
msgid "This function returns the largest of its arguments.  If any of the arguments is floating point, the value is returned as floating point, even if it was given as an integer."
msgstr "この関数は引数の最大をリターンする。引数のどれかが浮動小数なら、たとえ最大が整数であっても浮動小数として値がリターンする。"

#. type: example
#: original_texis/numbers.texi:440
#, no-wrap
msgid ""
"(max 20)\n"
"     @result{} 20\n"
"(max 1 2.5)\n"
"     @result{} 2.5\n"
"(max 1 3 2.5)\n"
"     @result{} 3.0\n"
msgstr ""
"(max 20)\n"
"     @result{} 20\n"
"(max 1 2.5)\n"
"     @result{} 2.5\n"
"(max 1 3 2.5)\n"
"     @result{} 3.0\n"

#. type: defun
#: original_texis/numbers.texi:443
#, no-wrap
msgid "min number-or-marker &rest numbers-or-markers"
msgstr "min number-or-marker &rest numbers-or-markers"

#. type: defun
#: original_texis/numbers.texi:447
msgid "This function returns the smallest of its arguments.  If any of the arguments is floating point, the value is returned as floating point, even if it was given as an integer."
msgstr "この関数は引数の最小をリターンする。引数のどれかが浮動小数なら、たとえ最小が整数であっても浮動小数として値がリターンする。"

#. type: example
#: original_texis/numbers.texi:451
#, no-wrap
msgid ""
"(min -4 1)\n"
"     @result{} -4\n"
msgstr ""
"(min -4 1)\n"
"     @result{} -4\n"

#. type: defun
#: original_texis/numbers.texi:454
#, no-wrap
msgid "abs number"
msgstr "abs number"

#. type: defun
#: original_texis/numbers.texi:456
msgid "This function returns the absolute value of @var{number}."
msgstr "この関数は@var{number}の絶対値をリターンする。"

#. type: cindex
#: original_texis/numbers.texi:460
#, no-wrap
msgid "rounding in conversions"
msgstr "rounding in conversions"

#. type: cindex
#: original_texis/numbers.texi:461
#, no-wrap
msgid "number conversions"
msgstr "number conversions"

#. type: cindex
#: original_texis/numbers.texi:462
#, no-wrap
msgid "converting numbers"
msgstr "converting numbers"

#. type: Plain text
#: original_texis/numbers.texi:465
msgid "To convert an integer to floating point, use the function @code{float}."
msgstr "整数を浮動少数の変換には関数@code{float}を使用します。"

#. type: defun
#: original_texis/numbers.texi:466
#, no-wrap
msgid "float number"
msgstr "float number"

#. type: defun
#: original_texis/numbers.texi:470
msgid "This returns @var{number} converted to floating point.  If @var{number} is already floating point, @code{float} returns it unchanged."
msgstr "これは浮動小数点数に変換された@var{number}をリターンする。すでに@var{number}が浮動小数点数なら@code{float}はそれを変更せずにリターンする。"

#. type: Plain text
#: original_texis/numbers.texi:482
msgid "There are four functions to convert floating-point numbers to integers; they differ in how they round.  All accept an argument @var{number} and an optional argument @var{divisor}.  Both arguments may be integers or floating-point numbers.  @var{divisor} may also be @code{nil}.  If @var{divisor} is @code{nil} or omitted, these functions convert @var{number} to an integer, or return it unchanged if it already is an integer.  If @var{divisor} is non-@code{nil}, they divide @var{number} by @var{divisor} and convert the result to an integer.  If @var{divisor} is zero (whether integer or floating point), Emacs signals an @code{arith-error} error."
msgstr "浮動小数点数を整数に変換する関数が4つあります。これらは浮動小数点数を丸める方法が異なります。これらはすべて引数@var{number}、およびオプション引数として@var{divisor}を受け取ります。引数は両方とも整数か浮動小数点数です。@var{divisor}が@code{nil}のこともあります。@var{divisor}が@code{nil}または省略された場合、これらの関数は@var{number}を整数に変換するか、それが既に整数の場合は変更せずにリターンします。@var{divisor}が非@code{nil}なら、これらの関数は@var{number}を@var{divisor}で除して結果を整数に変換します。@var{divisor}が(整数か浮動小数かに関わらず)0の場合、Emacsは@code{arith-error}エラーをシグナルします。"

#. type: defun
#: original_texis/numbers.texi:483
#, no-wrap
msgid "truncate number &optional divisor"
msgstr "truncate number &optional divisor"

#. type: defun
#: original_texis/numbers.texi:486
msgid "This returns @var{number}, converted to an integer by rounding towards zero."
msgstr "これは0に向かって丸めることにより整数に変換した@var{number}をリターンする。"

#. type: example
#: original_texis/numbers.texi:496
#, no-wrap
msgid ""
"(truncate 1.2)\n"
"     @result{} 1\n"
"(truncate 1.7)\n"
"     @result{} 1\n"
"(truncate -1.2)\n"
"     @result{} -1\n"
"(truncate -1.7)\n"
"     @result{} -1\n"
msgstr ""
"(truncate 1.2)\n"
"     @result{} 1\n"
"(truncate 1.7)\n"
"     @result{} 1\n"
"(truncate -1.2)\n"
"     @result{} -1\n"
"(truncate -1.7)\n"
"     @result{} -1\n"

#. type: defun
#: original_texis/numbers.texi:499
#, no-wrap
msgid "floor number &optional divisor"
msgstr "floor number &optional divisor"

#. type: defun
#: original_texis/numbers.texi:502
msgid "This returns @var{number}, converted to an integer by rounding downward (towards negative infinity)."
msgstr "これは下方(負の無限大に向かって)に丸めることにより整数に変換した@var{number}をリターンする。"

#. type: defun
#: original_texis/numbers.texi:505
msgid "If @var{divisor} is specified, this uses the kind of division operation that corresponds to @code{mod}, rounding downward."
msgstr "@var{divisor}が指定された場合には、@code{mod}に相当する種類の除算演算を使用して下方に丸めを行う。"

#. type: example
#: original_texis/numbers.texi:517
#, no-wrap
msgid ""
"(floor 1.2)\n"
"     @result{} 1\n"
"(floor 1.7)\n"
"     @result{} 1\n"
"(floor -1.2)\n"
"     @result{} -2\n"
"(floor -1.7)\n"
"     @result{} -2\n"
"(floor 5.99 3)\n"
"     @result{} 1\n"
msgstr ""
"(floor 1.2)\n"
"     @result{} 1\n"
"(floor 1.7)\n"
"     @result{} 1\n"
"(floor -1.2)\n"
"     @result{} -2\n"
"(floor -1.7)\n"
"     @result{} -2\n"
"(floor 5.99 3)\n"
"     @result{} 1\n"

#. type: defun
#: original_texis/numbers.texi:520
#, no-wrap
msgid "ceiling number &optional divisor"
msgstr "ceiling number &optional divisor"

#. type: defun
#: original_texis/numbers.texi:523
msgid "This returns @var{number}, converted to an integer by rounding upward (towards positive infinity)."
msgstr "これは上方(正の無限大に向かって)に丸めることにより整数に変換した@var{number}をリターンする。"

#. type: example
#: original_texis/numbers.texi:533
#, no-wrap
msgid ""
"(ceiling 1.2)\n"
"     @result{} 2\n"
"(ceiling 1.7)\n"
"     @result{} 2\n"
"(ceiling -1.2)\n"
"     @result{} -1\n"
"(ceiling -1.7)\n"
"     @result{} -1\n"
msgstr ""
"(ceiling 1.2)\n"
"     @result{} 2\n"
"(ceiling 1.7)\n"
"     @result{} 2\n"
"(ceiling -1.2)\n"
"     @result{} -1\n"
"(ceiling -1.7)\n"
"     @result{} -1\n"

#. type: defun
#: original_texis/numbers.texi:536
#, no-wrap
msgid "round number &optional divisor"
msgstr "round number &optional divisor"

#. type: defun
#: original_texis/numbers.texi:540
msgid "This returns @var{number}, converted to an integer by rounding towards the nearest integer.  Rounding a value equidistant between two integers returns the even integer."
msgstr "これはもっとも近い整数に向かって丸めることにより、整数に変換した@var{number}をリターンする。2つの整数から等距離にある値の丸めでは、偶数の整数をリターンする。"

#. type: example
#: original_texis/numbers.texi:550
#, no-wrap
msgid ""
"(round 1.2)\n"
"     @result{} 1\n"
"(round 1.7)\n"
"     @result{} 2\n"
"(round -1.2)\n"
"     @result{} -1\n"
"(round -1.7)\n"
"     @result{} -2\n"
msgstr ""
"(round 1.2)\n"
"     @result{} 1\n"
"(round 1.7)\n"
"     @result{} 2\n"
"(round -1.2)\n"
"     @result{} -1\n"
"(round -1.7)\n"
"     @result{} -2\n"

#. type: cindex
#: original_texis/numbers.texi:555
#, no-wrap
msgid "arithmetic operations"
msgstr "arithmetic operations"

#. type: Plain text
#: original_texis/numbers.texi:563
msgid "Emacs Lisp provides the traditional four arithmetic operations (addition, subtraction, multiplication, and division), as well as remainder and modulus functions, and functions to add or subtract 1.  Except for @code{%}, each of these functions accepts both integer and floating-point arguments, and returns a floating-point number if any argument is floating point."
msgstr "Emacs Lispは伝統的な4つの算術演算(加減乗除)、同様に剰余とmodulusの関数、および1の加算と減算を行う関数を提供します。@code{%}を除き、これらの各関数は引き数として整数か浮動小数を受け取り、浮動小数の引数がある場合は浮動小数点数をリターンします。"

#. type: Plain text
#: original_texis/numbers.texi:567
msgid "Emacs Lisp arithmetic functions do not check for integer overflow.  Thus @code{(1+ 536870911)} may evaluate to @minus{}536870912, depending on your hardware."
msgstr "Emacs Lispの算術関数は整数のオーバーフローをチェックしません。したがって@code{(1+ 536870911)}は@minus{}536870912に評価されるかもしれず、それはハードウェアーに依存します。"

#. type: defun
#: original_texis/numbers.texi:568
#, no-wrap
msgid "1+ number-or-marker"
msgstr "1+ number-or-marker"

#. type: defun
#: original_texis/numbers.texi:571
msgid "This function returns @var{number-or-marker} plus 1.  For example,"
msgstr "この関数は@var{number-or-marker} + 1をリターンする。例えば、"

#. type: example
#: original_texis/numbers.texi:577
#, no-wrap
msgid ""
"(setq foo 4)\n"
"     @result{} 4\n"
"(1+ foo)\n"
"     @result{} 5\n"
msgstr ""
"(setq foo 4)\n"
"     @result{} 4\n"
"(1+ foo)\n"
"     @result{} 5\n"

#. type: defun
#: original_texis/numbers.texi:581
msgid "This function is not analogous to the C operator @code{++}---it does not increment a variable.  It just computes a sum.  Thus, if we continue,"
msgstr "この関数はCの演算子@code{++}とは異なり、変数をインクリメントしない。この関数は和を計算するだけである。したがって以下を続けて評価すると、"

#. type: example
#: original_texis/numbers.texi:585
#, no-wrap
msgid ""
"foo\n"
"     @result{} 4\n"
msgstr ""
"foo\n"
"     @result{} 4\n"

#. type: defun
#: original_texis/numbers.texi:589
msgid "If you want to increment the variable, you must use @code{setq}, like this:"
msgstr "変数をインクリメントしたい場合は、以下のように@code{setq}を使用しなければならない:"

#. type: example
#: original_texis/numbers.texi:593
#, no-wrap
msgid ""
"(setq foo (1+ foo))\n"
"     @result{} 5\n"
msgstr ""
"(setq foo (1+ foo))\n"
"     @result{} 5\n"

#. type: defun
#: original_texis/numbers.texi:596
#, no-wrap
msgid "1- number-or-marker"
msgstr "1- number-or-marker"

#. type: defun
#: original_texis/numbers.texi:598
msgid "This function returns @var{number-or-marker} minus 1."
msgstr "この関数は@var{number-or-marker} @minus{} 1をリターンする。"

#. type: defun
#: original_texis/numbers.texi:600
#, no-wrap
msgid "+ &rest numbers-or-markers"
msgstr "+ &rest numbers-or-markers"

#. type: defun
#: original_texis/numbers.texi:603
msgid "This function adds its arguments together.  When given no arguments, @code{+} returns 0."
msgstr "この関数は引数すべてを加算する。引数を与えないと@code{+}は0をリターンする。"

#. type: example
#: original_texis/numbers.texi:611
#, no-wrap
msgid ""
"(+)\n"
"     @result{} 0\n"
"(+ 1)\n"
"     @result{} 1\n"
"(+ 1 2 3 4)\n"
"     @result{} 10\n"
msgstr ""
"(+)\n"
"     @result{} 0\n"
"(+ 1)\n"
"     @result{} 1\n"
"(+ 1 2 3 4)\n"
"     @result{} 10\n"

#. type: defun
#: original_texis/numbers.texi:614
#, no-wrap
msgid "- &optional number-or-marker &rest more-numbers-or-markers"
msgstr "- &optional number-or-marker &rest more-numbers-or-markers"

#. type: defun
#: original_texis/numbers.texi:620
msgid "The @code{-} function serves two purposes: negation and subtraction.  When @code{-} has a single argument, the value is the negative of the argument.  When there are multiple arguments, @code{-} subtracts each of the @var{more-numbers-or-markers} from @var{number-or-marker}, cumulatively.  If there are no arguments, the result is 0."
msgstr "@code{-}関数は2つの目的 --- 符号反転と減算 --- をもつ。@code{-}に1つの引数を与えると、値は引数の符号を反転したものになる。複数の引数の場合は、@var{number-or-marker}から@var{more-numbers-or-markers}までの各値を蓄積的に減算する。引数がなければ結果は0。"

#. type: example
#: original_texis/numbers.texi:628
#, no-wrap
msgid ""
"(- 10 1 2 3 4)\n"
"     @result{} 0\n"
"(- 10)\n"
"     @result{} -10\n"
"(-)\n"
"     @result{} 0\n"
msgstr ""
"(- 10 1 2 3 4)\n"
"     @result{} 0\n"
"(- 10)\n"
"     @result{} -10\n"
"(-)\n"
"     @result{} 0\n"

#. type: defun
#: original_texis/numbers.texi:631
#, no-wrap
msgid "* &rest numbers-or-markers"
msgstr "* &rest numbers-or-markers"

#. type: defun
#: original_texis/numbers.texi:634
msgid "This function multiplies its arguments together, and returns the product.  When given no arguments, @code{*} returns 1."
msgstr "この関数はすべての引数を乗じて積をリターンする。引数がなかれば@code{*}は1をリターンする。"

#. type: example
#: original_texis/numbers.texi:642
#, no-wrap
msgid ""
"(*)\n"
"     @result{} 1\n"
"(* 1)\n"
"     @result{} 1\n"
"(* 1 2 3 4)\n"
"     @result{} 24\n"
msgstr ""
"(*)\n"
"     @result{} 1\n"
"(* 1)\n"
"     @result{} 1\n"
"(* 1 2 3 4)\n"
"     @result{} 24\n"

#. type: defun
#: original_texis/numbers.texi:645
#, no-wrap
msgid "/ number &rest divisors"
msgstr "/ number &rest divisors"

#. type: defun
#: original_texis/numbers.texi:651
msgid "With one or more @var{divisors}, this function divides @var{number} by each divisor in @var{divisors} in turn, and returns the quotient.  With no @var{divisors}, this function returns 1/@var{number}, i.e., the multiplicative inverse of @var{number}.  Each argument may be a number or a marker."
msgstr "@var{divisors}が1つ以上ならこの関数は@var{divisors}内の除数で順に@var{number}を除して、その商をリターンする。@var{divisors}がなければ、この関数は1/@var{number}、つまり@var{number}の逆数をリターンする。各引数には数かマーカーを指定できる。"

#. type: defun
#: original_texis/numbers.texi:654
msgid "If all the arguments are integers, the result is an integer, obtained by rounding the quotient towards zero after each division."
msgstr "すべての引数が整数なら、結果は各除算の後に商を0へ向かって丸めることにより得られる整数となる。"

#. type: group
#: original_texis/numbers.texi:659
#, no-wrap
msgid ""
"(/ 6 2)\n"
"     @result{} 3\n"
msgstr ""
"(/ 6 2)\n"
"     @result{} 3\n"

#. type: group
#: original_texis/numbers.texi:663
#, no-wrap
msgid ""
"(/ 5 2)\n"
"     @result{} 2\n"
msgstr ""
"(/ 5 2)\n"
"     @result{} 2\n"

#. type: group
#: original_texis/numbers.texi:667
#, no-wrap
msgid ""
"(/ 5.0 2)\n"
"     @result{} 2.5\n"
msgstr ""
"(/ 5.0 2)\n"
"     @result{} 2.5\n"

#. type: group
#: original_texis/numbers.texi:671
#, no-wrap
msgid ""
"(/ 5 2.0)\n"
"     @result{} 2.5\n"
msgstr ""
"(/ 5 2.0)\n"
"     @result{} 2.5\n"

#. type: group
#: original_texis/numbers.texi:675
#, no-wrap
msgid ""
"(/ 5.0 2.0)\n"
"     @result{} 2.5\n"
msgstr ""
"(/ 5.0 2.0)\n"
"     @result{} 2.5\n"

#. type: group
#: original_texis/numbers.texi:679
#, no-wrap
msgid ""
"(/ 4.0)\n"
"     @result{} 0.25\n"
msgstr ""
"(/ 4.0)\n"
"     @result{} 0.25\n"

#. type: group
#: original_texis/numbers.texi:683
#, no-wrap
msgid ""
"(/ 4)\n"
"     @result{} 0\n"
msgstr ""
"(/ 4)\n"
"     @result{} 0\n"

#. type: group
#: original_texis/numbers.texi:687
#, no-wrap
msgid ""
"(/ 25 3 2)\n"
"     @result{} 4\n"
msgstr ""
"(/ 25 3 2)\n"
"     @result{} 4\n"

#. type: group
#: original_texis/numbers.texi:691
#, no-wrap
msgid ""
"(/ -17 6)\n"
"     @result{} -2\n"
msgstr ""
"(/ -17 6)\n"
"     @result{} -2\n"

#. type: cindex
#: original_texis/numbers.texi:694
#, no-wrap
msgid "@code{arith-error} in division"
msgstr "@code{arith-error} in division"

#. type: defun
#: original_texis/numbers.texi:699
msgid "If you divide an integer by the integer 0, Emacs signals an @code{arith-error} error (@pxref{Errors}).  Floating-point division of a nonzero number by zero yields either positive or negative infinity (@pxref{Float Basics})."
msgstr "整数を整数0で除するとEmacsは@code{arith-error}エラー(@ref{Errors}を参照)をシグナルする。浮動小数点数の除算では、非0の数を0で除することで正の無限大または負の無限大を得る(@ref{Float Basics}を参照)。"

#. type: defun
#: original_texis/numbers.texi:701
#, no-wrap
msgid "% dividend divisor"
msgstr "% dividend divisor"

#. type: cindex
#: original_texis/numbers.texi:702
#, no-wrap
msgid "remainder"
msgstr "remainder"

#. type: defun
#: original_texis/numbers.texi:705
msgid "This function returns the integer remainder after division of @var{dividend} by @var{divisor}.  The arguments must be integers or markers."
msgstr "この関数は@var{dividend}を@var{divisor}で除した後、その剰余を整数でリターンする。引数は整数かマーカーでなければならない。"

#. type: defun
#: original_texis/numbers.texi:707
msgid "For any two integers @var{dividend} and @var{divisor},"
msgstr "任意の2つの整数@var{dividend}と@var{divisor}にたいして、"

#. type: group
#: original_texis/numbers.texi:712
#, no-wrap
msgid ""
"(+ (% @var{dividend} @var{divisor})\n"
"   (* (/ @var{dividend} @var{divisor}) @var{divisor}))\n"
msgstr ""
"(+ (% @var{dividend} @var{divisor})\n"
"   (* (/ @var{dividend} @var{divisor}) @var{divisor}))\n"

#. type: defun
#: original_texis/numbers.texi:717
msgid "always equals @var{dividend} if @var{divisor} is nonzero."
msgstr "は、@var{divisor}が非0なら常に@var{dividend}と等しくなる。"

#. type: example
#: original_texis/numbers.texi:727
#, no-wrap
msgid ""
"(% 9 4)\n"
"     @result{} 1\n"
"(% -9 4)\n"
"     @result{} -1\n"
"(% 9 -4)\n"
"     @result{} 1\n"
"(% -9 -4)\n"
"     @result{} -1\n"
msgstr ""
"(% 9 4)\n"
"     @result{} 1\n"
"(% -9 4)\n"
"     @result{} -1\n"
"(% 9 -4)\n"
"     @result{} 1\n"
"(% -9 -4)\n"
"     @result{} -1\n"

#. type: defun
#: original_texis/numbers.texi:730
#, no-wrap
msgid "mod dividend divisor"
msgstr "mod dividend divisor"

#. type: cindex
#: original_texis/numbers.texi:731
#, no-wrap
msgid "modulus"
msgstr "modulus"

#. type: defun
#: original_texis/numbers.texi:736
msgid "This function returns the value of @var{dividend} modulo @var{divisor}; in other words, the remainder after division of @var{dividend} by @var{divisor}, but with the same sign as @var{divisor}.  The arguments must be numbers or markers."
msgstr "この関数は@var{dividend}の@var{divisor}にたいするmodulo、言い換えると@var{dividend}を@var{divisor}で除した後の剰余(ただし符号は@var{divisor}と同じ)をリターンする。引数は数かマーカーでなければならない。"

#. type: defun
#: original_texis/numbers.texi:740
msgid "Unlike @code{%}, @code{mod} permits floating-point arguments; it rounds the quotient downward (towards minus infinity) to an integer, and uses that quotient to compute the remainder."
msgstr "@code{%}とは異なり@code{mod}は浮動小数の引数を許す。これは商を整数に下方(負の無限大に向かって)へ丸めて剰余を計算するのにこの商を使用する。"

#. type: defun
#: original_texis/numbers.texi:743
msgid "If @var{divisor} is zero, @code{mod} signals an @code{arith-error} error if both arguments are integers, and returns a NaN otherwise."
msgstr "@code{mod}は@var{divisor}が0のとき、両方の引数が整数なら@code{arith-error}エラーをシグナルし、それ以外はNaNをリターンする。"

#. type: group
#: original_texis/numbers.texi:748
#, no-wrap
msgid ""
"(mod 9 4)\n"
"     @result{} 1\n"
msgstr ""
"(mod 9 4)\n"
"     @result{} 1\n"

#. type: group
#: original_texis/numbers.texi:752
#, no-wrap
msgid ""
"(mod -9 4)\n"
"     @result{} 3\n"
msgstr ""
"(mod -9 4)\n"
"     @result{} 3\n"

#. type: group
#: original_texis/numbers.texi:756
#, no-wrap
msgid ""
"(mod 9 -4)\n"
"     @result{} -3\n"
msgstr ""
"(mod 9 -4)\n"
"     @result{} -3\n"

#. type: group
#: original_texis/numbers.texi:760
#, no-wrap
msgid ""
"(mod -9 -4)\n"
"     @result{} -1\n"
msgstr ""
"(mod -9 -4)\n"
"     @result{} -1\n"

#. type: group
#: original_texis/numbers.texi:764
#, no-wrap
msgid ""
"(mod 5.5 2.5)\n"
"     @result{} .5\n"
msgstr ""
"(mod 5.5 2.5)\n"
"     @result{} .5\n"

#. type: defun
#: original_texis/numbers.texi:768
msgid "For any two numbers @var{dividend} and @var{divisor},"
msgstr "任意の2つの数@var{dividend}と@var{divisor}にたいして、"

#. type: group
#: original_texis/numbers.texi:773
#, no-wrap
msgid ""
"(+ (mod @var{dividend} @var{divisor})\n"
"   (* (floor @var{dividend} @var{divisor}) @var{divisor}))\n"
msgstr ""
"(+ (mod @var{dividend} @var{divisor})\n"
"   (* (floor @var{dividend} @var{divisor}) @var{divisor}))\n"

#. type: defun
#: original_texis/numbers.texi:781
msgid "always equals @var{dividend}, subject to rounding error if either argument is floating point and to an @code{arith-error} if @var{dividend} is an integer and @var{divisor} is 0.  For @code{floor}, see @ref{Numeric Conversions}."
msgstr "は常に@var{dividend}になる(ただし引数のどちらかが浮動小数なら、丸め誤差の範囲内で等しく、かつ@var{dividend}が整数で@var{divisor}が0なら@code{arith-error}となる)。@code{floor}については、@ref{Numeric Conversions}を参照のこと。"

#. type: cindex
#: original_texis/numbers.texi:785
#, no-wrap
msgid "rounding without conversion"
msgstr "rounding without conversion"

#. type: Plain text
#: original_texis/numbers.texi:793
msgid "The functions @code{ffloor}, @code{fceiling}, @code{fround}, and @code{ftruncate} take a floating-point argument and return a floating-point result whose value is a nearby integer.  @code{ffloor} returns the nearest integer below; @code{fceiling}, the nearest integer above; @code{ftruncate}, the nearest integer in the direction towards zero; @code{fround}, the nearest integer."
msgstr "関数@code{ffloor}、@code{fceiling}、@code{fround}、@code{ftruncate}は浮動小数の引数をとり、値が近くの整数であるような浮動少数をリターンします。@code{ffloor}は一番近い下方の整数、@code{fceiling}は一番近い上方の整数、@code{ftruncate}は0に向かう方向で一番近い整数、@code{fround}は一番近い整数をリターンします。"

#. type: defun
#: original_texis/numbers.texi:794
#, no-wrap
msgid "ffloor float"
msgstr "ffloor float"

#. type: defun
#: original_texis/numbers.texi:797
msgid "This function rounds @var{float} to the next lower integral value, and returns that value as a floating-point number."
msgstr "この関数は@var{float}を次に小さい整数値に丸めて、その値を浮動小数点数としてリターンする。"

#. type: defun
#: original_texis/numbers.texi:799
#, no-wrap
msgid "fceiling float"
msgstr "fceiling float"

#. type: defun
#: original_texis/numbers.texi:802
msgid "This function rounds @var{float} to the next higher integral value, and returns that value as a floating-point number."
msgstr "この関数は@var{float}を次に大きい整数値に丸めて、その値を浮動小数点数としてリターンする。"

#. type: defun
#: original_texis/numbers.texi:804
#, no-wrap
msgid "ftruncate float"
msgstr "ftruncate float"

#. type: defun
#: original_texis/numbers.texi:807
msgid "This function rounds @var{float} towards zero to an integral value, and returns that value as a floating-point number."
msgstr "この関数は@var{float}を0方向の整数値に丸めて、その値を浮動小数点数としてリターンする。"

#. type: defun
#: original_texis/numbers.texi:809
#, no-wrap
msgid "fround float"
msgstr "fround float"

#. type: defun
#: original_texis/numbers.texi:813
msgid "This function rounds @var{float} to the nearest integral value, and returns that value as a floating-point number.  Rounding a value equidistant between two integers returns the even integer."
msgstr "この関数は@var{float}を一番近い整数値に丸めて、その値を浮動小数点数としてリターンする。2つの整数値との距離が等しい値にたいする丸めでは、偶数の整数をリターンする。"

#. type: section
#: original_texis/numbers.texi:816
#, no-wrap
msgid "Bitwise Operations on Integers"
msgstr "Bitwise Operations on Integers"

#. type: cindex
#: original_texis/numbers.texi:817
#, no-wrap
msgid "bitwise arithmetic"
msgstr "bitwise arithmetic"

#. type: cindex
#: original_texis/numbers.texi:818
#, no-wrap
msgid "logical arithmetic"
msgstr "logical arithmetic"

#. type: Plain text
#: original_texis/numbers.texi:825
msgid "In a computer, an integer is represented as a binary number, a sequence of @dfn{bits} (digits which are either zero or one).  A bitwise operation acts on the individual bits of such a sequence.  For example, @dfn{shifting} moves the whole sequence left or right one or more places, reproducing the same pattern moved over."
msgstr "コンピューターの中では、整数は@dfn{ビット(bit: 0か1の数字)}のシーケンスである2進数で表されます。ビット演算は、そのようなシーケンスの中の個々のビットに作用します。たとえば@dfn{シフト(shifting)}はシーケンス全体を1つ以上左または右に移動して、移動されたのと同じパターンを再現します。"

#. type: Plain text
#: original_texis/numbers.texi:827
msgid "The bitwise operations in Emacs Lisp apply only to integers."
msgstr "Emacs Lispのビット演算は整数だけに適用されます。"

#. type: defun
#: original_texis/numbers.texi:828
#, no-wrap
msgid "lsh integer1 count"
msgstr "lsh integer1 count"

#. type: cindex
#: original_texis/numbers.texi:829
#, no-wrap
msgid "logical shift"
msgstr "logical shift"

#. type: defun
#: original_texis/numbers.texi:836
msgid "@code{lsh}, which is an abbreviation for @dfn{logical shift}, shifts the bits in @var{integer1} to the left @var{count} places, or to the right if @var{count} is negative, bringing zeros into the vacated bits.  If @var{count} is negative, @code{lsh} shifts zeros into the leftmost (most-significant) bit, producing a positive result even if @var{integer1} is negative.  Contrast this with @code{ash}, below."
msgstr "@code{lsh}は@dfn{logical shift}の略で、@var{integer1}のビットを左に@var{count}個シフトする。@var{count}が負なら右にシフトし、シフトにより空きになったビットには0がセットされる。@var{count}が負なら@code{lsh}は左端(最上位)に0をシフトするので、@var{integer1}が負の場合でも正の結果が生成される。これと対照的なのが以下で説明する@code{ash}である。"

#. type: defun
#: original_texis/numbers.texi:840
msgid "Here are two examples of @code{lsh}, shifting a pattern of bits one place to the left.  We show only the low-order eight bits of the binary pattern; the rest are all zero."
msgstr "以下は@code{lsh}でビットパターンの位置を1つ左にシフトする例である。ここでは下位8ビットの2進パターンだけを表示しており、残りのビットはすべて0である。"

#. type: group
#: original_texis/numbers.texi:847
#, no-wrap
msgid ""
"(lsh 5 1)\n"
"     @result{} 10\n"
";; @r{Decimal 5 becomes decimal 10.}\n"
"00000101 @result{} 00001010\n"
"\n"
msgstr ""
"(lsh 5 1)\n"
"     @result{} 10\n"
";; @r{10進の5が10進の10になる}\n"
"00000101 @result{} 00001010\n"
"\n"

#. type: group
#: original_texis/numbers.texi:852
#, no-wrap
msgid ""
"(lsh 7 1)\n"
"     @result{} 14\n"
";; @r{Decimal 7 becomes decimal 14.}\n"
"00000111 @result{} 00001110\n"
msgstr ""
"(lsh 7 1)\n"
"     @result{} 14\n"
";; @r{10進の7は10進の14になる}\n"
"00000111 @result{} 00001110\n"

#. type: defun
#: original_texis/numbers.texi:859
msgid "As the examples illustrate, shifting the pattern of bits one place to the left produces a number that is twice the value of the previous number."
msgstr "この例が示すように、ビットパターンを左に1シフトすると、生成される数は元の数の2倍になる。"

#. type: defun
#: original_texis/numbers.texi:862
msgid "Shifting a pattern of bits two places to the left produces results like this (with 8-bit binary numbers):"
msgstr "ビットパターンを左に2シフトすると、以下の結果が生成される(8ビット2進数):"

#. type: group
#: original_texis/numbers.texi:869
#, no-wrap
msgid ""
"(lsh 3 2)\n"
"     @result{} 12\n"
";; @r{Decimal 3 becomes decimal 12.}\n"
"00000011 @result{} 00001100\n"
msgstr ""
"(lsh 3 2)\n"
"     @result{} 12\n"
";; @r{10進の3が10進の12になる}\n"
"00000011 @result{} 00001100\n"

#. type: defun
#: original_texis/numbers.texi:873
msgid "On the other hand, shifting one place to the right looks like this:"
msgstr "一方、右に1シフトすると以下のようになる:"

#. type: group
#: original_texis/numbers.texi:880
#, no-wrap
msgid ""
"(lsh 6 -1)\n"
"     @result{} 3\n"
";; @r{Decimal 6 becomes decimal 3.}\n"
"00000110 @result{} 00000011\n"
msgstr ""
"(lsh 6 -1)\n"
"     @result{} 3\n"
";; @r{10進の6は10進の3になる}\n"
"00000110 @result{} 00000011\n"

#. type: group
#: original_texis/numbers.texi:887
#, no-wrap
msgid ""
"(lsh 5 -1)\n"
"     @result{} 2\n"
";; @r{Decimal 5 becomes decimal 2.}\n"
"00000101 @result{} 00000010\n"
msgstr ""
"(lsh 5 -1)\n"
"     @result{} 2\n"
";; @r{10進の5は10進の2になる}\n"
"00000101 @result{} 00000010\n"

#. type: defun
#: original_texis/numbers.texi:893
msgid "As the example illustrates, shifting one place to the right divides the value of a positive integer by two, rounding downward."
msgstr "例で明らかなように右に1シフトすることにより、正の整数の値が2で除され下方に丸められる。"

#. type: defun
#: original_texis/numbers.texi:898
msgid "The function @code{lsh}, like all Emacs Lisp arithmetic functions, does not check for overflow, so shifting left can discard significant bits and change the sign of the number.  For example, left shifting 536,870,911 produces @minus{}2 in the 30-bit implementation:"
msgstr "関数@code{lsh}は他のEmacs Lisp算術関数と同様、オーバーフローをチェックしないので、左にシフトすることにより上位ビットが捨てられ、その数の符号が変化するかもしれない。たとえば30ビットの実装では、536,870,911を左にシフトすると@minus{}2が生成されます。"

#. type: example
#: original_texis/numbers.texi:902
#, no-wrap
msgid ""
"(lsh 536870911 1)          ; @r{left shift}\n"
"     @result{} -2\n"
msgstr ""
"(lsh 536870911 1)          ; @r{左シフト}\n"
"     @result{} -2\n"

#. type: defun
#: original_texis/numbers.texi:905
msgid "In binary, the argument looks like this:"
msgstr "2進ではこの引数は以下のようになる:"

#. type: group
#: original_texis/numbers.texi:910
#, no-wrap
msgid ""
";; @r{Decimal 536,870,911}\n"
"0111...111111 (30 bits total)\n"
msgstr ""
";; @r{10進の536,870,911}\n"
"0111...111111 (全部で30ビット)\n"

#. type: defun
#: original_texis/numbers.texi:915
msgid "which becomes the following when left shifted:"
msgstr "これを左にシフトすると以下のようになる:"

#. type: group
#: original_texis/numbers.texi:920
#, no-wrap
msgid ""
";; @r{Decimal @minus{}2}\n"
"1111...111110 (30 bits total)\n"
msgstr ""
";; @r{10進の@minus{}2}\n"
"1111...111110 (全部で30ビット)\n"

#. type: defun
#: original_texis/numbers.texi:924
#, no-wrap
msgid "ash integer1 count"
msgstr "ash integer1 count"

#. type: cindex
#: original_texis/numbers.texi:925
#, no-wrap
msgid "arithmetic shift"
msgstr "arithmetic shift"

#. type: defun
#: original_texis/numbers.texi:929
msgid "@code{ash} (@dfn{arithmetic shift}) shifts the bits in @var{integer1} to the left @var{count} places, or to the right if @var{count} is negative."
msgstr "@code{ash} (@dfn{算術シフト(arithmetic shift)})は、@var{integer1}の中のビット位置を左に@var{count}シフトする。@var{count}が負なら右にシフトする。"

#. type: defun
#: original_texis/numbers.texi:934
msgid "@code{ash} gives the same results as @code{lsh} except when @var{integer1} and @var{count} are both negative.  In that case, @code{ash} puts ones in the empty bit positions on the left, while @code{lsh} puts zeros in those bit positions."
msgstr "@code{ash}は@code{lsh}と同じ結果を与えるが、例外は@var{integer1}と@var{count}がいずれも負の場合である。この場合、@code{lsh}は左にできる空きビットに0、@code{ash}は1を置く。"

#. type: defun
#: original_texis/numbers.texi:937
msgid "Thus, with @code{ash}, shifting the pattern of bits one place to the right looks like this:"
msgstr "したがって@code{ash}でビットパターンの位置を右に1シフトすると以下のようになる:"

#. type: group
#: original_texis/numbers.texi:945
#, no-wrap
msgid ""
"(ash -6 -1) @result{} -3\n"
";; @r{Decimal @minus{}6 becomes decimal @minus{}3.}\n"
"1111...111010 (30 bits total)\n"
"     @result{}\n"
"1111...111101 (30 bits total)\n"
msgstr ""
"(ash -6 -1) @result{} -3\n"
";; @r{10進の@minus{}6は10進の@minus{}3になる}\n"
"1111...111010 (30 bits total)\n"
"     @result{}\n"
"1111...111101 (30 bits total)\n"

#. type: defun
#: original_texis/numbers.texi:950
msgid "In contrast, shifting the pattern of bits one place to the right with @code{lsh} looks like this:"
msgstr "対照的に、@code{lsh}でビットパターンの位置を1右にシフトすると以下のようになる:"

#. type: group
#: original_texis/numbers.texi:958
#, no-wrap
msgid ""
"(lsh -6 -1) @result{} 536870909\n"
";; @r{Decimal @minus{}6 becomes decimal 536,870,909.}\n"
"1111...111010 (30 bits total)\n"
"     @result{}\n"
"0111...111101 (30 bits total)\n"
msgstr ""
"(lsh -6 -1) @result{} 536870909\n"
";; @r{10進の@minus{}6は10進の536,870,909になる}\n"
"1111...111010 (30 bits total)\n"
"     @result{}\n"
"0111...111101 (30 bits total)\n"

#. type: defun
#: original_texis/numbers.texi:962
msgid "Here are other examples:"
msgstr "他にも例を示す:"

#. type: group
#: original_texis/numbers.texi:968
#, no-wrap
msgid ""
"                   ;  @r{       30-bit binary values}\n"
"\n"
msgstr ""
"                   ;  @r{       30ビットの2進数}\n"
"\n"

#. type: group
#: original_texis/numbers.texi:971
#, no-wrap
msgid ""
"(lsh 5 2)          ;   5  =  @r{0000...000101}\n"
"     @result{} 20         ;      =  @r{0000...010100}\n"
msgstr ""
"(lsh 5 2)          ;   5  =  @r{0000...000101}\n"
"     @result{} 20         ;      =  @r{0000...010100}\n"

#. type: group
#: original_texis/numbers.texi:979
#, no-wrap
msgid ""
"(ash 5 2)\n"
"     @result{} 20\n"
"(lsh -5 2)         ;  -5  =  @r{1111...111011}\n"
"     @result{} -20        ;      =  @r{1111...101100}\n"
"(ash -5 2)\n"
"     @result{} -20\n"
msgstr ""
"(ash 5 2)\n"
"     @result{} 20\n"
"(lsh -5 2)         ;  -5  =  @r{1111...111011}\n"
"     @result{} -20        ;      =  @r{1111...101100}\n"
"(ash -5 2)\n"
"     @result{} -20\n"

#. type: group
#: original_texis/numbers.texi:983
#, no-wrap
msgid ""
"(lsh 5 -2)         ;   5  =  @r{0000...000101}\n"
"     @result{} 1          ;      =  @r{0000...000001}\n"
msgstr ""
"(lsh 5 -2)         ;   5  =  @r{0000...000101}\n"
"     @result{} 1          ;      =  @r{0000...000001}\n"

#. type: group
#: original_texis/numbers.texi:987
#, no-wrap
msgid ""
"(ash 5 -2)\n"
"     @result{} 1\n"
msgstr ""
"(ash 5 -2)\n"
"     @result{} 1\n"

#. type: group
#: original_texis/numbers.texi:992
#, no-wrap
msgid ""
"(lsh -5 -2)        ;  -5  =  @r{1111...111011}\n"
"     @result{} 268435454\n"
"                   ;      =  @r{0011...111110}\n"
msgstr ""
"(lsh -5 -2)        ;  -5  =  @r{1111...111011}\n"
"     @result{} 268435454\n"
"                   ;      =  @r{0011...111110}\n"

#. type: group
#: original_texis/numbers.texi:996
#, no-wrap
msgid ""
"(ash -5 -2)        ;  -5  =  @r{1111...111011}\n"
"     @result{} -2         ;      =  @r{1111...111110}\n"
msgstr ""
"(ash -5 -2)        ;  -5  =  @r{1111...111011}\n"
"     @result{} -2         ;      =  @r{1111...111110}\n"

#. type: defun
#: original_texis/numbers.texi:1000
#, no-wrap
msgid "logand &rest ints-or-markers"
msgstr "logand &rest ints-or-markers"

#. type: defun
#: original_texis/numbers.texi:1004
msgid "This function returns the bitwise AND of the arguments: the @var{n}th bit is 1 in the result if, and only if, the @var{n}th bit is 1 in all the arguments."
msgstr "この関数は引数のビットのANDをリターンする。すべての引数の@var{n}番目のビットが1の場合に限り、結果の@var{n}番目のビットが1となる。"

#. type: defun
#: original_texis/numbers.texi:1011
msgid "For example, using 4-bit binary numbers, the bitwise AND of 13 and 12 is 12: 1101 combined with 1100 produces 1100.  In both the binary numbers, the leftmost two bits are both 1 so the leftmost two bits of the returned value are both 1.  However, for the rightmost two bits, each is 0 in at least one of the arguments, so the rightmost two bits of the returned value are both 0."
msgstr "たとえば13と12では、4ビット2進数を使用すると1101と1100のビットANDは1100を生成する。この2進数ではいずれも左の2ビットがセット(つまり1)されているので、リターンされる値の左2ビットがセットされる。しかし右の2ビットにたいしては少なくとも1つの引数でそのビットが0なので、リターンされる値の右2ビットは0になる。"

#. type: defun
#: original_texis/numbers.texi:1014
msgid "Therefore,"
msgstr "したがって、"

#. type: group
#: original_texis/numbers.texi:1019
#, no-wrap
msgid ""
"(logand 13 12)\n"
"     @result{} 12\n"
msgstr ""
"(logand 13 12)\n"
"     @result{} 12\n"

#. type: defun
#: original_texis/numbers.texi:1026
msgid "If @code{logand} is not passed any argument, it returns a value of @minus{}1.  This number is an identity element for @code{logand} because its binary representation consists entirely of ones.  If @code{logand} is passed just one argument, it returns that argument."
msgstr "@code{logand}に何も引数も渡さなければ、値@minus{}1がリターンされる。@minus{}1を2進数で表すとすべてのビットが1なので、@minus{}1は@code{logand}にたいする単位元(identity element)である。"

#. type: group
#: original_texis/numbers.texi:1030 original_texis/numbers.texi:1060
#: original_texis/numbers.texi:1085
#, no-wrap
msgid ""
"                   ; @r{       30-bit binary values}\n"
"\n"
msgstr ""
"                   ; @r{       30ビット2進数}\n"
"\n"

#. type: group
#: original_texis/numbers.texi:1034
#, no-wrap
msgid ""
"(logand 14 13)     ; 14  =  @r{0000...001110}\n"
"                   ; 13  =  @r{0000...001101}\n"
"     @result{} 12         ; 12  =  @r{0000...001100}\n"
msgstr ""
"(logand 14 13)     ; 14  =  @r{0000...001110}\n"
"                   ; 13  =  @r{0000...001101}\n"
"     @result{} 12         ; 12  =  @r{0000...001100}\n"

#. type: group
#: original_texis/numbers.texi:1041
#, no-wrap
msgid ""
"(logand 14 13 4)   ; 14  =  @r{0000...001110}\n"
"                   ; 13  =  @r{0000...001101}\n"
"                   ;  4  =  @r{0000...000100}\n"
"     @result{} 4          ;  4  =  @r{0000...000100}\n"
msgstr ""
"(logand 14 13 4)   ; 14  =  @r{0000...001110}\n"
"                   ; 13  =  @r{0000...001101}\n"
"                   ;  4  =  @r{0000...000100}\n"
"     @result{} 4          ;  4  =  @r{0000...000100}\n"

#. type: group
#: original_texis/numbers.texi:1046
#, no-wrap
msgid ""
"(logand)\n"
"     @result{} -1         ; -1  =  @r{1111...111111}\n"
msgstr ""
"(logand)\n"
"     @result{} -1         ; -1  =  @r{1111...111111}\n"

#. type: defun
#: original_texis/numbers.texi:1050
#, no-wrap
msgid "logior &rest ints-or-markers"
msgstr "logior &rest ints-or-markers"

#. type: defun
#: original_texis/numbers.texi:1056
msgid "This function returns the bitwise inclusive OR of its arguments: the @var{n}th bit is 1 in the result if, and only if, the @var{n}th bit is 1 in at least one of the arguments.  If there are no arguments, the result is 0, which is an identity element for this operation.  If @code{logior} is passed just one argument, it returns that argument."
msgstr "この関数は、引数のビット単位の包含的ORをリターンする。少なくとも1つの引数で@var{n}番目のビットが1なら、結果の@var{n}番目のビットが1になる。引数を与えなければ、結果はこの処理にたいする単位元である0となる。@code{logior}に渡す引数が1つだけならその引数がリターンされる。"

#. type: group
#: original_texis/numbers.texi:1064
#, no-wrap
msgid ""
"(logior 12 5)      ; 12  =  @r{0000...001100}\n"
"                   ;  5  =  @r{0000...000101}\n"
"     @result{} 13         ; 13  =  @r{0000...001101}\n"
msgstr ""
"(logior 12 5)      ; 12  =  @r{0000...001100}\n"
"                   ;  5  =  @r{0000...000101}\n"
"     @result{} 13         ; 13  =  @r{0000...001101}\n"

#. type: group
#: original_texis/numbers.texi:1071
#, no-wrap
msgid ""
"(logior 12 5 7)    ; 12  =  @r{0000...001100}\n"
"                   ;  5  =  @r{0000...000101}\n"
"                   ;  7  =  @r{0000...000111}\n"
"     @result{} 15         ; 15  =  @r{0000...001111}\n"
msgstr ""
"(logior 12 5 7)    ; 12  =  @r{0000...001100}\n"
"                   ;  5  =  @r{0000...000101}\n"
"                   ;  7  =  @r{0000...000111}\n"
"     @result{} 15         ; 15  =  @r{0000...001111}\n"

#. type: defun
#: original_texis/numbers.texi:1075
#, no-wrap
msgid "logxor &rest ints-or-markers"
msgstr "logxor &rest ints-or-markers"

#. type: defun
#: original_texis/numbers.texi:1081
msgid "This function returns the bitwise exclusive OR of its arguments: the @var{n}th bit is 1 in the result if, and only if, the @var{n}th bit is 1 in an odd number of the arguments.  If there are no arguments, the result is 0, which is an identity element for this operation.  If @code{logxor} is passed just one argument, it returns that argument."
msgstr "この関数は、引数のビット単位の排他的ORをリターンする。@var{n}番目のビットが1であるような引数の数が奇数個の場合のみ、結果の@var{n}番目のビットが1となる。引数を与えなければ、結果はこの処理の単位元である0となる。@code{logxor}に渡す引数が1つだけならその引数がリターンされる。"

#. type: group
#: original_texis/numbers.texi:1089
#, no-wrap
msgid ""
"(logxor 12 5)      ; 12  =  @r{0000...001100}\n"
"                   ;  5  =  @r{0000...000101}\n"
"     @result{} 9          ;  9  =  @r{0000...001001}\n"
msgstr ""
"(logxor 12 5)      ; 12  =  @r{0000...001100}\n"
"                   ;  5  =  @r{0000...000101}\n"
"     @result{} 9          ;  9  =  @r{0000...001001}\n"

#. type: group
#: original_texis/numbers.texi:1096
#, no-wrap
msgid ""
"(logxor 12 5 7)    ; 12  =  @r{0000...001100}\n"
"                   ;  5  =  @r{0000...000101}\n"
"                   ;  7  =  @r{0000...000111}\n"
"     @result{} 14         ; 14  =  @r{0000...001110}\n"
msgstr ""
"(logxor 12 5 7)    ; 12  =  @r{0000...001100}\n"
"                   ;  5  =  @r{0000...000101}\n"
"                   ;  7  =  @r{0000...000111}\n"
"     @result{} 14         ; 14  =  @r{0000...001110}\n"

#. type: defun
#: original_texis/numbers.texi:1100
#, no-wrap
msgid "lognot integer"
msgstr "lognot integer"

#. type: defun
#: original_texis/numbers.texi:1104
msgid "This function returns the bitwise complement of its argument: the @var{n}th bit is one in the result if, and only if, the @var{n}th bit is zero in @var{integer}, and vice-versa."
msgstr "この関数は引数のビット単位の補数(bitwise complement)をリターンする。@var{integer}の@var{n}番目のビットが0の場合に限り、結果の@var{n}番目のビットが1になり、その逆も成り立つ。"

#. type: example
#: original_texis/numbers.texi:1111
#, no-wrap
msgid ""
"(lognot 5)\n"
"     @result{} -6\n"
";;  5  =  @r{0000...000101} (30 bits total)\n"
";; @r{becomes}\n"
";; -6  =  @r{1111...111010} (30 bits total)\n"
msgstr ""
"(lognot 5)\n"
"     @result{} -6\n"
";;  5  =  @r{0000...000101} (全部で30ビット)\n"
";; @r{becomes}\n"
";; -6  =  @r{1111...111010} (全部で30ビット)\n"

#. type: section
#: original_texis/numbers.texi:1115
#, no-wrap
msgid "Standard Mathematical Functions"
msgstr "Standard Mathematical Functions"

#. type: cindex
#: original_texis/numbers.texi:1116
#, no-wrap
msgid "transcendental functions"
msgstr "transcendental functions"

#. type: cindex
#: original_texis/numbers.texi:1117
#, no-wrap
msgid "mathematical functions"
msgstr "mathematical functions"

#. type: cindex
#: original_texis/numbers.texi:1118
#, no-wrap
msgid "floating-point functions"
msgstr "floating-point functions"

#. type: Plain text
#: original_texis/numbers.texi:1122
msgid "These mathematical functions allow integers as well as floating-point numbers as arguments."
msgstr "以下の数学的関数は、引数として整数と同様に浮動小数点数も受け入れます。"

#. type: defun
#: original_texis/numbers.texi:1123
#, no-wrap
msgid "sin arg"
msgstr "sin arg"

#. type: defunx
#: original_texis/numbers.texi:1124
#, no-wrap
msgid "cos arg"
msgstr "cos arg"

#. type: defunx
#: original_texis/numbers.texi:1125
#, no-wrap
msgid "tan arg"
msgstr "tan arg"

#. type: defun
#: original_texis/numbers.texi:1128
msgid "These are the basic trigonometric functions, with argument @var{arg} measured in radians."
msgstr "これらは三角関数であり、引数@var{arg}はラジアン単位。"

#. type: defun
#: original_texis/numbers.texi:1130
#, no-wrap
msgid "asin arg"
msgstr "asin arg"

#. type: defun
#: original_texis/numbers.texi:1132
msgid "The value of @code{(asin @var{arg})} is a number between"
msgstr "@code{(asin @var{arg})}の値は、sinの値が@var{arg}となるような"

#. type: ifnottex
#: original_texis/numbers.texi:1134 original_texis/numbers.texi:1165
msgid "@minus{}pi/2"
msgstr "@minus{}pi/2"

#. type: tex
#: original_texis/numbers.texi:1137 original_texis/numbers.texi:1168
#, no-wrap
msgid "@math{-\\pi/2}\n"
msgstr "@math{-\\pi/2}\n"

#. type: defun
#: original_texis/numbers.texi:1139 original_texis/numbers.texi:1170
msgid "and"
msgstr "から"

#. type: ifnottex
#: original_texis/numbers.texi:1141 original_texis/numbers.texi:1172
msgid "pi/2"
msgstr "pi/2"

#. type: tex
#: original_texis/numbers.texi:1144 original_texis/numbers.texi:1175
#, no-wrap
msgid "@math{\\pi/2}\n"
msgstr "@math{\\pi/2}\n"

#. type: defun
#: original_texis/numbers.texi:1147
msgid "(inclusive) whose sine is @var{arg}.  If @var{arg} is out of range (outside [@minus{}1, 1]), @code{asin} returns a NaN."
msgstr "(両端を含む)の数である。@var{arg}が範囲外([@minus{}1, 1]の外)なら、@code{asin}はNaNをリターンする。"

#. type: defun
#: original_texis/numbers.texi:1149
#, no-wrap
msgid "acos arg"
msgstr "acos arg"

#. type: defun
#: original_texis/numbers.texi:1151
msgid "The value of @code{(acos @var{arg})} is a number between 0 and"
msgstr "@code{(acos @var{arg})}の値は、cosの値が@var{arg}となるような、0から"

#. type: ifnottex
#: original_texis/numbers.texi:1153
msgid "pi"
msgstr "pi"

#. type: tex
#: original_texis/numbers.texi:1156
#, no-wrap
msgid "@math{\\pi}\n"
msgstr "@math{\\pi}\n"

#. type: defun
#: original_texis/numbers.texi:1159
msgid "(inclusive) whose cosine is @var{arg}.  If @var{arg} is out of range (outside [@minus{}1, 1]), @code{acos} returns a NaN."
msgstr "(両端を含む)の数である。argが範囲外([-1, 1]の外)なら@code{acos}はNaNをリターンする。"

#. type: defun
#: original_texis/numbers.texi:1161
#, no-wrap
msgid "atan y &optional x"
msgstr "atan y &optional x"

#. type: defun
#: original_texis/numbers.texi:1163
msgid "The value of @code{(atan @var{y})} is a number between"
msgstr "@code{(atan @var{y})}の値は、tanの値が@var{y}となるような、"

#. type: defun
#: original_texis/numbers.texi:1180
msgid "(exclusive) whose tangent is @var{y}.  If the optional second argument @var{x} is given, the value of @code{(atan y x)} is the angle in radians between the vector @code{[@var{x}, @var{y}]} and the @code{X} axis."
msgstr "(両端を含まず)の数である。オプションの第2引数@var{x}が与えられると、@code{(atan y x)}の値はベクトル@code{[@var{x}, @var{y}]}と@code{X}軸が成す角度のラジアン値となる。"

#. type: defun
#: original_texis/numbers.texi:1182
#, no-wrap
msgid "exp arg"
msgstr "exp arg"

#. type: defun
#: original_texis/numbers.texi:1185
msgid "This is the exponential function; it returns @math{e} to the power @var{arg}."
msgstr "これは指数関数である。この関数は@math{e}の指数@var{arg}をリターンする。"

#. type: defun
#: original_texis/numbers.texi:1187
#, no-wrap
msgid "log arg &optional base"
msgstr "log arg &optional base"

#. type: defun
#: original_texis/numbers.texi:1192
msgid "This function returns the logarithm of @var{arg}, with base @var{base}.  If you don't specify @var{base}, the natural base @math{e} is used.  If @var{arg} or @var{base} is negative, @code{log} returns a NaN."
msgstr "この関数は底を@var{base}とする@var{arg}の対数をリターンする。@var{base}を指定しなければ、自然底(natural base)@math{e}が使用される。@var{arg}か@var{base}が負なら、@code{log}はNaNをリターンする。"

#. type: defun
#: original_texis/numbers.texi:1194
#, no-wrap
msgid "expt x y"
msgstr "expt x y"

#. type: defun
#: original_texis/numbers.texi:1200
msgid "This function returns @var{x} raised to power @var{y}.  If both arguments are integers and @var{y} is positive, the result is an integer; in this case, overflow causes truncation, so watch out.  If @var{x} is a finite negative number and @var{y} is a finite non-integer, @code{expt} returns a NaN."
msgstr "この関数は@var{x}に@var{y}を乗じてリターンする。引数が両方とも整数で@var{y}が正なら結果は整数になる。この場合オーバーフローによる切り捨てが発生するので注意しされたい。@var{x}が有限の負数で@var{y}が有限の非整数なら、@code{expt}はNaNをリターンする。"

#. type: defun
#: original_texis/numbers.texi:1202
#, no-wrap
msgid "sqrt arg"
msgstr "sqrt arg"

#. type: defun
#: original_texis/numbers.texi:1205
msgid "This returns the square root of @var{arg}.  If @var{arg} is finite and less than zero, @code{sqrt} returns a NaN."
msgstr "これは@var{arg}の平方根をリターンする。@var{arg}が有限で0より小さければ、@code{sqrt}はNaNをリターンする。"

#. type: Plain text
#: original_texis/numbers.texi:1209
msgid "In addition, Emacs defines the following common mathematical constants:"
msgstr "加えて、Emacsは以下の数学的な定数を定義します:"

#. type: defvar
#: original_texis/numbers.texi:1210
#, no-wrap
msgid "float-e"
msgstr "float-e"

#. type: defvar
#: original_texis/numbers.texi:1212
msgid "The mathematical constant @math{e} (2.71828@dots{})."
msgstr "自然対数@math{e}(2.71828@dots{})"

#. type: defvar
#: original_texis/numbers.texi:1214
#, no-wrap
msgid "float-pi"
msgstr "float-pi"

#. type: defvar
#: original_texis/numbers.texi:1216
msgid "The mathematical constant @math{pi} (3.14159@dots{})."
msgstr "円周率@math{pi}(3.14159@dots{})"

#. type: cindex
#: original_texis/numbers.texi:1220
#, no-wrap
msgid "random numbers"
msgstr "random numbers"

#. type: Plain text
#: original_texis/numbers.texi:1228
msgid "A deterministic computer program cannot generate true random numbers.  For most purposes, @dfn{pseudo-random numbers} suffice.  A series of pseudo-random numbers is generated in a deterministic fashion.  The numbers are not truly random, but they have certain properties that mimic a random series.  For example, all possible values occur equally often in a pseudo-random series."
msgstr "決定論的なコンピュータープログラムでは真の乱数を生成することはできません。しかしほとんどの目的には、@dfn{疑似乱数(pseudo-random numbers)}で充分です。一連の疑似乱数は決定論的な手法により生成されます。真の乱数ではありませんが、それらにはランダム列を模する特別な性質があります。たとえば疑似ランダム系では、すべての可能な値は均等に発生します。"

#. type: cindex
#: original_texis/numbers.texi:1229
#, no-wrap
msgid "seed, for random number generation"
msgstr "seed, for random number generation"

#. type: Plain text
#: original_texis/numbers.texi:1235
msgid "Pseudo-random numbers are generated from a @dfn{seed value}.  Starting from any given seed, the @code{random} function always generates the same sequence of numbers.  By default, Emacs initializes the random seed at startup, in such a way that the sequence of values of @code{random} (with overwhelming likelihood) differs in each Emacs run."
msgstr "疑似乱数は@dfn{シード値(seed value)}から生成されます。与えられた任意のシードから開始することにより、@code{random}関数は常に同じ数列を生成します。デフォルトでは、Emacsは開始時に乱数シードを初期化することにより、それぞれのEmacsの実行において、@code{random}の値シーケンスは(ほとんど確実に)異なります。"

#. type: Plain text
#: original_texis/numbers.texi:1243
msgid "Sometimes you want the random number sequence to be repeatable.  For example, when debugging a program whose behavior depends on the random number sequence, it is helpful to get the same behavior in each program run.  To make the sequence repeat, execute @code{(random \"\")}.  This sets the seed to a constant value for your particular Emacs executable (though it may differ for other Emacs builds).  You can use other strings to choose various seed values."
msgstr "再現可能な乱数シーケンスが欲しい場合もあります。たとえば乱数シーケンスに依存するプログラムをデバッグする場合、プログラムの各実行において同じ挙動を得ることが助けになります。再現可能なシーケンスを作成するには、@code{(random \"\")}を実行します。これは特定のEmacsの実行可能ファイルにたいして、シードに定数値をセットします(しかしこの実行可能ファイルは、その他のEmacsビルドと異なるものになるであろう)。シード値として、他のさまざまな文字列を使用することができます。"

#. type: defun
#: original_texis/numbers.texi:1244
#, no-wrap
msgid "random &optional limit"
msgstr "random &optional limit"

#. type: defun
#: original_texis/numbers.texi:1247
msgid "This function returns a pseudo-random integer.  Repeated calls return a series of pseudo-random integers."
msgstr "この関数は疑似乱数の整数をリターンする。繰り返し呼び出すと一連の疑似乱数の整数をリターンする。"

#. type: defun
#: original_texis/numbers.texi:1253
msgid "If @var{limit} is a positive integer, the value is chosen to be nonnegative and less than @var{limit}.  Otherwise, the value might be any integer representable in Lisp, i.e., an integer between @code{most-negative-fixnum} and @code{most-positive-fixnum} (@pxref{Integer Basics})."
msgstr "@var{limit}が正なら、値は負ではない@var{limit}未満の値から選択される。それ以外なら値は@code{most-negative-fixnum}から@code{most-positive-fixnum}の間の、Lispで表現可能な任意の整数(@ref{Integer Basics}を参照)となるだろう。"

#. type: defun
#: original_texis/numbers.texi:1258
msgid "If @var{limit} is @code{t}, it means to choose a new seed as if Emacs were restarting, typically from the system entropy.  On systems lacking entropy pools, choose the seed from less-random volatile data such as the current time."
msgstr "@var{limit}が@code{t}なら、あたかもEmacsが再起動されたかのように、通常はシステムのエントロピーから新たなシードが選択されることを意味する。エントロピープールを欠くシステムでは、カレント時刻のような若干揮発性が低い乱数からシードが選択される。"

#. type: defun
#: original_texis/numbers.texi:1261
msgid "If @var{limit} is a string, it means to choose a new seed based on the string's contents."
msgstr "@var{limit}が文字列なら、その文字列定数にもとづいた新しいシードを選択することを意味する。"
