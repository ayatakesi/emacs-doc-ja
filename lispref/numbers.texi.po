# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Emacs 26.1\n"
"POT-Creation-Date: 2021-08-15 02:27+0900\n"
"PO-Revision-Date: 2021-05-21 12:21+0900\n"
"Last-Translator: Takeshi Ayanokoji <takeshi.ayanokoji@gmail.com>\n"
"Language-Team: Japanese <takeshi.ayanokoji@gmail.com>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: original_texis/numbers.texi:6 original_texis/numbers.texi:7
#, no-wrap
msgid "Numbers"
msgstr "Numbers"

#. type: cindex
#: original_texis/numbers.texi:8
#, no-wrap
msgid "integers"
msgstr "integers"

#. type: cindex
#: original_texis/numbers.texi:9
#, no-wrap
msgid "numbers"
msgstr "numbers"

#. type: Plain text
#: original_texis/numbers.texi:20
msgid "GNU Emacs supports two numeric data types: @dfn{integers} and @dfn{floating-point numbers}.  Integers are whole numbers such as @minus{}3, 0, 7, 13, and 511.  Floating-point numbers are numbers with fractional parts, such as @minus{}4.5, 0.0, and 2.71828.  They can also be expressed in exponential notation: @samp{1.5e2} is the same as @samp{150.0}; here, @samp{e2} stands for ten to the second power, and that is multiplied by 1.5.  Integer computations are exact.  Floating-point computations often involve rounding errors, as the numbers have a fixed amount of precision."
msgstr "GNU Emacsは2つの数値データ型 --- @dfn{整数(integers)}と@dfn{浮動小数点数(floating-point numbers)}をサポートします。整数は@minus{}3、0、7、13、511などの整数です。浮動小数点数は@minus{}4.5、0.0、2.71828などの小数部をもちます。これらは指数記数法でも表現できます --- @samp{1.5e2}は@samp{150.0}と同じです。ここで@samp{e2}は10の2乗を表し、それに1.5を乗じるという意味です。整数計算は正確です。浮動小数点数の計算では数値は固定された精度をもつので、しばしば丸め誤差(rounding errors)が発生します。"

#. type: section
#: original_texis/numbers.texi:32 original_texis/numbers.texi:34
#: original_texis/numbers.texi:35
#, no-wrap
msgid "Integer Basics"
msgstr "Integer Basics"

#. type: menuentry
#: original_texis/numbers.texi:32
msgid "Representation and range of integers."
msgstr "整数の表現と範囲。"

#. type: node
#: original_texis/numbers.texi:32 original_texis/numbers.texi:217
#, no-wrap
msgid "Float Basics"
msgstr "Float Basics"

#. type: menuentry
#: original_texis/numbers.texi:32
msgid "Representation and range of floating point."
msgstr "浮動少数の表現と範囲。"

#. type: node
#: original_texis/numbers.texi:32 original_texis/numbers.texi:341
#, no-wrap
msgid "Predicates on Numbers"
msgstr "Predicates on Numbers"

#. type: menuentry
#: original_texis/numbers.texi:32
msgid "Testing for numbers."
msgstr "数にたいするテスト。"

#. type: section
#: original_texis/numbers.texi:32 original_texis/numbers.texi:397
#: original_texis/numbers.texi:398
#, no-wrap
msgid "Comparison of Numbers"
msgstr "Comparison of Numbers"

#. type: menuentry
#: original_texis/numbers.texi:32
msgid "Equality and inequality predicates."
msgstr "同一性と非同一性の述語。"

#. type: section
#: original_texis/numbers.texi:32 original_texis/numbers.texi:506
#: original_texis/numbers.texi:507
#, no-wrap
msgid "Numeric Conversions"
msgstr "Numeric Conversions"

#. type: menuentry
#: original_texis/numbers.texi:32
msgid "Converting float to integer and vice versa."
msgstr "浮動小数点数から整数の変換と逆変換。"

#. type: section
#: original_texis/numbers.texi:32 original_texis/numbers.texi:601
#: original_texis/numbers.texi:602
#, no-wrap
msgid "Arithmetic Operations"
msgstr "Arithmetic Operations"

#. type: menuentry
#: original_texis/numbers.texi:32
msgid "How to add, subtract, multiply and divide."
msgstr "加減乗除の方法。"

#. type: section
#: original_texis/numbers.texi:32 original_texis/numbers.texi:827
#: original_texis/numbers.texi:828
#, no-wrap
msgid "Rounding Operations"
msgstr "Rounding Operations"

#. type: menuentry
#: original_texis/numbers.texi:32
msgid "Explicitly rounding floating-point numbers."
msgstr "浮動小数点数の明示的な丸め。"

#. type: node
#: original_texis/numbers.texi:32 original_texis/numbers.texi:859
#, no-wrap
msgid "Bitwise Operations"
msgstr "Bitwise Operations"

#. type: menuentry
#: original_texis/numbers.texi:32
msgid "Logical and, or, not, shifting."
msgstr "論理的なand、or、not、shift。"

#. type: node
#: original_texis/numbers.texi:32 original_texis/numbers.texi:1115
#, no-wrap
msgid "Math Functions"
msgstr "Math Functions"

#. type: menuentry
#: original_texis/numbers.texi:32
msgid "Trig, exponential and logarithmic functions."
msgstr "三角関数、指数、対数関数。"

#. type: section
#: original_texis/numbers.texi:32 original_texis/numbers.texi:1219
#: original_texis/numbers.texi:1220
#, no-wrap
msgid "Random Numbers"
msgstr "Random Numbers"

#. type: menuentry
#: original_texis/numbers.texi:32
msgid "Obtaining random integers, predictable or not."
msgstr "予測可能または不可能な乱数の取得。"

#. type: Plain text
#: original_texis/numbers.texi:40
msgid "The Lisp reader reads an integer as a nonempty sequence of decimal digits with optional initial sign and optional final period."
msgstr "Lispリーダーは、10進数字のシーケンス(オプションで最初の符号記号と最後のピリオドをともなう)として整数を読み取ります。"

#. type: example
#: original_texis/numbers.texi:48
#, no-wrap
msgid ""
" 1               ; @r{The integer 1.}\n"
" 1.              ; @r{The integer 1.}\n"
"+1               ; @r{Also the integer 1.}\n"
"-1               ; @r{The integer @minus{}1.}\n"
" 0               ; @r{The integer 0.}\n"
"-0               ; @r{The integer 0.}\n"
msgstr ""
" 1               ; @r{整数1}\n"
" 1.              ; @r{整数1}\n"
"+1               ; @r{これも整数1}\n"
"-1               ; @r{整数@minus{}1}\n"
" 0               ; @r{整数0}\n"
"-0               ; @r{整数0}\n"

#. type: cindex
#: original_texis/numbers.texi:50
#, no-wrap
msgid "integers in specific radix"
msgstr "integers in specific radix"

#. type: cindex
#: original_texis/numbers.texi:51
#, no-wrap
msgid "radix for reading an integer"
msgstr "radix for reading an integer"

#. type: cindex
#: original_texis/numbers.texi:52
#, no-wrap
msgid "base for reading an integer"
msgstr "base for reading an integer"

#. type: cindex
#: original_texis/numbers.texi:53
#, no-wrap
msgid "hex numbers"
msgstr "hex numbers"

#. type: cindex
#: original_texis/numbers.texi:54
#, no-wrap
msgid "octal numbers"
msgstr "octal numbers"

#. type: cindex
#: original_texis/numbers.texi:55
#, no-wrap
msgid "reading numbers in hex, octal, and binary"
msgstr "reading numbers in hex, octal, and binary"

#. type: Plain text
#: original_texis/numbers.texi:67
msgid "The syntax for integers in bases other than 10 consists of @samp{#} followed by a radix indication followed by one or more digits.  The radix indications are @samp{b} for binary, @samp{o} for octal, @samp{x} for hex, and @samp{@var{radix}r} for radix @var{radix}.  Thus, @samp{#b@var{integer}} reads @var{integer} in binary, and @samp{#@var{radix}r@var{integer}} reads @var{integer} in radix @var{radix}.  Allowed values of @var{radix} run from 2 to 36, and allowed digits are the first @var{radix} characters taken from @samp{0}--@samp{9}, @samp{A}--@samp{Z}.  Letter case is ignored and there is no initial sign or final period.  For example:"
msgstr "10以外の基数をもつ整数の構文は@samp{#}、基数表示(radix indication)、その後の1つ以上の数字から構成されます。基数表示は2進数(binary)は@samp{b}、8進数(octal)は@samp{o}、16進数(hex)は@samp{x}、基数@var{radix}にたいしては@samp{@var{radix}r}になります。したがって@samp{#b@var{integer}}は2進数、@samp{#@var{radix}r@var{integer}}は基数@var{radix}で@var{integer}を読み取ります。@var{radix}の値として可能な値は2から36であり、最初の@var{radix}文字は@samp{0}--@samp{9}および@samp{A}--@samp{Z}から採択されます。英文字のcase(大文字小文字)は無視されて、最初の符号と最後のピリオドはありません。たとえば:"

#. type: example
#: original_texis/numbers.texi:73
#, no-wrap
msgid ""
"#b101100 @result{} 44\n"
"#o54 @result{} 44\n"
"#x2c @result{} 44\n"
"#24r1k @result{} 44\n"
msgstr ""
"#b101100 @result{} 44\n"
"#o54 @result{} 44\n"
"#x2c @result{} 44\n"
"#24r1k @result{} 44\n"

#. type: Plain text
#: original_texis/numbers.texi:78
msgid "To understand how various functions work on integers, especially the bitwise operators (@pxref{Bitwise Operations}), it is often helpful to view the numbers in their binary form."
msgstr "整数にたいして処理を行なうさまざまな関数、特にビット演算(@ref{Bitwise Operations}を参照)を理解するためには、数を2進形式で見ることが助けになることがよくあります。"

#. type: Plain text
#: original_texis/numbers.texi:80
msgid "In binary, the decimal integer 5 looks like this:"
msgstr "10進整数の5は2進数では以下のようになります:"

#. type: example
#: original_texis/numbers.texi:83
#, no-wrap
msgid "@dots{}000101\n"
msgstr "@dots{}000101\n"

#. type: Plain text
#: original_texis/numbers.texi:89
msgid "(The ellipsis @samp{@dots{}} stands for a conceptually infinite number of bits that match the leading bit; here, an infinite number of 0 bits.  Later examples also use this @samp{@dots{}} notation.)"
msgstr "(省略記号@samp{@dots{}}は概念的に先頭ビットにマッチする無限個数のビットを意味する。ここでは無限個の0ビット。後の例でも@samp{@dots{}}表記を使用する。)"

#. type: Plain text
#: original_texis/numbers.texi:91
msgid "The integer @minus{}1 looks like this:"
msgstr "整数の@minus{}1は以下のようになります:"

#. type: example
#: original_texis/numbers.texi:94
#, no-wrap
msgid "@dots{}111111\n"
msgstr "@dots{}111111\n"

#. type: cindex
#: original_texis/numbers.texi:97
#, no-wrap
msgid "two's complement"
msgstr "two's complement"

#. type: Plain text
#: original_texis/numbers.texi:100
msgid "@minus{}1 is represented as all ones.  (This is called @dfn{two's complement} notation.)"
msgstr "@minus{}1はすべて1で表現されます(@dfn{2の補数}表記と呼ばれる)。"

#. type: Plain text
#: original_texis/numbers.texi:104
msgid "Subtracting 4 from @minus{}1 returns the negative integer @minus{}5.  In binary, the decimal integer 4 is 100.  Consequently, @minus{}5 looks like this:"
msgstr "@minus{}1から4を減じることで負の整数@minus{}5が得られます。10進の整数4は2進では100です。したがって@minus{}5は以下のようになります:"

#. type: example
#: original_texis/numbers.texi:107
#, no-wrap
msgid "@dots{}111011\n"
msgstr "@dots{}111011\n"

#. type: Plain text
#: original_texis/numbers.texi:114
msgid "Many of the functions described in this chapter accept markers for arguments in place of numbers.  (@xref{Markers}.)  Since the actual arguments to such functions may be either numbers or markers, we often give these arguments the name @var{number-or-marker}.  When the argument value is a marker, its position value is used and its buffer is ignored."
msgstr "このチャプターで説明する多くの関数は、数字の位置として引数にマーカー(@ref{Markers}を参照)を受け取ります。そのような関数にたいする実際の引数は数字かマーカーなので、わたしたちはこれらの引数に@var{number-or-marker}という名前を与えることがあります。引数の値がマーカーならマーカーの位置が使用され、マーカーのバッファーは無視されます。"

#. type: Plain text
#: original_texis/numbers.texi:118
msgid "In Emacs Lisp, text characters are represented by integers.  Any integer between zero and the value of @code{(max-char)}, inclusive, is considered to be valid as a character.  @xref{Character Codes}."
msgstr "Emacs Lispでは、テキスト文字は整数により表現されます。0から@code{(max-char)}までの整数は、有効な文字として判断されます。@ref{Character Codes}を参照してください。"

#. type: Plain text
#: original_texis/numbers.texi:129
msgid "Integers in Emacs Lisp are not limited to the machine word size.  Under the hood, though, there are two kinds of integers: smaller ones, called @dfn{fixnums}, and larger ones, called @dfn{bignums}.  Although Emacs Lisp code ordinarily should not depend on whether an integer is a fixnum or a bignum, older Emacs versions support only fixnums, some functions in Emacs still accept only fixnums, and older Emacs Lisp code may have trouble when given bignums.  For example, while older Emacs Lisp code could safely compare integers for numeric equality with @code{eq}, the presence of bignums means that equality predicates like @code{eql} and @code{=} should now be used to compare integers."
msgstr "Emacs Lispの整数はマシンのワードサイズに制限されません。しかしその背後には@dfn{fixnums}と呼ばれる小さい整数と、@dfn{bignums}と呼ばれる大きい整数という2種類の整数が存在します。Emacs Lispコードは通常は整数がfixnumかbignumのいずれであるかに依存するべきではありませんが、Emacsの古いバージョンではfixnumだけがサポートされており、未だにfixnumだけを受け取るEmacs関数がいくつかあり、古いEmacs Lispコードがbignumを受け取ると問題が起こるかもしれません。たとえば古いEmacs Lispコードは@code{eq}で整数にたいする数値の等価性を安全に比較できましたが、bignumの登場により整数の比較には@code{eql}や@code{=}のような等価性にたいする述語を使うことが必要になりました。"

#. type: Plain text
#: original_texis/numbers.texi:137
msgid "The range of values for bignums is limited by the amount of main memory, by machine characteristics such as the size of the word used to represent a bignum's exponent, and by the @code{integer-width} variable.  These limits are typically much more generous than the limits for fixnums.  A bignum is never numerically equal to a fixnum; Emacs always represents an integer in fixnum range as a fixnum, not a bignum."
msgstr "bignumの値の範囲は主メモリー量、bignumの指数の表現に使用されるワードサイズのようなマシン特性、および@code{integer-width}変数により制限されます。これらの制限は通常はfixnumにたいする制限よりは寛大です。bignumが数値的にfixnumと等しくなることはありません。Emacsはfixnum範囲内の整数を、bignumではなく常にfixnumとして表現します。"

#. type: Plain text
#: original_texis/numbers.texi:140
msgid "The range of values for a fixnum depends on the machine.  The minimum range is @minus{}536,870,912 to 536,870,911 (30 bits; i.e.,"
msgstr "fixnumの値の範囲はマシンに依存します。最小の範囲は@minus{}536,870,912から536,870,911(30ビット長の"

#. type: ifnottex
#: original_texis/numbers.texi:142 original_texis/numbers.texi:183
msgid "@minus{}2**29"
msgstr "@minus{}2**29"

#. type: tex
#: original_texis/numbers.texi:145 original_texis/numbers.texi:186
#, no-wrap
msgid "@math{-2^{29}}\n"
msgstr "@math{-2^{29}}\n"

#. type: Plain text
#: original_texis/numbers.texi:147
msgid "to"
msgstr "から"

#. type: ifnottex
#: original_texis/numbers.texi:149
msgid "2**29 @minus{} 1),"
msgstr "2**29 @minus{} 1)"

#. type: tex
#: original_texis/numbers.texi:152
#, no-wrap
msgid "@math{2^{29}-1}),\n"
msgstr "@math{2^{29}-1})\n"

#. type: Plain text
#: original_texis/numbers.texi:154
msgid "but many machines provide a wider range."
msgstr "ですが、多くのマシンはより広い範囲を提供します。"

#. type: cindex
#: original_texis/numbers.texi:155
#, no-wrap
msgid "largest fixnum"
msgstr "largest fixnum"

#. type: cindex
#: original_texis/numbers.texi:156
#, no-wrap
msgid "maximum fixnum"
msgstr "maximum fixnum"

#. type: defvar
#: original_texis/numbers.texi:157
#, no-wrap
msgid "most-positive-fixnum"
msgstr "most-positive-fixnum"

#. type: defvar
#: original_texis/numbers.texi:160
msgid "The value of this variable is the greatest ``small'' integer that Emacs Lisp can handle.  Typical values are"
msgstr "この変数の値はEmacs Lispが扱える``小さい''整数の最大値。典型的な値は32ビットでは"

#. type: ifnottex
#: original_texis/numbers.texi:162
msgid "2**29 @minus{} 1"
msgstr "2**29 @minus{} 1"

#. type: tex
#: original_texis/numbers.texi:165
#, no-wrap
msgid "@math{2^{29}-1}\n"
msgstr "@math{2^{29}-1}\n"

#. type: defvar
#: original_texis/numbers.texi:167 original_texis/numbers.texi:188
msgid "on 32-bit and"
msgstr "、64ビットでは"

#. type: ifnottex
#: original_texis/numbers.texi:169
msgid "2**61 @minus{} 1"
msgstr "2**61 @minus{} 1"

#. type: tex
#: original_texis/numbers.texi:172
#, no-wrap
msgid "@math{2^{61}-1}\n"
msgstr "@math{2^{61}-1}\n"

#. type: defvar
#: original_texis/numbers.texi:174 original_texis/numbers.texi:195
msgid "on 64-bit platforms."
msgstr "。"

#. type: cindex
#: original_texis/numbers.texi:176
#, no-wrap
msgid "smallest fixnum"
msgstr "smallest fixnum"

#. type: cindex
#: original_texis/numbers.texi:177
#, no-wrap
msgid "minimum fixnum"
msgstr "minimum fixnum"

#. type: defvar
#: original_texis/numbers.texi:178
#, no-wrap
msgid "most-negative-fixnum"
msgstr "most-negative-fixnum"

#. type: defvar
#: original_texis/numbers.texi:181
msgid "The value of this variable is the numerically least ``small'' integer that Emacs Lisp can handle.  It is negative.  Typical values are"
msgstr "この変数の値はEmacs Lispが扱える数値的に最小の``小さい''整数。これは負の整数。典型的な値は32ビットでは"

#. type: ifnottex
#: original_texis/numbers.texi:190
msgid "@minus{}2**61"
msgstr "@minus{}2**61、"

#. type: tex
#: original_texis/numbers.texi:193
#, no-wrap
msgid "@math{-2^{61}}\n"
msgstr "@math{-2^{61}}、\n"

#. type: cindex
#: original_texis/numbers.texi:197
#, no-wrap
msgid "bignum range"
msgstr "bignum range"

#. type: cindex
#: original_texis/numbers.texi:198
#, no-wrap
msgid "integer range"
msgstr "integer range"

#. type: cindex
#: original_texis/numbers.texi:199
#, no-wrap
msgid "number of bignum bits, limit on"
msgstr "number of bignum bits, limit on"

#. type: defvar
#: original_texis/numbers.texi:200
#, no-wrap
msgid "integer-width"
msgstr "integer-width"

#. type: defvar
#: original_texis/numbers.texi:204
msgid "The value of this variable is a nonnegative integer that controls whether Emacs signals a range error when a large integer would be calculated.  Integers with absolute values less than"
msgstr "この変数の値は大きな整数えお計算時にEmacsが範囲エラー(range error)をシグナルするかどうかを制御する負ではない整数。絶対値が"

#. type: ifnottex
#: original_texis/numbers.texi:206
msgid "2**@var{n},"
msgstr "2**@var{n},"

#. type: tex
#: original_texis/numbers.texi:209
#, no-wrap
msgid "@math{2^{n}},\n"
msgstr "@math{2^{n}},\n"

#. type: defvar
#: original_texis/numbers.texi:215
msgid "where @var{n} is this variable's value, do not signal a range error.  Attempts to create larger integers typically signal a range error, although there might be no signal if a larger integer can be created cheaply.  Setting this variable to a large number can be costly if a computation creates huge integers."
msgstr "(@var{n}はこの変数の値)が小さい整数は範囲エラーをシグナルしない。大きい整数を簡単に作成できればエラーがシグナルされない場合もあるが、通常は大きな整数の作成を試みると範囲エラーをシグナルする。この変数に大きな数値を設定すると、巨大な整数の計算にコストを要する可能性がある。"

#. type: section
#: original_texis/numbers.texi:218
#, no-wrap
msgid "Floating-Point Basics"
msgstr "Floating-Point Basics"

#. type: cindex
#: original_texis/numbers.texi:220
#, no-wrap
msgid "@acronym{IEEE} floating point"
msgstr "@acronym{IEEE} floating point"

#. type: Plain text
#: original_texis/numbers.texi:233
msgid "Floating-point numbers are useful for representing numbers that are not integral.  The range of floating-point numbers is the same as the range of the C data type @code{double} on the machine you are using.  On all computers supported by Emacs, this is @acronym{IEEE} binary64 floating point format, which is standardized by @url{https://standards.ieee.org/standard/754-2019.html,,IEEE Std 754-2019} and is discussed further in David Goldberg's paper ``@url{https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html, What Every Computer Scientist Should Know About Floating-Point Arithmetic}''.  On modern platforms, floating-point operations follow the IEEE-754 standard closely; however, results are not always rounded correctly on some obsolescent platforms, notably 32-bit x86."
msgstr "浮動小数点数は整数以外の数値の表現に有用です。浮動小数点数の範囲は使用中のシンでのCのデータ型@code{double}と同じ範囲です。Emacsがサポートするすべてのコンピューターでは@acronym{IEEE}の64ビット浮動小数フォーマットであり、これは@url{https://standards.ieee.org/standard/754-2019.html,,IEEE Std 754-2019}で標準化されたもので、David Goldbergの論文``@url{https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html, What Every Computer Scientist Should Know About Floating-Point Arithmetic}''で更に議論されています。モダンなプラットフォームでは浮動小数処理はIEEE-754標準に厳密にしたがいますが、特に32ビットX86のような陳腐化したプラットフォームでは丸めは常に正しい訳ではありません。"

#. type: Plain text
#: original_texis/numbers.texi:242
msgid "The read syntax for floating-point numbers requires either a decimal point, an exponent, or both.  Optional signs (@samp{+} or @samp{-})  precede the number and its exponent.  For example, @samp{1500.0}, @samp{+15e2}, @samp{15.0e+2}, @samp{+1500000e-3}, and @samp{.15e4} are five ways of writing a floating-point number whose value is 1500.  They are all equivalent.  Like Common Lisp, Emacs Lisp requires at least one digit after any decimal point in a floating-point number; @samp{1500.} is an integer, not a floating-point number."
msgstr "浮動小数点数にたいする入力構文は、小数点と指数のどちらか1つ、または両方が必要とします。オプションの符号(@samp{+}か@samp{-})は、その数字と指数の前に記述します。たとえば@samp{1500.0}、@samp{+15e2}、@samp{15.0e+2}、@samp{+1500000e-3}、@samp{.15e4}は値が1500の浮動小数点数を記述する5つの方法です。これらはすべて等価です。Common Lispと同様、Emacs Lispは浮動小数点数の小数点の後に少なくとも1つの数字を必要とします。@samp{1500.}は整数であって浮動小数点数ではありません。"

#. type: Plain text
#: original_texis/numbers.texi:248
msgid "Emacs Lisp treats @code{-0.0} as numerically equal to ordinary zero with respect to numeric comparisons like @code{=}.  This follows the @acronym{IEEE} floating-point standard, which says @code{-0.0} and @code{0.0} are numerically equal even though other operations can distinguish them."
msgstr "Emacs Lispは@code{=}のような数学的な比較に関して、@code{-0.0}を通常の0と数学的に同じものとして扱います。これは、(他の処理がこれらを区別するとしても@code{-0.0}と@code{0.0}は数学的に等しいとする)@acronym{IEEE}浮動小数点数規格にしたがっています。"

#. type: cindex
#: original_texis/numbers.texi:249
#, no-wrap
msgid "positive infinity"
msgstr "positive infinity"

#. type: cindex
#: original_texis/numbers.texi:250
#, no-wrap
msgid "negative infinity"
msgstr "negative infinity"

#. type: item
#: original_texis/numbers.texi:251 original_texis/numbers.texi:276
#, no-wrap
msgid "infinity"
msgstr "infinity"

#. type: cindex
#: original_texis/numbers.texi:252
#, no-wrap
msgid "NaN"
msgstr "NaN"

#. type: Plain text
#: original_texis/numbers.texi:263
msgid "The @acronym{IEEE} floating-point standard supports positive infinity and negative infinity as floating-point values.  It also provides for a class of values called NaN, or ``not a number''; numerical functions return such values in cases where there is no correct answer.  For example, @code{(/ 0.0 0.0)} returns a NaN@.  A NaN is never numerically equal to any value, not even to itself.  NaNs carry a sign and a significand, and non-numeric functions treat two NaNs as equal when their signs and significands agree.  Significands of NaNs are machine-dependent, as are the digits in their string representation."
msgstr "@acronym{IEEE}浮動小数点数規格は浮動小数点数として、正の無限大と負の無限大をサポートします。この規格はNaNまたは``not a number(数字ではない)''と呼ばれる値クラスも提供します。正しい答えが存在しないような場合に、数学関数はこのような値をリターンします。たとえば@code{(/ 0.0 0.0)}はNaNをリターンします。数値的にNaNはたとえ自身と比較してもすべての値にたいして数値的にイコールになることはありません。NaNは符号と仮数をもち、非数学関数は符号と仮数が一致すれば2つのNaNを等しいものと扱います。NaNの仮数は文字列表現の数字のようにマシン依存です。"

#. type: Plain text
#: original_texis/numbers.texi:272
msgid "When NaNs and signed zeros are involved, non-numeric functions like @code{eql}, @code{equal}, @code{sxhash-eql}, @code{sxhash-equal} and @code{gethash} determine whether values are indistinguishable, not whether they are numerically equal.  For example, when @var{x} and @var{y} are the same NaN, @code{(equal x y)} returns @code{t} whereas @code{(= x y)} uses numeric comparison and returns @code{nil}; conversely, @code{(equal 0.0 -0.0)} returns @code{nil} whereas @code{(= 0.0 -0.0)} returns @code{t}."
msgstr "NaNと符号つき0が関係する際には@code{eql}、@code{equal}、@code{sxhash-eql}、@code{sxhash-equal}、@code{gethash}のような非数学関数はそれらが数学的にイコールかではなく、値が区別できるかどうかを判断します。たとえば@var{x}と@var{y}が同じNaNなら数値比較を使用する@code{(= x y)}は@code{nil}をリターンするのにたいして@code{(equal x y)}は@code{t}をリターンして、反対に@code{(= 0.0 -0.0)}が@code{t}をリターンするのにたいして@code{(equal 0.0 -0.0)}は@code{nil}をリターンします。"

#. type: Plain text
#: original_texis/numbers.texi:274
msgid "Here are read syntaxes for these special floating-point values:"
msgstr "以下は、これらの特別な浮動小数点数にたいする入力構文です:"

#. type: table
#: original_texis/numbers.texi:278
msgid "@samp{1.0e+INF} and @samp{-1.0e+INF}"
msgstr "@samp{1.0e+INF}と@samp{-1.0e+INF}"

#. type: item
#: original_texis/numbers.texi:278
#, no-wrap
msgid "not-a-number"
msgstr "not-a-number"

#. type: table
#: original_texis/numbers.texi:280
msgid "@samp{0.0e+NaN} and @samp{-0.0e+NaN}"
msgstr "@samp{0.0e+NaN}と@samp{-0.0e+NaN}"

#. type: Plain text
#: original_texis/numbers.texi:284
msgid "The following functions are specialized for handling floating-point numbers:"
msgstr "以下の関数は浮動小数点数を扱うために特化したものです:"

#. type: defun
#: original_texis/numbers.texi:285
#, no-wrap
msgid "isnan x"
msgstr "isnan x"

#. type: defun
#: original_texis/numbers.texi:288
msgid "This predicate returns @code{t} if its floating-point argument is a NaN, @code{nil} otherwise."
msgstr "この述語は浮動小数引数がNaNなら@code{t}、それ以外は@code{nil}をリターンする。"

#. type: defun
#: original_texis/numbers.texi:290
#, no-wrap
msgid "frexp x"
msgstr "frexp x"

#. type: defun
#: original_texis/numbers.texi:294
msgid "This function returns a cons cell @code{(@var{s} . @var{e})}, where @var{s} and @var{e} are respectively the significand and exponent of the floating-point number @var{x}."
msgstr "この関数はコンスセル@code{(@var{s} . @var{e})}をリターンする。ここで@var{s}と@var{e}は、浮動小数点数の仮数(浮動小数点数を2の指数表現したときの仮数)と指数である。"

#. type: defun
#: original_texis/numbers.texi:297
msgid "If @var{x} is finite, then @var{s} is a floating-point number between 0.5 (inclusive) and 1.0 (exclusive), @var{e} is an integer, and"
msgstr "@var{x}が有限なら@var{s}は0.5以上1.0未満の浮動小数点数、@var{e}は整数で、"

#. type: ifnottex
#: original_texis/numbers.texi:299
msgid "@var{x} = @var{s} * 2**@var{e}."
msgstr "@var{x} = @var{s} * 2**@var{e}となる。"

#. type: tex
#: original_texis/numbers.texi:302
#, no-wrap
msgid "@math{x = s 2^e}.\n"
msgstr "@math{x = s 2^e}となる。\n"

#. type: defun
#: original_texis/numbers.texi:306
msgid "If @var{x} is zero or infinity, then @var{s} is the same as @var{x}.  If @var{x} is a NaN, then @var{s} is also a NaN@.  If @var{x} is zero, then @var{e} is 0."
msgstr "@var{x}が0または無限なら@var{s}は@var{x}と等しくなる。@var{x}がNaNなら@var{s}もNaN。@var{x}が0なら@var{e}は0。"

#. type: defun
#: original_texis/numbers.texi:308
#, no-wrap
msgid "ldexp s e"
msgstr "ldexp s e"

#. type: defun
#: original_texis/numbers.texi:311
msgid "Given a numeric significand @var{s} and an integer exponent @var{e}, this function returns the floating point number"
msgstr "数値の仮数@var{s}と整数の指数@var{e}を与えられると、この関数は浮動小数点数"

#. type: ifnottex
#: original_texis/numbers.texi:313
msgid "@var{s} * 2**@var{e}."
msgstr "@var{s} * 2**@var{e}をリターンする。"

#. type: tex
#: original_texis/numbers.texi:316
#, no-wrap
msgid "@math{s 2^e}.\n"
msgstr "@math{s 2^e}をリターンする。\n"

#. type: defun
#: original_texis/numbers.texi:319
#, no-wrap
msgid "copysign x1 x2"
msgstr "copysign x1 x2"

#. type: defun
#: original_texis/numbers.texi:322
msgid "This function copies the sign of @var{x2} to the value of @var{x1}, and returns the result.  @var{x1} and @var{x2} must be floating point."
msgstr "この関数は@var{x2}の符号を@var{x1}の値にコピーして結果をリターンする。@var{x1}と@var{x2}は浮動小数でなければならない。"

#. type: defun
#: original_texis/numbers.texi:324
#, no-wrap
msgid "logb x"
msgstr "logb x"

#. type: defun
#: original_texis/numbers.texi:330
msgid "This function returns the binary exponent of @var{x}.  More precisely, if @var{x} is finite and nonzero, the value is the logarithm base 2 of @math{|x|}, rounded down to an integer.  If @var{x} is zero or infinite, the value is infinity; if @var{x} is a NaN, the value is a NaN."
msgstr "この関数は@var{x}の2進指数をリターンする。より正確には@var{x}が有限かつ非0なら@math{|x|}の2を底とする対数を整数に切り下げた値。@var{x}が0または無限なら値は無限大。@var{x}がNaなら値はNaN。"

#. type: example
#: original_texis/numbers.texi:338
#, no-wrap
msgid ""
"(logb 10)\n"
"     @result{} 3\n"
"(logb 10.0e20)\n"
"     @result{} 69\n"
"(logb 0)\n"
"     @result{} -1.0e+INF\n"
msgstr ""
"(logb 10)\n"
"     @result{} 3\n"
"(logb 10.0e20)\n"
"     @result{} 69\n"
"(logb 0)\n"
"     @result{} -1.0e+INF\n"

#. type: section
#: original_texis/numbers.texi:342
#, no-wrap
msgid "Type Predicates for Numbers"
msgstr "Type Predicates for Numbers"

#. type: cindex
#: original_texis/numbers.texi:343
#, no-wrap
msgid "predicates for numbers"
msgstr "predicates for numbers"

#. type: Plain text
#: original_texis/numbers.texi:351
msgid "The functions in this section test for numbers, or for a specific type of number.  The functions @code{integerp} and @code{floatp} can take any type of Lisp object as argument (they would not be of much use otherwise), but the @code{zerop} predicate requires a number as its argument.  See also @code{integer-or-marker-p} and @code{number-or-marker-p}, in @ref{Predicates on Markers}."
msgstr "このセクションの関数は数値や、特定の数値型にたいしてテストを行ないます。関数@code{integerp}と@code{floatp}は、引数として任意のLispオブジェクト型をとることができます(でなければ、あまり使用する機会ない)。しかし述語@code{zerop}は引数として数値を要求します。@ref{Predicates on Markers}の@code{integer-or-marker-p}、@code{number-or-marker-p}も参照してください。"

#. type: defun
#: original_texis/numbers.texi:352
#, no-wrap
msgid "bignump object"
msgstr "bignump object"

#. type: defun
#: original_texis/numbers.texi:356
msgid "This predicate tests whether its argument is a large integer, and returns @code{t} if so, @code{nil} otherwise.  Unlike small integers, large integers can be @code{=} or @code{eql} even if they are not @code{eq}."
msgstr "この述語は引数が大きい整数かどうかをテストしてもしそうなら@code{t}、それ以外は@code{nil}をリターンする。小さい整数とは異なり大きい整数は@code{eq}でなくても@code{=}や@code{eql}になり得る。"

#. type: defun
#: original_texis/numbers.texi:358
#, no-wrap
msgid "fixnump object"
msgstr "fixnump object"

#. type: defun
#: original_texis/numbers.texi:362
msgid "This predicate tests whether its argument is a small integer, and returns @code{t} if so, @code{nil} otherwise.  Small integers can be compared with @code{eq}."
msgstr "この述語は引数が小さい整数かどうかをテストしてもしそうなら@code{t}、それ以外は@code{nil}をリターンする。小さい整数は@code{eq}で比較できる。"

#. type: defun
#: original_texis/numbers.texi:364
#, no-wrap
msgid "floatp object"
msgstr "floatp object"

#. type: defun
#: original_texis/numbers.texi:367
msgid "This predicate tests whether its argument is floating point and returns @code{t} if so, @code{nil} otherwise."
msgstr "この述語は引数が浮動小数かどうかをテストしてもしそうなら@code{t}、それ以外は@code{nil}をリターンする。"

#. type: defun
#: original_texis/numbers.texi:369
#, no-wrap
msgid "integerp object"
msgstr "integerp object"

#. type: defun
#: original_texis/numbers.texi:372
msgid "This predicate tests whether its argument is an integer, and returns @code{t} if so, @code{nil} otherwise."
msgstr "この述語は引数が整数かどうかをテストしてもしそうなら@code{t}、それ以外は@code{nil}をリターンする。"

#. type: defun
#: original_texis/numbers.texi:374
#, no-wrap
msgid "numberp object"
msgstr "numberp object"

#. type: defun
#: original_texis/numbers.texi:377
msgid "This predicate tests whether its argument is a number (either integer or floating point), and returns @code{t} if so, @code{nil} otherwise."
msgstr "この述語は引数が数(整数か浮動小数)かどうかをテストしてもしそうなら@code{t}、それ以外は@code{nil}をリターンする。"

#. type: defun
#: original_texis/numbers.texi:379
#, no-wrap
msgid "natnump object"
msgstr "natnump object"

#. type: cindex
#: original_texis/numbers.texi:380
#, no-wrap
msgid "natural numbers"
msgstr "natural numbers"

#. type: defun
#: original_texis/numbers.texi:385
msgid "This predicate (whose name comes from the phrase ``natural number'')  tests to see whether its argument is a nonnegative integer, and returns @code{t} if so, @code{nil} otherwise.  0 is considered non-negative."
msgstr "この述語は引数が正の整数かどうかをテストしてもしそうなら@code{t}、それ以外は@code{nil}をリターンする(名前は``natural numberl: 自然数''が由来)。0は整数と判断される。"

#. type: findex
#: original_texis/numbers.texi:386
#, no-wrap
msgid "wholenump"
msgstr "wholenump"

#. type: defun
#: original_texis/numbers.texi:388
msgid "@code{wholenump} is a synonym for @code{natnump}."
msgstr "@code{wholenump}は@code{natnump}のシノニム。"

#. type: defun
#: original_texis/numbers.texi:390
#, no-wrap
msgid "zerop number"
msgstr "zerop number"

#. type: defun
#: original_texis/numbers.texi:393
msgid "This predicate tests whether its argument is zero, and returns @code{t} if so, @code{nil} otherwise.  The argument must be a number."
msgstr "この述語は引数が0かどうかをテストしてもしそうなら@code{t}、それ以外は@code{nil}をリターンする。引数は数でなければならない。"

#. type: defun
#: original_texis/numbers.texi:395
msgid "@code{(zerop x)} is equivalent to @code{(= x 0)}."
msgstr "@code{(zerop x)}は@code{(= x 0)}と等価。"

#. type: cindex
#: original_texis/numbers.texi:399
#, no-wrap
msgid "number comparison"
msgstr "number comparison"

#. type: cindex
#: original_texis/numbers.texi:400
#, no-wrap
msgid "comparing numbers"
msgstr "comparing numbers"

#. type: Plain text
#: original_texis/numbers.texi:412
msgid "To test numbers for numerical equality, you should normally use @code{=} instead of non-numeric comparison predicates like @code{eq}, @code{eql} and @code{equal}.  Distinct floating-point and large integer objects can be numerically equal.  If you use @code{eq} to compare them, you test whether they are the same @emph{object}; if you use @code{eql} or @code{equal}, you test whether their values are @emph{indistinguishable}.  In contrast, @code{=} uses numeric comparison, and sometimes returns @code{t} when a non-numeric comparison would return @code{nil} and vice versa.  @xref{Float Basics}."
msgstr "数値にたいして数学的な等価性をテストするには通常は@code{eq}、@code{eql}、@code{equal}のような非数値的な比較述語のかわりに@code{=}を使用するべきです。異なる浮動小数点オブジェクトと大きい整数オブジェクトを数値的に等しくすることができます。これらの比較に@code{eq}を使用した場合にはそれらが同一の@emph{オブジェクト}かどうかを、@code{eql}や@code{equal}を使用した場合にはそれらの値が区別不能かどうかをテストすることになります。対照的に@code{=}は数値比較を使用して、非数値的な比較が@code{nil}をリターンするような場合に@code{t}をリターンしたり、その逆もあり得ます。@ref{Float Basics}を参照してください。"

#. type: Plain text
#: original_texis/numbers.texi:421
msgid "In Emacs Lisp, if two fixnums are numerically equal, they are the same Lisp object.  That is, @code{eq} is equivalent to @code{=} on fixnums.  It is sometimes convenient to use @code{eq} for comparing an unknown value with a fixnum, because @code{eq} does not report an error if the unknown value is not a number---it accepts arguments of any type.  By contrast, @code{=} signals an error if the arguments are not numbers or markers.  However, it is better programming practice to use @code{=} if you can, even for comparing integers."
msgstr "Emacs Lispでは2つのfixnumが数値的に等しければ同一のLispオブジェクトです。つまりfixnumでは@code{eq}は@code{=}と同じです。値が未知のfixnumの比較に@code{eq}を使用する方が便利な場合があります。なぜなら未知の値が数でない場合でも@code{eq}はエラーを報告しないからです。これは任意のタイプの引数を受け付けます。対照的に引数が数でもマーカーでもなければ@code{=}はエラーをシグナルします。しかし整数の比較においてさえ、使用できる場合には@code{=}を使用するのがよいプログラミング習慣です。"

#. type: Plain text
#: original_texis/numbers.texi:427
msgid "Sometimes it is useful to compare numbers with @code{eql} or @code{equal}, which treat two numbers as equal if they have the same data type (both integers, or both floating point) and the same value.  By contrast, @code{=} can treat an integer and a floating-point number as equal.  @xref{Equality Predicates}."
msgstr "数の比較において、2つの数が同じデータ型(どちらも整数か浮動小数)では、同じ値の場合は等しい数として扱う@code{eql}や@code{equal}のほうが便利なときもあります。対照的に@code{=}は整数と浮動小数点数を等しい数と扱うことができます。@ref{Equality Predicates}を参照してください。"

#. type: Plain text
#: original_texis/numbers.texi:432
msgid "There is another wrinkle: because floating-point arithmetic is not exact, it is often a bad idea to check for equality of floating-point values.  Usually it is better to test for approximate equality.  Here's a function to do this:"
msgstr "他の欠点もあります。浮動小数演算は正確ではないので、浮動小数値を比較するのが悪いアイデアとなるときがよくあります。通常は近似的に等しいことをテストするほうがよいでしょう。以下はこれを行なう関数です:"

#. type: example
#: original_texis/numbers.texi:440
#, no-wrap
msgid ""
"(defvar fuzz-factor 1.0e-6)\n"
"(defun approx-equal (x y)\n"
"  (or (= x y)\n"
"      (< (/ (abs (- x y))\n"
"            (max (abs x) (abs y)))\n"
"         fuzz-factor)))\n"
msgstr ""
"(defvar fuzz-factor 1.0e-6)\n"
"(defun approx-equal (x y)\n"
"  (or (= x y)\n"
"      (< (/ (abs (- x y))\n"
"            (max (abs x) (abs y)))\n"
"         fuzz-factor)))\n"

#. type: defun
#: original_texis/numbers.texi:442
#, no-wrap
msgid "= number-or-marker &rest number-or-markers"
msgstr "= number-or-marker &rest number-or-markers"

#. type: defun
#: original_texis/numbers.texi:445
msgid "This function tests whether all its arguments are numerically equal, and returns @code{t} if so, @code{nil} otherwise."
msgstr "この関数はすべての引数が数値的に等しいかどうかをテストしてもしそうなら@code{t}、それ以外は@code{nil}をリターンする。"

#. type: defun
#: original_texis/numbers.texi:447
#, no-wrap
msgid "eql value1 value2"
msgstr "eql value1 value2"

#. type: defun
#: original_texis/numbers.texi:453
msgid "This function acts like @code{eq} except when both arguments are numbers.  It compares numbers by type and numeric value, so that @code{(eql 1.0 1)} returns @code{nil}, but @code{(eql 1.0 1.0)} and @code{(eql 1 1)} both return @code{t}.  This can be used to compare large integers as well as small ones."
msgstr "この関数は@code{eq}と同様に振る舞うが引数が両方とも数のときを除く。これは数を型と数値的な値により比較するので@code{(eql 1.0 1)}は@code{nil}をリターンするが、@code{(eql 1.0 1.0)}と@code{(eql 1 1)}は@code{t}をリターンする。これは小さい整数と同様に大きい整数の比較に使用できる。"

#. type: defun
#: original_texis/numbers.texi:455
#, no-wrap
msgid "/= number-or-marker1 number-or-marker2"
msgstr "/= number-or-marker1 number-or-marker2"

#. type: defun
#: original_texis/numbers.texi:458
msgid "This function tests whether its arguments are numerically equal, and returns @code{t} if they are not, and @code{nil} if they are."
msgstr "この関数は引数が数値的に等しいかどうかをテストして、もし異なる場合は@code{t}、等しい場合は@code{nil}をリターンする。"

#. type: defun
#: original_texis/numbers.texi:460
#, no-wrap
msgid "<  number-or-marker &rest number-or-markers"
msgstr "<  number-or-marker &rest number-or-markers"

#. type: defun
#: original_texis/numbers.texi:463
msgid "This function tests whether each argument is strictly less than the following argument.  It returns @code{t} if so, @code{nil} otherwise."
msgstr "この関数は、各引数それぞれを後の引数より小さいかどうかをテストしてもしそうなら@code{t}、それ以外は@code{nil}をリターンする。"

#. type: defun
#: original_texis/numbers.texi:465
#, no-wrap
msgid "<= number-or-marker &rest number-or-markers"
msgstr "<= number-or-marker &rest number-or-markers"

#. type: defun
#: original_texis/numbers.texi:468
msgid "This function tests whether each argument is less than or equal to the following argument.  It returns @code{t} if so, @code{nil} otherwise."
msgstr "この関数は、各引数それぞれが後の引数以下かどうかをテストしてもしそうなら@code{t}、それ以外は@code{nil}をリターンする。"

#. type: defun
#: original_texis/numbers.texi:470
#, no-wrap
msgid "> number-or-marker &rest number-or-markers"
msgstr "> number-or-marker &rest number-or-markers"

#. type: defun
#: original_texis/numbers.texi:473
msgid "This function tests whether each argument is strictly greater than the following argument.  It returns @code{t} if so, @code{nil} otherwise."
msgstr "この関数は、各引数それぞれが後の引数より大きいかどうかをテストしてもしそうなら@code{t}、それ以外は@code{nil}をリターンする。"

#. type: defun
#: original_texis/numbers.texi:475
#, no-wrap
msgid ">= number-or-marker &rest number-or-markers"
msgstr ">= number-or-marker &rest number-or-markers"

#. type: defun
#: original_texis/numbers.texi:478
msgid "This function tests whether each argument is greater than or equal to the following argument.  It returns @code{t} if so, @code{nil} otherwise."
msgstr "この関数は、各引数それぞれが後の引数以上かどうかをテストしてもしそうなら@code{t}、それ以外は@code{nil}をリターンする。"

#. type: defun
#: original_texis/numbers.texi:480
#, no-wrap
msgid "max number-or-marker &rest numbers-or-markers"
msgstr "max number-or-marker &rest numbers-or-markers"

#. type: defun
#: original_texis/numbers.texi:482
msgid "This function returns the largest of its arguments."
msgstr "この関数は最大の引数をリターンする。"

#. type: example
#: original_texis/numbers.texi:490
#, no-wrap
msgid ""
"(max 20)\n"
"     @result{} 20\n"
"(max 1 2.5)\n"
"     @result{} 2.5\n"
"(max 1 3 2.5)\n"
"     @result{} 3\n"
msgstr ""
"(max 20)\n"
"     @result{} 20\n"
"(max 1 2.5)\n"
"     @result{} 2.5\n"
"(max 1 3 2.5)\n"
"     @result{} 3\n"

#. type: defun
#: original_texis/numbers.texi:493
#, no-wrap
msgid "min number-or-marker &rest numbers-or-markers"
msgstr "min number-or-marker &rest numbers-or-markers"

#. type: defun
#: original_texis/numbers.texi:495
msgid "This function returns the smallest of its arguments."
msgstr "この関数は最小の引数をリターンする。"

#. type: example
#: original_texis/numbers.texi:499
#, no-wrap
msgid ""
"(min -4 1)\n"
"     @result{} -4\n"
msgstr ""
"(min -4 1)\n"
"     @result{} -4\n"

#. type: defun
#: original_texis/numbers.texi:502
#, no-wrap
msgid "abs number"
msgstr "abs number"

#. type: defun
#: original_texis/numbers.texi:504
msgid "This function returns the absolute value of @var{number}."
msgstr "この関数は@var{number}の絶対値をリターンする。"

#. type: cindex
#: original_texis/numbers.texi:508
#, no-wrap
msgid "rounding in conversions"
msgstr "rounding in conversions"

#. type: cindex
#: original_texis/numbers.texi:509
#, no-wrap
msgid "number conversions"
msgstr "number conversions"

#. type: cindex
#: original_texis/numbers.texi:510
#, no-wrap
msgid "converting numbers"
msgstr "converting numbers"

#. type: Plain text
#: original_texis/numbers.texi:513
msgid "To convert an integer to floating point, use the function @code{float}."
msgstr "整数を浮動少数の変換には関数@code{float}を使用します。"

#. type: defun
#: original_texis/numbers.texi:514
#, no-wrap
msgid "float number"
msgstr "float number"

#. type: defun
#: original_texis/numbers.texi:518
msgid "This returns @var{number} converted to floating point.  If @var{number} is already floating point, @code{float} returns it unchanged."
msgstr "これは浮動小数点数に変換された@var{number}をリターンする。すでに@var{number}が浮動小数点数なら@code{float}はそれを変更せずにリターンする。"

#. type: Plain text
#: original_texis/numbers.texi:530
msgid "There are four functions to convert floating-point numbers to integers; they differ in how they round.  All accept an argument @var{number} and an optional argument @var{divisor}.  Both arguments may be integers or floating-point numbers.  @var{divisor} may also be @code{nil}.  If @var{divisor} is @code{nil} or omitted, these functions convert @var{number} to an integer, or return it unchanged if it already is an integer.  If @var{divisor} is non-@code{nil}, they divide @var{number} by @var{divisor} and convert the result to an integer.  If @var{divisor} is zero (whether integer or floating point), Emacs signals an @code{arith-error} error."
msgstr "浮動小数点数を整数に変換する関数が4つあります。これらは浮動小数点数を丸める方法が異なります。これらはすべて引数@var{number}、およびオプション引数として@var{divisor}を受け取ります。引数は両方とも整数か浮動小数点数です。@var{divisor}が@code{nil}のこともあります。@var{divisor}が@code{nil}または省略された場合、これらの関数は@var{number}を整数に変換するか、それが既に整数の場合は変更せずにリターンします。@var{divisor}が非@code{nil}なら、これらの関数は@var{number}を@var{divisor}で除して結果を整数に変換します。@var{divisor}が(整数か浮動小数かに関わらず)0の場合、Emacsは@code{arith-error}エラーをシグナルします。"

#. type: defun
#: original_texis/numbers.texi:531
#, no-wrap
msgid "truncate number &optional divisor"
msgstr "truncate number &optional divisor"

#. type: defun
#: original_texis/numbers.texi:534
msgid "This returns @var{number}, converted to an integer by rounding towards zero."
msgstr "これは0に向かって丸めることにより整数に変換した@var{number}をリターンする。"

#. type: example
#: original_texis/numbers.texi:544
#, no-wrap
msgid ""
"(truncate 1.2)\n"
"     @result{} 1\n"
"(truncate 1.7)\n"
"     @result{} 1\n"
"(truncate -1.2)\n"
"     @result{} -1\n"
"(truncate -1.7)\n"
"     @result{} -1\n"
msgstr ""
"(truncate 1.2)\n"
"     @result{} 1\n"
"(truncate 1.7)\n"
"     @result{} 1\n"
"(truncate -1.2)\n"
"     @result{} -1\n"
"(truncate -1.7)\n"
"     @result{} -1\n"

#. type: defun
#: original_texis/numbers.texi:547
#, no-wrap
msgid "floor number &optional divisor"
msgstr "floor number &optional divisor"

#. type: defun
#: original_texis/numbers.texi:550
msgid "This returns @var{number}, converted to an integer by rounding downward (towards negative infinity)."
msgstr "これは下方(負の無限大に向かって)に丸めることにより整数に変換した@var{number}をリターンする。"

#. type: defun
#: original_texis/numbers.texi:553
msgid "If @var{divisor} is specified, this uses the kind of division operation that corresponds to @code{mod}, rounding downward."
msgstr "@var{divisor}が指定された場合には、@code{mod}に相当する種類の除算演算を使用して下方に丸めを行う。"

#. type: example
#: original_texis/numbers.texi:565
#, no-wrap
msgid ""
"(floor 1.2)\n"
"     @result{} 1\n"
"(floor 1.7)\n"
"     @result{} 1\n"
"(floor -1.2)\n"
"     @result{} -2\n"
"(floor -1.7)\n"
"     @result{} -2\n"
"(floor 5.99 3)\n"
"     @result{} 1\n"
msgstr ""
"(floor 1.2)\n"
"     @result{} 1\n"
"(floor 1.7)\n"
"     @result{} 1\n"
"(floor -1.2)\n"
"     @result{} -2\n"
"(floor -1.7)\n"
"     @result{} -2\n"
"(floor 5.99 3)\n"
"     @result{} 1\n"

#. type: defun
#: original_texis/numbers.texi:568
#, no-wrap
msgid "ceiling number &optional divisor"
msgstr "ceiling number &optional divisor"

#. type: defun
#: original_texis/numbers.texi:571
msgid "This returns @var{number}, converted to an integer by rounding upward (towards positive infinity)."
msgstr "これは上方(正の無限大に向かって)に丸めることにより整数に変換した@var{number}をリターンする。"

#. type: example
#: original_texis/numbers.texi:581
#, no-wrap
msgid ""
"(ceiling 1.2)\n"
"     @result{} 2\n"
"(ceiling 1.7)\n"
"     @result{} 2\n"
"(ceiling -1.2)\n"
"     @result{} -1\n"
"(ceiling -1.7)\n"
"     @result{} -1\n"
msgstr ""
"(ceiling 1.2)\n"
"     @result{} 2\n"
"(ceiling 1.7)\n"
"     @result{} 2\n"
"(ceiling -1.2)\n"
"     @result{} -1\n"
"(ceiling -1.7)\n"
"     @result{} -1\n"

#. type: defun
#: original_texis/numbers.texi:584
#, no-wrap
msgid "round number &optional divisor"
msgstr "round number &optional divisor"

#. type: defun
#: original_texis/numbers.texi:588
msgid "This returns @var{number}, converted to an integer by rounding towards the nearest integer.  Rounding a value equidistant between two integers returns the even integer."
msgstr "これはもっとも近い整数に向かって丸めることにより、整数に変換した@var{number}をリターンする。2つの整数から等距離にある値の丸めでは、偶数の整数をリターンする。"

#. type: example
#: original_texis/numbers.texi:598
#, no-wrap
msgid ""
"(round 1.2)\n"
"     @result{} 1\n"
"(round 1.7)\n"
"     @result{} 2\n"
"(round -1.2)\n"
"     @result{} -1\n"
"(round -1.7)\n"
"     @result{} -2\n"
msgstr ""
"(round 1.2)\n"
"     @result{} 1\n"
"(round 1.7)\n"
"     @result{} 2\n"
"(round -1.2)\n"
"     @result{} -1\n"
"(round -1.7)\n"
"     @result{} -2\n"

#. type: cindex
#: original_texis/numbers.texi:603
#, no-wrap
msgid "arithmetic operations"
msgstr "arithmetic operations"

#. type: Plain text
#: original_texis/numbers.texi:611
msgid "Emacs Lisp provides the traditional four arithmetic operations (addition, subtraction, multiplication, and division), as well as remainder and modulus functions, and functions to add or subtract 1.  Except for @code{%}, each of these functions accepts both integer and floating-point arguments, and returns a floating-point number if any argument is floating point."
msgstr "Emacs Lispは伝統的な4つの算術演算(加減乗除)、同様に剰余とmodulusの関数、および1の加算と減算を行う関数を提供します。@code{%}を除き、これらの各関数は引き数として整数か浮動小数を受け取り、浮動小数の引数がある場合は浮動小数点数をリターンします。"

#. type: defun
#: original_texis/numbers.texi:612
#, no-wrap
msgid "1+ number-or-marker"
msgstr "1+ number-or-marker"

#. type: defun
#: original_texis/numbers.texi:615
msgid "This function returns @var{number-or-marker} plus 1.  For example,"
msgstr "この関数は@var{number-or-marker} + 1をリターンする。例えば、"

#. type: example
#: original_texis/numbers.texi:621
#, no-wrap
msgid ""
"(setq foo 4)\n"
"     @result{} 4\n"
"(1+ foo)\n"
"     @result{} 5\n"
msgstr ""
"(setq foo 4)\n"
"     @result{} 4\n"
"(1+ foo)\n"
"     @result{} 5\n"

#. type: defun
#: original_texis/numbers.texi:625
msgid "This function is not analogous to the C operator @code{++}---it does not increment a variable.  It just computes a sum.  Thus, if we continue,"
msgstr "この関数はCの演算子@code{++}とは異なり、変数をインクリメントしない。この関数は和を計算するだけである。したがって以下を続けて評価すると、"

#. type: example
#: original_texis/numbers.texi:629
#, no-wrap
msgid ""
"foo\n"
"     @result{} 4\n"
msgstr ""
"foo\n"
"     @result{} 4\n"

#. type: defun
#: original_texis/numbers.texi:633
msgid "If you want to increment the variable, you must use @code{setq}, like this:"
msgstr "変数をインクリメントしたい場合は、以下のように@code{setq}を使用しなければならない:"

#. type: example
#: original_texis/numbers.texi:637
#, no-wrap
msgid ""
"(setq foo (1+ foo))\n"
"     @result{} 5\n"
msgstr ""
"(setq foo (1+ foo))\n"
"     @result{} 5\n"

#. type: defun
#: original_texis/numbers.texi:640
#, no-wrap
msgid "1- number-or-marker"
msgstr "1- number-or-marker"

#. type: defun
#: original_texis/numbers.texi:642
msgid "This function returns @var{number-or-marker} minus 1."
msgstr "この関数は@var{number-or-marker} @minus{} 1をリターンする。"

#. type: defun
#: original_texis/numbers.texi:644
#, no-wrap
msgid "+ &rest numbers-or-markers"
msgstr "+ &rest numbers-or-markers"

#. type: defun
#: original_texis/numbers.texi:647
msgid "This function adds its arguments together.  When given no arguments, @code{+} returns 0."
msgstr "この関数は引数すべてを加算する。引数を与えないと@code{+}は0をリターンする。"

#. type: example
#: original_texis/numbers.texi:655
#, no-wrap
msgid ""
"(+)\n"
"     @result{} 0\n"
"(+ 1)\n"
"     @result{} 1\n"
"(+ 1 2 3 4)\n"
"     @result{} 10\n"
msgstr ""
"(+)\n"
"     @result{} 0\n"
"(+ 1)\n"
"     @result{} 1\n"
"(+ 1 2 3 4)\n"
"     @result{} 10\n"

#. type: defun
#: original_texis/numbers.texi:658
#, no-wrap
msgid "- &optional number-or-marker &rest more-numbers-or-markers"
msgstr "- &optional number-or-marker &rest more-numbers-or-markers"

#. type: defun
#: original_texis/numbers.texi:664
msgid "The @code{-} function serves two purposes: negation and subtraction.  When @code{-} has a single argument, the value is the negative of the argument.  When there are multiple arguments, @code{-} subtracts each of the @var{more-numbers-or-markers} from @var{number-or-marker}, cumulatively.  If there are no arguments, the result is 0."
msgstr "@code{-}関数は2つの目的 --- 符号反転と減算 --- をもつ。@code{-}に1つの引数を与えると、値は引数の符号を反転したものになる。複数の引数の場合は、@var{number-or-marker}から@var{more-numbers-or-markers}までの各値を蓄積的に減算する。引数がなければ結果は0。"

#. type: example
#: original_texis/numbers.texi:672
#, no-wrap
msgid ""
"(- 10 1 2 3 4)\n"
"     @result{} 0\n"
"(- 10)\n"
"     @result{} -10\n"
"(-)\n"
"     @result{} 0\n"
msgstr ""
"(- 10 1 2 3 4)\n"
"     @result{} 0\n"
"(- 10)\n"
"     @result{} -10\n"
"(-)\n"
"     @result{} 0\n"

#. type: defun
#: original_texis/numbers.texi:675
#, no-wrap
msgid "* &rest numbers-or-markers"
msgstr "* &rest numbers-or-markers"

#. type: defun
#: original_texis/numbers.texi:678
msgid "This function multiplies its arguments together, and returns the product.  When given no arguments, @code{*} returns 1."
msgstr "この関数はすべての引数を乗じて積をリターンする。引数がなかれば@code{*}は1をリターンする。"

#. type: example
#: original_texis/numbers.texi:686
#, no-wrap
msgid ""
"(*)\n"
"     @result{} 1\n"
"(* 1)\n"
"     @result{} 1\n"
"(* 1 2 3 4)\n"
"     @result{} 24\n"
msgstr ""
"(*)\n"
"     @result{} 1\n"
"(* 1)\n"
"     @result{} 1\n"
"(* 1 2 3 4)\n"
"     @result{} 24\n"

#. type: defun
#: original_texis/numbers.texi:689
#, no-wrap
msgid "/ number &rest divisors"
msgstr "/ number &rest divisors"

#. type: defun
#: original_texis/numbers.texi:695
msgid "With one or more @var{divisors}, this function divides @var{number} by each divisor in @var{divisors} in turn, and returns the quotient.  With no @var{divisors}, this function returns 1/@var{number}, i.e., the multiplicative inverse of @var{number}.  Each argument may be a number or a marker."
msgstr "@var{divisors}が1つ以上ならこの関数は@var{divisors}内の除数で順に@var{number}を除して、その商をリターンする。@var{divisors}がなければ、この関数は1/@var{number}、つまり@var{number}の逆数をリターンする。各引数には数かマーカーを指定できる。"

#. type: defun
#: original_texis/numbers.texi:698
msgid "If all the arguments are integers, the result is an integer, obtained by rounding the quotient towards zero after each division."
msgstr "すべての引数が整数なら、結果は各除算の後に商を0へ向かって丸めることにより得られる整数となる。"

#. type: group
#: original_texis/numbers.texi:703
#, no-wrap
msgid ""
"(/ 6 2)\n"
"     @result{} 3\n"
msgstr ""
"(/ 6 2)\n"
"     @result{} 3\n"

#. type: group
#: original_texis/numbers.texi:707
#, no-wrap
msgid ""
"(/ 5 2)\n"
"     @result{} 2\n"
msgstr ""
"(/ 5 2)\n"
"     @result{} 2\n"

#. type: group
#: original_texis/numbers.texi:711
#, no-wrap
msgid ""
"(/ 5.0 2)\n"
"     @result{} 2.5\n"
msgstr ""
"(/ 5.0 2)\n"
"     @result{} 2.5\n"

#. type: group
#: original_texis/numbers.texi:715
#, no-wrap
msgid ""
"(/ 5 2.0)\n"
"     @result{} 2.5\n"
msgstr ""
"(/ 5 2.0)\n"
"     @result{} 2.5\n"

#. type: group
#: original_texis/numbers.texi:719
#, no-wrap
msgid ""
"(/ 5.0 2.0)\n"
"     @result{} 2.5\n"
msgstr ""
"(/ 5.0 2.0)\n"
"     @result{} 2.5\n"

#. type: group
#: original_texis/numbers.texi:723
#, no-wrap
msgid ""
"(/ 4.0)\n"
"     @result{} 0.25\n"
msgstr ""
"(/ 4.0)\n"
"     @result{} 0.25\n"

#. type: group
#: original_texis/numbers.texi:727
#, no-wrap
msgid ""
"(/ 4)\n"
"     @result{} 0\n"
msgstr ""
"(/ 4)\n"
"     @result{} 0\n"

#. type: group
#: original_texis/numbers.texi:731
#, no-wrap
msgid ""
"(/ 25 3 2)\n"
"     @result{} 4\n"
msgstr ""
"(/ 25 3 2)\n"
"     @result{} 4\n"

#. type: group
#: original_texis/numbers.texi:735
#, no-wrap
msgid ""
"(/ -17 6)\n"
"     @result{} -2\n"
msgstr ""
"(/ -17 6)\n"
"     @result{} -2\n"

#. type: cindex
#: original_texis/numbers.texi:738
#, no-wrap
msgid "@code{arith-error} in division"
msgstr "@code{arith-error} in division"

#. type: defun
#: original_texis/numbers.texi:743
msgid "If you divide an integer by the integer 0, Emacs signals an @code{arith-error} error (@pxref{Errors}).  Floating-point division of a nonzero number by zero yields either positive or negative infinity (@pxref{Float Basics})."
msgstr "整数を整数0で除するとEmacsは@code{arith-error}エラー(@ref{Errors}を参照)をシグナルする。浮動小数点数の除算では、非0の数を0で除することで正の無限大または負の無限大を得る(@ref{Float Basics}を参照)。"

#. type: defun
#: original_texis/numbers.texi:745
#, no-wrap
msgid "% dividend divisor"
msgstr "% dividend divisor"

#. type: cindex
#: original_texis/numbers.texi:746
#, no-wrap
msgid "remainder"
msgstr "remainder"

#. type: defun
#: original_texis/numbers.texi:749
msgid "This function returns the integer remainder after division of @var{dividend} by @var{divisor}.  The arguments must be integers or markers."
msgstr "この関数は@var{dividend}を@var{divisor}で除した後、その剰余を整数でリターンする。引数は整数かマーカーでなければならない。"

#. type: defun
#: original_texis/numbers.texi:751
msgid "For any two integers @var{dividend} and @var{divisor},"
msgstr "任意の2つの整数@var{dividend}と@var{divisor}にたいして、"

#. type: group
#: original_texis/numbers.texi:756
#, no-wrap
msgid ""
"(+ (% @var{dividend} @var{divisor})\n"
"   (* (/ @var{dividend} @var{divisor}) @var{divisor}))\n"
msgstr ""
"(+ (% @var{dividend} @var{divisor})\n"
"   (* (/ @var{dividend} @var{divisor}) @var{divisor}))\n"

#. type: defun
#: original_texis/numbers.texi:761
msgid "always equals @var{dividend} if @var{divisor} is nonzero."
msgstr "は、@var{divisor}が非0なら常に@var{dividend}と等しくなる。"

#. type: example
#: original_texis/numbers.texi:771
#, no-wrap
msgid ""
"(% 9 4)\n"
"     @result{} 1\n"
"(% -9 4)\n"
"     @result{} -1\n"
"(% 9 -4)\n"
"     @result{} 1\n"
"(% -9 -4)\n"
"     @result{} -1\n"
msgstr ""
"(% 9 4)\n"
"     @result{} 1\n"
"(% -9 4)\n"
"     @result{} -1\n"
"(% 9 -4)\n"
"     @result{} 1\n"
"(% -9 -4)\n"
"     @result{} -1\n"

#. type: defun
#: original_texis/numbers.texi:774
#, no-wrap
msgid "mod dividend divisor"
msgstr "mod dividend divisor"

#. type: cindex
#: original_texis/numbers.texi:775
#, no-wrap
msgid "modulus"
msgstr "modulus"

#. type: defun
#: original_texis/numbers.texi:780
msgid "This function returns the value of @var{dividend} modulo @var{divisor}; in other words, the remainder after division of @var{dividend} by @var{divisor}, but with the same sign as @var{divisor}.  The arguments must be numbers or markers."
msgstr "この関数は@var{dividend}の@var{divisor}にたいするmodulo、言い換えると@var{dividend}を@var{divisor}で除した後の剰余(ただし符号は@var{divisor}と同じ)をリターンする。引数は数かマーカーでなければならない。"

#. type: defun
#: original_texis/numbers.texi:784
msgid "Unlike @code{%}, @code{mod} permits floating-point arguments; it rounds the quotient downward (towards minus infinity) to an integer, and uses that quotient to compute the remainder."
msgstr "@code{%}とは異なり@code{mod}は浮動小数の引数を許す。これは商を整数に下方(負の無限大に向かって)へ丸めて剰余を計算するのにこの商を使用する。"

#. type: defun
#: original_texis/numbers.texi:787
msgid "If @var{divisor} is zero, @code{mod} signals an @code{arith-error} error if both arguments are integers, and returns a NaN otherwise."
msgstr "@code{mod}は@var{divisor}が0のとき、両方の引数が整数なら@code{arith-error}エラーをシグナルし、それ以外はNaNをリターンする。"

#. type: group
#: original_texis/numbers.texi:792
#, no-wrap
msgid ""
"(mod 9 4)\n"
"     @result{} 1\n"
msgstr ""
"(mod 9 4)\n"
"     @result{} 1\n"

#. type: group
#: original_texis/numbers.texi:796
#, no-wrap
msgid ""
"(mod -9 4)\n"
"     @result{} 3\n"
msgstr ""
"(mod -9 4)\n"
"     @result{} 3\n"

#. type: group
#: original_texis/numbers.texi:800
#, no-wrap
msgid ""
"(mod 9 -4)\n"
"     @result{} -3\n"
msgstr ""
"(mod 9 -4)\n"
"     @result{} -3\n"

#. type: group
#: original_texis/numbers.texi:804
#, no-wrap
msgid ""
"(mod -9 -4)\n"
"     @result{} -1\n"
msgstr ""
"(mod -9 -4)\n"
"     @result{} -1\n"

#. type: group
#: original_texis/numbers.texi:808
#, no-wrap
msgid ""
"(mod 5.5 2.5)\n"
"     @result{} .5\n"
msgstr ""
"(mod 5.5 2.5)\n"
"     @result{} .5\n"

#. type: defun
#: original_texis/numbers.texi:812
msgid "For any two numbers @var{dividend} and @var{divisor},"
msgstr "任意の2つの数@var{dividend}と@var{divisor}にたいして、"

#. type: group
#: original_texis/numbers.texi:817
#, no-wrap
msgid ""
"(+ (mod @var{dividend} @var{divisor})\n"
"   (* (floor @var{dividend} @var{divisor}) @var{divisor}))\n"
msgstr ""
"(+ (mod @var{dividend} @var{divisor})\n"
"   (* (floor @var{dividend} @var{divisor}) @var{divisor}))\n"

#. type: defun
#: original_texis/numbers.texi:825
msgid "always equals @var{dividend}, subject to rounding error if either argument is floating point and to an @code{arith-error} if @var{dividend} is an integer and @var{divisor} is 0.  For @code{floor}, see @ref{Numeric Conversions}."
msgstr "は常に@var{dividend}になる(ただし引数のどちらかが浮動小数なら、丸め誤差の範囲内で等しく、かつ@var{dividend}が整数で@var{divisor}が0なら@code{arith-error}となる)。@code{floor}については、@ref{Numeric Conversions}を参照のこと。"

#. type: cindex
#: original_texis/numbers.texi:829
#, no-wrap
msgid "rounding without conversion"
msgstr "rounding without conversion"

#. type: Plain text
#: original_texis/numbers.texi:837
msgid "The functions @code{ffloor}, @code{fceiling}, @code{fround}, and @code{ftruncate} take a floating-point argument and return a floating-point result whose value is a nearby integer.  @code{ffloor} returns the nearest integer below; @code{fceiling}, the nearest integer above; @code{ftruncate}, the nearest integer in the direction towards zero; @code{fround}, the nearest integer."
msgstr "関数@code{ffloor}、@code{fceiling}、@code{fround}、@code{ftruncate}は浮動小数の引数をとり、値が近くの整数であるような浮動少数をリターンします。@code{ffloor}は一番近い下方の整数、@code{fceiling}は一番近い上方の整数、@code{ftruncate}は0に向かう方向で一番近い整数、@code{fround}は一番近い整数をリターンします。"

#. type: defun
#: original_texis/numbers.texi:838
#, no-wrap
msgid "ffloor float"
msgstr "ffloor float"

#. type: defun
#: original_texis/numbers.texi:841
msgid "This function rounds @var{float} to the next lower integral value, and returns that value as a floating-point number."
msgstr "この関数は@var{float}を次に小さい整数値に丸めて、その値を浮動小数点数としてリターンする。"

#. type: defun
#: original_texis/numbers.texi:843
#, no-wrap
msgid "fceiling float"
msgstr "fceiling float"

#. type: defun
#: original_texis/numbers.texi:846
msgid "This function rounds @var{float} to the next higher integral value, and returns that value as a floating-point number."
msgstr "この関数は@var{float}を次に大きい整数値に丸めて、その値を浮動小数点数としてリターンする。"

#. type: defun
#: original_texis/numbers.texi:848
#, no-wrap
msgid "ftruncate float"
msgstr "ftruncate float"

#. type: defun
#: original_texis/numbers.texi:851
msgid "This function rounds @var{float} towards zero to an integral value, and returns that value as a floating-point number."
msgstr "この関数は@var{float}を0方向の整数値に丸めて、その値を浮動小数点数としてリターンする。"

#. type: defun
#: original_texis/numbers.texi:853
#, no-wrap
msgid "fround float"
msgstr "fround float"

#. type: defun
#: original_texis/numbers.texi:857
msgid "This function rounds @var{float} to the nearest integral value, and returns that value as a floating-point number.  Rounding a value equidistant between two integers returns the even integer."
msgstr "この関数は@var{float}を一番近い整数値に丸めて、その値を浮動小数点数としてリターンする。2つの整数値との距離が等しい値にたいする丸めでは、偶数の整数をリターンする。"

#. type: section
#: original_texis/numbers.texi:860
#, no-wrap
msgid "Bitwise Operations on Integers"
msgstr "Bitwise Operations on Integers"

#. type: cindex
#: original_texis/numbers.texi:861
#, no-wrap
msgid "bitwise arithmetic"
msgstr "bitwise arithmetic"

#. type: cindex
#: original_texis/numbers.texi:862
#, no-wrap
msgid "logical arithmetic"
msgstr "logical arithmetic"

#. type: Plain text
#: original_texis/numbers.texi:871
msgid "In a computer, an integer is represented as a binary number, a sequence of @dfn{bits} (digits which are either zero or one).  Conceptually the bit sequence is infinite on the left, with the most-significant bits being all zeros or all ones.  A bitwise operation acts on the individual bits of such a sequence.  For example, @dfn{shifting} moves the whole sequence left or right one or more places, reproducing the same pattern moved over."
msgstr "コンピューターの中では、整数は@dfn{ビット(bit: 0か1の数字)}のシーケンスである2進数で表されます。ビットシーケンスは概念的には最上位ビットがすべて0か1であるような左側に無限なシ0ケンスです。ビット演算はそのようなシーケンスの中の個々のビットに作用します。たとえば@dfn{シフト(shifting)}はシーケンス全体を1つ以上左または右に移動して、移動されたのと同じパターンを再現します。"

#. type: Plain text
#: original_texis/numbers.texi:873
msgid "The bitwise operations in Emacs Lisp apply only to integers."
msgstr "Emacs Lispのビット演算は整数だけに適用されます。"

#. type: defun
#: original_texis/numbers.texi:874
#, no-wrap
msgid "ash integer1 count"
msgstr "ash integer1 count"

#. type: cindex
#: original_texis/numbers.texi:875
#, no-wrap
msgid "arithmetic shift"
msgstr "arithmetic shift"

#. type: defun
#: original_texis/numbers.texi:881
msgid "@code{ash} (@dfn{arithmetic shift}) shifts the bits in @var{integer1} to the left @var{count} places, or to the right if @var{count} is negative.  Left shifts introduce zero bits on the right; right shifts discard the rightmost bits.  Considered as an integer operation, @code{ash} multiplies @var{integer1} by"
msgstr "@code{ash} (@dfn{算術シフト(arithmetic shift)})は、@var{integer1}の中のビット位置を左に@var{count}シフトする。@var{count}が負なら右にシフトする。左シフトでは右側に0が挿入されて、右シフトでは最右ビットが破棄される。整数処理として考えると、@code{ash}は@var{integer1}を"

#. type: ifnottex
#: original_texis/numbers.texi:883
msgid "2**@var{count},"
msgstr "2**@var{count}"

#. type: tex
#: original_texis/numbers.texi:886
#, no-wrap
msgid "@math{2^{count}},\n"
msgstr "@math{2^{count}}\n"

#. type: defun
#: original_texis/numbers.texi:889
msgid "and then converts the result to an integer by rounding downward, toward minus infinity."
msgstr "乗じてから下方、負の無限大に向かって丸めることにより結果を変換する。"

#. type: defun
#: original_texis/numbers.texi:896
msgid "Here are examples of @code{ash}, shifting a pattern of bits one place to the left and to the right.  These examples show only the low-order bits of the binary pattern; leading bits all agree with the highest-order bit shown.  As you can see, shifting left by one is equivalent to multiplying by two, whereas shifting right by one is equivalent to dividing by two and then rounding toward minus infinity."
msgstr "以下はビットパターンを1ビット左にシフトしてから右にシフトする例。この例で2進数パターンの下位ビットだけを示している。先行ビットは表示されている上位ビットにすべて一致する。確認できるように1ビットの左シフトは2を乗じて、右シフトは2で除してから負の無限大方向に丸められる。"

#. type: group
#: original_texis/numbers.texi:904
#, no-wrap
msgid ""
"(ash 7 1) @result{} 14\n"
";; @r{Decimal 7 becomes decimal 14.}\n"
"@dots{}000111\n"
"     @result{}\n"
"@dots{}001110\n"
msgstr ""
"(ash 7 1) @result{} 14\n"
";; @r{10進の7は10進の14になる}\n"
"@dots{}000111\n"
"     @result{}\n"
"@dots{}001110\n"

#. type: group
#: original_texis/numbers.texi:911
#, no-wrap
msgid ""
"(ash 7 -1) @result{} 3\n"
"@dots{}000111\n"
"     @result{}\n"
"@dots{}000011\n"
msgstr ""
"(ash 7 -1) @result{} 3\n"
"@dots{}000111\n"
"     @result{}\n"
"@dots{}000011\n"

#. type: group
#: original_texis/numbers.texi:918
#, no-wrap
msgid ""
"(ash -7 1) @result{} -14\n"
"@dots{}111001\n"
"     @result{}\n"
"@dots{}110010\n"
msgstr ""
"(ash -7 1) @result{} -14\n"
"@dots{}111001\n"
"     @result{}\n"
"@dots{}110010\n"

#. type: group
#: original_texis/numbers.texi:925
#, no-wrap
msgid ""
"(ash -7 -1) @result{} -4\n"
"@dots{}111001\n"
"     @result{}\n"
"@dots{}111100\n"
msgstr ""
"(ash -7 -1) @result{} -4\n"
"@dots{}111001\n"
"     @result{}\n"
"@dots{}111100\n"

#. type: defun
#: original_texis/numbers.texi:929
msgid "Here are examples of shifting left or right by two bits:"
msgstr "以下は2ビット左にシフトしてから右に2ビットシフトする例:"

#. type: group
#: original_texis/numbers.texi:937
#, no-wrap
msgid ""
"                  ;  @r{       binary values}\n"
"(ash 5 2)         ;   5  =  @r{@dots{}000101}\n"
"     @result{} 20         ;      =  @r{@dots{}010100}\n"
"(ash -5 2)        ;  -5  =  @r{@dots{}111011}\n"
"     @result{} -20        ;      =  @r{@dots{}101100}\n"
msgstr ""
"                  ;  @r{       2進数値}\n"
"(ash 5 2)         ;   5  =  @r{@dots{}000101}\n"
"     @result{} 20         ;      =  @r{@dots{}010100}\n"
"(ash -5 2)        ;  -5  =  @r{@dots{}111011}\n"
"     @result{} -20        ;      =  @r{@dots{}101100}\n"

#. type: group
#: original_texis/numbers.texi:941
#, no-wrap
msgid ""
"(ash 5 -2)\n"
"     @result{} 1          ;      =  @r{@dots{}000001}\n"
msgstr ""
"(ash 5 -2)\n"
"     @result{} 1          ;      =  @r{@dots{}000001}\n"

#. type: group
#: original_texis/numbers.texi:945
#, no-wrap
msgid ""
"(ash -5 -2)\n"
"     @result{} -2         ;      =  @r{@dots{}111110}\n"
msgstr ""
"(ash -5 -2)\n"
"     @result{} -2         ;      =  @r{@dots{}111110}\n"

#. type: defun
#: original_texis/numbers.texi:949
#, no-wrap
msgid "lsh integer1 count"
msgstr "lsh integer1 count"

#. type: cindex
#: original_texis/numbers.texi:950
#, no-wrap
msgid "logical shift"
msgstr "logical shift"

#. type: defun
#: original_texis/numbers.texi:960
msgid "@code{lsh}, which is an abbreviation for @dfn{logical shift}, shifts the bits in @var{integer1} to the left @var{count} places, or to the right if @var{count} is negative, bringing zeros into the vacated bits.  If @var{count} is negative, then @var{integer1} must be either a fixnum or a positive bignum, and @code{lsh} treats a negative fixnum as if it were unsigned by subtracting twice @code{most-negative-fixnum} before shifting, producing a nonnegative result.  This quirky behavior dates back to when Emacs supported only fixnums; nowadays @code{ash} is a better choice."
msgstr "@code{lsh}は@dfn{logical shift}の略で、@var{integer1}のビットを左に@var{count}シフトする。@var{count}が負なら@var{integer1}はfixnumか正のbignumのいずれかでなければならず、@code{lsh}はシフト前に負のfixnumを@code{most-negative-fixnum}で2回減算してあたかも符号なしであるかのように非負の結果を生成する。この奇妙な振る舞いはEmacsがfixnumsだけをサポートしていた頃の振る舞いであり、現在では@code{ash}がより良い選択である。"

#. type: defun
#: original_texis/numbers.texi:964
msgid "As @code{lsh} behaves like @code{ash} except when @var{integer1} and @var{count1} are both negative, the following examples focus on these exceptional cases.  These examples assume 30-bit fixnums."
msgstr "@var{integer1}と@var{count1}がいずれも負の場合を除いて@code{lsh}は@code{ash}のように振る舞うので、以下の例ではこれらの例外ケースに焦点をあてている。これらの例は30ビットのfixnumsを想定している。"

#. type: group
#: original_texis/numbers.texi:972
#, no-wrap
msgid ""
"                 ; @r{     binary values}\n"
"(ash -7 -1)      ; -7 = @r{@dots{}111111111111111111111111111001}\n"
"     @result{} -4        ;    = @r{@dots{}111111111111111111111111111100}\n"
"(lsh -7 -1)\n"
"     @result{} 536870908 ;    = @r{@dots{}011111111111111111111111111100}\n"
msgstr ""
"                 ; @r{     2進数値}\n"
"(ash -7 -1)      ; -7 = @r{@dots{}111111111111111111111111111001}\n"
"     @result{} -4        ;    = @r{@dots{}111111111111111111111111111100}\n"
"(lsh -7 -1)\n"
"     @result{} 536870908 ;    = @r{@dots{}011111111111111111111111111100}\n"

#. type: group
#: original_texis/numbers.texi:978
#, no-wrap
msgid ""
"(ash -5 -2)      ; -5 = @r{@dots{}111111111111111111111111111011}\n"
"     @result{} -2        ;    = @r{@dots{}111111111111111111111111111110}\n"
"(lsh -5 -2)\n"
"     @result{} 268435454 ;    = @r{@dots{}001111111111111111111111111110}\n"
msgstr ""
"(ash -5 -2)      ; -5 = @r{@dots{}111111111111111111111111111011}\n"
"     @result{} -2        ;    = @r{@dots{}111111111111111111111111111110}\n"
"(lsh -5 -2)\n"
"     @result{} 268435454 ;    = @r{@dots{}001111111111111111111111111110}\n"

#. type: defun
#: original_texis/numbers.texi:982
#, no-wrap
msgid "logand &rest ints-or-markers"
msgstr "logand &rest ints-or-markers"

#. type: defun
#: original_texis/numbers.texi:986
msgid "This function returns the bitwise AND of the arguments: the @var{n}th bit is 1 in the result if, and only if, the @var{n}th bit is 1 in all the arguments."
msgstr "この関数は引数のビットのANDをリターンする。すべての引数の@var{n}番目のビットが1の場合に限り、結果の@var{n}番目のビットが1となる。"

#. type: defun
#: original_texis/numbers.texi:993
msgid "For example, using 4-bit binary numbers, the bitwise AND of 13 and 12 is 12: 1101 combined with 1100 produces 1100.  In both the binary numbers, the leftmost two bits are both 1 so the leftmost two bits of the returned value are both 1.  However, for the rightmost two bits, each is 0 in at least one of the arguments, so the rightmost two bits of the returned value are both 0."
msgstr "たとえば13と12では、4ビット2進数を使用すると1101と1100のビットANDは1100を生成する。この2進数ではいずれも左の2ビットがセット(つまり1)されているので、リターンされる値の左2ビットがセットされる。しかし右の2ビットにたいしては少なくとも1つの引数でそのビットが0なので、リターンされる値の右2ビットは0になる。"

#. type: defun
#: original_texis/numbers.texi:996
msgid "Therefore,"
msgstr "したがって、"

#. type: group
#: original_texis/numbers.texi:1001
#, no-wrap
msgid ""
"(logand 13 12)\n"
"     @result{} 12\n"
msgstr ""
"(logand 13 12)\n"
"     @result{} 12\n"

#. type: defun
#: original_texis/numbers.texi:1008
msgid "If @code{logand} is not passed any argument, it returns a value of @minus{}1.  This number is an identity element for @code{logand} because its binary representation consists entirely of ones.  If @code{logand} is passed just one argument, it returns that argument."
msgstr "@code{logand}に何も引数も渡さなければ、値@minus{}1がリターンされる。@minus{}1を2進数で表すとすべてのビットが1なので、@minus{}1は@code{logand}にたいする単位元(identity element)である。"

#. type: group
#: original_texis/numbers.texi:1012 original_texis/numbers.texi:1042
#: original_texis/numbers.texi:1067
#, no-wrap
msgid ""
"                   ; @r{       binary values}\n"
"\n"
msgstr ""
"                   ; @r{       2進数値}\n"
"\n"

#. type: group
#: original_texis/numbers.texi:1016
#, no-wrap
msgid ""
"(logand 14 13)     ; 14  =  @r{@dots{}001110}\n"
"                   ; 13  =  @r{@dots{}001101}\n"
"     @result{} 12         ; 12  =  @r{@dots{}001100}\n"
msgstr ""
"(logand 14 13)     ; 14  =  @r{@dots{}001110}\n"
"                   ; 13  =  @r{@dots{}001101}\n"
"     @result{} 12         ; 12  =  @r{@dots{}001100}\n"

#. type: group
#: original_texis/numbers.texi:1023
#, no-wrap
msgid ""
"(logand 14 13 4)   ; 14  =  @r{@dots{}001110}\n"
"                   ; 13  =  @r{@dots{}001101}\n"
"                   ;  4  =  @r{@dots{}000100}\n"
"     @result{} 4          ;  4  =  @r{@dots{}000100}\n"
msgstr ""
"(logand 14 13 4)   ; 14  =  @r{@dots{}001110}\n"
"                   ; 13  =  @r{@dots{}001101}\n"
"                   ;  4  =  @r{@dots{}000100}\n"
"     @result{} 4          ;  4  =  @r{@dots{}000100}\n"

#. type: group
#: original_texis/numbers.texi:1028
#, no-wrap
msgid ""
"(logand)\n"
"     @result{} -1         ; -1  =  @r{@dots{}111111}\n"
msgstr ""
"(logand)\n"
"     @result{} -1         ; -1  =  @r{@dots{}111111}\n"

#. type: defun
#: original_texis/numbers.texi:1032
#, no-wrap
msgid "logior &rest ints-or-markers"
msgstr "logior &rest ints-or-markers"

#. type: defun
#: original_texis/numbers.texi:1038
msgid "This function returns the bitwise inclusive OR of its arguments: the @var{n}th bit is 1 in the result if, and only if, the @var{n}th bit is 1 in at least one of the arguments.  If there are no arguments, the result is 0, which is an identity element for this operation.  If @code{logior} is passed just one argument, it returns that argument."
msgstr "この関数は、引数のビット単位の包含的ORをリターンする。少なくとも1つの引数で@var{n}番目のビットが1なら、結果の@var{n}番目のビットが1になる。引数を与えなければ、結果はこの処理にたいする単位元である0となる。@code{logior}に渡す引数が1つだけならその引数がリターンされる。"

#. type: group
#: original_texis/numbers.texi:1046
#, no-wrap
msgid ""
"(logior 12 5)      ; 12  =  @r{@dots{}001100}\n"
"                   ;  5  =  @r{@dots{}000101}\n"
"     @result{} 13         ; 13  =  @r{@dots{}001101}\n"
msgstr ""
"(logior 12 5)      ; 12  =  @r{@dots{}001100}\n"
"                   ;  5  =  @r{@dots{}000101}\n"
"     @result{} 13         ; 13  =  @r{@dots{}001101}\n"

#. type: group
#: original_texis/numbers.texi:1053
#, no-wrap
msgid ""
"(logior 12 5 7)    ; 12  =  @r{@dots{}001100}\n"
"                   ;  5  =  @r{@dots{}000101}\n"
"                   ;  7  =  @r{@dots{}000111}\n"
"     @result{} 15         ; 15  =  @r{@dots{}001111}\n"
msgstr ""
"(logior 12 5 7)    ; 12  =  @r{@dots{}001100}\n"
"                   ;  5  =  @r{@dots{}000101}\n"
"                   ;  7  =  @r{@dots{}000111}\n"
"     @result{} 15         ; 15  =  @r{@dots{}001111}\n"

#. type: defun
#: original_texis/numbers.texi:1057
#, no-wrap
msgid "logxor &rest ints-or-markers"
msgstr "logxor &rest ints-or-markers"

#. type: defun
#: original_texis/numbers.texi:1063
msgid "This function returns the bitwise exclusive OR of its arguments: the @var{n}th bit is 1 in the result if, and only if, the @var{n}th bit is 1 in an odd number of the arguments.  If there are no arguments, the result is 0, which is an identity element for this operation.  If @code{logxor} is passed just one argument, it returns that argument."
msgstr "この関数は、引数のビット単位の排他的ORをリターンする。@var{n}番目のビットが1であるような引数の数が奇数個の場合のみ、結果の@var{n}番目のビットが1となる。引数を与えなければ、結果はこの処理の単位元である0となる。@code{logxor}に渡す引数が1つだけならその引数がリターンされる。"

#. type: group
#: original_texis/numbers.texi:1071
#, no-wrap
msgid ""
"(logxor 12 5)      ; 12  =  @r{@dots{}001100}\n"
"                   ;  5  =  @r{@dots{}000101}\n"
"     @result{} 9          ;  9  =  @r{@dots{}001001}\n"
msgstr ""
"(logxor 12 5)      ; 12  =  @r{@dots{}001100}\n"
"                   ;  5  =  @r{@dots{}000101}\n"
"     @result{} 9          ;  9  =  @r{@dots{}001001}\n"

#. type: group
#: original_texis/numbers.texi:1078
#, no-wrap
msgid ""
"(logxor 12 5 7)    ; 12  =  @r{@dots{}001100}\n"
"                   ;  5  =  @r{@dots{}000101}\n"
"                   ;  7  =  @r{@dots{}000111}\n"
"     @result{} 14         ; 14  =  @r{@dots{}001110}\n"
msgstr ""
"(logxor 12 5 7)    ; 12  =  @r{@dots{}001100}\n"
"                   ;  5  =  @r{@dots{}000101}\n"
"                   ;  7  =  @r{@dots{}000111}\n"
"     @result{} 14         ; 14  =  @r{@dots{}001110}\n"

#. type: defun
#: original_texis/numbers.texi:1082
#, no-wrap
msgid "lognot integer"
msgstr "lognot integer"

#. type: defun
#: original_texis/numbers.texi:1087
msgid "This function returns the bitwise complement of its argument: the @var{n}th bit is one in the result if, and only if, the @var{n}th bit is zero in @var{integer}, and vice-versa.  The result equals @minus{}1 @minus{} @var{integer}."
msgstr "この関数は引数のビット単位の補数(bitwise complement)をリターンする。@var{integer}の@var{n}番目のビットが0の場合に限り、結果の@var{n}番目のビットが1になり、その逆も成り立つ。結果は@minus{}1 @minus{} @var{integer}と等価。"

#. type: example
#: original_texis/numbers.texi:1094
#, no-wrap
msgid ""
"(lognot 5)\n"
"     @result{} -6\n"
";;  5  =  @r{@dots{}000101}\n"
";; @r{becomes}\n"
";; -6  =  @r{@dots{}111010}\n"
msgstr ""
"(lognot 5)\n"
"     @result{} -6\n"
";;  5  =  @r{@dots{}000101}\n"
";; @r{becomes}\n"
";; -6  =  @r{@dots{}111010}\n"

#. type: cindex
#: original_texis/numbers.texi:1097
#, no-wrap
msgid "popcount"
msgstr "popcount"

#. type: cindex
#: original_texis/numbers.texi:1098
#, no-wrap
msgid "Hamming weight"
msgstr "Hamming weight"

#. type: cindex
#: original_texis/numbers.texi:1099
#, no-wrap
msgid "counting set bits"
msgstr "counting set bits"

#. type: defun
#: original_texis/numbers.texi:1100
#, no-wrap
msgid "logcount integer"
msgstr "logcount integer"

#. type: defun
#: original_texis/numbers.texi:1106
msgid "This function returns the @dfn{Hamming weight} of @var{integer}: the number of ones in the binary representation of @var{integer}.  If @var{integer} is negative, it returns the number of zero bits in its two's complement binary representation.  The result is always nonnegative."
msgstr "この関数は@var{integer}の@dfn{ハミング重み} (Hamming weight: @var{integer}の2進数表現での1の個数)をリターンする。@var{integer}が負なら、その2の補数の2進数表現での0ビットの個数をリターンする。結果は常に非負となる。"

#. type: example
#: original_texis/numbers.texi:1112
#, no-wrap
msgid ""
"(logcount 43)     ;  43 = @r{@dots{}000101011}\n"
"     @result{} 4\n"
"(logcount -43)    ; -43 = @r{@dots{}111010101}\n"
"     @result{} 3\n"
msgstr ""
"(logcount 43)     ;  43 = @r{@dots{}000101011}\n"
"     @result{} 4\n"
"(logcount -43)    ; -43 = @r{@dots{}111010101}\n"
"     @result{} 3\n"

#. type: section
#: original_texis/numbers.texi:1116
#, no-wrap
msgid "Standard Mathematical Functions"
msgstr "Standard Mathematical Functions"

#. type: cindex
#: original_texis/numbers.texi:1117
#, no-wrap
msgid "transcendental functions"
msgstr "transcendental functions"

#. type: cindex
#: original_texis/numbers.texi:1118
#, no-wrap
msgid "mathematical functions"
msgstr "mathematical functions"

#. type: cindex
#: original_texis/numbers.texi:1119
#, no-wrap
msgid "floating-point functions"
msgstr "floating-point functions"

#. type: Plain text
#: original_texis/numbers.texi:1123
msgid "These mathematical functions allow integers as well as floating-point numbers as arguments."
msgstr "以下の数学的関数は、引数として整数と同様に浮動小数点数も受け入れます。"

#. type: defun
#: original_texis/numbers.texi:1124
#, no-wrap
msgid "sin arg"
msgstr "sin arg"

#. type: defunx
#: original_texis/numbers.texi:1125
#, no-wrap
msgid "cos arg"
msgstr "cos arg"

#. type: defunx
#: original_texis/numbers.texi:1126
#, no-wrap
msgid "tan arg"
msgstr "tan arg"

#. type: defun
#: original_texis/numbers.texi:1129
msgid "These are the basic trigonometric functions, with argument @var{arg} measured in radians."
msgstr "これらは三角関数であり、引数@var{arg}はラジアン単位。"

#. type: defun
#: original_texis/numbers.texi:1131
#, no-wrap
msgid "asin arg"
msgstr "asin arg"

#. type: defun
#: original_texis/numbers.texi:1133
msgid "The value of @code{(asin @var{arg})} is a number between"
msgstr "@code{(asin @var{arg})}の値は、sinの値が@var{arg}となるような"

#. type: ifnottex
#: original_texis/numbers.texi:1135 original_texis/numbers.texi:1166
msgid "@minus{}pi/2"
msgstr "@minus{}pi/2"

#. type: tex
#: original_texis/numbers.texi:1138 original_texis/numbers.texi:1169
#, no-wrap
msgid "@math{-\\pi/2}\n"
msgstr "@math{-\\pi/2}\n"

#. type: defun
#: original_texis/numbers.texi:1140 original_texis/numbers.texi:1171
msgid "and"
msgstr "から"

#. type: ifnottex
#: original_texis/numbers.texi:1142 original_texis/numbers.texi:1173
msgid "pi/2"
msgstr "pi/2"

#. type: tex
#: original_texis/numbers.texi:1145 original_texis/numbers.texi:1176
#, no-wrap
msgid "@math{\\pi/2}\n"
msgstr "@math{\\pi/2}\n"

#. type: defun
#: original_texis/numbers.texi:1148
msgid "(inclusive) whose sine is @var{arg}.  If @var{arg} is out of range (outside [@minus{}1, 1]), @code{asin} returns a NaN."
msgstr "(両端を含む)の数である。@var{arg}が範囲外([@minus{}1, 1]の外)なら、@code{asin}はNaNをリターンする。"

#. type: defun
#: original_texis/numbers.texi:1150
#, no-wrap
msgid "acos arg"
msgstr "acos arg"

#. type: defun
#: original_texis/numbers.texi:1152
msgid "The value of @code{(acos @var{arg})} is a number between 0 and"
msgstr "@code{(acos @var{arg})}の値は、cosの値が@var{arg}となるような、0から"

#. type: ifnottex
#: original_texis/numbers.texi:1154
msgid "pi"
msgstr "pi"

#. type: tex
#: original_texis/numbers.texi:1157
#, no-wrap
msgid "@math{\\pi}\n"
msgstr "@math{\\pi}\n"

#. type: defun
#: original_texis/numbers.texi:1160
msgid "(inclusive) whose cosine is @var{arg}.  If @var{arg} is out of range (outside [@minus{}1, 1]), @code{acos} returns a NaN."
msgstr "(両端を含む)の数である。argが範囲外([-1, 1]の外)なら@code{acos}はNaNをリターンする。"

#. type: defun
#: original_texis/numbers.texi:1162
#, no-wrap
msgid "atan y &optional x"
msgstr "atan y &optional x"

#. type: defun
#: original_texis/numbers.texi:1164
msgid "The value of @code{(atan @var{y})} is a number between"
msgstr "@code{(atan @var{y})}の値は、tanの値が@var{y}となるような、"

#. type: defun
#: original_texis/numbers.texi:1181
msgid "(exclusive) whose tangent is @var{y}.  If the optional second argument @var{x} is given, the value of @code{(atan y x)} is the angle in radians between the vector @code{[@var{x}, @var{y}]} and the @code{X} axis."
msgstr "(両端を含まず)の数である。オプションの第2引数@var{x}が与えられると、@code{(atan y x)}の値はベクトル@code{[@var{x}, @var{y}]}と@code{X}軸が成す角度のラジアン値となる。"

#. type: defun
#: original_texis/numbers.texi:1183
#, no-wrap
msgid "exp arg"
msgstr "exp arg"

#. type: defun
#: original_texis/numbers.texi:1186
msgid "This is the exponential function; it returns @math{e} to the power @var{arg}."
msgstr "これは指数関数である。この関数は@math{e}の指数@var{arg}をリターンする。"

#. type: defun
#: original_texis/numbers.texi:1188
#, no-wrap
msgid "log arg &optional base"
msgstr "log arg &optional base"

#. type: defun
#: original_texis/numbers.texi:1193
msgid "This function returns the logarithm of @var{arg}, with base @var{base}.  If you don't specify @var{base}, the natural base @math{e} is used.  If @var{arg} or @var{base} is negative, @code{log} returns a NaN."
msgstr "この関数は底を@var{base}とする@var{arg}の対数をリターンする。@var{base}を指定しなければ、自然底(natural base)@math{e}が使用される。@var{arg}か@var{base}が負なら、@code{log}はNaNをリターンする。"

#. type: defun
#: original_texis/numbers.texi:1195
#, no-wrap
msgid "expt x y"
msgstr "expt x y"

#. type: defun
#: original_texis/numbers.texi:1201
msgid "This function returns @var{x} raised to power @var{y}.  If both arguments are integers and @var{y} is nonnegative, the result is an integer; in this case, overflow signals an error, so watch out.  If @var{x} is a finite negative number and @var{y} is a finite non-integer, @code{expt} returns a NaN."
msgstr "この関数は@var{x}に@var{y}を乗じてリターンする。引数が両方とも整数で@var{y}が非負なら結果は整数になる。この場合オーバーフローはエラーをシグナルするので注意。@var{x}が有限の負数で@var{y}が有限の非整数なら、@code{expt}はNaNをリターンする。"

#. type: defun
#: original_texis/numbers.texi:1203
#, no-wrap
msgid "sqrt arg"
msgstr "sqrt arg"

#. type: defun
#: original_texis/numbers.texi:1206
msgid "This returns the square root of @var{arg}.  If @var{arg} is finite and less than zero, @code{sqrt} returns a NaN."
msgstr "これは@var{arg}の平方根をリターンする。@var{arg}が有限で0より小さければ、@code{sqrt}はNaNをリターンする。"

#. type: Plain text
#: original_texis/numbers.texi:1210
msgid "In addition, Emacs defines the following common mathematical constants:"
msgstr "加えて、Emacsは以下の数学的な定数を定義します:"

#. type: defvar
#: original_texis/numbers.texi:1211
#, no-wrap
msgid "float-e"
msgstr "float-e"

#. type: defvar
#: original_texis/numbers.texi:1213
msgid "The mathematical constant @math{e} (2.71828@dots{})."
msgstr "自然対数@math{e}(2.71828@dots{})"

#. type: defvar
#: original_texis/numbers.texi:1215
#, no-wrap
msgid "float-pi"
msgstr "float-pi"

#. type: defvar
#: original_texis/numbers.texi:1217
msgid "The mathematical constant @math{pi} (3.14159@dots{})."
msgstr "円周率@math{pi}(3.14159@dots{})"

#. type: cindex
#: original_texis/numbers.texi:1221
#, no-wrap
msgid "random numbers"
msgstr "random numbers"

#. type: Plain text
#: original_texis/numbers.texi:1229
msgid "A deterministic computer program cannot generate true random numbers.  For most purposes, @dfn{pseudo-random numbers} suffice.  A series of pseudo-random numbers is generated in a deterministic fashion.  The numbers are not truly random, but they have certain properties that mimic a random series.  For example, all possible values occur equally often in a pseudo-random series."
msgstr "決定論的なコンピュータープログラムでは真の乱数を生成することはできません。しかしほとんどの目的には、@dfn{疑似乱数(pseudo-random numbers)}で充分です。一連の疑似乱数は決定論的な手法により生成されます。真の乱数ではありませんが、それらにはランダム列を模する特別な性質があります。たとえば疑似ランダム系では、すべての可能な値は均等に発生します。"

#. type: cindex
#: original_texis/numbers.texi:1230
#, no-wrap
msgid "seed, for random number generation"
msgstr "seed, for random number generation"

#. type: Plain text
#: original_texis/numbers.texi:1236
msgid "Pseudo-random numbers are generated from a @dfn{seed value}.  Starting from any given seed, the @code{random} function always generates the same sequence of numbers.  By default, Emacs initializes the random seed at startup, in such a way that the sequence of values of @code{random} (with overwhelming likelihood) differs in each Emacs run."
msgstr "疑似乱数は@dfn{シード値(seed value)}から生成されます。与えられた任意のシードから開始することにより、@code{random}関数は常に同じ数列を生成します。デフォルトでは、Emacsは開始時に乱数シードを初期化することにより、それぞれのEmacsの実行において、@code{random}の値シーケンスは(ほとんど確実に)異なります。"

#. type: Plain text
#: original_texis/numbers.texi:1244
msgid "Sometimes you want the random number sequence to be repeatable.  For example, when debugging a program whose behavior depends on the random number sequence, it is helpful to get the same behavior in each program run.  To make the sequence repeat, execute @code{(random \"\")}.  This sets the seed to a constant value for your particular Emacs executable (though it may differ for other Emacs builds).  You can use other strings to choose various seed values."
msgstr "再現可能な乱数シーケンスが欲しい場合もあります。たとえば乱数シーケンスに依存するプログラムをデバッグする場合、プログラムの各実行において同じ挙動を得ることが助けになります。再現可能なシーケンスを作成するには、@code{(random \"\")}を実行します。これは特定のEmacsの実行可能ファイルにたいして、シードに定数値をセットします(しかしこの実行可能ファイルは、その他のEmacsビルドと異なるものになるであろう)。シード値として、他のさまざまな文字列を使用することができます。"

#. type: defun
#: original_texis/numbers.texi:1245
#, no-wrap
msgid "random &optional limit"
msgstr "random &optional limit"

#. type: defun
#: original_texis/numbers.texi:1248
msgid "This function returns a pseudo-random integer.  Repeated calls return a series of pseudo-random integers."
msgstr "この関数は疑似乱数の整数をリターンする。繰り返し呼び出すと一連の疑似乱数の整数をリターンする。"

#. type: defun
#: original_texis/numbers.texi:1253
msgid "If @var{limit} is a positive fixnum, the value is chosen to be nonnegative and less than @var{limit}.  Otherwise, the value might be any fixnum, i.e., any integer from @code{most-negative-fixnum} through @code{most-positive-fixnum} (@pxref{Integer Basics})."
msgstr "@var{limit}が正のfixnumなら、値は負ではない@var{limit}未満の値から選択される。それ以外なら値はLispで表現可能な任意のfixnum(@code{most-negative-fixnum}から@code{most-positive-fixnum}の間の任意の整数)となるだろう(@ref{Integer Basics}を参照)。"

#. type: defun
#: original_texis/numbers.texi:1258
msgid "If @var{limit} is @code{t}, it means to choose a new seed as if Emacs were restarting, typically from the system entropy.  On systems lacking entropy pools, choose the seed from less-random volatile data such as the current time."
msgstr "@var{limit}が@code{t}なら、あたかもEmacsが再起動されたかのように、通常はシステムのエントロピーから新たなシードが選択されることを意味する。エントロピープールを欠くシステムでは、カレント時刻のような若干揮発性が低い乱数からシードが選択される。"

#. type: defun
#: original_texis/numbers.texi:1261
msgid "If @var{limit} is a string, it means to choose a new seed based on the string's contents."
msgstr "@var{limit}が文字列なら、その文字列定数にもとづいた新しいシードを選択することを意味する。"
