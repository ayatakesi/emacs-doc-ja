# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2024-06-26 23:46+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: original_texis/lists.texi:6 original_texis/lists.texi:7
#, no-wrap
msgid "Lists"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:8
#, no-wrap
msgid "lists"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:9
#, no-wrap
msgid "element (of list)"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:16
msgid ""
"A @dfn{list} represents a sequence of zero or more elements (which may be "
"any Lisp objects).  The important difference between lists and vectors is "
"that two or more lists can share part of their structure; in addition, you "
"can insert or delete elements in a list without copying the whole list."
msgstr ""

#. type: node
#: original_texis/lists.texi:27 original_texis/lists.texi:29
#, no-wrap
msgid "Cons Cells"
msgstr ""

#. type: menuentry
#: original_texis/lists.texi:27
msgid "How lists are made out of cons cells."
msgstr ""

#. type: node
#: original_texis/lists.texi:27 original_texis/lists.texi:91
#, no-wrap
msgid "List-related Predicates"
msgstr ""

#. type: menuentry
#: original_texis/lists.texi:27
msgid "Is this object a list? Comparing two lists."
msgstr ""

#. type: node
#: original_texis/lists.texi:27 original_texis/lists.texi:179
#, no-wrap
msgid "List Elements"
msgstr ""

#. type: menuentry
#: original_texis/lists.texi:27
msgid "Extracting the pieces of a list."
msgstr ""

#. type: node
#: original_texis/lists.texi:27 original_texis/lists.texi:472
#, no-wrap
msgid "Building Lists"
msgstr ""

#. type: menuentry
#: original_texis/lists.texi:27
msgid "Creating list structure."
msgstr ""

#. type: node
#: original_texis/lists.texi:27 original_texis/lists.texi:784
#, no-wrap
msgid "List Variables"
msgstr ""

#. type: menuentry
#: original_texis/lists.texi:27
msgid "Modifying lists stored in variables."
msgstr ""

#. type: node
#: original_texis/lists.texi:27 original_texis/lists.texi:921
#, no-wrap
msgid "Modifying Lists"
msgstr ""

#. type: menuentry
#: original_texis/lists.texi:27
msgid "Storing new pieces into an existing list."
msgstr ""

#. type: node
#: original_texis/lists.texi:27 original_texis/lists.texi:1266
#, no-wrap
msgid "Sets And Lists"
msgstr ""

#. type: menuentry
#: original_texis/lists.texi:27
msgid "A list can represent a finite mathematical set."
msgstr ""

#. type: section
#: original_texis/lists.texi:27 original_texis/lists.texi:1541
#: original_texis/lists.texi:1542
#, no-wrap
msgid "Association Lists"
msgstr ""

#. type: menuentry
#: original_texis/lists.texi:27
msgid "A list can represent a finite relation or mapping."
msgstr ""

#. type: section
#: original_texis/lists.texi:27 original_texis/lists.texi:1889
#: original_texis/lists.texi:1890
#, no-wrap
msgid "Property Lists"
msgstr ""

#. type: menuentry
#: original_texis/lists.texi:27
msgid "A list of paired elements."
msgstr ""

#. type: section
#: original_texis/lists.texi:30
#, no-wrap
msgid "Lists and Cons Cells"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:31
#, no-wrap
msgid "lists and cons cells"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:40
msgid ""
"Lists in Lisp are not a primitive data type; they are built up from "
"@dfn{cons cells} (@pxref{Cons Cell Type}).  A cons cell is a data object "
"that represents an ordered pair.  That is, it has two slots, and each slot "
"@dfn{holds}, or @dfn{refers to}, some Lisp object.  One slot is known as the "
"@sc{car}, and the other is known as the @sc{cdr}.  (These names are "
"traditional; see @ref{Cons Cell Type}.)  @sc{cdr} is pronounced "
"``could-er''."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:43
msgid ""
"We say that ``the @sc{car} of this cons cell is'' whatever object its "
"@sc{car} slot currently holds, and likewise for the @sc{cdr}."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:52
msgid ""
"A list is a series of cons cells chained together, so that each cell refers "
"to the next one.  There is one cons cell for each element of the list.  By "
"convention, the @sc{car}s of the cons cells hold the elements of the list, "
"and the @sc{cdr}s are used to chain the list (this asymmetry between "
"@sc{car} and @sc{cdr} is entirely a matter of convention; at the level of "
"cons cells, the @sc{car} and @sc{cdr} slots have similar properties).  "
"Hence, the @sc{cdr} slot of each cons cell in a list refers to the following "
"cons cell."
msgstr ""

#. type: cindex
#: original_texis/lists.texi:53
#, no-wrap
msgid "proper list"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:54
#, no-wrap
msgid "true list"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:63
msgid ""
"Also by convention, the @sc{cdr} of the last cons cell in a list is "
"@code{nil}.  We call such a @code{nil}-terminated structure a @dfn{proper "
"list}@footnote{It is sometimes also referred to as a @dfn{true list}, but we "
"generally do not use this terminology in this manual.}.  In Emacs Lisp, the "
"symbol @code{nil} is both a symbol and a list with no elements.  For "
"convenience, the symbol @code{nil} is considered to have @code{nil} as its "
"@sc{cdr} (and also as its @sc{car})."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:67
msgid ""
"Hence, the @sc{cdr} of a proper list is always a proper list.  The @sc{cdr} "
"of a nonempty proper list is a proper list containing all the elements "
"except the first."
msgstr ""

#. type: cindex
#: original_texis/lists.texi:68
#, no-wrap
msgid "dotted list"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:69
#, no-wrap
msgid "circular list"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:76
msgid ""
"If the @sc{cdr} of a list's last cons cell is some value other than "
"@code{nil}, we call the structure a @dfn{dotted list}, since its printed "
"representation would use dotted pair notation (@pxref{Dotted Pair "
"Notation}).  There is one other possibility: some cons cell's @sc{cdr} could "
"point to one of the previous cons cells in the list.  We call that structure "
"a @dfn{circular list}."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:86
msgid ""
"For some purposes, it does not matter whether a list is proper, circular or "
"dotted.  If a program doesn't look far enough down the list to see the "
"@sc{cdr} of the final cons cell, it won't care.  However, some functions "
"that operate on lists demand proper lists and signal errors if given a "
"dotted list.  Most functions that try to find the end of a list enter "
"infinite loops if given a circular list.  You can use the function "
"@code{proper-list-p}, described in the next section (@pxref{List-related "
"Predicates, proper-list-p}), to determine whether a list is a proper one."
msgstr ""

#. type: cindex
#: original_texis/lists.texi:87
#, no-wrap
msgid "list structure"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:90
msgid ""
"Because most cons cells are used as part of lists, we refer to any structure "
"made out of cons cells as a @dfn{list structure}."
msgstr ""

#. type: section
#: original_texis/lists.texi:92
#, no-wrap
msgid "Predicates on Lists"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:93
#, no-wrap
msgid "predicates for lists"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:94
#, no-wrap
msgid "list predicates"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:101
msgid ""
"The following predicates test whether a Lisp object is an atom, whether it "
"is a cons cell or is a list, or whether it is the distinguished object "
"@code{nil}.  (Many of these predicates can be defined in terms of the "
"others, but they are used so often that it is worth having them.)"
msgstr ""

#. type: defun
#: original_texis/lists.texi:102
#, no-wrap
msgid "consp object"
msgstr ""

#. type: defun
#: original_texis/lists.texi:105
msgid ""
"This function returns @code{t} if @var{object} is a cons cell, @code{nil} "
"otherwise.  @code{nil} is not a cons cell, although it @emph{is} a list."
msgstr ""

#. type: defun
#: original_texis/lists.texi:107
#, no-wrap
msgid "atom object"
msgstr ""

#. type: defun
#: original_texis/lists.texi:112
msgid ""
"This function returns @code{t} if @var{object} is an atom, @code{nil} "
"otherwise.  All objects except cons cells are atoms.  The symbol @code{nil} "
"is an atom and is also a list; it is the only Lisp object that is both."
msgstr ""

#. type: example
#: original_texis/lists.texi:115
#, no-wrap
msgid "(atom @var{object}) @equiv{} (not (consp @var{object}))\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:118
#, no-wrap
msgid "listp object"
msgstr ""

#. type: defun
#: original_texis/lists.texi:121
msgid ""
"This function returns @code{t} if @var{object} is a cons cell or "
"@code{nil}.  Otherwise, it returns @code{nil}."
msgstr ""

#. type: group
#: original_texis/lists.texi:126
#, no-wrap
msgid ""
"(listp '(1))\n"
"     @result{} t\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:130
#, no-wrap
msgid ""
"(listp '())\n"
"     @result{} t\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:134
#, no-wrap
msgid "nlistp object"
msgstr ""

#. type: defun
#: original_texis/lists.texi:137
msgid ""
"This function is the opposite of @code{listp}: it returns @code{t} if "
"@var{object} is not a list.  Otherwise, it returns @code{nil}."
msgstr ""

#. type: example
#: original_texis/lists.texi:140
#, no-wrap
msgid "(listp @var{object}) @equiv{} (not (nlistp @var{object}))\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:143
#, no-wrap
msgid "null object"
msgstr ""

#. type: defun
#: original_texis/lists.texi:149
msgid ""
"This function returns @code{t} if @var{object} is @code{nil}, and returns "
"@code{nil} otherwise.  This function is identical to @code{not}, but as a "
"matter of clarity we use @code{not} when @var{object} is considered a truth "
"value (see @code{not} in @ref{Combining Conditions}) and @code{null} "
"otherwise."
msgstr ""

#. type: group
#: original_texis/lists.texi:154
#, no-wrap
msgid ""
"(null '(1))\n"
"     @result{} nil\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:158
#, no-wrap
msgid ""
"(null '())\n"
"     @result{} t\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:162
#, no-wrap
msgid "proper-list-p object"
msgstr ""

#. type: defun
#: original_texis/lists.texi:166
msgid ""
"This function returns the length of @var{object} if it is a proper list, "
"@code{nil} otherwise (@pxref{Cons Cells}).  In addition to satisfying "
"@code{listp}, a proper list is neither circular nor dotted."
msgstr ""

#. type: group
#: original_texis/lists.texi:171
#, no-wrap
msgid ""
"(proper-list-p '(a b c))\n"
"    @result{} 3\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:175
#, no-wrap
msgid ""
"(proper-list-p '(a b . c))\n"
"    @result{} nil\n"
msgstr ""

#. type: section
#: original_texis/lists.texi:180
#, no-wrap
msgid "Accessing Elements of Lists"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:181
#, no-wrap
msgid "list elements"
msgstr ""

#. type: defun
#: original_texis/lists.texi:183
#, no-wrap
msgid "car cons-cell"
msgstr ""

#. type: defun
#: original_texis/lists.texi:187
msgid ""
"This function returns the value referred to by the first slot of the cons "
"cell @var{cons-cell}.  In other words, it returns the @sc{car} of "
"@var{cons-cell}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:191
msgid ""
"As a special case, if @var{cons-cell} is @code{nil}, this function returns "
"@code{nil}.  Therefore, any list is a valid argument.  An error is signaled "
"if the argument is not a cons cell or @code{nil}."
msgstr ""

#. type: group
#: original_texis/lists.texi:196
#, no-wrap
msgid ""
"(car '(a b c))\n"
"     @result{} a\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:200
#, no-wrap
msgid ""
"(car '())\n"
"     @result{} nil\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:204
#, no-wrap
msgid "cdr cons-cell"
msgstr ""

#. type: defun
#: original_texis/lists.texi:208
msgid ""
"This function returns the value referred to by the second slot of the cons "
"cell @var{cons-cell}.  In other words, it returns the @sc{cdr} of "
"@var{cons-cell}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:212
msgid ""
"As a special case, if @var{cons-cell} is @code{nil}, this function returns "
"@code{nil}; therefore, any list is a valid argument.  An error is signaled "
"if the argument is not a cons cell or @code{nil}."
msgstr ""

#. type: group
#: original_texis/lists.texi:217
#, no-wrap
msgid ""
"(cdr '(a b c))\n"
"     @result{} (b c)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:221
#, no-wrap
msgid ""
"(cdr '())\n"
"     @result{} nil\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:225
#, no-wrap
msgid "car-safe object"
msgstr ""

#. type: defun
#: original_texis/lists.texi:230
msgid ""
"This function lets you take the @sc{car} of a cons cell while avoiding "
"errors for other data types.  It returns the @sc{car} of @var{object} if "
"@var{object} is a cons cell, @code{nil} otherwise.  This is in contrast to "
"@code{car}, which signals an error if @var{object} is not a list."
msgstr ""

#. type: group
#: original_texis/lists.texi:239
#, no-wrap
msgid ""
"(car-safe @var{object})\n"
"@equiv{}\n"
"(let ((x @var{object}))\n"
"  (if (consp x)\n"
"      (car x)\n"
"    nil))\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:243
#, no-wrap
msgid "cdr-safe object"
msgstr ""

#. type: defun
#: original_texis/lists.texi:249
msgid ""
"This function lets you take the @sc{cdr} of a cons cell while avoiding "
"errors for other data types.  It returns the @sc{cdr} of @var{object} if "
"@var{object} is a cons cell, @code{nil} otherwise.  This is in contrast to "
"@code{cdr}, which signals an error if @var{object} is not a list."
msgstr ""

#. type: group
#: original_texis/lists.texi:258
#, no-wrap
msgid ""
"(cdr-safe @var{object})\n"
"@equiv{}\n"
"(let ((x @var{object}))\n"
"  (if (consp x)\n"
"      (cdr x)\n"
"    nil))\n"
msgstr ""

#. type: defmac
#: original_texis/lists.texi:262
#, no-wrap
msgid "pop listname"
msgstr ""

#. type: defmac
#: original_texis/lists.texi:268
msgid ""
"This macro provides a convenient way to examine the @sc{car} of a list, and "
"take it off the list, all at once.  It operates on the list stored in "
"@var{listname}.  It removes the first element from the list, saves the "
"@sc{cdr} into @var{listname}, then returns the removed element."
msgstr ""

#. type: defmac
#: original_texis/lists.texi:272
msgid ""
"In the simplest case, @var{listname} is an unquoted symbol naming a list; in "
"that case, this macro is equivalent to @w{@code{(prog1 (car listname) (setq "
"listname (cdr listname)))}}."
msgstr ""

#. type: example
#: original_texis/lists.texi:280
#, no-wrap
msgid ""
"x\n"
"     @result{} (a b c)\n"
"(pop x)\n"
"     @result{} a\n"
"x\n"
"     @result{} (b c)\n"
msgstr ""

#. type: defmac
#: original_texis/lists.texi:285
msgid ""
"More generally, @var{listname} can be a generalized variable.  In that case, "
"this macro saves into @var{listname} using @code{setf}.  @xref{Generalized "
"Variables}."
msgstr ""

#. type: defmac
#: original_texis/lists.texi:288
msgid ""
"For the @code{push} macro, which adds an element to a list, @xref{List "
"Variables}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:290
#, no-wrap
msgid "nth n list"
msgstr ""

#. type: anchor{#1}
#: original_texis/lists.texi:296
msgid "Definition of nth"
msgstr ""

#. type: defun
#: original_texis/lists.texi:296
msgid ""
"This function returns the @var{n}th element of @var{list}.  Elements are "
"numbered starting with zero, so the @sc{car} of @var{list} is element number "
"zero.  If the length of @var{list} is @var{n} or less, the value is "
"@code{nil}."
msgstr ""

#. type: group
#: original_texis/lists.texi:306
#, no-wrap
msgid ""
"(nth 2 '(1 2 3 4))\n"
"     @result{} 3\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:310
#, no-wrap
msgid ""
"(nth 10 '(1 2 3 4))\n"
"     @result{} nil\n"
"\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:312
#, no-wrap
msgid "(nth n x) @equiv{} (car (nthcdr n x))\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:318
msgid ""
"The function @code{elt} is similar, but applies to any kind of sequence.  "
"For historical reasons, it takes its arguments in the opposite order.  "
"@xref{Sequence Functions}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:320
#, no-wrap
msgid "nthcdr n list"
msgstr ""

#. type: defun
#: original_texis/lists.texi:324
msgid ""
"This function returns the @var{n}th @sc{cdr} of @var{list}.  In other words, "
"it skips past the first @var{n} links of @var{list} and returns what "
"follows."
msgstr ""

#. type: defun
#: original_texis/lists.texi:329
msgid ""
"If @var{n} is zero, @code{nthcdr} returns all of @var{list}.  If the length "
"of @var{list} is @var{n} or less, @code{nthcdr} returns @code{nil}."
msgstr ""

#. type: group
#: original_texis/lists.texi:334
#, no-wrap
msgid ""
"(nthcdr 1 '(1 2 3 4))\n"
"     @result{} (2 3 4)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:338
#, no-wrap
msgid ""
"(nthcdr 10 '(1 2 3 4))\n"
"     @result{} nil\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:342
#, no-wrap
msgid ""
"(nthcdr 0 '(1 2 3 4))\n"
"     @result{} (1 2 3 4)\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:346
#, no-wrap
msgid "take n list"
msgstr ""

#. type: defun
#: original_texis/lists.texi:349
msgid ""
"This function returns the @var{n} first elements of @var{list}.  "
"Essentially, it returns the part of @var{list} that @code{nthcdr} skips."
msgstr ""

#. type: defun
#: original_texis/lists.texi:352
msgid ""
"@code{take} returns @var{list} if shorter than @var{n} elements; it returns "
"@code{nil} if @var{n} is zero or negative."
msgstr ""

#. type: group
#: original_texis/lists.texi:357
#, no-wrap
msgid ""
"(take 3 '(a b c d))\n"
"     @result{} (a b c)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:361
#, no-wrap
msgid ""
"(take 10 '(a b c d))\n"
"     @result{} (a b c d)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:365
#, no-wrap
msgid ""
"(take 0 '(a b c d))\n"
"     @result{} nil\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:369
#, no-wrap
msgid "ntake n list"
msgstr ""

#. type: defun
#: original_texis/lists.texi:373
msgid ""
"This is a version of @code{take} that works by destructively modifying the "
"list structure of the argument.  That makes it faster, but the original "
"value of @var{list} may be lost."
msgstr ""

#. type: defun
#: original_texis/lists.texi:378
msgid ""
"@code{ntake} returns @var{list} unmodified if shorter than @var{n} elements; "
"it returns @code{nil} if @var{n} is zero or negative.  Otherwise, it returns "
"@var{list} truncated to its first @var{n} elements."
msgstr ""

#. type: defun
#: original_texis/lists.texi:382
msgid ""
"This means that it is usually a good idea to use the return value and not "
"just rely on the truncation effect unless @var{n} is known to be positive."
msgstr ""

#. type: defun
#: original_texis/lists.texi:384
#, no-wrap
msgid "last list &optional n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:390
msgid ""
"This function returns the last link of @var{list}.  The @code{car} of this "
"link is the list's last element.  If @var{list} is null, @code{nil} is "
"returned.  If @var{n} is non-@code{nil}, the @var{n}th-to-last link is "
"returned instead, or the whole of @var{list} if @var{n} is bigger than "
"@var{list}'s length."
msgstr ""

#. type: defun
#: original_texis/lists.texi:392
#, no-wrap
msgid "safe-length list"
msgstr ""

#. type: anchor{#1}
#: original_texis/lists.texi:398
msgid "Definition of safe-length"
msgstr ""

#. type: defun
#: original_texis/lists.texi:398
msgid ""
"This function returns the length of @var{list}, with no risk of either an "
"error or an infinite loop.  It generally returns the number of distinct cons "
"cells in the list.  However, for circular lists, the value is just an upper "
"bound; it is often too large."
msgstr ""

#. type: defun
#: original_texis/lists.texi:401
msgid ""
"If @var{list} is not @code{nil} or a cons cell, @code{safe-length} returns "
"0."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:406
msgid ""
"The most common way to compute the length of a list, when you are not "
"worried that it may be circular, is with @code{length}.  @xref{Sequence "
"Functions}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:407
#, no-wrap
msgid "caar cons-cell"
msgstr ""

#. type: defun
#: original_texis/lists.texi:409
msgid "This is the same as @code{(car (car @var{cons-cell}))}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:411
#, no-wrap
msgid "cadr cons-cell"
msgstr ""

#. type: defun
#: original_texis/lists.texi:414
msgid ""
"This is the same as @code{(car (cdr @var{cons-cell}))} or @code{(nth 1 "
"@var{cons-cell})}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:416
#, no-wrap
msgid "cdar cons-cell"
msgstr ""

#. type: defun
#: original_texis/lists.texi:418
msgid "This is the same as @code{(cdr (car @var{cons-cell}))}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:420
#, no-wrap
msgid "cddr cons-cell"
msgstr ""

#. type: defun
#: original_texis/lists.texi:423
msgid ""
"This is the same as @code{(cdr (cdr @var{cons-cell}))} or @code{(nthcdr 2 "
"@var{cons-cell})}."
msgstr ""

#. type: findex
#: original_texis/lists.texi:425
#, no-wrap
msgid "caaar"
msgstr ""

#. type: findex
#: original_texis/lists.texi:426
#, no-wrap
msgid "caadr"
msgstr ""

#. type: findex
#: original_texis/lists.texi:427
#, no-wrap
msgid "cadar"
msgstr ""

#. type: findex
#: original_texis/lists.texi:428
#, no-wrap
msgid "caddr"
msgstr ""

#. type: findex
#: original_texis/lists.texi:429
#, no-wrap
msgid "cdaar"
msgstr ""

#. type: findex
#: original_texis/lists.texi:430
#, no-wrap
msgid "cdadr"
msgstr ""

#. type: findex
#: original_texis/lists.texi:431
#, no-wrap
msgid "cddar"
msgstr ""

#. type: findex
#: original_texis/lists.texi:432
#, no-wrap
msgid "cdddr"
msgstr ""

#. type: findex
#: original_texis/lists.texi:433
#, no-wrap
msgid "caaaar"
msgstr ""

#. type: findex
#: original_texis/lists.texi:434
#, no-wrap
msgid "caaadr"
msgstr ""

#. type: findex
#: original_texis/lists.texi:435
#, no-wrap
msgid "caadar"
msgstr ""

#. type: findex
#: original_texis/lists.texi:436
#, no-wrap
msgid "caaddr"
msgstr ""

#. type: findex
#: original_texis/lists.texi:437
#, no-wrap
msgid "cadaar"
msgstr ""

#. type: findex
#: original_texis/lists.texi:438
#, no-wrap
msgid "cadadr"
msgstr ""

#. type: findex
#: original_texis/lists.texi:439
#, no-wrap
msgid "caddar"
msgstr ""

#. type: findex
#: original_texis/lists.texi:440
#, no-wrap
msgid "cadddr"
msgstr ""

#. type: findex
#: original_texis/lists.texi:441
#, no-wrap
msgid "cdaaar"
msgstr ""

#. type: findex
#: original_texis/lists.texi:442
#, no-wrap
msgid "cdaadr"
msgstr ""

#. type: findex
#: original_texis/lists.texi:443
#, no-wrap
msgid "cdadar"
msgstr ""

#. type: findex
#: original_texis/lists.texi:444
#, no-wrap
msgid "cdaddr"
msgstr ""

#. type: findex
#: original_texis/lists.texi:445
#, no-wrap
msgid "cddaar"
msgstr ""

#. type: findex
#: original_texis/lists.texi:446
#, no-wrap
msgid "cddadr"
msgstr ""

#. type: findex
#: original_texis/lists.texi:447
#, no-wrap
msgid "cdddar"
msgstr ""

#. type: findex
#: original_texis/lists.texi:448
#, no-wrap
msgid "cddddr"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:457
msgid ""
"In addition to the above, 24 additional compositions of @code{car} and "
"@code{cdr} are defined as @code{c@var{xxx}r} and @code{c@var{xxxx}r}, where "
"each @code{@var{x}} is either @code{a} or @code{d}.  @code{cadr}, "
"@code{caddr}, and @code{cadddr} pick out the second, third or fourth "
"elements of a list, respectively.  @file{cl-lib} provides the same under the "
"names @code{cl-second}, @code{cl-third}, and @code{cl-fourth}.  @xref{List "
"Functions,,, cl, Common Lisp Extensions}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:458
#, no-wrap
msgid "butlast x &optional n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:464
msgid ""
"This function returns the list @var{x} with the last element, or the last "
"@var{n} elements, removed.  If @var{n} is greater than zero it makes a copy "
"of the list so as not to damage the original list.  In general, "
"@code{(append (butlast @var{x} @var{n})  (last @var{x} @var{n}))} will "
"return a list equal to @var{x}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:466
#, no-wrap
msgid "nbutlast x &optional n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:470
msgid ""
"This is a version of @code{butlast} that works by destructively modifying "
"the @code{cdr} of the appropriate element, rather than making a copy of the "
"list."
msgstr ""

#. type: section
#: original_texis/lists.texi:473
#, no-wrap
msgid "Building Cons Cells and Lists"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:474
#, no-wrap
msgid "cons cells"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:475
#, no-wrap
msgid "building lists"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:481
msgid ""
"Many functions build lists, as lists reside at the very heart of Lisp.  "
"@code{cons} is the fundamental list-building function; however, it is "
"interesting to note that @code{list} is used more times in the source code "
"for Emacs than @code{cons}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:482
#, no-wrap
msgid "cons object1 object2"
msgstr ""

#. type: defun
#: original_texis/lists.texi:488
msgid ""
"This function is the most basic function for building new list structure.  "
"It creates a new cons cell, making @var{object1} the @sc{car}, and "
"@var{object2} the @sc{cdr}.  It then returns the new cons cell.  The "
"arguments @var{object1} and @var{object2} may be any Lisp objects, but most "
"often @var{object2} is a list."
msgstr ""

#. type: group
#: original_texis/lists.texi:493
#, no-wrap
msgid ""
"(cons 1 '(2))\n"
"     @result{} (1 2)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:497
#, no-wrap
msgid ""
"(cons 1 '())\n"
"     @result{} (1)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:501
#, no-wrap
msgid ""
"(cons 1 2)\n"
"     @result{} (1 . 2)\n"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:504
#, no-wrap
msgid "consing"
msgstr ""

#. type: defun
#: original_texis/lists.texi:516
msgid ""
"@code{cons} is often used to add a single element to the front of a list.  "
"This is called @dfn{consing the element onto the list}.  @footnote{There is "
"no strictly equivalent way to add an element to the end of a list.  You can "
"use @code{(append @var{listname} (list @var{newelt}))}, which creates a "
"whole new list by copying @var{listname} and adding @var{newelt} to its "
"end.  Or you can use @code{(nconc @var{listname} (list @var{newelt}))}, "
"which modifies @var{listname} by following all the @sc{cdr}s and then "
"replacing the terminating @code{nil}.  Compare this to adding an element to "
"the beginning of a list with @code{cons}, which neither copies nor modifies "
"the list.} For example:"
msgstr ""

#. type: example
#: original_texis/lists.texi:519
#, no-wrap
msgid "(setq list (cons newelt list))\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:524
msgid ""
"Note that there is no conflict between the variable named @code{list} used "
"in this example and the function named @code{list} described below; any "
"symbol can serve both purposes."
msgstr ""

#. type: defun
#: original_texis/lists.texi:526
#, no-wrap
msgid "list &rest objects"
msgstr ""

#. type: defun
#: original_texis/lists.texi:530
msgid ""
"This function creates a list with @var{objects} as its elements.  The "
"resulting list is always @code{nil}-terminated.  If no @var{objects} are "
"given, the empty list is returned."
msgstr ""

#. type: group
#: original_texis/lists.texi:535
#, no-wrap
msgid ""
"(list 1 2 3 4 5)\n"
"     @result{} (1 2 3 4 5)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:539
#, no-wrap
msgid ""
"(list 1 2 '(3 4 5) 'foo)\n"
"     @result{} (1 2 (3 4 5) foo)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:543
#, no-wrap
msgid ""
"(list)\n"
"     @result{} nil\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:547
#, no-wrap
msgid "make-list length object"
msgstr ""

#. type: defun
#: original_texis/lists.texi:551
msgid ""
"This function creates a list of @var{length} elements, in which each element "
"is @var{object}.  Compare @code{make-list} with @code{make-string} "
"(@pxref{Creating Strings})."
msgstr ""

#. type: group
#: original_texis/lists.texi:556
#, no-wrap
msgid ""
"(make-list 3 'pigs)\n"
"     @result{} (pigs pigs pigs)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:560
#, no-wrap
msgid ""
"(make-list 0 'pigs)\n"
"     @result{} nil\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:566
#, no-wrap
msgid ""
"(setq l (make-list 3 '(a b)))\n"
"     @result{} ((a b) (a b) (a b))\n"
"(eq (car l) (cadr l))\n"
"     @result{} t\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:570
#, no-wrap
msgid "append &rest sequences"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:571
#, no-wrap
msgid "copying lists"
msgstr ""

#. type: defun
#: original_texis/lists.texi:578
msgid ""
"This function returns a list containing all the elements of "
"@var{sequences}.  The @var{sequences} may be lists, vectors, bool-vectors, "
"or strings, but the last one should usually be a list.  All arguments except "
"the last one are copied, so none of the arguments is altered.  (See "
"@code{nconc} in @ref{Rearrangement}, for a way to join lists with no "
"copying.)"
msgstr ""

#. type: defun
#: original_texis/lists.texi:586
msgid ""
"More generally, the final argument to @code{append} may be any Lisp object.  "
"The final argument is not copied or converted; it becomes the @sc{cdr} of "
"the last cons cell in the new list.  If the final argument is itself a list, "
"then its elements become in effect elements of the result list.  If the "
"final element is not a list, the result is a dotted list since its final "
"@sc{cdr} is not @code{nil} as required in a proper list (@pxref{Cons "
"Cells})."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:589
msgid "Here is an example of using @code{append}:"
msgstr ""

#. type: group
#: original_texis/lists.texi:596
#, no-wrap
msgid ""
"(setq trees '(pine oak))\n"
"     @result{} (pine oak)\n"
"(setq more-trees (append '(maple birch) trees))\n"
"     @result{} (maple birch pine oak)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:603
#, no-wrap
msgid ""
"trees\n"
"     @result{} (pine oak)\n"
"more-trees\n"
"     @result{} (maple birch pine oak)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:607
#, no-wrap
msgid ""
"(eq trees (cdr (cdr more-trees)))\n"
"     @result{} t\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:615
msgid ""
"You can see how @code{append} works by looking at a box diagram.  The "
"variable @code{trees} is set to the list @code{(pine oak)} and then the "
"variable @code{more-trees} is set to the list @code{(maple birch pine "
"oak)}.  However, the variable @code{trees} continues to refer to the "
"original list:"
msgstr ""

#. type: group
#: original_texis/lists.texi:626
#, no-wrap
msgid ""
"more-trees                trees\n"
"|                           |\n"
"|     --- ---      --- ---   -> --- ---      --- ---\n"
" --> |   |   |--> |   |   |--> |   |   |--> |   |   |--> nil\n"
"      --- ---      --- ---      --- ---      --- ---\n"
"       |            |            |            |\n"
"       |            |            |            |\n"
"        --> maple    -->birch     --> pine     --> oak\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:632
msgid ""
"An empty sequence contributes nothing to the value returned by "
"@code{append}.  As a consequence of this, a final @code{nil} argument forces "
"a copy of the previous argument:"
msgstr ""

#. type: group
#: original_texis/lists.texi:637
#, no-wrap
msgid ""
"trees\n"
"     @result{} (pine oak)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:641
#, no-wrap
msgid ""
"(setq wood (append trees nil))\n"
"     @result{} (pine oak)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:645
#, no-wrap
msgid ""
"wood\n"
"     @result{} (pine oak)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:649
#, no-wrap
msgid ""
"(eq wood trees)\n"
"     @result{} nil\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:655
msgid ""
"This once was the usual way to copy a list, before the function "
"@code{copy-sequence} was invented.  @xref{Sequences Arrays Vectors}."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:657
msgid "Here we show the use of vectors and strings as arguments to @code{append}:"
msgstr ""

#. type: group
#: original_texis/lists.texi:662
#, no-wrap
msgid ""
"(append [a b] \"cd\" nil)\n"
"     @result{} (a b 99 100)\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:667
msgid ""
"With the help of @code{apply} (@pxref{Calling Functions}), we can append all "
"the lists in a list of lists:"
msgstr ""

#. type: group
#: original_texis/lists.texi:672
#, no-wrap
msgid ""
"(apply 'append '((a b c) nil (x y z) nil))\n"
"     @result{} (a b c x y z)\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:676
msgid "If no @var{sequences} are given, @code{nil} is returned:"
msgstr ""

#. type: group
#: original_texis/lists.texi:681
#, no-wrap
msgid ""
"(append)\n"
"     @result{} nil\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:685
msgid "Here are some examples where the final argument is not a list:"
msgstr ""

#. type: example
#: original_texis/lists.texi:691
#, no-wrap
msgid ""
"(append '(x y) 'z)\n"
"     @result{} (x y . z)\n"
"(append '(x y) [z])\n"
"     @result{} (x y . [z])\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:698
msgid ""
"The second example shows that when the final argument is a sequence but not "
"a list, the sequence's elements do not become elements of the resulting "
"list.  Instead, the sequence becomes the final @sc{cdr}, like any other "
"non-list final argument."
msgstr ""

#. type: defun
#: original_texis/lists.texi:699
#, no-wrap
msgid "copy-tree tree &optional vecp"
msgstr ""

#. type: defun
#: original_texis/lists.texi:704
msgid ""
"This function returns a copy of the tree @var{tree}.  If @var{tree} is a "
"cons cell, this makes a new cons cell with the same @sc{car} and @sc{cdr}, "
"then recursively copies the @sc{car} and @sc{cdr} in the same way."
msgstr ""

#. type: defun
#: original_texis/lists.texi:709
msgid ""
"Normally, when @var{tree} is anything other than a cons cell, "
"@code{copy-tree} simply returns @var{tree}.  However, if @var{vecp} is "
"non-@code{nil}, it copies vectors too (and operates recursively on their "
"elements)."
msgstr ""

#. type: defun
#: original_texis/lists.texi:711
#, no-wrap
msgid "flatten-tree tree"
msgstr ""

#. type: defun
#: original_texis/lists.texi:716
msgid ""
"This function returns a ``flattened'' copy of @var{tree}, that is, a list "
"containing all the non-@code{nil} terminal nodes, or leaves, of the tree of "
"cons cells rooted at @var{tree}.  Leaves in the returned list are in the "
"same order as in @var{tree}."
msgstr ""

#. type: example
#: original_texis/lists.texi:721
#, no-wrap
msgid ""
"(flatten-tree '(1 (2 . 3) nil (4 5 (6)) 7))\n"
"    @result{}(1 2 3 4 5 6 7)\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:723
#, no-wrap
msgid "ensure-list object"
msgstr ""

#. type: defun
#: original_texis/lists.texi:727
msgid ""
"This function returns @var{object} as a list.  If @var{object} is already a "
"list, the function returns it; otherwise, the function returns a one-element "
"list containing @var{object}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:730
msgid ""
"This is usually useful if you have a variable that may or may not be a list, "
"and you can then say, for instance:"
msgstr ""

#. type: lisp
#: original_texis/lists.texi:734
#, no-wrap
msgid ""
"(dolist (elem (ensure-list foo))\n"
"  (princ elem))\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:737
#, no-wrap
msgid "number-sequence from &optional to separation"
msgstr ""

#. type: defun
#: original_texis/lists.texi:746
msgid ""
"This function returns a list of numbers starting with @var{from} and "
"incrementing by @var{separation}, and ending at or just before @var{to}.  "
"@var{separation} can be positive or negative and defaults to 1.  If @var{to} "
"is @code{nil} or numerically equal to @var{from}, the value is the "
"one-element list @code{(@var{from})}.  If @var{to} is less than @var{from} "
"with a positive @var{separation}, or greater than @var{from} with a negative "
"@var{separation}, the value is @code{nil} because those arguments specify an "
"empty sequence."
msgstr ""

#. type: defun
#: original_texis/lists.texi:750
msgid ""
"If @var{separation} is 0 and @var{to} is neither @code{nil} nor numerically "
"equal to @var{from}, @code{number-sequence} signals an error, since those "
"arguments specify an infinite sequence."
msgstr ""

#. type: defun
#: original_texis/lists.texi:763
msgid ""
"All arguments are numbers.  Floating-point arguments can be tricky, because "
"floating-point arithmetic is inexact.  For instance, depending on the "
"machine, it may quite well happen that @code{(number-sequence 0.4 0.6 0.2)} "
"returns the one element list @code{(0.4)}, whereas @code{(number-sequence "
"0.4 0.8 0.2)} returns a list with three elements.  The @var{n}th element of "
"the list is computed by the exact formula @code{(+ @var{from} (* @var{n} "
"@var{separation}))}.  Thus, if one wants to make sure that @var{to} is "
"included in the list, one can pass an expression of this exact type for "
"@var{to}.  Alternatively, one can replace @var{to} with a slightly larger "
"value (or a slightly more negative value if @var{separation} is negative)."
msgstr ""

#. type: defun
#: original_texis/lists.texi:765
msgid "Some examples:"
msgstr ""

#. type: example
#: original_texis/lists.texi:781
#, no-wrap
msgid ""
"(number-sequence 4 9)\n"
"     @result{} (4 5 6 7 8 9)\n"
"(number-sequence 9 4 -1)\n"
"     @result{} (9 8 7 6 5 4)\n"
"(number-sequence 9 4 -2)\n"
"     @result{} (9 7 5)\n"
"(number-sequence 8)\n"
"     @result{} (8)\n"
"(number-sequence 8 5)\n"
"     @result{} nil\n"
"(number-sequence 5 8 -1)\n"
"     @result{} nil\n"
"(number-sequence 1.5 6 2)\n"
"     @result{} (1.5 3.5 5.5)\n"
msgstr ""

#. type: section
#: original_texis/lists.texi:785
#, no-wrap
msgid "Modifying List Variables"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:786
#, no-wrap
msgid "modify a list"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:787
#, no-wrap
msgid "list modification"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:791
msgid ""
"These functions, and one macro, provide convenient ways to modify a list "
"which is stored in a variable."
msgstr ""

#. type: defmac
#: original_texis/lists.texi:792
#, no-wrap
msgid "push element listname"
msgstr ""

#. type: defmac
#: original_texis/lists.texi:798
msgid ""
"This macro creates a new list whose @sc{car} is @var{element} and whose "
"@sc{cdr} is the list specified by @var{listname}, and saves that list in "
"@var{listname}.  In the simplest case, @var{listname} is an unquoted symbol "
"naming a list, and this macro is equivalent to @w{@code{(setq @var{listname} "
"(cons @var{element} @var{listname}))}}."
msgstr ""

#. type: example
#: original_texis/lists.texi:806
#, no-wrap
msgid ""
"(setq l '(a b))\n"
"     @result{} (a b)\n"
"(push 'c l)\n"
"     @result{} (c a b)\n"
"l\n"
"     @result{} (c a b)\n"
msgstr ""

#. type: defmac
#: original_texis/lists.texi:812
msgid ""
"More generally, @code{listname} can be a generalized variable.  In that "
"case, this macro does the equivalent of @w{@code{(setf @var{listname} (cons "
"@var{element} @var{listname}))}}.  @xref{Generalized Variables}."
msgstr ""

#. type: defmac
#: original_texis/lists.texi:815
msgid ""
"For the @code{pop} macro, which removes the first element from a list, "
"@xref{List Elements}."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:818
msgid "Two functions modify lists that are the values of variables."
msgstr ""

#. type: defun
#: original_texis/lists.texi:819
#, no-wrap
msgid "add-to-list symbol element &optional append compare-fn"
msgstr ""

#. type: defun
#: original_texis/lists.texi:827
msgid ""
"This function sets the variable @var{symbol} by consing @var{element} onto "
"the old value, if @var{element} is not already a member of that value.  It "
"returns the resulting list, whether updated or not.  The value of "
"@var{symbol} had better be a list already before the call.  "
"@code{add-to-list} uses @var{compare-fn} to compare @var{element} against "
"existing list members; if @var{compare-fn} is @code{nil}, it uses "
"@code{equal}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:831
msgid ""
"Normally, if @var{element} is added, it is added to the front of "
"@var{symbol}, but if the optional argument @var{append} is non-@code{nil}, "
"it is added at the end."
msgstr ""

#. type: defun
#: original_texis/lists.texi:835
msgid ""
"The argument @var{symbol} is not implicitly quoted; @code{add-to-list} is an "
"ordinary function, like @code{set} and unlike @code{setq}.  Quote the "
"argument yourself if that is what you want."
msgstr ""

#. type: defun
#: original_texis/lists.texi:838
msgid "Do not use this function when @var{symbol} refers to a lexical variable."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:841
msgid "Here's a scenario showing how to use @code{add-to-list}:"
msgstr ""

#. type: example
#: original_texis/lists.texi:845
#, no-wrap
msgid ""
"(setq foo '(a b))\n"
"     @result{} (a b)\n"
"\n"
msgstr ""

#. type: example
#: original_texis/lists.texi:848
#, no-wrap
msgid ""
"(add-to-list 'foo 'c)     ;; @r{Add @code{c}.}\n"
"     @result{} (c a b)\n"
"\n"
msgstr ""

#. type: example
#: original_texis/lists.texi:851
#, no-wrap
msgid ""
"(add-to-list 'foo 'b)     ;; @r{No effect.}\n"
"     @result{} (c a b)\n"
"\n"
msgstr ""

#. type: example
#: original_texis/lists.texi:854
#, no-wrap
msgid ""
"foo                       ;; @r{@code{foo} was changed.}\n"
"     @result{} (c a b)\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:858
msgid ""
"An equivalent expression for @code{(add-to-list '@var{var} @var{value})} is "
"this:"
msgstr ""

#. type: example
#: original_texis/lists.texi:863
#, no-wrap
msgid ""
"(if (member @var{value} @var{var})\n"
"    @var{var}\n"
"  (setq @var{var} (cons @var{value} @var{var})))\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:865
#, no-wrap
msgid "add-to-ordered-list symbol element &optional order"
msgstr ""

#. type: defun
#: original_texis/lists.texi:872
msgid ""
"This function sets the variable @var{symbol} by inserting @var{element} into "
"the old value, which must be a list, at the position specified by "
"@var{order}.  If @var{element} is already a member of the list, its position "
"in the list is adjusted according to @var{order}.  Membership is tested "
"using @code{eq}.  This function returns the resulting list, whether updated "
"or not."
msgstr ""

#. type: defun
#: original_texis/lists.texi:875
msgid ""
"The @var{order} is typically a number (integer or float), and the elements "
"of the list are sorted in non-decreasing numerical order."
msgstr ""

#. type: defun
#: original_texis/lists.texi:880
msgid ""
"@var{order} may also be omitted or @code{nil}.  Then the numeric order of "
"@var{element} stays unchanged if it already has one; otherwise, "
"@var{element} has no numeric order.  Elements without a numeric list order "
"are placed at the end of the list, in no particular order."
msgstr ""

#. type: defun
#: original_texis/lists.texi:883
msgid ""
"Any other value for @var{order} removes the numeric order of @var{element} "
"if it already has one; otherwise, it is equivalent to @code{nil}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:887
msgid ""
"The argument @var{symbol} is not implicitly quoted; "
"@code{add-to-ordered-list} is an ordinary function, like @code{set} and "
"unlike @code{setq}.  Quote the argument yourself if necessary."
msgstr ""

#. type: defun
#: original_texis/lists.texi:891
msgid ""
"The ordering information is stored in a hash table on @var{symbol}'s "
"@code{list-order} property.  @var{symbol} cannot refer to a lexical "
"variable."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:894
msgid "Here's a scenario showing how to use @code{add-to-ordered-list}:"
msgstr ""

#. type: example
#: original_texis/lists.texi:898
#, no-wrap
msgid ""
"(setq foo '())\n"
"     @result{} nil\n"
"\n"
msgstr ""

#. type: example
#: original_texis/lists.texi:901
#, no-wrap
msgid ""
"(add-to-ordered-list 'foo 'a 1)     ;; @r{Add @code{a}.}\n"
"     @result{} (a)\n"
"\n"
msgstr ""

#. type: example
#: original_texis/lists.texi:904
#, no-wrap
msgid ""
"(add-to-ordered-list 'foo 'c 3)     ;; @r{Add @code{c}.}\n"
"     @result{} (a c)\n"
"\n"
msgstr ""

#. type: example
#: original_texis/lists.texi:907
#, no-wrap
msgid ""
"(add-to-ordered-list 'foo 'b 2)     ;; @r{Add @code{b}.}\n"
"     @result{} (a b c)\n"
"\n"
msgstr ""

#. type: example
#: original_texis/lists.texi:910
#, no-wrap
msgid ""
"(add-to-ordered-list 'foo 'b 4)     ;; @r{Move @code{b}.}\n"
"     @result{} (a c b)\n"
"\n"
msgstr ""

#. type: example
#: original_texis/lists.texi:913
#, no-wrap
msgid ""
"(add-to-ordered-list 'foo 'd)       ;; @r{Append @code{d}.}\n"
"     @result{} (a c b d)\n"
"\n"
msgstr ""

#. type: example
#: original_texis/lists.texi:916
#, no-wrap
msgid ""
"(add-to-ordered-list 'foo 'e)       ;; @r{Add @code{e}}.\n"
"     @result{} (a c b e d)\n"
"\n"
msgstr ""

#. type: example
#: original_texis/lists.texi:919
#, no-wrap
msgid ""
"foo                       ;; @r{@code{foo} was changed.}\n"
"     @result{} (a c b e d)\n"
msgstr ""

#. type: section
#: original_texis/lists.texi:922
#, no-wrap
msgid "Modifying Existing List Structure"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:923
#, no-wrap
msgid "destructive list operations"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:924
#, no-wrap
msgid "mutable lists"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:933
msgid ""
"You can modify the @sc{car} and @sc{cdr} contents of a cons cell with the "
"primitives @code{setcar} and @code{setcdr}.  These are destructive "
"operations because they change existing list structure.  Destructive "
"operations should be applied only to mutable lists, that is, lists "
"constructed via @code{cons}, @code{list} or similar operations.  Lists "
"created by quoting are part of the program and should not be changed by "
"destructive operations.  @xref{Mutability}."
msgstr ""

#. type: cindex
#: original_texis/lists.texi:934
#, no-wrap
msgid "CL note---@code{rplaca} vs @code{setcar}"
msgstr ""

#. type: findex
#: original_texis/lists.texi:936
#, no-wrap
msgid "rplaca"
msgstr ""

#. type: findex
#: original_texis/lists.texi:937
#, no-wrap
msgid "rplacd"
msgstr ""

#. type: quotation
#: original_texis/lists.texi:943
msgid ""
"@b{Common Lisp note:} Common Lisp uses functions @code{rplaca} and "
"@code{rplacd} to alter list structure; they change structure the same way as "
"@code{setcar} and @code{setcdr}, but the Common Lisp functions return the "
"cons cell while @code{setcar} and @code{setcdr} return the new @sc{car} or "
"@sc{cdr}."
msgstr ""

#. type: node
#: original_texis/lists.texi:950 original_texis/lists.texi:952
#, no-wrap
msgid "Setcar"
msgstr ""

#. type: menuentry
#: original_texis/lists.texi:950
msgid "Replacing an element in a list."
msgstr ""

#. type: node
#: original_texis/lists.texi:950 original_texis/lists.texi:1059
#, no-wrap
msgid "Setcdr"
msgstr ""

#. type: menuentry
#: original_texis/lists.texi:950
msgid ""
"Replacing part of the list backbone.  This can be used to remove or add "
"elements."
msgstr ""

#. type: node
#: original_texis/lists.texi:950 original_texis/lists.texi:1161
#, no-wrap
msgid "Rearrangement"
msgstr ""

#. type: menuentry
#: original_texis/lists.texi:950
msgid "Reordering the elements in a list; combining lists."
msgstr ""

#. type: subsection
#: original_texis/lists.texi:953
#, no-wrap
msgid "Altering List Elements with @code{setcar}"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:954
#, no-wrap
msgid "replace list element"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:955
#, no-wrap
msgid "list, replace element"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:960
msgid ""
"Changing the @sc{car} of a cons cell is done with @code{setcar}.  When used "
"on a list, @code{setcar} replaces one element of a list with a different "
"element."
msgstr ""

#. type: defun
#: original_texis/lists.texi:961
#, no-wrap
msgid "setcar cons object"
msgstr ""

#. type: defun
#: original_texis/lists.texi:966
msgid ""
"This function stores @var{object} as the new @sc{car} of @var{cons}, "
"replacing its previous @sc{car}.  In other words, it changes the @sc{car} "
"slot of @var{cons} to refer to @var{object}.  It returns the value "
"@var{object}.  For example:"
msgstr ""

#. type: group
#: original_texis/lists.texi:971
#, no-wrap
msgid ""
"(setq x (list 1 2))\n"
"     @result{} (1 2)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:975
#, no-wrap
msgid ""
"(setcar x 4)\n"
"     @result{} 4\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:979
#, no-wrap
msgid ""
"x\n"
"     @result{} (4 2)\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:986
msgid ""
"When a cons cell is part of the shared structure of several lists, storing a "
"new @sc{car} into the cons changes one element of each of these lists.  Here "
"is an example:"
msgstr ""

#. type: group
#: original_texis/lists.texi:994
#, no-wrap
msgid ""
";; @r{Create two lists that are partly shared.}\n"
"(setq x1 (list 'a 'b 'c))\n"
"     @result{} (a b c)\n"
"(setq x2 (cons 'z (cdr x1)))\n"
"     @result{} (z b c)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1004
#, no-wrap
msgid ""
";; @r{Replace the @sc{car} of a shared link.}\n"
"(setcar (cdr x1) 'foo)\n"
"     @result{} foo\n"
"x1                           ; @r{Both lists are changed.}\n"
"     @result{} (a foo c)\n"
"x2\n"
"     @result{} (z foo c)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1014
#, no-wrap
msgid ""
";; @r{Replace the @sc{car} of a link that is not shared.}\n"
"(setcar x1 'baz)\n"
"     @result{} baz\n"
"x1                           ; @r{Only one list is changed.}\n"
"     @result{} (baz foo c)\n"
"x2\n"
"     @result{} (z foo c)\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1020
msgid ""
"Here is a graphical depiction of the shared structure of the two lists in "
"the variables @code{x1} and @code{x2}, showing why replacing @code{b} "
"changes them both:"
msgstr ""

#. type: group
#: original_texis/lists.texi:1036
#, no-wrap
msgid ""
"        --- ---        --- ---      --- ---\n"
"x1---> |   |   |----> |   |   |--> |   |   |--> nil\n"
"        --- ---        --- ---      --- ---\n"
"         |        -->   |            |\n"
"         |       |      |            |\n"
"          --> a  |       --> b        --> c\n"
"                 |\n"
"       --- ---   |\n"
"x2--> |   |   |--\n"
"       --- ---\n"
"        |\n"
"        |\n"
"         --> z\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1040
msgid "Here is an alternative form of box diagram, showing the same relationship:"
msgstr ""

#. type: group
#: original_texis/lists.texi:1056
#, no-wrap
msgid ""
"x1:\n"
" --------------       --------------       --------------\n"
"| car   | cdr  |     | car   | cdr  |     | car   | cdr  |\n"
"|   a   |   o------->|   b   |   o------->|   c   |  nil |\n"
"|       |      |  -->|       |      |     |       |      |\n"
" --------------  |    --------------       --------------\n"
"                 |\n"
"x2:              |\n"
" --------------  |\n"
"| car   | cdr  | |\n"
"|   z   |   o----\n"
"|       |      |\n"
" --------------\n"
msgstr ""

#. type: subsection
#: original_texis/lists.texi:1060
#, no-wrap
msgid "Altering the CDR of a List"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1061
#, no-wrap
msgid "replace part of list"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1064
msgid "The lowest-level primitive for modifying a @sc{cdr} is @code{setcdr}:"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1065
#, no-wrap
msgid "setcdr cons object"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1070
msgid ""
"This function stores @var{object} as the new @sc{cdr} of @var{cons}, "
"replacing its previous @sc{cdr}.  In other words, it changes the @sc{cdr} "
"slot of @var{cons} to refer to @var{object}.  It returns the value "
"@var{object}."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1077
msgid ""
"Here is an example of replacing the @sc{cdr} of a list with a different "
"list.  All but the first element of the list are removed in favor of a "
"different sequence of elements.  The first element is unchanged, because it "
"resides in the @sc{car} of the list, and is not reached via the @sc{cdr}."
msgstr ""

#. type: group
#: original_texis/lists.texi:1082 original_texis/lists.texi:1195
#: original_texis/lists.texi:1215
#, no-wrap
msgid ""
"(setq x (list 1 2 3))\n"
"     @result{} (1 2 3)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1086
#, no-wrap
msgid ""
"(setcdr x '(4))\n"
"     @result{} (4)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1090
#, no-wrap
msgid ""
"x\n"
"     @result{} (1 4)\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1097
msgid ""
"You can delete elements from the middle of a list by altering the @sc{cdr}s "
"of the cons cells in the list.  For example, here we delete the second "
"element, @code{b}, from the list @code{(a b c)}, by changing the @sc{cdr} of "
"the first cons cell:"
msgstr ""

#. type: group
#: original_texis/lists.texi:1106
#, no-wrap
msgid ""
"(setq x1 (list 'a 'b 'c))\n"
"     @result{} (a b c)\n"
"(setcdr x1 (cdr (cdr x1)))\n"
"     @result{} (c)\n"
"x1\n"
"     @result{} (a c)\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1110
msgid "Here is the result in box notation:"
msgstr ""

#. type: group
#: original_texis/lists.texi:1120
#, no-wrap
msgid ""
"                   --------------------\n"
"                  |                    |\n"
" --------------   |   --------------   |    --------------\n"
"| car   | cdr  |  |  | car   | cdr  |   -->| car   | cdr  |\n"
"|   a   |   o-----   |   b   |   o-------->|   c   |  nil |\n"
"|       |      |     |       |      |      |       |      |\n"
" --------------       --------------        --------------\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1127
msgid ""
"The second cons cell, which previously held the element @code{b}, still "
"exists and its @sc{car} is still @code{b}, but it no longer forms part of "
"this list."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1129
msgid "It is equally easy to insert a new element by changing @sc{cdr}s:"
msgstr ""

#. type: group
#: original_texis/lists.texi:1138
#, no-wrap
msgid ""
"(setq x1 (list 'a 'b 'c))\n"
"     @result{} (a b c)\n"
"(setcdr x1 (cons 'd (cdr x1)))\n"
"     @result{} (d b c)\n"
"x1\n"
"     @result{} (a d b c)\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1142
msgid "Here is this result in box notation:"
msgstr ""

#. type: group
#: original_texis/lists.texi:1158
#, no-wrap
msgid ""
" --------------        -------------       -------------\n"
"| car  | cdr   |      | car  | cdr  |     | car  | cdr  |\n"
"|   a  |   o   |   -->|   b  |   o------->|   c  |  nil |\n"
"|      |   |   |  |   |      |      |     |      |      |\n"
" --------- | --   |    -------------       -------------\n"
"           |      |\n"
"     -----         --------\n"
"    |                      |\n"
"    |    ---------------   |\n"
"    |   | car   | cdr   |  |\n"
"     -->|   d   |   o------\n"
"        |       |       |\n"
"         ---------------\n"
msgstr ""

#. type: subsection
#: original_texis/lists.texi:1162
#, no-wrap
msgid "Functions that Rearrange Lists"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1163
#, no-wrap
msgid "rearrangement of lists"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1164
#, no-wrap
msgid "reordering, of elements in lists"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1165
#, no-wrap
msgid "modification of lists"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1172
msgid ""
"Here are some functions that rearrange lists destructively by modifying the "
"@sc{cdr}s of their component cons cells.  These functions are destructive "
"because they chew up the original lists passed to them as arguments, "
"relinking their cons cells to form a new list that is the returned value."
msgstr ""

#. type: ifnottex
#: original_texis/lists.texi:1176
msgid ""
"See @code{delq}, in @ref{Sets And Lists}, for another function that modifies "
"cons cells."
msgstr ""

#. type: iftex
#: original_texis/lists.texi:1180
msgid ""
"The function @code{delq} in the following section is another example of "
"destructive list manipulation."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1182
#, no-wrap
msgid "nconc &rest lists"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1183
#, no-wrap
msgid "concatenating lists"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1184
#, no-wrap
msgid "joining lists"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1190
msgid ""
"This function returns a list containing all the elements of @var{lists}.  "
"Unlike @code{append} (@pxref{Building Lists}), the @var{lists} are "
"@emph{not} copied.  Instead, the last @sc{cdr} of each of the @var{lists} is "
"changed to refer to the following list.  The last of the @var{lists} is not "
"altered.  For example:"
msgstr ""

#. type: group
#: original_texis/lists.texi:1199
#, no-wrap
msgid ""
"(nconc x '(4 5))\n"
"     @result{} (1 2 3 4 5)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1203
#, no-wrap
msgid ""
"x\n"
"     @result{} (1 2 3 4 5)\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1210
msgid ""
"Since the last argument of @code{nconc} is not itself modified, it is "
"reasonable to use a constant list, such as @code{'(4 5)}, as in the above "
"example.  For the same reason, the last argument need not be a list:"
msgstr ""

#. type: group
#: original_texis/lists.texi:1219
#, no-wrap
msgid ""
"(nconc x 'z)\n"
"     @result{} (1 2 3 . z)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1223
#, no-wrap
msgid ""
"x\n"
"     @result{} (1 2 3 . z)\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1228
msgid "However, the other arguments (all but the last) should be mutable lists."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1234
msgid ""
"A common pitfall is to use a constant list as a non-last argument to "
"@code{nconc}.  If you do this, the resulting behavior is undefined "
"(@pxref{Self-Evaluating Forms}).  It is possible that your program will "
"change each time you run it! Here is what might happen (though this is not "
"guaranteed to happen):"
msgstr ""

#. type: group
#: original_texis/lists.texi:1239
#, no-wrap
msgid ""
"(defun add-foo (x)            ; @r{We want this function to add}\n"
"  (nconc '(foo) x))           ;   @r{@code{foo} to the front of its arg.}\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1244
#, no-wrap
msgid ""
"(symbol-function 'add-foo)\n"
"     @result{} (lambda (x) (nconc '(foo) x))\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1249
#, no-wrap
msgid ""
"(setq xx (add-foo '(1 2)))    ; @r{It seems to work.}\n"
"     @result{} (foo 1 2)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1253
#, no-wrap
msgid ""
"(setq xy (add-foo '(3 4)))    ; @r{What happened?}\n"
"     @result{} (foo 1 2 3 4)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1257
#, no-wrap
msgid ""
"(eq xx xy)\n"
"     @result{} t\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1262
#, no-wrap
msgid ""
"(symbol-function 'add-foo)\n"
"     @result{} (lambda (x) (nconc '(foo 1 2 3 4) x))\n"
msgstr ""

#. type: section
#: original_texis/lists.texi:1267
#, no-wrap
msgid "Using Lists as Sets"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1268
#, no-wrap
msgid "lists as sets"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1269
#, no-wrap
msgid "sets"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1278
msgid ""
"A list can represent an unordered mathematical set---simply consider a value "
"an element of a set if it appears in the list, and ignore the order of the "
"list.  To form the union of two sets, use @code{append} (as long as you "
"don't mind having duplicate elements).  You can remove @code{equal} "
"duplicates using @code{delete-dups} or @code{seq-uniq}.  Other useful "
"functions for sets include @code{memq} and @code{delq}, and their "
"@code{equal} versions, @code{member} and @code{delete}."
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1279
#, no-wrap
msgid "CL note---lack @code{union}, @code{intersection}"
msgstr ""

#. type: quotation
#: original_texis/lists.texi:1285
msgid ""
"@b{Common Lisp note:} Common Lisp has functions @code{union} (which avoids "
"duplicate elements) and @code{intersection} for set operations.  In Emacs "
"Lisp, variants of these facilities are provided by the @file{cl-lib} "
"library.  @xref{Lists as Sets,,,cl,Common Lisp Extensions}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1287
#, no-wrap
msgid "memq object list"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1288
#, no-wrap
msgid "membership in a list"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1294
msgid ""
"This function tests to see whether @var{object} is a member of @var{list}.  "
"If it is, @code{memq} returns a list starting with the first occurrence of "
"@var{object}.  Otherwise, it returns @code{nil}.  The letter @samp{q} in "
"@code{memq} says that it uses @code{eq} to compare @var{object} against the "
"elements of the list.  For example:"
msgstr ""

#. type: group
#: original_texis/lists.texi:1299
#, no-wrap
msgid ""
"(memq 'b '(a b c b a))\n"
"     @result{} (b c b a)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1303
#, no-wrap
msgid ""
"(memq '(2) '((1) (2)))    ; @r{The two @code{(2)}s need not be @code{eq}.}\n"
"     @result{} @r{Unspecified; might be @code{nil} or @code{((2))}.}\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1307
#, no-wrap
msgid "delq object list"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1308
#, no-wrap
msgid "deleting list elements"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1314
msgid ""
"This function destructively removes all elements @code{eq} to @var{object} "
"from @var{list}, and returns the resulting list.  The letter @samp{q} in "
"@code{delq} says that it uses @code{eq} to compare @var{object} against the "
"elements of the list, like @code{memq} and @code{remq}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1318
msgid ""
"Typically, when you invoke @code{delq}, you should use the return value by "
"assigning it to the variable which held the original list.  The reason for "
"this is explained below."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1323
msgid ""
"The @code{delq} function deletes elements from the front of the list by "
"simply advancing down the list, and returning a sublist that starts after "
"those elements.  For example:"
msgstr ""

#. type: group
#: original_texis/lists.texi:1327
#, no-wrap
msgid "(delq 'a '(a b c)) @equiv{} (cdr '(a b c))\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1333
msgid ""
"When an element to be deleted appears in the middle of the list, removing it "
"involves changing the @sc{cdr}s (@pxref{Setcdr})."
msgstr ""

#. type: group
#: original_texis/lists.texi:1338
#, no-wrap
msgid ""
"(setq sample-list (list 'a 'b 'c '(4)))\n"
"     @result{} (a b c (4))\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1342
#, no-wrap
msgid ""
"(delq 'a sample-list)\n"
"     @result{} (b c (4))\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1346
#, no-wrap
msgid ""
"sample-list\n"
"     @result{} (a b c (4))\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1350
#, no-wrap
msgid ""
"(delq 'c sample-list)\n"
"     @result{} (a b (4))\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1354
#, no-wrap
msgid ""
"sample-list\n"
"     @result{} (a b (4))\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1364
msgid ""
"Note that @code{(delq 'c sample-list)} modifies @code{sample-list} to splice "
"out the third element, but @code{(delq 'a sample-list)} does not splice "
"anything---it just returns a shorter list.  Don't assume that a variable "
"which formerly held the argument @var{list} now has fewer elements, or that "
"it still holds the original list! Instead, save the result of @code{delq} "
"and use that.  Most often we store the result back into the variable that "
"held the original list:"
msgstr ""

#. type: example
#: original_texis/lists.texi:1367
#, no-wrap
msgid "(setq flowers (delq 'rose flowers))\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1371
msgid ""
"In the following example, the @code{(list 4)} that @code{delq} attempts to "
"match and the @code{(4)} in the @code{sample-list} are @code{equal} but not "
"@code{eq}:"
msgstr ""

#. type: group
#: original_texis/lists.texi:1376
#, no-wrap
msgid ""
"(delq (list 4) sample-list)\n"
"     @result{} (a c (4))\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1381
msgid ""
"If you want to delete elements that are @code{equal} to a given value, use "
"@code{delete} (see below)."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1382
#, no-wrap
msgid "remq object list"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1387
msgid ""
"This function returns a copy of @var{list}, with all elements removed which "
"are @code{eq} to @var{object}.  The letter @samp{q} in @code{remq} says that "
"it uses @code{eq} to compare @var{object} against the elements of "
"@code{list}."
msgstr ""

#. type: group
#: original_texis/lists.texi:1392
#, no-wrap
msgid ""
"(setq sample-list (list 'a 'b 'c 'a 'b 'c))\n"
"     @result{} (a b c a b c)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1396
#, no-wrap
msgid ""
"(remq 'a sample-list)\n"
"     @result{} (b c b c)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1400
#, no-wrap
msgid ""
"sample-list\n"
"     @result{} (a b c a b c)\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1404
#, no-wrap
msgid "memql object list"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1410
msgid ""
"The function @code{memql} tests to see whether @var{object} is a member of "
"@var{list}, comparing members with @var{object} using @code{eql}, so "
"floating-point elements are compared by value.  If @var{object} is a member, "
"@code{memql} returns a list starting with its first occurrence in "
"@var{list}.  Otherwise, it returns @code{nil}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1412 original_texis/lists.texi:1436
msgid "Compare this with @code{memq}:"
msgstr ""

#. type: group
#: original_texis/lists.texi:1417
#, no-wrap
msgid ""
"(memql 1.2 '(1.1 1.2 1.3))  ; @r{@code{1.2} and @code{1.2} are "
"@code{eql}.}\n"
"     @result{} (1.2 1.3)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1421
#, no-wrap
msgid ""
"(memq 1.2 '(1.1 1.2 1.3))  ; @r{The two @code{1.2}s need not be "
"@code{eq}.}\n"
"     @result{} @r{Unspecified; might be @code{nil} or @code{(1.2 1.3)}.}\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1428
msgid ""
"The following three functions are like @code{memq}, @code{delq} and "
"@code{remq}, but use @code{equal} rather than @code{eq} to compare "
"elements.  @xref{Equality Predicates}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1429
#, no-wrap
msgid "member object list"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1434
msgid ""
"The function @code{member} tests to see whether @var{object} is a member of "
"@var{list}, comparing members with @var{object} using @code{equal}.  If "
"@var{object} is a member, @code{member} returns a list starting with its "
"first occurrence in @var{list}.  Otherwise, it returns @code{nil}."
msgstr ""

#. type: group
#: original_texis/lists.texi:1441
#, no-wrap
msgid ""
"(member '(2) '((1) (2)))  ; @r{@code{(2)} and @code{(2)} are "
"@code{equal}.}\n"
"     @result{} ((2))\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1445
#, no-wrap
msgid ""
"(memq '(2) '((1) (2)))    ; @r{The two @code{(2)}s need not be @code{eq}.}\n"
"     @result{} @r{Unspecified; might be @code{nil} or @code{(2)}.}\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1450
#, no-wrap
msgid ""
";; @r{Two strings with the same contents are @code{equal}.}\n"
"(member \"foo\" '(\"foo\" \"bar\"))\n"
"     @result{} (\"foo\" \"bar\")\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1454
#, no-wrap
msgid "delete object sequence"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1457
msgid ""
"This function removes all elements @code{equal} to @var{object} from "
"@var{sequence}, and returns the resulting sequence."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1464
msgid ""
"If @var{sequence} is a list, @code{delete} is to @code{delq} as "
"@code{member} is to @code{memq}: it uses @code{equal} to compare elements "
"with @var{object}, like @code{member}; when it finds an element that "
"matches, it cuts the element out just as @code{delq} would.  As with "
"@code{delq}, you should typically use the return value by assigning it to "
"the variable which held the original list."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1468
msgid ""
"If @code{sequence} is a vector or string, @code{delete} returns a copy of "
"@code{sequence} with all elements @code{equal} to @code{object} removed."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1470 original_texis/lists.texi:1720
msgid "For example:"
msgstr ""

#. type: group
#: original_texis/lists.texi:1480
#, no-wrap
msgid ""
"(setq l (list '(2) '(1) '(2)))\n"
"(delete '(2) l)\n"
"     @result{} ((1))\n"
"l\n"
"     @result{} ((2) (1))\n"
";; @r{If you want to change @code{l} reliably,}\n"
";; @r{write @code{(setq l (delete '(2) l))}.}\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1489
#, no-wrap
msgid ""
"(setq l (list '(2) '(1) '(2)))\n"
"(delete '(1) l)\n"
"     @result{} ((2) (2))\n"
"l\n"
"     @result{} ((2) (2))\n"
";; @r{In this case, it makes no difference whether you set @code{l},}\n"
";; @r{but you should do so for the sake of the other case.}\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1493
#, no-wrap
msgid ""
"(delete '(2) [(2) (1) (2)])\n"
"     @result{} [(1)]\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1497
#, no-wrap
msgid "remove object sequence"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1501
msgid ""
"This function is the non-destructive counterpart of @code{delete}.  It "
"returns a copy of @code{sequence}, a list, vector, or string, with elements "
"@code{equal} to @code{object} removed.  For example:"
msgstr ""

#. type: group
#: original_texis/lists.texi:1506
#, no-wrap
msgid ""
"(remove '(2) '((2) (1) (2)))\n"
"     @result{} ((1))\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1510
#, no-wrap
msgid ""
"(remove '(2) [(2) (1) (2)])\n"
"     @result{} [(1)]\n"
msgstr ""

#. type: quotation
#: original_texis/lists.texi:1519
msgid ""
"@b{Common Lisp note:} The functions @code{member}, @code{delete} and "
"@code{remove} in GNU Emacs Lisp are derived from Maclisp, not Common Lisp.  "
"The Common Lisp versions do not use @code{equal} to compare elements."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1521
#, no-wrap
msgid "member-ignore-case object list"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1527
msgid ""
"This function is like @code{member}, except that @var{object} should be a "
"string and that it ignores differences in letter-case and text "
"representation: upper-case and lower-case letters are treated as equal, and "
"unibyte strings are converted to multibyte prior to comparison."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1529
#, no-wrap
msgid "delete-dups list"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1535
msgid ""
"This function destructively removes all @code{equal} duplicates from "
"@var{list}, stores the result in @var{list} and returns it.  Of several "
"@code{equal} occurrences of an element in @var{list}, @code{delete-dups} "
"keeps the first one.  See @code{seq-uniq} for non-destructive operation "
"(@pxref{Sequence Functions})."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1540
msgid ""
"See also the function @code{add-to-list}, in @ref{List Variables}, for a way "
"to add an element to a list stored in a variable and used as a set."
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1543
#, no-wrap
msgid "association list"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1544
#, no-wrap
msgid "alist"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1553
msgid ""
"An @dfn{association list}, or @dfn{alist} for short, records a mapping from "
"keys to values.  It is a list of cons cells called @dfn{associations}: the "
"@sc{car} of each cons cell is the @dfn{key}, and the @sc{cdr} is the "
"@dfn{associated value}.@footnote{This usage of ``key'' is not related to the "
"term ``key sequence''; it means a value used to look up an item in a table.  "
"In this case, the table is the alist, and the alist associations are the "
"items.}"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1557
msgid ""
"Here is an example of an alist.  The key @code{pine} is associated with the "
"value @code{cones}; the key @code{oak} is associated with @code{acorns}; and "
"the key @code{maple} is associated with @code{seeds}."
msgstr ""

#. type: group
#: original_texis/lists.texi:1563
#, no-wrap
msgid ""
"((pine . cones)\n"
" (oak . acorns)\n"
" (maple . seeds))\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1571
msgid ""
"Both the values and the keys in an alist may be any Lisp objects.  For "
"example, in the following alist, the symbol @code{a} is associated with the "
"number @code{1}, and the string @code{\"b\"} is associated with the "
"@emph{list} @code{(2 3)}, which is the @sc{cdr} of the alist element:"
msgstr ""

#. type: example
#: original_texis/lists.texi:1574
#, no-wrap
msgid "((a . 1) (\"b\" 2 3))\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1579
msgid ""
"Sometimes it is better to design an alist to store the associated value in "
"the @sc{car} of the @sc{cdr} of the element.  Here is an example of such an "
"alist:"
msgstr ""

#. type: example
#: original_texis/lists.texi:1582
#, no-wrap
msgid "((rose red) (lily white) (buttercup yellow))\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1592
msgid ""
"Here we regard @code{red} as the value associated with @code{rose}.  One "
"advantage of this kind of alist is that you can store other related "
"information---even a list of other items---in the @sc{cdr} of the @sc{cdr}.  "
"One disadvantage is that you cannot use @code{rassq} (see below) to find the "
"element containing a given value.  When neither of these considerations is "
"important, the choice is a matter of taste, as long as you are consistent "
"about it for any given alist."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1596
msgid ""
"The same alist shown above could be regarded as having the associated value "
"in the @sc{cdr} of the element; the value associated with @code{rose} would "
"be the list @code{(red)}."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1602
msgid ""
"Association lists are often used to record information that you might "
"otherwise keep on a stack, since new associations may be added easily to the "
"front of the list.  When searching an association list for an association "
"with a given key, the first one found is returned, if there is more than "
"one."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1607
msgid ""
"In Emacs Lisp, it is @emph{not} an error if an element of an association "
"list is not a cons cell.  The alist search functions simply ignore such "
"elements.  Many other versions of Lisp signal errors in such cases."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1612
msgid ""
"Note that property lists are similar to association lists in several "
"respects.  A property list behaves like an association list in which each "
"key can occur only once.  @xref{Property Lists}, for a comparison of "
"property lists and association lists."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1613
#, no-wrap
msgid "assoc key alist &optional testfn"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1622
msgid ""
"This function returns the first association for @var{key} in @var{alist}, "
"comparing @var{key} against the alist elements using @var{testfn} if it is a "
"function, and @code{equal} otherwise (@pxref{Equality Predicates}).  If "
"@var{testfn} is a function, it is called with two arguments: the @sc{car} of "
"an element from @var{alist} and @var{key}.  The function returns @code{nil} "
"if no association in @var{alist} has a @sc{car} equal to @var{key}, as "
"tested by @var{testfn}.  For example:"
msgstr ""

#. type: smallexample
#: original_texis/lists.texi:1632
#, no-wrap
msgid ""
"(setq trees '((pine . cones) (oak . acorns) (maple . seeds)))\n"
"     @result{} ((pine . cones) (oak . acorns) (maple . seeds))\n"
"(assoc 'oak trees)\n"
"     @result{} (oak . acorns)\n"
"(cdr (assoc 'oak trees))\n"
"     @result{} acorns\n"
"(assoc 'birch trees)\n"
"     @result{} nil\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1635
msgid "Here is another example, in which the keys and values are not symbols:"
msgstr ""

#. type: smallexample
#: original_texis/lists.texi:1641
#, no-wrap
msgid ""
"(setq needles-per-cluster\n"
"      '((2 \"Austrian Pine\" \"Red Pine\")\n"
"        (3 \"Pitch Pine\")\n"
"        (5 \"White Pine\")))\n"
"\n"
msgstr ""

#. type: smallexample
#: original_texis/lists.texi:1646
#, no-wrap
msgid ""
"(cdr (assoc 3 needles-per-cluster))\n"
"     @result{} (\"Pitch Pine\")\n"
"(cdr (assoc 2 needles-per-cluster))\n"
"     @result{} (\"Austrian Pine\" \"Red Pine\")\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1652
msgid ""
"The function @code{assoc-string} is much like @code{assoc} except that it "
"ignores certain differences between strings.  @xref{Text Comparison}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1653
#, no-wrap
msgid "rassoc value alist"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1657
msgid ""
"This function returns the first association with value @var{value} in "
"@var{alist}.  It returns @code{nil} if no association in @var{alist} has a "
"@sc{cdr} @code{equal} to @var{value}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1661
msgid ""
"@code{rassoc} is like @code{assoc} except that it compares the @sc{cdr} of "
"each @var{alist} association instead of the @sc{car}.  You can think of this "
"as reverse @code{assoc}, finding the key for a given value."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1663
#, no-wrap
msgid "assq key alist"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1671
msgid ""
"This function is like @code{assoc} in that it returns the first association "
"for @var{key} in @var{alist}, but it makes the comparison using @code{eq}.  "
"@code{assq} returns @code{nil} if no association in @var{alist} has a "
"@sc{car} @code{eq} to @var{key}.  This function is used more often than "
"@code{assoc}, since @code{eq} is faster than @code{equal} and most alists "
"use symbols as keys.  @xref{Equality Predicates}."
msgstr ""

#. type: smallexample
#: original_texis/lists.texi:1677
#, no-wrap
msgid ""
"(setq trees '((pine . cones) (oak . acorns) (maple . seeds)))\n"
"     @result{} ((pine . cones) (oak . acorns) (maple . seeds))\n"
"(assq 'pine trees)\n"
"     @result{} (pine . cones)\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1681
msgid ""
"On the other hand, @code{assq} is not usually useful in alists where the "
"keys may not be symbols:"
msgstr ""

#. type: smallexample
#: original_texis/lists.texi:1686
#, no-wrap
msgid ""
"(setq leaves\n"
"      '((\"simple leaves\" . oak)\n"
"        (\"compound leaves\" . horsechestnut)))\n"
"\n"
msgstr ""

#. type: smallexample
#: original_texis/lists.texi:1691
#, no-wrap
msgid ""
"(assq \"simple leaves\" leaves)\n"
"     @result{} @r{Unspecified; might be @code{nil} or @code{(\"simple "
"leaves\" . oak)}.}\n"
"(assoc \"simple leaves\" leaves)\n"
"     @result{} (\"simple leaves\" . oak)\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1694
#, no-wrap
msgid "alist-get key alist &optional default remove testfn"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1702
msgid ""
"This function is similar to @code{assq}.  It finds the first association "
"@w{@code{(@var{key} . @var{value})}} by comparing @var{key} with @var{alist} "
"elements, and, if found, returns the @var{value} of that association.  If no "
"association is found, the function returns @var{default}.  Comparison of "
"@var{key} against @var{alist} elements uses the function specified by "
"@var{testfn}, defaulting to @code{eq}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1708
msgid ""
"This is a generalized variable (@pxref{Generalized Variables})  that can be "
"used to change a value with @code{setf}.  When using it to set a value, "
"optional argument @var{remove} non-@code{nil} means to remove @var{key}'s "
"association from @var{alist} if the new value is @code{eql} to "
"@var{default}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1710
#, no-wrap
msgid "rassq value alist"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1714
msgid ""
"This function returns the first association with value @var{value} in "
"@var{alist}.  It returns @code{nil} if no association in @var{alist} has a "
"@sc{cdr} @code{eq} to @var{value}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1718
msgid ""
"@code{rassq} is like @code{assq} except that it compares the @sc{cdr} of "
"each @var{alist} association instead of the @sc{car}.  You can think of this "
"as reverse @code{assq}, finding the key for a given value."
msgstr ""

#. type: smallexample
#: original_texis/lists.texi:1723
#, no-wrap
msgid ""
"(setq trees '((pine . cones) (oak . acorns) (maple . seeds)))\n"
"\n"
msgstr ""

#. type: smallexample
#: original_texis/lists.texi:1728
#, no-wrap
msgid ""
"(rassq 'acorns trees)\n"
"     @result{} (oak . acorns)\n"
"(rassq 'spores trees)\n"
"     @result{} nil\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1732
msgid ""
"@code{rassq} cannot search for a value stored in the @sc{car} of the "
"@sc{cdr} of an element:"
msgstr ""

#. type: smallexample
#: original_texis/lists.texi:1735
#, no-wrap
msgid ""
"(setq colors '((rose red) (lily white) (buttercup yellow)))\n"
"\n"
msgstr ""

#. type: smallexample
#: original_texis/lists.texi:1738
#, no-wrap
msgid ""
"(rassq 'white colors)\n"
"     @result{} nil\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1743
msgid ""
"In this case, the @sc{cdr} of the association @code{(lily white)} is not the "
"symbol @code{white}, but rather the list @code{(white)}.  This becomes "
"clearer if the association is written in dotted pair notation:"
msgstr ""

#. type: smallexample
#: original_texis/lists.texi:1746
#, no-wrap
msgid "(lily white) @equiv{} (lily . (white))\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1749
#, no-wrap
msgid "assoc-default key alist &optional test default"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1758
msgid ""
"This function searches @var{alist} for a match for @var{key}.  For each "
"element of @var{alist}, it compares the element (if it is an atom) or the "
"element's @sc{car} (if it is a cons) against @var{key}, by calling "
"@var{test} with two arguments: the element or its @sc{car}, and @var{key}.  "
"The arguments are passed in that order so that you can get useful results "
"using @code{string-match} with an alist that contains regular expressions "
"(@pxref{Regexp Search}).  If @var{test} is omitted or @code{nil}, "
"@code{equal} is used for comparison."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1763
msgid ""
"If an alist element matches @var{key} by this criterion, then "
"@code{assoc-default} returns a value based on this element.  If the element "
"is a cons, then the value is the element's @sc{cdr}.  Otherwise, the return "
"value is @var{default}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1766
msgid ""
"If no alist element matches @var{key}, @code{assoc-default} returns "
"@code{nil}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1768
#, no-wrap
msgid "copy-alist alist"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1769
#, no-wrap
msgid "copying alists"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1773
msgid ""
"This function returns a two-level deep copy of @var{alist}: it creates a new "
"copy of each association, so that you can alter the associations of the new "
"alist without changing the old one."
msgstr ""

#. type: group
#: original_texis/lists.texi:1779
#, no-wrap
msgid ""
"(setq needles-per-cluster\n"
"      '((2 . (\"Austrian Pine\" \"Red Pine\"))\n"
"        (3 . (\"Pitch Pine\"))\n"
msgstr ""

#. type: smallexample
#: original_texis/lists.texi:1785
#, no-wrap
msgid ""
"        (5 . (\"White Pine\"))))\n"
"@result{}\n"
"((2 \"Austrian Pine\" \"Red Pine\")\n"
" (3 \"Pitch Pine\")\n"
" (5 \"White Pine\"))\n"
"\n"
msgstr ""

#. type: smallexample
#: original_texis/lists.texi:1791
#, no-wrap
msgid ""
"(setq copy (copy-alist needles-per-cluster))\n"
"@result{}\n"
"((2 \"Austrian Pine\" \"Red Pine\")\n"
" (3 \"Pitch Pine\")\n"
" (5 \"White Pine\"))\n"
"\n"
msgstr ""

#. type: smallexample
#: original_texis/lists.texi:1800
#, no-wrap
msgid ""
"(eq needles-per-cluster copy)\n"
"     @result{} nil\n"
"(equal needles-per-cluster copy)\n"
"     @result{} t\n"
"(eq (car needles-per-cluster) (car copy))\n"
"     @result{} nil\n"
"(cdr (car (cdr needles-per-cluster)))\n"
"     @result{} (\"Pitch Pine\")\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1804
#, no-wrap
msgid ""
"(eq (cdr (car (cdr needles-per-cluster)))\n"
"    (cdr (car (cdr copy))))\n"
"     @result{} t\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1809
msgid ""
"This example shows how @code{copy-alist} makes it possible to change the "
"associations of one copy without affecting the other:"
msgstr ""

#. type: group
#: original_texis/lists.texi:1815
#, no-wrap
msgid ""
"(setcdr (assq 3 copy) '(\"Martian Vacuum Pine\"))\n"
"(cdr (assq 3 needles-per-cluster))\n"
"     @result{} (\"Pitch Pine\")\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1819
#, no-wrap
msgid "assq-delete-all key alist"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1826
msgid ""
"This function deletes from @var{alist} all the elements whose @sc{car} is "
"@code{eq} to @var{key}, much as if you used @code{delq} to delete each such "
"element one by one.  It returns the shortened alist, and often modifies the "
"original list structure of @var{alist}.  For correct results, use the return "
"value of @code{assq-delete-all} rather than looking at the saved value of "
"@var{alist}."
msgstr ""

#. type: example
#: original_texis/lists.texi:1834
#, no-wrap
msgid ""
"(setq alist (list '(foo 1) '(bar 2) '(foo 3) '(lose 4)))\n"
"     @result{} ((foo 1) (bar 2) (foo 3) (lose 4))\n"
"(assq-delete-all 'foo alist)\n"
"     @result{} ((bar 2) (lose 4))\n"
"alist\n"
"     @result{} ((foo 1) (bar 2) (lose 4))\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1837
#, no-wrap
msgid "assoc-delete-all key alist &optional test"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1843
msgid ""
"This function is like @code{assq-delete-all} except that it accepts an "
"optional argument @var{test}, a predicate function to compare the keys in "
"@var{alist}.  If omitted or @code{nil}, @var{test} defaults to "
"@code{equal}.  As @code{assq-delete-all}, this function often modifies the "
"original list structure of @var{alist}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1845
#, no-wrap
msgid "rassq-delete-all value alist"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1852
msgid ""
"This function deletes from @var{alist} all the elements whose @sc{cdr} is "
"@code{eq} to @var{value}.  It returns the shortened alist, and often "
"modifies the original list structure of @var{alist}.  "
"@code{rassq-delete-all} is like @code{assq-delete-all} except that it "
"compares the @sc{cdr} of each @var{alist} association instead of the "
"@sc{car}."
msgstr ""

#. type: defmac
#: original_texis/lists.texi:1854
#, no-wrap
msgid "let-alist alist body"
msgstr ""

#. type: defmac
#: original_texis/lists.texi:1859
msgid ""
"Creates a binding for each symbol used as keys the association list "
"@var{alist}, prefixed with dot.  This can be useful when accessing several "
"items in the same association list, and it's best understood through a "
"simple example:"
msgstr ""

#. type: lisp
#: original_texis/lists.texi:1866
#, no-wrap
msgid ""
"(setq colors '((rose . red) (lily . white) (buttercup . yellow)))\n"
"(let-alist colors\n"
"  (if (eq .rose 'red)\n"
"      .lily))\n"
"     @result{} white\n"
msgstr ""

#. type: defmac
#: original_texis/lists.texi:1873
msgid ""
"The @var{body} is inspected at compilation time, and only the symbols that "
"appear in @var{body} with a @samp{.} as the first character in the symbol "
"name will be bound.  Finding the keys is done with @code{assq}, and the "
"@code{cdr} of the return value of this @code{assq} is assigned as the value "
"for the binding."
msgstr ""

#. type: defmac
#: original_texis/lists.texi:1875
msgid "Nested association lists is supported:"
msgstr ""

#. type: lisp
#: original_texis/lists.texi:1882
#, no-wrap
msgid ""
"(setq colors '((rose . red) (lily (belladonna . yellow) (brindisi "
". pink))))\n"
"(let-alist colors\n"
"  (if (eq .rose 'red)\n"
"      .lily.belladonna))\n"
"     @result{} yellow\n"
msgstr ""

#. type: defmac
#: original_texis/lists.texi:1887
msgid ""
"Nesting @code{let-alist} inside each other is allowed, but the code in the "
"inner @code{let-alist} can't access the variables bound by the outer "
"@code{let-alist}."
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1891
#, no-wrap
msgid "property list"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1892
#, no-wrap
msgid "plist"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1898
msgid ""
"A @dfn{property list} (@dfn{plist} for short) is a list of paired elements.  "
"Each of the pairs associates a property name (usually a symbol) with a "
"property or value.  Here is an example of a property list:"
msgstr ""

#. type: example
#: original_texis/lists.texi:1901
#, no-wrap
msgid "(pine cones numbers (1 2 3) color \"blue\")\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1908
msgid ""
"This property list associates @code{pine} with @code{cones}, @code{numbers} "
"with @code{(1 2 3)}, and @code{color} with @code{\"blue\"}.  The property "
"names and values can be any Lisp objects, but the names are usually symbols "
"(as they are in this example)."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1914
msgid ""
"Property lists are used in several contexts.  For instance, the function "
"@code{put-text-property} takes an argument which is a property list, "
"specifying text properties and associated values which are to be applied to "
"text in a string or buffer.  @xref{Text Properties}."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1919
msgid ""
"Another prominent use of property lists is for storing symbol properties.  "
"Every symbol possesses a list of properties, used to record miscellaneous "
"information about the symbol; these properties are stored in the form of a "
"property list.  @xref{Symbol Properties}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1920
#, no-wrap
msgid "plistp object"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1923
msgid ""
"This predicate function returns non-@code{nil} if @var{object} is a valid "
"property list."
msgstr ""

#. type: node
#: original_texis/lists.texi:1929 original_texis/lists.texi:1931
#, no-wrap
msgid "Plists and Alists"
msgstr ""

#. type: menuentry
#: original_texis/lists.texi:1929
msgid "Comparison of the advantages of property lists and association lists."
msgstr ""

#. type: node
#: original_texis/lists.texi:1929 original_texis/lists.texi:1966
#, no-wrap
msgid "Plist Access"
msgstr ""

#. type: menuentry
#: original_texis/lists.texi:1929
msgid "Accessing property lists stored elsewhere."
msgstr ""

#. type: subsection
#: original_texis/lists.texi:1932
#, no-wrap
msgid "Property Lists and Association Lists"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1933
#, no-wrap
msgid "plist vs. alist"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1934
#, no-wrap
msgid "alist vs. plist"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1936
#, no-wrap
msgid "property lists vs association lists"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1941
msgid ""
"Association lists (@pxref{Association Lists}) are very similar to property "
"lists.  In contrast to association lists, the order of the pairs in the "
"property list is not significant, since the property names must be distinct."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1954
msgid ""
"Property lists are better than association lists for attaching information "
"to various Lisp function names or variables.  If your program keeps all such "
"information in one association list, it will typically need to search that "
"entire list each time it checks for an association for a particular Lisp "
"function name or variable, which could be slow.  By contrast, if you keep "
"the same information in the property lists of the function names or "
"variables themselves, each search will scan only the length of one property "
"list, which is usually short.  This is why the documentation for a variable "
"is recorded in a property named @code{variable-documentation}.  The byte "
"compiler likewise uses properties to record those functions needing special "
"treatment."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1965
msgid ""
"However, association lists have their own advantages.  Depending on your "
"application, it may be faster to add an association to the front of an "
"association list than to update a property.  All properties for a symbol are "
"stored in the same property list, so there is a possibility of a conflict "
"between different uses of a property name.  (For this reason, it is a good "
"idea to choose property names that are probably unique, such as by beginning "
"the property name with the program's usual name-prefix for variables and "
"functions.)  An association list may be used like a stack where associations "
"are pushed on the front of the list and later discarded; this is not "
"possible with a property list."
msgstr ""

#. type: subsection
#: original_texis/lists.texi:1967
#, no-wrap
msgid "Property Lists Outside Symbols"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1968
#, no-wrap
msgid "plist access"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1969
#, no-wrap
msgid "accessing plist properties"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1973
msgid ""
"The following functions can be used to manipulate property lists.  They all "
"default to comparing property names using @code{eq}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1974
#, no-wrap
msgid "plist-get plist property &optional predicate"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1980
msgid ""
"This returns the value of the @var{property} property stored in the property "
"list @var{plist}.  Comparisons are done with @var{predicate}, which defaults "
"to @code{eq}.  It accepts a malformed @var{plist} argument.  If "
"@var{property} is not found in the @var{plist}, it returns @code{nil}.  For "
"example,"
msgstr ""

#. type: example
#: original_texis/lists.texi:1990
#, no-wrap
msgid ""
"(plist-get '(foo 4) 'foo)\n"
"     @result{} 4\n"
"(plist-get '(foo 4 bad) 'foo)\n"
"     @result{} 4\n"
"(plist-get '(foo 4 bad) 'bad)\n"
"     @result{} nil\n"
"(plist-get '(foo 4 bad) 'bar)\n"
"     @result{} nil\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1993
#, no-wrap
msgid "plist-put plist property value &optional predicate"
msgstr ""

#. type: defun
#: original_texis/lists.texi:2000
msgid ""
"This stores @var{value} as the value of the @var{property} property in the "
"property list @var{plist}.  Comparisons are done with @var{predicate}, which "
"defaults to @code{eq}.  It may modify @var{plist} destructively, or it may "
"construct a new list structure without altering the old.  The function "
"returns the modified property list, so you can store that back in the place "
"where you got @var{plist}.  For example,"
msgstr ""

#. type: example
#: original_texis/lists.texi:2008
#, no-wrap
msgid ""
"(setq my-plist (list 'bar t 'foo 4))\n"
"     @result{} (bar t foo 4)\n"
"(setq my-plist (plist-put my-plist 'foo 69))\n"
"     @result{} (bar t foo 69)\n"
"(setq my-plist (plist-put my-plist 'quux '(a)))\n"
"     @result{} (bar t foo 69 quux (a))\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:2011
#, no-wrap
msgid "lax-plist-get plist property"
msgstr ""

#. type: defun
#: original_texis/lists.texi:2014
msgid ""
"This obsolete function is like @code{plist-get} except that it compares "
"properties using @code{equal} instead of @code{eq}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:2016
#, no-wrap
msgid "lax-plist-put plist property value"
msgstr ""

#. type: defun
#: original_texis/lists.texi:2019
msgid ""
"This obsolete function is like @code{plist-put} except that it compares "
"properties using @code{equal} instead of @code{eq}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:2021
#, no-wrap
msgid "plist-member plist property &optional predicate"
msgstr ""

#. type: defun
#: original_texis/lists.texi:2028
msgid ""
"This returns non-@code{nil} if @var{plist} contains the given "
"@var{property}.  Comparisons are done with @var{predicate}, which defaults "
"to @code{eq}.  Unlike @code{plist-get}, this allows you to distinguish "
"between a missing property and a property with the value @code{nil}.  The "
"value is actually the tail of @var{plist} whose @code{car} is "
"@var{property}."
msgstr ""
