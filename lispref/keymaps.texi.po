# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Emacs 26.1\n"
"POT-Creation-Date: 2020-03-08 09:41+0900\n"
"PO-Revision-Date: 2020-03-23 20:10+0900\n"
"Last-Translator: Ayanokoji Takesi <ayanokoji.takesi@gmail.com>\n"
"Language-Team: \n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: original_texis/keymaps.texi:5 original_texis/keymaps.texi:6
#, no-wrap
msgid "Keymaps"
msgstr "Keymaps"

#. type: var{#1}
#: original_texis/keymaps.texi:7 original_texis/keymaps.texi:1053
#, no-wrap
msgid "keymap"
msgstr "keymap"

#. type: Plain text
#: original_texis/keymaps.texi:15
msgid "The command bindings of input events are recorded in data structures called @dfn{keymaps}.  Each entry in a keymap associates (or @dfn{binds}) an individual event type, either to another keymap or to a command.  When an event type is bound to a keymap, that keymap is used to look up the next input event; this continues until a command is found.  The whole process is called @dfn{key lookup}."
msgstr "入力イベントのコマンドバインディングは@dfn{キーマップ(keymap)}と呼ばれるデータ構造に記録されます。キーマップ内の各エントリーは個別のイベント型(他のキーマップ、またはコマンド)に関連づけ(または@dfn{バインド})されます。イベント型がキーマップにバインドされていれば、そのキーマップは次の入力イベントを調べるために使用されます。これはコマンドが見つかるまで継続されます。このプロセス全体を@dfn{キールックアップ(key lookup: キーの照合)}と呼びます。"

#. type: section
#: original_texis/keymaps.texi:38 original_texis/keymaps.texi:40
#: original_texis/keymaps.texi:41
#, no-wrap
msgid "Key Sequences"
msgstr "Key Sequences"

#. type: menuentry
#: original_texis/keymaps.texi:38
msgid "Key sequences as Lisp objects."
msgstr "Lispオブジェクトとしてのキーシーケンス。"

#. type: section
#: original_texis/keymaps.texi:38 original_texis/keymaps.texi:99
#: original_texis/keymaps.texi:100
#, no-wrap
msgid "Keymap Basics"
msgstr "Keymap Basics"

#. type: menuentry
#: original_texis/keymaps.texi:38
msgid "Basic concepts of keymaps."
msgstr "キーマップの基本概念。"

#. type: section
#: original_texis/keymaps.texi:38 original_texis/keymaps.texi:151
#: original_texis/keymaps.texi:152
#, no-wrap
msgid "Format of Keymaps"
msgstr "Format of Keymaps"

#. type: menuentry
#: original_texis/keymaps.texi:38
msgid "What a keymap looks like as a Lisp object."
msgstr "キーマップはLispオブジェクトとしてどのように見えるか。"

#. type: section
#: original_texis/keymaps.texi:38 original_texis/keymaps.texi:303
#: original_texis/keymaps.texi:304
#, no-wrap
msgid "Creating Keymaps"
msgstr "Creating Keymaps"

#. type: menuentry
#: original_texis/keymaps.texi:38
msgid "Functions to create and copy keymaps."
msgstr "キーマップの作成やコピーを行う関数。"

#. type: section
#: original_texis/keymaps.texi:38 original_texis/keymaps.texi:398
#: original_texis/keymaps.texi:399
#, no-wrap
msgid "Inheritance and Keymaps"
msgstr "Inheritance and Keymaps"

#. type: menuentry
#: original_texis/keymaps.texi:38
msgid "How one keymap can inherit the bindings of another keymap."
msgstr "キーマップが他のキーマップのバインディングを継承する方法。"

#. type: section
#: original_texis/keymaps.texi:38 original_texis/keymaps.texi:486
#: original_texis/keymaps.texi:487
#, no-wrap
msgid "Prefix Keys"
msgstr "Prefix Keys"

#. type: menuentry
#: original_texis/keymaps.texi:38
msgid "Defining a key with a keymap as its definition."
msgstr "キーマップの定義としてキーを定義する。"

#. type: section
#: original_texis/keymaps.texi:38 original_texis/keymaps.texi:645
#: original_texis/keymaps.texi:646
#, no-wrap
msgid "Active Keymaps"
msgstr "Active Keymaps"

#. type: menuentry
#: original_texis/keymaps.texi:38
msgid "How Emacs searches the active keymaps for a key binding."
msgstr "Emacsがアクティブなキーマップでキーバインディングを探す方法。"

#. type: node
#: original_texis/keymaps.texi:38 original_texis/keymaps.texi:755
#, no-wrap
msgid "Searching Keymaps"
msgstr "Searching Keymaps"

#. type: menuentry
#: original_texis/keymaps.texi:38
msgid "A pseudo-Lisp summary of searching active maps."
msgstr "アクティブなマップ検索のLisp処理概要。"

#. type: node
#: original_texis/keymaps.texi:38 original_texis/keymaps.texi:806
#, no-wrap
msgid "Controlling Active Maps"
msgstr "Controlling Active Maps"

#. type: menuentry
#: original_texis/keymaps.texi:38
msgid "Each buffer has a local keymap to override the standard (global) bindings.  A minor mode can also override them."
msgstr "各バッファーは標準(グローバル)のバインディングをオーバーライドするためのキーマップをもつ。マイナーモードもそれらをオーバーライドできる。"

#. type: section
#: original_texis/keymaps.texi:38 original_texis/keymaps.texi:1000
#: original_texis/keymaps.texi:1001
#, no-wrap
msgid "Key Lookup"
msgstr "Key Lookup"

#. type: menuentry
#: original_texis/keymaps.texi:38
msgid "Finding a key's binding in one keymap."
msgstr "1つのキーマップから、あるキーのバインディングを探す。"

#. type: section
#: original_texis/keymaps.texi:38 original_texis/keymaps.texi:1112
#: original_texis/keymaps.texi:1113
#, no-wrap
msgid "Functions for Key Lookup"
msgstr "Functions for Key Lookup"

#. type: menuentry
#: original_texis/keymaps.texi:38
msgid "How to request key lookup."
msgstr "キールックアップを要求する方法。"

#. type: section
#: original_texis/keymaps.texi:38 original_texis/keymaps.texi:1263
#: original_texis/keymaps.texi:1264
#, no-wrap
msgid "Changing Key Bindings"
msgstr "Changing Key Bindings"

#. type: menuentry
#: original_texis/keymaps.texi:38
msgid "Redefining a key in a keymap."
msgstr "キーマップ内でのキーの再定義。"

#. type: section
#: original_texis/keymaps.texi:38 original_texis/keymaps.texi:1499
#: original_texis/keymaps.texi:1500
#, no-wrap
msgid "Remapping Commands"
msgstr "Remapping Commands"

#. type: menuentry
#: original_texis/keymaps.texi:38
msgid "A keymap can translate one command to another."
msgstr "キーマップはあるコマンドを他のコマンドに変換できる。"

#. type: node
#: original_texis/keymaps.texi:38 original_texis/keymaps.texi:1561
#, no-wrap
msgid "Translation Keymaps"
msgstr "Translation Keymaps"

#. type: menuentry
#: original_texis/keymaps.texi:38
msgid "Keymaps for translating sequences of events."
msgstr "イベントシーケンスを変換するキーマップ。"

#. type: node
#: original_texis/keymaps.texi:38 original_texis/keymaps.texi:1702
#, no-wrap
msgid "Key Binding Commands"
msgstr "Key Binding Commands"

#. type: menuentry
#: original_texis/keymaps.texi:38
msgid "Interactive interfaces for redefining keys."
msgstr "キーの再定義にたいするインタラクティブなインターフェイス。"

#. type: section
#: original_texis/keymaps.texi:38 original_texis/keymaps.texi:1835
#: original_texis/keymaps.texi:1836
#, no-wrap
msgid "Scanning Keymaps"
msgstr "Scanning Keymaps"

#. type: menuentry
#: original_texis/keymaps.texi:38
msgid "Looking through all keymaps, for printing help."
msgstr "ヘルプをプリントするためにすべてのキーマップを走査する。"

#. type: section
#: original_texis/keymaps.texi:38 original_texis/keymaps.texi:2006
#: original_texis/keymaps.texi:2007
#, no-wrap
msgid "Menu Keymaps"
msgstr "Menu Keymaps"

#. type: menuentry
#: original_texis/keymaps.texi:38
msgid "Defining a menu as a keymap."
msgstr "キーマップとしてキーマップを定義する。"

#. type: cindex
#: original_texis/keymaps.texi:42
#, no-wrap
msgid "key"
msgstr "key"

#. type: cindex
#: original_texis/keymaps.texi:43
#, no-wrap
msgid "keystroke"
msgstr "keystroke"

#. type: cindex
#: original_texis/keymaps.texi:44
#, no-wrap
msgid "key sequence"
msgstr "key sequence"

#. type: Plain text
#: original_texis/keymaps.texi:53
msgid "A @dfn{key sequence}, or @dfn{key} for short, is a sequence of one or more input events that form a unit.  Input events include characters, function keys, mouse actions, or system events external to Emacs, such as @code{iconify-frame} (@pxref{Input Events}).  The Emacs Lisp representation for a key sequence is a string or vector.  Unless otherwise stated, any Emacs Lisp function that accepts a key sequence as an argument can handle both representations."
msgstr "@dfn{キーシーケンス(key sequence)}、短くは@dfn{キー(key)}とは1つの単位を形成する1つ以上の入力イベントのシーケンスです。入力イベントには文字、ファンクションキー、マウスアクション、または@code{iconify-frame}のようなEmacs外部のシステムイベントが含まれます(@ref{Input Events}を参照)。キーシーケンスにたいするEmacs Lispの表現は文字列かベクターです。特に明記しない限り、引数としてキーシーケンスを受け取るEmacs Lisp関数は両方の表現を処理することができます。"

#. type: Plain text
#: original_texis/keymaps.texi:65
msgid "In the string representation, alphanumeric characters ordinarily stand for themselves; for example, @code{\"a\"} represents @kbd{a} and @code{\"2\"} represents @kbd{2}.  Control character events are prefixed by the substring @code{\"\\C-\"}, and meta characters by @code{\"\\M-\"}; for example, @code{\"\\C-x\"} represents the key @kbd{C-x}.  In addition, the @key{TAB}, @key{RET}, @key{ESC}, and @key{DEL} events are represented by @code{\"\\t\"}, @code{\"\\r\"}, @code{\"\\e\"}, and @code{\"\\d\"} respectively.  The string representation of a complete key sequence is the concatenation of the string representations of the constituent events; thus, @code{\"\\C-xl\"} represents the key sequence @kbd{C-x l}."
msgstr "文字列表現ではたとえば@code{\"a\"}は@kbd{a}、@code{\"2\"}は@kbd{2}を表すといったように、英数字はその文字自身を意味します。コントロール文字イベントは部分文字列@code{\"\\C-\"}、メタ文字は@code{\"\\M-\"}によりプレフィクスされます。たとえば@code{\"\\C-x\"}はキー@kbd{C-x}を表します。それらに加えて@key{TAB}、@key{RET}、@key{ESC}、@key{DEL}などのイベントはそれぞれ@code{\"\\t\"}、@code{\"\\r\"}、@code{\"\\e\"}、@code{\"\\d\"}で表されます。複雑なキーシーケンスの文字列表現はイベント成分の文字列表現を結合したものです。したがって@code{\"\\C-xl\"}はキーシーケンス@kbd{C-x l}を表します。"

#. type: Plain text
#: original_texis/keymaps.texi:70
msgid "Key sequences containing function keys, mouse button events, system events, or non-@acronym{ASCII} characters such as @kbd{C-=} or @kbd{H-a} cannot be represented as strings; they have to be represented as vectors."
msgstr "キーシーケンスにはファンクションキー、マウスボタンイベント、システムイベント、または@kbd{C-=}や@kbd{H-a}のような文字列で表現できない非@acronym{ASCII}文字が含まれます。これらはベクターとして表現する必要があります。"

#. type: Plain text
#: original_texis/keymaps.texi:74
msgid "In the vector representation, each element of the vector represents an input event, in its Lisp form.  @xref{Input Events}.  For example, the vector @code{[?\\C-x ?l]} represents the key sequence @kbd{C-x l}."
msgstr "ベクター表現ではベクターの各要素は1つの入力イベントをイベントのLisp形式で表します。@ref{Input Events}を参照してください。たとえばベクター@code{[?\\C-x ?l]}はキーシーケンス@kbd{C-x l}を表します。"

#. type: Plain text
#: original_texis/keymaps.texi:77
msgid "For examples of key sequences written in string and vector representations, @ref{Init Rebinding,,, emacs, The GNU Emacs Manual}."
msgstr "キーシーケンスを文字列やベクターによる表現で記述する例は、@ref{Init Rebinding,,, emacs, The GNU Emacs Manual}を参照してください。"

#. type: defun
#: original_texis/keymaps.texi:78
#, no-wrap
msgid "kbd keyseq-text"
msgstr "kbd keyseq-text"

#. type: defun
#: original_texis/keymaps.texi:86
msgid "This function converts the text @var{keyseq-text} (a string constant)  into a key sequence (a string or vector constant).  The contents of @var{keyseq-text} should use the same syntax as in the buffer invoked by the @kbd{C-x C-k @key{RET}} (@code{kmacro-edit-macro}) command; in particular, you must surround function key names with @samp{<@dots{}>}.  @xref{Edit Keyboard Macro,,, emacs, The GNU Emacs Manual}."
msgstr "この関数はテキスト@var{keyseq-text}(文字列定数)をキーシーケンス(文字列かベクターの定数)に変換する。@var{keyseq-text}の内容は@kbd{C-x C-k @key{RET}} (@code{kmacro-edit-macro})コマンドにより呼び出されたバッファー内と同じ構文を使用するべきである。特にファンクションキーの名前は@samp{<@dots{}>}で囲まなければならない。@ref{Edit Keyboard Macro,,, emacs, The GNU Emacs Manual}を参照のこと。"

#. type: example
#: original_texis/keymaps.texi:96
#, no-wrap
msgid ""
"(kbd \"C-x\") @result{} \"\\C-x\"\n"
"(kbd \"C-x C-f\") @result{} \"\\C-x\\C-f\"\n"
"(kbd \"C-x 4 C-f\") @result{} \"\\C-x4\\C-f\"\n"
"(kbd \"X\") @result{} \"X\"\n"
"(kbd \"RET\") @result{} \"\\^M\"\n"
"(kbd \"C-c SPC\") @result{} \"\\C-c@ \"\n"
"(kbd \"<f1> SPC\") @result{} [f1 32]\n"
"(kbd \"C-M-<down>\") @result{} [C-M-down]\n"
msgstr ""
"(kbd \"C-x\") @result{} \"\\C-x\"\n"
"(kbd \"C-x C-f\") @result{} \"\\C-x\\C-f\"\n"
"(kbd \"C-x 4 C-f\") @result{} \"\\C-x4\\C-f\"\n"
"(kbd \"X\") @result{} \"X\"\n"
"(kbd \"RET\") @result{} \"\\^M\"\n"
"(kbd \"C-c SPC\") @result{} \"\\C-c@ \"\n"
"(kbd \"<f1> SPC\") @result{} [f1 32]\n"
"(kbd \"C-M-<down>\") @result{} [C-M-down]\n"

#. type: cindex
#: original_texis/keymaps.texi:101
#, no-wrap
msgid "key binding"
msgstr "key binding"

#. type: cindex
#: original_texis/keymaps.texi:102
#, no-wrap
msgid "binding of a key"
msgstr "binding of a key"

#. type: cindex
#: original_texis/keymaps.texi:103
#, no-wrap
msgid "complete key"
msgstr "complete key"

#. type: cindex
#: original_texis/keymaps.texi:104
#, no-wrap
msgid "undefined key"
msgstr "undefined key"

#. type: Plain text
#: original_texis/keymaps.texi:108
msgid "A keymap is a Lisp data structure that specifies @dfn{key bindings} for various key sequences."
msgstr "キーマップはさまざまなキーシーケンスにたいして@dfn{キーバインディング(key binding)}を指定するLispデータ構造です。"

#. type: Plain text
#: original_texis/keymaps.texi:116
msgid "A single keymap directly specifies definitions for individual events.  When a key sequence consists of a single event, its binding in a keymap is the keymap's definition for that event.  The binding of a longer key sequence is found by an iterative process: first find the definition of the first event (which must itself be a keymap); then find the second event's definition in that keymap, and so on until all the events in the key sequence have been processed."
msgstr "1つのキーマップが、個々のイベントにたいする定義を直接指定します。単一のイベントでキーシーケンスが構成されるとき、そのキーシーケンスのキーマップ内でのバインディングは、そのイベントにたいするそのキーマップの定義です。それより長いキーシーケンスのバインディングは対話的プロセスによって見つけ出されます。まず最初にイベント(それ自身がキーマップでなければならない)の定義を探します。そして次にそのキーマップ内で2つ目のイベントを探すといったように、そのキーシーケンス内のすべてのイベントが処理されるまで、これを続けます。"

#. type: Plain text
#: original_texis/keymaps.texi:125
msgid "If the binding of a key sequence is a keymap, we call the key sequence a @dfn{prefix key}.  Otherwise, we call it a @dfn{complete key} (because no more events can be added to it).  If the binding is @code{nil}, we call the key @dfn{undefined}.  Examples of prefix keys are @kbd{C-c}, @kbd{C-x}, and @kbd{C-x 4}.  Examples of defined complete keys are @kbd{X}, @key{RET}, and @kbd{C-x 4 C-f}.  Examples of undefined complete keys are @kbd{C-x C-g}, and @kbd{C-c 3}.  @xref{Prefix Keys}, for more details."
msgstr "あるキーシーケンスのバインディングがキーマップであるような場合、わたしたちはそのキーシーケンスを@dfn{プレフィクスキー(prefix key)}と呼び、それ以外の場合には(それ以上イベントを追加できないので)@dfn{コンプリートキー(complete keyl}と呼んでいます。バインディングが@code{nil}の場合、わたしたちはそのキーを@dfn{未定義(undefined)}と呼びます。@kbd{C-c}、@kbd{C-x}、@kbd{C-x 4}などはプレフィクスキーの例です。@kbd{X}、@key{RET}、@kbd{C-x 4 C-f}などは定義されたコンプリートキーの例です。@kbd{C-x C-g}や@kbd{C-c 3}などは未定義なコンプリートキーの例です。詳細は@ref{Prefix Keys}を参照してください。"

#. type: Plain text
#: original_texis/keymaps.texi:134
msgid "The rule for finding the binding of a key sequence assumes that the intermediate bindings (found for the events before the last) are all keymaps; if this is not so, the sequence of events does not form a unit---it is not really one key sequence.  In other words, removing one or more events from the end of any valid key sequence must always yield a prefix key.  For example, @kbd{C-f C-n} is not a key sequence; @kbd{C-f} is not a prefix key, so a longer sequence starting with @kbd{C-f} cannot be a key sequence."
msgstr "キーシーケンスのバインディングを見つけ出すルールは、(最後のイベントの前までに見つかる)中間的なバインディングがすべてキーマップであると仮定します。もしそうでなければ、そのイベントシーケンスは単位を形成せず、実際の単一キーシーケンスではありません。言い換えると任意の有効なキーシーケンスから1つ以上のイベントを取り除くと、常にプレフィクスキーにならなければなりません。たとえば@kbd{C-f C-n}はキーシーケンスではありません。@kbd{C-f}はプレフィクスキーではないので、@kbd{C-f}で始まるこれより長いシーケンスは、キーシーケンスではあり得ないからです。"

#. type: Plain text
#: original_texis/keymaps.texi:140
msgid "The set of possible multi-event key sequences depends on the bindings for prefix keys; therefore, it can be different for different keymaps, and can change when bindings are changed.  However, a one-event sequence is always a key sequence, because it does not depend on any prefix keys for its well-formedness."
msgstr "利用可能な複数イベントキーシーケンスのセットは、プレフィクスキーにたいするバインディングに依存します。したがってこれはキーマップが異なれば異なるかもしれず、バインディングが変更されたときに変更されるかもしれません。しかし単一イベントキーシーケンスは整合性において任意のプレフィクスキーに依存しないので、常に単一のキーシーケンスです。"

#. type: Plain text
#: original_texis/keymaps.texi:150
msgid "At any time, several primary keymaps are @dfn{active}---that is, in use for finding key bindings.  These are the @dfn{global map}, which is shared by all buffers; the @dfn{local keymap}, which is usually associated with a specific major mode; and zero or more @dfn{minor mode keymaps}, which belong to currently enabled minor modes.  (Not all minor modes have keymaps.)  The local keymap bindings shadow (i.e., take precedence over) the corresponding global bindings.  The minor mode keymaps shadow both local and global keymaps.  @xref{Active Keymaps}, for details."
msgstr "常に複数のプライマリーキーマップ(primary keymap: 主キーマップ)がアクティブであり、これらはキーバインディングを見つけるために使用されます。すべてのバッファーで共有される@dfn{グローバルキーマップ(global map)}というキーマップが存在します。@dfn{ローカルキーマップ(local keymap)}は通常は特定のメジャーモードに関連します。そして0個以上の@dfn{マイナーモードキーマップ(minor mode keymap)}はカレントで有効なマイナーモードに属します(すべてのマイナーモードがキーマップをもつわけでなない)。ローカルキーマップは対応するグローバルバインディングをshadow(訳注: 隠すという意味)します。マイナーモードキーマップは、ローカルキーマップとグローバルキーマップの両方をshadowします。詳細は@ref{Active Keymaps}を参照してください。"

#. type: cindex
#: original_texis/keymaps.texi:153
#, no-wrap
msgid "format of keymaps"
msgstr "format of keymaps"

#. type: cindex
#: original_texis/keymaps.texi:154
#, no-wrap
msgid "keymap format"
msgstr "keymap format"

#. type: cindex
#: original_texis/keymaps.texi:155
#, no-wrap
msgid "full keymap"
msgstr "full keymap"

#. type: cindex
#: original_texis/keymaps.texi:156
#, no-wrap
msgid "sparse keymap"
msgstr "sparse keymap"

#. type: Plain text
#: original_texis/keymaps.texi:163
msgid "Each keymap is a list whose @sc{car} is the symbol @code{keymap}.  The remaining elements of the list define the key bindings of the keymap.  A symbol whose function definition is a keymap is also a keymap.  Use the function @code{keymapp} (see below) to test whether an object is a keymap."
msgstr "キーマップはそれぞれ@sc{car}がシンボル@code{keymap}であるようなリストです。このリストの残りの要素はそのキーマップのキーバインディングを定義します。関数定義がキーマップであるようなシンボルもキーマップです。あるオブジェクトがキーマップかどうかテストするには、関数@code{keymapp}(以下参照)を使用してください。"

#. type: Plain text
#: original_texis/keymaps.texi:166
msgid "Several kinds of elements may appear in a keymap, after the symbol @code{keymap} that begins it:"
msgstr "キーマップを開始するシンボル@code{keymap}の後には、いくつかの種類の要素が出現します:"

#. type: item
#: original_texis/keymaps.texi:168
#, no-wrap
msgid "(@var{type} .@: @var{binding})"
msgstr "(@var{type} .@: @var{binding})"

#. type: table
#: original_texis/keymaps.texi:173
msgid "This specifies one binding, for events of type @var{type}.  Each ordinary binding applies to events of a particular @dfn{event type}, which is always a character or a symbol.  @xref{Classifying Events}.  In this kind of binding, @var{binding} is a command."
msgstr "これは型@var{type}のイベントにたいする1つのバインディングを指定する。通常のバインディングはそれぞれ、常に文字かシンボルであるような特定の@dfn{イベント型(event type)}のイベントに適用される。@ref{Classifying Events}を参照のこと。この種のバインディングでは、@var{binding}はコマンドである。"

#. type: item
#: original_texis/keymaps.texi:174
#, no-wrap
msgid "(@var{type} @var{item-name} .@: @var{binding})"
msgstr "(@var{type} @var{item-name} .@: @var{binding})"

#. type: table
#: original_texis/keymaps.texi:177
msgid "This specifies a binding which is also a simple menu item that displays as @var{item-name} in the menu.  @xref{Simple Menu Items}."
msgstr "これはメニュー内で@var{item-name}として表示されるシンプルなメニューアイテムでもあるようなバインディングを指定する。@ref{Simple Menu Items}を参照のこと。"

#. type: item
#: original_texis/keymaps.texi:178
#, no-wrap
msgid "(@var{type} @var{item-name} @var{help-string} .@: @var{binding})"
msgstr "(@var{type} @var{item-name} @var{help-string} .@: @var{binding})"

#. type: table
#: original_texis/keymaps.texi:180
msgid "This is a simple menu item with help string @var{help-string}."
msgstr "これはヘルプ文字列@var{help-string}のシンプルなメニューアイテムである。"

#. type: item
#: original_texis/keymaps.texi:181
#, no-wrap
msgid "(@var{type} menu-item .@: @var{details})"
msgstr "(@var{type} menu-item .@: @var{details})"

#. type: table
#: original_texis/keymaps.texi:184
msgid "This specifies a binding which is also an extended menu item.  This allows use of other features.  @xref{Extended Menu Items}."
msgstr "これは拡張されたメニューアイテムでもあるようなバインディングを指定する。これは他の機能も使用できる。@ref{Extended Menu Items}を参照のこと。"

#. type: item
#: original_texis/keymaps.texi:185
#, no-wrap
msgid "(t .@: @var{binding})"
msgstr "(t .@: @var{binding})"

#. type: cindex
#: original_texis/keymaps.texi:186
#, no-wrap
msgid "default key binding"
msgstr "default key binding"

#. type: table
#: original_texis/keymaps.texi:193
msgid "This specifies a @dfn{default key binding}; any event not bound by other elements of the keymap is given @var{binding} as its binding.  Default bindings allow a keymap to bind all possible event types without having to enumerate all of them.  A keymap that has a default binding completely masks any lower-precedence keymap, except for events explicitly bound to @code{nil} (see below)."
msgstr "これは@dfn{デフォルトキーバインディング(default key binding)}を指定する。キーマップの他の要素でバインドされないイベントは、バインディングとして@var{binding}が与えられる。デフォルトバインディングにより、利用可能なすべてのイベント型を列挙することなくバインドできる。デフォルトバインディングをもつキーマップは、明示的に@code{nil}にバインドされるイベント(以下参照)を除いて、より低い優先度にあるすべてのキーマップをマスクする。"

#. type: var{#1}
#: original_texis/keymaps.texi:194
#, no-wrap
msgid "char-table"
msgstr "char-table"

#. type: table
#: original_texis/keymaps.texi:201
msgid "If an element of a keymap is a char-table, it counts as holding bindings for all character events with no modifier bits (@pxref{modifier bits}): the element whose index is @var{c} is the binding for the character @var{c}.  This is a compact way to record lots of bindings.  A keymap with such a char-table is called a @dfn{full keymap}.  Other keymaps are called @dfn{sparse keymaps}."
msgstr "キーマップのある要素が文字テーブル(char-table)なら、それは修飾ビットなしのすべての文字イベントにたいするバインディングを保持するとみなされる(@ref{modifier bits}を参照)。インデックス@var{c}の要素は文字@var{c}にたいしてバインドされる。これは多量のバインディングを記録するためのコンパクトな方法である。そのような文字テーブルのキーマップは、@dfn{fullキーマップ(full keymap: 完全なキーマップ)}と呼ばれる。それにたいして他のキーマップは@dfn{sparseキーマップ(sparse keymaps: 疎なキーマップ)}と呼ばれる。"

#. type: var{#1}
#: original_texis/keymaps.texi:202
#, no-wrap
msgid "vector"
msgstr "vector"

#. type: table
#: original_texis/keymaps.texi:210
msgid "This kind of element is similar to a char-table: the element whose index is @var{c} is the binding for the character @var{c}.  Since the range of characters that can be bound this way is limited by the vector size, and vector creation allocates space for all character codes from 0 up, this format should not be used except for creating menu keymaps (@pxref{Menu Keymaps}), where the bindings themselves don't matter."
msgstr "この種の要素は文字テーブルと類似する。インデックス@var{c}の要素は文字@var{c}にバインドされる。この方法でバインド可能な文字の範囲はそのベクターのサイズに制限され、かつベクターの作成により0からすべての文字コードまでスペースが割り当てられるので、バインディング自身が問題とならないメニューキーマップ(@ref{Menu Keymaps}を参照)の作成以外では、このフォーマットを使用しないこと。"

#. type: var{#1}
#: original_texis/keymaps.texi:211
#, no-wrap
msgid "string"
msgstr "string"

#. type: cindex
#: original_texis/keymaps.texi:212
#, no-wrap
msgid "keymap prompt string"
msgstr "keymap prompt string"

#. type: cindex
#: original_texis/keymaps.texi:213
#, no-wrap
msgid "overall prompt string"
msgstr "overall prompt string"

#. type: cindex
#: original_texis/keymaps.texi:214
#, no-wrap
msgid "prompt string of keymap"
msgstr "prompt string of keymap"

#. type: table
#: original_texis/keymaps.texi:219
msgid "Aside from elements that specify bindings for keys, a keymap can also have a string as an element.  This is called the @dfn{overall prompt string} and makes it possible to use the keymap as a menu.  @xref{Defining Menus}."
msgstr "キーにたいするバインディングを指定する要素は別として、キーマップは要素として文字列ももつことができる。これは@dfn{overallプロンプト文字列(overall prompt string: 全般的なプロンプト文字列)}と呼ばれ、メニューとしてキーマップを使用することを可能にする。@ref{Defining Menus}を参照のこと。"

#. type: item
#: original_texis/keymaps.texi:220
#, no-wrap
msgid "(keymap @dots{})"
msgstr "(keymap @dots{})"

#. type: table
#: original_texis/keymaps.texi:224
msgid "If an element of a keymap is itself a keymap, it counts as if this inner keymap were inlined in the outer keymap.  This is used for multiple-inheritance, such as in @code{make-composed-keymap}."
msgstr "キーマップのある要素それ自身がキーマップなら、外側のキーマップ内でこれが内側のキーマップとしてinline指定されているかのようにみなされる。これは@code{make-composed-keymap}内で行なわれるような多重継承にたいして使用される。"

#. type: Plain text
#: original_texis/keymaps.texi:232
msgid "When the binding is @code{nil}, it doesn't constitute a definition but it does take precedence over a default binding or a binding in the parent keymap.  On the other hand, a binding of @code{nil} does @emph{not} override lower-precedence keymaps; thus, if the local map gives a binding of @code{nil}, Emacs uses the binding from the global map."
msgstr "バインディングが@code{nil}なら、それは定義の構成要素ではありませんが、デフォルトバインディングや親キーマップ内のバインディングに優先されます。一方@code{nil}のバインディングは、より低い優先度のキーマップを@emph{オーバーライドしません}。したがってローカルマップで@code{nil}のバインディングが与えられると、Emacsはグローバルマップのバインディングを使用します。"

#. type: cindex
#: original_texis/keymaps.texi:233
#, no-wrap
msgid "meta characters lookup"
msgstr "meta characters lookup"

#. type: Plain text
#: original_texis/keymaps.texi:241
msgid "Keymaps do not directly record bindings for the meta characters.  Instead, meta characters are regarded for purposes of key lookup as sequences of two characters, the first of which is @key{ESC} (or whatever is currently the value of @code{meta-prefix-char}).  Thus, the key @kbd{M-a} is internally represented as @kbd{@key{ESC} a}, and its global binding is found at the slot for @kbd{a} in @code{esc-map} (@pxref{Prefix Keys})."
msgstr "キーマップはメタ文字にたいするバインディングを直接記録しません。かわりにメタ文字は１文字目が@key{ESC}(または何であれ@code{meta-prefix-char}のカレント値)であるような、2文字のキーシーケンスをルックアップするものとみなされます。したがってキー@kbd{M-a}は内部的には@kbd{@key{ESC} a}で表され、そのグローバルバインディングは@code{esc-map}内の@kbd{a}にたいするスロットで見つけることができます(@ref{Prefix Keys}を参照)。"

#. type: Plain text
#: original_texis/keymaps.texi:245
msgid "This conversion applies only to characters, not to function keys or other input events; thus, @kbd{M-@key{end}} has nothing to do with @kbd{@key{ESC} @key{end}}."
msgstr "この変換は文字にたいしてのみ適用され、ファンクションキーや他の入力イベントには適用されないので@kbd{M-@key{end}}は@kbd{@key{ESC} @key{end}}と何も関係ありません。"

#. type: Plain text
#: original_texis/keymaps.texi:250
msgid "Here as an example is the local keymap for Lisp mode, a sparse keymap.  It defines bindings for @key{DEL}, @kbd{C-c C-z}, @kbd{C-M-q}, and @kbd{C-M-x} (the actual value also contains a menu binding, which is omitted here for the sake of brevity)."
msgstr "以下に例としてLispモードにたいするローカルキーマップ(sparseキーマップ)を挙げます。以下では@key{DEL}、@kbd{C-c C-z}、@kbd{C-M-q}、@kbd{C-M-x}にたいするバインディングを定義しています(実際の値はメニューバインディングも含まれるが簡潔にするためここでは省略)。"

#. type: group
#: original_texis/keymaps.texi:255
#, no-wrap
msgid ""
"lisp-mode-map\n"
"@result{}\n"
msgstr ""
"lisp-mode-map\n"
"@result{}\n"

#. type: group
#: original_texis/keymaps.texi:261
#, no-wrap
msgid ""
"(keymap\n"
" (3 keymap\n"
"    ;; @kbd{C-c C-z}\n"
"    (26 . run-lisp))\n"
msgstr ""
"(keymap\n"
" (3 keymap\n"
"    ;; @kbd{C-c C-z}\n"
"    (26 . run-lisp))\n"

#. type: group
#: original_texis/keymaps.texi:266
#, no-wrap
msgid ""
" (27 keymap\n"
"     ;; @r{@kbd{C-M-x}, treated as @kbd{@key{ESC} C-x}}\n"
"     (24 . lisp-send-defun))\n"
msgstr ""
" (27 keymap\n"
"     ;; @r{@kbd{C-M-x}は@kbd{@key{ESC} C-x}として扱われる}\n"
"     (24 . lisp-send-defun))\n"

#. type: group
#: original_texis/keymaps.texi:272
#, no-wrap
msgid ""
" ;; @r{This part is inherited from @code{lisp-mode-shared-map}.}\n"
" keymap\n"
" ;; @key{DEL}\n"
" (127 . backward-delete-char-untabify)\n"
msgstr ""
" ;; @r{この部分は@code{lisp-mode-shared-map}から継承}\n"
" keymap\n"
" ;; @key{DEL}\n"
" (127 . backward-delete-char-untabify)\n"

#. type: group
#: original_texis/keymaps.texi:277
#, no-wrap
msgid ""
" (27 keymap\n"
"     ;; @r{@kbd{C-M-q}, treated as @kbd{@key{ESC} C-q}}\n"
"     (17 . indent-sexp)))\n"
msgstr ""
" (27 keymap\n"
"     ;; @r{@kbd{C-M-q}は@kbd{@key{ESC} C-q}として扱われる}\n"
"     (17 . indent-sexp)))\n"

#. type: defun
#: original_texis/keymaps.texi:280
#, no-wrap
msgid "keymapp object"
msgstr "keymapp object"

#. type: defun
#: original_texis/keymaps.texi:285
msgid "This function returns @code{t} if @var{object} is a keymap, @code{nil} otherwise.  More precisely, this function tests for a list whose @sc{car} is @code{keymap}, or for a symbol whose function definition satisfies @code{keymapp}."
msgstr "この関数は@var{object}がキーマップなら@code{t}、それ以外は@code{nil}をリターンする。より正確にはこの関数はリストにたいしてその@sc{car}が@code{keymap}か、あるいはシンボルにたいしてその関数定義が@code{keymapp}かどうかをテストする。"

#. type: group
#: original_texis/keymaps.texi:290
#, no-wrap
msgid ""
"(keymapp '(keymap))\n"
"    @result{} t\n"
msgstr ""
"(keymapp '(keymap))\n"
"    @result{} t\n"

#. type: group
#: original_texis/keymaps.texi:295
#, no-wrap
msgid ""
"(fset 'foo '(keymap))\n"
"(keymapp 'foo)\n"
"    @result{} t\n"
msgstr ""
"(fset 'foo '(keymap))\n"
"(keymapp 'foo)\n"
"    @result{} t\n"

#. type: group
#: original_texis/keymaps.texi:299
#, no-wrap
msgid ""
"(keymapp (current-global-map))\n"
"    @result{} t\n"
msgstr ""
"(keymapp (current-global-map))\n"
"    @result{} t\n"

#. type: cindex
#: original_texis/keymaps.texi:305
#, no-wrap
msgid "creating keymaps"
msgstr "creating keymaps"

#. type: Plain text
#: original_texis/keymaps.texi:308
msgid "Here we describe the functions for creating keymaps."
msgstr "以下はキーマップを作成する関数です。"

#. type: defun
#: original_texis/keymaps.texi:309
#, no-wrap
msgid "make-sparse-keymap &optional prompt"
msgstr "make-sparse-keymap &optional prompt"

#. type: defun
#: original_texis/keymaps.texi:314
msgid "This function creates and returns a new sparse keymap with no entries.  (A sparse keymap is the kind of keymap you usually want.)  The new keymap does not contain a char-table, unlike @code{make-keymap}, and does not bind any events."
msgstr "この関数はエントリーをもたない新たなsparseキーマップを作成してそれをリターンする(sparseキーマップはあなたが通常望む類のキーマップのこと)。@code{make-keymap}と異なり新たなキーマップは文字テーブルを含まず、何のイベントもバインドしない。"

#. type: group
#: original_texis/keymaps.texi:319
#, no-wrap
msgid ""
"(make-sparse-keymap)\n"
"    @result{} (keymap)\n"
msgstr ""
"(make-sparse-keymap)\n"
"    @result{} (keymap)\n"

#. type: defun
#: original_texis/keymaps.texi:329
msgid "If you specify @var{prompt}, that becomes the overall prompt string for the keymap.  You should specify this only for menu keymaps (@pxref{Defining Menus}).  A keymap with an overall prompt string will always present a mouse menu or a keyboard menu if it is active for looking up the next input event.  Don't specify an overall prompt string for the main map of a major or minor mode, because that would cause the command loop to present a keyboard menu every time."
msgstr "@var{prompt}を指定すると、それはキーマップにたいするoverallプロンプト文字列になる。これはメニューキーマップ(@ref{Defining Menus}を参照)にたいしてのみ指定すべきである。overallプロンプト文字列をともなうキーマップがアクティブなら、次の入力イベントのルックアップにたいしてマウスメニューとキーボードメニューを常に提示する。これはコマンドループにたいして毎回キーボードメニューを提示するので、overallプロンプト文字列をメインマップ、メジャーモードマップ、マイナーモードマップに指定しないこと。"

#. type: defun
#: original_texis/keymaps.texi:331
#, no-wrap
msgid "make-keymap &optional prompt"
msgstr "make-keymap &optional prompt"

#. type: defun
#: original_texis/keymaps.texi:338
msgid "This function creates and returns a new full keymap.  That keymap contains a char-table (@pxref{Char-Tables}) with slots for all characters without modifiers.  The new keymap initially binds all these characters to @code{nil}, and does not bind any other kind of event.  The argument @var{prompt} specifies a prompt string, as in @code{make-sparse-keymap}."
msgstr "この関数は新たなfullキーマップを作成してそれをリターンする。このキーマップは修飾されないすべての文字にたいするスロットをもつ文字テーブル(@ref{Char-Tables}を参照)を含む。この新たなキーマップは初期状態ではすべての文字、およびその他の種類のイベントが@code{nil}にバインドされている。引数@var{prompt}は@code{make-sparse-keymap}のようにプロンプト文字列を指定する。"

#. type: group
#: original_texis/keymaps.texi:345
#, no-wrap
msgid ""
"(make-keymap)\n"
"    @result{} (keymap #^[nil nil keymap nil nil nil @dots{}])\n"
msgstr ""
"(make-keymap)\n"
"    @result{} (keymap #^[nil nil keymap nil nil nil @dots{}])\n"

#. type: defun
#: original_texis/keymaps.texi:350
msgid "A full keymap is more efficient than a sparse keymap when it holds lots of bindings; for just a few, the sparse keymap is better."
msgstr "fullキーマップは多くのスロットを保持するときはsparseキーマップより効果的であり、少ししかスロットを保持しないときはsparseキーマップのほうが適している。"

#. type: defun
#: original_texis/keymaps.texi:352
#, no-wrap
msgid "copy-keymap keymap"
msgstr "copy-keymap keymap"

#. type: defun
#: original_texis/keymaps.texi:357
msgid "This function returns a copy of @var{keymap}.  This is almost never needed.  If you want a keymap that's like another yet with a few changes, you should use map inheritance rather than copying.  I.e., something like:"
msgstr "この関数は@var{keymap}のコピーをリターンする。これはほとんど必要ないだろう。ほとんど差のないキーマップが必要なら、コピーより以下のように継承を使用するべきである:"

#. type: group
#: original_texis/keymaps.texi:364
#, no-wrap
msgid ""
"(let ((map (make-sparse-keymap)))\n"
"  (set-keymap-parent map <theirmap>)\n"
"  (define-key map ...)\n"
"  ...)\n"
msgstr ""
"(let ((map (make-sparse-keymap)))\n"
"  (set-keymap-parent map <theirmap>)\n"
"  (define-key map ...)\n"
"  ...)\n"

#. type: defun
#: original_texis/keymaps.texi:373
msgid "When performing @code{copy-keymap}, any keymaps that appear directly as bindings in @var{keymap} are also copied recursively, and so on to any number of levels.  However, recursive copying does not take place when the definition of a character is a symbol whose function definition is a keymap; the same symbol appears in the new copy."
msgstr "@code{copy-keymap}を処理する際には、@var{keymap}内でバインディングとして直接出現するすべてのキーマップも、すべてのレベルまで再帰的にコピーされる。しかしある文字の定義が関数定義にキーマップをもつ関数のときには再帰的なコピーは行われず、新たにコピーされたキーマップには同じシンボルがコピーされる。"

#. type: group
#: original_texis/keymaps.texi:378
#, no-wrap
msgid ""
"(setq map (copy-keymap (current-local-map)))\n"
"@result{} (keymap\n"
msgstr ""
"(setq map (copy-keymap (current-local-map)))\n"
"@result{} (keymap\n"

#. type: group
#: original_texis/keymaps.texi:385
#, no-wrap
msgid ""
"     ;; @r{(This implements meta characters.)}\n"
"     (27 keymap\n"
"         (83 . center-paragraph)\n"
"         (115 . center-line))\n"
"     (9 . tab-to-tab-stop))\n"
msgstr ""
"     ;; @r{(これはメタ文字を実装する)}\n"
"     (27 keymap\n"
"         (83 . center-paragraph)\n"
"         (115 . center-line))\n"
"     (9 . tab-to-tab-stop))\n"

#. type: group
#: original_texis/keymaps.texi:390
#, no-wrap
msgid ""
"(eq map (current-local-map))\n"
"    @result{} nil\n"
msgstr ""
"(eq map (current-local-map))\n"
"    @result{} nil\n"

#. type: group
#: original_texis/keymaps.texi:394
#, no-wrap
msgid ""
"(equal map (current-local-map))\n"
"    @result{} t\n"
msgstr ""
"(equal map (current-local-map))\n"
"    @result{} t\n"

#. type: cindex
#: original_texis/keymaps.texi:400
#, no-wrap
msgid "keymap inheritance"
msgstr "keymap inheritance"

#. type: cindex
#: original_texis/keymaps.texi:401
#, no-wrap
msgid "inheritance, keymap"
msgstr "inheritance, keymap"

#. type: Plain text
#: original_texis/keymaps.texi:405
msgid "A keymap can inherit the bindings of another keymap, which we call the @dfn{parent keymap}.  Such a keymap looks like this:"
msgstr "キーマップは他のキーマップを継承することができ、この継承元のキーマップを@dfn{親キーマップ(parent keymap)}と呼びます。そのようなキーマップは以下のようなキーマップです:"

#. type: example
#: original_texis/keymaps.texi:408
#, no-wrap
msgid "(keymap @var{elements}@dots{} . @var{parent-keymap})\n"
msgstr "(keymap @var{elements}@dots{} . @var{parent-keymap})\n"

#. type: Plain text
#: original_texis/keymaps.texi:414
msgid "The effect is that this keymap inherits all the bindings of @var{parent-keymap}, whatever they may be at the time a key is looked up, but can add to them or override them with @var{elements}."
msgstr "これにはそのキーマップのキールックアップ時に@var{parent-keymap}のすべてのバインディングを継承するものの、それらにバインディングを追加したり@var{elements}でオーバーライドできるという効果があります。"

#. type: Plain text
#: original_texis/keymaps.texi:422
msgid "If you change the bindings in @var{parent-keymap} using @code{define-key} or other key-binding functions, these changed bindings are visible in the inheriting keymap, unless shadowed by the bindings made by @var{elements}.  The converse is not true: if you use @code{define-key} to change bindings in the inheriting keymap, these changes are recorded in @var{elements}, but have no effect on @var{parent-keymap}."
msgstr "@code{define-key}や他のキーバインディング関数を使用して@var{parent-keymap}内のバインディングを変更すると、変更されたバインディングは@var{elements}で作られたバインディングにshadowされない限り継承されたキーマップ内で可視になります。逆は真ではありません。@code{define-key}を使用して継承されたキーマップ内のバインディングを変更すると、これらの変更は@var{elements}内に記録されますが@var{parent-keymap}に影響はありません。"

#. type: Plain text
#: original_texis/keymaps.texi:427
msgid "The proper way to construct a keymap with a parent is to use @code{set-keymap-parent}; if you have code that directly constructs a keymap with a parent, please convert the program to use @code{set-keymap-parent} instead."
msgstr "親キーマップからキーマップを構築するには@code{set-keymap-parent}を使用するのが正しい方法です。親キーマップから直接キーマップを構築するコードがあるなら、かわりに@code{set-keymap-parent}を使用するようにプログラムを変更してください。"

#. type: defun
#: original_texis/keymaps.texi:428
#, no-wrap
msgid "keymap-parent keymap"
msgstr "keymap-parent keymap"

#. type: defun
#: original_texis/keymaps.texi:431
msgid "This returns the parent keymap of @var{keymap}.  If @var{keymap} has no parent, @code{keymap-parent} returns @code{nil}."
msgstr "これは@var{keymap}の親キーマップをリターンする。@var{keymap}に親キーマップがなければ@code{keymap-parent}は@code{nil}をリターンする。"

#. type: defun
#: original_texis/keymaps.texi:433
#, no-wrap
msgid "set-keymap-parent keymap parent"
msgstr "set-keymap-parent keymap parent"

#. type: defun
#: original_texis/keymaps.texi:437
msgid "This sets the parent keymap of @var{keymap} to @var{parent}, and returns @var{parent}.  If @var{parent} is @code{nil}, this function gives @var{keymap} no parent at all."
msgstr "これは@var{keymap}の親キーマップを@var{parent}にセットして@var{parent}をリターンする。@var{parent}が@code{nil}ならこの関数は@var{keymap}に親キーマップを与えない。"

#. type: defun
#: original_texis/keymaps.texi:441
msgid "If @var{keymap} has submaps (bindings for prefix keys), they too receive new parent keymaps that reflect what @var{parent} specifies for those prefix keys."
msgstr "@var{keymap}がサブマップ(プレフィクスキーにたいするバインディング)をもつ場合は、それらも新たな親キーマップを受け取ってそれらのプレフィクスキーにたいして@var{parent}が何を指定するかが反映される。"

#. type: Plain text
#: original_texis/keymaps.texi:445
msgid "Here is an example showing how to make a keymap that inherits from @code{text-mode-map}:"
msgstr "以下は@code{text-mode-map}から継承してキーマップを作成する方法を示す例です:"

#. type: example
#: original_texis/keymaps.texi:450
#, no-wrap
msgid ""
"(let ((map (make-sparse-keymap)))\n"
"  (set-keymap-parent map text-mode-map)\n"
"  map)\n"
msgstr ""
"(let ((map (make-sparse-keymap)))\n"
"  (set-keymap-parent map text-mode-map)\n"
"  map)\n"

#. type: Plain text
#: original_texis/keymaps.texi:457
msgid "A non-sparse keymap can have a parent too, but this is not very useful.  A non-sparse keymap always specifies something as the binding for every numeric character code without modifier bits, even if it is @code{nil}, so these character's bindings are never inherited from the parent keymap."
msgstr "非sparseキーマップも親キーマップをもつことができますが便利とは言えません。非sparseキーマップは修飾ビットをもたないすべての数値文字コードにたいするバインディングとして、たとえそれが@code{nil}であっても常に何かを指定するので、これらの文字のバインディングが親キーマップから継承されることは決してないのです。"

#. type: cindex
#: original_texis/keymaps.texi:458
#, no-wrap
msgid "keymap inheritance from multiple maps"
msgstr "keymap inheritance from multiple maps"

#. type: Plain text
#: original_texis/keymaps.texi:461
msgid "Sometimes you want to make a keymap that inherits from more than one map.  You can use the function @code{make-composed-keymap} for this."
msgstr "複数のマップからキーマップを継承したいときがあるかもしれません。これにたいして関数@code{make-composed-keymap}が使用できます。"

#. type: defun
#: original_texis/keymaps.texi:462
#, no-wrap
msgid "make-composed-keymap maps &optional parent"
msgstr "make-composed-keymap maps &optional parent"

#. type: defun
#: original_texis/keymaps.texi:471
msgid "This function returns a new keymap composed of the existing keymap(s)  @var{maps}, and optionally inheriting from a parent keymap @var{parent}.  @var{maps} can be a single keymap or a list of more than one.  When looking up a key in the resulting new map, Emacs searches in each of the @var{maps} in turn, and then in @var{parent}, stopping at the first match.  A @code{nil} binding in any one of @var{maps} overrides any binding in @var{parent}, but it does not override any non-@code{nil} binding in any other of the @var{maps}."
msgstr "この関数は既存のキーマップから構成される新たなキーマップをリターンする。またオプションで親キーマップ@var{parent}から継承を行う。@var{maps}には単一のキーマップ、または複数のキーマップのリストを指定できる。リターンされた新たなマップ内でキーをルックアップするとき、Emacsは@var{maps}内のキーマップを順に検索してから@var{parent}内を検索する。この検索は最初のマッチで停止する。@var{maps}のいずれか1つのキーマップ内の@code{nil}バインディングは、@var{parent}内のすべてのバインディングをオーバーライドするが、@var{maps}にないキーマップの非@code{nil}なバインディングはオーバーライドしない。"

#. type: Plain text
#: original_texis/keymaps.texi:476
msgid "@code{help-mode-map}, such that it inherits from both @code{button-buffer-map} and @code{special-mode-map}:"
msgstr "たとえば以下は@code{button-buffer-map}と@code{special-mode-map}の両方を継承する@code{help-mode-map}のようなキーマップの親キーマップをEmacsがセットする方法です:"

#. type: example
#: original_texis/keymaps.texi:483
#, no-wrap
msgid ""
"(defvar help-mode-map\n"
"  (let ((map (make-sparse-keymap)))\n"
"    (set-keymap-parent map\n"
"      (make-composed-keymap button-buffer-map special-mode-map))\n"
"    ... map) ... )\n"
msgstr ""
"(defvar help-mode-map\n"
"  (let ((map (make-sparse-keymap)))\n"
"    (set-keymap-parent map\n"
"      (make-composed-keymap button-buffer-map special-mode-map))\n"
"    ... map) ... )\n"

#. type: cindex
#: original_texis/keymaps.texi:488
#, no-wrap
msgid "prefix key"
msgstr "prefix key"

#. type: Plain text
#: original_texis/keymaps.texi:495
msgid "A @dfn{prefix key} is a key sequence whose binding is a keymap.  The keymap defines what to do with key sequences that extend the prefix key.  For example, @kbd{C-x} is a prefix key, and it uses a keymap that is also stored in the variable @code{ctl-x-map}.  This keymap defines bindings for key sequences starting with @kbd{C-x}."
msgstr "@dfn{プレフィクスキー(prefix key)}とは、バインディングがキーマップであるようなキーシーケンスです。このキーマップはプレフィクスキーを拡張するキーシーケンスが何を行うかを定義します。たとえば@kbd{C-x}はプレフィクスキーであり、これはキーマップを使用してそのキーマップは変数@code{ctl-x-map}にも格納されています。このキーマップは@kbd{C-x}で始まるキーシーケンスにたいするバインディングを定義します。"

#. type: Plain text
#: original_texis/keymaps.texi:498
msgid "Some of the standard Emacs prefix keys use keymaps that are also found in Lisp variables:"
msgstr "標準的なEmacsのプレフィクスキーのいくつかは、Lisp変数でも見い出すことができるキーマップを使用しています:"

#. type: vindex
#: original_texis/keymaps.texi:501
#, no-wrap
msgid "esc-map"
msgstr "esc-map"

#. type: findex
#: original_texis/keymaps.texi:502
#, no-wrap
msgid "ESC-prefix"
msgstr "ESC-prefix"

#. type: itemize
#: original_texis/keymaps.texi:506
msgid "@code{esc-map} is the global keymap for the @key{ESC} prefix key.  Thus, the global definitions of all meta characters are actually found here.  This map is also the function definition of @code{ESC-prefix}."
msgstr "@code{esc-map}はプレフィクスキー@key{ESC}にたいするグローバルキーマップである。したがってすべてのメタ文字にたいする定義は、このキーマップで見い出すことができる。このマップは@code{ESC-prefix}の関数定義でもある。"

#. type: kbd{#1}
#: original_texis/keymaps.texi:508
#, no-wrap
msgid "C-h"
msgstr "C-h"

#. type: itemize
#: original_texis/keymaps.texi:510
msgid "@code{help-map} is the global keymap for the @kbd{C-h} prefix key."
msgstr "@code{help-map}はプレフィクスキー@kbd{C-h}にたいするグローバルキーマップである。"

#. type: kbd{#1}
#: original_texis/keymaps.texi:512
#, no-wrap
msgid "C-c"
msgstr "C-c"

#. type: vindex
#: original_texis/keymaps.texi:513
#, no-wrap
msgid "mode-specific-map"
msgstr "mode-specific-map"

#. type: itemize
#: original_texis/keymaps.texi:519
msgid "@code{mode-specific-map} is the global keymap for the prefix key @kbd{C-c}.  This map is actually global, not mode-specific, but its name provides useful information about @kbd{C-c} in the output of @kbd{C-h b} (@code{display-bindings}), since the main use of this prefix key is for mode-specific bindings."
msgstr "@code{mode-specific-map}はプレフィクスキー@kbd{C-c}にたいするグローバルキーマップである。このマップは実際にはモード特有(mode-specific)ではなくグローバルであるが、このプレフィクスキーは主にモード特有なバインディングに使用されるので、@kbd{C-h b} (@code{display-bindings})の出力内の@kbd{C-c}に関する情報で、この名前は有意義な情報を提供する。"

#. type: kbd{#1}
#: original_texis/keymaps.texi:521
#, no-wrap
msgid "C-x"
msgstr "C-x"

#. type: vindex
#: original_texis/keymaps.texi:522
#, no-wrap
msgid "ctl-x-map"
msgstr "ctl-x-map"

#. type: findex
#: original_texis/keymaps.texi:523
#, no-wrap
msgid "Control-X-prefix"
msgstr "Control-X-prefix"

#. type: itemize
#: original_texis/keymaps.texi:527
msgid "@code{ctl-x-map} is the global keymap used for the @kbd{C-x} prefix key.  This map is found via the function cell of the symbol @code{Control-X-prefix}."
msgstr "@code{ctl-x-map}はプレフィクスキー@kbd{C-x}にたいして使用されるグローバルキーマップである。このマップはシンボル@code{Control-X-prefix}の関数セルを通して見つけることができる。"

#. type: kbd{#1}
#: original_texis/keymaps.texi:529
#, no-wrap
msgid "C-x @key{RET}"
msgstr "C-x @key{RET}"

#. type: vindex
#: original_texis/keymaps.texi:530
#, no-wrap
msgid "mule-keymap"
msgstr "mule-keymap"

#. type: itemize
#: original_texis/keymaps.texi:533
msgid "@code{mule-keymap} is the global keymap used for the @kbd{C-x @key{RET}} prefix key."
msgstr "@code{mule-keymap}はプレフィクスキー@kbd{C-x @key{RET}} にたいして使用されるグローバルキーマップである。"

#. type: kbd{#1}
#: original_texis/keymaps.texi:535
#, no-wrap
msgid "C-x 4"
msgstr "C-x 4"

#. type: vindex
#: original_texis/keymaps.texi:536
#, no-wrap
msgid "ctl-x-4-map"
msgstr "ctl-x-4-map"

#. type: itemize
#: original_texis/keymaps.texi:539
msgid "@code{ctl-x-4-map} is the global keymap used for the @kbd{C-x 4} prefix key."
msgstr "@code{ctl-x-4-map}はプレフィクスキー@kbd{C-x 4}にたいして使用されるグローバルキーマップである。"

#. type: kbd{#1}
#: original_texis/keymaps.texi:541
#, no-wrap
msgid "C-x 5"
msgstr "C-x 5"

#. type: vindex
#: original_texis/keymaps.texi:542
#, no-wrap
msgid "ctl-x-5-map"
msgstr "ctl-x-5-map"

#. type: itemize
#: original_texis/keymaps.texi:545
msgid "@code{ctl-x-5-map} is the global keymap used for the @kbd{C-x 5} prefix key."
msgstr "@code{ctl-x-5-map}はプレフィクスキー@kbd{C-x 5}にたいして使用されるグローバルキーマップである。"

#. type: kbd{#1}
#: original_texis/keymaps.texi:547
#, no-wrap
msgid "C-x 6"
msgstr "C-x 6"

#. type: vindex
#: original_texis/keymaps.texi:548
#, no-wrap
msgid "2C-mode-map"
msgstr "2C-mode-map"

#. type: itemize
#: original_texis/keymaps.texi:551
msgid "@code{2C-mode-map} is the global keymap used for the @kbd{C-x 6} prefix key."
msgstr "@code{2C-mode-map}はプレフィクスキー@kbd{C-x 6}にたいして使用されるグローバルキーマップである。"

#. type: kbd{#1}
#: original_texis/keymaps.texi:553
#, no-wrap
msgid "C-x v"
msgstr "C-x v"

#. type: vindex
#: original_texis/keymaps.texi:554
#, no-wrap
msgid "vc-prefix-map"
msgstr "vc-prefix-map"

#. type: itemize
#: original_texis/keymaps.texi:557
msgid "@code{vc-prefix-map} is the global keymap used for the @kbd{C-x v} prefix key."
msgstr "@code{vc-prefix-map}はプレフィクスキー@kbd{C-x v}にたいして使用されるグローバルキーマップである。"

#. type: kbd{#1}
#: original_texis/keymaps.texi:559
#, no-wrap
msgid "M-g"
msgstr "M-g"

#. type: vindex
#: original_texis/keymaps.texi:560
#, no-wrap
msgid "goto-map"
msgstr "goto-map"

#. type: itemize
#: original_texis/keymaps.texi:563
msgid "@code{goto-map} is the global keymap used for the @kbd{M-g} prefix key."
msgstr "@code{goto-map}はプレフィクスキー@kbd{M-g}にたいして使用されるグローバルキーマップである。"

#. type: kbd{#1}
#: original_texis/keymaps.texi:565
#, no-wrap
msgid "M-s"
msgstr "M-s"

#. type: vindex
#: original_texis/keymaps.texi:566
#, no-wrap
msgid "search-map"
msgstr "search-map"

#. type: itemize
#: original_texis/keymaps.texi:569
msgid "@code{search-map} is the global keymap used for the @kbd{M-s} prefix key."
msgstr "@code{search-map}はプレフィクスキー@kbd{M-s}にたいして使用されるグローバルキーマップである。"

#. type: kbd{#1}
#: original_texis/keymaps.texi:571
#, no-wrap
msgid "M-o"
msgstr "M-o"

#. type: vindex
#: original_texis/keymaps.texi:572
#, no-wrap
msgid "facemenu-keymap"
msgstr "facemenu-keymap"

#. type: itemize
#: original_texis/keymaps.texi:575
msgid "@code{facemenu-keymap} is the global keymap used for the @kbd{M-o} prefix key."
msgstr "@code{facemenu-keymap}はプレフィクスキー@kbd{M-o}にたいして使用されるグローバルキーマップである。"

#. type: itemize
#: original_texis/keymaps.texi:580
msgid "The other Emacs prefix keys are @kbd{C-x @@}, @kbd{C-x a i}, @kbd{C-x @key{ESC}} and @kbd{@key{ESC} @key{ESC}}.  They use keymaps that have no special names."
msgstr "Emacsの他のプレフィクスキーには@kbd{C-x @@}、@kbd{C-x a i}、@kbd{C-x @key{ESC}}、@kbd{@key{ESC} @key{ESC}}がある。これらは特別な名前をもたないキーマップを使用する。"

#. type: Plain text
#: original_texis/keymaps.texi:589
msgid "The keymap binding of a prefix key is used for looking up the event that follows the prefix key.  (It may instead be a symbol whose function definition is a keymap.  The effect is the same, but the symbol serves as a name for the prefix key.)  Thus, the binding of @kbd{C-x} is the symbol @code{Control-X-prefix}, whose function cell holds the keymap for @kbd{C-x} commands.  (The same keymap is also the value of @code{ctl-x-map}.)"
msgstr "プレフィクスキーのキーマップバインディングは、プレフィクスキーに続くイベントをルックアップするために使用されます(これは関数定義がキーマップであるようなシンボルかもしれない。効果は同じだがシンボルはプレフィクスキーにたいする名前の役割を果たす)。したがって@kbd{C-x}のバインディングはシンボル@code{Control-X-prefix}であり、このシンボルの関数セルが@kbd{C-x}コマンドにたいするキーマップを保持します(@code{ctl-x-map}の値も同じキーマップ)。"

#. type: Plain text
#: original_texis/keymaps.texi:596
msgid "Prefix key definitions can appear in any active keymap.  The definitions of @kbd{C-c}, @kbd{C-x}, @kbd{C-h} and @key{ESC} as prefix keys appear in the global map, so these prefix keys are always available.  Major and minor modes can redefine a key as a prefix by putting a prefix key definition for it in the local map or the minor mode's map.  @xref{Active Keymaps}."
msgstr "プレフィクスキー定義は任意のアクティブなキーマップ内に置くことができます。プレフィクスキーとしての@kbd{C-c}、@kbd{C-x}、@kbd{C-h}、@key{ESC}の定義はグローバルマップ内にもあるので、これらのプレフィクスキーは常に使用できます。メジャーモードとマイナーモードは、ローカルマップやマイナーモードのマップ内にプレフィクスキー定義を置くことによってキーをプレフィクスキーとして再定義できます。@ref{Active Keymaps}を参照してください。"

#. type: Plain text
#: original_texis/keymaps.texi:601
msgid "If a key is defined as a prefix in more than one active map, then its various definitions are in effect merged: the commands defined in the minor mode keymaps come first, followed by those in the local map's prefix definition, and then by those from the global map."
msgstr "あるキーが複数のアクティブなマップ内でプレフィクスキーとして定義されていると、それぞれの定義がマージされて効果をもちます。まずマイナーモードキーマップ内で定義されたコマンド、次にローカルマップのプレフィクス定義されたコマンド、そしてグローバルマップのコマンドが続きます。"

#. type: Plain text
#: original_texis/keymaps.texi:607
msgid "In the following example, we make @kbd{C-p} a prefix key in the local keymap, in such a way that @kbd{C-p} is identical to @kbd{C-x}.  Then the binding for @kbd{C-p C-f} is the function @code{find-file}, just like @kbd{C-x C-f}.  The key sequence @kbd{C-p 6} is not found in any active keymap."
msgstr "以下の例ではローカルキーマップ内で@kbd{C-p}を@kbd{C-x}と等価なプレフィクスキーにしています。すると@kbd{C-p C-f}にたいするバインディングは@kbd{C-x C-f}と同様に関数@code{find-file}になります。キーシーケンス@kbd{C-p 6}はすべてのアクティブなキーマップで見つけることができません。"

#. type: group
#: original_texis/keymaps.texi:612
#, no-wrap
msgid ""
"(use-local-map (make-sparse-keymap))\n"
"    @result{} nil\n"
msgstr ""
"(use-local-map (make-sparse-keymap))\n"
"    @result{} nil\n"

#. type: group
#: original_texis/keymaps.texi:616
#, no-wrap
msgid ""
"(local-set-key \"\\C-p\" ctl-x-map)\n"
"    @result{} nil\n"
msgstr ""
"(local-set-key \"\\C-p\" ctl-x-map)\n"
"    @result{} nil\n"

#. type: group
#: original_texis/keymaps.texi:620
#, no-wrap
msgid ""
"(key-binding \"\\C-p\\C-f\")\n"
"    @result{} find-file\n"
msgstr ""
"(key-binding \"\\C-p\\C-f\")\n"
"    @result{} find-file\n"

#. type: group
#: original_texis/keymaps.texi:625
#, no-wrap
msgid ""
"(key-binding \"\\C-p6\")\n"
"    @result{} nil\n"
msgstr ""
"(key-binding \"\\C-p6\")\n"
"    @result{} nil\n"

#. type: defun
#: original_texis/keymaps.texi:628
#, no-wrap
msgid "define-prefix-command symbol &optional mapvar prompt"
msgstr "define-prefix-command symbol &optional mapvar prompt"

#. type: cindex
#: original_texis/keymaps.texi:629
#, no-wrap
msgid "prefix command"
msgstr "prefix command"

#. type: anchor{#1}
#: original_texis/keymaps.texi:635
msgid "Definition of define-prefix-command"
msgstr "Definition of define-prefix-command"

#. type: defun
#: original_texis/keymaps.texi:635
msgid "This function prepares @var{symbol} for use as a prefix key's binding: it creates a sparse keymap and stores it as @var{symbol}'s function definition.  Subsequently binding a key sequence to @var{symbol} will make that key sequence into a prefix key.  The return value is @code{symbol}."
msgstr "この関数はプレフィクスキーのバインディングとして使用するために@var{symbol}を用意する。これはsparseキーマップを作成してそれを@var{symbol}の関数定義として格納する。その後は@var{symbol}にキーシーケンスをバインディングすると、そのキーシーケンスはプレフィクスキーになるだろう。リターン値は@code{symbol}。"

#. type: defun
#: original_texis/keymaps.texi:639
msgid "This function also sets @var{symbol} as a variable, with the keymap as its value.  But if @var{mapvar} is non-@code{nil}, it sets @var{mapvar} as a variable instead."
msgstr "この関数は値がそのキーマップであるような変数としても@var{symbol}をセットする。しかし@var{mapvar}が非@code{nil}なら、かわりに@var{mapvar}を変数としてセットする。"

#. type: defun
#: original_texis/keymaps.texi:643
msgid "If @var{prompt} is non-@code{nil}, that becomes the overall prompt string for the keymap.  The prompt string should be given for menu keymaps (@pxref{Defining Menus})."
msgstr "@var{prompt}が非@code{nil}なら、これはそのキーマップにたいするoverallプロンプト文字列になる。プロンプト文字列はメニューキーマップにたいして与えらること(@ref{Defining Menus}を参照)。"

#. type: cindex
#: original_texis/keymaps.texi:647
#, no-wrap
msgid "active keymap"
msgstr "active keymap"

#. type: Plain text
#: original_texis/keymaps.texi:653
msgid "Emacs contains many keymaps, but at any time only a few keymaps are @dfn{active}.  When Emacs receives user input, it translates the input event (@pxref{Translation Keymaps}), and looks for a key binding in the active keymaps."
msgstr "Emacsには多くのキーマップを含まれていますが、常にいくつかのキーマップだけが@dfn{アクティブ}です。Emacsがユーザー入力を受け取ったとき、それは入力イベントに変換されて(@ref{Translation Keymaps}を参照)、アクティブなキーマップ内でキーバインディングがルックアップされます。"

#. type: Plain text
#: original_texis/keymaps.texi:659
msgid "Usually, the active keymaps are: (i) the keymap specified by the @code{keymap} property, (ii) the keymaps of enabled minor modes, (iii)  the current buffer's local keymap, and (iv) the global keymap, in that order.  Emacs searches for each input key sequence in all these keymaps."
msgstr "アクティブなキーマップは通常は、(1) @code{keymap}プロパティにより指定されるキーマップ、(2) 有効なマイナーモードのキーマップ、(3) カレントバッファーのローカルキーマップ、(4) グローバルキーマップの順です。Emacsは入力キーシーケンスそれぞれにたいして、これらすべてのキーマップ内を検索します。"

#. type: Plain text
#: original_texis/keymaps.texi:663
msgid "Of these usual keymaps, the highest-precedence one is specified by the @code{keymap} text or overlay property at point, if any.  (For a mouse input event, Emacs uses the event position instead of point;"
msgstr "これらの通常のキーマップのうち最優先されるのは、もしあればポイント位置の@code{keymap}テキストにより指定されるキーマップかoverallプロパティです(マウス入力イベントにたいしてはEmacsはポイント位置のかわりにイベント位置を使用する。"

#. type: iftex
#: original_texis/keymaps.texi:665
msgid "see the next section for details.)"
msgstr "詳細は次のセクションを参照されたい)。"

#. type: ifnottex
#: original_texis/keymaps.texi:668
msgid "@pxref{Searching Keymaps}.)"
msgstr "@ref{Searching Keymaps}を参照されたい)。"

#. type: Plain text
#: original_texis/keymaps.texi:675
msgid "Next in precedence are keymaps specified by enabled minor modes.  These keymaps, if any, are specified by the variables @code{emulation-mode-map-alists}, @code{minor-mode-overriding-map-alist}, and @code{minor-mode-map-alist}.  @xref{Controlling Active Maps}."
msgstr "次に優先されるのは有効なマイナーモードにより指定されるキーマップです。もしあればこれらのキーマップは変数@code{emulation-mode-map-alists}、@code{minor-mode-overriding-map-alist}、@code{minor-mode-map-alist}により指定されます。@ref{Controlling Active Maps}を参照してください。"

#. type: cindex
#: original_texis/keymaps.texi:676
#, no-wrap
msgid "local keymap"
msgstr "local keymap"

#. type: Plain text
#: original_texis/keymaps.texi:682
msgid "Next in precedence is the buffer's @dfn{local keymap}, containing key bindings specific to the buffer.  The minibuffer also has a local keymap (@pxref{Intro to Minibuffers}).  If there is a @code{local-map} text or overlay property at point, that specifies the local keymap to use, in place of the buffer's default local keymap."
msgstr "次に優先されるのはバッファーの@dfn{ローカルキーマップ(local keymap)}で、これにはそのバッファー特有なキーバインディングが含まれます。ミニバッファーもローカルキーマップをもちます(@ref{Intro to Minibuffers}を参照)。ポイント位置に@code{local-map}テキスト、またはoverlayプロパティがあるなら、それはバッファーのデフォルトローカルキーマップのかわりに使用するローカルキーマップを指定します。"

#. type: cindex
#: original_texis/keymaps.texi:683
#, no-wrap
msgid "major mode keymap"
msgstr "major mode keymap"

#. type: Plain text
#: original_texis/keymaps.texi:689
msgid "The local keymap is normally set by the buffer's major mode, and every buffer with the same major mode shares the same local keymap.  Hence, if you call @code{local-set-key} (@pxref{Key Binding Commands})  to change the local keymap in one buffer, that also affects the local keymaps in other buffers with the same major mode."
msgstr "ローカルキーマップは通常はそのバッファーのメジャーモードによってセットされます。同じメジャーモードをもつすべてのバッファーは、同じローカルキーマップを共有します。したがってあるバッファーでローカルキーマップを変更するために@code{local-set-key} (@ref{Key Binding Commands}を参照)を呼び出すと、それは同じメジャーモードをもつ他のバッファーのローカルキーマップにも影響を与えます。"

#. type: cindex
#: original_texis/keymaps.texi:690
#, no-wrap
msgid "global keymap"
msgstr "global keymap"

#. type: Plain text
#: original_texis/keymaps.texi:694
msgid "Finally, the @dfn{global keymap} contains key bindings that are defined regardless of the current buffer, such as @kbd{C-f}.  It is always active, and is bound to the variable @code{global-map}."
msgstr "最後は@kbd{C-f}のようなカレントバッファーとは関係なく定義されるキーバインディングを含んだ@dfn{グローバルキーマップ(global keymap)}です。このキーマップは常にアクティブであり変数@code{global-map}にバインドされています。"

#. type: Plain text
#: original_texis/keymaps.texi:705
msgid "Apart from the above usual keymaps, Emacs provides special ways for programs to make other keymaps active.  Firstly, the variable @code{overriding-local-map} specifies a keymap that replaces the usual active keymaps, except for the global keymap.  Secondly, the terminal-local variable @code{overriding-terminal-local-map} specifies a keymap that takes precedence over @emph{all} other keymaps (including @code{overriding-local-map}); this is normally used for modal/transient keybindings (the function @code{set-transient-map} provides a convenient interface for this).  @xref{Controlling Active Maps}, for details."
msgstr "これら通常のキーマップとは別に、Emacsはプログラムが他のキーマップをアクティブにするための特別な手段を提供します。1つ目はグローバルキーマップ以外の通常アクティブなキーマップを置き換えるキーマップを指定する変数@code{overriding-local-map}です。2つ目は他の@emph{すべて}のキーマップより優先されるキーマップを指定する端末ローカル変数@code{overriding-terminal-local-map}です。この端末ローカル変数は通常はmodal(訳注: 他のキーマップを選択できない状態)かつ一時的なキーバインディングに使用されます(ここの変数にたいして関数@code{set-transient-map}は便利なインターフェイスを提供する)。詳細は@ref{Controlling Active Maps}を参照してください。"

#. type: Plain text
#: original_texis/keymaps.texi:709
msgid "Making keymaps active is not the only way to use them.  Keymaps are also used in other ways, such as for translating events within @code{read-key-sequence}.  @xref{Translation Keymaps}."
msgstr "これらを使用するのがキーマップをアクティブにする唯一の方法ではありません。キーマップは@code{read-key-sequence}によるイベントの変換のような他の用途にも使用されます。@ref{Translation Keymaps}を参照してください。"

#. type: Plain text
#: original_texis/keymaps.texi:711
msgid "@xref{Standard Keymaps}, for a list of some standard keymaps."
msgstr "いくつかの標準的なキーマップのリストは@ref{Standard Keymaps}を参照してください。"

#. type: defun
#: original_texis/keymaps.texi:712
#, no-wrap
msgid "current-active-maps &optional olp position"
msgstr "current-active-maps &optional olp position"

#. type: defun
#: original_texis/keymaps.texi:721
msgid "This returns the list of active keymaps that would be used by the command loop in the current circumstances to look up a key sequence.  Normally it ignores @code{overriding-local-map} and @code{overriding-terminal-local-map}, but if @var{olp} is non-@code{nil} then it pays attention to them.  @var{position} can optionally be either an event position as returned by @code{event-start} or a buffer position, and may change the keymaps as described for @code{key-binding}."
msgstr "これはカレント状況下でコマンドループによりキーシーケンスをルックアップするために使用される、アクティブなキーマップのリストをリターンする。これは通常は@code{overriding-local-map}と@code{overriding-terminal-local-map}を無視するが、@var{olp}が非@code{nil}なら、それらのキーマップにも注意を払う。オプションで@var{position}に@code{event-start}によってリターンされるイベント位置、またはバッファー位置を指定でき、@code{key-binding}で説明されているようにキーマップを変更するかもしれない。"

#. type: defun
#: original_texis/keymaps.texi:723
#, no-wrap
msgid "key-binding key &optional accept-defaults no-remap position"
msgstr "key-binding key &optional accept-defaults no-remap position"

#. type: defun
#: original_texis/keymaps.texi:727
msgid "This function returns the binding for @var{key} according to the current active keymaps.  The result is @code{nil} if @var{key} is undefined in the keymaps."
msgstr "この関数はカレントのアクティブキーマップで@var{key}にたいするバインディングをリターンする。そのキーマップ内で@var{key}が未定義なら結果は@code{nil}。"

#. type: defun
#: original_texis/keymaps.texi:730
msgid "The argument @var{accept-defaults} controls checking for default bindings, as in @code{lookup-key} (@pxref{Functions for Key Lookup})."
msgstr "引数@var{accept-defaults}は@code{lookup-key} (@ref{Functions for Key Lookup}を参照)のようにデフォルトバインディングをチェックするかどうかを制御する。"

#. type: defun
#: original_texis/keymaps.texi:736
msgid "When commands are remapped (@pxref{Remapping Commands}), @code{key-binding} normally processes command remappings so as to return the remapped command that will actually be executed.  However, if @var{no-remap} is non-@code{nil}, @code{key-binding} ignores remappings and returns the binding directly specified for @var{key}."
msgstr "コマンドがリマップ(remap: 再マップ。@ref{Remapping Commands}を参照)されたとき、@code{key-binding}が実際に実行されるであろうリマップされたコマンドをリターンするように、通常のようにコマンドのリマップを行う。しかし@var{no-remap}が非@code{nil}なら、@code{key-binding}はリマップを無視して@var{key}にたいして直接指定されたバインディングをリターンする。"

#. type: defun
#: original_texis/keymaps.texi:744
msgid "If @var{key} starts with a mouse event (perhaps following a prefix event), the maps to be consulted are determined based on the event's position.  Otherwise, they are determined based on the value of point.  However, you can override either of them by specifying @var{position}.  If @var{position} is non-@code{nil}, it should be either a buffer position or an event position like the value of @code{event-start}.  Then the maps consulted are determined based on @var{position}."
msgstr "@var{key}がマウスイベント(もしかしたらプレフィクスイベントが先行するかもしれない)で始まるなら、照合されるマップはそのイベントの位置を元に決定される。それ以外では、それらのマップはポイント値にもとづき決定される。しかし@var{position}を指定することによってこれらをオーバーライドできる。@var{position}が非@code{nil}なら、それはバッファー位置か@code{event-start}の値のようなイベント位置のいずれかである。その場合には照合されるマップは@var{position}にもとづいて決定される。"

#. type: defun
#: original_texis/keymaps.texi:746
msgid "Emacs signals an error if @var{key} is not a string or a vector."
msgstr "@var{key}が文字列とベクターのいずれでもなければEmacsはエラーをシグナルする。"

#. type: group
#: original_texis/keymaps.texi:751
#, no-wrap
msgid ""
"(key-binding \"\\C-x\\C-f\")\n"
"    @result{} find-file\n"
msgstr ""
"(key-binding \"\\C-x\\C-f\")\n"
"    @result{} find-file\n"

#. type: section
#: original_texis/keymaps.texi:756
#, no-wrap
msgid "Searching the Active Keymaps"
msgstr "Searching the Active Keymaps"

#. type: cindex
#: original_texis/keymaps.texi:757
#, no-wrap
msgid "searching active keymaps for keys"
msgstr "searching active keymaps for keys"

#. type: Plain text
#: original_texis/keymaps.texi:761
msgid "Here is a pseudo-Lisp summary of how Emacs searches the active keymaps:"
msgstr "以下はEmacsがアクティブなキーマップを検索する方法を示すLisp処理の概要です:"

#. type: lisp
#: original_texis/keymaps.texi:775
#, no-wrap
msgid ""
"(or (if overriding-terminal-local-map\n"
"        (@var{find-in} overriding-terminal-local-map))\n"
"    (if overriding-local-map\n"
"        (@var{find-in} overriding-local-map)\n"
"      (or (@var{find-in} (get-char-property (point) 'keymap))\n"
"          (@var{find-in-any} emulation-mode-map-alists)\n"
"          (@var{find-in-any} minor-mode-overriding-map-alist)\n"
"          (@var{find-in-any} minor-mode-map-alist)\n"
"          (if (get-text-property (point) 'local-map)\n"
"              (@var{find-in} (get-char-property (point) 'local-map))\n"
"            (@var{find-in} (current-local-map)))))\n"
"    (@var{find-in} (current-global-map)))\n"
msgstr ""
"(or (if overriding-terminal-local-map\n"
"        (@var{find-in} overriding-terminal-local-map))\n"
"    (if overriding-local-map\n"
"        (@var{find-in} overriding-local-map)\n"
"      (or (@var{find-in} (get-char-property (point) 'keymap))\n"
"          (@var{find-in-any} emulation-mode-map-alists)\n"
"          (@var{find-in-any} minor-mode-overriding-map-alist)\n"
"          (@var{find-in-any} minor-mode-map-alist)\n"
"          (if (get-text-property (point) 'local-map)\n"
"              (@var{find-in} (get-char-property (point) 'local-map))\n"
"            (@var{find-in} (current-local-map)))))\n"
"    (@var{find-in} (current-global-map)))\n"

#. type: Plain text
#: original_texis/keymaps.texi:783
msgid "Here, @var{find-in} and @var{find-in-any} are pseudo functions that search in one keymap and in an alist of keymaps, respectively.  Note that the @code{set-transient-map} function works by setting @code{overriding-terminal-local-map} (@pxref{Controlling Active Maps})."
msgstr "ここで@var{find-in}と@var{find-in-any}はそれぞれ、1つのキーマップとキーマップのalistを検索する仮の関数です。関数@code{set-transient-map}が@code{overriding-terminal-local-map} (@ref{Controlling Active Maps}を参照)をセットすることによって機能する点に注意してください。"

#. type: Plain text
#: original_texis/keymaps.texi:795
msgid "In the above pseudo-code, if a key sequence starts with a mouse event (@pxref{Mouse Events}), that event's position is used instead of point, and the event's buffer is used instead of the current buffer.  In particular, this affects how the @code{keymap} and @code{local-map} properties are looked up.  If a mouse event occurs on a string embedded with a @code{display}, @code{before-string}, or @code{after-string} property (@pxref{Special Properties}), and the string has a non-@code{nil} @code{keymap} or @code{local-map} property, that overrides the corresponding property in the underlying buffer text (i.e., the property specified by the underlying text is ignored)."
msgstr "上記の処理概要ではキーシーケンスがマウスイベント(@ref{Mouse Events}を参照)で始まる場合には、ポイント位置のかわりにそのイベント位置、カレントバッファーのかわりにそのイベントのバッファーが使用されます。これは特にプロパティ@code{keymap}と@code{local-map}をルックアップする方法に影響を与えます。@code{display}、@code{before-string}、@code{after-string}プロパティ(@ref{Special Properties}を参照)が埋め込まれていて@code{keymap}か@code{local-map}プロパティが非@code{nil}の文字列上でマウスイベントが発生すると、それは基調となるバッファーテキストの対応するプロパティをオーバーライドします(バッファーテキストにより指定されたプロパティは無視される)。"

#. type: Plain text
#: original_texis/keymaps.texi:802
msgid "When a key binding is found in one of the active keymaps, and that binding is a command, the search is over---the command is executed.  However, if the binding is a symbol with a value or a string, Emacs replaces the input key sequences with the variable's value or the string, and restarts the search of the active keymaps.  @xref{Key Lookup}."
msgstr "アクティブなキーマップの1つでキーバインディングが見つかって、そのバインディングがコマンドなら検索は終了してそのコマンドが実行されます。しかしそのバインディングが値をもつ変数か文字列なら、Emacsは入力キーシーケンスをその変数の値か文字列で置き換えて、アクティブなキーマップの検索を再開します。 @ref{Key Lookup}を参照してください。"

#. type: Plain text
#: original_texis/keymaps.texi:805
msgid "The command which is finally found might also be remapped.  @xref{Remapping Commands}."
msgstr "最終的に見つかったコマンドもリマップされるかもしれません。@ref{Remapping Commands}を参照してください。"

#. type: section
#: original_texis/keymaps.texi:807
#, no-wrap
msgid "Controlling the Active Keymaps"
msgstr "Controlling the Active Keymaps"

#. type: cindex
#: original_texis/keymaps.texi:808
#, no-wrap
msgid "active keymap, controlling"
msgstr "active keymap, controlling"

#. type: defvar
#: original_texis/keymaps.texi:810
#, no-wrap
msgid "global-map"
msgstr "global-map"

#. type: defvar
#: original_texis/keymaps.texi:815
msgid "This variable contains the default global keymap that maps Emacs keyboard input to commands.  The global keymap is normally this keymap.  The default global keymap is a full keymap that binds @code{self-insert-command} to all of the printing characters."
msgstr "この変数はEmacsキーボード入力をコマンドにマップするデフォルトのグローバルキーマップを含む。通常はこのキーマップがグローバルキーマップである。デフォルトグローバルキーマップは@code{self-insert-command}をすべてのプリント文字にバインドするfullキーマップである。"

#. type: defvar
#: original_texis/keymaps.texi:819
msgid "It is normal practice to change the bindings in the global keymap, but you should not assign this variable any value other than the keymap it starts out with."
msgstr "これはグローバルキーマップ内のバインディングを変更する通常の手段だが、この変数に開始時のキーマップ以外の値を割り当てるべきではない。"

#. type: defun
#: original_texis/keymaps.texi:821
#, no-wrap
msgid "current-global-map"
msgstr "current-global-map"

#. type: defun
#: original_texis/keymaps.texi:827
msgid "This function returns the current global keymap.  This is the same as the value of @code{global-map} unless you change one or the other.  The return value is a reference, not a copy; if you use @code{define-key} or other functions on it you will alter global bindings."
msgstr "この関数はカレントのグローバルキーマップをリターンする。デフォルトグローバルキーマップとカレントグローバルキーマップのいずれも変更していなければ@code{global-map}と同じ値。リターン値はコピーではなく参照である。これに@code{define-key}などの関数を使用すると、グローバルバインディングが変更されるだろう。"

#. type: group
#: original_texis/keymaps.texi:833
#, no-wrap
msgid ""
"(current-global-map)\n"
"@result{} (keymap [set-mark-command beginning-of-line @dots{}\n"
"            delete-backward-char])\n"
msgstr ""
"(current-global-map)\n"
"@result{} (keymap [set-mark-command beginning-of-line @dots{}\n"
"            delete-backward-char])\n"

#. type: defun
#: original_texis/keymaps.texi:837
#, no-wrap
msgid "current-local-map"
msgstr "current-local-map"

#. type: defun
#: original_texis/keymaps.texi:843
msgid "This function returns the current buffer's local keymap, or @code{nil} if it has none.  In the following example, the keymap for the @file{*scratch*} buffer (using Lisp Interaction mode) is a sparse keymap in which the entry for @key{ESC}, @acronym{ASCII} code 27, is another sparse keymap."
msgstr "この関数はカレントバッファーのローカルキーマップをリターンする。ローカルキーマップがなければ@code{nil}をリターンする。以下の例では、(Lisp Interactionモードを使用する)@file{*scratch*}バッファーにたいするキーマップは、@key{ESC}(@acronym{ASCII}コード27)にたいするエントリーが別のsparseキーマップであるようなsparseキーマップである。"

#. type: group
#: original_texis/keymaps.texi:851
#, no-wrap
msgid ""
"(current-local-map)\n"
"@result{} (keymap\n"
"    (10 . eval-print-last-sexp)\n"
"    (9 . lisp-indent-line)\n"
"    (127 . backward-delete-char-untabify)\n"
msgstr ""
"(current-local-map)\n"
"@result{} (keymap\n"
"    (10 . eval-print-last-sexp)\n"
"    (9 . lisp-indent-line)\n"
"    (127 . backward-delete-char-untabify)\n"

#. type: group
#: original_texis/keymaps.texi:856
#, no-wrap
msgid ""
"    (27 keymap\n"
"        (24 . eval-defun)\n"
"        (17 . indent-sexp)))\n"
msgstr ""
"    (27 keymap\n"
"        (24 . eval-defun)\n"
"        (17 . indent-sexp)))\n"

#. type: Plain text
#: original_texis/keymaps.texi:863
msgid "@code{current-local-map} returns a reference to the local keymap, not a copy of it; if you use @code{define-key} or other functions on it you will alter local bindings."
msgstr "@code{current-local-map}はローカルキーマップのコピーではなく参照をリターンします。これに@code{define-key}などの関数を使用するとローカルバインディングが変更されるでしょう。"

#. type: defun
#: original_texis/keymaps.texi:864
#, no-wrap
msgid "current-minor-mode-maps"
msgstr "current-minor-mode-maps"

#. type: defun
#: original_texis/keymaps.texi:866
msgid "This function returns a list of the keymaps of currently enabled minor modes."
msgstr "この関数はカレントで有効なメジャーモードのキーマップリストをリターンする。"

#. type: defun
#: original_texis/keymaps.texi:868
#, no-wrap
msgid "use-global-map keymap"
msgstr "use-global-map keymap"

#. type: defun
#: original_texis/keymaps.texi:871
msgid "This function makes @var{keymap} the new current global keymap.  It returns @code{nil}."
msgstr "この関数は@var{keymap}を新たなカレントグローバルキーマップにする。これは@code{nil}をリターンする。"

#. type: defun
#: original_texis/keymaps.texi:873
msgid "It is very unusual to change the global keymap."
msgstr "グローバルキーマップの変更は異例である。"

#. type: defun
#: original_texis/keymaps.texi:875
#, no-wrap
msgid "use-local-map keymap"
msgstr "use-local-map keymap"

#. type: defun
#: original_texis/keymaps.texi:880
msgid "This function makes @var{keymap} the new local keymap of the current buffer.  If @var{keymap} is @code{nil}, then the buffer has no local keymap.  @code{use-local-map} returns @code{nil}.  Most major mode commands use this function."
msgstr "この関数は@var{keymap}をカレントバッファーの新たなローカルキーマップにする。@var{keymap}が@code{nil}なら、そのバッファーはローカルキーマップをもたない。@code{use-local-map}は@code{nil}をリターンする。ほとんどのメジャーモードコマンドはこの関数を使用する。"

#. type: defvar
#: original_texis/keymaps.texi:882
#, no-wrap
msgid "minor-mode-map-alist"
msgstr "minor-mode-map-alist"

#. type: anchor{#1}
#: original_texis/keymaps.texi:887
msgid "Definition of minor-mode-map-alist"
msgstr "Definition of minor-mode-map-alist"

#. type: defvar
#: original_texis/keymaps.texi:887
msgid "This variable is an alist describing keymaps that may or may not be active according to the values of certain variables.  Its elements look like this:"
msgstr "この変数はアクティブかどうかに関わらず、特定の変数の値にたいするキーマップを示すalistである。要素は以下のようになる:"

#. type: example
#: original_texis/keymaps.texi:890
#, no-wrap
msgid "(@var{variable} . @var{keymap})\n"
msgstr "(@var{variable} . @var{keymap})\n"

#. type: defvar
#: original_texis/keymaps.texi:895
msgid "The keymap @var{keymap} is active whenever @var{variable} has a non-@code{nil} value.  Typically @var{variable} is the variable that enables or disables a minor mode.  @xref{Keymaps and Minor Modes}."
msgstr "キーマップ@var{keymap}は @var{variable}が非@code{nil}値をもつときはアクティブである。@var{variable}は通常はメジャーモードを有効か無効にする変数である。@ref{Keymaps and Minor Modes}を参照のこと。"

#. type: defvar
#: original_texis/keymaps.texi:901
msgid "Note that elements of @code{minor-mode-map-alist} do not have the same structure as elements of @code{minor-mode-alist}.  The map must be the @sc{cdr} of the element; a list with the map as the second element will not do.  The @sc{cdr} can be either a keymap (a list) or a symbol whose function definition is a keymap."
msgstr "@code{minor-mode-map-alist}の要素が@code{minor-mode-alist}の要素と異なる構造をもつことに注意。マップは要素の@sc{cdr}でなければならず、そうでなければ2つ目の要素にマップリストは用いられないだろう。@sc{cdr}はキーマップ(リスト)、または関数定義がキーマップであるようなシンボルである。"

#. type: defvar
#: original_texis/keymaps.texi:906
msgid "When more than one minor mode keymap is active, the earlier one in @code{minor-mode-map-alist} takes priority.  But you should design minor modes so that they don't interfere with each other.  If you do this properly, the order will not matter."
msgstr "1つ以上のマイナーモードキーマップがアクティブなとき、@code{minor-mode-map-alist}内で前のキーマップが優先される。しかし互いが干渉しないようにマイナーモードをデザインすること。これを正しく行えば順序は問題にならない。"

#. type: defvar
#: original_texis/keymaps.texi:910
msgid "See @ref{Keymaps and Minor Modes}, for more information about minor modes.  See also @code{minor-mode-key-binding} (@pxref{Functions for Key Lookup})."
msgstr "マイナーモードについての詳細な情報は、@ref{Keymaps and Minor Modes}を参照のこと。@code{minor-mode-key-binding} (@ref{Functions for Key Lookup}を参照)も確認されたい。"

#. type: defvar
#: original_texis/keymaps.texi:912
#, no-wrap
msgid "minor-mode-overriding-map-alist"
msgstr "minor-mode-overriding-map-alist"

#. type: defvar
#: original_texis/keymaps.texi:917
msgid "This variable allows major modes to override the key bindings for particular minor modes.  The elements of this alist look like the elements of @code{minor-mode-map-alist}: @code{(@var{variable} . @var{keymap})}."
msgstr "この変数はメジャーモードによる特定のマイナーモードにたいするキーバインディングのオーバーライドを可能にする。このalistの要素は@code{minor-mode-map-alist}の要素のような@code{(@var{variable} . @var{keymap})}という形式である。"

#. type: defvar
#: original_texis/keymaps.texi:922
msgid "If a variable appears as an element of @code{minor-mode-overriding-map-alist}, the map specified by that element totally replaces any map specified for the same variable in @code{minor-mode-map-alist}."
msgstr "ある変数が@code{minor-mode-overriding-map-alist}の要素として出現するなら、その要素によって指定されるマップは@code{minor-mode-map-alist}内の同じ変数にたいして指定されるすべてのマップを完全に置き換える。"

#. type: defvar
#: original_texis/keymaps.texi:925
msgid "@code{minor-mode-overriding-map-alist} is automatically buffer-local in all buffers."
msgstr "すべてのバッファーにおいて@code{minor-mode-overriding-map-alist}は自動的にバッファーローカルである。"

#. type: defvar
#: original_texis/keymaps.texi:927
#, no-wrap
msgid "overriding-local-map"
msgstr "overriding-local-map"

#. type: defvar
#: original_texis/keymaps.texi:932
msgid "If non-@code{nil}, this variable holds a keymap to use instead of the buffer's local keymap, any text property or overlay keymaps, and any minor mode keymaps.  This keymap, if specified, overrides all other maps that would have been active, except for the current global map."
msgstr "この変数が非@code{nil}ならバッファーのローカルキーマップ、テキストプロパティまたはoverlayによるキーマップ、マイナーモードキーマップのかわりに使用されるするキーマップを保持する。このキーマップが指定されると、カレントグローバルキーマップ以外のアクティブだった他のすべてのマップがオーバーライドされる。"

#. type: defvar
#: original_texis/keymaps.texi:934
#, no-wrap
msgid "overriding-terminal-local-map"
msgstr "overriding-terminal-local-map"

#. type: defvar
#: original_texis/keymaps.texi:938
msgid "If non-@code{nil}, this variable holds a keymap to use instead of @code{overriding-local-map}, the buffer's local keymap, text property or overlay keymaps, and all the minor mode keymaps."
msgstr "この変数が非@code{nil}なら@code{overriding-local-map}、バッファーのローカルキーマップ、テキストプロパティまたはoverlayによるキーマップ、およびすべてのマイナーモードキーマップのかわりに使用されるキーマップを保持する。"

#. type: defvar
#: original_texis/keymaps.texi:942
msgid "This variable is always local to the current terminal and cannot be buffer-local.  @xref{Multiple Terminals}.  It is used to implement incremental search mode."
msgstr "この変数はカレント端末にたいして常にローカルでありバッファーローカルにできない。@ref{Multiple Terminals}を参照のこと。これはインクリメンタル検索モードの実装に使用される。"

#. type: defvar
#: original_texis/keymaps.texi:944
#, no-wrap
msgid "overriding-local-map-menu-flag"
msgstr "overriding-local-map-menu-flag"

#. type: defvar
#: original_texis/keymaps.texi:949
msgid "If this variable is non-@code{nil}, the value of @code{overriding-local-map} or @code{overriding-terminal-local-map} can affect the display of the menu bar.  The default value is @code{nil}, so those map variables have no effect on the menu bar."
msgstr "この変数が非@code{nil}なら、@code{overriding-local-map}と@code{overriding-terminal-local-map}の値がメニューバーの表示に影響し得る。デフォルト値は@code{nil}なので、これらのマップ変数なメニューバーに影響をもたない。"

#. type: defvar
#: original_texis/keymaps.texi:957
msgid "Note that these two map variables do affect the execution of key sequences entered using the menu bar, even if they do not affect the menu bar display.  So if a menu bar key sequence comes in, you should clear the variables before looking up and executing that key sequence.  Modes that use the variables would typically do this anyway; normally they respond to events that they do not handle by ``unreading'' them and exiting."
msgstr "これら2つのマップ変数は、たとえこれらの変数がメニューバー表示に影響し得るを与えない場合でも、メニューバーを使用してエンターされたキーシーケンスの実行には影響を与えることに注意。したがってもしメニューバーキーシーケンスが到着したら、そのキーシーケンスをルックアップして実行する前に変数をクリアーすること。この変数を使用するモードは通常は何らかの手段でこれを行っている。これらのモードは通常は``読み戻し(unread)''とexitによって処理されないイベントに応答する。"

#. type: defvar
#: original_texis/keymaps.texi:959
#, no-wrap
msgid "special-event-map"
msgstr "special-event-map"

#. type: defvar
#: original_texis/keymaps.texi:963
msgid "This variable holds a keymap for special events.  If an event type has a binding in this keymap, then it is special, and the binding for the event is run directly by @code{read-event}.  @xref{Special Events}."
msgstr "この変数はスペシャルイベントにたいするキーマップを保持する。あるイベント型がこのキーマップ内でバインディングをもつなら、それはスペシャルイベントであり、そのイベントにたいするバインディングは@code{read-event}によって直接実行される。@ref{Special Events}を参照のこと。"

#. type: defvar
#: original_texis/keymaps.texi:965
#, no-wrap
msgid "emulation-mode-map-alists"
msgstr "emulation-mode-map-alists"

#. type: defvar
#: original_texis/keymaps.texi:973
msgid "This variable holds a list of keymap alists to use for emulation modes.  It is intended for modes or packages using multiple minor-mode keymaps.  Each element is a keymap alist which has the same format and meaning as @code{minor-mode-map-alist}, or a symbol with a variable binding which is such an alist.  The active keymaps in each alist are used before @code{minor-mode-map-alist} and @code{minor-mode-overriding-map-alist}."
msgstr "この変数はエミュレーションモードにたいして使用するキーマップのalistのリストを保持する。この変数は複数マイナーモードキーマップを使用するモードとパッケージを意図している。リストの各要素は@code{minor-mode-map-alist}と同じフォーマットと意味をもつキーマップのalistか、そのようなalist形式の変数バインディングをもつシンボルである。それぞれのalist内のアクティブなキーマップは@code{minor-mode-map-alist}と@code{minor-mode-overriding-map-alist}の前に使用される。"

#. type: cindex
#: original_texis/keymaps.texi:975
#, no-wrap
msgid "transient keymap"
msgstr "transient keymap"

#. type: defun
#: original_texis/keymaps.texi:976
#, no-wrap
msgid "set-transient-map keymap &optional keep-pred on-exit"
msgstr "set-transient-map keymap &optional keep-pred on-exit"

#. type: defun
#: original_texis/keymaps.texi:979
msgid "This function adds @var{keymap} as a @dfn{transient} keymap, which takes precedence over other keymaps for one (or more) subsequent keys."
msgstr "この関数は@dfn{一時的(transient)}なキーマップとして@var{keymap}を追加する。一時的なキーマップは1つ以上の後続するキーにたいして、他のキーマップより優先される。"

#. type: defun
#: original_texis/keymaps.texi:985
msgid "Normally, @var{keymap} is used just once, to look up the very next key.  If the optional argument @var{keep-pred} is @code{t}, the map stays active as long as the user types keys defined in @var{keymap}; when the user types a key that is not in @var{keymap}, the transient keymap is deactivated and normal key lookup continues for that key."
msgstr "@var{keymap}は通常は直後のキーをルックアップするために1回だけ使用される。しかし、オプション引数@var{keep-pred}が@code{t}なら、そのマップはユーザーが@var{keymap}内で定義されたキーをタイプするまでアクティブのままとなる。@var{keymap}内にないキーをユーザーがタイプしたとき一時的キーマップは非アクティブとなり、そのキーにたいして通常のキールックアップが継続される。"

#. type: defun
#: original_texis/keymaps.texi:990
msgid "The @var{keep-pred} argument can also be a function.  In that case, the function is called with no arguments, prior to running each command, while @var{keymap} is active; it should return non-@code{nil} if @var{keymap} should stay active."
msgstr "@var{keep-pred}には関数も指定できる。この場合には@var{keymap}がアクティブの間は、各コマンドの実行に優先してその関数が引数なしで呼び出される。@var{keymap}がアクティブの間、関数は非@code{nil}をリターンすること。"

#. type: defun
#: original_texis/keymaps.texi:994
msgid "The optional argument @var{on-exit}, if non-@code{nil}, specifies a function that is called, with no arguments, after @var{keymap} is deactivated."
msgstr "オプション引数@var{on-exit}が非@code{nil}なら、それは@var{keymap}が非アクティブになった後に引数なしで呼び出される関数を指定する。"

#. type: defun
#: original_texis/keymaps.texi:998
msgid "This function works by adding and removing @var{keymap} from the variable @code{overriding-terminal-local-map}, which takes precedence over all other active keymaps (@pxref{Searching Keymaps})."
msgstr "この関数は他のすべてのアクティブなキーマップに優先される変数@code{overriding-terminal-local-map}にたいして、@var{keymap}を追加または削除することによって機能する(@ref{Searching Keymaps}を参照)。"

#. type: cindex
#: original_texis/keymaps.texi:1002
#, no-wrap
msgid "key lookup"
msgstr "key lookup"

#. type: cindex
#: original_texis/keymaps.texi:1003
#, no-wrap
msgid "keymap entry"
msgstr "keymap entry"

#. type: Plain text
#: original_texis/keymaps.texi:1008
msgid "@dfn{Key lookup} is the process of finding the binding of a key sequence from a given keymap.  The execution or use of the binding is not part of key lookup."
msgstr "@dfn{キールックアップ(key lookup: キー照合)}とは与えられたキーマップからキーシーケンスのバインディングを見つけ出すことです。そのバインディングの使用や実行はキールックアップの一部ではありません。"

#. type: Plain text
#: original_texis/keymaps.texi:1015
msgid "Key lookup uses just the event type of each event in the key sequence; the rest of the event is ignored.  In fact, a key sequence used for key lookup may designate a mouse event with just its types (a symbol)  instead of the entire event (a list).  @xref{Input Events}.  Such a key sequence is insufficient for @code{command-execute} to run, but it is sufficient for looking up or rebinding a key."
msgstr "キールックアップはキーシーケンス内の各イベントのイベント型だけを使用して、そのイベントの残りは無視します。実際のところキールックアップに使用されるキーシーケンスは、マウスイベントをイベント全体(リスト)のかわりにイベント型のみ(シンボル)を用いるでしょう。@ref{Input Events}を参照してください。そのようなキーシーケンスは@code{command-execute}による実行には不十分ですが、キーのルックアップやリバインドには十分です。"

#. type: Plain text
#: original_texis/keymaps.texi:1025
msgid "When the key sequence consists of multiple events, key lookup processes the events sequentially: the binding of the first event is found, and must be a keymap; then the second event's binding is found in that keymap, and so on until all the events in the key sequence are used up.  (The binding thus found for the last event may or may not be a keymap.)  Thus, the process of key lookup is defined in terms of a simpler process for looking up a single event in a keymap.  How that is done depends on the type of object associated with the event in that keymap."
msgstr "キーシーケンスが複数イベントから構成されるとき、キールックアップはイベントを順に処理します。最初のイベントのバインディングが見つかったとき、それはキーマップでなければなりません。そのキーマップ内で2つ目のイベントを見つけ出して、そのキーシーケンス内のすべてのイベントが消費されるまで、このプロセスを続けます(故に最後のイベントにたいして見つかったイベントはキーマップかどうかはわからない)。したがってキールックアッププロセスはキーマップ内で単一イベントを見つけ出す、よりシンプルなプロセスで定義されます。これが行なわれる方法はキーマップ内でそのイベントに関連するオブジェクトの型に依存します。"

#. type: Plain text
#: original_texis/keymaps.texi:1033
msgid "Let's use the term @dfn{keymap entry} to describe the value found by looking up an event type in a keymap.  (This doesn't include the item string and other extra elements in a keymap element for a menu item, because @code{lookup-key} and other key lookup functions don't include them in the returned value.)  While any Lisp object may be stored in a keymap as a keymap entry, not all make sense for key lookup.  Here is a table of the meaningful types of keymap entries:"
msgstr "キーマップ内のイベント型ルックアップによる値の発見を説明するために、@dfn{キーマップエントリー(keymap entry)}という用語を導入しましょう(これにはメニューアイテムにたいするキーマップ内のアイテム文字列や他の余計な要素は含まれない。なぜなら@code{lookup-key}や他のキーマップルックアップ関数がリターン値にそれらを含まないから)。任意のLispオブジェクトがキーマップエントリーとしてキーマップに格納されるかもしれませんが、すべてがキールックアップに意味をもつわけではありません。以下のテーブルはキーマップエントリーで重要な型です:"

#. type: code{#1}
#: original_texis/keymaps.texi:1035
#, no-wrap
msgid "nil"
msgstr "nil"

#. type: cindex
#: original_texis/keymaps.texi:1036
#, no-wrap
msgid "@code{nil} in keymap"
msgstr "@code{nil} in keymap"

#. type: table
#: original_texis/keymaps.texi:1041
msgid "@code{nil} means that the events used so far in the lookup form an undefined key.  When a keymap fails to mention an event type at all, and has no default binding, that is equivalent to a binding of @code{nil} for that event type."
msgstr "@code{nil}はそれまでにルックアップに使用されたイベントが未定義キーを形成することを意味する。最終的にキーマップがイベント型を調べるのに失敗してデフォルトバインディングも存在しないときは、そのイベント型のバインディングが@code{nil}であるのと同じである。"

#. type: var{#1}
#: original_texis/keymaps.texi:1042
#, no-wrap
msgid "command"
msgstr "command"

#. type: cindex
#: original_texis/keymaps.texi:1043
#, no-wrap
msgid "command in keymap"
msgstr "command in keymap"

#. type: table
#: original_texis/keymaps.texi:1046
msgid "The events used so far in the lookup form a complete key, and @var{command} is its binding.  @xref{What Is a Function}."
msgstr "それまでにルックアップに使用されたイベントがコンプリートキーを形成して、@var{command}がそのバインディングである。@ref{What Is a Function}を参照のこと。"

#. type: var{#1}
#: original_texis/keymaps.texi:1047
#, no-wrap
msgid "array"
msgstr "array"

#. type: cindex
#: original_texis/keymaps.texi:1048
#, no-wrap
msgid "string in keymap"
msgstr "string in keymap"

#. type: table
#: original_texis/keymaps.texi:1052
msgid "The array (either a string or a vector) is a keyboard macro.  The events used so far in the lookup form a complete key, and the array is its binding.  See @ref{Keyboard Macros}, for more information."
msgstr "array(文字列かベクター)はキーボードマクロである。それまでにルックアップに使用されたイベントはコンプリートキーを形成して、arrayがそのバインディングである。詳細は@ref{Keyboard Macros}を参照のこと。"

#. type: cindex
#: original_texis/keymaps.texi:1054
#, no-wrap
msgid "keymap in keymap"
msgstr "keymap in keymap"

#. type: table
#: original_texis/keymaps.texi:1057
msgid "The events used so far in the lookup form a prefix key.  The next event of the key sequence is looked up in @var{keymap}."
msgstr "それまでにルックアップに使用されたイベントはプレフィクスキーを形成する。そのキーシーケンスの次のイベントは@var{keymap}内でルックアップされる。"

#. type: var{#1}
#: original_texis/keymaps.texi:1058
#, no-wrap
msgid "list"
msgstr "list"

#. type: cindex
#: original_texis/keymaps.texi:1059
#, no-wrap
msgid "list in keymap"
msgstr "list in keymap"

#. type: table
#: original_texis/keymaps.texi:1061
msgid "The meaning of a list depends on what it contains:"
msgstr "listの意味はそのリストが何を含んでいるかに依存する:"

#. type: itemize
#: original_texis/keymaps.texi:1066
msgid "If the @sc{car} of @var{list} is the symbol @code{keymap}, then the list is a keymap, and is treated as a keymap (see above)."
msgstr "@var{list}の@sc{car}がシンボル@code{keymap}なら、そのリストはキーマップでありキーマップとして扱われる(上記参照)。"

#. type: cindex
#: original_texis/keymaps.texi:1068
#, no-wrap
msgid "@code{lambda} in keymap"
msgstr "@code{lambda} in keymap"

#. type: itemize
#: original_texis/keymaps.texi:1074
msgid "If the @sc{car} of @var{list} is @code{lambda}, then the list is a lambda expression.  This is presumed to be a function, and is treated as such (see above).  In order to execute properly as a key binding, this function must be a command---it must have an @code{interactive} specification.  @xref{Defining Commands}."
msgstr "@var{list}の@sc{car}が@code{lambda}なら、そのリストはラムダ式である。これは関数とみなされてそのように扱われる(上記参照)。キーバインディングとして正しく実行されるために、この関数はコマンドでなければならず@code{interactive}指定をもたなければならない。@ref{Defining Commands}を参照のこと。"

#. type: var{#1}
#: original_texis/keymaps.texi:1076
#, no-wrap
msgid "symbol"
msgstr "symbol"

#. type: cindex
#: original_texis/keymaps.texi:1077
#, no-wrap
msgid "symbol in keymap"
msgstr "symbol in keymap"

#. type: table
#: original_texis/keymaps.texi:1082
msgid "The function definition of @var{symbol} is used in place of @var{symbol}.  If that too is a symbol, then this process is repeated, any number of times.  Ultimately this should lead to an object that is a keymap, a command, or a keyboard macro."
msgstr "@var{symbol}の関数定義が@var{symbol}のかわりに使用される。もし関数定義もシンボルなら、任意の回数このプロセスが繰り返される。これは最終的にキーマップであるようなオブジェクト、コマンド、またはキーボードマクロに行き着くはずである。"

#. type: table
#: original_texis/keymaps.texi:1089
msgid "Note that keymaps and keyboard macros (strings and vectors) are not valid functions, so a symbol with a keymap, string, or vector as its function definition is invalid as a function.  It is, however, valid as a key binding.  If the definition is a keyboard macro, then the symbol is also valid as an argument to @code{command-execute} (@pxref{Interactive Call})."
msgstr "キーマップとキーボードマクロ(文字列かベクター)は有効な関数ではないので関数定義にキーマップ、文字列、ベクターをもつシンボルは関数としては無効であることに注意。しかしキーバインディングとしては有効である。その定義がキーボードマクロなら、そのシンボルは@code{command-execute}(@ref{Interactive Call}を参照)の引数としても有効である。"

#. type: cindex
#: original_texis/keymaps.texi:1090
#, no-wrap
msgid "@code{undefined} in keymap"
msgstr "@code{undefined} in keymap"

#. type: table
#: original_texis/keymaps.texi:1096
msgid "The symbol @code{undefined} is worth special mention: it means to treat the key as undefined.  Strictly speaking, the key is defined, and its binding is the command @code{undefined}; but that command does the same thing that is done automatically for an undefined key: it rings the bell (by calling @code{ding}) but does not signal an error."
msgstr "シンボル@code{undefined}は特記するに値する。これはそのキーを未定義として扱うことを意味する。厳密に言うとそのキーは定義されているが、そのバインディングがコマンド@code{undefined}なのである。しかしこのコマンドは未定義キーにたいして自動的に行われるのと同じことを行う。これは(@code{ding}を呼び出して)bellを鳴らすがエラーはシグナルしない。"

#. type: cindex
#: original_texis/keymaps.texi:1097
#, no-wrap
msgid "preventing prefix key"
msgstr "preventing prefix key"

#. type: table
#: original_texis/keymaps.texi:1102
msgid "@code{undefined} is used in local keymaps to override a global key binding and make the key undefined locally.  A local binding of @code{nil} would fail to do this because it would not override the global binding."
msgstr "@code{undefined}はグローバルキーバインディングをオーバーライドして、そのキーをローカルに未定義とするために使用される。@code{nil}にローカルにバインドしてもグローバルバインディングをオーバーライドしないであろうから、これを行うのに失敗するだろう。"

#. type: var{#1}
#: original_texis/keymaps.texi:1103
#, no-wrap
msgid "anything else"
msgstr "anything else"

#. type: table
#: original_texis/keymaps.texi:1107
msgid "If any other type of object is found, the events used so far in the lookup form a complete key, and the object is its binding, but the binding is not executable as a command."
msgstr "オブジェクトの他の型が見つかったら、それまでにルックアップで使用されたイベントはコンプリートキーを形成してそのオブジェクトがバインディングになるが、そのバインディングはコマンドとして実行不可能である。"

#. type: Plain text
#: original_texis/keymaps.texi:1111
msgid "In short, a keymap entry may be a keymap, a command, a keyboard macro, a symbol that leads to one of them, or @code{nil}."
msgstr "要約するとキーマップエントリーはキーマップ、コマンド、キーボードマクロ、あるいはそれらに導出されるシンボル、あるいは@code{nil}のいずれかです。"

#. type: Plain text
#: original_texis/keymaps.texi:1116
msgid "Here are the functions and variables pertaining to key lookup."
msgstr "以下はキールックアップに関連する関数および変数です。"

#. type: defun
#: original_texis/keymaps.texi:1117
#, no-wrap
msgid "lookup-key keymap key &optional accept-defaults"
msgstr "lookup-key keymap key &optional accept-defaults"

#. type: defun
#: original_texis/keymaps.texi:1121
msgid "This function returns the definition of @var{key} in @var{keymap}.  All the other functions described in this chapter that look up keys use @code{lookup-key}.  Here are examples:"
msgstr "この関数は@var{keymap}内の@var{key}の定義をリターンする。このチャプターで説明されているキーをルックアップする他のすべての関数が@code{lookup-key}を使用する。以下は例:"

#. type: group
#: original_texis/keymaps.texi:1126
#, no-wrap
msgid ""
"(lookup-key (current-global-map) \"\\C-x\\C-f\")\n"
"    @result{} find-file\n"
msgstr ""
"(lookup-key (current-global-map) \"\\C-x\\C-f\")\n"
"    @result{} find-file\n"

#. type: group
#: original_texis/keymaps.texi:1130
#, no-wrap
msgid ""
"(lookup-key (current-global-map) (kbd \"C-x C-f\"))\n"
"    @result{} find-file\n"
msgstr ""
"(lookup-key (current-global-map) (kbd \"C-x C-f\"))\n"
"    @result{} find-file\n"

#. type: group
#: original_texis/keymaps.texi:1134
#, no-wrap
msgid ""
"(lookup-key (current-global-map) \"\\C-x\\C-f12345\")\n"
"    @result{} 2\n"
msgstr ""
"(lookup-key (current-global-map) \"\\C-x\\C-f12345\")\n"
"    @result{} 2\n"

#. type: defun
#: original_texis/keymaps.texi:1142
msgid "If the string or vector @var{key} is not a valid key sequence according to the prefix keys specified in @var{keymap}, it must be too long and have extra events at the end that do not fit into a single key sequence.  Then the value is a number, the number of events at the front of @var{key} that compose a complete key."
msgstr "文字列かベクターの@var{key}が@var{keymap}内で指定されるプレフィクスキーとして有効なキーシーケンスでなければ、それは最後に余計なイベントをもった、単一のキーシーケンスに適合しない長過ぎるキーのはずである。その場合のリターン値は数となり、この数はコンプリートキーを構成する@var{key}の前にあるイベントの数である。"

#. type: defun
#: original_texis/keymaps.texi:1150
msgid "If @var{accept-defaults} is non-@code{nil}, then @code{lookup-key} considers default bindings as well as bindings for the specific events in @var{key}.  Otherwise, @code{lookup-key} reports only bindings for the specific sequence @var{key}, ignoring default bindings except when you explicitly ask about them.  (To do this, supply @code{t} as an element of @var{key}; see @ref{Format of Keymaps}.)"
msgstr "@var{accept-defaults}が非@code{nil}なら、@code{lookup-key}は@var{key}内の特定のイベントにたいするバインディングと同様にデフォルトバインディングも考慮する。それ以外では@code{lookup-key}は特定の@var{key}のシーケンスにたいするバインディングだけを報告して、明示的に指定したとき以外はデフォルトバインディングを無視する(これを行うには@var{key}の要素として@code{t}を与える。@ref{Format of Keymaps}を参照されたい)。"

#. type: defun
#: original_texis/keymaps.texi:1156
msgid "If @var{key} contains a meta character (not a function key), that character is implicitly replaced by a two-character sequence: the value of @code{meta-prefix-char}, followed by the corresponding non-meta character.  Thus, the first example below is handled by conversion into the second example."
msgstr "@var{key}がメタ文字(ファンクションキーではない)を含むなら、その文字は暗黙に@code{meta-prefix-char}の値と対応する非メタ文字からなる2文字シーケンスに置き換えられる。したがって以下の1つ目の例は2つ目の例に変換されて処理される。"

#. type: group
#: original_texis/keymaps.texi:1161
#, no-wrap
msgid ""
"(lookup-key (current-global-map) \"\\M-f\")\n"
"    @result{} forward-word\n"
msgstr ""
"(lookup-key (current-global-map) \"\\M-f\")\n"
"    @result{} forward-word\n"

#. type: group
#: original_texis/keymaps.texi:1165
#, no-wrap
msgid ""
"(lookup-key (current-global-map) \"\\ef\")\n"
"    @result{} forward-word\n"
msgstr ""
"(lookup-key (current-global-map) \"\\ef\")\n"
"    @result{} forward-word\n"

#. type: defun
#: original_texis/keymaps.texi:1172
msgid "Unlike @code{read-key-sequence}, this function does not modify the specified events in ways that discard information (@pxref{Key Sequence Input}).  In particular, it does not convert letters to lower case and it does not change drag events to clicks."
msgstr "@code{read-key-sequence}とは異なり、この関数は指定されたイベントの情報を破棄する変更(@ref{Key Sequence Input}を参照)を行わない。特にこの関数はアルファベット文字を小文字に変更せず、ドラッグイベントをクリックイベントに変更しない。"

#. type: deffn
#: original_texis/keymaps.texi:1174
#, no-wrap
msgid "Command undefined"
msgstr "Command undefined"

#. type: deffn
#: original_texis/keymaps.texi:1177
msgid "Used in keymaps to undefine keys.  It calls @code{ding}, but does not cause an error."
msgstr "キーを未定義にするためにキーマップ内で使用される。これは@code{ding}を呼び出すがエラーを発生ささない。"

#. type: defun
#: original_texis/keymaps.texi:1179
#, no-wrap
msgid "local-key-binding key &optional accept-defaults"
msgstr "local-key-binding key &optional accept-defaults"

#. type: defun
#: original_texis/keymaps.texi:1182
msgid "This function returns the binding for @var{key} in the current local keymap, or @code{nil} if it is undefined there."
msgstr "この関数はカレントのローカルキーマップ内の@var{key}にたいするバインディングをリターンする。カレントのローカルキーマップ内で未定義なら@code{nil}をリターンする。"

#. type: defun
#: original_texis/keymaps.texi:1186 original_texis/keymaps.texi:1195
#: original_texis/keymaps.texi:1213
msgid "The argument @var{accept-defaults} controls checking for default bindings, as in @code{lookup-key} (above)."
msgstr "引数@var{accept-defaults}は@code{lookup-key}(上記)と同じようにデフォルトバインディングのチェックを制御する。"

#. type: defun
#: original_texis/keymaps.texi:1188
#, no-wrap
msgid "global-key-binding key &optional accept-defaults"
msgstr "global-key-binding key &optional accept-defaults"

#. type: defun
#: original_texis/keymaps.texi:1191
msgid "This function returns the binding for command @var{key} in the current global keymap, or @code{nil} if it is undefined there."
msgstr "この関数はカレントのグローバルキーマップ内でコマンド@var{key}にたいするバインディングをリターンする。カレントのグローバルキーマップ内で未定義なら@code{nil}をリターンする。"

#. type: defun
#: original_texis/keymaps.texi:1198
#, no-wrap
msgid "minor-mode-key-binding key &optional accept-defaults"
msgstr "minor-mode-key-binding key &optional accept-defaults"

#. type: defun
#: original_texis/keymaps.texi:1205
msgid "This function returns a list of all the active minor mode bindings of @var{key}.  More precisely, it returns an alist of pairs @code{(@var{modename} . @var{binding})}, where @var{modename} is the variable that enables the minor mode, and @var{binding} is @var{key}'s binding in that mode.  If @var{key} has no minor-mode bindings, the value is @code{nil}."
msgstr "この関数はアクティブなマイナーモードの@var{key}のバインディングをリストでリターンする。より正確にはこの関数は@code{(@var{modename} . @var{binding})}のようなペアのalistをリターンする。ここで@var{modename}なそのマイナーモードを有効にする変数、@var{binding}はそのモードでの@var{key}のバインディングである。@var{key}がマイナーモードバインディングをもたなければ値は@code{nil}。"

#. type: defun
#: original_texis/keymaps.texi:1210
msgid "If the first binding found is not a prefix definition (a keymap or a symbol defined as a keymap), all subsequent bindings from other minor modes are omitted, since they would be completely shadowed.  Similarly, the list omits non-prefix bindings that follow prefix bindings."
msgstr "最初に見つかったバインディングがプレフィクス定義(キーマップ、またはキーマップとして定義されたシンボル)でなければ、他のマイナーモードに由来するすべての後続するバインディングは完全にshadowされて省略される。同様にこのリストはプレフィクスバインディングに後続する非プレフィクスバインディングは省略される。"

#. type: defopt
#: original_texis/keymaps.texi:1215
#, no-wrap
msgid "meta-prefix-char"
msgstr "meta-prefix-char"

#. type: key{#1}
#: original_texis/keymaps.texi:1216
#, no-wrap
msgid "ESC"
msgstr "ESC"

#. type: defopt
#: original_texis/keymaps.texi:1222
msgid "This variable is the meta-prefix character code.  It is used for translating a meta character to a two-character sequence so it can be looked up in a keymap.  For useful results, the value should be a prefix event (@pxref{Prefix Keys}).  The default value is 27, which is the @acronym{ASCII} code for @key{ESC}."
msgstr "この変数はメタ/プレフィクス文字コードである。これはメタ文字をキーマップ内でルックアップできるように2文字シーケンスに変換する。有用な結果を得るために値はプレフィクスイベント(@ref{Prefix Keys}を参照)であること。デフォルト値は27で、これは@key{ESC}にたいする@acronym{ASCII}コード。"

#. type: defopt
#: original_texis/keymaps.texi:1230
msgid "As long as the value of @code{meta-prefix-char} remains 27, key lookup translates @kbd{M-b} into @kbd{@key{ESC} b}, which is normally defined as the @code{backward-word} command.  However, if you were to set @code{meta-prefix-char} to 24, the code for @kbd{C-x}, then Emacs will translate @kbd{M-b} into @kbd{C-x b}, whose standard binding is the @code{switch-to-buffer} command.  (Don't actually do this!)  Here is an illustration of what would happen:"
msgstr "@code{meta-prefix-char}の値が27であるような限り、キールックアップは通常は@code{backward-word}コマンドとして定義される@kbd{M-b}を@kbd{@key{ESC} b}に変換する。しかし@code{meta-prefix-char}を24(@kbd{C-x}のコード)にセットすると、Emacsは@kbd{M-b}を@kbd{C-x b}に変換するだろうが、これの標準のバインディングは@code{switch-to-buffer}コマンドである。以下に何が起こるかを示す(実際にこれを行ってはならない!):"

#. type: group
#: original_texis/keymaps.texi:1235
#, no-wrap
msgid ""
"meta-prefix-char                    ; @r{The default value.}\n"
"     @result{} 27\n"
msgstr ""
"meta-prefix-char                    ; @r{デフォルト値}\n"
"     @result{} 27\n"

#. type: group
#: original_texis/keymaps.texi:1239
#, no-wrap
msgid ""
"(key-binding \"\\M-b\")\n"
"     @result{} backward-word\n"
msgstr ""
"(key-binding \"\\M-b\")\n"
"     @result{} backward-word\n"

#. type: group
#: original_texis/keymaps.texi:1243
#, no-wrap
msgid ""
"?\\C-x                               ; @r{The print representation}\n"
"     @result{} 24                          ;   @r{of a character.}\n"
msgstr ""
"?\\C-x                               ; @r{文字.の}\n"
"     @result{} 24                          ; @r{プリント表現}\n"

#. type: group
#: original_texis/keymaps.texi:1247
#, no-wrap
msgid ""
"(setq meta-prefix-char 24)\n"
"     @result{} 24\n"
msgstr ""
"(setq meta-prefix-char 24)\n"
"     @result{} 24\n"

#. type: group
#: original_texis/keymaps.texi:1252
#, no-wrap
msgid ""
"(key-binding \"\\M-b\")\n"
"     @result{} switch-to-buffer            ; @r{Now, typing @kbd{M-b} is}\n"
"                                    ;   @r{like typing @kbd{C-x b}.}\n"
"\n"
msgstr ""
"(key-binding \"\\M-b\")\n"
"     @result{} switch-to-buffer            ; @r{今や@kbd{M-b}をタイプすると}\n"
"                                    ;   @r{@kbd{C-x b}をタイプしたようになる}\n"
"\n"

#. type: group
#: original_texis/keymaps.texi:1255
#, no-wrap
msgid ""
"(setq meta-prefix-char 27)          ; @r{Avoid confusion!}\n"
"     @result{} 27                          ; @r{Restore the default value!}\n"
msgstr ""
"(setq meta-prefix-char 27)          ; @r{混乱を避けよう!}\n"
"     @result{} 27                          ; @r{デフォルト値をリストア!}\n"

#. type: defopt
#: original_texis/keymaps.texi:1261
msgid "This translation of one event into two happens only for characters, not for other kinds of input events.  Thus, @kbd{M-@key{F1}}, a function key, is not converted into @kbd{@key{ESC} @key{F1}}."
msgstr "この単一イベントから2イベントへの変換は文字にたいしてのみ発生し、他の種類の入力イベントには発生しない。したがってファンクションキー@kbd{M-@key{F1}}は@kbd{@key{ESC} @key{F1}}に変換されない。"

#. type: cindex
#: original_texis/keymaps.texi:1265
#, no-wrap
msgid "changing key bindings"
msgstr "changing key bindings"

#. type: cindex
#: original_texis/keymaps.texi:1266
#, no-wrap
msgid "rebinding"
msgstr "rebinding"

#. type: Plain text
#: original_texis/keymaps.texi:1277
msgid "The way to rebind a key is to change its entry in a keymap.  If you change a binding in the global keymap, the change is effective in all buffers (though it has no direct effect in buffers that shadow the global binding with a local one).  If you change the current buffer's local map, that usually affects all buffers using the same major mode.  The @code{global-set-key} and @code{local-set-key} functions are convenient interfaces for these operations (@pxref{Key Binding Commands}).  You can also use @code{define-key}, a more general function; then you must explicitly specify the map to change."
msgstr "キーのリバインド(rebind: 再バインド、再束縛)は、キーマップ内でそのキーのバインディングエントリーを変更することによって行われます。グローバルキーマップ内のバインディングを変更すると、その変更は(たとえローカルバインディングによりグローバルバインディングをshadowしているバッファーでは直接影響しないとしても)すべてのバッファーに影響します。カレントバッファーのローカルマップを変更すると、通常は同じメジャーモードを使用するすべてのバッファーに影響します。関数@code{global-set-key}と@code{local-set-key}は、これらの操作のための使いやすいインターフェイスです(@ref{Key Binding Commands}を参照)。より汎用的な関数@code{define-key}を使用することもできます。その場合には変更するマップを明示的に指定しなければなりません。"

#. type: Plain text
#: original_texis/keymaps.texi:1281
msgid "When choosing the key sequences for Lisp programs to rebind, please follow the Emacs conventions for use of various keys (@pxref{Key Binding Conventions})."
msgstr "Lispプログラムでリバインドするキーシーケンスを選択するときは、さまざまなキーの使用についてのEmacsの慣習にしたがってください(@ref{Key Binding Conventions}を参照)。"

#. type: cindex
#: original_texis/keymaps.texi:1282
#, no-wrap
msgid "meta character key constants"
msgstr "meta character key constants"

#. type: cindex
#: original_texis/keymaps.texi:1283
#, no-wrap
msgid "control character key constants"
msgstr "control character key constants"

#. type: Plain text
#: original_texis/keymaps.texi:1294
msgid "In writing the key sequence to rebind, it is good to use the special escape sequences for control and meta characters (@pxref{String Type}).  The syntax @samp{\\C-} means that the following character is a control character and @samp{\\M-} means that the following character is a meta character.  Thus, the string @code{\"\\M-x\"} is read as containing a single @kbd{M-x}, @code{\"\\C-f\"} is read as containing a single @kbd{C-f}, and @code{\"\\M-\\C-x\"} and @code{\"\\C-\\M-x\"} are both read as containing a single @kbd{C-M-x}.  You can also use this escape syntax in vectors, as well as others that aren't allowed in strings; one example is @samp{[?\\C-\\H-x home]}.  @xref{Character Type}."
msgstr "リバインドするキーシーケンスの記述では、コントロール文字とメタ文字にたいして特別なエスケープシーケンスを使用すると良いでしょう(@ref{String Type}を参照)。構文@samp{\\C-}は後続する文字がコントロール文字でること、@samp{\\M-}は後続する文字がメタ文字であることを意味します。したがって文字列@code{\"\\M-x\"}は1つの@kbd{M-x}、@code{\"\\C-f\"}は1つの@kbd{C-f}、@code{\"\\M-\\C-x\"}と@code{\"\\C-\\M-x\"}は1つの@kbd{C-M-x}として読み取られます。ベクター内でもこのエスケープシーケンス、および文字列では使用できない他のエスケープシーケンスを使用できます。一例は@samp{[?\\C-\\H-x home]}です。@ref{Character Type}を参照してください。"

#. type: Plain text
#: original_texis/keymaps.texi:1302
msgid "The key definition and lookup functions accept an alternate syntax for event types in a key sequence that is a vector: you can use a list containing modifier names plus one base event (a character or function key name).  For example, @code{(control ?a)} is equivalent to @code{?\\C-a} and @code{(hyper control left)} is equivalent to @code{C-H-left}.  One advantage of such lists is that the precise numeric codes for the modifier bits don't appear in compiled files."
msgstr "キー定義とルックアップ関数は、ベクターであるようなキーシーケンス内のイベント型にたいして別の構文を受け入れます。修飾名に基本イベント(文字かファンクションキー名)を付加したものを含んだリストを使用できます。たとえば@code{(control ?a)}は@code{?\\C-a}、@code{(hyper control left)}は@code{C-H-left}と等価です。このようなリストの利点の1つは、コンパイル済みファイル内に修飾ビットの正確な数値コードが出現しないことです。"

#. type: Plain text
#: original_texis/keymaps.texi:1308
msgid "The functions below signal an error if @var{keymap} is not a keymap, or if @var{key} is not a string or vector representing a key sequence.  You can use event types (symbols) as shorthand for events that are lists.  The @code{kbd} function (@pxref{Key Sequences}) is a convenient way to specify the key sequence."
msgstr "以下の関数は@var{keymap}がキーマップでない場合、および@var{key}がキーシーケンスを表す文字列やベクターでない場合にはエラーをシグナルします。リストであるようなイベントにたいする略記として、イベント型(シンボル)を使用できます。@code{kbd}関数(@ref{Key Sequences}を参照)はキーシーケンスを指定するための便利な方法です。"

#. type: defun
#: original_texis/keymaps.texi:1309
#, no-wrap
msgid "define-key keymap key binding"
msgstr "define-key keymap key binding"

#. type: defun
#: original_texis/keymaps.texi:1316
msgid "This function sets the binding for @var{key} in @var{keymap}.  (If @var{key} is more than one event long, the change is actually made in another keymap reached from @var{keymap}.)  The argument @var{binding} can be any Lisp object, but only certain types are meaningful.  (For a list of meaningful types, see @ref{Key Lookup}.)  The value returned by @code{define-key} is @var{binding}."
msgstr "この関数は@var{keymap}内で@var{key}にたいするバインディングをセットする(@var{key}が長さ2以上のイベントなら、その変更は実際は@var{keymap}から辿られる他のキーマップで行なわれる)。引数@var{binding}には任意のLispオブジェクトを指定できるが、意味があるのは特定のオブジェクトだけである(意味のある型のリストは@ref{Key Lookup}を参照)。@code{define-key}のリターン値は@var{binding}である。"

#. type: defun
#: original_texis/keymaps.texi:1320
msgid "If @var{key} is @code{[t]}, this sets the default binding in @var{keymap}.  When an event has no binding of its own, the Emacs command loop uses the keymap's default binding, if there is one."
msgstr "@var{key}が@code{[t]}なら、それは@var{keymap}内でデフォルトバインディングをセットする。イベントが自身のバインディングをもたないとき、そのキーマップ内にデフォルトバインディングが存在すればEmacsコマンドループはそれを使用する。"

#. type: cindex
#: original_texis/keymaps.texi:1321
#, no-wrap
msgid "invalid prefix key error"
msgstr "invalid prefix key error"

#. type: cindex
#: original_texis/keymaps.texi:1322
#, no-wrap
msgid "key sequence error"
msgstr "key sequence error"

#. type: defun
#: original_texis/keymaps.texi:1327
msgid "Every prefix of @var{key} must be a prefix key (i.e., bound to a keymap)  or undefined; otherwise an error is signaled.  If some prefix of @var{key} is undefined, then @code{define-key} defines it as a prefix key so that the rest of @var{key} can be defined as specified."
msgstr "@var{key}のすべてのプレフィクスは、プレフィクスキー(キーマップにバインドされる)か、あるいは未定義でなけらばならず、それ以外ならエラーがシグナルされる。@var{key}のいくつかのプレフィクスが未定義なら、@code{define-key}はそれをプレフィクスキーとして定義するので、残りの@var{key}は指定されたように定義できる。"

#. type: defun
#: original_texis/keymaps.texi:1332
msgid "If there was previously no binding for @var{key} in @var{keymap}, the new binding is added at the beginning of @var{keymap}.  The order of bindings in a keymap makes no difference for keyboard input, but it does matter for menu keymaps (@pxref{Menu Keymaps})."
msgstr "前に@var{keymap}内で@var{key}にたいするバインディングが存在しなければ、新たなバインディングが@var{keymap}の先頭に追加される。キーマップ内のバインディングの順序はキーボード入力にたいし影響を与えないが、メニューキーマップにたいしては問題となる(@ref{Menu Keymaps}を参照)。"

#. type: Plain text
#: original_texis/keymaps.texi:1336
msgid "This example creates a sparse keymap and makes a number of bindings in it:"
msgstr "以下はsparseキーマップを作成してその中にバインディングをいくつか作成する例:"

#. type: group
#: original_texis/keymaps.texi:1341
#, no-wrap
msgid ""
"(setq map (make-sparse-keymap))\n"
"    @result{} (keymap)\n"
msgstr ""
"(setq map (make-sparse-keymap))\n"
"    @result{} (keymap)\n"

#. type: group
#: original_texis/keymaps.texi:1345
#, no-wrap
msgid ""
"(define-key map \"\\C-f\" 'forward-char)\n"
"    @result{} forward-char\n"
msgstr ""
"(define-key map \"\\C-f\" 'forward-char)\n"
"    @result{} forward-char\n"

#. type: group
#: original_texis/keymaps.texi:1349
#, no-wrap
msgid ""
"map\n"
"    @result{} (keymap (6 . forward-char))\n"
msgstr ""
"map\n"
"    @result{} (keymap (6 . forward-char))\n"

#. type: group
#: original_texis/keymaps.texi:1355
#, no-wrap
msgid ""
";; @r{Build sparse submap for @kbd{C-x} and bind @kbd{f} in that.}\n"
"(define-key map (kbd \"C-x f\") 'forward-word)\n"
"    @result{} forward-word\n"
msgstr ""
";; @r{@kbd{C-x}にたいしsparseサブマップを作成して\n"
";; その中で@kbd{f}をバインドする}\n"
"(define-key map (kbd \"C-x f\") 'forward-word)\n"
"    @result{} forward-word\n"

#. type: group
#: original_texis/keymaps.texi:1362
#, no-wrap
msgid ""
"map\n"
"@result{} (keymap\n"
"    (24 keymap                ; @kbd{C-x}\n"
"        (102 . forward-word)) ;      @kbd{f}\n"
"    (6 . forward-char))       ; @kbd{C-f}\n"
msgstr ""
"map\n"
"@result{} (keymap\n"
"    (24 keymap                ; @kbd{C-x}\n"
"        (102 . forward-word)) ;      @kbd{f}\n"
"    (6 . forward-char))       ; @kbd{C-f}\n"

#. type: group
#: original_texis/keymaps.texi:1369
#, no-wrap
msgid ""
";; @r{Bind @kbd{C-p} to the @code{ctl-x-map}.}\n"
"(define-key map (kbd \"C-p\") ctl-x-map)\n"
";; @code{ctl-x-map}\n"
"@result{} [nil @dots{} find-file @dots{} backward-kill-sentence]\n"
msgstr ""
";; @r{@kbd{C-p}を@code{ctl-x-map}にバインド}\n"
"(define-key map (kbd \"C-p\") ctl-x-map)\n"
";; @code{ctl-x-map}\n"
"@result{} [nil @dots{} find-file @dots{} backward-kill-sentence]\n"

#. type: group
#: original_texis/keymaps.texi:1375
#, no-wrap
msgid ""
";; @r{Bind @kbd{C-f} to @code{foo} in the @code{ctl-x-map}.}\n"
"(define-key map (kbd \"C-p C-f\") 'foo)\n"
"@result{} 'foo\n"
msgstr ""
";; @r{@code{ctl-x-map}内で@kbd{C-f}を@code{foo}にバインド}\n"
"(define-key map (kbd \"C-p C-f\") 'foo)\n"
"@result{} 'foo\n"

#. type: group
#: original_texis/keymaps.texi:1383
#, no-wrap
msgid ""
"map\n"
"@result{} (keymap     ; @r{Note @code{foo} in @code{ctl-x-map}.}\n"
"    (16 keymap [nil @dots{} foo @dots{} backward-kill-sentence])\n"
"    (24 keymap\n"
"        (102 . forward-word))\n"
"    (6 . forward-char))\n"
msgstr ""
"map\n"
"@result{} (keymap     ; @r{@code{ctl-x-map}内の@code{foo}に注目}\n"
"    (16 keymap [nil @dots{} foo @dots{} backward-kill-sentence])\n"
"    (24 keymap\n"
"        (102 . forward-word))\n"
"    (6 . forward-char))\n"

#. type: Plain text
#: original_texis/keymaps.texi:1391
msgid "Note that storing a new binding for @kbd{C-p C-f} actually works by changing an entry in @code{ctl-x-map}, and this has the effect of changing the bindings of both @kbd{C-p C-f} and @kbd{C-x C-f} in the default global map."
msgstr "@kbd{C-p C-f}にたいする新たなバインディングの格納は、実際には@code{ctl-x-map}内のエントリーを変更することによって機能し、これはデフォルトグローバルマップ内の@kbd{C-p C-f}と@kbd{C-x C-f}の両方のバインディングを変更する効果をもつことに注意。"

#. type: Plain text
#: original_texis/keymaps.texi:1397
msgid "The function @code{substitute-key-definition} scans a keymap for keys that have a certain binding and rebinds them with a different binding.  Another feature which is cleaner and can often produce the same results is to remap one command into another (@pxref{Remapping Commands})."
msgstr "関数@code{substitute-key-definition}はキーマップから特定のバインディングをもつキーをスキャンして、それらを異なるバインディングにリバインドする。より明快かつ多くの場合には同じ結果を生成できる他の機能として、あるコマンドから別のコマンドへのリマップがある(@ref{Remapping Commands}を参照)。"

#. type: defun
#: original_texis/keymaps.texi:1398
#, no-wrap
msgid "substitute-key-definition olddef newdef keymap &optional oldmap"
msgstr "substitute-key-definition olddef newdef keymap &optional oldmap"

#. type: cindex
#: original_texis/keymaps.texi:1399
#, no-wrap
msgid "replace bindings"
msgstr "replace bindings"

#. type: defun
#: original_texis/keymaps.texi:1404
msgid "This function replaces @var{olddef} with @var{newdef} for any keys in @var{keymap} that were bound to @var{olddef}.  In other words, @var{olddef} is replaced with @var{newdef} wherever it appears.  The function returns @code{nil}."
msgstr "この関数は@var{keymap}内で@var{olddef}にバインドされるすべてのキーについて@var{olddef}を@var{newdef}に置き換える。言い換えると@var{olddef}が出現する箇所のすべてを@var{newdef}に置き換える。この関数は@code{nil}をリターンする。"

#. type: defun
#: original_texis/keymaps.texi:1407
msgid "For example, this redefines @kbd{C-x C-f}, if you do it in an Emacs with standard bindings:"
msgstr "たとえば以下をEmacsの標準バインディングで行うと@kbd{C-x C-f}を再定義する:"

#. type: group
#: original_texis/keymaps.texi:1412
#, no-wrap
msgid ""
"(substitute-key-definition\n"
" 'find-file 'find-file-read-only (current-global-map))\n"
msgstr ""
"(substitute-key-definition\n"
" 'find-file 'find-file-read-only (current-global-map))\n"

#. type: defun
#: original_texis/keymaps.texi:1421
msgid "If @var{oldmap} is non-@code{nil}, that changes the behavior of @code{substitute-key-definition}: the bindings in @var{oldmap} determine which keys to rebind.  The rebindings still happen in @var{keymap}, not in @var{oldmap}.  Thus, you can change one map under the control of the bindings in another.  For example,"
msgstr "@var{oldmap}が非@code{nil}なら、どのキーをリバインドするかを@var{oldmap}内のバインディングが決定するように@code{substitute-key-definition}の動作を変更する。リバインディングは依然として@var{oldmap}ではなく@var{keymap}で発生する。したがって他のマップ内のバインディングの制御下でマップを変更することができる。たとえば、"

#. type: smallexample
#: original_texis/keymaps.texi:1426
#, no-wrap
msgid ""
"(substitute-key-definition\n"
"  'delete-backward-char 'my-funny-delete\n"
"  my-map global-map)\n"
msgstr ""
"(substitute-key-definition\n"
"  'delete-backward-char 'my-funny-delete\n"
"  my-map global-map)\n"

#. type: defun
#: original_texis/keymaps.texi:1431
msgid "puts the special deletion command in @code{my-map} for whichever keys are globally bound to the standard deletion command."
msgstr "これは標準的な削除コマンドにグローバルにバインドされたキーにたいして@code{my-map}内の特別な削除コマンドを設定する。"

#. type: defun
#: original_texis/keymaps.texi:1433
msgid "Here is an example showing a keymap before and after substitution:"
msgstr "以下はキーマップの置き換え(substitution)の前後を示した例:"

#. type: group
#: original_texis/keymaps.texi:1441
#, no-wrap
msgid ""
"(setq map '(keymap\n"
"            (?1 . olddef-1)\n"
"            (?2 . olddef-2)\n"
"            (?3 . olddef-1)))\n"
"@result{} (keymap (49 . olddef-1) (50 . olddef-2) (51 . olddef-1))\n"
msgstr ""
"(setq map '(keymap\n"
"            (?1 . olddef-1)\n"
"            (?2 . olddef-2)\n"
"            (?3 . olddef-1)))\n"
"@result{} (keymap (49 . olddef-1) (50 . olddef-2) (51 . olddef-1))\n"

#. type: group
#: original_texis/keymaps.texi:1446
#, no-wrap
msgid ""
"(substitute-key-definition 'olddef-1 'newdef map)\n"
"@result{} nil\n"
msgstr ""
"(substitute-key-definition 'olddef-1 'newdef map)\n"
"@result{} nil\n"

#. type: group
#: original_texis/keymaps.texi:1450
#, no-wrap
msgid ""
"map\n"
"@result{} (keymap (49 . newdef) (50 . olddef-2) (51 . newdef))\n"
msgstr ""
"map\n"
"@result{} (keymap (49 . newdef) (50 . olddef-2) (51 . newdef))\n"

#. type: defun
#: original_texis/keymaps.texi:1454
#, no-wrap
msgid "suppress-keymap keymap &optional nodigits"
msgstr "suppress-keymap keymap &optional nodigits"

#. type: cindex
#: original_texis/keymaps.texi:1455
#, no-wrap
msgid "@code{self-insert-command} override"
msgstr "@code{self-insert-command} override"

#. type: defun
#: original_texis/keymaps.texi:1461
msgid "This function changes the contents of the full keymap @var{keymap} by remapping @code{self-insert-command} to the command @code{undefined} (@pxref{Remapping Commands}).  This has the effect of undefining all printing characters, thus making ordinary insertion of text impossible.  @code{suppress-keymap} returns @code{nil}."
msgstr "この関数は@code{self-insert-command}をコマンド@code{undefined}にリマップ(@ref{Remapping Commands}を参照)することによってfullキーマップのコンテンツを変更する。これはすべてのプリント文字を未定義にする効果をもつので、通常のテキスト挿入は不可能になる。@code{suppress-keymap}は@code{nil}をリターンする。"

#. type: defun
#: original_texis/keymaps.texi:1466
msgid "If @var{nodigits} is @code{nil}, then @code{suppress-keymap} defines digits to run @code{digit-argument}, and @kbd{-} to run @code{negative-argument}.  Otherwise it makes them undefined like the rest of the printing characters."
msgstr "@var{nodigits}が@code{nil}なら、@code{suppress-keymap}は数字が@code{digit-argument}、@kbd{-}が@code{negative-argument}を実行するように定義する。それ以外は残りのプリント文字と同じように、それらの文字も未定義にする。"

#. type: cindex
#: original_texis/keymaps.texi:1467
#, no-wrap
msgid "yank suppression"
msgstr "yank suppression"

#. type: cindex
#: original_texis/keymaps.texi:1468
#, no-wrap
msgid "@code{quoted-insert} suppression"
msgstr "@code{quoted-insert} suppression"

#. type: defun
#: original_texis/keymaps.texi:1473
msgid "The @code{suppress-keymap} function does not make it impossible to modify a buffer, as it does not suppress commands such as @code{yank} and @code{quoted-insert}.  To prevent any modification of a buffer, make it read-only (@pxref{Read Only Buffers})."
msgstr "@code{suppress-keymap}関数は@code{yank}や@code{quoted-insert}のようなコマンドを抑制(suppress)しないのでバッファーの変更は可能。バッファーの変更を防ぐには、バッファーを読み取り専用(read-only)にすること(@ref{Read Only Buffers}を参照)。"

#. type: defun
#: original_texis/keymaps.texi:1479
msgid "Since this function modifies @var{keymap}, you would normally use it on a newly created keymap.  Operating on an existing keymap that is used for some other purpose is likely to cause trouble; for example, suppressing @code{global-map} would make it impossible to use most of Emacs."
msgstr "この関数は@var{keymap}を変更するので、通常は新たに作成したキーマップにたいして使用するだろう。他の目的のために使用されている既存のキーマップに操作を行うと恐らくトラブルの原因となる。たとえば@code{global-map}の抑制はEmacsをほとんど使用不可能にするだろう。"

#. type: defun
#: original_texis/keymaps.texi:1486
msgid "This function can be used to initialize the local keymap of a major mode for which insertion of text is not desirable.  But usually such a mode should be derived from @code{special-mode} (@pxref{Basic Major Modes}); then its keymap will automatically inherit from @code{special-mode-map}, which is already suppressed.  Here is how @code{special-mode-map} is defined:"
msgstr "この関数はテキストの挿入が望ましくないメジャーモードの、ローカルキーマップ初期化に使用され得る。しかしそのようなモードは通常は@code{special-mode} (@ref{Basic Major Modes}を参照)から継承される。この場合にはそのモードのキーマップは既に抑制済みの@code{special-mode-map}から自動的に受け継がれる。以下に@code{special-mode-map}が定義される方法を示す:"

#. type: group
#: original_texis/keymaps.texi:1495
#, no-wrap
msgid ""
"(defvar special-mode-map\n"
"  (let ((map (make-sparse-keymap)))\n"
"    (suppress-keymap map)\n"
"    (define-key map \"q\" 'quit-window)\n"
"    @dots{}\n"
"    map))\n"
msgstr ""
"(defvar special-mode-map\n"
"  (let ((map (make-sparse-keymap)))\n"
"    (suppress-keymap map)\n"
"    (define-key map \"q\" 'quit-window)\n"
"    @dots{}\n"
"    map))\n"

#. type: cindex
#: original_texis/keymaps.texi:1501
#, no-wrap
msgid "remapping commands"
msgstr "remapping commands"

#. type: Plain text
#: original_texis/keymaps.texi:1510
msgid "A special kind of key binding can be used to @dfn{remap} one command to another, without having to refer to the key sequence(s) bound to the original command.  To use this feature, make a key binding for a key sequence that starts with the dummy event @code{remap}, followed by the command name you want to remap; for the binding, specify the new definition (usually a command name, but possibly any other valid definition for a key binding)."
msgstr "あるコマンドから他のコマンドへの@dfn{リマップ(remap)}には、特別な種類のキーバインディングが使用できます。この機能を使用するためには、ダミーイベント@code{remap}で始まり、その後にリマップしたいコマンド名が続くようなキーシーケンスにたいするキーバインディングを作成します。そしてそのバインディングにたいしては、新たな定義(通常はコマンド名だがキーバインディングにたいして有効な他の任意の定義を指定可能)を指定します。"

#. type: Plain text
#: original_texis/keymaps.texi:1515
msgid "For example, suppose My mode provides a special command @code{my-kill-line}, which should be invoked instead of @code{kill-line}.  To establish this, its mode keymap should contain the following remapping:"
msgstr "たとえばMyモードというモードが、@code{kill-line}のかわりに呼び出される@code{my-kill-line}という特別なコマンドを提供するとします。これを設定するには、このモードのキーマップに以下のようなリマッピングが含まれるはずです:"

#. type: smallexample
#: original_texis/keymaps.texi:1518
#, no-wrap
msgid "(define-key my-mode-map [remap kill-line] 'my-kill-line)\n"
msgstr "(define-key my-mode-map [remap kill-line] 'my-kill-line)\n"

#. type: Plain text
#: original_texis/keymaps.texi:1524
msgid "Then, whenever @code{my-mode-map} is active, if the user types @kbd{C-k} (the default global key sequence for @code{kill-line}) Emacs will instead run @code{my-kill-line}."
msgstr "その後は@code{my-mode-map}がアクティブなときは常に、ユーザーが@kbd{C-k} (@code{kill-line}にたいするデフォルトのグローバルキーシーケンス)をタイプするとEmacsはかわりに@code{my-kill-line}を実行するでしょう。"

#. type: Plain text
#: original_texis/keymaps.texi:1530
msgid "Note that remapping only takes place through active keymaps; for example, putting a remapping in a prefix keymap like @code{ctl-x-map} typically has no effect, as such keymaps are not themselves active.  In addition, remapping only works through a single level; in the following example,"
msgstr "リマップはアクティブなキーマップでのみ行なわれることに注意してください。たとえば@code{ctl-x-map}のようなプレフィクスキーマップ内にリマッピングを置いても、そのようなキーマップはそれ自体がアクティブでないので通常は効果がありません。それに加えてリマップは1レベルを通じてのみ機能します。以下の例では、"

#. type: smallexample
#: original_texis/keymaps.texi:1534
#, no-wrap
msgid ""
"(define-key my-mode-map [remap kill-line] 'my-kill-line)\n"
"(define-key my-mode-map [remap my-kill-line] 'my-other-kill-line)\n"
msgstr ""
"(define-key my-mode-map [remap kill-line] 'my-kill-line)\n"
"(define-key my-mode-map [remap my-kill-line] 'my-other-kill-line)\n"

#. type: Plain text
#: original_texis/keymaps.texi:1541
msgid "@code{kill-line} is @emph{not} remapped to @code{my-other-kill-line}.  Instead, if an ordinary key binding specifies @code{kill-line}, it is remapped to @code{my-kill-line}; if an ordinary binding specifies @code{my-kill-line}, it is remapped to @code{my-other-kill-line}."
msgstr "これは@code{kill-line}を@code{my-other-kill-line}にリマップ@emph{しません}。かわりに通常のキーバインディングが@code{kill-line}を指定する場合には、それが@code{my-kill-line}にリマップされます。通常のバインディングが@code{my-kill-line}を指定すると、@code{my-other-kill-line}にリマップされます。"

#. type: Plain text
#: original_texis/keymaps.texi:1543
msgid "To undo the remapping of a command, remap it to @code{nil}; e.g.,"
msgstr "コマンドのリマップをアンドゥするには、以下のようにそれを@code{nil}にリマップします："

#. type: smallexample
#: original_texis/keymaps.texi:1546
#, no-wrap
msgid "(define-key my-mode-map [remap kill-line] nil)\n"
msgstr "(define-key my-mode-map [remap kill-line] nil)\n"

#. type: defun
#: original_texis/keymaps.texi:1548
#, no-wrap
msgid "command-remapping command &optional position keymaps"
msgstr "command-remapping command &optional position keymaps"

#. type: defun
#: original_texis/keymaps.texi:1555
msgid "This function returns the remapping for @var{command} (a symbol), given the current active keymaps.  If @var{command} is not remapped (which is the usual situation), or not a symbol, the function returns @code{nil}.  @code{position} can optionally specify a buffer position or an event position to determine the keymaps to use, as in @code{key-binding}."
msgstr "この関数はカレントアクティブキーマップによって与えられる@var{command}(シンボル)にたいするリマッピングをリターンする。@var{command}がリマップされていない(これは普通の状況である)、あるいはシンボル以外なら、この関数は@code{nil}をリターンする。@code{position}は@code{key-binding}の場合と同様、使用するキーマップを決定するためにバッファー位置かイベント位置をオプションで指定できる。"

#. type: defun
#: original_texis/keymaps.texi:1559
msgid "If the optional argument @code{keymaps} is non-@code{nil}, it specifies a list of keymaps to search in.  This argument is ignored if @code{position} is non-@code{nil}."
msgstr "オプション引数@code{keymaps}が非@code{nil}なら、それは検索するキーマップのリストを指定する。この引数は@code{position}が非@code{nil}なら無視される。"

#. type: section
#: original_texis/keymaps.texi:1562
#, no-wrap
msgid "Keymaps for Translating Sequences of Events"
msgstr "Keymaps for Translating Sequences of Events"

#. type: cindex
#: original_texis/keymaps.texi:1563
#, no-wrap
msgid "translation keymap"
msgstr "translation keymap"

#. type: cindex
#: original_texis/keymaps.texi:1564
#, no-wrap
msgid "keymaps for translating events"
msgstr "keymaps for translating events"

#. type: Plain text
#: original_texis/keymaps.texi:1571
msgid "When the @code{read-key-sequence} function reads a key sequence (@pxref{Key Sequence Input}), it uses @dfn{translation keymaps} to translate certain event sequences into others.  The translation keymaps are @code{input-decode-map}, @code{local-function-key-map}, and @code{key-translation-map} (in order of priority)."
msgstr "@code{read-key-sequence}関数がキーシーケンス(@ref{Key Sequence Input}を参照)を読み取るときには、特定のイベントシーケンスを他のものに変換(translate)するために@dfn{変換キーマップ(translation keymaps)}を使用します。@code{input-decode-map}、@code{local-function-key-map}、@code{key-translation-map}(優先順)は変換キーマップです。"

#. type: Plain text
#: original_texis/keymaps.texi:1580
msgid "Translation keymaps have the same structure as other keymaps, but are used differently: they specify translations to make while reading key sequences, rather than bindings for complete key sequences.  As each key sequence is read, it is checked against each translation keymap.  If one of the translation keymaps binds @var{k} to a vector @var{v}, then whenever @var{k} appears as a sub-sequence @emph{anywhere} in a key sequence, that sub-sequence is replaced with the events in @var{v}."
msgstr "変換キーマップは他のキーマップと同じ構造をもちますが使い方は異なります。変換キーマップはキーシーケンスを読み取るときに、コンプリートキーシーケンスにたいするバインディングではなくキーシーケンスに行う変換を指定します。キーシーケンスが読み取られると、それらのキーシーケンスは変換キーマップにたいしてチェックされます。ある変換キーマップが@var{k}をベクター@var{v}にバインドするなら、キーシーケンス内の@emph{どこか}にサブシーケンスとして@var{k}が出現すると、それは@var{v}内のイベントに置き換えられます。"

#. type: Plain text
#: original_texis/keymaps.texi:1589
msgid "For example, VT100 terminals send @kbd{@key{ESC} O P} when the keypad key @key{PF1} is pressed.  On such terminals, Emacs must translate that sequence of events into a single event @code{pf1}.  This is done by binding @kbd{@key{ESC} O P} to @code{[pf1]} in @code{input-decode-map}.  Thus, when you type @kbd{C-c @key{PF1}} on the terminal, the terminal emits the character sequence @kbd{C-c @key{ESC} O P}, and @code{read-key-sequence} translates this back into @kbd{C-c @key{PF1}} and returns it as the vector @code{[?\\C-c pf1]}."
msgstr "たとえばキーパッドキー@key{PF1}が押下されたとき、VT100端末は@kbd{@key{ESC} O P}を送信します。そのような端末ではEmacsはそのイベントシーケンスを単一イベント@code{pf1}に変換しなければなりません。これは@code{input-decode-map}内で@kbd{@key{ESC} O P}を@code{[pf1]}にバインドすることにより行われます。したがってその端末上で@kbd{C-c @key{PF1}}をタイプしたとき、端末は文字シーケンス@kbd{C-c @key{ESC} O P}を発行して、@code{read-key-sequence}がそれを@kbd{C-c @key{PF1}}に変換、ベクター@code{[?\\C-c pf1]}としてリターンします。"

#. type: Plain text
#: original_texis/keymaps.texi:1593
msgid "Translation keymaps take effect only after Emacs has decoded the keyboard input (via the input coding system specified by @code{keyboard-coding-system}).  @xref{Terminal I/O Encoding}."
msgstr "変換キーマップは、(@code{keyboard-coding-system}で指定された入力コーディングシステムを通じて)Emacsがキーボード入力をデコードした直後だけ効果をもちます。@ref{Terminal I/O Encoding}を参照してください。"

#. type: defvar
#: original_texis/keymaps.texi:1594
#, no-wrap
msgid "input-decode-map"
msgstr "input-decode-map"

#. type: defvar
#: original_texis/keymaps.texi:1597
msgid "This variable holds a keymap that describes the character sequences sent by function keys on an ordinary character terminal."
msgstr "この変数は通常の文字端末上のファンクションキーから送信された文字シーケンスを記述するキーマップを保持する。"

#. type: defvar
#: original_texis/keymaps.texi:1604
msgid "The value of @code{input-decode-map} is usually set up automatically according to the terminal's Terminfo or Termcap entry, but sometimes those need help from terminal-specific Lisp files.  Emacs comes with terminal-specific files for many common terminals; their main purpose is to make entries in @code{input-decode-map} beyond those that can be deduced from Termcap and Terminfo.  @xref{Terminal-Specific}."
msgstr "@code{input-decode-map}の値は、通常はその端末のTerminfoかTermcapのエントリーに応じて自動的にセットアップされるが、Lispの端末仕様ファイルの助けが必要なときもある。Emacsには一般的な多くの端末の端末仕様ファイルが同梱されている。これらのファイルの主な目的はTermcapやTerminfoから推定できないエントリーを@code{input-decode-map}内に作成することである。@ref{Terminal-Specific}を参照のこと。"

#. type: defvar
#: original_texis/keymaps.texi:1606
#, no-wrap
msgid "local-function-key-map"
msgstr "local-function-key-map"

#. type: defvar
#: original_texis/keymaps.texi:1611
msgid "This variable holds a keymap similar to @code{input-decode-map} except that it describes key sequences which should be translated to alternative interpretations that are usually preferred.  It applies after @code{input-decode-map} and before @code{key-translation-map}."
msgstr "この変数は@code{input-decode-map}と同じようにキーマップを保持するが、通常は優先される解釈選択肢(alternative interpretation)に変換されるべきキーシーケンスを記述するキーマップを保持する。このキーマップは@code{input-decode-map}の後、@code{key-translation-map}の前に適用される。"

#. type: defvar
#: original_texis/keymaps.texi:1616
msgid "Entries in @code{local-function-key-map} are ignored if they conflict with bindings made in the minor mode, local, or global keymaps.  I.e., the remapping only applies if the original key sequence would otherwise not have any binding."
msgstr "@code{local-function-key-map}内のエントリーはマイナーモード、ローカルキーマップ、グローバルキーマップによるバインディングと衝突する場合には無視される。つまり元のキーシーケンスが他にバインディングをもたない場合だけリマッピングが適用される。"

#. type: defvar
#: original_texis/keymaps.texi:1619
msgid "@code{local-function-key-map} inherits from @code{function-key-map}, but the latter should not be used directly."
msgstr "@code{local-function-key-map}は@code{function-key-map}を継承するが@code{function-key-map}を直接使用しないこと。"

#. type: defvar
#: original_texis/keymaps.texi:1621
#, no-wrap
msgid "key-translation-map"
msgstr "key-translation-map"

#. type: defvar
#: original_texis/keymaps.texi:1627
msgid "This variable is another keymap used just like @code{input-decode-map} to translate input events into other events.  It differs from @code{input-decode-map} in that it goes to work after @code{local-function-key-map} is finished rather than before; it receives the results of translation by @code{local-function-key-map}."
msgstr "この変数は入力イベントを他のイベントに変換するために、@code{input-decode-map}と同じように使用される別のキーマップを保持する。@code{input-decode-map}との違いは、@code{local-function-key-map}の前ではなく後に機能する点である。このキーマップは@code{local-function-key-map}による変換結果を受け取る。"

#. type: defvar
#: original_texis/keymaps.texi:1636
msgid "Just like @code{input-decode-map}, but unlike @code{local-function-key-map}, this keymap is applied regardless of whether the input key-sequence has a normal binding.  Note however that actual key bindings can have an effect on @code{key-translation-map}, even though they are overridden by it.  Indeed, actual key bindings override @code{local-function-key-map} and thus may alter the key sequence that @code{key-translation-map} receives.  Clearly, it is better to avoid this type of situation."
msgstr "@code{input-decode-map}と同様だが@code{local-function-key-map}とは異なり、このキーマップは入力キーシーケンスが通常のバインディングをもつかどうかかに関わらず適用される。しかしこのキーマップによりキーバインディングがオーバーライドされても、@code{key-translation-map}では実際のキーバインディングが効果をもち得ることに注意。確かに実際のキーバインディングは@code{local-function-key-map}をオーバーライドし、したがって@code{key-translation-map}が受け取るキーシーケンスは変更されるだろう。明確にするためにはこのような類の状況は避けたほうがよい。"

#. type: defvar
#: original_texis/keymaps.texi:1640
msgid "The intent of @code{key-translation-map} is for users to map one character set to another, including ordinary characters normally bound to @code{self-insert-command}."
msgstr "@code{key-translation-map}は通常は@code{self-insert-command}にバインディングされるような通常文字を含めて、ユーザーがある文字を他の文字にマップすることを意図している。"

#. type: cindex
#: original_texis/keymaps.texi:1642
#, no-wrap
msgid "key translation function"
msgstr "key translation function"

#. type: Plain text
#: original_texis/keymaps.texi:1648
msgid "You can use @code{input-decode-map}, @code{local-function-key-map}, and @code{key-translation-map} for more than simple aliases, by using a function, instead of a key sequence, as the translation of a key.  Then this function is called to compute the translation of that key."
msgstr "キーシーケンスのかわりにキーの変換として関数を使用することにより、シンプルなエイリアスより多くのことに@code{input-decode-map}、@code{local-function-key-map}、@code{key-translation-map}を使用できます。その場合にはこの関数はそのキーの変換を計算するために呼び出されます。"

#. type: Plain text
#: original_texis/keymaps.texi:1653
msgid "The key translation function receives one argument, which is the prompt that was specified in @code{read-key-sequence}---or @code{nil} if the key sequence is being read by the editor command loop.  In most cases you can ignore the prompt value."
msgstr "キー変換関数は引数を1つ受け取ります。この引数は@code{read-key-sequence}内で指定されるプロンプトです。キーシーケンスがエディターコマンドループに読み取られる場合は@code{nil}です。ほとんどの場合にはプロンプト値は無視できます。"

#. type: Plain text
#: original_texis/keymaps.texi:1657
msgid "If the function reads input itself, it can have the effect of altering the event that follows.  For example, here's how to define @kbd{C-c h} to turn the character that follows into a Hyper character:"
msgstr "関数が自身で入力を読み取る場合、その関数は後続のイベントを変更する効果をもつことができます。たとえば以下は@kbd{C-c h}をハイパー文字に後続する文字とするために定義する方法の例です:"

#. type: group
#: original_texis/keymaps.texi:1667
#, no-wrap
msgid ""
"(defun hyperify (prompt)\n"
"  (let ((e (read-event)))\n"
"    (vector (if (numberp e)\n"
"                (logior (lsh 1 24) e)\n"
"              (if (memq 'hyper (event-modifiers e))\n"
"                  e\n"
"                (add-event-modifier \"H-\" e))))))\n"
"\n"
msgstr ""
"(defun hyperify (prompt)\n"
"  (let ((e (read-event)))\n"
"    (vector (if (numberp e)\n"
"                (logior (lsh 1 24) e)\n"
"              (if (memq 'hyper (event-modifiers e))\n"
"                  e\n"
"                (add-event-modifier \"H-\" e))))))\n"
"\n"

#. type: group
#: original_texis/keymaps.texi:1675
#, no-wrap
msgid ""
"(defun add-event-modifier (string e)\n"
"  (let ((symbol (if (symbolp e) e (car e))))\n"
"    (setq symbol (intern (concat string\n"
"                                 (symbol-name symbol))))\n"
"    (if (symbolp e)\n"
"        symbol\n"
"      (cons symbol (cdr e)))))\n"
"\n"
msgstr ""
"(defun add-event-modifier (string e)\n"
"  (let ((symbol (if (symbolp e) e (car e))))\n"
"    (setq symbol (intern (concat string\n"
"                                 (symbol-name symbol))))\n"
"    (if (symbolp e)\n"
"        symbol\n"
"      (cons symbol (cdr e)))))\n"
"\n"

#. type: group
#: original_texis/keymaps.texi:1677
#, no-wrap
msgid "(define-key local-function-key-map \"\\C-ch\" 'hyperify)\n"
msgstr "(define-key local-function-key-map \"\\C-ch\" 'hyperify)\n"

#. type: subsection
#: original_texis/keymaps.texi:1680
#, no-wrap
msgid "Interaction with normal keymaps"
msgstr "Interaction with normal keymaps"

#. type: Plain text
#: original_texis/keymaps.texi:1685
msgid "The end of a key sequence is detected when that key sequence either is bound to a command, or when Emacs determines that no additional event can lead to a sequence that is bound to a command."
msgstr "そのキーシーケンスがコマンドにバインドされたとき、またはさらにイベントを追加してもコマンドにバインドされるシーケンスにすることができないとEmacsが判断したときにキーシーケンスの終わりが検出されます。"

#. type: Plain text
#: original_texis/keymaps.texi:1696
msgid "This means that, while @code{input-decode-map} and @code{key-translation-map} apply regardless of whether the original key sequence would have a binding, the presence of such a binding can still prevent translation from taking place.  For example, let us return to our VT100 example above and add a binding for @kbd{C-c @key{ESC}} to the global map; now when the user hits @kbd{C-c @key{PF1}} Emacs will fail to decode @kbd{C-c @key{ESC} O P} into @kbd{C-c @key{PF1}} because it will stop reading keys right after @kbd{C-x @key{ESC}}, leaving @kbd{O P} for later.  This is in case the user really hit @kbd{C-c @key{ESC}}, in which case Emacs should not sit there waiting for the next key to decide whether the user really pressed @kbd{@key{ESC}} or @kbd{@key{PF1}}."
msgstr "これは元のキーシーケンスがバインディングをもつかどうかに関わらず、@code{input-decode-map}や@code{key-translation-map}を適用するときに、そのようなバインディングが変換の開始を妨げることを意味します。たとえば前述のVT100の例に戻って、グローバルマップに@kbd{C-c @key{ESC}}を追加してみましょう。するとユーザーが@kbd{C-c @key{PF1}}をタイプしたとき、Emacsは@kbd{C-c @key{ESC} O P}を@kbd{C-c @key{PF1}}に変換するのに失敗するでしょう。これはEmacsが@kbd{C-x @key{ESC}}の直後に読み取りを停止して、@kbd{O P}が読み取られずに残るからです。この場合にはユーザーが実際に@kbd{C-c @key{ESC}}をタイプすると、ユーザーが実際に@kbd{@key{ESC}}を押下したのか、あるいは@kbd{@key{PF1}}を押下したのか判断するためにEmacsが待つべきではないのです。"

#. type: Plain text
#: original_texis/keymaps.texi:1701
msgid "For that reason, it is better to avoid binding commands to key sequences where the end of the key sequence is a prefix of a key translation.  The main such problematic suffixes/prefixes are @kbd{@key{ESC}}, @kbd{M-O} (which is really @kbd{@key{ESC} O}) and @kbd{M-[} (which is really @kbd{@key{ESC} [})."
msgstr "この理由によりキーシーケンスの終わりがキー変換のプレフィクスであるようなキーシーケンスをコマンドにバインドするのは、避けたほうがよいでしょう。そのような問題を起こす主なサフィックス、およびプレフィクスは@kbd{@key{ESC}}、@kbd{M-O} (実際は@kbd{@key{ESC} O})、@kbd{M-[} (実際は@kbd{@key{ESC} [})です。"

#. type: section
#: original_texis/keymaps.texi:1703
#, no-wrap
msgid "Commands for Binding Keys"
msgstr "Commands for Binding Keys"

#. type: Plain text
#: original_texis/keymaps.texi:1707
msgid "This section describes some convenient interactive interfaces for changing key bindings.  They work by calling @code{define-key}."
msgstr "このセクションではキーバインディングを変更するための便利な対話的インターフェイスを説明します。これらは@code{define-key}を呼び出すことにより機能します。"

#. type: Plain text
#: original_texis/keymaps.texi:1710
msgid "People often use @code{global-set-key} in their init files (@pxref{Init File}) for simple customization.  For example,"
msgstr "ユーザーはinitファイルにたいしてシンプルなカスタマイズを行うとき、しばしば@code{global-set-key}を使用します。たとえば、"

#. type: smallexample
#: original_texis/keymaps.texi:1713
#, no-wrap
msgid "(global-set-key (kbd \"C-x C-\\\\\") 'next-line)\n"
msgstr "(global-set-key (kbd \"C-x C-\\\\\") 'next-line)\n"

#. type: Plain text
#: original_texis/keymaps.texi:1717 original_texis/keymaps.texi:1724
#: original_texis/keymaps.texi:1752
msgid "or"
msgstr "または"

#. type: smallexample
#: original_texis/keymaps.texi:1720
#, no-wrap
msgid "(global-set-key [?\\C-x ?\\C-\\\\] 'next-line)\n"
msgstr "(global-set-key [?\\C-x ?\\C-\\\\] 'next-line)\n"

#. type: smallexample
#: original_texis/keymaps.texi:1727
#, no-wrap
msgid "(global-set-key [(control ?x) (control ?\\\\)] 'next-line)\n"
msgstr "(global-set-key [(control ?x) (control ?\\\\)] 'next-line)\n"

#. type: Plain text
#: original_texis/keymaps.texi:1731
msgid "redefines @kbd{C-x C-\\} to move down a line."
msgstr "は、次の行に移動するように@kbd{C-x C-\\}を再定義します。"

#. type: smallexample
#: original_texis/keymaps.texi:1734
#, no-wrap
msgid "(global-set-key [M-mouse-1] 'mouse-set-point)\n"
msgstr "(global-set-key [M-mouse-1] 'mouse-set-point)\n"

#. type: Plain text
#: original_texis/keymaps.texi:1739
msgid "redefines the first (leftmost) mouse button, entered with the Meta key, to set point where you click."
msgstr "は、メタキーを押してマウスの第一ボタン(左ボタン)をクリックすると、クリックした箇所にポイントをセットするように再定義します。"

#. type: cindex
#: original_texis/keymaps.texi:1740
#, no-wrap
msgid "non-@acronym{ASCII} text in keybindings"
msgstr "non-@acronym{ASCII} text in keybindings"

#. type: Plain text
#: original_texis/keymaps.texi:1745
msgid "Be careful when using non-@acronym{ASCII} text characters in Lisp specifications of keys to bind.  If these are read as multibyte text, as they usually will be in a Lisp file (@pxref{Loading Non-ASCII}), you must type the keys as multibyte too.  For instance, if you use this:"
msgstr "バインドするキーのLisp指定に非@acronym{ASCII}文字のテキストを使用するときには注意してください。マルチバイトとして読み取られたテキストがあるなら、Lispファイル内でマルチバイトテキストが読み取られるときのように(@ref{Loading Non-ASCII}を参照)、マルチバイトとしてキーをタイプしなければなりません。たとえば、"

#. type: smallexample
#: original_texis/keymaps.texi:1748
#, no-wrap
msgid "(global-set-key \"ö\" 'my-function) ; bind o-umlaut\n"
msgstr "(global-set-key \"ö\" 'my-function) ; bind o-umlaut\n"

#. type: smallexample
#: original_texis/keymaps.texi:1755
#, no-wrap
msgid "(global-set-key ?ö 'my-function) ; bind o-umlaut\n"
msgstr "(global-set-key ?ö 'my-function) ; bind o-umlaut\n"

#. type: Plain text
#: original_texis/keymaps.texi:1764
msgid "and your language environment is multibyte Latin-1, these commands actually bind the multibyte character with code 246, not the byte code 246 (@kbd{M-v}) sent by a Latin-1 terminal.  In order to use this binding, you need to teach Emacs how to decode the keyboard by using an appropriate input method (@pxref{Input Methods, , Input Methods, emacs, The GNU Emacs Manual})."
msgstr "をLatin-1のマルチバイト環境で使用すると、これらのコマンドはLatin-1端末から送信されたバイトコード246(@kbd{M-v})ではなく、コード246のマルチバイト文字に実際にはバインドされます。このバインディングを使用するためには適切な入力メソッド(@ref{Input Methods, , Input Methods, emacs, The GNU Emacs Manual}を参照)を使用して、キーボードをデコードする方法をEmacsに教える必要があります。"

#. type: deffn
#: original_texis/keymaps.texi:1765
#, no-wrap
msgid "Command global-set-key key binding"
msgstr "Command global-set-key key binding"

#. type: deffn
#: original_texis/keymaps.texi:1768
msgid "This function sets the binding of @var{key} in the current global map to @var{binding}."
msgstr "この関数はカレントグローバルマップ内で@var{key}のバインディングを@var{binding}にセットする。"

#. type: group
#: original_texis/keymaps.texi:1774
#, no-wrap
msgid ""
"(global-set-key @var{key} @var{binding})\n"
"@equiv{}\n"
"(define-key (current-global-map) @var{key} @var{binding})\n"
msgstr ""
"(global-set-key @var{key} @var{binding})\n"
"@equiv{}\n"
"(define-key (current-global-map) @var{key} @var{binding})\n"

#. type: deffn
#: original_texis/keymaps.texi:1778
#, no-wrap
msgid "Command global-unset-key key"
msgstr "Command global-unset-key key"

#. type: cindex
#: original_texis/keymaps.texi:1779
#, no-wrap
msgid "unbinding keys"
msgstr "unbinding keys"

#. type: deffn
#: original_texis/keymaps.texi:1782
msgid "This function removes the binding of @var{key} from the current global map."
msgstr "この関数はカレントグローバルマップから@var{key}のバインディングを削除する。"

#. type: deffn
#: original_texis/keymaps.texi:1786
msgid "One use of this function is in preparation for defining a longer key that uses @var{key} as a prefix---which would not be allowed if @var{key} has a non-prefix binding.  For example:"
msgstr "プレフィクスとして@var{key}を使用する長いキーの定義の準備に使用するのもこの関数の1つの用途である。@var{key}が非プレフィクスのようなバインディングをもつならこの使い方は許容されないだろう。たとえば、"

#. type: group
#: original_texis/keymaps.texi:1791
#, no-wrap
msgid ""
"(global-unset-key \"\\C-l\")\n"
"    @result{} nil\n"
msgstr ""
"(global-unset-key \"\\C-l\")\n"
"    @result{} nil\n"

#. type: group
#: original_texis/keymaps.texi:1795
#, no-wrap
msgid ""
"(global-set-key \"\\C-l\\C-l\" 'redraw-display)\n"
"    @result{} nil\n"
msgstr ""
"(global-set-key \"\\C-l\\C-l\" 'redraw-display)\n"
"    @result{} nil\n"

#. type: deffn
#: original_texis/keymaps.texi:1799
msgid "This function is equivalent to using @code{define-key} as follows:"
msgstr "この関数は以下のように@code{define-key}を使用するのと等しい:"

#. type: group
#: original_texis/keymaps.texi:1805
#, no-wrap
msgid ""
"(global-unset-key @var{key})\n"
"@equiv{}\n"
"(define-key (current-global-map) @var{key} nil)\n"
msgstr ""
"(global-unset-key @var{key})\n"
"@equiv{}\n"
"(define-key (current-global-map) @var{key} nil)\n"

#. type: deffn
#: original_texis/keymaps.texi:1809
#, no-wrap
msgid "Command local-set-key key binding"
msgstr "Command local-set-key key binding"

#. type: deffn
#: original_texis/keymaps.texi:1812
msgid "This function sets the binding of @var{key} in the current local keymap to @var{binding}."
msgstr "この関数はカレントローカルキーマップ内の@var{key}のバインディングを@var{binding}にセットする。"

#. type: group
#: original_texis/keymaps.texi:1818
#, no-wrap
msgid ""
"(local-set-key @var{key} @var{binding})\n"
"@equiv{}\n"
"(define-key (current-local-map) @var{key} @var{binding})\n"
msgstr ""
"(local-set-key @var{key} @var{binding})\n"
"@equiv{}\n"
"(define-key (current-local-map) @var{key} @var{binding})\n"

#. type: deffn
#: original_texis/keymaps.texi:1822
#, no-wrap
msgid "Command local-unset-key key"
msgstr "Command local-unset-key key"

#. type: deffn
#: original_texis/keymaps.texi:1825
msgid "This function removes the binding of @var{key} from the current local map."
msgstr "この関数はカレントローカルキーマップから@var{key}のバインディングを削除する。"

#. type: group
#: original_texis/keymaps.texi:1831
#, no-wrap
msgid ""
"(local-unset-key @var{key})\n"
"@equiv{}\n"
"(define-key (current-local-map) @var{key} nil)\n"
msgstr ""
"(local-unset-key @var{key})\n"
"@equiv{}\n"
"(define-key (current-local-map) @var{key} nil)\n"

#. type: cindex
#: original_texis/keymaps.texi:1837
#, no-wrap
msgid "scanning keymaps"
msgstr "scanning keymaps"

#. type: cindex
#: original_texis/keymaps.texi:1838
#, no-wrap
msgid "keymaps, scanning"
msgstr "keymaps, scanning"

#. type: Plain text
#: original_texis/keymaps.texi:1842
msgid "This section describes functions used to scan all the current keymaps for the sake of printing help information."
msgstr "このセクションではすべてのカレントキーマップをスキャンして、ヘルプ情報をプリントするために使用される関数を説明します。"

#. type: defun
#: original_texis/keymaps.texi:1843
#, no-wrap
msgid "accessible-keymaps keymap &optional prefix"
msgstr "accessible-keymaps keymap &optional prefix"

#. type: defun
#: original_texis/keymaps.texi:1849
msgid "This function returns a list of all the keymaps that can be reached (via zero or more prefix keys) from @var{keymap}.  The value is an association list with elements of the form @code{(@var{key} .@: @var{map})}, where @var{key} is a prefix key whose definition in @var{keymap} is @var{map}."
msgstr "この関数は、(0個以上のプレフィクスキーを通じて)@var{keymap}から到達可能なすべてのキーマップのリストをリターンする。リターン値は@code{(@var{key} .@: @var{map})}のような形式の要素をもつ連想配列(alist)である。ここで@var{key}は@var{keymap}内での定義が@var{map}であるようなプレフィクスキーである。"

#. type: defun
#: original_texis/keymaps.texi:1854
msgid "The elements of the alist are ordered so that the @var{key} increases in length.  The first element is always @code{([] .@: @var{keymap})}, because the specified keymap is accessible from itself with a prefix of no events."
msgstr "alistの要素は@var{key}の長さにたいして昇順にソートされている。1つ目の要素は常に@code{([] .@: @var{keymap})}。これは指定されたキーマップがイベントなしのプレフィクスによって、自分自身からアクセス可能だからである。"

#. type: defun
#: original_texis/keymaps.texi:1860
msgid "If @var{prefix} is given, it should be a prefix key sequence; then @code{accessible-keymaps} includes only the submaps whose prefixes start with @var{prefix}.  These elements look just as they do in the value of @code{(accessible-keymaps)}; the only difference is that some elements are omitted."
msgstr "@var{prefix}が与えられたら、それはプレフィクスキーシーケンスである。その場合には@var{prefix}で始まるプレフィクスキーをもつサブマップだけが@code{accessible-keymaps}に含まれる。これらの要素の意味は@code{(accessible-keymaps)}の値の場合と同様であり、いくつかの要素が省略されている点だけが異なる。"

#. type: defun
#: original_texis/keymaps.texi:1865
msgid "In the example below, the returned alist indicates that the key @key{ESC}, which is displayed as @samp{^[}, is a prefix key whose definition is the sparse keymap @code{(keymap (83 .@: center-paragraph)  (115 .@: foo))}."
msgstr "以下の例ではリターンされるalistにより@samp{^[}と表示されるキー@key{ESC}がプレフィクスキーであり、その定義がsparseキーマップ@code{(keymap (83 .@: center-paragraph)  (115 .@: foo))}であることが示される。"

#. type: group
#: original_texis/keymaps.texi:1874
#, no-wrap
msgid ""
"(accessible-keymaps (current-local-map))\n"
"@result{}(([] keymap\n"
"      (27 keymap   ; @r{Note this keymap for @key{ESC} is repeated below.}\n"
"          (83 . center-paragraph)\n"
"          (115 . center-line))\n"
"      (9 . tab-to-tab-stop))\n"
msgstr ""
"(accessible-keymaps (current-local-map))\n"
"@result{}(([] keymap\n"
"      (27 keymap   ; @r{以降@key{ESC}にたいするこのキーマップが繰り返されることに注意}\n"
"          (83 . center-paragraph)\n"
"          (115 . center-line))\n"
"      (9 . tab-to-tab-stop))\n"

#. type: group
#: original_texis/keymaps.texi:1880
#, no-wrap
msgid ""
"   (\"^[\" keymap\n"
"    (83 . center-paragraph)\n"
"    (115 . foo)))\n"
msgstr ""
"   (\"^[\" keymap\n"
"    (83 . center-paragraph)\n"
"    (115 . foo)))\n"

#. type: defun
#: original_texis/keymaps.texi:1889
msgid "In the following example, @kbd{C-h} is a prefix key that uses a sparse keymap starting with @code{(keymap (118 . describe-variable)@dots{})}.  Another prefix, @kbd{C-x 4}, uses a keymap which is also the value of the variable @code{ctl-x-4-map}.  The event @code{mode-line} is one of several dummy events used as prefixes for mouse actions in special parts of a window."
msgstr "また以下の例では@kbd{C-h}は@code{(keymap (118 . describe-variable)@dots{})}で始まるsparseキーマップを使用するプレフィクスキーである。他のプレフィクス@kbd{C-x 4}は変数@code{ctl-x-4-map}の値でもあるキーマップを使用する。イベント@code{mode-line}はウィンドウの特別な箇所でのマウスイベントにたいするプレフィクスとして使用される、いくつかのダミーイベントのうちの1つである。"

#. type: group
#: original_texis/keymaps.texi:1895
#, no-wrap
msgid ""
"(accessible-keymaps (current-global-map))\n"
"@result{} (([] keymap [set-mark-command beginning-of-line @dots{}\n"
"                   delete-backward-char])\n"
msgstr ""
"(accessible-keymaps (current-global-map))\n"
"@result{} (([] keymap [set-mark-command beginning-of-line @dots{}\n"
"                   delete-backward-char])\n"

#. type: group
#: original_texis/keymaps.texi:1899
#, no-wrap
msgid ""
"    (\"^H\" keymap (118 . describe-variable) @dots{}\n"
"     (8 . help-for-help))\n"
msgstr ""
"    (\"^H\" keymap (118 . describe-variable) @dots{}\n"
"     (8 . help-for-help))\n"

#. type: group
#: original_texis/keymaps.texi:1903
#, no-wrap
msgid ""
"    (\"^X\" keymap [x-flush-mouse-queue @dots{}\n"
"     backward-kill-sentence])\n"
msgstr ""
"    (\"^X\" keymap [x-flush-mouse-queue @dots{}\n"
"     backward-kill-sentence])\n"

#. type: group
#: original_texis/keymaps.texi:1907
#, no-wrap
msgid ""
"    (\"^[\" keymap [mark-sexp backward-sexp @dots{}\n"
"     backward-kill-word])\n"
msgstr ""
"    (\"^[\" keymap [mark-sexp backward-sexp @dots{}\n"
"     backward-kill-word])\n"

#. type: smallexample
#: original_texis/keymaps.texi:1909
#, no-wrap
msgid "    (\"^X4\" keymap (15 . display-buffer) @dots{})\n"
msgstr "    (\"^X4\" keymap (15 . display-buffer) @dots{})\n"

#. type: group
#: original_texis/keymaps.texi:1912
#, no-wrap
msgid ""
"    ([mode-line] keymap\n"
"     (S-mouse-2 . mouse-split-window-horizontally) @dots{}))\n"
msgstr ""
"    ([mode-line] keymap\n"
"     (S-mouse-2 . mouse-split-window-horizontally) @dots{}))\n"

#. type: defun
#: original_texis/keymaps.texi:1917
msgid "These are not all the keymaps you would see in actuality."
msgstr "これらが実際に目にするであろうキーマップのすべてではない。"

#. type: defun
#: original_texis/keymaps.texi:1919
#, no-wrap
msgid "map-keymap function keymap"
msgstr "map-keymap function keymap"

#. type: defun
#: original_texis/keymaps.texi:1926
msgid "The function @code{map-keymap} calls @var{function} once for each binding in @var{keymap}.  It passes two arguments, the event type and the value of the binding.  If @var{keymap} has a parent, the parent's bindings are included as well.  This works recursively: if the parent has itself a parent, then the grandparent's bindings are also included and so on."
msgstr "関数@code{map-keymap}は@var{keymap}内のバインディングそれぞれにたいして1回@var{function}を呼び出す。呼び出す際の引数はイベント型と、そのバインディングの値の2つ。@var{keymap}に親キーマップがあれば、その親キーマップのバインディングも含まれる。これは再帰的に機能する。つまりその親キーマップ自身が親キーマップをもてば、それのバインディングも含まれる、といった具合である。"

#. type: defun
#: original_texis/keymaps.texi:1929
msgid "This function is the cleanest way to examine all the bindings in a keymap."
msgstr "これはキーマップ内のすべてのバインディングを検証するもっとも明快な方法である。"

#. type: defun
#: original_texis/keymaps.texi:1931
#, no-wrap
msgid "where-is-internal command &optional keymap firstonly noindirect no-remap"
msgstr "where-is-internal command &optional keymap firstonly noindirect no-remap"

#. type: defun
#: original_texis/keymaps.texi:1936
msgid "This function is a subroutine used by the @code{where-is} command (@pxref{Help, , Help, emacs,The GNU Emacs Manual}).  It returns a list of all key sequences (of any length) that are bound to @var{command} in a set of keymaps."
msgstr "この関数は@code{where-is}コマンド(@ref{Help, , Help, emacs,The GNU Emacs Manual}を参照)により使用されるサブルーチンである。これはキーマップのセット内で@var{command}にバインドされる、(任意の長さの)キーシーケンスすべてのリストをリターンする。"

#. type: defun
#: original_texis/keymaps.texi:1939
msgid "The argument @var{command} can be any object; it is compared with all keymap entries using @code{eq}."
msgstr "引数@var{command}には任意のオブジェクトを指定できる。このオブジェクトはすべてのキーマップエントリーにたいして、@code{eq}を使用して比較される。"

#. type: defun
#: original_texis/keymaps.texi:1945
msgid "If @var{keymap} is @code{nil}, then the maps used are the current active keymaps, disregarding @code{overriding-local-map} (that is, pretending its value is @code{nil}).  If @var{keymap} is a keymap, then the maps searched are @var{keymap} and the global keymap.  If @var{keymap} is a list of keymaps, only those keymaps are searched."
msgstr "@var{keymap}が@code{nil}なら、@code{overriding-local-map}の値とは無関係に(@code{overriding-local-map}の値が@code{nil}であると装って)、カレントアクティブキーマップをマップとして使用する。@var{keymap}がキーマップなら@var{keymap}とグローバルキーマップが検索されるマップとなる。@var{keymap}がキーマップのリストなら、それらのキーマップだけが検索される。"

#. type: defun
#: original_texis/keymaps.texi:1950
msgid "Usually it's best to use @code{overriding-local-map} as the expression for @var{keymap}.  Then @code{where-is-internal} searches precisely the keymaps that are active.  To search only the global map, pass the value @code{(keymap)} (an empty keymap) as @var{keymap}."
msgstr "@var{keymap}にたいする式としては、通常は@code{overriding-local-map}を使用するのが最善である。その場合には@code{where-is-internal}は正にアクティブなキーマップを検索する。グローバルマップだけを検索するには@var{keymap}の値に@code{(keymap)}(空のキーマップ)を渡せばよい。"

#. type: defun
#: original_texis/keymaps.texi:1958
msgid "If @var{firstonly} is @code{non-ascii}, then the value is a single vector representing the first key sequence found, rather than a list of all possible key sequences.  If @var{firstonly} is @code{t}, then the value is the first key sequence, except that key sequences consisting entirely of @acronym{ASCII} characters (or meta variants of @acronym{ASCII} characters) are preferred to all other key sequences and that the return value can never be a menu binding."
msgstr "@var{firstonly}が@code{non-ascii}なら、値はすべての可能なキーシーケンスのリストではなく最初に見つかったキーシーケンスを表す単一のベクターとなる。@var{firstonly}が@code{t}なら、値は最初のキーシーケンスだが全体が@acronym{ASCII}文字(またはメタ修飾された@acronym{ASCII}文字)で構成されるキーシーケンスが他のすべてのキーシーケンスに優先されて、リターン値がメニューバインディングになることは決してない。"

#. type: defun
#: original_texis/keymaps.texi:1962
msgid "If @var{noindirect} is non-@code{nil}, @code{where-is-internal} doesn't look inside menu-items to find their commands.  This makes it possible to search for a menu-item itself."
msgstr "@var{noindirect}が非@code{nil}なら@code{where-is-internal}は自身のコマンドを探すためにメニューアイテムの内部を調べない。これによりメニューアイテム自体の検索が可能になる。"

#. type: defun
#: original_texis/keymaps.texi:1966
msgid "The fifth argument, @var{no-remap}, determines how this function treats command remappings (@pxref{Remapping Commands}).  There are two cases of interest:"
msgstr "5つ目の引数@var{no-remap}はこの関数がコマンドリマッピング(@ref{Remapping Commands}を参照)を扱う方法を決定する。興味深いケースが2つある:"

#. type: item
#: original_texis/keymaps.texi:1968
#, no-wrap
msgid "If a command @var{other-command} is remapped to @var{command}:"
msgstr "コマンド@var{other-command}が@var{command}にリマップされる場合:"

#. type: table
#: original_texis/keymaps.texi:1974
msgid "If @var{no-remap} is @code{nil}, find the bindings for @var{other-command} and treat them as though they are also bindings for @var{command}.  If @var{no-remap} is non-@code{nil}, include the vector @code{[remap @var{other-command}]} in the list of possible key sequences, instead of finding those bindings."
msgstr "@var{no-remap}が@code{nil}なら@var{other-command}にたいするバインディングを探して、@var{command}にたいするバインディングであるかのようにそれらを扱う。@var{no-remap}が非@code{nil}ならそれらのバインディングを探すかわりに、利用可能なキーシーケンスリストにベクター@code{[remap @var{other-command}]}を含める。"

#. type: item
#: original_texis/keymaps.texi:1975
#, no-wrap
msgid "If @var{command} is remapped to @var{other-command}:"
msgstr "@var{command}が@var{other-command}にリマップされる場合:"

#. type: table
#: original_texis/keymaps.texi:1980
msgid "If @var{no-remap} is @code{nil}, return the bindings for @var{other-command} rather than @var{command}.  If @var{no-remap} is non-@code{nil}, return the bindings for @var{command}, ignoring the fact that it is remapped."
msgstr "@var{no-remap}が@code{nil}なら、@var{command}ではなく@var{other-command}にたいするバインディングをリターンする。@var{no-remap}が非@code{nil}なら、リマップされていることを無視して@var{command}にたいするバインディングをリターンする。"

#. type: deffn
#: original_texis/keymaps.texi:1983
#, no-wrap
msgid "Command describe-bindings &optional prefix buffer-or-name"
msgstr "Command describe-bindings &optional prefix buffer-or-name"

#. type: deffn
#: original_texis/keymaps.texi:1987
msgid "This function creates a listing of all current key bindings, and displays it in a buffer named @file{*Help*}.  The text is grouped by modes---minor modes first, then the major mode, then global bindings."
msgstr "この関数はすべてのカレントキーバインディングのリストを作成して、@file{*Help*}という名前のバッファーにそれを表示する。テキストはモードごとにグループ化されて順番はマイナーモード、メジャーモード、グローバルバインディングの順である。"

#. type: deffn
#: original_texis/keymaps.texi:1990
msgid "If @var{prefix} is non-@code{nil}, it should be a prefix key; then the listing includes only keys that start with @var{prefix}."
msgstr "@var{prefix}が非@code{nil}なら、それはプレフィクスキーである。その場合にはリストに含まれるのは@var{prefix}で始まるキーだけになる。"

#. type: deffn
#: original_texis/keymaps.texi:2000
msgid "When several characters with consecutive @acronym{ASCII} codes have the same definition, they are shown together, as @samp{@var{firstchar}..@var{lastchar}}.  In this instance, you need to know the @acronym{ASCII} codes to understand which characters this means.  For example, in the default global map, the characters @samp{@key{SPC} ..@: ~} are described by a single line.  @key{SPC} is @acronym{ASCII} 32, @kbd{~} is @acronym{ASCII} 126, and the characters between them include all the normal printing characters, (e.g., letters, digits, punctuation, etc.@:); all these characters are bound to @code{self-insert-command}."
msgstr "複数の連続する@acronym{ASCII}コードが同じ定義をもつとき、それらは@samp{@var{firstchar}..@var{lastchar}}のようにまとめて表示される。この場合にはそれがどの文字に該当するかを理解するには、その@acronym{ASCII}コードを知っている必要がある。たとえばデフォルトグローバルマップでは文字@samp{@key{SPC} ..@: ~}は1行で記述される。@key{SPC}は@acronym{ASCII}の32，@kbd{~}は@acronym{ASCII}の126で、その間のすべての文字には通常のプリント文字(アルファベット文字や数字、区切り文字等)が含まれる。これらの文字はすべて@code{self-insert-command}にバインドされる。"

#. type: deffn
#: original_texis/keymaps.texi:2004
msgid "If @var{buffer-or-name} is non-@code{nil}, it should be a buffer or a buffer name.  Then @code{describe-bindings} lists that buffer's bindings, instead of the current buffer's."
msgstr "@var{buffer-or-name}が非@code{nil}のならそれはバッファーかバッファー名である。その場合は@code{describe-bindings}はカレントバッファーのかわりに、そのバッファーのバインディングをリストする。"

#. type: cindex
#: original_texis/keymaps.texi:2008
#, no-wrap
msgid "menu keymaps"
msgstr "menu keymaps"

#. type: Plain text
#: original_texis/keymaps.texi:2015
msgid "A keymap can operate as a menu as well as defining bindings for keyboard keys and mouse buttons.  Menus are usually actuated with the mouse, but they can function with the keyboard also.  If a menu keymap is active for the next input event, that activates the keyboard menu feature."
msgstr "キーマップはキーボードキーやマウスボタンにたいするバインディング定義と同様に、メニューとして操作することができます。メニューは通常はマウスにより操作されますが、キーボードでも機能させことができます。次の入力イベントにたいしてメニューキーマップがアクティブならキーボードメニュー機能がアクティブになります。"

#. type: subsection
#: original_texis/keymaps.texi:2025 original_texis/keymaps.texi:2027
#: original_texis/keymaps.texi:2028
#, no-wrap
msgid "Defining Menus"
msgstr "Defining Menus"

#. type: menuentry
#: original_texis/keymaps.texi:2025
msgid "How to make a keymap that defines a menu."
msgstr "メニューを定義するキーマップを作成する方法。"

#. type: node
#: original_texis/keymaps.texi:2025 original_texis/keymaps.texi:2362
#, no-wrap
msgid "Mouse Menus"
msgstr "Mouse Menus"

#. type: menuentry
#: original_texis/keymaps.texi:2025
msgid "How users actuate the menu with the mouse."
msgstr "ユーザーがマウスでメニューを操作する方法。"

#. type: node
#: original_texis/keymaps.texi:2025 original_texis/keymaps.texi:2400
#, no-wrap
msgid "Keyboard Menus"
msgstr "Keyboard Menus"

#. type: menuentry
#: original_texis/keymaps.texi:2025
msgid "How users actuate the menu with the keyboard."
msgstr "ユーザーがキーボードでメニューを操作する方法。"

#. type: subsection
#: original_texis/keymaps.texi:2025 original_texis/keymaps.texi:2427
#: original_texis/keymaps.texi:2428
#, no-wrap
msgid "Menu Example"
msgstr "Menu Example"

#. type: menuentry
#: original_texis/keymaps.texi:2025
msgid "Making a simple menu."
msgstr "シンプルなメニューの作成。"

#. type: node
#: original_texis/keymaps.texi:2025 original_texis/keymaps.texi:2499
#, no-wrap
msgid "Menu Bar"
msgstr "Menu Bar"

#. type: menuentry
#: original_texis/keymaps.texi:2025
msgid "How to customize the menu bar."
msgstr "メニューバーのカスタマイズ方法。"

#. type: node
#: original_texis/keymaps.texi:2025 original_texis/keymaps.texi:2587
#, no-wrap
msgid "Tool Bar"
msgstr "Tool Bar"

#. type: menuentry
#: original_texis/keymaps.texi:2025
msgid "A tool bar is a row of images."
msgstr "イメージ行のツールバー。"

#. type: subsection
#: original_texis/keymaps.texi:2025 original_texis/keymaps.texi:2806
#: original_texis/keymaps.texi:2807
#, no-wrap
msgid "Modifying Menus"
msgstr "Modifying Menus"

#. type: menuentry
#: original_texis/keymaps.texi:2025
msgid "How to add new items to a menu."
msgstr "メニューへ新たなアイテムを追加する方法。"

#. type: subsection
#: original_texis/keymaps.texi:2025 original_texis/keymaps.texi:2847
#: original_texis/keymaps.texi:2848
#, no-wrap
msgid "Easy Menu"
msgstr "Easy Menu"

#. type: menuentry
#: original_texis/keymaps.texi:2025
msgid "A convenience macro for making menus."
msgstr "メニュー作成のための便利なマクロ。"

#. type: cindex
#: original_texis/keymaps.texi:2029
#, no-wrap
msgid "defining menus"
msgstr "defining menus"

#. type: cindex
#: original_texis/keymaps.texi:2030
#, no-wrap
msgid "menu prompt string"
msgstr "menu prompt string"

#. type: cindex
#: original_texis/keymaps.texi:2031
#, no-wrap
msgid "prompt string (of menu)"
msgstr "prompt string (of menu)"

#. type: cindex
#: original_texis/keymaps.texi:2032
#, no-wrap
msgid "menu item"
msgstr "menu item"

#. type: Plain text
#: original_texis/keymaps.texi:2042
msgid "A keymap acts as a menu if it has an @dfn{overall prompt string}, which is a string that appears as an element of the keymap.  (@xref{Format of Keymaps}.)  The string should describe the purpose of the menu's commands.  Emacs displays the overall prompt string as the menu title in some cases, depending on the toolkit (if any) used for displaying menus.@footnote{It is required for menus which do not use a toolkit, e.g., on a text terminal.} Keyboard menus also display the overall prompt string."
msgstr "キーマップが@dfn{overallプロンプト文字列(overall prompt string)}をもつ場合には、そのキーマップはメニューとして動作します。overallプロンプト文字列はキーマップの要素として表される文字列です(@ref{Format of Keymaps}を参照)。この文字列にはメニューコマンドの目的を記述します。(もしあれば)Emacsはメニュー表示に使用されるツールキットに応じて、メニュータイトルにoverallメニュー文字列を表示します@footnote{これはテキスト端末のようなツールキットを使用しないメニューにたいして要求されます。}。キーボードメニューもoverallプロンプト文字列を表示します。"

#. type: Plain text
#: original_texis/keymaps.texi:2049
msgid "The easiest way to construct a keymap with a prompt string is to specify the string as an argument when you call @code{make-keymap}, @code{make-sparse-keymap} (@pxref{Creating Keymaps}), or @code{define-prefix-command} (@pxref{Definition of define-prefix-command}).  If you do not want the keymap to operate as a menu, don't specify a prompt string for it."
msgstr "プロンプト文字列をもつキーマップを構築するもっとも簡単な方法は@code{make-keymap}、@code{make-sparse-keymap} (@ref{Creating Keymaps}を参照)、@code{define-prefix-command} (@ref{Definition of define-prefix-command}を参照)を呼び出すときに引数として文字列を指定する方法です。キーマップをメニューとして操作したくなければ、これらの関数にたいしてプロンプト文字列を指定しないでください。"

#. type: defun
#: original_texis/keymaps.texi:2050
#, no-wrap
msgid "keymap-prompt keymap"
msgstr "keymap-prompt keymap"

#. type: defun
#: original_texis/keymaps.texi:2053
msgid "This function returns the overall prompt string of @var{keymap}, or @code{nil} if it has none."
msgstr "この関数は@var{keymap}のoverallプロンプト文字列、もしなければ@code{nil}をリターンする。"

#. type: Plain text
#: original_texis/keymaps.texi:2061
msgid "The menu's items are the bindings in the keymap.  Each binding associates an event type to a definition, but the event types have no significance for the menu appearance.  (Usually we use pseudo-events, symbols that the keyboard cannot generate, as the event types for menu item bindings.)  The menu is generated entirely from the bindings that correspond in the keymap to these events."
msgstr "メニューのアイテムは、そのキーマップ内のバインディングです。各バインディングはイベント型と定義を関連付けますが、イベント型はメニューの外見には何の意味ももっていません(通常はイベント型としてキーボードが生成できない擬似イベントのシンボルをメニューアイテムのバインディングに使用する)。メニュー全体はこれらのイベントにたいするキーマップ内のバインディングから生成されます。"

#. type: Plain text
#: original_texis/keymaps.texi:2068
msgid "The order of items in the menu is the same as the order of bindings in the keymap.  Since @code{define-key} puts new bindings at the front, you should define the menu items starting at the bottom of the menu and moving to the top, if you care about the order.  When you add an item to an existing menu, you can specify its position in the menu using @code{define-key-after} (@pxref{Modifying Menus})."
msgstr "メニュー内のアイテムの順序はキーマップ内のバインディングの順序と同じです。@code{define-key}は新たなバインディングを先頭に配置するので、メニューアイテムの順序が重要ならメニューの最後から先頭へメニューアイテムを定義する必要があります。既存のメニューにアイテムを追加するときには、@code{define-key-after}を使用してメニュー内の位置を指定できます(@ref{Modifying Menus}を参照)。"

#. type: subsubsection
#: original_texis/keymaps.texi:2074 original_texis/keymaps.texi:2076
#: original_texis/keymaps.texi:2077
#, no-wrap
msgid "Simple Menu Items"
msgstr "Simple Menu Items"

#. type: menuentry
#: original_texis/keymaps.texi:2074
msgid "A simple kind of menu key binding."
msgstr "単純なメニューのキーバインディング。"

#. type: subsubsection
#: original_texis/keymaps.texi:2074 original_texis/keymaps.texi:2126
#: original_texis/keymaps.texi:2127
#, no-wrap
msgid "Extended Menu Items"
msgstr "Extended Menu Items"

#. type: menuentry
#: original_texis/keymaps.texi:2074
msgid "More complex menu item definitions."
msgstr "複雑なメニューアイテムの定義。"

#. type: subsubsection
#: original_texis/keymaps.texi:2074 original_texis/keymaps.texi:2245
#: original_texis/keymaps.texi:2246
#, no-wrap
msgid "Menu Separators"
msgstr "Menu Separators"

#. type: menuentry
#: original_texis/keymaps.texi:2074
msgid "Drawing a horizontal line through a menu."
msgstr "メニューに水平ラインを描画する。"

#. type: subsubsection
#: original_texis/keymaps.texi:2074 original_texis/keymaps.texi:2330
#: original_texis/keymaps.texi:2331
#, no-wrap
msgid "Alias Menu Items"
msgstr "Alias Menu Items"

#. type: menuentry
#: original_texis/keymaps.texi:2074
msgid "Using command aliases in menu items."
msgstr "メニューアイテムにコマンドエイリアスを使用する。"

#. type: Plain text
#: original_texis/keymaps.texi:2081
msgid "The simpler (and original) way to define a menu item is to bind some event type (it doesn't matter what event type) to a binding like this:"
msgstr "メニューアイテムを定義するシンプル(かつ初歩的)な方法は、何らかのイベント型(何のイベント型かは問題ではない)を以下のようにバインドすることです:"

#. type: example
#: original_texis/keymaps.texi:2084
#, no-wrap
msgid "(@var{item-string} . @var{real-binding})\n"
msgstr "(@var{item-string} . @var{real-binding})\n"

#. type: Plain text
#: original_texis/keymaps.texi:2093
msgid "The @sc{car}, @var{item-string}, is the string to be displayed in the menu.  It should be short---preferably one to three words.  It should describe the action of the command it corresponds to.  Note that not all graphical toolkits can display non-@acronym{ASCII} text in menus (it will work for keyboard menus and will work to a large extent with the GTK+ toolkit)."
msgstr "@sc{car}の@var{item-string}はメニュー内で表示される文字列です。これは短いほうが望ましく、1個から3個の単語が望ましいでしょう。この文字列は対応するコマンドの動作を記述します。すべてのグラフィカルツールキットが非@acronym{ASCII}テキストを表示できる訳ではないことに注意してください(キーボードメニューとGTK+ツールキットの大部分では機能するだろう)。"

#. type: Plain text
#: original_texis/keymaps.texi:2095
msgid "You can also supply a second string, called the help string, as follows:"
msgstr "以下のようにヘルプ文字列と呼ばれる2つ目の文字列を与えることもできます:"

#. type: example
#: original_texis/keymaps.texi:2098
#, no-wrap
msgid "(@var{item-string} @var{help} . @var{real-binding})\n"
msgstr "(@var{item-string} @var{help} . @var{real-binding})\n"

#. type: Plain text
#: original_texis/keymaps.texi:2104
msgid "@var{help} specifies a help-echo string to display while the mouse is on that item in the same way as @code{help-echo} text properties (@pxref{Help display})."
msgstr "@var{help}はマウスがそのアイテム上にあるときに、@code{help-echo}テキストプロパティ(@ref{Help display}を参照)と同じ方法で表示されるhelp-echo文字列を指定します。"

#. type: Plain text
#: original_texis/keymaps.texi:2109
msgid "As far as @code{define-key} is concerned, @var{item-string} and @var{help-string} are part of the event's binding.  However, @code{lookup-key} returns just @var{real-binding}, and only @var{real-binding} is used for executing the key."
msgstr "@code{define-key}に関する限り、@var{item-string}と@var{help-string}はそのイベントのバインディングの一部です。しかし@code{lookup-key}は単に@var{real-binding}だけをリターンし、そのキーの実行には@var{real-binding}だけが使用されます。"

#. type: Plain text
#: original_texis/keymaps.texi:2112
msgid "If @var{real-binding} is @code{nil}, then @var{item-string} appears in the menu but cannot be selected."
msgstr "@var{real-binding}が@code{nil}なら@var{item-string}はメニューに表示されますが選択できません。"

#. type: Plain text
#: original_texis/keymaps.texi:2120
msgid "If @var{real-binding} is a symbol and has a non-@code{nil} @code{menu-enable} property, that property is an expression that controls whether the menu item is enabled.  Every time the keymap is used to display a menu, Emacs evaluates the expression, and it enables the menu item only if the expression's value is non-@code{nil}.  When a menu item is disabled, it is displayed in a fuzzy fashion, and cannot be selected."
msgstr "@var{real-binding}がシンボルで@code{menu-enable}プロパティが非@code{nil}なら、そのプロパティはメニューアイテムが有効か無効かを制御する式です。メニュー表示にキーマップが使用されるたびにEmacsはその式を評価して、式の値が非@code{nil}の場合のみそのメニューのメニューアイテムを有効にします。メニューアイテム無効なときには、そのアイテムはfuzzy形式で表示されて選択できなくなります。"

#. type: Plain text
#: original_texis/keymaps.texi:2125
msgid "The menu bar does not recalculate which items are enabled every time you look at a menu.  This is because the X toolkit requires the whole tree of menus in advance.  To force recalculation of the menu bar, call @code{force-mode-line-update} (@pxref{Mode Line Format})."
msgstr "メニューバーはメニューを調べる際にどのアイテムが有効かを再計算しません。これはXツールキットが事前にメニュー全体を要求するからです。メニューバーの再計算を強制するには@code{force-mode-line-update}を呼び出してください(@ref{Mode Line Format}を参照)。"

#. type: kindex
#: original_texis/keymaps.texi:2128
#, no-wrap
msgid "menu-item"
msgstr "menu-item"

#. type: cindex
#: original_texis/keymaps.texi:2129
#, no-wrap
msgid "extended menu item"
msgstr "extended menu item"

#. type: Plain text
#: original_texis/keymaps.texi:2135
msgid "An extended-format menu item is a more flexible and also cleaner alternative to the simple format.  You define an event type with a binding that's a list starting with the symbol @code{menu-item}.  For a non-selectable string, the binding looks like this:"
msgstr "メニューアイテムの拡張フォーマットは、単純なフォーマットに比べてより柔軟かつ明快です。拡張フォーマットではシンボル@code{menu-item}で始まるリストでイベント型を定義します。選択できない文字列にたいしては以下のようなバインディングになります:"

#. type: example
#: original_texis/keymaps.texi:2138
#, no-wrap
msgid "(menu-item @var{item-name})\n"
msgstr "(menu-item @var{item-name})\n"

#. type: Plain text
#: original_texis/keymaps.texi:2143
msgid "A string starting with two or more dashes specifies a separator line; see @ref{Menu Separators}."
msgstr "2つ以上のダッシュで始まる文字列はリストのセパレーターを指定します。@ref{Menu Separators}を参照してください。"

#. type: Plain text
#: original_texis/keymaps.texi:2146
msgid "To define a real menu item which can be selected, the extended format binding looks like this:"
msgstr "選択可能な実際のメニューアイテムを定義するには以下のような拡張フォーマットでバインドします:"

#. type: example
#: original_texis/keymaps.texi:2150
#, no-wrap
msgid ""
"(menu-item @var{item-name} @var{real-binding}\n"
"    . @var{item-property-list})\n"
msgstr ""
"(menu-item @var{item-name} @var{real-binding}\n"
"    . @var{item-property-list})\n"

#. type: Plain text
#: original_texis/keymaps.texi:2158
msgid "Here, @var{item-name} is an expression which evaluates to the menu item string.  Thus, the string need not be a constant.  The third element, @var{real-binding}, is the command to execute.  The tail of the list, @var{item-property-list}, has the form of a property list which contains other information."
msgstr "ここで@var{item-name}はメニューアイテム文字列を評価する式です。つまり文字列は定数である必要はありません。3つ目の引数@var{real-binding}は実行するコマンドです。リストの最後の要素@var{item-property-list}は、その他の情報を含んだプロパティリストの形式です。"

#. type: Plain text
#: original_texis/keymaps.texi:2160
msgid "Here is a table of the properties that are supported:"
msgstr "以下はサポートされるプロパティのテーブルです:"

#. type: item
#: original_texis/keymaps.texi:2162
#, no-wrap
msgid ":enable @var{form}"
msgstr ":enable @var{form}"

#. type: table
#: original_texis/keymaps.texi:2166
msgid "The result of evaluating @var{form} determines whether the item is enabled (non-@code{nil} means yes).  If the item is not enabled, you can't really click on it."
msgstr "@var{form}の評価結果はそのアイテムを有効にするかどうかを決定する(非@code{nil}なら有効)。アイテムが無効なら▽まったくクリックできない。"

#. type: item
#: original_texis/keymaps.texi:2167
#, no-wrap
msgid ":visible @var{form}"
msgstr ":visible @var{form}"

#. type: table
#: original_texis/keymaps.texi:2172
msgid "The result of evaluating @var{form} determines whether the item should actually appear in the menu (non-@code{nil} means yes).  If the item does not appear, then the menu is displayed as if this item were not defined at all."
msgstr "@var{form}の評価結果はそのアイテムを実際にメニューに表示するかどうかを決定する(非@code{nil}なら表示)。アイテムが非表示ならそのアイテムが定義されていないかのようにメニューが表示される。"

#. type: item
#: original_texis/keymaps.texi:2173 original_texis/keymaps.texi:2946
#, no-wrap
msgid ":help @var{help}"
msgstr ":help @var{help}"

#. type: table
#: original_texis/keymaps.texi:2179
msgid "The value of this property, @var{help}, specifies a help-echo string to display while the mouse is on that item.  This is displayed in the same way as @code{help-echo} text properties (@pxref{Help display}).  Note that this must be a constant string, unlike the @code{help-echo} property for text and overlays."
msgstr "このプロパティ@var{help}の値はそのアイテム上にマウスがある間に表示するhelp-echo文字列を指定する。この文字列は@code{help-echo}テキストプロパティ(@ref{Help display}を参照)と同じ方法で表示される。これはテキストやoverlayにたいする@code{help-echo}プロパティとは異なり、文字列定数でなければならないことに注意。"

#. type: item
#: original_texis/keymaps.texi:2180
#, no-wrap
msgid ":button (@var{type} . @var{selected})"
msgstr ":button (@var{type} . @var{selected})"

#. type: table
#: original_texis/keymaps.texi:2185
msgid "This property provides a way to define radio buttons and toggle buttons.  The @sc{car}, @var{type}, says which: it should be @code{:toggle} or @code{:radio}.  The @sc{cdr}, @var{selected}, should be a form; the result of evaluating it says whether this button is currently selected."
msgstr "このプロパティはラジオボタンとトグルボタンを定義する手段を提供する。@sc{car}の@var{type}には、@code{:toggle}か@code{:radio}のいずれかを指定する。@sc{cdr}の@var{selected}はフォームで、評価結果によってそのボタンがカレントで選択されているかどうかを指定する。"

#. type: table
#: original_texis/keymaps.texi:2191
msgid "A @dfn{toggle} is a menu item which is labeled as either on or off according to the value of @var{selected}.  The command itself should toggle @var{selected}, setting it to @code{t} if it is @code{nil}, and to @code{nil} if it is @code{t}.  Here is how the menu item to toggle the @code{debug-on-error} flag is defined:"
msgstr "@dfn{トグル(toggle)}は@var{selected}の値に応じてonかoffのいずれかがラベルされるメニューアイテムである。コマンド自身は@var{selected}が@code{nil}なら@code{t}、@code{t}なら@code{nil}に@var{selected}を切り替える(toggleする)こと。以下は@code{debug-on-error}フラグが定義されているときにメニューアイテムをトグルする方法の例:"

#. type: example
#: original_texis/keymaps.texi:2197
#, no-wrap
msgid ""
"(menu-item \"Debug on Error\" toggle-debug-on-error\n"
"           :button (:toggle\n"
"                    . (and (boundp 'debug-on-error)\n"
"                           debug-on-error)))\n"
msgstr ""
"(menu-item \"Debug on Error\" toggle-debug-on-error\n"
"           :button (:toggle\n"
"                    . (and (boundp 'debug-on-error)\n"
"                           debug-on-error)))\n"

#. type: table
#: original_texis/keymaps.texi:2202
msgid "This works because @code{toggle-debug-on-error} is defined as a command which toggles the variable @code{debug-on-error}."
msgstr "これは@code{toggle-debug-on-error}が変数@code{debug-on-error}をトグルするコマンドとして定義されていることによって機能する。"

#. type: table
#: original_texis/keymaps.texi:2209
msgid "@dfn{Radio buttons} are a group of menu items, in which at any time one and only one is selected.  There should be a variable whose value says which one is selected at any time.  The @var{selected} form for each radio button in the group should check whether the variable has the right value for selecting that button.  Clicking on the button should set the variable so that the button you clicked on becomes selected."
msgstr "@dfn{ラジオボタン}とはメニューアイテムのグループであり、常にただ1つのメニューアイテムだけが選択される(selected)。そのためにはどのメニューアイテムが選択されているかを示す変数が存在する必要がある。グループ内の各ラジオボタンにたいする@var{selected}フォームは、そのボタンを選択するためにその変数が正しい値をもつかどうかをチェックする。そしてボタンのクリックにより変数をセットして、クリックされたボタンが選択される。"

#. type: item
#: original_texis/keymaps.texi:2210
#, no-wrap
msgid ":key-sequence @var{key-sequence}"
msgstr ":key-sequence @var{key-sequence}"

#. type: table
#: original_texis/keymaps.texi:2214
msgid "This property specifies which key sequence is likely to be bound to the same command invoked by this menu item.  If you specify the right key sequence, that makes preparing the menu for display run much faster."
msgstr "このプロパティはそのメニューアイテムによって呼び出されるのと同じコマンドにバインドされるかもしれないキーシーケンスを指定する。正しいキーシーケンスを指定すればメニュー表示の準備がより高速になる。"

#. type: table
#: original_texis/keymaps.texi:2218
msgid "If you specify the wrong key sequence, it has no effect; before Emacs displays @var{key-sequence} in the menu, it verifies that @var{key-sequence} is really equivalent to this menu item."
msgstr "間違ったキーシーケンスを指定すると何の効果もない。Emacsはメニュー内の@var{key-sequence}の表示前に、実際にその@var{key-sequence}がそのメニューアイテムと等価なのか検証する。"

#. type: item
#: original_texis/keymaps.texi:2219
#, no-wrap
msgid ":key-sequence nil"
msgstr ":key-sequence nil"

#. type: table
#: original_texis/keymaps.texi:2224
msgid "This property indicates that there is normally no key binding which is equivalent to this menu item.  Using this property saves time in preparing the menu for display, because Emacs does not need to search the keymaps for a keyboard equivalent for this menu item."
msgstr "このプロパティはそのメニューアイテムには等価なキーバインディングが通常は存在しないことを示す。このプロパティを使用することによりEmacsはそのメニューアイテムにたいして等価なキーボード入力をキーマップから検索する必要がなくなるので、メニュー表示の準備時間が短縮される。"

#. type: table
#: original_texis/keymaps.texi:2228
msgid "However, if the user has rebound this item's definition to a key sequence, Emacs ignores the @code{:keys} property and finds the keyboard equivalent anyway."
msgstr "しかしユーザーがそのアイテムの定義をキーシーケンスにリバインドすると、Emacsは@code{:keys}プロパティを無視して結局は等価なキーボード入力を見つけ出す。"

#. type: item
#: original_texis/keymaps.texi:2229
#, no-wrap
msgid ":keys @var{string}"
msgstr ":keys @var{string}"

#. type: table
#: original_texis/keymaps.texi:2233
msgid "This property specifies that @var{string} is the string to display as the keyboard equivalent for this menu item.  You can use the @samp{\\\\[...]} documentation construct in @var{string}."
msgstr "このプロパティはそのメニューにたいする等価なキーボード入力として表示される文字列@var{string}を指定する。@var{string}内ではドキュメント構文@samp{\\\\[...]}を使用できる。"

#. type: item
#: original_texis/keymaps.texi:2234
#, no-wrap
msgid ":filter @var{filter-fn}"
msgstr ":filter @var{filter-fn}"

#. type: table
#: original_texis/keymaps.texi:2239
msgid "This property provides a way to compute the menu item dynamically.  The property value @var{filter-fn} should be a function of one argument; when it is called, its argument will be @var{real-binding}.  The function should return the binding to use instead."
msgstr "このプロパティはメニューアイテムを直接計算する手段を提供する。このプロパティの値@var{filter-fn}は引数が1つの関数で、呼び出し時の引数は@var{real-binding}。この関数はかわりに使用するバインディングをリターンすること。"

#. type: table
#: original_texis/keymaps.texi:2243
msgid "Emacs can call this function at any time that it does redisplay or operates on menu data structures, so you should write it so it can safely be called at any time."
msgstr "Emacs、メニューデータ構造の再表示や操作を行うすべてのタイミングでこの関数を呼び出すかもしれないので、いつ呼び出されても安全なように関数を記述すること。"

#. type: cindex
#: original_texis/keymaps.texi:2247
#, no-wrap
msgid "menu separators"
msgstr "menu separators"

#. type: Plain text
#: original_texis/keymaps.texi:2252
msgid "A menu separator is a kind of menu item that doesn't display any text---instead, it divides the menu into subparts with a horizontal line.  A separator looks like this in the menu keymap:"
msgstr "メニューセパレーターはテキストを表示するかわりに、水平ラインでメニューをサブパーツに分割するメニューアイテムの一種です。メニューキーマップ内でセパレーターは以下のように見えるでしょう:"

#. type: example
#: original_texis/keymaps.texi:2255
#, no-wrap
msgid "(menu-item @var{separator-type})\n"
msgstr "(menu-item @var{separator-type})\n"

#. type: Plain text
#: original_texis/keymaps.texi:2259
msgid "where @var{separator-type} is a string starting with two or more dashes."
msgstr "ここで@var{separator-type}は2つ以上のダッシュで始まる文字列です。"

#. type: Plain text
#: original_texis/keymaps.texi:2263
msgid "In the simplest case, @var{separator-type} consists of only dashes.  That specifies the default kind of separator.  (For compatibility, @code{\"\"} and @code{-} also count as separators.)"
msgstr "もっとも単純なケースではダッシュだけで@var{separator-type}が構成されます。これはデフォルトのセパレーターを指定します(互換性のため@code{\"\"}と@code{-}もセパレーターとみなされる)。"

#. type: Plain text
#: original_texis/keymaps.texi:2266
msgid "Certain other values of @var{separator-type} specify a different style of separator.  Here is a table of them:"
msgstr "@var{separator-type}にたいする他の特定の値は、異なるスタイルのセパレーターを指定します。以下はそれらのテーブルです:"

#. type: item
#: original_texis/keymaps.texi:2268
#, no-wrap
msgid "\"--no-line\""
msgstr "\"--no-line\""

#. type: itemx
#: original_texis/keymaps.texi:2269
#, no-wrap
msgid "\"--space\""
msgstr "\"--space\""

#. type: table
#: original_texis/keymaps.texi:2271
msgid "An extra vertical space, with no actual line."
msgstr "実際のラインではない余分な垂直スペース。"

#. type: item
#: original_texis/keymaps.texi:2272
#, no-wrap
msgid "\"--single-line\""
msgstr "\"--single-line\""

#. type: table
#: original_texis/keymaps.texi:2274
msgid "A single line in the menu's foreground color."
msgstr "メニューのforegroundカラーの一重ライン。"

#. type: item
#: original_texis/keymaps.texi:2275
#, no-wrap
msgid "\"--double-line\""
msgstr "\"--double-line\""

#. type: table
#: original_texis/keymaps.texi:2277
msgid "A double line in the menu's foreground color."
msgstr "メニューのforegroundカラーの二重ライン。"

#. type: item
#: original_texis/keymaps.texi:2278
#, no-wrap
msgid "\"--single-dashed-line\""
msgstr "\"--single-dashed-line\""

#. type: table
#: original_texis/keymaps.texi:2280
msgid "A single dashed line in the menu's foreground color."
msgstr "メニューのforegroundカラーの一重ダッシュライン。"

#. type: item
#: original_texis/keymaps.texi:2281
#, no-wrap
msgid "\"--double-dashed-line\""
msgstr "\"--double-dashed-line\""

#. type: table
#: original_texis/keymaps.texi:2283
msgid "A double dashed line in the menu's foreground color."
msgstr "メニューのforegroundカラーの二重ダッシュライン。"

#. type: item
#: original_texis/keymaps.texi:2284
#, no-wrap
msgid "\"--shadow-etched-in\""
msgstr "\"--shadow-etched-in\""

#. type: table
#: original_texis/keymaps.texi:2287
msgid "A single line with a 3D sunken appearance.  This is the default, used separators consisting of dashes only."
msgstr "3Dの窪んだ外観(3D sunken appearance)をもつ一重ライン。これはダッシュだけで構成されるセパレーターに使用されるデフォルト。"

#. type: item
#: original_texis/keymaps.texi:2288
#, no-wrap
msgid "\"--shadow-etched-out\""
msgstr "\"--shadow-etched-out\""

#. type: table
#: original_texis/keymaps.texi:2290
msgid "A single line with a 3D raised appearance."
msgstr "3Dの浮き上がった外観(3D raised appearance)をもつ一重ライン。"

#. type: item
#: original_texis/keymaps.texi:2291
#, no-wrap
msgid "\"--shadow-etched-in-dash\""
msgstr "\"--shadow-etched-in-dash\""

#. type: table
#: original_texis/keymaps.texi:2293
msgid "A single dashed line with a 3D sunken appearance."
msgstr "3Dの窪んだ外観(3D sunken appearance)をもつ一重ダッシュライン。"

#. type: item
#: original_texis/keymaps.texi:2294
#, no-wrap
msgid "\"--shadow-etched-out-dash\""
msgstr "\"--shadow-etched-out-dash\""

#. type: table
#: original_texis/keymaps.texi:2296
msgid "A single dashed line with a 3D raised appearance."
msgstr "3Dの浮き上がった外観(3D raised appearance)をもつ一重ダッシュライン。"

#. type: item
#: original_texis/keymaps.texi:2297
#, no-wrap
msgid "\"--shadow-double-etched-in\""
msgstr "\"--shadow-double-etched-in\""

#. type: table
#: original_texis/keymaps.texi:2299
msgid "Two lines with a 3D sunken appearance."
msgstr "3Dの窪んだ外観をもつ二重ライン。"

#. type: item
#: original_texis/keymaps.texi:2300
#, no-wrap
msgid "\"--shadow-double-etched-out\""
msgstr "\"--shadow-double-etched-out\""

#. type: table
#: original_texis/keymaps.texi:2302
msgid "Two lines with a 3D raised appearance."
msgstr "3Dの浮き上がった外観をもつ二重ライン。"

#. type: item
#: original_texis/keymaps.texi:2303
#, no-wrap
msgid "\"--shadow-double-etched-in-dash\""
msgstr "\"--shadow-double-etched-in-dash\""

#. type: table
#: original_texis/keymaps.texi:2305
msgid "Two dashed lines with a 3D sunken appearance."
msgstr "3Dの窪んだ外観をもつ二重ダッシュライン。"

#. type: item
#: original_texis/keymaps.texi:2306
#, no-wrap
msgid "\"--shadow-double-etched-out-dash\""
msgstr "\"--shadow-double-etched-out-dash\""

#. type: table
#: original_texis/keymaps.texi:2308
msgid "Two dashed lines with a 3D raised appearance."
msgstr "3Dの浮き上がった外観をもつ二重ダッシュライン。"

#. type: Plain text
#: original_texis/keymaps.texi:2314
msgid "You can also give these names in another style, adding a colon after the double-dash and replacing each single dash with capitalization of the following word.  Thus, @code{\"--:singleLine\"}, is equivalent to @code{\"--single-line\"}."
msgstr "2連ダッシュの後にコロンを追加して1連ダッシュの後の単語の先頭の文字を大文字にすることによって、別のスタイルで名前を与えることもできます。つまり@code{\"--:singleLine\"}は@code{\"--single-line\"}と等価です。"

#. type: Plain text
#: original_texis/keymaps.texi:2317
msgid "You can use a longer form to specify keywords such as @code{:enable} and @code{:visible} for a menu separator:"
msgstr "メニューセパレーターにたいして@code{:enable}や@code{:visible}のようなキーワードを指定するために長い形式を使用できます。"

#. type: code{#1}
#: original_texis/keymaps.texi:2319
msgid "(menu-item @var{separator-type} nil . @var{item-property-list})"
msgstr "(menu-item @var{separator-type} nil . @var{item-property-list})"

#. type: Plain text
#: original_texis/keymaps.texi:2321
msgid "For example:"
msgstr "たとえば:"

#. type: example
#: original_texis/keymaps.texi:2324
#, no-wrap
msgid "(menu-item \"--\" nil :visible (boundp 'foo))\n"
msgstr "(menu-item \"--\" nil :visible (boundp 'foo))\n"

#. type: Plain text
#: original_texis/keymaps.texi:2329
msgid "Some systems and display toolkits don't really handle all of these separator types.  If you use a type that isn't supported, the menu displays a similar kind of separator that is supported."
msgstr "いくつかのシステムとディスプレイツールキットは、これらすべてのセパレータータイプを実際に処理しません。サポートされていないタイプのセパレーターを使用すると、メニューはサポートされている似た種別のセパレーターを表示します。"

#. type: Plain text
#: original_texis/keymaps.texi:2339
msgid "Sometimes it is useful to make menu items that use the same command but with different enable conditions.  The best way to do this in Emacs now is with extended menu items; before that feature existed, it could be done by defining alias commands and using them in menu items.  Here's an example that makes two aliases for @code{read-only-mode} and gives them different enable conditions:"
msgstr "同じコマンドを使用するものの有効条件が異なるメニューアイテムを作成できれば便利な場合が時折あります。Emacsでこれを行う最善の方法は拡張メニューアイテム(extended menu item)です。この機能が存在する以前にはエイリアスコマンドを定義して、それらをメニューアイテムで使用することによってこれを行っていました。以下は@code{read-only-mode}にたいして2つのエイリアスを作成して、それらに異なる有効条件を与える例です:"

#. type: example
#: original_texis/keymaps.texi:2345
#, no-wrap
msgid ""
"(defalias 'make-read-only 'read-only-mode)\n"
"(put 'make-read-only 'menu-enable '(not buffer-read-only))\n"
"(defalias 'make-writable 'read-only-mode)\n"
"(put 'make-writable 'menu-enable 'buffer-read-only)\n"
msgstr ""
"(defalias 'make-read-only 'read-only-mode)\n"
"(put 'make-read-only 'menu-enable '(not buffer-read-only))\n"
"(defalias 'make-writable 'read-only-mode)\n"
"(put 'make-writable 'menu-enable 'buffer-read-only)\n"

#. type: Plain text
#: original_texis/keymaps.texi:2352
msgid "When using aliases in menus, often it is useful to display the equivalent key bindings for the real command name, not the aliases (which typically don't have any key bindings except for the menu itself).  To request this, give the alias symbol a non-@code{nil} @code{menu-alias} property.  Thus,"
msgstr "メニュー内でエイリアスを使用するときには、エイリアスではなく実際のコマンド名にたいする等価なキーバインディングを表示する方が便利な場合が多々あります(エイリアスは通常はメニュー自身を除いてキーバインディングをもたない)。これを要求するにはエイリアスシンボルの@code{menu-alias}プロパティに非@code{nil}を与えます。したがって、"

#. type: example
#: original_texis/keymaps.texi:2356
#, no-wrap
msgid ""
"(put 'make-read-only 'menu-alias t)\n"
"(put 'make-writable 'menu-alias t)\n"
msgstr ""
"(put 'make-read-only 'menu-alias t)\n"
"(put 'make-writable 'menu-alias t)\n"

#. type: Plain text
#: original_texis/keymaps.texi:2361
msgid "causes menu items for @code{make-read-only} and @code{make-writable} to show the keyboard bindings for @code{read-only-mode}."
msgstr "は@code{make-read-only}と@code{make-writable}にたいするメニューアイテムに@code{read-only-mode}のキーバインディングを表示します。"

#. type: subsection
#: original_texis/keymaps.texi:2363
#, no-wrap
msgid "Menus and the Mouse"
msgstr "Menus and the Mouse"

#. type: Plain text
#: original_texis/keymaps.texi:2368
msgid "The usual way to make a menu keymap produce a menu is to make it the definition of a prefix key.  (A Lisp program can explicitly pop up a menu and receive the user's choice---see @ref{Pop-Up Menus}.)"
msgstr "メニューキーマップがメニューを生成する通常の方法は、それをプレフィクスキーの定義とすることです(Lispプログラムは明示的にメニューをポップアップしてユーザーの選択を受け取ることができる。@ref{Pop-Up Menus}を参照)。"

#. type: Plain text
#: original_texis/keymaps.texi:2375
msgid "If the prefix key ends with a mouse event, Emacs handles the menu keymap by popping up a visible menu, so that the user can select a choice with the mouse.  When the user clicks on a menu item, the event generated is whatever character or symbol has the binding that brought about that menu item.  (A menu item may generate a series of events if the menu has multiple levels or comes from the menu bar.)"
msgstr "プレフィクスキーがマウスイベントで終わる場合には、Emacsはユーザーがマウスで選択できるように可視なメニューをポップアップすることによってメニューキーマップを処理します。ユーザーがメニューアイテムをクリックしたときは、そのメニューアイテムによりもたらされるバインディングの文字やシンボルが何であれイベントが生成されます(メニューが複数レベルをもつ場合やメニューバー由来ならメニューアイテムは1連のイベントを生成するかもしれない)。"

#. type: Plain text
#: original_texis/keymaps.texi:2378
msgid "It's often best to use a button-down event to trigger the menu.  Then the user can select a menu item by releasing the button."
msgstr "メニューのトリガーにbutton-downイベントを使用するのが最善な場合もしばしばあります。その場合にはユーザーはマウスボタンをリリースすることによってメニューアイテムを選択できます。"

#. type: cindex
#: original_texis/keymaps.texi:2379
#, no-wrap
msgid "submenu"
msgstr "submenu"

#. type: Plain text
#: original_texis/keymaps.texi:2387
msgid "If the menu keymap contains a binding to a nested keymap, the nested keymap specifies a @dfn{submenu}.  There will be a menu item, labeled by the nested keymap's item string, and clicking on this item automatically pops up the specified submenu.  As a special exception, if the menu keymap contains a single nested keymap and no other menu items, the menu shows the contents of the nested keymap directly, not as a submenu."
msgstr "メニューキーマップがネストされたキーマップにたいするバインディングを含む場合、そのネストされたキーマップは@dfn{サブメニュー(submenu)}を指定します。それはネストされたキーマップのアイテム文字列によってラベル付けされれメニューアイテムをもち、そのアイテムをクリックすることによって指定されたサブメニューが自動的にポップアップされます。特別な例外としてメニューキーマップが単一のネストされたキーマップを含み、それ以外のメニューアイテムを含まなければ、そのメニューはネストされたキーマップの内容をサブメニューとしてではなく直接メニューに表示します。"

#. type: Plain text
#: original_texis/keymaps.texi:2399
msgid "However, if Emacs is compiled without X toolkit support, or on text terminals, submenus are not supported.  Each nested keymap is shown as a menu item, but clicking on it does not automatically pop up the submenu.  If you wish to imitate the effect of submenus, you can do that by giving a nested keymap an item string which starts with @samp{@@}.  This causes Emacs to display the nested keymap using a separate @dfn{menu pane}; the rest of the item string after the @samp{@@} is the pane label.  If Emacs is compiled without X toolkit support, or if a menu is displayed on a text terminal, menu panes are not used; in that case, a @samp{@@} at the beginning of an item string is omitted when the menu label is displayed, and has no other effect."
msgstr "しかしXツールキットのサポートなしでEmacsをコンパイルした場合、またはテキスト端末の場合にはサブメニューはサポートされません。ネストされたキーマップはメニューアイテムとして表示されますが、それをクリックしてもサブメニューは自動的にポップアップされません。サブメニューの効果を模倣したければ、ネストされたキーマップに@samp{@@}で始まるアイテム文字列を与えることによってこれを行うことができます。これによりEmacsは別個の@dfn{メニューペイン(menu pane)}を使用してネストされたキーマップを表示します。@samp{@@}の後の残りのアイテム文字列はそのペインのラベルです。XツールキットのサポートなしでEmacsをコンパイルした場合、またはメニューがテキスト端末で表示されている場合にはメニューペインは使用されません。この場合はアイテム文字列の先頭の@samp{@@}は、メニューラベル表示時には省略されて他に効果はありません。"

#. type: subsection
#: original_texis/keymaps.texi:2401
#, no-wrap
msgid "Menus and the Keyboard"
msgstr "Menus and the Keyboard"

#. type: Plain text
#: original_texis/keymaps.texi:2407
msgid "When a prefix key ending with a keyboard event (a character or function key) has a definition that is a menu keymap, the keymap operates as a keyboard menu; the user specifies the next event by choosing a menu item with the keyboard."
msgstr "キーボードイベント(文字かファンクションキー)で終わるプレフィクスキーがメニューキーマップであるような定義をもつときには、そのキーマップはキーボードメニューのように動作します。ユーザーはキーボードでメニューアイテムを選択して次のイベントを指定します。"

#. type: Plain text
#: original_texis/keymaps.texi:2416
msgid "Emacs displays the keyboard menu with the map's overall prompt string, followed by the alternatives (the item strings of the map's bindings), in the echo area.  If the bindings don't all fit at once, the user can type @key{SPC} to see the next line of alternatives.  Successive uses of @key{SPC} eventually get to the end of the menu and then cycle around to the beginning.  (The variable @code{menu-prompt-more-char} specifies which character is used for this; @key{SPC} is the default.)"
msgstr "Emacsはエコーエリアにキーボードメニュー、そのマップのoverallプロンプト文字列、その後に選択肢(そのマップのバインディングのアイテム文字列)を表示します。そのバインディングを一度に全部表示できない場合、ユーザーは@key{SPC}をタイプして候補の次の行を確認できます。連続して@key{SPC}を使用するとメニューの最後に達して、その後は先頭へ巡回します(変数@code{menu-prompt-more-char}はこのために使用する文字を指定する。デフォルトは@key{SPC})。"

#. type: Plain text
#: original_texis/keymaps.texi:2420
msgid "When the user has found the desired alternative from the menu, he or she should type the corresponding character---the one whose binding is that alternative."
msgstr "ユーザーがメニューから望ましい候補を見つけたら、バインディングがその候補であるような対応する文字をタイプする必要があります。"

#. type: defvar
#: original_texis/keymaps.texi:2421
#, no-wrap
msgid "menu-prompt-more-char"
msgstr "menu-prompt-more-char"

#. type: defvar
#: original_texis/keymaps.texi:2425
msgid "This variable specifies the character to use to ask to see the next line of a menu.  Its initial value is 32, the code for @key{SPC}."
msgstr "この変数はメニューの次の行を確認するために使用する文字を指定する。初期値は32でこれは@key{SPC}のコード。"

#. type: cindex
#: original_texis/keymaps.texi:2429
#, no-wrap
msgid "menu definition example"
msgstr "menu definition example"

#. type: Plain text
#: original_texis/keymaps.texi:2436
msgid "Here is a complete example of defining a menu keymap.  It is the definition of the @samp{Replace} submenu in the @samp{Edit} menu in the menu bar, and it uses the extended menu item format (@pxref{Extended Menu Items}).  First we create the keymap, and give it a name:"
msgstr "以下はメニューキーマップを定義する完全な例です。これはメニューバー内の@samp{Edit}メニューにサブメニュー@samp{Replace}を定義して、その定義内で拡張メニューフォーマット(@ref{Extended Menu Items}を参照)を使用します。例ではまずキーマップを作成してそれに名前をつけています:"

#. type: smallexample
#: original_texis/keymaps.texi:2439
#, no-wrap
msgid "(defvar menu-bar-replace-menu (make-sparse-keymap \"Replace\"))\n"
msgstr "(defvar menu-bar-replace-menu (make-sparse-keymap \"Replace\"))\n"

#. type: Plain text
#: original_texis/keymaps.texi:2443
msgid "Next we define the menu items:"
msgstr "次にメニューアイテムを定義します:"

#. type: smallexample
#: original_texis/keymaps.texi:2454
#, no-wrap
msgid ""
"(define-key menu-bar-replace-menu [tags-repl-continue]\n"
"  '(menu-item \"Continue Replace\" tags-loop-continue\n"
"              :help \"Continue last tags replace operation\"))\n"
"(define-key menu-bar-replace-menu [tags-repl]\n"
"  '(menu-item \"Replace in tagged files\" tags-query-replace\n"
"              :help \"Interactively replace a regexp in all tagged files\"))\n"
"(define-key menu-bar-replace-menu [separator-replace-tags]\n"
"  '(menu-item \"--\"))\n"
";; @r{@dots{}}\n"
msgstr ""
"(define-key menu-bar-replace-menu [tags-repl-continue]\n"
"  '(menu-item \"Continue Replace\" tags-loop-continue\n"
"              :help \"Continue last tags replace operation\"))\n"
"(define-key menu-bar-replace-menu [tags-repl]\n"
"  '(menu-item \"Replace in tagged files\" tags-query-replace\n"
"              :help \"Interactively replace a regexp in all tagged files\"))\n"
"(define-key menu-bar-replace-menu [separator-replace-tags]\n"
"  '(menu-item \"--\"))\n"
";; @r{@dots{}}\n"

#. type: Plain text
#: original_texis/keymaps.texi:2465
msgid "Note the symbols which the bindings are made for; these appear inside square brackets, in the key sequence being defined.  In some cases, this symbol is the same as the command name; sometimes it is different.  These symbols are treated as function keys, but they are not real function keys on the keyboard.  They do not affect the functioning of the menu itself, but they are echoed in the echo area when the user selects from the menu, and they appear in the output of @code{where-is} and @code{apropos}."
msgstr "バインディングがそのシンボルのために作成されることに注意してください。これらのシンボルは定義されるキーシーケンス内の角カッコ内に記述されます。このシンボルはコマンド名と同じときもあれば異なることもあります。これらのシンボルはファンクションキーとして扱われますが、これらはキーボード上の実際のファンクションキーではありません。これらはメニュー自体の機能に影響しませんが、ユーザーがメニューから選択したときにエコーエリアにエコーされて、@code{where-is}と@code{apropos}の出力に現れます。"

#. type: Plain text
#: original_texis/keymaps.texi:2471
msgid "The menu in this example is intended for use with the mouse.  If a menu is intended for use with the keyboard, that is, if it is bound to a key sequence ending with a keyboard event, then the menu items should be bound to characters or real function keys, that can be typed with the keyboard."
msgstr "この例のメニューはマウスによる使用を意図しています。もしキーボードの使用を意図したメニュー、つまりキーボードイベントで終了するキーシーケンスにバインドされたメニューの場合には、メニューアイテムはキーボードでタイプできる文字、または本当のファンクションキーにバインドされるべきです。"

#. type: Plain text
#: original_texis/keymaps.texi:2476
msgid "The binding whose definition is @code{(\"--\")} is a separator line.  Like a real menu item, the separator has a key symbol, in this case @code{separator-replace-tags}.  If one menu has two separators, they must have two different key symbols."
msgstr "定義が@code{(\"--\")}のバインディングはセパレーターラインです。実際のメニューアイテムと同様にセパレーターはキーシンボルをもち、この例では@code{separator-replace-tags}です。1つのメニューが2つのセパレーターをもつ場合には、それらは2つの異なるキーシンボルをもたなければなりません。"

#. type: Plain text
#: original_texis/keymaps.texi:2478
msgid "Here is how we make this menu appear as an item in the parent menu:"
msgstr "以下では親メニュー内のアイテムとしてこのメニューがどのように表示されるかを記述しています:"

#. type: example
#: original_texis/keymaps.texi:2482
#, no-wrap
msgid ""
"(define-key menu-bar-edit-menu [replace]\n"
"  (list 'menu-item \"Replace\" menu-bar-replace-menu))\n"
msgstr ""
"(define-key menu-bar-edit-menu [replace]\n"
"  (list 'menu-item \"Replace\" menu-bar-replace-menu))\n"

#. type: Plain text
#: original_texis/keymaps.texi:2490
msgid "Note that this incorporates the submenu keymap, which is the value of the variable @code{menu-bar-replace-menu}, rather than the symbol @code{menu-bar-replace-menu} itself.  Using that symbol in the parent menu item would be meaningless because @code{menu-bar-replace-menu} is not a command."
msgstr "これはシンボル@code{menu-bar-replace-menu}自体ではなく、変数@code{menu-bar-replace-menu}の値であるサブメニューキーマップを組み込むことに注意してください。@code{menu-bar-replace-menu}はコマンドではないので親メニューアイテムにそのシンボルを使用するのは無意味です。"

#. type: Plain text
#: original_texis/keymaps.texi:2493
msgid "If you wanted to attach the same replace menu to a mouse click, you can do it this way:"
msgstr "同じreplaceメニューをマウスクリックに割り当てたければ以下のようにしてこれを行うことができます:"

#. type: example
#: original_texis/keymaps.texi:2497
#, no-wrap
msgid ""
"(define-key global-map [C-S-down-mouse-1]\n"
"   menu-bar-replace-menu)\n"
msgstr ""
"(define-key global-map [C-S-down-mouse-1]\n"
"   menu-bar-replace-menu)\n"

#. type: subsection
#: original_texis/keymaps.texi:2500
#, no-wrap
msgid "The Menu Bar"
msgstr "The Menu Bar"

#. type: cindex
#: original_texis/keymaps.texi:2501
#, no-wrap
msgid "menu bar"
msgstr "menu bar"

#. type: Plain text
#: original_texis/keymaps.texi:2507
msgid "Emacs usually shows a @dfn{menu bar} at the top of each frame.  @xref{Menu Bars,,,emacs, The GNU Emacs Manual}.  Menu bar items are subcommands of the fake function key @code{menu-bar}, as defined in the active keymaps."
msgstr "Emacsは通常は各フレームの最上部に@dfn{メニューバー(menu bar)}を表示します。@ref{Menu Bars,,,emacs, The GNU Emacs Manual}を参照してください。メニューバーのアイテムはアクティブキーマップ内で定義される偽りのファンクションキー@code{menu-bar}のサブコマンドです。"

#. type: Plain text
#: original_texis/keymaps.texi:2512
msgid "To add an item to the menu bar, invent a fake function key of your own (let's call it @var{key}), and make a binding for the key sequence @code{[menu-bar @var{key}]}.  Most often, the binding is a menu keymap, so that pressing a button on the menu bar item leads to another menu."
msgstr "メニューバーにアイテムを追加するには、自分で偽りのファンクションキー(これを@var{key}と呼ぶこととする)を創作して、キーシーケンス@code{[menu-bar @var{key}]}にたいするキーバインディングを作成します。ほとんどの場合において、そのバインディングはメニューキーマップなので、メニューバーアイテム上でボタンを押下すると他のメニューに導かれます。"

#. type: Plain text
#: original_texis/keymaps.texi:2518
msgid "When more than one active keymap defines the same function key for the menu bar, the item appears just once.  If the user clicks on that menu bar item, it brings up a single, combined menu containing all the subcommands of that item---the global subcommands, the local subcommands, and the minor mode subcommands."
msgstr "メニューバーにたいして同じファンクションキーを定義するアクティブなキーマップが1つ以上存在するとき、そのアイテムは一度だけ出現します。ユーザーがメニューバーのそのアイテムをクリックすると、そのアイテムのすべてのサブコマンド、すなわちグローバルサブコマンド、ローカルサブコマンド、マイナーモードサブコマンドが組み合わされた単一のメニューを表示します。"

#. type: Plain text
#: original_texis/keymaps.texi:2523
msgid "The variable @code{overriding-local-map} is normally ignored when determining the menu bar contents.  That is, the menu bar is computed from the keymaps that would be active if @code{overriding-local-map} were @code{nil}.  @xref{Active Keymaps}."
msgstr "変数@code{overriding-local-map}は通常はメニューバーのコンテンツを決定する際は無視されます。つまりメニューバーは@code{overriding-local-map}が@code{nil}の場合にアクティブになるであろうキーマップから計算されます。@ref{Active Keymaps}を参照してください。"

#. type: Plain text
#: original_texis/keymaps.texi:2525
msgid "Here's an example of setting up a menu bar item:"
msgstr "以下はメニューバーのアイテムをセットアップする例です:"

#. type: group
#: original_texis/keymaps.texi:2532
#, no-wrap
msgid ""
";; @r{Make a menu keymap (with a prompt string)}\n"
";; @r{and make it the menu bar item's definition.}\n"
"(define-key global-map [menu-bar words]\n"
"  (cons \"Words\" (make-sparse-keymap \"Words\")))\n"
msgstr ""
";; @r{(プロンプト文字列とともに)メニューキーマップを作成して}\n"
";; @r{それをメニューバーアイテムの定義にする}\n"
"(define-key global-map [menu-bar words]\n"
"  (cons \"Words\" (make-sparse-keymap \"Words\")))\n"

#. type: group
#: original_texis/keymaps.texi:2539
#, no-wrap
msgid ""
";; @r{Define specific subcommands in this menu.}\n"
"(define-key global-map\n"
"  [menu-bar words forward]\n"
"  '(\"Forward word\" . forward-word))\n"
msgstr ""
";; @r{メニュー内に具体的なサブコマンドを定義する}\n"
"(define-key global-map\n"
"  [menu-bar words forward]\n"
"  '(\"Forward word\" . forward-word))\n"

#. type: group
#: original_texis/keymaps.texi:2544
#, no-wrap
msgid ""
"(define-key global-map\n"
"  [menu-bar words backward]\n"
"  '(\"Backward word\" . backward-word))\n"
msgstr ""
"(define-key global-map\n"
"  [menu-bar words backward]\n"
"  '(\"Backward word\" . backward-word))\n"

#. type: Plain text
#: original_texis/keymaps.texi:2551
msgid "A local keymap can cancel a menu bar item made by the global keymap by rebinding the same fake function key with @code{undefined} as the binding.  For example, this is how Dired suppresses the @samp{Edit} menu bar item:"
msgstr "ローカルキーマップはグローバルキーマップにより作成されたメニューバーアイテムにたいして、同じ偽ファンクションキーを@code{undefined}にリバインドしてキャンセルすることができます。たとえば以下はDiredが@samp{Edit}メニューバーアイテムを抑制する方法です:"

#. type: example
#: original_texis/keymaps.texi:2554
#, no-wrap
msgid "(define-key dired-mode-map [menu-bar edit] 'undefined)\n"
msgstr "(define-key dired-mode-map [menu-bar edit] 'undefined)\n"

#. type: Plain text
#: original_texis/keymaps.texi:2560
msgid "Here, @code{edit} is the fake function key used by the global map for the @samp{Edit} menu bar item.  The main reason to suppress a global menu bar item is to regain space for mode-specific items."
msgstr "ここで@code{edit}は@samp{Edit}メニューバーアイテムにたいしてグローバルキーマップにより使用される偽ファンクションキーです。グローバルメニューバーアイテムを抑制する主な理由は、モード特有のアイテム用にスペースを確保するためです。"

#. type: defvar
#: original_texis/keymaps.texi:2561
#, no-wrap
msgid "menu-bar-final-items"
msgstr "menu-bar-final-items"

#. type: defvar
#: original_texis/keymaps.texi:2564
msgid "Normally the menu bar shows global items followed by items defined by the local maps."
msgstr "メニューバーは通常はローカルマップで定義されるアイテムを終端にもつグローバルアイテムを表示する。"

#. type: defvar
#: original_texis/keymaps.texi:2569
msgid "This variable holds a list of fake function keys for items to display at the end of the menu bar rather than in normal sequence.  The default value is @code{(help-menu)}; thus, the @samp{Help} menu item normally appears at the end of the menu bar, following local menu items."
msgstr "この変数は通常の順番による位置ではなく、メニューの最後に表示するアイテムのための偽ファンクションキーのリストを保持する。デフォルト値は@code{(help-menu)}。したがって@samp{Help}メニューアイテムはメニューバーの最後、ローカルメニューアイテムの後に表示される。"

#. type: defvar
#: original_texis/keymaps.texi:2571
#, no-wrap
msgid "menu-bar-update-hook"
msgstr "menu-bar-update-hook"

#. type: defvar
#: original_texis/keymaps.texi:2577
msgid "This normal hook is run by redisplay to update the menu bar contents, before redisplaying the menu bar.  You can use it to update menus whose contents should vary.  Since this hook is run frequently, we advise you to ensure that the functions it calls do not take much time in the usual case."
msgstr "このノーマルフックはメニューバーの再表示の前に、メニューバーのコンテンツ更新のための再表示によって実行される。コンテンツを変化させる必要があるメニューの更新に使用できる。このフックは頻繁に実行されるので、フックが呼び出す関数は通常は長い時間を要さないことを確実にするよう助言する。"

#. type: Plain text
#: original_texis/keymaps.texi:2586
msgid "Next to every menu bar item, Emacs displays a key binding that runs the same command (if such a key binding exists).  This serves as a convenient hint for users who do not know the key binding.  If a command has multiple bindings, Emacs normally displays the first one it finds.  You can specify one particular key binding by assigning an @code{:advertised-binding} symbol property to the command.  @xref{Keys in Documentation}."
msgstr "Emacsはすべてのメニューバーアイテムの隣に、(もしそのようなキーバインディングが存在するなら)同じコマンドを実行するキーバインディングを表示します。これはキーバインディングを知らないユーザーにたいして有用なヒントを与える役目をもちます。コマンドが複数のバインディングをもつ場合、Emacsは通常は最初に見つけたバインディングを表示します。コマンドのシンボルプロパティ@code{:advertised-binding}に割り当てることによって特定のキーバインディングを指定できます。@ref{Keys in Documentation}を参照してください。"

#. type: subsection
#: original_texis/keymaps.texi:2588
#, no-wrap
msgid "Tool bars"
msgstr "Tool bars"

#. type: cindex
#: original_texis/keymaps.texi:2589
#, no-wrap
msgid "tool bar"
msgstr "tool bar"

#. type: Plain text
#: original_texis/keymaps.texi:2594
msgid "A @dfn{tool bar} is a row of clickable icons at the top of a frame, just below the menu bar.  @xref{Tool Bars,,,emacs, The GNU Emacs Manual}.  Emacs normally shows a tool bar on graphical displays."
msgstr "@dfn{ツールバー(tool bar)}とはフレームの最上部、メニューバー直下にあるクリック可能なアイコンの行のことです。@ref{Tool Bars,,,emacs, The GNU Emacs Manual}を参照してください。Emacsは通常はグラフィカルなディスプレイ上でツールバーを表示します。"

#. type: Plain text
#: original_texis/keymaps.texi:2602
msgid "On each frame, the frame parameter @code{tool-bar-lines} controls how many lines' worth of height to reserve for the tool bar.  A zero value suppresses the tool bar.  If the value is nonzero, and @code{auto-resize-tool-bars} is non-@code{nil}, the tool bar expands and contracts automatically as needed to hold the specified contents.  If the value is @code{grow-only}, the tool bar expands automatically, but does not contract automatically."
msgstr "各フレームではツールバーに何行分の高さを割り当てるかをフレームパラメーター@code{tool-bar-lines}で制御します。値0はツールバーを抑制します。値が非0で@code{auto-resize-tool-bars}が非@code{nil}なら、指定されたコンテンツを維持するのに必要な分、ツールバーは拡大縮小されます。値が@code{grow-only}ならツールバーは自動的に拡大されますが、自動的に縮小はされません。"

#. type: Plain text
#: original_texis/keymaps.texi:2607
msgid "The tool bar contents are controlled by a menu keymap attached to a fake function key called @code{tool-bar} (much like the way the menu bar is controlled).  So you define a tool bar item using @code{define-key}, like this:"
msgstr "ツールバーのコンテンツは、(メニューバーが制御されるのと似た方法により)@code{tool-bar}と呼ばれる偽りのファンクションキーに割り当てられるメニューキーマップにより制御されます。したがって以下のように@code{define-key}を使用してツールバーアイテムを定義します。"

#. type: example
#: original_texis/keymaps.texi:2610
#, no-wrap
msgid "(define-key global-map [tool-bar @var{key}] @var{item})\n"
msgstr "(define-key global-map [tool-bar @var{key}] @var{item})\n"

#. type: Plain text
#: original_texis/keymaps.texi:2616
msgid "where @var{key} is a fake function key to distinguish this item from other items, and @var{item} is a menu item key binding (@pxref{Extended Menu Items}), which says how to display this item and how it behaves."
msgstr "ここで@var{key}はそのアイテムを他のアイテムと区別する偽ファンクションキー、@var{item}はそのアイテムを表示する方法とアイテムの振る舞いを示すメニューアイテムキーバインディングです(@ref{Extended Menu Items}を参照)。"

#. type: Plain text
#: original_texis/keymaps.texi:2622
msgid "The usual menu keymap item properties, @code{:visible}, @code{:enable}, @code{:button}, and @code{:filter}, are useful in tool bar bindings and have their normal meanings.  The @var{real-binding} in the item must be a command, not a keymap; in other words, it does not work to define a tool bar icon as a prefix key."
msgstr "メニューキーマップの通常のプロパティ@code{:visible}、@code{:enable}、@code{:button}、@code{:filter}はツールバーバインディングでも有用で、いずれのプロパティも通常通りの意味をもちます。アイテム内の@var{real-binding}はキーマップではなくコマンドでなければなりません。言い換えるとこれはツールバーアイコンをプレフィクスキーとして定義するようには機能しないということです。"

#. type: Plain text
#: original_texis/keymaps.texi:2626
msgid "The @code{:help} property specifies a help-echo string to display while the mouse is on that item.  This is displayed in the same way as @code{help-echo} text properties (@pxref{Help display})."
msgstr "@code{:help}プロパティは、そのアイテム上にマウスがある間表示するhelp-echo文字列を指定します。これはテキストプロパティ@code{help-echo}と同じ方法で表示されます(@ref{Help display}を参照)。"

#. type: Plain text
#: original_texis/keymaps.texi:2629
msgid "In addition, you should use the @code{:image} property; this is how you specify the image to display in the tool bar:"
msgstr "これらに加えて@code{:image}プロパティも使用するべきでしょう。ツールバー内にイメージを表示するにはこのプロパティを使用します。"

#. type: item
#: original_texis/keymaps.texi:2631
#, no-wrap
msgid ":image @var{image}"
msgstr ":image @var{image}"

#. type: table
#: original_texis/keymaps.texi:2635
msgid "@var{image} is either a single image specification (@pxref{Images}) or a vector of four image specifications.  If you use a vector of four, one of them is used, depending on circumstances:"
msgstr "@var{image}は単一イメージ様式(single image specification)か4ベクターイメージ様式(vector of four image specifications)で指定する(@ref{Images}を参照)。4ベクターを使用する場合には状況に応じて以下のいずれかが使用される:"

#. type: item
#: original_texis/keymaps.texi:2637
#, no-wrap
msgid "item 0"
msgstr "item 0"

#. type: table
#: original_texis/keymaps.texi:2639
msgid "Used when the item is enabled and selected."
msgstr "アイテムが有効かつ選択されているときに使用。"

#. type: item
#: original_texis/keymaps.texi:2639
#, no-wrap
msgid "item 1"
msgstr "item 1"

#. type: table
#: original_texis/keymaps.texi:2641
msgid "Used when the item is enabled and deselected."
msgstr "アイテムが有効かつ未選択のときに使用。"

#. type: item
#: original_texis/keymaps.texi:2641
#, no-wrap
msgid "item 2"
msgstr "item 2"

#. type: table
#: original_texis/keymaps.texi:2643
msgid "Used when the item is disabled and selected."
msgstr "アイテムが無効かつ選択されているときに使用。"

#. type: item
#: original_texis/keymaps.texi:2643
#, no-wrap
msgid "item 3"
msgstr "item 3"

#. type: table
#: original_texis/keymaps.texi:2645
msgid "Used when the item is disabled and deselected."
msgstr "アイテムが無効かつ未選択のときに使用。"

#. type: Plain text
#: original_texis/keymaps.texi:2650
msgid "The GTK+ and NS versions of Emacs ignores items 1 to 3, because disabled and/or deselected images are autocomputed from item 0."
msgstr "GTK+バージョンとNSバージョンのEmacsは、無効および/または未選択のイメージをitem0から自動的に計算するので、item1からitem3は無視されます。"

#. type: Plain text
#: original_texis/keymaps.texi:2654
msgid "If @var{image} is a single image specification, Emacs draws the tool bar button in disabled state by applying an edge-detection algorithm to the image."
msgstr "@var{image}が単一イメージ様式なあ、Emacsはそのイメージにエッジ検出アルゴリズム(edge-detection algorithm)を適用することによってツールバーの無効な状態のボタンを描画します。"

#. type: Plain text
#: original_texis/keymaps.texi:2658
msgid "The @code{:rtl} property specifies an alternative image to use for right-to-left languages.  Only the GTK+ version of Emacs supports this at present."
msgstr "@code{:rtl}プロパティには右から左に記述する言語のためのイメージ候補を指定します。これをサポートするのは現在のところGTK+バージョンのEmacsだけです。"

#. type: Plain text
#: original_texis/keymaps.texi:2667
msgid "Like the menu bar, the tool bar can display separators (@pxref{Menu Separators}).  Tool bar separators are vertical rather than horizontal, though, and only a single style is supported.  They are represented in the tool bar keymap by @code{(menu-item \"--\")} entries; properties like @code{:visible} are not supported for tool bar separators.  Separators are rendered natively in GTK+ and Nextstep tool bars; in the other cases, they are rendered using an image of a vertical line."
msgstr "メニューバーと同様、ツールバーはセパレーター(@ref{Menu Separators}を参照)を表示できます。ツールバーのセパレーターは水平ラインではなく垂直ラインであり、1つのスタイルだけがサポートされます。これらはツールバーキーマップ内では@code{(menu-item \"--\")}エントリーで表されます。ツールバーのセパレーターでは、@code{:visible}のようなプロパティはサポートされません。GTK+とNextstepのツールバーでは、セパレーターはネイティブに描画されます。それ以外ではセパレーターは垂直ラインイメージを使用して描画されます。"

#. type: Plain text
#: original_texis/keymaps.texi:2676
msgid "The default tool bar is defined so that items specific to editing do not appear for major modes whose command symbol has a @code{mode-class} property of @code{special} (@pxref{Major Mode Conventions}).  Major modes may add items to the global bar by binding @code{[tool-bar @var{foo}]} in their local map.  It makes sense for some major modes to replace the default tool bar items completely, since not many can be accommodated conveniently, and the default bindings make this easy by using an indirection through @code{tool-bar-map}."
msgstr "デフォルトツールバーはコマンドシンボルの@code{mode-class}プロパティに@code{special}をもつメジャーモードにたいしては、編集に特化したアイテムは表示しないよう定義されています(@ref{Major Mode Conventions}を参照)。メジャーモードは、ローカルマップ内でバインディング@code{[tool-bar @var{foo}]}によって、グローバルバーにアイテムを追加するかもしれません。デフォルトツールバーの多くを適宜流用するのができないかもしれないので、デフォルトツールバーを完全に置き換えることは、いくつかのメジャーモードにとっては有意義です。デフォルトバインディングで@code{tool-bar-map}を通じてインダイレクトすることにより、これを簡単に行うことができます。"

#. type: defvar
#: original_texis/keymaps.texi:2677
#, no-wrap
msgid "tool-bar-map"
msgstr "tool-bar-map"

#. type: defvar
#: original_texis/keymaps.texi:2679
msgid "By default, the global map binds @code{[tool-bar]} as follows:"
msgstr "デフォルトではグローバルマップは@code{[tool-bar]}を以下のようにバインドする:"

#. type: example
#: original_texis/keymaps.texi:2684
#, no-wrap
msgid ""
"(global-set-key [tool-bar]\n"
"                `(menu-item ,(purecopy \"tool bar\") ignore\n"
"                            :filter tool-bar-make-keymap))\n"
msgstr ""
"(global-set-key [tool-bar]\n"
"                `(menu-item ,(purecopy \"tool bar\") ignore\n"
"                            :filter tool-bar-make-keymap))\n"

#. type: defvar
#: original_texis/keymaps.texi:2693
msgid "The function @code{tool-bar-make-keymap}, in turn, derives the actual tool bar map dynamically from the value of the variable @code{tool-bar-map}.  Hence, you should normally adjust the default (global) tool bar by changing that map.  Some major modes, such as Info mode, completely replace the global tool bar by making @code{tool-bar-map} buffer-local and setting it to a different keymap."
msgstr "関数@code{tool-bar-make-keymap}は、変数@code{tool-bar-map}の値より順番に実際のツールバーマップをダイナミックに継承する。したがって通常はそのマップを変更することにより、デフォルト(グローバル)ツールバーを調整すること。Infoモードのようないくつかのメジャーモードは、@code{tool-bar-map}をバッファーローカルにして、それに異なるキーマップをセットすることによりグローバルツールバーを完全に置き換える。"

#. type: Plain text
#: original_texis/keymaps.texi:2697
msgid "There are two convenience functions for defining tool bar items, as follows."
msgstr "以下のようなツールバーアイテムを定義するのに便利な関数があります。"

#. type: defun
#: original_texis/keymaps.texi:2698
#, no-wrap
msgid "tool-bar-add-item icon def key &rest props"
msgstr "tool-bar-add-item icon def key &rest props"

#. type: defun
#: original_texis/keymaps.texi:2709
msgid "This function adds an item to the tool bar by modifying @code{tool-bar-map}.  The image to use is defined by @var{icon}, which is the base name of an XPM, XBM or PBM image file to be located by @code{find-image}.  Given a value @samp{\"exit\"}, say, @file{exit.xpm}, @file{exit.pbm} and @file{exit.xbm} would be searched for in that order on a color display.  On a monochrome display, the search order is @samp{.pbm}, @samp{.xbm} and @samp{.xpm}.  The binding to use is the command @var{def}, and @var{key} is the fake function key symbol in the prefix keymap.  The remaining arguments @var{props} are additional property list elements to add to the menu item specification."
msgstr "この関数は@code{tool-bar-map}を変更することにより、ツールバーにアイテムを追加する。使用するイメージは@var{icon}により定義され、これは@code{find-image}に配置されたXPM、XBM、PBMのイメージファイルの拡張子を除いたファイル名(basename)である。たとえばカラーディスプレイ上では、値に@samp{\"exit\"}を与えると@file{exit.xpm}、@file{exit.pbm}、@file{exit.xbm}の順に検索されるだろう。モノクロディスプレイでは検索は@samp{.pbm}、@samp{.xbm}、@samp{.xpm}の順になる。使用するバインディングはコマンド@var{def}で、@var{key}はプレフィクスキーマップ内の偽ファンクションキーである。残りの引数@var{props}はメニューアイテム仕様に追加する追加のプロパティリスト要素である。"

#. type: defun
#: original_texis/keymaps.texi:2712
msgid "To define items in some local map, bind @code{tool-bar-map} with @code{let} around calls of this function:"
msgstr "あるローカルマップ内にアイテムを定義するためには、この関数呼び出しの周囲の@code{let}で@code{tool-bar-map}をバインドする:"

#. type: example
#: original_texis/keymaps.texi:2718
#, no-wrap
msgid ""
"(defvar foo-tool-bar-map\n"
"  (let ((tool-bar-map (make-sparse-keymap)))\n"
"    (tool-bar-add-item @dots{})\n"
"    @dots{}\n"
"    tool-bar-map))\n"
msgstr ""
"(defvar foo-tool-bar-map\n"
"  (let ((tool-bar-map (make-sparse-keymap)))\n"
"    (tool-bar-add-item @dots{})\n"
"    @dots{}\n"
"    tool-bar-map))\n"

#. type: defun
#: original_texis/keymaps.texi:2721
#, no-wrap
msgid "tool-bar-add-item-from-menu command icon &optional map &rest props"
msgstr "tool-bar-add-item-from-menu command icon &optional map &rest props"

#. type: defun
#: original_texis/keymaps.texi:2730
msgid "This function is a convenience for defining tool bar items which are consistent with existing menu bar bindings.  The binding of @var{command} is looked up in the menu bar in @var{map} (default @code{global-map}) and modified to add an image specification for @var{icon}, which is found in the same way as by @code{tool-bar-add-item}.  The resulting binding is then placed in @code{tool-bar-map}, so use this function only for global tool bar items."
msgstr "この関数は既存のメニューバインディングと矛盾しないツールバーアイテムの定義に有用。@var{command}のバインディングは@var{map}(デフォルトは@code{global-map})内よりルックアップ(lookup: 照合)され、@var{icon}にたいするイメージ仕様は@code{tool-bar-add-item}と同じ方法で見つけ出される。結果のバインディングは@code{tool-bar-map}に配置されるので、この関数の使用はグローバルツールバーアイテムに限定される。"

#. type: defun
#: original_texis/keymaps.texi:2734
msgid "@var{map} must contain an appropriate keymap bound to @code{[menu-bar]}.  The remaining arguments @var{props} are additional property list elements to add to the menu item specification."
msgstr "@var{map}には@code{[menu-bar]}にバインドされた適切なキーマップが含まれていなければならない。残りの引数@var{props}はメニューアイテム仕様に追加する追加のプロパティリスト要素。"

#. type: defun
#: original_texis/keymaps.texi:2736
#, no-wrap
msgid "tool-bar-local-item-from-menu command icon in-map &optional from-map &rest props"
msgstr "tool-bar-local-item-from-menu command icon in-map &optional from-map &rest props"

#. type: defun
#: original_texis/keymaps.texi:2742
msgid "This function is used for making non-global tool bar items.  Use it like @code{tool-bar-add-item-from-menu} except that @var{in-map} specifies the local map to make the definition in.  The argument @var{from-map} is like the @var{map} argument of @code{tool-bar-add-item-from-menu}."
msgstr "この関数は非グローバルツールバーアイテムの作成に使用される。@var{in-map}に定義を作成するローカルマップを指定する以外は@code{tool-bar-add-item-from-menu}と同じように使用する。引数@var{from-map}は@code{tool-bar-add-item-from-menu}の@var{map}と同様。"

#. type: defvar
#: original_texis/keymaps.texi:2744
#, no-wrap
msgid "auto-resize-tool-bars"
msgstr "auto-resize-tool-bars"

#. type: defvar
#: original_texis/keymaps.texi:2748
msgid "If this variable is non-@code{nil}, the tool bar automatically resizes to show all defined tool bar items---but not larger than a quarter of the frame's height."
msgstr "この変数が非@code{nil}なら定義されたすべてのツールバーアイテムを表示するためにツールバーは自動的にリサイズされるが、そのフレーム高さの1/4を超えてリサイズされることはない。"

#. type: defvar
#: original_texis/keymaps.texi:2752
msgid "If the value is @code{grow-only}, the tool bar expands automatically, but does not contract automatically.  To contract the tool bar, the user has to redraw the frame by entering @kbd{C-l}."
msgstr "値が@code{grow-only}ならツールバーは自動的に拡張されるが縮小はされない。ツールバーを縮小するためにユーザーは@kbd{C-l}をエンターしてフレームを再描画する必要がある。"

#. type: defvar
#: original_texis/keymaps.texi:2755
msgid "If Emacs is built with GTK+ or Nextstep, the tool bar can only show one line, so this variable has no effect."
msgstr "GTK+やNextstepとともにEmacsがビルドされた場合には、ツールバーが表示できるのは1行だけであり、この変数は効果がない。"

#. type: defvar
#: original_texis/keymaps.texi:2757
#, no-wrap
msgid "auto-raise-tool-bar-buttons"
msgstr "auto-raise-tool-bar-buttons"

#. type: defvar
#: original_texis/keymaps.texi:2760
msgid "If this variable is non-@code{nil}, tool bar items display in raised form when the mouse moves over them."
msgstr "この変数が非@code{nil}ならツールバーアイテム上をマウスが通過したとき、浮き上がった形式(raised form)で表示される。"

#. type: defvar
#: original_texis/keymaps.texi:2762
#, no-wrap
msgid "tool-bar-button-margin"
msgstr "tool-bar-button-margin"

#. type: defvar
#: original_texis/keymaps.texi:2765
msgid "This variable specifies an extra margin to add around tool bar items.  The value is an integer, a number of pixels.  The default is 4."
msgstr "この変数はツールバーアイテムの周囲に追加する余白(extra margin)を指定する。値はピクセル数を整数で指定する。デフォルトは4。"

#. type: defvar
#: original_texis/keymaps.texi:2767
#, no-wrap
msgid "tool-bar-button-relief"
msgstr "tool-bar-button-relief"

#. type: defvar
#: original_texis/keymaps.texi:2770
msgid "This variable specifies the shadow width for tool bar items.  The value is an integer, a number of pixels.  The default is 1."
msgstr "この変数はツールバーアイテムの影(shadow)を指定する。値はピクセル数を整数で指定する。デフォルトは1。"

#. type: defvar
#: original_texis/keymaps.texi:2772
#, no-wrap
msgid "tool-bar-border"
msgstr "tool-bar-border"

#. type: defvar
#: original_texis/keymaps.texi:2778
msgid "This variable specifies the height of the border drawn below the tool bar area.  An integer specifies height as a number of pixels.  If the value is one of @code{internal-border-width} (the default) or @code{border-width}, the tool bar border height corresponds to the corresponding frame parameter."
msgstr "この変数はツールバーエリアの下に描画するボーダー高さを指定する。値が整数なら高さのピクセル数。値が@code{internal-border-width}(デフォルト)か@code{border-width}のいずれかなら、ツールバーのボーダー高さはそのフレームの対応するパラメーターとなる。"

#. type: Plain text
#: original_texis/keymaps.texi:2786
msgid "You can define a special meaning for clicking on a tool bar item with the shift, control, meta, etc., modifiers.  You do this by setting up additional items that relate to the original item through the fake function keys.  Specifically, the additional items should use the modified versions of the same fake function key used to name the original item."
msgstr "シフトやメタ等の修飾キーを押下した状態でのツールバーアイテムのクリックに特別な意味を付与できます。偽りのファンクションキーを通じて元のアイテムに関連する追加アイテムをセットアップすることによって、これを行うことができます。より具体的には追加アイテムは、元のアイテムの命名に使用されたのと同じ偽ファンクションキーの修飾されたバージョンを使用するべきです。"

#. type: Plain text
#: original_texis/keymaps.texi:2788
msgid "Thus, if the original item was defined this way,"
msgstr "つまり元のアイテムが以下のように定義されていれば、"

#. type: example
#: original_texis/keymaps.texi:2793
#, no-wrap
msgid ""
"(define-key global-map [tool-bar shell]\n"
"  '(menu-item \"Shell\" shell\n"
"              :image (image :type xpm :file \"shell.xpm\")))\n"
msgstr ""
"(define-key global-map [tool-bar shell]\n"
"  '(menu-item \"Shell\" shell\n"
"              :image (image :type xpm :file \"shell.xpm\")))\n"

#. type: Plain text
#: original_texis/keymaps.texi:2798
msgid "then here is how you can define clicking on the same tool bar image with the shift modifier:"
msgstr "シフト修飾とともに同じツールバーイメージをクリックしたときを以下のような方法で定義することができます:"

#. type: example
#: original_texis/keymaps.texi:2801
#, no-wrap
msgid "(define-key global-map [tool-bar S-shell] 'some-command)\n"
msgstr "(define-key global-map [tool-bar S-shell] 'some-command)\n"

#. type: Plain text
#: original_texis/keymaps.texi:2805
msgid "@xref{Function Keys}, for more information about how to add modifiers to function keys."
msgstr "ファンクションキーに修飾を追加する方法についての詳細な情報は、@ref{Function Keys}を参照してください。"

#. type: cindex
#: original_texis/keymaps.texi:2808
#, no-wrap
msgid "menu modification"
msgstr "menu modification"

#. type: Plain text
#: original_texis/keymaps.texi:2814
msgid "When you insert a new item in an existing menu, you probably want to put it in a particular place among the menu's existing items.  If you use @code{define-key} to add the item, it normally goes at the front of the menu.  To put it elsewhere in the menu, use @code{define-key-after}:"
msgstr "既存のメニューに新たなアイテムを挿入するときは、そのメニューの既存のアイテムの中の特定の位置にアイテムを追加したいと思うかもしれません。@code{define-key}を使用してアイテムを追加すると、そのアイテムは通常はメニューの先頭に追加されます。メニュー内の他の位置にアイテムを追加するには@code{define-key-after}を使用します:"

#. type: defun
#: original_texis/keymaps.texi:2815
#, no-wrap
msgid "define-key-after map key binding &optional after"
msgstr "define-key-after map key binding &optional after"

#. type: defun
#: original_texis/keymaps.texi:2825
msgid "Define a binding in @var{map} for @var{key}, with value @var{binding}, just like @code{define-key}, but position the binding in @var{map} after the binding for the event @var{after}.  The argument @var{key} should be of length one---a vector or string with just one element.  But @var{after} should be a single event type---a symbol or a character, not a sequence.  The new binding goes after the binding for @var{after}.  If @var{after} is @code{t} or is omitted, then the new binding goes last, at the end of the keymap.  However, new bindings are added before any inherited keymap."
msgstr "@code{define-key}と同じように@var{map}内に@var{key}にたいする値@var{binding}のバインディングを定義するが、@var{map}内でのバインディング位置はイベント@var{after}のバインディングの後になる。引数@var{key}は長さ1 --- 1要素だけのベクターか文字列にすること。しかし@var{after}は単一のイベント型 --- シーケンスではないシンボルか文字にすること。新たなバインディングは@var{after}のバインディングの後に追加される。@var{after}が@code{t}または省略された場合には、新たなバインディングはそのキーマップの最後に追加される。しかし新たなバインディングは継承されたすべてのキーマップの前に追加される。"

#. type: defun
#: original_texis/keymaps.texi:2827
msgid "Here is an example:"
msgstr "以下は例:"

#. type: example
#: original_texis/keymaps.texi:2831
#, no-wrap
msgid ""
"(define-key-after my-menu [drink]\n"
"  '(\"Drink\" . drink-command) 'eat)\n"
msgstr ""
"(define-key-after my-menu [drink]\n"
"  '(\"Drink\" . drink-command) 'eat)\n"

#. type: defun
#: original_texis/keymaps.texi:2836
msgid "makes a binding for the fake function key @key{DRINK} and puts it right after the binding for @key{EAT}."
msgstr "これは偽ファンクションキー@key{DRINK}のバインディングを作成して、@key{EAT}のバインディングの直後に追加する。"

#. type: defun
#: original_texis/keymaps.texi:2839
msgid "Here is how to insert an item called @samp{Work} in the @samp{Signals} menu of Shell mode, after the item @code{break}:"
msgstr "以下はShellモードの@samp{Signals}メニュー内のアイテム@code{break}の後に@samp{Work}と呼ばれるアイテムを追加する方法:"

#. type: example
#: original_texis/keymaps.texi:2844
#, no-wrap
msgid ""
"(define-key-after\n"
"  (lookup-key shell-mode-map [menu-bar signals])\n"
"  [work] '(\"Work\" . work-command) 'break)\n"
msgstr ""
"(define-key-after\n"
"  (lookup-key shell-mode-map [menu-bar signals])\n"
"  [work] '(\"Work\" . work-command) 'break)\n"

#. type: Plain text
#: original_texis/keymaps.texi:2852
msgid "The following macro provides a convenient way to define pop-up menus and/or menu bar menus."
msgstr "以下のマクロはポップアップメニューおよび/またはメニューバーメニューを定義する便利な方法を提供します。"

#. type: defmac
#: original_texis/keymaps.texi:2853
#, no-wrap
msgid "easy-menu-define symbol maps doc menu"
msgstr "easy-menu-define symbol maps doc menu"

#. type: defmac
#: original_texis/keymaps.texi:2856
msgid "This macro defines a pop-up menu and/or menu bar submenu, whose contents are given by @var{menu}."
msgstr "このマクロは@var{menu}により与えるコンテンツのポップアップメニューおよび/またはメニューバーサブメニューを定義する。"

#. type: defmac
#: original_texis/keymaps.texi:2861
msgid "If @var{symbol} is non-@code{nil}, it should be a symbol; then this macro defines @var{symbol} as a function for popping up the menu (@pxref{Pop-Up Menus}), with @var{doc} as its documentation string.  @var{symbol} should not be quoted."
msgstr "@var{symbol}が非@code{nil}なら、それはシンボルである。その場合、このマクロはドキュメント文字列@var{doc}をもつ、メニューをポップアップ(@ref{Pop-Up Menus}を参照)する関数として@var{symbol}を定義する。@var{symbol}はクォートしないこと。"

#. type: defmac
#: original_texis/keymaps.texi:2866
msgid "Regardless of the value of @var{symbol}, if @var{maps} is a keymap, the menu is added to that keymap, as a top-level menu for the menu bar (@pxref{Menu Bar}).  It can also be a list of keymaps, in which case the menu is added separately to each of those keymaps."
msgstr "@var{symbol}の値とは関係なく、@var{maps}がキーマップならメニューはメニューバーのトップレベルのメニュー(@ref{Menu Bar}を参照)として@var{maps}に追加される。これにはキーマップのリストも指定でき、その場合メニューはそれらのキーマップに個別に追加される。"

#. type: defmac
#: original_texis/keymaps.texi:2870
msgid "The first element of @var{menu} must be a string, which serves as the menu label.  It may be followed by any number of the following keyword-argument pairs:"
msgstr "@var{menu}の最初の要素は文字列でなければならず、それはメニューラベルの役割をもつ。値には以下のキーワード/引数ペアーが任意の個数続くかもしれない:"

#. type: item
#: original_texis/keymaps.texi:2872
#, no-wrap
msgid ":filter @var{function}"
msgstr ":filter @var{function}"

#. type: table
#: original_texis/keymaps.texi:2876
msgid "@var{function} must be a function which, if called with one argument---the list of the other menu items---returns the actual items to be displayed in the menu."
msgstr "@var{function}は1つの引数(他のメニューアイテムのリスト)で呼び出される関数でなければならず、メニュー内に表示される実際のアイテムをリターンする。"

#. type: item
#: original_texis/keymaps.texi:2877 original_texis/keymaps.texi:2924
#, no-wrap
msgid ":visible @var{include}"
msgstr ":visible @var{include}"

#. type: table
#: original_texis/keymaps.texi:2881
msgid "@var{include} is an expression; if it evaluates to @code{nil}, the menu is made invisible.  @code{:included} is an alias for @code{:visible}."
msgstr "@var{include}には式を指定する。その式が@code{nil}に評価されるとメニューは不可視になる。@code{:included}は@code{:visible}にたいするエイリアス。"

#. type: item
#: original_texis/keymaps.texi:2882 original_texis/keymaps.texi:2920
#, no-wrap
msgid ":active @var{enable}"
msgstr ":active @var{enable}"

#. type: table
#: original_texis/keymaps.texi:2885
msgid "@var{enable} is an expression; if it evaluates to @code{nil}, the menu is not selectable.  @code{:enable} is an alias for @code{:active}."
msgstr "@var{enable}は式を指定する。その式が@code{nil}に評価されるとメニューは選択不可になる。@code{:enable}は@code{:active}にたいするエイリアス。"

#. type: defmac
#: original_texis/keymaps.texi:2888
msgid "The remaining elements in @var{menu} are menu items."
msgstr "@var{menu}内の残りの要素はメニューアイテム。"

#. type: defmac
#: original_texis/keymaps.texi:2894
msgid "A menu item can be a vector of three elements, @code{[@var{name} @var{callback} @var{enable}]}.  @var{name} is the menu item name (a string).  @var{callback} is a command to run, or an expression to evaluate, when the item is chosen.  @var{enable} is an expression; if it evaluates to @code{nil}, the item is disabled for selection."
msgstr "メニューアイテムには3要素のベクター@code{[@var{name} @var{callback} @var{enable}]}を指定できる。ここで@var{name}はメニューアイテム名(文字列)、@var{callback}はアイテム選択時に実行するコマンドか評価される式。@var{enable}が式で@code{nil}に評価されると、そのアイテムの選択は無効になる。"

#. type: defmac
#: original_texis/keymaps.texi:2896
msgid "Alternatively, a menu item may have the form:"
msgstr "かわりにメニューアイテムは以下の形式をもつことができる:"

#. type: smallexample
#: original_texis/keymaps.texi:2899
#, no-wrap
msgid "   [ @var{name} @var{callback} [ @var{keyword} @var{arg} ]... ]\n"
msgstr "   [ @var{name} @var{callback} [ @var{keyword} @var{arg} ]... ]\n"

#. type: defmac
#: original_texis/keymaps.texi:2905
msgid "where @var{name} and @var{callback} have the same meanings as above, and each optional @var{keyword} and @var{arg} pair should be one of the following:"
msgstr "ここで@var{name}と@var{callback}は上記と同じ意味をもち、オプションの@var{keyword}と@var{arg}の各ペアーは以下のいずれかである:"

#. type: item
#: original_texis/keymaps.texi:2907
#, no-wrap
msgid ":keys @var{keys}"
msgstr ":keys @var{keys}"

#. type: table
#: original_texis/keymaps.texi:2913
msgid "@var{keys} is a keyboard equivalent to the menu item (a string).  This is normally not needed, as keyboard equivalents are computed automatically.  @var{keys} is expanded with @code{substitute-command-keys} before it is displayed (@pxref{Keys in Documentation})."
msgstr "@var{keys}はメニューアイテムにたいする等価なキーボード入力(文字列)である。等価なキーボード入力は自動的に計算されるので通常は必要ない。@var{keys}は表示前に@code{substitute-command-keys}により展開される(@ref{Keys in Documentation}を参照)。"

#. type: item
#: original_texis/keymaps.texi:2914
#, no-wrap
msgid ":key-sequence @var{keys}"
msgstr ":key-sequence @var{keys}"

#. type: table
#: original_texis/keymaps.texi:2919
msgid "@var{keys} is a hint for speeding up Emacs's first display of the menu.  It should be @code{nil} if you know that the menu item has no keyboard equivalent; otherwise it should be a string or vector specifying a keyboard equivalent for the menu item."
msgstr "@var{keys}は最初にメニューを表示される際に、Emacsを高速化するヒントになる。等価なキーボード入力がないことが既知なら@code{nil}を指定すること。それ以外ならメニューアイテムにたいする等価なキーボード入力を指定する文字列かベクターを指定すること。"

#. type: table
#: original_texis/keymaps.texi:2923
msgid "@var{enable} is an expression; if it evaluates to @code{nil}, the item is make unselectable..  @code{:enable} is an alias for @code{:active}."
msgstr "@var{enable}には式を指定する。その式が@code{nil}に評価されるとアイテムは選択不可になる。@var{enable}は@code{:active}にたいするエイリアス。"

#. type: table
#: original_texis/keymaps.texi:2928
msgid "@var{include} is an expression; if it evaluates to @code{nil}, the item is made invisible.  @code{:included} is an alias for @code{:visible}."
msgstr "@var{include}には式を指定する。その式が@code{nil}に評価されるとアイテムは不可視になる。@code{:included}は@code{:visible}にたいするエイリアス。"

#. type: item
#: original_texis/keymaps.texi:2929
#, no-wrap
msgid ":label @var{form}"
msgstr ":label @var{form}"

#. type: table
#: original_texis/keymaps.texi:2932
msgid "@var{form} is an expression that is evaluated to obtain a value which serves as the menu item's label (the default is @var{name})."
msgstr "@var{form}はメニューアイテムのラベル(デフォルトは@var{name})の役目をもつ値を取得するために表示される式である。"

#. type: item
#: original_texis/keymaps.texi:2933
#, no-wrap
msgid ":suffix @var{form}"
msgstr ":suffix @var{form}"

#. type: table
#: original_texis/keymaps.texi:2936
msgid "@var{form} is an expression that is dynamically evaluated and whose value is concatenated with the menu entry's label."
msgstr "@var{form}は動的に評価される式であり、値はメニューエントリーのラベルに結合される。"

#. type: item
#: original_texis/keymaps.texi:2937
#, no-wrap
msgid ":style @var{style}"
msgstr ":style @var{style}"

#. type: table
#: original_texis/keymaps.texi:2941
msgid "@var{style} is a symbol describing the type of menu item; it should be @code{toggle} (a checkbox), or @code{radio} (a radio button), or anything else (meaning an ordinary menu item)."
msgstr "@var{style}はメニューアイテムの型を記述するシンボルであり、@code{toggle}(チェックボックス)、@code{radio}(ラジオボタン)、またはそれ以外(通常のメニューアイテムであることを意味する)のいずれかである。"

#. type: item
#: original_texis/keymaps.texi:2942
#, no-wrap
msgid ":selected @var{selected}"
msgstr ":selected @var{selected}"

#. type: table
#: original_texis/keymaps.texi:2945
msgid "@var{selected} is an expression; the checkbox or radio button is selected whenever the expression's value is non-@code{nil}."
msgstr "@var{selected}には式を指定し、その式の値が非@code{nil}のときはチェックボックスまたはラジオボタンが選択状態になる。"

#. type: table
#: original_texis/keymaps.texi:2948
msgid "@var{help} is a string describing the menu item."
msgstr "@var{help}はメニューアイテムを説明する文字列。"

#. type: defmac
#: original_texis/keymaps.texi:2953
msgid "Alternatively, a menu item can be a string.  Then that string appears in the menu as unselectable text.  A string consisting of dashes is displayed as a separator (@pxref{Menu Separators})."
msgstr "かわりにメニューアイテムに文字列を指定できる。その場合には文字列は選択不可なテキストとしてメニューに表示される。ダッシュから構成される文字列はセパレーターとして表示される(@ref{Menu Separators}を参照)"

#. type: defmac
#: original_texis/keymaps.texi:2956
msgid "Alternatively, a menu item can be a list with the same format as @var{menu}.  This is a submenu."
msgstr "かわりにメニューアイテムに@var{menu}と同じフォーマットのリストを指定できる。これはサブメニューとなる。"

#. type: Plain text
#: original_texis/keymaps.texi:2960
msgid "Here is an example of using @code{easy-menu-define} to define a menu similar to the one defined in the example in @ref{Menu Bar}:"
msgstr "以下は@code{easy-menu-define}を使用して@ref{Menu Bar}内で定義したメニューと同等なメニューを定義する例:"

#. type: example
#: original_texis/keymaps.texi:2967
#, no-wrap
msgid ""
"(easy-menu-define words-menu global-map\n"
"  \"Menu for word navigation commands.\"\n"
"  '(\"Words\"\n"
"     [\"Forward word\" forward-word]\n"
"     [\"Backward word\" backward-word]))\n"
msgstr ""
"(easy-menu-define words-menu global-map\n"
"  \"単語単位コマンドにたいするメニュー\"\n"
"  '(\"Words\"\n"
"     [\"Forward word\" forward-word]\n"
"     [\"Backward word\" backward-word]))\n"
