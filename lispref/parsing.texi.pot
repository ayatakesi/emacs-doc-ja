# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2024-06-30 06:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: original_texis/parsing.texi:5 original_texis/parsing.texi:6
#, no-wrap
msgid "Parsing Program Source"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:7
#, no-wrap
msgid "parsing program source"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:9
#, no-wrap
msgid "syntax tree, from parsing program source"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:16
msgid ""
"Emacs provides various ways to parse program source text and produce a "
"@dfn{syntax tree}.  In a syntax tree, text is no longer considered a "
"one-dimensional stream of characters, but a structured tree of nodes, where "
"each node represents a piece of text.  Thus, a syntax tree can enable "
"interesting features like precise fontification, indentation, navigation, "
"structured editing, etc."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:20
msgid ""
"Emacs has a simple facility for parsing balanced expressions (@pxref{Parsing "
"Expressions}).  There is also the SMIE library for generic navigation and "
"indentation (@pxref{SMIE})."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:26
msgid ""
"In addition to those, Emacs also provides integration with "
"@uref{https://tree-sitter.github.io/tree-sitter, the tree-sitter library} if "
"support for it was compiled in.  The tree-sitter library implements an "
"incremental parser and has support for a wide range of programming "
"languages."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:27
#, no-wrap
msgid "treesit-available-p"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:30
msgid ""
"This function returns non-@code{nil} if tree-sitter features are available "
"for the current Emacs session."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:41
msgid ""
"To be able to parse the program source using the tree-sitter library and "
"access the syntax tree of the program, a Lisp program needs to load a "
"language grammar library, and create a parser for that language and the "
"current buffer.  After that, the Lisp program can query the parser about "
"specific nodes of the syntax tree.  Then, it can access various kinds of "
"information about each node, and search for nodes using a powerful "
"pattern-matching syntax.  This chapter explains how to do all this, and also "
"how a Lisp program can work with source files that mix multiple programming "
"languages."
msgstr ""

#. type: node
#: original_texis/parsing.texi:51 original_texis/parsing.texi:53
#, no-wrap
msgid "Language Grammar"
msgstr ""

#. type: menuentry
#: original_texis/parsing.texi:51
msgid "Loading tree-sitter language grammar."
msgstr ""

#. type: node
#: original_texis/parsing.texi:51 original_texis/parsing.texi:387
#, no-wrap
msgid "Using Parser"
msgstr ""

#. type: menuentry
#: original_texis/parsing.texi:51
msgid "Introduction to parsers."
msgstr ""

#. type: section
#: original_texis/parsing.texi:51 original_texis/parsing.texi:533
#: original_texis/parsing.texi:534
#, no-wrap
msgid "Retrieving Nodes"
msgstr ""

#. type: menuentry
#: original_texis/parsing.texi:51
msgid "Retrieving nodes from a syntax tree."
msgstr ""

#. type: section
#: original_texis/parsing.texi:51 original_texis/parsing.texi:895
#: original_texis/parsing.texi:896
#, no-wrap
msgid "Accessing Node Information"
msgstr ""

#. type: menuentry
#: original_texis/parsing.texi:51
msgid "Accessing node information."
msgstr ""

#. type: node
#: original_texis/parsing.texi:51 original_texis/parsing.texi:1032
#, no-wrap
msgid "Pattern Matching"
msgstr ""

#. type: menuentry
#: original_texis/parsing.texi:51
msgid "Pattern matching with query patterns."
msgstr ""

#. type: node
#: original_texis/parsing.texi:51 original_texis/parsing.texi:1437
#, no-wrap
msgid "Multiple Languages"
msgstr ""

#. type: menuentry
#: original_texis/parsing.texi:51
msgid "Parse text written in multiple languages."
msgstr ""

#. type: node
#: original_texis/parsing.texi:51 original_texis/parsing.texi:1700
#, no-wrap
msgid "Tree-sitter Major Modes"
msgstr ""

#. type: menuentry
#: original_texis/parsing.texi:51
msgid "Develop major modes using tree-sitter."
msgstr ""

#. type: node
#: original_texis/parsing.texi:51 original_texis/parsing.texi:1841
#, no-wrap
msgid "Tree-sitter C API"
msgstr ""

#. type: menuentry
#: original_texis/parsing.texi:51
msgid "Compare the C API and the ELisp API."
msgstr ""

#. type: section
#: original_texis/parsing.texi:54
#, no-wrap
msgid "Tree-sitter Language Grammar"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:55
#, no-wrap
msgid "language grammar, for tree-sitter"
msgstr ""

#. type: heading
#: original_texis/parsing.texi:57
#, no-wrap
msgid "Loading a language grammar"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:58
#, no-wrap
msgid "loading language grammar for tree-sitter"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:60
#, no-wrap
msgid "language argument, for tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:66
msgid ""
"Tree-sitter relies on language grammar to parse text in that language.  In "
"Emacs, a language grammar is represented by a symbol.  For example, the C "
"language grammar is represented as the symbol @code{c}, and @code{c} can be "
"passed to tree-sitter functions as the @var{language} argument."
msgstr ""

#. type: vindex
#: original_texis/parsing.texi:67
#, no-wrap
msgid "treesit-extra-load-path"
msgstr ""

#. type: vindex
#: original_texis/parsing.texi:68
#, no-wrap
msgid "treesit-load-language-error"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:73
msgid ""
"Tree-sitter language grammars are distributed as dynamic libraries.  In "
"order to use a language grammar in Emacs, you need to make sure that the "
"dynamic library is installed on the system.  Emacs looks for language "
"grammars in several places, in the following order:"
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:78
msgid ""
"first, in the list of directories specified by the variable "
"@code{treesit-extra-load-path};"
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:81
msgid ""
"then, in the @file{tree-sitter} subdirectory of the directory specified by "
"@code{user-emacs-directory} (@pxref{Init File});"
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:83
msgid "and finally, in the system's default locations for dynamic libraries."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:87
msgid ""
"In each of these directories, Emacs looks for a file with file-name "
"extensions specified by the variable @code{dynamic-library-suffixes}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:91
msgid ""
"If Emacs cannot find the library or has problems loading it, Emacs signals "
"the @code{treesit-load-language-error} error.  The data of that signal could "
"be one of the following:"
msgstr ""

#. type: item
#: original_texis/parsing.texi:93
#, no-wrap
msgid "(not-found @var{error-msg} @dots{})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:95
msgid "This means that Emacs could not find the language grammar library."
msgstr ""

#. type: item
#: original_texis/parsing.texi:95
#, no-wrap
msgid "(symbol-error @var{error-msg})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:98
msgid ""
"This means that Emacs could not find in the library the expected function "
"that every language grammar library should export."
msgstr ""

#. type: item
#: original_texis/parsing.texi:98
#, no-wrap
msgid "(version-mismatch @var{error-msg})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:101
msgid ""
"This means that the version of the language grammar library is incompatible "
"with that of the tree-sitter library."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:106
msgid ""
"In all of these cases, @var{error-msg} might provide additional details "
"about the failure."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:107
#, no-wrap
msgid "treesit-language-available-p language &optional detail"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:110
msgid ""
"This function returns non-@code{nil} if the language grammar for "
"@var{language} exists and can be loaded."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:115
msgid ""
"If @var{detail} is non-@code{nil}, return @code{(t . nil)} when "
"@var{language} is available, and @code{(nil . @var{data})} when it's "
"unavailable.  @var{data} is the signal data of "
"@code{treesit-load-language-error}."
msgstr ""

#. type: vindex
#: original_texis/parsing.texi:117
#, no-wrap
msgid "treesit-load-name-override-list"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:124
msgid ""
"By convention, the file name of the dynamic library for @var{language} is "
"@file{libtree-sitter-@var{language}.@var{ext}}, where @var{ext} is the "
"system-specific extension for dynamic libraries.  Also by convention, the "
"function provided by that library is named "
"@code{tree_sitter_@var{language}}.  If a language grammar library doesn't "
"follow this convention, you should add an entry"
msgstr ""

#. type: example
#: original_texis/parsing.texi:127
#, no-wrap
msgid "(@var{language} @var{library-base-name} @var{function-name})\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:134
msgid ""
"to the list in the variable @code{treesit-load-name-override-list}, where "
"@var{library-base-name} is the basename of the dynamic library's file name "
"(usually, @file{libtree-sitter-@var{language}}), and @var{function-name} is "
"the function provided by the library (usually, "
"@code{tree_sitter_@var{language}}).  For example,"
msgstr ""

#. type: example
#: original_texis/parsing.texi:137
#, no-wrap
msgid "(cool-lang \"libtree-sitter-coool\" \"tree_sitter_cooool\")\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:142
msgid "for a language that considers itself too ``cool'' to abide by conventions."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:143
#, no-wrap
msgid "language grammar version, compatibility"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:144
#, no-wrap
msgid "treesit-library-abi-version &optional min-compatible"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:154
msgid ""
"This function returns the version of the language grammar Application Binary "
"Interface (@acronym{ABI}) supported by the tree-sitter library.  By default, "
"it returns the latest ABI version supported by the library, but if "
"@var{min-compatible} is non-@code{nil}, it returns the oldest ABI version "
"which the library still can support.  Language grammar libraries must be "
"built for ABI versions between the oldest and the latest versions supported "
"by the tree-sitter library, otherwise the library will be unable to load "
"them."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:156
#, no-wrap
msgid "treesit-language-abi-version language"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:160
msgid ""
"This function returns the @acronym{ABI} version of the language grammar "
"library loaded by Emacs for @var{language}.  If @var{language} is "
"unavailable, this function returns @code{nil}."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:162
#, no-wrap
msgid "Concrete syntax tree"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:163
#, no-wrap
msgid "syntax tree, concrete"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:168
msgid ""
"A syntax tree is what a parser generates.  In a syntax tree, each node "
"represents a piece of text, and is connected to each other by a parent-child "
"relationship.  For example, if the source text is"
msgstr ""

#. type: example
#: original_texis/parsing.texi:171
#, no-wrap
msgid "1 + 2\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:175
msgid "its syntax tree could be"
msgstr ""

#. type: group
#: original_texis/parsing.texi:189
#, no-wrap
msgid ""
"                  +--------------+\n"
"                  | root \"1 + 2\" |\n"
"                  +--------------+\n"
"                         |\n"
"        +--------------------------------+\n"
"        |       expression \"1 + 2\"       |\n"
"        +--------------------------------+\n"
"           |             |            |\n"
"+------------+   +--------------+   +------------+\n"
"| number \"1\" |   | operator \"+\" |   | number \"2\" |\n"
"+------------+   +--------------+   +------------+\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:193
msgid "We can also represent it as an s-expression:"
msgstr ""

#. type: example
#: original_texis/parsing.texi:196
#, no-wrap
msgid "(root (expression (number) (operator) (number)))\n"
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:198
#, no-wrap
msgid "Node types"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:199
#, no-wrap
msgid "node types, in a syntax tree"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:201
#, no-wrap
msgid "type of node, tree-sitter"
msgstr ""

#. type: anchor{#1}
#: original_texis/parsing.texi:203
msgid "tree-sitter node type"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:203
#, no-wrap
msgid "named node, tree-sitter"
msgstr ""

#. type: anchor{#1}
#: original_texis/parsing.texi:205
msgid "tree-sitter named node"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:205
#, no-wrap
msgid "anonymous node, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:213
msgid ""
"Names like @code{root}, @code{expression}, @code{number}, and "
"@code{operator} specify the @dfn{type} of the nodes.  However, not all nodes "
"in a syntax tree have a type.  Nodes that don't have a type are known as "
"@dfn{anonymous nodes}, and nodes with a type are @dfn{named nodes}.  "
"Anonymous nodes are tokens with fixed spellings, including punctuation "
"characters like bracket @samp{]}, and keywords like @code{return}."
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:214
#, no-wrap
msgid "Field names"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:216
#, no-wrap
msgid "field name, tree-sitter"
msgstr ""

#. type: anchor{#1}
#: original_texis/parsing.texi:217 original_texis/parsing.texi:223
#, no-wrap
msgid "tree-sitter node field name"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:223
msgid ""
"To make the syntax tree easier to analyze, many language grammar assign "
"@dfn{field names} to child nodes.  For example, a @code{function_definition} "
"node could have a @code{declarator} and a @code{body}:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:229
#, no-wrap
msgid ""
"(function_definition\n"
" declarator: (declaration)\n"
" body: (compound_statement))\n"
msgstr ""

#. type: heading
#: original_texis/parsing.texi:232
#, no-wrap
msgid "Exploring the syntax tree"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:233
#, no-wrap
msgid "explore tree-sitter syntax tree"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:234
#, no-wrap
msgid "inspection of tree-sitter parse tree nodes"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:241
msgid ""
"To aid in understanding the syntax of a language and in debugging Lisp "
"programs that use the syntax tree, Emacs provides an ``explore'' mode, which "
"displays the syntax tree of the source in the current buffer in real time.  "
"Emacs also comes with an ``inspect mode'', which displays information of the "
"nodes at point in the mode-line."
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:242
#, no-wrap
msgid "Command treesit-explore-mode"
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:248
msgid ""
"This mode pops up a window displaying the syntax tree of the source in the "
"current buffer.  Selecting text in the source buffer highlights the "
"corresponding nodes in the syntax tree display.  Clicking on nodes in the "
"syntax tree highlights the corresponding text in the source buffer."
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:250
#, no-wrap
msgid "Command treesit-inspect-mode"
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:253
msgid ""
"This minor mode displays on the mode-line the node that @emph{starts} at "
"point.  For example, the mode-line can display"
msgstr ""

#. type: example
#: original_texis/parsing.texi:256
#, no-wrap
msgid "@var{parent} @var{field}: (@var{node} (@var{child} (@dots{})))\n"
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:263
msgid ""
"where @var{node}, @var{child}, etc., are nodes which begin at point.  "
"@var{parent} is the parent of @var{node}.  @var{node} is displayed in a bold "
"typeface.  @var{field-name}s are field names of @var{node} and of "
"@var{child}, etc."
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:267
msgid ""
"If no node starts at point, i.e., point is in the middle of a node, then the "
"mode line displays the earliest node that spans point, and its immediate "
"parent."
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:270
msgid ""
"This minor mode doesn't create parsers on its own.  It uses the first parser "
"in @code{(treesit-parser-list)} (@pxref{Using Parser})."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:272
#, no-wrap
msgid "Reading the grammar definition"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:273
#, no-wrap
msgid "reading grammar definition, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:279
msgid ""
"Authors of language grammars define the @dfn{grammar} of a programming "
"language, which determines how a parser constructs a concrete syntax tree "
"out of the program text.  In order to use the syntax tree effectively, you "
"need to consult the @dfn{grammar file}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:285
msgid ""
"The grammar file is usually @file{grammar.js} in a language grammar's "
"project repository.  The link to a language grammar's home page can be found "
"on @uref{https://tree-sitter.github.io/tree-sitter, tree-sitter's homepage}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:288
msgid ""
"The grammar definition is written in JavaScript.  For example, the rule "
"matching a @code{function_definition} node may look like"
msgstr ""

#. type: group
#: original_texis/parsing.texi:296
#, no-wrap
msgid ""
"function_definition: $ => seq(\n"
"  $.declaration_specifiers,\n"
"  field('declarator', $.declaration),\n"
"  field('body', $.compound_statement)\n"
")\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:306
msgid ""
"The rules are represented by functions that take a single argument @var{$}, "
"representing the whole grammar.  The function itself is constructed by other "
"functions: the @code{seq} function puts together a sequence of children; the "
"@code{field} function annotates a child with a field name.  If we write the "
"above definition in the so-called @dfn{Backus-Naur Form} (@acronym{BNF}) "
"syntax, it would look like"
msgstr ""

#. type: group
#: original_texis/parsing.texi:311
#, no-wrap
msgid ""
"function_definition :=\n"
"  <declaration_specifiers> <declaration> <compound_statement>\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:316
msgid "and the node returned by the parser would look like"
msgstr ""

#. type: group
#: original_texis/parsing.texi:323
#, no-wrap
msgid ""
"(function_definition\n"
"  (declaration_specifier)\n"
"  declarator: (declaration)\n"
"  body: (compound_statement))\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:328
msgid ""
"Below is a list of functions that one can see in a grammar definition.  Each "
"function takes other rules as arguments and returns a new rule."
msgstr ""

#. type: item
#: original_texis/parsing.texi:330
#, no-wrap
msgid "seq(@var{rule1}, @var{rule2}, @dots{})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:332
msgid "matches each rule one after another."
msgstr ""

#. type: item
#: original_texis/parsing.texi:332
#, no-wrap
msgid "choice(@var{rule1}, @var{rule2}, @dots{})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:334
msgid "matches one of the rules in its arguments."
msgstr ""

#. type: item
#: original_texis/parsing.texi:334
#, no-wrap
msgid "repeat(@var{rule})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:337
msgid ""
"matches @var{rule} @emph{zero or more} times.  This is like the @samp{*} "
"operator in regular expressions."
msgstr ""

#. type: item
#: original_texis/parsing.texi:337
#, no-wrap
msgid "repeat1(@var{rule})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:340
msgid ""
"matches @var{rule} @emph{one or more} times.  This is like the @samp{+} "
"operator in regular expressions."
msgstr ""

#. type: item
#: original_texis/parsing.texi:340
#, no-wrap
msgid "optional(@var{rule})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:343
msgid ""
"matches @var{rule} @emph{zero or one} times.  This is like the @samp{?} "
"operator in regular expressions."
msgstr ""

#. type: item
#: original_texis/parsing.texi:343
#, no-wrap
msgid "field(@var{name}, @var{rule})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:345
msgid "assigns field name @var{name} to the child node matched by @var{rule}."
msgstr ""

#. type: item
#: original_texis/parsing.texi:345
#, no-wrap
msgid "alias(@var{rule}, @var{alias})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:348
msgid ""
"makes nodes matched by @var{rule} appear as @var{alias} in the syntax tree "
"generated by the parser.  For example,"
msgstr ""

#. type: example
#: original_texis/parsing.texi:351
#, no-wrap
msgid "alias(preprocessor_call_exp, call_expression)\n"
msgstr ""

#. type: table
#: original_texis/parsing.texi:356
msgid ""
"makes any node matched by @code{preprocessor_call_exp} appear as "
"@code{call_expression}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:360
msgid ""
"Below are grammar functions of lesser importance for reading a language "
"grammar."
msgstr ""

#. type: item
#: original_texis/parsing.texi:362
#, no-wrap
msgid "token(@var{rule})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:367
msgid ""
"marks @var{rule} to produce a single leaf node.  That is, instead of "
"generating a parent node with individual child nodes under it, everything is "
"combined into a single leaf node.  @xref{Retrieving Nodes}."
msgstr ""

#. type: item
#: original_texis/parsing.texi:367
#, no-wrap
msgid "token.immediate(@var{rule})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:371
msgid ""
"Normally, grammar rules ignore preceding whitespace; this changes @var{rule} "
"to match only when there is no preceding whitespace."
msgstr ""

#. type: item
#: original_texis/parsing.texi:371
#, no-wrap
msgid "prec(@var{n}, @var{rule})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:373
msgid "gives @var{rule} the level-@var{n} precedence."
msgstr ""

#. type: item
#: original_texis/parsing.texi:373
#, no-wrap
msgid "prec.left([@var{n},] @var{rule})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:375
msgid "marks @var{rule} as left-associative, optionally with level @var{n}."
msgstr ""

#. type: item
#: original_texis/parsing.texi:375
#, no-wrap
msgid "prec.right([@var{n},] @var{rule})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:377
msgid "marks @var{rule} as right-associative, optionally with level @var{n}."
msgstr ""

#. type: item
#: original_texis/parsing.texi:377
#, no-wrap
msgid "prec.dynamic(@var{n}, @var{rule})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:380
msgid "this is like @code{prec}, but the precedence is applied at runtime instead."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:386
msgid ""
"The documentation of the tree-sitter project has "
"@uref{https://tree-sitter.github.io/tree-sitter/creating-parsers, more about "
"writing a grammar}.  Read especially ``The Grammar DSL'' section."
msgstr ""

#. type: section
#: original_texis/parsing.texi:388
#, no-wrap
msgid "Using Tree-sitter Parser"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:389
#, no-wrap
msgid "tree-sitter parser, using"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:395
msgid ""
"This section describes how to create and configure a tree-sitter parser.  In "
"Emacs, each tree-sitter parser is associated with a buffer.  As the user "
"edits the buffer, the associated parser and syntax tree are automatically "
"kept up-to-date."
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:396
#, no-wrap
msgid "treesit-max-buffer-size"
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:400
msgid ""
"This variable contains the maximum size of buffers in which tree-sitter can "
"be activated.  Major modes should check this value when deciding whether to "
"enable tree-sitter features."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:402
#, no-wrap
msgid "creating tree-sitter parsers"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:403
#, no-wrap
msgid "tree-sitter parser, creating"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:404
#, no-wrap
msgid "treesit-parser-create language &optional buffer no-reuse"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:408
msgid ""
"Create a parser for the specified @var{buffer} and @var{language} "
"(@pxref{Language Grammar}).  If @var{buffer} is omitted or @code{nil}, it "
"stands for the current buffer."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:412
msgid ""
"By default, this function reuses a parser if one already exists for "
"@var{language} in @var{buffer}, but if @var{no-reuse} is non-@code{nil}, "
"this function always creates a new parser."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:419
msgid ""
"If that buffer is an indirect buffer, its base buffer is used instead.  That "
"is, indirect buffers use their base buffer's parsers.  If the base buffer is "
"narrowed, an indirect buffer might not be able to retrieve information of "
"the portion of the buffer text that is invisible in the base buffer.  Lisp "
"programs should widen as necessary should they want to use a parser in an "
"indirect buffer."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:422
msgid "Given a parser, we can query information about it."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:423
#, no-wrap
msgid "treesit-parser-buffer parser"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:425
msgid "This function returns the buffer associated with @var{parser}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:427
#, no-wrap
msgid "treesit-parser-language parser"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:429
msgid "This function returns the language used by @var{parser}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:431
#, no-wrap
msgid "treesit-parser-p object"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:434
msgid ""
"This function checks if @var{object} is a tree-sitter parser, and returns "
"non-@code{nil} if it is, and @code{nil} otherwise."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:442
msgid ""
"There is no need to explicitly parse a buffer, because parsing is done "
"automatically and lazily.  A parser only parses when a Lisp program queries "
"for a node in its syntax tree.  Therefore, when a parser is first created, "
"it doesn't parse the buffer; it waits until the Lisp program queries for a "
"node for the first time.  Similarly, when some change is made in the buffer, "
"a parser doesn't re-parse immediately."
msgstr ""

#. type: vindex
#: original_texis/parsing.texi:443
#, no-wrap
msgid "treesit-buffer-too-large"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:448
msgid ""
"When a parser does parse, it checks for the size of the buffer.  Tree-sitter "
"can only handle buffers no larger than about 4GB@.  If the size exceeds "
"that, Emacs signals the @code{treesit-buffer-too-large} error with signal "
"data being the buffer size."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:453
msgid ""
"Once a parser is created, Emacs automatically adds it to the internal parser "
"list.  Every time a change is made to the buffer, Emacs updates parsers in "
"this list so they can update their syntax tree incrementally."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:454
#, no-wrap
msgid "treesit-parser-list &optional buffer"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:459
msgid ""
"This function returns the parser list of @var{buffer}.  If @var{buffer} is "
"@code{nil} or omitted, it defaults to the current buffer.  If that buffer is "
"an indirect buffer, its base buffer is used instead.  That is, indirect "
"buffers use their base buffer's parsers."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:461
#, no-wrap
msgid "treesit-parser-delete parser"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:463
msgid "This function deletes @var{parser}."
msgstr ""

#. type: anchor{#1}
#: original_texis/parsing.texi:465 original_texis/parsing.texi:475
#, no-wrap
msgid "tree-sitter narrowing"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:475
msgid ""
"Normally, a parser ``sees'' the whole buffer, but when the buffer is "
"narrowed (@pxref{Narrowing}), the parser will only see the accessible "
"portion of the buffer.  As far as the parser can tell, the hidden region was "
"deleted.  When the buffer is later widened, the parser thinks text is "
"inserted at the beginning and at the end.  Although parsers respect "
"narrowing, modes should not use narrowing as a means to handle a "
"multi-language buffer; instead, set the ranges in which the parser should "
"operate.  @xref{Multiple Languages}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:480
msgid ""
"Because a parser parses lazily, when the user or a Lisp program narrows the "
"buffer, the parser is not affected immediately; as long as the mode doesn't "
"query for a node while the buffer is narrowed, the parser is oblivious of "
"the narrowing."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:481
#, no-wrap
msgid "tree-sitter parse string"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:482
#, no-wrap
msgid "parse string, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:486
msgid ""
"Besides creating a parser for a buffer, a Lisp program can also parse a "
"string.  Unlike a buffer, parsing a string is a one-off operation, and there "
"is no way to update the result."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:487
#, no-wrap
msgid "treesit-parse-string string language"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:490
msgid ""
"This function parses @var{string} using @var{language}, and returns the root "
"node of the generated syntax tree."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:492
#, no-wrap
msgid "Be notified by changes to the parse tree"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:493
#, no-wrap
msgid "update callback, for tree-sitter parse-tree"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:494
#, no-wrap
msgid "after-change notifier, for tree-sitter parse-tree"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:495
#, no-wrap
msgid "tree-sitter parse-tree, update and after-change callback"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:496
#, no-wrap
msgid "notifiers, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:503
msgid ""
"A Lisp program might want to be notified of text affected by incremental "
"parsing.  For example, inserting a comment-closing token converts text "
"before that token into a comment.  Even though the text is not directly "
"edited, it is deemed to be ``changed'' nevertheless."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:510
msgid ""
"Emacs lets a Lisp program register callback functions (a.k.a.@: "
"@dfn{notifiers}) for these kinds of changes.  A notifier function takes two "
"arguments: @var{ranges} and @var{parser}.  @var{ranges} is a list of cons "
"cells of the form @w{@code{(@var{start} . @var{end})}}, where @var{start} "
"and @var{end} mark the start and the end positions of a range.  @var{parser} "
"is the parser issuing the notification."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:516
msgid ""
"Every time a parser reparses a buffer, it compares the old and new "
"parse-tree, computes the ranges in which nodes have changed, and passes the "
"ranges to notifier functions.  Note that the initial parse is also "
"considered a ``change'', so notifier functions are called on the initial "
"parse, with range being the whole buffer."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:517
#, no-wrap
msgid "treesit-parser-add-notifier parser function"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:521
msgid ""
"This function adds @var{function} to @var{parser}'s list of after-change "
"notifier functions.  @var{function} must be a function symbol, not a lambda "
"function (@pxref{Anonymous Functions})."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:523
#, no-wrap
msgid "treesit-parser-remove-notifier parser function"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:527
msgid ""
"This function removes @var{function} from the list of @var{parser}'s "
"after-change notifier functions.  @var{function} must be a function symbol, "
"rather than a lambda function."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:529
#, no-wrap
msgid "treesit-parser-notifiers parser"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:531
msgid "This function returns the list of @var{parser}'s notifier functions."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:535
#, no-wrap
msgid "retrieve node, tree-sitter"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:536
#, no-wrap
msgid "tree-sitter, find node"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:537
#, no-wrap
msgid "get node, tree-sitter"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:539
#, no-wrap
msgid "terminology, for tree-sitter functions"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:542
msgid ""
"Here are some terms and conventions we use when documenting tree-sitter "
"functions."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:552
msgid ""
"A node in a syntax tree spans some portion of the program text in the "
"buffer.  We say that a node is ``smaller'' or ``larger'' than another if it "
"spans, respectively, a smaller or larger portion of buffer text than the "
"other node.  Since nodes that are deeper (``lower'') in the tree are "
"children of the nodes that are ``higher'' in the tree, it follows that a "
"lower node will always be smaller than a node that is higher in the node "
"hierarchy.  A node that is higher up in the syntax tree contains one or more "
"smaller nodes as its children, and therefore spans a larger portion of "
"buffer text."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:557
msgid ""
"When a function cannot find a node, it returns @code{nil}.  For convenience, "
"all functions that take a node as argument and return a node, also accept "
"the node argument of @code{nil} and in that case just return @code{nil}."
msgstr ""

#. type: vindex
#: original_texis/parsing.texi:558
#, no-wrap
msgid "treesit-node-outdated"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:562
msgid ""
"Nodes are not automatically updated when the associated buffer is modified, "
"and there is no way to update a node once it is retrieved.  Using an "
"outdated node signals the @code{treesit-node-outdated} error."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:563
#, no-wrap
msgid "Retrieving nodes from syntax tree"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:564
#, no-wrap
msgid "retrieving tree-sitter nodes"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:565
#, no-wrap
msgid "syntax tree, retrieving nodes"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:567
#, no-wrap
msgid "leaf node, of tree-sitter parse tree"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:568
#, no-wrap
msgid "tree-sitter parse tree, leaf node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:569
#, no-wrap
msgid "treesit-node-at pos &optional parser-or-lang named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:572
msgid ""
"This function returns a @dfn{leaf} node at buffer position @var{pos}.  A "
"leaf node is a node that doesn't have any child nodes."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:576
msgid ""
"This function tries to return a node whose span covers @var{pos}: the node's "
"beginning position is less than or equal to @var{pos}, and the node's end "
"position is greater than or equal to @var{pos}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:580
msgid ""
"If no leaf node's span covers @var{pos} (e.g., @var{pos} is in the "
"whitespace between two leaf nodes), this function returns the first leaf "
"node after @var{pos}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:583
msgid ""
"Finally, if there is no leaf node after @var{pos}, return the first leaf "
"node before @var{pos}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:590
msgid ""
"If @var{parser-or-lang} is a parser object, this function uses that parser; "
"if @var{parser-or-lang} is a language, this function uses the first parser "
"for that language in the current buffer, or creates one if none exists; if "
"@var{parser-or-lang} is @code{nil}, this function tries to guess the "
"language at @var{pos} by calling @code{treesit-language-at} (@pxref{Multiple "
"Languages})."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:593
msgid ""
"If this function cannot find a suitable node to return, it returns "
"@code{nil}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:596
msgid ""
"If @var{named} is non-@code{nil}, this function looks only for named nodes "
"(@pxref{tree-sitter named node, named node})."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:598 original_texis/parsing.texi:1492
msgid "Example:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:604
#, no-wrap
msgid ""
";; Find the node at point in a C parser's syntax tree.\n"
"(treesit-node-at (point) 'c)\n"
"  @result{} #<treesit-node (primitive_type) in 23-27>\n"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:608
#, no-wrap
msgid "treesit-node-on beg end &optional parser-or-lang named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:613
msgid ""
"This function returns the @emph{smallest} node that covers the region of "
"buffer text between @var{beg} and @var{end}.  In other words, the start of "
"the node is before or at @var{beg}, and the end of the node is at or after "
"@var{end}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:619
msgid ""
"@emph{Beware:} calling this function on an empty line that is not inside any "
"top-level construct (function definition, etc.@:) most probably will give "
"you the root node, because the root node is the smallest node that covers "
"that empty line.  Most of the time, you want to use @code{treesit-node-at} "
"instead."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:626
msgid ""
"If @var{parser-or-lang} is a parser object, this function uses that parser; "
"if @var{parser-or-lang} is a language, this function uses the first parser "
"for that language in the current buffer, or creates one if none exists; if "
"@var{parser-or-lang} is @code{nil}, this function tries to guess the "
"language at @var{beg} by calling @code{treesit-language-at}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:629
msgid ""
"If @var{named} is non-@code{nil}, this function looks for a named node only "
"(@pxref{tree-sitter named node, named node})."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:631
#, no-wrap
msgid "treesit-parser-root-node parser"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:634
msgid ""
"This function returns the root node of the syntax tree generated by "
"@var{parser}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:636
#, no-wrap
msgid "treesit-buffer-root-node &optional language"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:642
msgid ""
"This function finds the first parser for @var{language} in the current "
"buffer, or creates one if none exists, and returns the root node generated "
"by that parser.  If @var{language} is omitted, it uses the first parser in "
"the parser list.  If it cannot find an appropriate parser, it returns "
"@code{nil}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:646
msgid ""
"Given a node, a Lisp program can retrieve other nodes starting from it, or "
"query for information about this node."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:647
#, no-wrap
msgid "Retrieving nodes from other nodes"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:648
#, no-wrap
msgid "syntax tree nodes, retrieving from other nodes"
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:650
#, no-wrap
msgid "By kinship"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:651
#, no-wrap
msgid "kinship, syntax tree nodes"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:652
#, no-wrap
msgid "nodes, by kinship"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:653
#, no-wrap
msgid "syntax tree nodes, by kinship"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:655
#, no-wrap
msgid "treesit-node-parent node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:657
msgid "This function returns the immediate parent of @var{node}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:661
msgid ""
"If @var{node} is more than 1000 levels deep in a parse tree, the return "
"value is undefined.  Currently it returns @code{nil}, but that could change "
"in the future."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:663
#, no-wrap
msgid "treesit-node-child node n &optional named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:667
msgid ""
"This function returns the @var{n}'th child of @var{node}.  If @var{named} is "
"non-@code{nil}, it counts only named nodes (@pxref{tree-sitter named node, "
"named node})."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:673
msgid ""
"For example, in a node that represents a string @code{\"text\"}, there are "
"three children nodes: the opening quote @code{\"}, the string text "
"@code{text}, and the closing quote @code{\"}.  Among these nodes, the first "
"child is the opening quote @code{\"}, and the first named child is the "
"string text."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:676
msgid ""
"This function returns @code{nil} if there is no @var{n}'th child.  @var{n} "
"could be negative, e.g., @minus{}1 represents the last child."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:678
#, no-wrap
msgid "treesit-node-children node &optional named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:681
msgid ""
"This function returns all of @var{node}'s children as a list.  If "
"@var{named} is non-@code{nil}, it retrieves only named nodes."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:683
#, no-wrap
msgid "treesit-node-next-sibling node &optional named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:686
msgid ""
"This function finds the next sibling of @var{node}.  If @var{named} is "
"non-@code{nil}, it finds the next named sibling."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:688
#, no-wrap
msgid "treesit-node-prev-sibling node &optional named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:691
msgid ""
"This function finds the previous sibling of @var{node}.  If @var{named} is "
"non-@code{nil}, it finds the previous named sibling."
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:693
#, no-wrap
msgid "By field name"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:694
#, no-wrap
msgid "nodes, by field name"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:695
#, no-wrap
msgid "syntax tree nodes, by field name"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:701
msgid ""
"To make the syntax tree easier to analyze, many language grammars assign "
"@dfn{field names} to child nodes (@pxref{tree-sitter node field name, field "
"name}).  For example, a @code{function_definition} node could have a "
"@code{declarator} node and a @code{body} node."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:702
#, no-wrap
msgid "treesit-node-child-by-field-name node field-name"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:705
msgid ""
"This function finds the child of @var{node} whose field name is "
"@var{field-name}, a string."
msgstr ""

#. type: group
#: original_texis/parsing.texi:711
#, no-wrap
msgid ""
";; Get the child that has \"body\" as its field name.\n"
"(treesit-node-child-by-field-name node \"body\")\n"
"  @result{} #<treesit-node (compound_statement) in 45-89>\n"
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:715
#, no-wrap
msgid "By position"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:716
#, no-wrap
msgid "nodes, by position"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:717
#, no-wrap
msgid "syntax tree nodes, by position"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:719
#, no-wrap
msgid "treesit-node-first-child-for-pos node pos &optional named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:726
msgid ""
"This function finds the first child of @var{node} that extends beyond buffer "
"position @var{pos}.  ``Extends beyond'' means the end of the child node is "
"greater or equal to @var{pos}.  This function only looks for immediate "
"children of @var{node}, and doesn't look in its grandchildren.  If "
"@var{named} is non-@code{nil}, it looks for the first named child "
"(@pxref{tree-sitter named node, named node})."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:728
#, no-wrap
msgid "treesit-node-descendant-for-range node beg end &optional named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:733
msgid ""
"This function finds the @emph{smallest} descendant node of @var{node} that "
"spans the region of text between positions @var{beg} and @var{end}.  It is "
"similar to @code{treesit-node-at}.  If @var{named} is non-@code{nil}, it "
"looks for the smallest named child."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:735
#, no-wrap
msgid "Searching for node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:737
#, no-wrap
msgid "treesit-search-subtree node predicate &optional backward all depth"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:744
msgid ""
"This function traverses the subtree of @var{node} (including @var{node} "
"itself), looking for a node for which @var{predicate} returns "
"non-@code{nil}.  @var{predicate} is a regexp that is matched against each "
"node's type, or a predicate function that takes a node and returns "
"non-@code{nil} if the node matches.  The function returns the first node "
"that matches, or @code{nil} if none does."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:752
msgid ""
"By default, this function only traverses named nodes, but if @var{all} is "
"non-@code{nil}, it traverses all the nodes.  If @var{backward} is "
"non-@code{nil}, it traverses backwards (i.e., it visits the last child first "
"when traversing down the tree).  If @var{depth} is non-@code{nil}, it must "
"be a number that limits the tree traversal to that many levels down the "
"tree.  If @var{depth} is @code{nil}, it defaults to 1000."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:754
#, no-wrap
msgid "treesit-search-forward start predicate &optional backward all"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:760
msgid ""
"Like @code{treesit-search-subtree}, this function also traverses the parse "
"tree and matches each node with @var{predicate} (except for @var{start}), "
"where @var{predicate} can be a regexp or a function.  For a tree like the "
"one below where @var{start} is marked @samp{S}, this function traverses as "
"numbered from 1 to 12:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:772
#, no-wrap
msgid ""
"              12\n"
"              |\n"
"     S--------3----------11\n"
"     |        |          |\n"
"o--o-+--o  1--+--2    6--+-----10\n"
"|  |                  |        |\n"
"o  o                +-+-+   +--+--+\n"
"                    |   |   |  |  |\n"
"                    4   5   7  8  9\n"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:777
msgid ""
"Note that this function doesn't traverse the subtree of @var{start}, and it "
"always traverses leaf nodes first, before moving upwards."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:782
msgid ""
"Like @code{treesit-search-subtree}, this function only searches for named "
"nodes by default, but if @var{all} is non-@code{nil}, it searches for all "
"nodes.  If @var{backward} is non-@code{nil}, it searches backwards."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:787
msgid ""
"While @code{treesit-search-subtree} traverses the subtree of a node, this "
"function starts with node @var{start} and traverses every node that comes "
"after it in the buffer position order, i.e., nodes with start positions "
"greater than the end position of @var{start}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:793
msgid ""
"In the tree shown above, @code{treesit-search-subtree} traverses node "
"@samp{S} (@var{start}) and nodes marked with @code{o}, whereas this function "
"traverses the nodes marked with numbers.  This function is useful for "
"answering questions like ``what is the first node after @var{start} in the "
"buffer that satisfies some condition?''"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:795
#, no-wrap
msgid "treesit-search-forward-goto node predicate &optional start backward all"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:799
msgid ""
"This function moves point to the start or end of the next node after "
"@var{node} in the buffer that matches @var{predicate}.  If @var{start} is "
"non-@code{nil}, stop at the beginning rather than the end of a node."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:803
msgid ""
"This function guarantees that the matched node it returns makes progress in "
"terms of buffer position: the start/end position of the returned node is "
"always greater than that of @var{node}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:806
msgid ""
"Arguments @var{predicate}, @var{backward}, and @var{all} are the same as in "
"@code{treesit-search-forward}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:808
#, no-wrap
msgid "treesit-induce-sparse-tree root predicate &optional process-fn depth"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:810
msgid "This function creates a sparse tree from @var{root}'s subtree."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:816
msgid ""
"It takes the subtree under @var{root}, and combs it so only the nodes that "
"match @var{predicate} are left.  Like previous functions, the "
"@var{predicate} can be a regexp string that matches against each node's "
"type, or a function that takes a node and returns non-@code{nil} if it "
"matches."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:820
msgid ""
"For example, given the subtree on the left that consists of both numbers and "
"letters, if @var{predicate} is ``letter only'', the returned tree is the one "
"on the right."
msgstr ""

#. type: group
#: original_texis/parsing.texi:834
#, no-wrap
msgid ""
"    a                 a              a\n"
"    |                 |              |\n"
"+---+---+         +---+---+      +---+---+\n"
"|   |   |         |   |   |      |   |   |\n"
"b   1   2         b   |   |      b   c   d\n"
"    |   |     =>      |   |  =>      |\n"
"    c   +--+          c   +          e\n"
"    |   |  |          |   |\n"
" +--+   d  4       +--+   d\n"
" |  |              |\n"
" e  5              e\n"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:842
msgid ""
"If @var{process-fn} is non-@code{nil}, instead of returning the matched "
"nodes, this function passes each node to @var{process-fn} and uses the "
"returned value instead.  If non-@code{nil}, @var{depth} limits the number of "
"levels to go down from @var{root}.  If @var{depth} is @code{nil}, it "
"defaults to 1000."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:848
msgid ""
"Each node in the returned tree looks like @w{@code{(@var{tree-sitter-node} "
". (@var{child} @dots{}))}}.  The @var{tree-sitter-node} of the root of this "
"tree will be @code{nil} if @var{root} doesn't match @var{predicate}.  If no "
"node matches @var{predicate}, the function returns @code{nil}."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:850
#, no-wrap
msgid "More convenience functions"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:852
#, no-wrap
msgid "treesit-filter-child node predicate &optional named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:855
msgid ""
"This function finds immediate children of @var{node} that satisfy "
"@var{predicate}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:860
msgid ""
"The @var{predicate} function takes a node as argument and should return "
"non-@code{nil} to indicate that the node should be kept.  If @var{named} is "
"non-@code{nil}, this function only examines named nodes."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:862
#, no-wrap
msgid "treesit-parent-until node predicate &optional include-node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:867
msgid ""
"This function repeatedly finds the parents of @var{node}, and returns the "
"parent that satisfies @var{predicate}, a function that takes a node as "
"argument and returns a boolean that indicates a match.  If no parent "
"satisfies @var{predicate}, this function returns @code{nil}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:871
msgid ""
"Normally this function only looks at the parents of @var{node} but not "
"@var{node} itself.  But if @var{include-node} is non-@code{nil}, this "
"function returns @var{node} if @var{node} satisfies @var{predicate}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:873
#, no-wrap
msgid "treesit-parent-while node predicate"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:880
msgid ""
"This function goes up the tree starting from @var{node}, and keeps doing so "
"as long as the nodes satisfy @var{predicate}, a function that takes a node "
"as argument.  That is, this function returns the highest parent of "
"@var{node} that still satisfies @var{predicate}.  Note that if @var{node} "
"satisfies @var{predicate} but its immediate parent doesn't, @var{node} "
"itself is returned."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:882
#, no-wrap
msgid "treesit-node-top-level node &optional predicate include-node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:887
msgid ""
"This function returns the highest parent of @var{node} that has the same "
"type as @var{node}.  If no such parent exists, it returns @code{nil}.  "
"Therefore this function is also useful for testing whether @var{node} is "
"top-level."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:893
msgid ""
"If @var{predicate} is @code{nil}, this function uses @var{node}'s type to "
"find the parent.  If @var{predicate} is non-@code{nil}, this function "
"searches the parent that satisfies @var{predicate}.  If @var{include-node} "
"is non-@code{nil}, this function returns @var{node} if @var{node} satisfies "
"@var{predicate}."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:897
#, no-wrap
msgid "information of node, syntax trees"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:898
#, no-wrap
msgid "syntax trees, node information"
msgstr ""

#. type: heading
#: original_texis/parsing.texi:900
#, no-wrap
msgid "Basic information of Node"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:904
msgid ""
"Every node is associated with a parser, and that parser is associated with a "
"buffer.  The following functions retrieve them."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:905
#, no-wrap
msgid "treesit-node-parser node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:907
msgid "This function returns @var{node}'s associated parser."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:909
#, no-wrap
msgid "treesit-node-buffer node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:911
msgid "This function returns @var{node}'s parser's associated buffer."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:913
#, no-wrap
msgid "treesit-node-language node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:915
msgid "This function returns @var{node}'s parser's associated language."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:919
msgid ""
"Each node represents a portion of text in the buffer.  Functions below find "
"relevant information about that text."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:920
#, no-wrap
msgid "treesit-node-start node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:922
msgid "Return the start position of @var{node}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:924
#, no-wrap
msgid "treesit-node-end node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:926
msgid "Return the end position of @var{node}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:928
#, no-wrap
msgid "treesit-node-text node &optional object"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:932
msgid ""
"Return the buffer text that @var{node} represents, as a string.  (If "
"@var{node} is retrieved from parsing a string, it will be the text from that "
"string.)"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:934
#, no-wrap
msgid "predicates for syntax tree nodes"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:936
msgid "Here are some predicates on tree-sitter nodes:"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:937
#, no-wrap
msgid "treesit-node-p object"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:939
msgid "Checks if @var{object} is a tree-sitter syntax node."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:941
#, no-wrap
msgid "compare tree-sitter syntax nodes"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:942
#, no-wrap
msgid "tree-sitter nodes, comparing"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:943
#, no-wrap
msgid "treesit-node-eq node1 node2"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:948
msgid ""
"Checks if @var{node1} and @var{node2} refer to the same node in a "
"tree-sitter syntax tree.  This function uses the same equivalence metric as "
"@code{equal}.  You can also compare nodes using @code{equal} "
"(@pxref{Equality Predicates})."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:950
#, no-wrap
msgid "Property information"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:956
msgid ""
"In general, nodes in a concrete syntax tree fall into two categories: "
"@dfn{named nodes} and @dfn{anonymous nodes}.  Whether a node is named or "
"anonymous is determined by the language grammar (@pxref{tree-sitter named "
"node, named node})."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:957
#, no-wrap
msgid "tree-sitter missing node"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:958
#, no-wrap
msgid "missing node, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:965
msgid ""
"Apart from being named or anonymous, a node can have other properties.  A "
"node can be ``missing'': such nodes are inserted by the parser in order to "
"recover from certain kinds of syntax errors, i.e., something should probably "
"be there according to the grammar, but is not there.  This can happen during "
"editing of the program source, when the source is not yet in its final form."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:966
#, no-wrap
msgid "tree-sitter extra node"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:967
#, no-wrap
msgid "extra node, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:970
msgid ""
"A node can be ``extra'': such nodes represent things like comments, which "
"can appear anywhere in the text."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:971
#, no-wrap
msgid "tree-sitter outdated node"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:972
#, no-wrap
msgid "outdated node, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:975
msgid ""
"A node can be ``outdated'', if its parser has reparsed at least once after "
"the node was created."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:976
#, no-wrap
msgid "tree-sitter node that has error"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:977
#, no-wrap
msgid "has error, tree-sitter node"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:981
msgid ""
"A node ``has error'' if the text it spans contains a syntax error.  It can "
"be that the node itself has an error, or one of its descendants has an "
"error."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:982
#, no-wrap
msgid "tree-sitter, live parsing node"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:983
#, no-wrap
msgid "live node, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:986
msgid ""
"A node is considered @dfn{live} if its parser is not deleted, and the buffer "
"to which it belongs is a live buffer (@pxref{Killing Buffers})."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:987
#, no-wrap
msgid "treesit-node-check node property"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:991
msgid ""
"This function returns non-@code{nil} if @var{node} has the specified "
"@var{property}.  @var{property} can be @code{named}, @code{missing}, "
"@code{extra}, @code{outdated}, @code{has-error}, or @code{live}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:993
#, no-wrap
msgid "treesit-node-type node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:999
msgid ""
"Named nodes have ``types'' (@pxref{tree-sitter node type, node type}).  For "
"example, a named node can be a @code{string_literal} node, where "
"@code{string_literal} is its type.  The type of an anonymous node is just "
"the text that the node represents; e.g., the type of a @samp{,} node is just "
"@samp{,}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1001
msgid "This function returns @var{node}'s type as a string."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:1003
#, no-wrap
msgid "Information as a child or parent"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1005
#, no-wrap
msgid "treesit-node-index node &optional named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1009
msgid ""
"This function returns the index of @var{node} as a child node of its "
"parent.  If @var{named} is non-@code{nil}, it only counts named nodes "
"(@pxref{tree-sitter named node, named node})."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1011
#, no-wrap
msgid "treesit-node-field-name node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1015
msgid ""
"A child of a parent node could have a field name (@pxref{tree-sitter node "
"field name, field name}).  This function returns the field name of "
"@var{node} as a child of its parent."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1017
#, no-wrap
msgid "treesit-node-field-name-for-child node n"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1021
msgid ""
"This function returns the field name of the @var{n}'th child of @var{node}.  "
"It returns @code{nil} if there is no @var{n}'th child, or the @var{n}'th "
"child doesn't have a field name."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1024
msgid ""
"Note that @var{n} counts both named and anonymous children, and @var{n} can "
"be negative, e.g., @minus{}1 represents the last child."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1026
#, no-wrap
msgid "treesit-node-child-count node &optional named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1030
msgid ""
"This function returns the number of children of @var{node}.  If @var{named} "
"is non-@code{nil}, it only counts named children (@pxref{tree-sitter named "
"node, named node})."
msgstr ""

#. type: section
#: original_texis/parsing.texi:1033
#, no-wrap
msgid "Pattern Matching Tree-sitter Nodes"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1034
#, no-wrap
msgid "pattern matching with tree-sitter nodes"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1036
#, no-wrap
msgid "capturing, tree-sitter node"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1042
msgid ""
"Tree-sitter lets Lisp programs match patterns using a small declarative "
"language.  This pattern matching consists of two steps: first tree-sitter "
"matches a @dfn{pattern} against nodes in the syntax tree, then it "
"@dfn{captures} specific nodes that matched the pattern and returns the "
"captured nodes."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1046
msgid ""
"We describe first how to write the most basic query pattern and how to "
"capture nodes in a pattern, then the pattern-matching function, and finally "
"the more advanced pattern syntax."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:1047
#, no-wrap
msgid "Basic query syntax"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1049
#, no-wrap
msgid "tree-sitter query pattern syntax"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1050
#, no-wrap
msgid "pattern syntax, tree-sitter query"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1051
#, no-wrap
msgid "query, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1055
msgid ""
"A @dfn{query} consists of multiple @dfn{patterns}.  Each pattern is an "
"s-expression that matches a certain node in the syntax node.  A pattern has "
"the form @w{@code{(@var{type} (@var{child}@dots{}))}}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1058
msgid ""
"For example, a pattern that matches a @code{binary_expression} node that "
"contains @code{number_literal} child nodes would look like"
msgstr ""

#. type: example
#: original_texis/parsing.texi:1061
#, no-wrap
msgid "(binary_expression (number_literal))\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1066
msgid ""
"To @dfn{capture} a node using the query pattern above, append "
"@code{@@@var{capture-name}} after the node pattern you want to capture.  For "
"example,"
msgstr ""

#. type: example
#: original_texis/parsing.texi:1069
#, no-wrap
msgid "(binary_expression (number_literal) @@number-in-exp)\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1075
msgid ""
"captures @code{number_literal} nodes that are inside a "
"@code{binary_expression} node with the capture name @code{number-in-exp}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1078
msgid ""
"We can capture the @code{binary_expression} node as well, with, for example, "
"the capture name @code{biexp}:"
msgstr ""

#. type: example
#: original_texis/parsing.texi:1082
#, no-wrap
msgid ""
"(binary_expression\n"
" (number_literal) @@number-in-exp) @@biexp\n"
msgstr ""

#. type: heading
#: original_texis/parsing.texi:1084
#, no-wrap
msgid "Query function"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1086
#, no-wrap
msgid "query functions, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1088
msgid "Now we can introduce the @dfn{query functions}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1089
#, no-wrap
msgid "treesit-query-capture node query &optional beg end node-only"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1095
msgid ""
"This function matches patterns in @var{query} within @var{node}.  The "
"argument @var{query} can be either an s-expression, a string, or a compiled "
"query object.  For now, we focus on the s-expression syntax; string syntax "
"and compiled queries are described at the end of the section."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1100
msgid ""
"The argument @var{node} can also be a parser or a language symbol.  A parser "
"means use its root node, a language symbol means find or create a parser for "
"that language in the current buffer, and use the root node."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1110
msgid ""
"The function returns all the captured nodes in an alist with elements of the "
"form @w{@code{(@var{capture_name} . @var{node})}}.  If @var{node-only} is "
"non-@code{nil}, it returns the list of @var{node}s instead.  By default the "
"entire text of @var{node} is searched, but if @var{beg} and @var{end} are "
"both non-@code{nil}, they specify the region of buffer text where this "
"function should match nodes.  Any matching node whose span overlaps with the "
"region between @var{beg} and @var{end} is captured; it doesn't have to be "
"completely contained in the region."
msgstr ""

#. type: vindex
#: original_texis/parsing.texi:1111
#, no-wrap
msgid "treesit-query-error"
msgstr ""

#. type: findex
#: original_texis/parsing.texi:1112
#, no-wrap
msgid "treesit-query-validate"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1117 original_texis/parsing.texi:1417
msgid ""
"This function raises the @code{treesit-query-error} error if @var{query} is "
"malformed.  The signal data contains a description of the specific error.  "
"You can use @code{treesit-query-validate} to validate and debug the query."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1121
msgid "For example, suppose @var{node}'s text is @code{1 + 2}, and @var{query} is"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1127
#, no-wrap
msgid ""
"(setq query\n"
"      '((binary_expression\n"
"         (number_literal) @@number-in-exp) @@biexp)\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1131
msgid "Matching that query would return"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1138
#, no-wrap
msgid ""
"(treesit-query-capture node query)\n"
"    @result{} ((biexp . @var{<node for \"1 + 2\">})\n"
"       (number-in-exp . @var{<node for \"1\">})\n"
"       (number-in-exp . @var{<node for \"2\">}))\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1143
msgid ""
"As mentioned earlier, @var{query} could contain multiple patterns.  For "
"example, it could have two top-level patterns:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1149
#, no-wrap
msgid ""
"(setq query\n"
"      '((binary_expression) @@biexp\n"
"        (number_literal) @@number @@biexp)\n"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1152
#, no-wrap
msgid "treesit-query-string string query language"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1155
msgid ""
"This function parses @var{string} as @var{language}, matches its root node "
"with @var{query}, and returns the result."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:1157
#, no-wrap
msgid "More query syntax"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1162
msgid ""
"Besides node type and capture name, tree-sitter's pattern syntax can express "
"anonymous node, field name, wildcard, quantification, grouping, alternation, "
"anchor, and predicate."
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:1163
#, no-wrap
msgid "Anonymous node"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1167
msgid ""
"An anonymous node is written verbatim, surrounded by quotes.  A pattern "
"matching (and capturing) keyword @code{return} would be"
msgstr ""

#. type: example
#: original_texis/parsing.texi:1170
#, no-wrap
msgid "\"return\" @@keyword\n"
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:1172
#, no-wrap
msgid "Wild card"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1177
msgid ""
"In a pattern, @samp{(_)} matches any named node, and @samp{_} matches any "
"named or anonymous node.  For example, to capture any named child of a "
"@code{binary_expression} node, the pattern would be"
msgstr ""

#. type: example
#: original_texis/parsing.texi:1180
#, no-wrap
msgid "(binary_expression (_) @@in-biexp)\n"
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:1182
#, no-wrap
msgid "Field name"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1187
msgid ""
"It is possible to capture child nodes that have specific field names.  In "
"the pattern below, @code{declarator} and @code{body} are field names, "
"indicated by the colon following them."
msgstr ""

#. type: group
#: original_texis/parsing.texi:1193
#, no-wrap
msgid ""
"(function_definition\n"
"  declarator: (_) @@func-declarator\n"
"  body: (_) @@func-body)\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1198
msgid ""
"It is also possible to capture a node that doesn't have a certain field, "
"say, a @code{function_definition} without a @code{body} field:"
msgstr ""

#. type: example
#: original_texis/parsing.texi:1201
#, no-wrap
msgid "(function_definition !body) @@func-no-body\n"
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:1203
#, no-wrap
msgid "Quantify node"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1205
#, no-wrap
msgid "quantify node, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1210
msgid ""
"Tree-sitter recognizes quantification operators @samp{:*}, @samp{:+}, and "
"@samp{:?}.  Their meanings are the same as in regular expressions: @samp{:*} "
"matches the preceding pattern zero or more times, @samp{:+} matches one or "
"more times, and @samp{:?} matches zero or one times."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1213
msgid ""
"For example, the following pattern matches @code{type_declaration} nodes "
"that have @emph{zero or more} @code{long} keywords."
msgstr ""

#. type: example
#: original_texis/parsing.texi:1216
#, no-wrap
msgid "(type_declaration \"long\" :*) @@long-type\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1220
msgid ""
"The following pattern matches a type declaration that may or may not have a "
"@code{long} keyword:"
msgstr ""

#. type: example
#: original_texis/parsing.texi:1223
#, no-wrap
msgid "(type_declaration \"long\" :?) @@long-type\n"
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:1225
#, no-wrap
msgid "Grouping"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1230
msgid ""
"Similar to groups in regular expressions, we can bundle patterns into groups "
"and apply quantification operators to them.  For example, to express a "
"comma-separated list of identifiers, one could write"
msgstr ""

#. type: example
#: original_texis/parsing.texi:1233
#, no-wrap
msgid "(identifier) (\",\" (identifier)) :*\n"
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:1235
#, no-wrap
msgid "Alternation"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1240
msgid ""
"Again, similar to regular expressions, we can express ``match any one of "
"these patterns'' in a pattern.  The syntax is a vector of patterns.  For "
"example, to capture some keywords in C, the pattern would be"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1249
#, no-wrap
msgid ""
"[\n"
"  \"return\"\n"
"  \"break\"\n"
"  \"if\"\n"
"  \"else\"\n"
"] @@keyword\n"
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:1252
#, no-wrap
msgid "Anchor"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1259
msgid ""
"The anchor operator @code{:anchor} can be used to enforce juxtaposition, "
"i.e., to enforce two things to be directly next to each other.  The two "
"``things'' can be two nodes, or a child and the end of its parent.  For "
"example, to capture the first child, the last child, or two adjacent "
"children:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1264
#, no-wrap
msgid ""
";; Anchor the child with the end of its parent.\n"
"(compound_expression (_) @@last-child :anchor)\n"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1269
#, no-wrap
msgid ""
";; Anchor the child with the beginning of its parent.\n"
"(compound_expression :anchor (_) @@first-child)\n"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1277
#, no-wrap
msgid ""
";; Anchor two adjacent children.\n"
"(compound_expression\n"
" (_) @@prev-child\n"
" :anchor\n"
" (_) @@next-child)\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1282
msgid "Note that the enforcement of juxtaposition ignores any anonymous nodes."
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:1283
#, no-wrap
msgid "Predicate"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1287
msgid ""
"It is possible to add predicate constraints to a pattern.  For example, with "
"the following pattern:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1294
#, no-wrap
msgid ""
"(\n"
" (array :anchor (_) @@first (_) @@last :anchor)\n"
" (:equal @@first @@last)\n"
")\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1302
msgid ""
"tree-sitter only matches arrays where the first element is equal to the last "
"element.  To attach a predicate to a pattern, we need to group them "
"together.  Currently there are three predicates: @code{:equal}, "
"@code{:match}, and @code{:pred}."
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:1303
#, no-wrap
msgid "Predicate :equal arg1 arg2"
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:1307
msgid ""
"Matches if @var{arg1} is equal to @var{arg2}.  Arguments can be either "
"strings or capture names.  Capture names represent the text that the "
"captured node spans in the buffer."
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:1309
#, no-wrap
msgid "Predicate :match regexp capture-name"
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:1313
msgid ""
"Matches if the text that @var{capture-name}'s node spans in the buffer "
"matches regular expression @var{regexp}, given as a string literal.  "
"Matching is case-sensitive."
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:1315
#, no-wrap
msgid "Predicate :pred fn &rest nodes"
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:1318
msgid ""
"Matches if function @var{fn} returns non-@code{nil} when passed each node in "
"@var{nodes} as arguments."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1323
msgid ""
"Note that a predicate can only refer to capture names that appear in the "
"same pattern.  Indeed, it makes little sense to refer to capture names in "
"other patterns."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:1324
#, no-wrap
msgid "String patterns"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1326
#, no-wrap
msgid "tree-sitter patterns as strings"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1327
#, no-wrap
msgid "patterns, tree-sitter, in string form"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1331
msgid ""
"Besides s-expressions, Emacs allows the tree-sitter's native query syntax to "
"be used by writing them as strings.  It largely resembles the s-expression "
"syntax.  For example, the following query"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1339
#, no-wrap
msgid ""
"(treesit-query-capture\n"
" node '((addition_expression\n"
"         left: (_) @@left\n"
"         \"+\" @@plus-sign\n"
"         right: (_) @@right) @@addition\n"
"\n"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1341
#, no-wrap
msgid "         [\"return\" \"break\"] @@keyword))\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1346
msgid "is equivalent to"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1354
#, no-wrap
msgid ""
"(treesit-query-capture\n"
" node \"(addition_expression\n"
"        left: (_) @@left\n"
"        \\\"+\\\" @@plus-sign\n"
"        right: (_) @@right) @@addition\n"
"\n"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1356
#, no-wrap
msgid "        [\\\"return\\\" \\\"break\\\"] @@keyword\")\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1361
msgid ""
"Most patterns can be written directly as s-expressions inside a string.  "
"Only a few of them need modification:"
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1365
msgid "Anchor @code{:anchor} is written as @samp{.}."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1367
msgid "@samp{:?} is written as @samp{?}."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1369
msgid "@samp{:*} is written as @samp{*}."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1371
msgid "@samp{:+} is written as @samp{+}."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1375
msgid ""
"@code{:equal}, @code{:match} and @code{:pred} are written as @code{#equal}, "
"@code{#match} and @code{#pred}, respectively.  In general, predicates change "
"their @samp{:} to @samp{#}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1378
msgid "For example,"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1385
#, no-wrap
msgid ""
"'((\n"
"   (compound_expression :anchor (_) @@first (_) :* @@rest)\n"
"   (:match \"love\" @@first)\n"
"   ))\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1390
msgid "is written in string form as"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1397
#, no-wrap
msgid ""
"\"(\n"
"  (compound_expression . (_) @@first (_)* @@rest)\n"
"  (#match \\\"love\\\" @@first)\n"
"  )\"\n"
msgstr ""

#. type: heading
#: original_texis/parsing.texi:1400
#, no-wrap
msgid "Compiling queries"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1402
#, no-wrap
msgid "compiling tree-sitter queries"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1403
#, no-wrap
msgid "queries, compiling"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1408
msgid ""
"If a query is intended to be used repeatedly, especially in tight loops, it "
"is important to compile that query, because a compiled query is much faster "
"than an uncompiled one.  A compiled query can be used anywhere a query is "
"accepted."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1409
#, no-wrap
msgid "treesit-query-compile language query"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1412
msgid ""
"This function compiles @var{query} for @var{language} into a compiled query "
"object and returns it."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1419
#, no-wrap
msgid "treesit-query-language query"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1421
msgid "This function returns the language of @var{query}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1423
#, no-wrap
msgid "treesit-query-expand query"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1426
msgid "This function converts the s-expression @var{query} into the string format."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1428
#, no-wrap
msgid "treesit-pattern-expand pattern"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1431
msgid ""
"This function converts the s-expression @var{pattern} into the string "
"format."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1436
msgid ""
"For more details, read the tree-sitter project's documentation about "
"pattern-matching, which can be found at "
"@uref{https://tree-sitter.github.io/tree-sitter/using-parsers#pattern-matching-with-queries}."
msgstr ""

#. type: section
#: original_texis/parsing.texi:1438
#, no-wrap
msgid "Parsing Text in Multiple Languages"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1439
#, no-wrap
msgid "multiple languages, parsing with tree-sitter"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1440
#, no-wrap
msgid "parsing multiple languages with tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1450
msgid ""
"Sometimes, the source of a programming language could contain snippets of "
"other languages; @acronym{HTML} + @acronym{CSS} + JavaScript is one "
"example.  In that case, text segments written in different languages need to "
"be assigned different parsers.  Traditionally, this is achieved by using "
"narrowing.  While tree-sitter works with narrowing (@pxref{tree-sitter "
"narrowing, narrowing}), the recommended way is instead to specify regions of "
"buffer text (i.e., ranges) in which a parser will operate.  This section "
"describes functions for setting and getting ranges for a parser."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1460
msgid ""
"Lisp programs should call @code{treesit-update-ranges} to make sure the "
"ranges for each parser are correct before using parsers in a buffer, and "
"call @code{treesit-language-at} to figure out the language responsible for "
"the text at some position.  These two functions don't work by themselves, "
"they need major modes to set @code{treesit-range-settings} and "
"@code{treesit-language-at-point-function}, which do the actual work.  These "
"functions and variables are explained in more detail towards the end of the "
"section."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:1461
#, no-wrap
msgid "Getting and setting ranges"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1463
#, no-wrap
msgid "treesit-parser-set-included-ranges parser ranges"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1468
msgid ""
"This function sets up @var{parser} to operate on @var{ranges}.  The "
"@var{parser} will only read the text of the specified ranges.  Each range in "
"@var{ranges} is a pair of the form @w{@code{(@var{beg} . @var{end})}}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1471
msgid ""
"The ranges in @var{ranges} must come in order and must not overlap.  That "
"is, in pseudo code:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1479
#, no-wrap
msgid ""
"(cl-loop for idx from 1 to (1- (length ranges))\n"
"         for prev = (nth (1- idx) ranges)\n"
"         for next = (nth idx ranges)\n"
"         should (<= (car prev) (cdr prev)\n"
"                    (car next) (cdr next)))\n"
msgstr ""

#. type: vindex
#: original_texis/parsing.texi:1482
#, no-wrap
msgid "treesit-range-invalid"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1487
msgid ""
"If @var{ranges} violates this constraint, or something else went wrong, this "
"function signals the @code{treesit-range-invalid} error.  The signal data "
"contains a specific error message and the ranges we are trying to set."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1490
msgid ""
"This function can also be used for disabling ranges.  If @var{ranges} is "
"@code{nil}, the parser is set to parse the whole buffer."
msgstr ""

#. type: group
#: original_texis/parsing.texi:1497
#, no-wrap
msgid ""
"(treesit-parser-set-included-ranges\n"
" parser '((1 . 9) (16 . 24) (24 . 25)))\n"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1501
#, no-wrap
msgid "treesit-parser-included-ranges parser"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1507
msgid ""
"This function returns the ranges set for @var{parser}.  The return value is "
"the same as the @var{ranges} argument of "
"@code{treesit-parser-included-ranges}: a list of cons cells of the form "
"@w{@code{(@var{beg} . @var{end})}}.  If @var{parser} doesn't have any "
"ranges, the return value is @code{nil}."
msgstr ""

#. type: group
#: original_texis/parsing.texi:1512
#, no-wrap
msgid ""
"(treesit-parser-included-ranges parser)\n"
"    @result{} ((1 . 9) (16 . 24) (24 . 25))\n"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1516
#, no-wrap
msgid "treesit-query-range source query &optional beg end"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1521
msgid ""
"This function matches @var{source} with @var{query} and returns the ranges "
"of captured nodes.  The return value is a list of cons cells of the form "
"@w{@code{(@var{beg} . @var{end})}}, where @var{beg} and @var{end} specify "
"the beginning and the end of a region of text."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1527
msgid ""
"For convenience, @var{source} can be a language symbol, a parser, or a "
"node.  If it's a language symbol, this function matches in the root node of "
"the first parser using that language; if a parser, this function matches in "
"the root node of that parser; if a node, this function matches in that node."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1532
msgid ""
"The argument @var{query} is the query used to capture nodes (@pxref{Pattern "
"Matching}).  The capture names don't matter.  The arguments @var{beg} and "
"@var{end}, if both non-@code{nil}, limit the range in which this function "
"queries."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1535
msgid ""
"Like other query functions, this function raises the "
"@code{treesit-query-error} error if @var{query} is malformed."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:1537
#, no-wrap
msgid "Supporting multiple languages in Lisp programs"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1542
msgid ""
"It should suffice for general Lisp programs to call the following two "
"functions in order to support program sources that mix multiple languages."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1543
#, no-wrap
msgid "treesit-update-ranges &optional beg end"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1549
msgid ""
"This function updates ranges for parsers in the buffer.  It makes sure the "
"parsers' ranges are set correctly between @var{beg} and @var{end}, according "
"to @code{treesit-range-settings}.  If omitted, @var{beg} defaults to the "
"beginning of the buffer, and @var{end} defaults to the end of the buffer."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1552
msgid ""
"For example, fontification functions use this function before querying for "
"nodes in a region."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1554
#, no-wrap
msgid "treesit-language-at pos"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1562
msgid ""
"This function returns the language of the text at buffer position "
"@var{pos}.  Under the hood it calls "
"@code{treesit-language-at-point-function} and returns its return value.  If "
"@code{treesit-language-at-point-function} is @code{nil}, this function "
"returns the language of the first parser in the returned value of "
"@code{treesit-parser-list}.  If there is no parser in the buffer, it returns "
"@code{nil}."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:1564
#, no-wrap
msgid "Supporting multiple languages in major modes"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1566
#, no-wrap
msgid "host language, tree-sitter"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1567
#, no-wrap
msgid "tree-sitter host and embedded languages"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1568
#, no-wrap
msgid "embedded language, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1575
msgid ""
"Normally, in a set of languages that can be mixed together, there is a "
"@dfn{host language} and one or more @dfn{embedded languages}.  A Lisp "
"program usually first parses the whole document with the host language's "
"parser, retrieves some information, sets ranges for the embedded languages "
"with that information, and then parses the embedded languages."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1583
msgid ""
"Take a buffer containing @acronym{HTML}, @acronym{CSS}, and JavaScript as an "
"example.  A Lisp program will first parse the whole buffer with an "
"@acronym{HTML} parser, then query the parser for @code{style_element} and "
"@code{script_element} nodes, which correspond to @acronym{CSS} and "
"JavaScript text, respectively.  Then it sets the range of the @acronym{CSS} "
"and JavaScript parsers to the range which their corresponding nodes span."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1585
msgid "Given a simple @acronym{HTML} document:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1592
#, no-wrap
msgid ""
"<html>\n"
"  <script>1 + 2</script>\n"
"  <style>body @{ color: \"blue\"; @}</style>\n"
"</html>\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1598
msgid ""
"a Lisp program will first parse with a @acronym{HTML} parser, then set "
"ranges for @acronym{CSS} and JavaScript parsers:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1605
#, no-wrap
msgid ""
";; Create parsers.\n"
"(setq html (treesit-parser-create 'html))\n"
"(setq css (treesit-parser-create 'css))\n"
"(setq js (treesit-parser-create 'javascript))\n"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1614
#, no-wrap
msgid ""
";; Set CSS ranges.\n"
"(setq css-range\n"
"      (treesit-query-range\n"
"       'html\n"
"       '((style_element (raw_text) @@capture))))\n"
"(treesit-parser-set-included-ranges css css-range)\n"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1623
#, no-wrap
msgid ""
";; Set JavaScript ranges.\n"
"(setq js-range\n"
"      (treesit-query-range\n"
"       'html\n"
"       '((script_element (raw_text) @@capture))))\n"
"(treesit-parser-set-included-ranges js js-range)\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1633
msgid ""
"Emacs automates this process in @code{treesit-update-ranges}.  A "
"multi-language major mode should set @code{treesit-range-settings} so that "
"@code{treesit-update-ranges} knows how to perform this process "
"automatically.  Major modes should use the helper function "
"@code{treesit-range-rules} to generate a value that can be assigned to "
"@code{treesit-range-settings}.  The settings in the following example "
"directly translate into operations shown above."
msgstr ""

#. type: group
#: original_texis/parsing.texi:1641
#, no-wrap
msgid ""
"(setq treesit-range-settings\n"
"      (treesit-range-rules\n"
"       :embed 'javascript\n"
"       :host 'html\n"
"       '((script_element (raw_text) @@capture))\n"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1647
#, no-wrap
msgid ""
"       :embed 'css\n"
"       :host 'html\n"
"       '((style_element (raw_text) @@capture))))\n"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1650
#, no-wrap
msgid "treesit-range-rules &rest query-specs"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1654
msgid ""
"This function is used to set @code{treesit-range-settings}.  It takes care "
"of compiling queries and other post-processing, and outputs a value that "
"@code{treesit-range-settings} can have."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1659
msgid ""
"It takes a series of @var{query-spec}s, where each @var{query-spec} is a "
"@var{query} preceded by zero or more @var{keyword}/@var{value} pairs.  Each "
"@var{query} is a tree-sitter query in either the string, s-expression, or "
"compiled form, or a function."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1664
msgid ""
"If @var{query} is a tree-sitter query, it should be preceded by two "
"@var{keyword}/@var{value} pairs, where the @code{:embed} keyword specifies "
"the embedded language, and the @code{:host} keyword specifies the host "
"language."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1670
msgid ""
"@code{treesit-update-ranges} uses @var{query} to figure out how to set the "
"ranges for parsers for the embedded language.  It queries @var{query} in a "
"host language parser, computes the ranges which the captured nodes span, and "
"applies these ranges to embedded language parsers."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1677
msgid ""
"If @var{query} is a function, it doesn't need any @var{keyword} and "
"@var{value} pair.  It should be a function that takes 2 arguments, "
"@var{start} and @var{end}, and sets the ranges for parsers in the current "
"buffer in the region between @var{start} and @var{end}.  It is fine for this "
"function to set ranges in a larger region that encompasses the region "
"between @var{start} and @var{end}."
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:1679
#, no-wrap
msgid "treesit-range-settings"
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:1685
msgid ""
"This variable helps @code{treesit-update-ranges} in updating the ranges for "
"parsers in the buffer.  It is a list of @var{setting}s where the exact "
"format of a @var{setting} is considered internal.  You should use "
"@code{treesit-range-rules} to generate a value that this variable can have."
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:1693
#, no-wrap
msgid "treesit-language-at-point-function"
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:1698
msgid ""
"This variable's value should be a function that takes a single argument, "
"@var{pos}, which is a buffer position, and returns the language of the "
"buffer text at @var{pos}.  This variable is used by "
"@code{treesit-language-at}."
msgstr ""

#. type: section
#: original_texis/parsing.texi:1701
#, no-wrap
msgid "Developing major modes with tree-sitter"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1702
#, no-wrap
msgid "major mode, developing with tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1706
msgid ""
"This section covers some general guidelines on developing tree-sitter "
"integration for a major mode."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1709
msgid ""
"A major mode supporting tree-sitter features should roughly follow this "
"pattern:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1718
#, no-wrap
msgid ""
"(define-derived-mode woomy-mode prog-mode \"Woomy\"\n"
"  \"A mode for Woomy programming language.\"\n"
"  (when (treesit-ready-p 'woomy)\n"
"    (setq-local treesit-variables ...)\n"
"    ...\n"
"    (treesit-major-mode-setup)))\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1723
msgid ""
"@code{treesit-ready-p} automatically emits a warning if conditions for "
"enabling tree-sitter aren't met."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1727
msgid ""
"If a tree-sitter major mode shares setup with its ``native'' counterpart, "
"one can create a ``base mode'' that contains the common setup, like this:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1734
#, no-wrap
msgid ""
"(define-derived-mode woomy--base-mode prog-mode \"Woomy\"\n"
"  \"An internal mode for Woomy programming language.\"\n"
"  (common-setup)\n"
"  ...)\n"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1741
#, no-wrap
msgid ""
"(define-derived-mode woomy-mode woomy--base-mode \"Woomy\"\n"
"  \"A mode for Woomy programming language.\"\n"
"  (native-setup)\n"
"  ...)\n"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1750
#, no-wrap
msgid ""
"(define-derived-mode woomy-ts-mode woomy--base-mode \"Woomy\"\n"
"  \"A mode for Woomy programming language.\"\n"
"  (when (treesit-ready-p 'woomy)\n"
"    (setq-local treesit-variables ...)\n"
"    ...\n"
"    (treesit-major-mode-setup)))\n"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1753
#, no-wrap
msgid "treesit-ready-p language &optional quiet"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1759
msgid ""
"This function checks for conditions for activating tree-sitter.  It checks "
"whether Emacs was built with tree-sitter, whether the buffer's size is not "
"too large for tree-sitter to handle, and whether the grammar for "
"@var{language} is available on the system (@pxref{Language Grammar})."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1763
msgid ""
"This function emits a warning if tree-sitter cannot be activated.  If "
"@var{quiet} is @code{message}, the warning is turned into a message; if "
"@var{quiet} is @code{t}, no warning or message is displayed."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1766
msgid ""
"If all the necessary conditions are met, this function returns "
"non-@code{nil}; otherwise it returns @code{nil}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1768
#, no-wrap
msgid "treesit-major-mode-setup"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1770
msgid "This function activates some tree-sitter features for a major mode."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1772
msgid "Currently, it sets up the following features:"
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1776
msgid ""
"If @code{treesit-font-lock-settings} (@pxref{Parser-based Font Lock})  is "
"non-@code{nil}, it sets up fontification."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1780
msgid ""
"If @code{treesit-simple-indent-rules} (@pxref{Parser-based Indentation})  is "
"non-@code{nil}, it sets up indentation."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1785
msgid ""
"If @code{treesit-defun-type-regexp} is non-@code{nil}, it sets up navigation "
"functions for @code{beginning-of-defun} and @code{end-of-defun}."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1789
msgid ""
"If @code{treesit-defun-name-function} is non-@code{nil}, it sets up add-log "
"functions used by @code{add-log-current-defun}."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1793
msgid ""
"If @code{treesit-simple-imenu-settings} (@pxref{Imenu}) is non-@code{nil}, "
"it sets up Imenu."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1799
msgid ""
"For more information on these built-in tree-sitter features, "
"@pxref{Parser-based Font Lock}, @pxref{Parser-based Indentation}, and "
"@pxref{List Motion}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1802
msgid ""
"For supporting mixing of multiple languages in a major mode, @pxref{Multiple "
"Languages}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1807
msgid ""
"Besides @code{beginning-of-defun} and @code{end-of-defun}, Emacs provides "
"some additional functions for working with defuns: "
"@code{treesit-defun-at-point} returns the defun node at point, and "
"@code{treesit-defun-name} returns the name of a defun node."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1810
#, no-wrap
msgid "treesit-defun-at-point"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1815
msgid ""
"This function returns the defun node at point, or @code{nil} if none is "
"found.  It respects @code{treesit-defun-tactic}: if its value is "
"@code{top-level}, this function returns the top-level defun, and if its "
"value is @code{nested}, it returns the immediate enclosing defun."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1818
msgid ""
"This function requires @code{treesit-defun-type-regexp} to work.  If it is "
"@code{nil}, this function simply returns @code{nil}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1820
#, no-wrap
msgid "treesit-defun-name node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1824
msgid ""
"This function returns the defun name of @var{node}.  It returns @code{nil} "
"if there is no defun name for @var{node}, or if @var{node} is not a defun "
"node, or if @var{node} is @code{nil}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1827
msgid ""
"Depending on the language and major mode, the defun names are names like "
"function name, class name, struct name, etc."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1830
msgid ""
"If @code{treesit-defun-name-function} is @code{nil}, this function always "
"returns @code{nil}."
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:1832
#, no-wrap
msgid "treesit-defun-name-function"
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:1839
msgid ""
"If non-@code{nil}, this variable's value should be a function that is called "
"with a node as its argument, and returns the defun name of the node.  The "
"function should have the same semantics as @code{treesit-defun-name}: if the "
"node is not a defun node, or the node is a defun node but doesn't have a "
"name, or the node is @code{nil}, it should return @code{nil}."
msgstr ""

#. type: section
#: original_texis/parsing.texi:1842
#, no-wrap
msgid "Tree-sitter C API Correspondence"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1846
msgid ""
"Emacs' tree-sitter integration doesn't expose every feature provided by "
"tree-sitter's C API@.  Missing features include:"
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1850
msgid "Creating a tree cursor and navigating the syntax tree with it."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1852
msgid "Setting timeout and cancellation flag for a parser."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1854
msgid "Setting the logger for a parser."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1856
msgid "Printing a @acronym{DOT} graph of the syntax tree to a file."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1859
msgid "Copying and modifying a syntax tree.  (Emacs doesn't expose a tree object.)"
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1861
msgid "Using (row, column) coordinates as position."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1864
msgid ""
"Updating a node with changes.  (In Emacs, retrieve a new node instead of "
"updating the existing one.)"
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1866
msgid "Querying statics of a language grammar."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1870
msgid ""
"In addition, Emacs makes some changes to the C API to make the API more "
"convenient and idiomatic:"
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1875
msgid ""
"Instead of using byte positions, the Emacs Lisp API uses character "
"positions."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1877
msgid "Null nodes are converted to @code{nil}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1883
msgid ""
"Below is the correspondence between all C API functions and their ELisp "
"counterparts.  Sometimes one ELisp function corresponds to multiple C "
"functions, and many C functions don't have an ELisp counterpart."
msgstr ""

#. type: example
#: original_texis/parsing.texi:1985
#, no-wrap
msgid ""
"ts_parser_new                           treesit-parser-create\n"
"ts_parser_delete\n"
"ts_parser_set_language\n"
"ts_parser_language                      treesit-parser-language\n"
"ts_parser_set_included_ranges           treesit-parser-set-included-ranges\n"
"ts_parser_included_ranges               treesit-parser-included-ranges\n"
"ts_parser_parse\n"
"ts_parser_parse_string                  treesit-parse-string\n"
"ts_parser_parse_string_encoding\n"
"ts_parser_reset\n"
"ts_parser_set_timeout_micros\n"
"ts_parser_timeout_micros\n"
"ts_parser_set_cancellation_flag\n"
"ts_parser_cancellation_flag\n"
"ts_parser_set_logger\n"
"ts_parser_logger\n"
"ts_parser_print_dot_graphs\n"
"ts_tree_copy\n"
"ts_tree_delete\n"
"ts_tree_root_node\n"
"ts_tree_language\n"
"ts_tree_edit\n"
"ts_tree_get_changed_ranges\n"
"ts_tree_print_dot_graph\n"
"ts_node_type                            treesit-node-type\n"
"ts_node_symbol\n"
"ts_node_start_byte                      treesit-node-start\n"
"ts_node_start_point\n"
"ts_node_end_byte                        treesit-node-end\n"
"ts_node_end_point\n"
"ts_node_string                          treesit-node-string\n"
"ts_node_is_null\n"
"ts_node_is_named                        treesit-node-check\n"
"ts_node_is_missing                      treesit-node-check\n"
"ts_node_is_extra                        treesit-node-check\n"
"ts_node_has_changes\n"
"ts_node_has_error                       treesit-node-check\n"
"ts_node_parent                          treesit-node-parent\n"
"ts_node_child                           treesit-node-child\n"
"ts_node_field_name_for_child            treesit-node-field-name-for-child\n"
"ts_node_child_count                     treesit-node-child-count\n"
"ts_node_named_child                     treesit-node-child\n"
"ts_node_named_child_count               treesit-node-child-count\n"
"ts_node_child_by_field_name             treesit-node-child-by-field-name\n"
"ts_node_child_by_field_id\n"
"ts_node_next_sibling                    treesit-node-next-sibling\n"
"ts_node_prev_sibling                    treesit-node-prev-sibling\n"
"ts_node_next_named_sibling              treesit-node-next-sibling\n"
"ts_node_prev_named_sibling              treesit-node-prev-sibling\n"
"ts_node_first_child_for_byte            treesit-node-first-child-for-pos\n"
"ts_node_first_named_child_for_byte      treesit-node-first-child-for-pos\n"
"ts_node_descendant_for_byte_range       treesit-node-descendant-for-range\n"
"ts_node_descendant_for_point_range\n"
"ts_node_named_descendant_for_byte_range treesit-node-descendant-for-range\n"
"ts_node_named_descendant_for_point_range\n"
"ts_node_edit\n"
"ts_node_eq                              treesit-node-eq\n"
"ts_tree_cursor_new\n"
"ts_tree_cursor_delete\n"
"ts_tree_cursor_reset\n"
"ts_tree_cursor_current_node\n"
"ts_tree_cursor_current_field_name\n"
"ts_tree_cursor_current_field_id\n"
"ts_tree_cursor_goto_parent\n"
"ts_tree_cursor_goto_next_sibling\n"
"ts_tree_cursor_goto_first_child\n"
"ts_tree_cursor_goto_first_child_for_byte\n"
"ts_tree_cursor_goto_first_child_for_point\n"
"ts_tree_cursor_copy\n"
"ts_query_new\n"
"ts_query_delete\n"
"ts_query_pattern_count\n"
"ts_query_capture_count\n"
"ts_query_string_count\n"
"ts_query_start_byte_for_pattern\n"
"ts_query_predicates_for_pattern\n"
"ts_query_step_is_definite\n"
"ts_query_capture_name_for_id\n"
"ts_query_string_value_for_id\n"
"ts_query_disable_capture\n"
"ts_query_disable_pattern\n"
"ts_query_cursor_new\n"
"ts_query_cursor_delete\n"
"ts_query_cursor_exec                    treesit-query-capture\n"
"ts_query_cursor_did_exceed_match_limit\n"
"ts_query_cursor_match_limit\n"
"ts_query_cursor_set_match_limit\n"
"ts_query_cursor_set_byte_range\n"
"ts_query_cursor_set_point_range\n"
"ts_query_cursor_next_match\n"
"ts_query_cursor_remove_match\n"
"ts_query_cursor_next_capture\n"
"ts_language_symbol_count\n"
"ts_language_symbol_name\n"
"ts_language_symbol_for_name\n"
"ts_language_field_count\n"
"ts_language_field_name_for_id\n"
"ts_language_field_id_for_name\n"
"ts_language_symbol_type\n"
"ts_language_version\n"
msgstr ""
