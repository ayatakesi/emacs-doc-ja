# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2024-10-06 07:31+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: original_texis/parsing.texi:5 original_texis/parsing.texi:6
#, no-wrap
msgid "Parsing Program Source"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:7
#, no-wrap
msgid "parsing program source"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:9
#, no-wrap
msgid "syntax tree, from parsing program source"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:16
msgid ""
"Emacs provides various ways to parse program source text and produce a "
"@dfn{syntax tree}.  In a syntax tree, text is no longer considered a "
"one-dimensional stream of characters, but a structured tree of nodes, where "
"each node represents a piece of text.  Thus, a syntax tree can enable "
"interesting features like precise fontification, indentation, navigation, "
"structured editing, etc."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:20
msgid ""
"Emacs has a simple facility for parsing balanced expressions (@pxref{Parsing "
"Expressions}).  There is also the SMIE library for generic navigation and "
"indentation (@pxref{SMIE})."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:26
msgid ""
"In addition to those, Emacs also provides integration with "
"@uref{https://tree-sitter.github.io/tree-sitter, the tree-sitter library} if "
"support for it was compiled in.  The tree-sitter library implements an "
"incremental parser and has support for a wide range of programming "
"languages."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:27
#, no-wrap
msgid "treesit-available-p"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:30
msgid ""
"This function returns non-@code{nil} if tree-sitter features are available "
"for the current Emacs session."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:41
msgid ""
"To be able to parse the program source using the tree-sitter library and "
"access the syntax tree of the program, a Lisp program needs to load a "
"language grammar library, and create a parser for that language and the "
"current buffer.  After that, the Lisp program can query the parser about "
"specific nodes of the syntax tree.  Then, it can access various kinds of "
"information about each node, and search for nodes using a powerful "
"pattern-matching syntax.  This chapter explains how to do all this, and also "
"how a Lisp program can work with source files that mix multiple programming "
"languages."
msgstr ""

#. type: node
#: original_texis/parsing.texi:52 original_texis/parsing.texi:54
#, no-wrap
msgid "Language Grammar"
msgstr ""

#. type: menuentry
#: original_texis/parsing.texi:52
msgid "Loading tree-sitter language grammar."
msgstr ""

#. type: node
#: original_texis/parsing.texi:52 original_texis/parsing.texi:388
#, no-wrap
msgid "Using Parser"
msgstr ""

#. type: menuentry
#: original_texis/parsing.texi:52
msgid "Introduction to parsers."
msgstr ""

#. type: section
#: original_texis/parsing.texi:52 original_texis/parsing.texi:543 original_texis/parsing.texi:544
#, no-wrap
msgid "Retrieving Nodes"
msgstr ""

#. type: menuentry
#: original_texis/parsing.texi:52
msgid "Retrieving nodes from a syntax tree."
msgstr ""

#. type: section
#: original_texis/parsing.texi:52 original_texis/parsing.texi:965 original_texis/parsing.texi:966
#, no-wrap
msgid "Accessing Node Information"
msgstr ""

#. type: menuentry
#: original_texis/parsing.texi:52
msgid "Accessing node information."
msgstr ""

#. type: node
#: original_texis/parsing.texi:52 original_texis/parsing.texi:1118
#, no-wrap
msgid "Pattern Matching"
msgstr ""

#. type: menuentry
#: original_texis/parsing.texi:52
msgid "Pattern matching with query patterns."
msgstr ""

#. type: node
#: original_texis/parsing.texi:52 original_texis/parsing.texi:1524
#, no-wrap
msgid "User-defined Things"
msgstr ""

#. type: menuentry
#: original_texis/parsing.texi:52
msgid "User-defined ``Things'' and Navigation."
msgstr ""

#. type: node
#: original_texis/parsing.texi:52 original_texis/parsing.texi:1673
#, no-wrap
msgid "Multiple Languages"
msgstr ""

#. type: menuentry
#: original_texis/parsing.texi:52
msgid "Parse text written in multiple languages."
msgstr ""

#. type: node
#: original_texis/parsing.texi:52 original_texis/parsing.texi:2004
#, no-wrap
msgid "Tree-sitter Major Modes"
msgstr ""

#. type: menuentry
#: original_texis/parsing.texi:52
msgid "Develop major modes using tree-sitter."
msgstr ""

#. type: node
#: original_texis/parsing.texi:52 original_texis/parsing.texi:2159
#, no-wrap
msgid "Tree-sitter C API"
msgstr ""

#. type: menuentry
#: original_texis/parsing.texi:52
msgid "Compare the C API and the ELisp API."
msgstr ""

#. type: section
#: original_texis/parsing.texi:55
#, no-wrap
msgid "Tree-sitter Language Grammar"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:56
#, no-wrap
msgid "language grammar, for tree-sitter"
msgstr ""

#. type: heading
#: original_texis/parsing.texi:58
#, no-wrap
msgid "Loading a language grammar"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:59
#, no-wrap
msgid "loading language grammar for tree-sitter"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:61
#, no-wrap
msgid "language argument, for tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:67
msgid ""
"Tree-sitter relies on language grammar to parse text in that language.  In "
"Emacs, a language grammar is represented by a symbol.  For example, the C "
"language grammar is represented as the symbol @code{c}, and @code{c} can be "
"passed to tree-sitter functions as the @var{language} argument."
msgstr ""

#. type: vindex
#: original_texis/parsing.texi:68
#, no-wrap
msgid "treesit-extra-load-path"
msgstr ""

#. type: vindex
#: original_texis/parsing.texi:69
#, no-wrap
msgid "treesit-load-language-error"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:74
msgid ""
"Tree-sitter language grammars are distributed as dynamic libraries.  In "
"order to use a language grammar in Emacs, you need to make sure that the "
"dynamic library is installed on the system.  Emacs looks for language "
"grammars in several places, in the following order:"
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:79
msgid ""
"first, in the list of directories specified by the variable "
"@code{treesit-extra-load-path};"
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:82
msgid ""
"then, in the @file{tree-sitter} subdirectory of the directory specified by "
"@code{user-emacs-directory} (@pxref{Init File});"
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:84
msgid "and finally, in the system's default locations for dynamic libraries."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:88
msgid ""
"In each of these directories, Emacs looks for a file with file-name "
"extensions specified by the variable @code{dynamic-library-suffixes}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:92
msgid ""
"If Emacs cannot find the library or has problems loading it, Emacs signals "
"the @code{treesit-load-language-error} error.  The data of that signal could "
"be one of the following:"
msgstr ""

#. type: item
#: original_texis/parsing.texi:94
#, no-wrap
msgid "(not-found @var{error-msg} @dots{})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:96
msgid "This means that Emacs could not find the language grammar library."
msgstr ""

#. type: item
#: original_texis/parsing.texi:96
#, no-wrap
msgid "(symbol-error @var{error-msg})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:99
msgid ""
"This means that Emacs could not find in the library the expected function "
"that every language grammar library should export."
msgstr ""

#. type: item
#: original_texis/parsing.texi:99
#, no-wrap
msgid "(version-mismatch @var{error-msg})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:102
msgid ""
"This means that the version of the language grammar library is incompatible "
"with that of the tree-sitter library."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:107
msgid ""
"In all of these cases, @var{error-msg} might provide additional details "
"about the failure."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:108
#, no-wrap
msgid "treesit-language-available-p language &optional detail"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:111
msgid ""
"This function returns non-@code{nil} if the language grammar for "
"@var{language} exists and can be loaded."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:116
msgid ""
"If @var{detail} is non-@code{nil}, return @code{(t . nil)} when "
"@var{language} is available, and @code{(nil . @var{data})} when it's "
"unavailable.  @var{data} is the signal data of "
"@code{treesit-load-language-error}."
msgstr ""

#. type: vindex
#: original_texis/parsing.texi:118
#, no-wrap
msgid "treesit-load-name-override-list"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:125
msgid ""
"By convention, the file name of the dynamic library for @var{language} is "
"@file{libtree-sitter-@var{language}.@var{ext}}, where @var{ext} is the "
"system-specific extension for dynamic libraries.  Also by convention, the "
"function provided by that library is named "
"@code{tree_sitter_@var{language}}.  If a language grammar library doesn't "
"follow this convention, you should add an entry"
msgstr ""

#. type: example
#: original_texis/parsing.texi:128
#, no-wrap
msgid "(@var{language} @var{library-base-name} @var{function-name})\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:135
msgid ""
"to the list in the variable @code{treesit-load-name-override-list}, where "
"@var{library-base-name} is the basename of the dynamic library's file name "
"(usually, @file{libtree-sitter-@var{language}}), and @var{function-name} is "
"the function provided by the library (usually, "
"@code{tree_sitter_@var{language}}).  For example,"
msgstr ""

#. type: example
#: original_texis/parsing.texi:138
#, no-wrap
msgid "(cool-lang \"libtree-sitter-coool\" \"tree_sitter_cooool\")\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:143
msgid "for a language that considers itself too ``cool'' to abide by conventions."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:144
#, no-wrap
msgid "language grammar version, compatibility"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:145
#, no-wrap
msgid "treesit-library-abi-version &optional min-compatible"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:155
msgid ""
"This function returns the version of the language grammar Application Binary "
"Interface (@acronym{ABI}) supported by the tree-sitter library.  By default, "
"it returns the latest ABI version supported by the library, but if "
"@var{min-compatible} is non-@code{nil}, it returns the oldest ABI version "
"which the library still can support.  Language grammar libraries must be "
"built for ABI versions between the oldest and the latest versions supported "
"by the tree-sitter library, otherwise the library will be unable to load "
"them."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:157
#, no-wrap
msgid "treesit-language-abi-version language"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:161
msgid ""
"This function returns the @acronym{ABI} version of the language grammar "
"library loaded by Emacs for @var{language}.  If @var{language} is "
"unavailable, this function returns @code{nil}."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:163
#, no-wrap
msgid "Concrete syntax tree"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:164
#, no-wrap
msgid "syntax tree, concrete"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:169
msgid ""
"A syntax tree is what a parser generates.  In a syntax tree, each node "
"represents a piece of text, and is connected to each other by a parent-child "
"relationship.  For example, if the source text is"
msgstr ""

#. type: example
#: original_texis/parsing.texi:172
#, no-wrap
msgid "1 + 2\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:176
msgid "its syntax tree could be"
msgstr ""

#. type: group
#: original_texis/parsing.texi:190
#, no-wrap
msgid ""
"                  +--------------+\n"
"                  | root \"1 + 2\" |\n"
"                  +--------------+\n"
"                         |\n"
"        +--------------------------------+\n"
"        |       expression \"1 + 2\"       |\n"
"        +--------------------------------+\n"
"           |             |            |\n"
"+------------+   +--------------+   +------------+\n"
"| number \"1\" |   | operator \"+\" |   | number \"2\" |\n"
"+------------+   +--------------+   +------------+\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:194
msgid "We can also represent it as an s-expression:"
msgstr ""

#. type: example
#: original_texis/parsing.texi:197
#, no-wrap
msgid "(root (expression (number) (operator) (number)))\n"
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:199
#, no-wrap
msgid "Node types"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:200
#, no-wrap
msgid "node types, in a syntax tree"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:202
#, no-wrap
msgid "type of node, tree-sitter"
msgstr ""

#. type: anchor{#1}
#: original_texis/parsing.texi:204
msgid "tree-sitter node type"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:204
#, no-wrap
msgid "named node, tree-sitter"
msgstr ""

#. type: anchor{#1}
#: original_texis/parsing.texi:206
msgid "tree-sitter named node"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:206
#, no-wrap
msgid "anonymous node, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:214
msgid ""
"Names like @code{root}, @code{expression}, @code{number}, and "
"@code{operator} specify the @dfn{type} of the nodes.  However, not all nodes "
"in a syntax tree have a type.  Nodes that don't have a type are known as "
"@dfn{anonymous nodes}, and nodes with a type are @dfn{named nodes}.  "
"Anonymous nodes are tokens with fixed spellings, including punctuation "
"characters like bracket @samp{]}, and keywords like @code{return}."
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:215
#, no-wrap
msgid "Field names"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:217
#, no-wrap
msgid "field name, tree-sitter"
msgstr ""

#. type: anchor{#1}
#: original_texis/parsing.texi:218 original_texis/parsing.texi:224
#, no-wrap
msgid "tree-sitter node field name"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:224
msgid ""
"To make the syntax tree easier to analyze, many language grammar assign "
"@dfn{field names} to child nodes.  For example, a @code{function_definition} "
"node could have a @code{declarator} and a @code{body}:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:230
#, no-wrap
msgid ""
"(function_definition\n"
" declarator: (declaration)\n"
" body: (compound_statement))\n"
msgstr ""

#. type: heading
#: original_texis/parsing.texi:233
#, no-wrap
msgid "Exploring the syntax tree"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:234
#, no-wrap
msgid "explore tree-sitter syntax tree"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:235
#, no-wrap
msgid "inspection of tree-sitter parse tree nodes"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:242
msgid ""
"To aid in understanding the syntax of a language and in debugging Lisp "
"programs that use the syntax tree, Emacs provides an ``explore'' mode, which "
"displays the syntax tree of the source in the current buffer in real time.  "
"Emacs also comes with an ``inspect mode'', which displays information of the "
"nodes at point in the mode-line."
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:243
#, no-wrap
msgid "Command treesit-explore-mode"
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:249
msgid ""
"This mode pops up a window displaying the syntax tree of the source in the "
"current buffer.  Selecting text in the source buffer highlights the "
"corresponding nodes in the syntax tree display.  Clicking on nodes in the "
"syntax tree highlights the corresponding text in the source buffer."
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:251
#, no-wrap
msgid "Command treesit-inspect-mode"
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:254
msgid ""
"This minor mode displays on the mode-line the node that @emph{starts} at "
"point.  For example, the mode-line can display"
msgstr ""

#. type: example
#: original_texis/parsing.texi:257
#, no-wrap
msgid "@var{parent} @var{field}: (@var{node} (@var{child} (@dots{})))\n"
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:264
msgid ""
"where @var{node}, @var{child}, etc., are nodes which begin at point.  "
"@var{parent} is the parent of @var{node}.  @var{node} is displayed in a bold "
"typeface.  @var{field-name}s are field names of @var{node} and of "
"@var{child}, etc."
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:268
msgid ""
"If no node starts at point, i.e., point is in the middle of a node, then the "
"mode line displays the earliest node that spans point, and its immediate "
"parent."
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:271
msgid ""
"This minor mode doesn't create parsers on its own.  It uses the first parser "
"in @code{(treesit-parser-list)} (@pxref{Using Parser})."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:273
#, no-wrap
msgid "Reading the grammar definition"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:274
#, no-wrap
msgid "reading grammar definition, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:280
msgid ""
"Authors of language grammars define the @dfn{grammar} of a programming "
"language, which determines how a parser constructs a concrete syntax tree "
"out of the program text.  In order to use the syntax tree effectively, you "
"need to consult the @dfn{grammar file}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:286
msgid ""
"The grammar file is usually @file{grammar.js} in a language grammar's "
"project repository.  The link to a language grammar's home page can be found "
"on @uref{https://tree-sitter.github.io/tree-sitter, tree-sitter's homepage}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:289
msgid ""
"The grammar definition is written in JavaScript.  For example, the rule "
"matching a @code{function_definition} node may look like"
msgstr ""

#. type: group
#: original_texis/parsing.texi:297
#, no-wrap
msgid ""
"function_definition: $ => seq(\n"
"  $.declaration_specifiers,\n"
"  field('declarator', $.declaration),\n"
"  field('body', $.compound_statement)\n"
")\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:307
msgid ""
"The rules are represented by functions that take a single argument @var{$}, "
"representing the whole grammar.  The function itself is constructed by other "
"functions: the @code{seq} function puts together a sequence of children; the "
"@code{field} function annotates a child with a field name.  If we write the "
"above definition in the so-called @dfn{Backus-Naur Form} (@acronym{BNF}) "
"syntax, it would look like"
msgstr ""

#. type: group
#: original_texis/parsing.texi:312
#, no-wrap
msgid ""
"function_definition :=\n"
"  <declaration_specifiers> <declaration> <compound_statement>\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:317
msgid "and the node returned by the parser would look like"
msgstr ""

#. type: group
#: original_texis/parsing.texi:324
#, no-wrap
msgid ""
"(function_definition\n"
"  (declaration_specifier)\n"
"  declarator: (declaration)\n"
"  body: (compound_statement))\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:329
msgid ""
"Below is a list of functions that one can see in a grammar definition.  Each "
"function takes other rules as arguments and returns a new rule."
msgstr ""

#. type: item
#: original_texis/parsing.texi:331
#, no-wrap
msgid "seq(@var{rule1}, @var{rule2}, @dots{})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:333
msgid "matches each rule one after another."
msgstr ""

#. type: item
#: original_texis/parsing.texi:333
#, no-wrap
msgid "choice(@var{rule1}, @var{rule2}, @dots{})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:335
msgid "matches one of the rules in its arguments."
msgstr ""

#. type: item
#: original_texis/parsing.texi:335
#, no-wrap
msgid "repeat(@var{rule})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:338
msgid ""
"matches @var{rule} @emph{zero or more} times.  This is like the @samp{*} "
"operator in regular expressions."
msgstr ""

#. type: item
#: original_texis/parsing.texi:338
#, no-wrap
msgid "repeat1(@var{rule})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:341
msgid ""
"matches @var{rule} @emph{one or more} times.  This is like the @samp{+} "
"operator in regular expressions."
msgstr ""

#. type: item
#: original_texis/parsing.texi:341
#, no-wrap
msgid "optional(@var{rule})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:344
msgid ""
"matches @var{rule} @emph{zero or one} times.  This is like the @samp{?} "
"operator in regular expressions."
msgstr ""

#. type: item
#: original_texis/parsing.texi:344
#, no-wrap
msgid "field(@var{name}, @var{rule})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:346
msgid "assigns field name @var{name} to the child node matched by @var{rule}."
msgstr ""

#. type: item
#: original_texis/parsing.texi:346
#, no-wrap
msgid "alias(@var{rule}, @var{alias})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:349
msgid ""
"makes nodes matched by @var{rule} appear as @var{alias} in the syntax tree "
"generated by the parser.  For example,"
msgstr ""

#. type: example
#: original_texis/parsing.texi:352
#, no-wrap
msgid "alias(preprocessor_call_exp, call_expression)\n"
msgstr ""

#. type: table
#: original_texis/parsing.texi:357
msgid ""
"makes any node matched by @code{preprocessor_call_exp} appear as "
"@code{call_expression}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:361
msgid ""
"Below are grammar functions of lesser importance for reading a language "
"grammar."
msgstr ""

#. type: item
#: original_texis/parsing.texi:363
#, no-wrap
msgid "token(@var{rule})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:368
msgid ""
"marks @var{rule} to produce a single leaf node.  That is, instead of "
"generating a parent node with individual child nodes under it, everything is "
"combined into a single leaf node.  @xref{Retrieving Nodes}."
msgstr ""

#. type: item
#: original_texis/parsing.texi:368
#, no-wrap
msgid "token.immediate(@var{rule})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:372
msgid ""
"Normally, grammar rules ignore preceding whitespace; this changes @var{rule} "
"to match only when there is no preceding whitespace."
msgstr ""

#. type: item
#: original_texis/parsing.texi:372
#, no-wrap
msgid "prec(@var{n}, @var{rule})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:374
msgid "gives @var{rule} the level-@var{n} precedence."
msgstr ""

#. type: item
#: original_texis/parsing.texi:374
#, no-wrap
msgid "prec.left([@var{n},] @var{rule})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:376
msgid "marks @var{rule} as left-associative, optionally with level @var{n}."
msgstr ""

#. type: item
#: original_texis/parsing.texi:376
#, no-wrap
msgid "prec.right([@var{n},] @var{rule})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:378
msgid "marks @var{rule} as right-associative, optionally with level @var{n}."
msgstr ""

#. type: item
#: original_texis/parsing.texi:378
#, no-wrap
msgid "prec.dynamic(@var{n}, @var{rule})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:381
msgid "this is like @code{prec}, but the precedence is applied at runtime instead."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:387
msgid ""
"The documentation of the tree-sitter project has "
"@uref{https://tree-sitter.github.io/tree-sitter/creating-parsers, more about "
"writing a grammar}.  Read especially ``The Grammar DSL'' section."
msgstr ""

#. type: section
#: original_texis/parsing.texi:389
#, no-wrap
msgid "Using Tree-sitter Parser"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:390
#, no-wrap
msgid "tree-sitter parser, using"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:396
msgid ""
"This section describes how to create and configure a tree-sitter parser.  In "
"Emacs, each tree-sitter parser is associated with a buffer.  As the user "
"edits the buffer, the associated parser and syntax tree are automatically "
"kept up-to-date."
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:397
#, no-wrap
msgid "treesit-max-buffer-size"
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:401
msgid ""
"This variable contains the maximum size of buffers in which tree-sitter can "
"be activated.  Major modes should check this value when deciding whether to "
"enable tree-sitter features."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:403
#, no-wrap
msgid "creating tree-sitter parsers"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:404
#, no-wrap
msgid "tree-sitter parser, creating"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:405
#, no-wrap
msgid "treesit-parser-create language &optional buffer no-reuse tag"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:409
msgid ""
"Create a parser for the specified @var{buffer} and @var{language} "
"(@pxref{Language Grammar}), with @var{tag}.  If @var{buffer} is omitted or "
"@code{nil}, it stands for the current buffer."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:413
msgid ""
"By default, this function reuses a parser if one already exists for "
"@var{language} with @var{tag} in @var{buffer}, but if @var{no-reuse} is "
"non-@code{nil}, this function always creates a new parser."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:416
msgid ""
"@var{tag} can be any symbol except @code{t}, and defaults to @code{nil}.  "
"Different parsers can have the same tag."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:423
msgid ""
"If that buffer is an indirect buffer, its base buffer is used instead.  That "
"is, indirect buffers use their base buffer's parsers.  If the base buffer is "
"narrowed, an indirect buffer might not be able to retrieve information of "
"the portion of the buffer text that is invisible in the base buffer.  Lisp "
"programs should widen as necessary should they want to use a parser in an "
"indirect buffer."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:426
msgid "Given a parser, we can query information about it."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:427
#, no-wrap
msgid "treesit-parser-buffer parser"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:429
msgid "This function returns the buffer associated with @var{parser}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:431
#, no-wrap
msgid "treesit-parser-language parser"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:433
msgid "This function returns the language used by @var{parser}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:435
#, no-wrap
msgid "treesit-parser-p object"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:438
msgid ""
"This function checks if @var{object} is a tree-sitter parser, and returns "
"non-@code{nil} if it is, and @code{nil} otherwise."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:446
msgid ""
"There is no need to explicitly parse a buffer, because parsing is done "
"automatically and lazily.  A parser only parses when a Lisp program queries "
"for a node in its syntax tree.  Therefore, when a parser is first created, "
"it doesn't parse the buffer; it waits until the Lisp program queries for a "
"node for the first time.  Similarly, when some change is made in the buffer, "
"a parser doesn't re-parse immediately."
msgstr ""

#. type: vindex
#: original_texis/parsing.texi:447
#, no-wrap
msgid "treesit-buffer-too-large"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:452
msgid ""
"When a parser does parse, it checks for the size of the buffer.  Tree-sitter "
"can only handle buffers no larger than about 4GB@.  If the size exceeds "
"that, Emacs signals the @code{treesit-buffer-too-large} error with signal "
"data being the buffer size."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:457
msgid ""
"Once a parser is created, Emacs automatically adds it to the internal parser "
"list.  Every time a change is made to the buffer, Emacs updates parsers in "
"this list so they can update their syntax tree incrementally."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:458
#, no-wrap
msgid "treesit-parser-list &optional buffer language tag"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:464
msgid ""
"This function returns the parser list of @var{buffer}, filtered by "
"@var{language} and @var{tag}.  If @var{buffer} is @code{nil} or omitted, it "
"defaults to the current buffer.  If that buffer is an indirect buffer, its "
"base buffer is used instead.  That is, indirect buffers use their base "
"buffer's parsers."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:469
msgid ""
"If @var{language} is non-@var{nil}, only include parsers for that language, "
"and only include parsers with @var{tag}.  @var{tag} defaults to @code{nil}.  "
"If @var{tag} is @code{t}, include parsers in the returned list regardless of "
"their tag."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:471
#, no-wrap
msgid "treesit-parser-delete parser"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:473
msgid "This function deletes @var{parser}."
msgstr ""

#. type: anchor{#1}
#: original_texis/parsing.texi:475 original_texis/parsing.texi:485
#, no-wrap
msgid "tree-sitter narrowing"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:485
msgid ""
"Normally, a parser ``sees'' the whole buffer, but when the buffer is "
"narrowed (@pxref{Narrowing}), the parser will only see the accessible "
"portion of the buffer.  As far as the parser can tell, the hidden region was "
"deleted.  When the buffer is later widened, the parser thinks text is "
"inserted at the beginning and at the end.  Although parsers respect "
"narrowing, modes should not use narrowing as a means to handle a "
"multi-language buffer; instead, set the ranges in which the parser should "
"operate.  @xref{Multiple Languages}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:490
msgid ""
"Because a parser parses lazily, when the user or a Lisp program narrows the "
"buffer, the parser is not affected immediately; as long as the mode doesn't "
"query for a node while the buffer is narrowed, the parser is oblivious of "
"the narrowing."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:491
#, no-wrap
msgid "tree-sitter parse string"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:492
#, no-wrap
msgid "parse string, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:496
msgid ""
"Besides creating a parser for a buffer, a Lisp program can also parse a "
"string.  Unlike a buffer, parsing a string is a one-off operation, and there "
"is no way to update the result."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:497
#, no-wrap
msgid "treesit-parse-string string language"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:500
msgid ""
"This function parses @var{string} using @var{language}, and returns the root "
"node of the generated syntax tree."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:502
#, no-wrap
msgid "Be notified by changes to the parse tree"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:503
#, no-wrap
msgid "update callback, for tree-sitter parse-tree"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:504
#, no-wrap
msgid "after-change notifier, for tree-sitter parse-tree"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:505
#, no-wrap
msgid "tree-sitter parse-tree, update and after-change callback"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:506
#, no-wrap
msgid "notifiers, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:513
msgid ""
"A Lisp program might want to be notified of text affected by incremental "
"parsing.  For example, inserting a comment-closing token converts text "
"before that token into a comment.  Even though the text is not directly "
"edited, it is deemed to be ``changed'' nevertheless."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:520
msgid ""
"Emacs lets a Lisp program register callback functions (a.k.a.@: "
"@dfn{notifiers}) for these kinds of changes.  A notifier function takes two "
"arguments: @var{ranges} and @var{parser}.  @var{ranges} is a list of cons "
"cells of the form @w{@code{(@var{start} . @var{end})}}, where @var{start} "
"and @var{end} mark the start and the end positions of a range.  @var{parser} "
"is the parser issuing the notification."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:526
msgid ""
"Every time a parser reparses a buffer, it compares the old and new "
"parse-tree, computes the ranges in which nodes have changed, and passes the "
"ranges to notifier functions.  Note that the initial parse is also "
"considered a ``change'', so notifier functions are called on the initial "
"parse, with range being the whole buffer."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:527
#, no-wrap
msgid "treesit-parser-add-notifier parser function"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:531
msgid ""
"This function adds @var{function} to @var{parser}'s list of after-change "
"notifier functions.  @var{function} must be a function symbol, not a lambda "
"function (@pxref{Anonymous Functions})."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:533
#, no-wrap
msgid "treesit-parser-remove-notifier parser function"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:537
msgid ""
"This function removes @var{function} from the list of @var{parser}'s "
"after-change notifier functions.  @var{function} must be a function symbol, "
"rather than a lambda function."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:539
#, no-wrap
msgid "treesit-parser-notifiers parser"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:541
msgid "This function returns the list of @var{parser}'s notifier functions."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:545
#, no-wrap
msgid "retrieve node, tree-sitter"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:546
#, no-wrap
msgid "tree-sitter, find node"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:547
#, no-wrap
msgid "get node, tree-sitter"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:549
#, no-wrap
msgid "terminology, for tree-sitter functions"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:552
msgid ""
"Here are some terms and conventions we use when documenting tree-sitter "
"functions."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:562
msgid ""
"A node in a syntax tree spans some portion of the program text in the "
"buffer.  We say that a node is ``smaller'' or ``larger'' than another if it "
"spans, respectively, a smaller or larger portion of buffer text than the "
"other node.  Since nodes that are deeper (``lower'') in the tree are "
"children of the nodes that are ``higher'' in the tree, it follows that a "
"lower node will always be smaller than a node that is higher in the node "
"hierarchy.  A node that is higher up in the syntax tree contains one or more "
"smaller nodes as its children, and therefore spans a larger portion of "
"buffer text."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:567
msgid ""
"When a function cannot find a node, it returns @code{nil}.  For convenience, "
"all functions that take a node as argument and return a node, also accept "
"the node argument of @code{nil} and in that case just return @code{nil}."
msgstr ""

#. type: vindex
#: original_texis/parsing.texi:568
#, no-wrap
msgid "treesit-node-outdated"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:572
msgid ""
"Nodes are not automatically updated when the associated buffer is modified, "
"and there is no way to update a node once it is retrieved.  Using an "
"outdated node signals the @code{treesit-node-outdated} error."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:573
#, no-wrap
msgid "Retrieving nodes from syntax tree"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:574
#, no-wrap
msgid "retrieving tree-sitter nodes"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:575
#, no-wrap
msgid "syntax tree, retrieving nodes"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:577
#, no-wrap
msgid "leaf node, of tree-sitter parse tree"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:578
#, no-wrap
msgid "tree-sitter parse tree, leaf node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:579
#, no-wrap
msgid "treesit-node-at pos &optional parser-or-lang named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:582
msgid ""
"This function returns a @dfn{leaf} node at buffer position @var{pos}.  A "
"leaf node is a node that doesn't have any child nodes."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:586
msgid ""
"This function tries to return a node whose span covers @var{pos}: the node's "
"beginning position is less than or equal to @var{pos}, and the node's end "
"position is greater than or equal to @var{pos}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:590
msgid ""
"If no leaf node's span covers @var{pos} (e.g., @var{pos} is in the "
"whitespace between two leaf nodes), this function returns the first leaf "
"node after @var{pos}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:593
msgid ""
"Finally, if there is no leaf node after @var{pos}, return the first leaf "
"node before @var{pos}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:600
msgid ""
"If @var{parser-or-lang} is a parser object, this function uses that parser; "
"if @var{parser-or-lang} is a language, this function uses the first parser "
"for that language in the current buffer, or creates one if none exists; if "
"@var{parser-or-lang} is @code{nil}, this function tries to guess the "
"language at @var{pos} by calling @code{treesit-language-at} (@pxref{Multiple "
"Languages})."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:603
msgid ""
"If this function cannot find a suitable node to return, it returns "
"@code{nil}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:606
msgid ""
"If @var{named} is non-@code{nil}, this function looks only for named nodes "
"(@pxref{tree-sitter named node, named node})."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:608 original_texis/parsing.texi:1745
msgid "Example:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:614
#, no-wrap
msgid ""
";; Find the node at point in a C parser's syntax tree.\n"
"(treesit-node-at (point) 'c)\n"
"  @result{} #<treesit-node (primitive_type) in 23-27>\n"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:618
#, no-wrap
msgid "treesit-node-on beg end &optional parser-or-lang named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:623
msgid ""
"This function returns the @emph{smallest} node that covers the region of "
"buffer text between @var{beg} and @var{end}.  In other words, the start of "
"the node is before or at @var{beg}, and the end of the node is at or after "
"@var{end}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:629
msgid ""
"@emph{Beware:} calling this function on an empty line that is not inside any "
"top-level construct (function definition, etc.@:) most probably will give "
"you the root node, because the root node is the smallest node that covers "
"that empty line.  Most of the time, you want to use @code{treesit-node-at} "
"instead."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:636
msgid ""
"If @var{parser-or-lang} is a parser object, this function uses that parser; "
"if @var{parser-or-lang} is a language, this function uses the first parser "
"for that language in the current buffer, or creates one if none exists; if "
"@var{parser-or-lang} is @code{nil}, this function tries to guess the "
"language at @var{beg} by calling @code{treesit-language-at}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:639
msgid ""
"If @var{named} is non-@code{nil}, this function looks for a named node only "
"(@pxref{tree-sitter named node, named node})."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:641
#, no-wrap
msgid "treesit-parser-root-node parser"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:644
msgid ""
"This function returns the root node of the syntax tree generated by "
"@var{parser}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:646
#, no-wrap
msgid "treesit-buffer-root-node &optional language"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:652
msgid ""
"This function finds the first parser for @var{language} in the current "
"buffer, or creates one if none exists, and returns the root node generated "
"by that parser.  If @var{language} is omitted, it uses the first parser in "
"the parser list.  If it cannot find an appropriate parser, it returns "
"@code{nil}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:656
msgid ""
"Given a node, a Lisp program can retrieve other nodes starting from it, or "
"query for information about this node."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:657
#, no-wrap
msgid "Retrieving nodes from other nodes"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:658
#, no-wrap
msgid "syntax tree nodes, retrieving from other nodes"
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:660
#, no-wrap
msgid "By kinship"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:661
#, no-wrap
msgid "kinship, syntax tree nodes"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:662
#, no-wrap
msgid "nodes, by kinship"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:663
#, no-wrap
msgid "syntax tree nodes, by kinship"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:665
#, no-wrap
msgid "treesit-node-parent node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:667
msgid "This function returns the immediate parent of @var{node}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:671
msgid ""
"If @var{node} is more than 1000 levels deep in a parse tree, the return "
"value is undefined.  Currently it returns @code{nil}, but that could change "
"in the future."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:673
#, no-wrap
msgid "treesit-node-child node n &optional named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:677
msgid ""
"This function returns the @var{n}'th child of @var{node}.  If @var{named} is "
"non-@code{nil}, it counts only named nodes (@pxref{tree-sitter named node, "
"named node})."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:683
msgid ""
"For example, in a node that represents a string @code{\"text\"}, there are "
"three children nodes: the opening quote @code{\"}, the string text "
"@code{text}, and the closing quote @code{\"}.  Among these nodes, the first "
"child is the opening quote @code{\"}, and the first named child is the "
"string text."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:686
msgid ""
"This function returns @code{nil} if there is no @var{n}'th child.  @var{n} "
"could be negative, e.g., @minus{}1 represents the last child."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:688
#, no-wrap
msgid "treesit-node-children node &optional named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:691
msgid ""
"This function returns all of @var{node}'s children as a list.  If "
"@var{named} is non-@code{nil}, it retrieves only named nodes."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:693
#, no-wrap
msgid "treesit-node-next-sibling node &optional named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:696
msgid ""
"This function finds the next sibling of @var{node}.  If @var{named} is "
"non-@code{nil}, it finds the next named sibling."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:698
#, no-wrap
msgid "treesit-node-prev-sibling node &optional named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:701
msgid ""
"This function finds the previous sibling of @var{node}.  If @var{named} is "
"non-@code{nil}, it finds the previous named sibling."
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:703
#, no-wrap
msgid "By field name"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:704
#, no-wrap
msgid "nodes, by field name"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:705
#, no-wrap
msgid "syntax tree nodes, by field name"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:711
msgid ""
"To make the syntax tree easier to analyze, many language grammars assign "
"@dfn{field names} to child nodes (@pxref{tree-sitter node field name, field "
"name}).  For example, a @code{function_definition} node could have a "
"@code{declarator} child and a @code{body} child."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:712
#, no-wrap
msgid "treesit-node-child-by-field-name node field-name"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:715
msgid ""
"This function finds the child of @var{node} whose field name is "
"@var{field-name}, a string."
msgstr ""

#. type: group
#: original_texis/parsing.texi:721
#, no-wrap
msgid ""
";; Get the child that has \"body\" as its field name.\n"
"(treesit-node-child-by-field-name node \"body\")\n"
"  @result{} #<treesit-node (compound_statement) in 45-89>\n"
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:725
#, no-wrap
msgid "By position"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:726
#, no-wrap
msgid "nodes, by position"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:727
#, no-wrap
msgid "syntax tree nodes, by position"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:729
#, no-wrap
msgid "treesit-node-first-child-for-pos node pos &optional named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:736
msgid ""
"This function finds the first child of @var{node} that extends beyond buffer "
"position @var{pos}.  ``Extends beyond'' means the end of the child node is "
"greater or equal to @var{pos}.  This function only looks for immediate "
"children of @var{node}, and doesn't look in its grandchildren.  If "
"@var{named} is non-@code{nil}, it looks for the first named child "
"(@pxref{tree-sitter named node, named node})."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:738
#, no-wrap
msgid "treesit-node-descendant-for-range node beg end &optional named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:743
msgid ""
"This function finds the @emph{smallest} descendant node of @var{node} that "
"spans the region of text between positions @var{beg} and @var{end}.  It is "
"similar to @code{treesit-node-at}.  If @var{named} is non-@code{nil}, it "
"looks for the smallest named child."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:745
#, no-wrap
msgid "Searching for node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:747
#, no-wrap
msgid "treesit-search-subtree node predicate &optional backward all depth"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:756
msgid ""
"This function traverses the subtree of @var{node} (including @var{node} "
"itself), looking for a node for which @var{predicate} returns "
"non-@code{nil}.  @var{predicate} is a regexp that is matched against each "
"node's type, or a predicate function that takes a node and returns "
"non-@code{nil} if the node matches.  @var{predicate} can also be a thing "
"symbol or thing definition (@pxref{User-defined Things}).  Using an "
"undefined thing doesn't raise an error, the function simply returns "
"@code{nil}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:759
msgid ""
"This function returns the first node that matches, or @code{nil} if none "
"matches @var{predicate}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:767
msgid ""
"By default, this function only traverses named nodes, but if @var{all} is "
"non-@code{nil}, it traverses all the nodes.  If @var{backward} is "
"non-@code{nil}, it traverses backwards (i.e., it visits the last child first "
"when traversing down the tree).  If @var{depth} is non-@code{nil}, it must "
"be a number that limits the tree traversal to that many levels down the "
"tree.  If @var{depth} is @code{nil}, it defaults to 1000."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:769
#, no-wrap
msgid "treesit-search-forward start predicate &optional backward all"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:776
msgid ""
"Like @code{treesit-search-subtree}, this function also traverses the parse "
"tree and matches each node with @var{predicate} (except for @var{start}), "
"where @var{predicate} can be a regexp or a predicate function.  "
"@var{predicate} can also be a thing symbol or thing definition "
"(@pxref{User-defined Things}).  Using an undefined thing doesn't raise an "
"error, the function simply returns @code{nil}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:779
msgid ""
"For a tree like the one below where @var{start} is marked @samp{S}, this "
"function traverses as numbered from 1 to 12:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:791
#, no-wrap
msgid ""
"              12\n"
"              |\n"
"     S--------3----------11\n"
"     |        |          |\n"
"o--o-+--o  1--+--2    6--+-----10\n"
"|  |                  |        |\n"
"o  o                +-+-+   +--+--+\n"
"                    |   |   |  |  |\n"
"                    4   5   7  8  9\n"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:796
msgid ""
"Note that this function doesn't traverse the subtree of @var{start}, and it "
"always traverses leaf nodes first, before moving upwards."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:801
msgid ""
"Like @code{treesit-search-subtree}, this function only searches for named "
"nodes by default, but if @var{all} is non-@code{nil}, it searches for all "
"nodes.  If @var{backward} is non-@code{nil}, it searches backwards."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:806
msgid ""
"While @code{treesit-search-subtree} traverses the subtree of a node, this "
"function starts with node @var{start} and traverses every node that comes "
"after it in the buffer position order, i.e., nodes with start positions "
"greater than the end position of @var{start}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:812
msgid ""
"In the tree shown above, @code{treesit-search-subtree} traverses node "
"@samp{S} (@var{start}) and nodes marked with @code{o}, whereas this function "
"traverses the nodes marked with numbers.  This function is useful for "
"answering questions like ``what is the first node after @var{start} in the "
"buffer that satisfies some condition?''"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:814
#, no-wrap
msgid "treesit-search-forward-goto node predicate &optional start backward all"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:818
msgid ""
"This function moves point to the start or end of the next node after "
"@var{node} in the buffer that matches @var{predicate}.  If @var{start} is "
"non-@code{nil}, stop at the beginning rather than the end of a node."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:822
msgid ""
"This function guarantees that the matched node it returns makes progress in "
"terms of buffer position: the start/end position of the returned node is "
"always greater than that of @var{node}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:825
msgid ""
"Arguments @var{predicate}, @var{backward}, and @var{all} are the same as in "
"@code{treesit-search-forward}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:827
#, no-wrap
msgid "treesit-induce-sparse-tree root predicate &optional process-fn depth"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:829
msgid "This function creates a sparse tree from @var{root}'s subtree."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:837
msgid ""
"It takes the subtree under @var{root}, and combs it so only the nodes that "
"match @var{predicate} are left.  Like previous functions, the "
"@var{predicate} can be a regexp string that matches against each node's "
"type, or a function that takes a node and returns non-@code{nil} if it "
"matches.  @var{predicate} can also be a thing symbol or thing definition "
"(@pxref{User-defined Things}).  Using an undefined thing doesn't raise an "
"error, the function simply returns @code{nil}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:841
msgid ""
"For example, given the subtree on the left that consists of both numbers and "
"letters, if @var{predicate} is ``letter only'', the returned tree is the one "
"on the right."
msgstr ""

#. type: group
#: original_texis/parsing.texi:855
#, no-wrap
msgid ""
"    a                 a              a\n"
"    |                 |              |\n"
"+---+---+         +---+---+      +---+---+\n"
"|   |   |         |   |   |      |   |   |\n"
"b   1   2         b   |   |      b   c   d\n"
"    |   |     =>      |   |  =>      |\n"
"    c   +--+          c   +          e\n"
"    |   |  |          |   |\n"
" +--+   d  4       +--+   d\n"
" |  |              |\n"
" e  5              e\n"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:863
msgid ""
"If @var{process-fn} is non-@code{nil}, instead of returning the matched "
"nodes, this function passes each node to @var{process-fn} and uses the "
"returned value instead.  If non-@code{nil}, @var{depth} limits the number of "
"levels to go down from @var{root}.  If @var{depth} is @code{nil}, it "
"defaults to 1000."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:869
msgid ""
"Each node in the returned tree looks like @w{@code{(@var{tree-sitter-node} "
". (@var{child} @dots{}))}}.  The @var{tree-sitter-node} of the root of this "
"tree will be @code{nil} if @var{root} doesn't match @var{predicate}.  If no "
"node matches @var{predicate}, the function returns @code{nil}."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:871
#, no-wrap
msgid "More convenience functions"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:873
#, no-wrap
msgid "treesit-node-get node instructions"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:877
msgid ""
"This is a convenience function that chains together multiple node accessor "
"functions together.  For example, to get @var{node}'s parent's next "
"sibling's second child's text:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:885
#, no-wrap
msgid ""
"(treesit-node-get node\n"
"   '((parent 1)\n"
"    (sibling 1 nil)\n"
"    (child 1 nil)\n"
"    (text nil)))\n"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:891
msgid ""
"@var{instruction} is a list of INSTRUCTIONs of the form @w{@code{(@var{fn} "
"@var{arg}...)}}.  The following @var{fn}'s are supported:"
msgstr ""

#. type: item
#: original_texis/parsing.texi:893
#, no-wrap
msgid "(child @var{idx} @var{named})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:895
msgid "Get the @var{idx}'th child."
msgstr ""

#. type: item
#: original_texis/parsing.texi:896
#, no-wrap
msgid "(parent @var{n})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:898
msgid "Go to parent @var{n} times."
msgstr ""

#. type: item
#: original_texis/parsing.texi:899
#, no-wrap
msgid "(field-name)"
msgstr ""

#. type: table
#: original_texis/parsing.texi:901
msgid "Get the field name of the current node."
msgstr ""

#. type: item
#: original_texis/parsing.texi:902
#, no-wrap
msgid "(type)"
msgstr ""

#. type: table
#: original_texis/parsing.texi:904
msgid "Get the type of the current node."
msgstr ""

#. type: item
#: original_texis/parsing.texi:905
#, no-wrap
msgid "(text @var{no-property})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:907
msgid "Get the text of the current node."
msgstr ""

#. type: item
#: original_texis/parsing.texi:908
#, no-wrap
msgid "(children @var{named})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:910
msgid "Get a list of children."
msgstr ""

#. type: item
#: original_texis/parsing.texi:911
#, no-wrap
msgid "(sibling @var{step} @var{named})"
msgstr ""

#. type: table
#: original_texis/parsing.texi:914
msgid ""
"Get the nth prev/next sibling, negative @var{step} means prev sibling, "
"positive means next sibling."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:918
msgid ""
"Note that arguments like @var{named} and @var{no-property} can't be omitted, "
"unlike in their original functions."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:920
#, no-wrap
msgid "treesit-filter-child node predicate &optional named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:923
msgid ""
"This function finds immediate children of @var{node} that satisfy "
"@var{predicate}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:928
msgid ""
"The @var{predicate} function takes a node as argument and should return "
"non-@code{nil} to indicate that the node should be kept.  If @var{named} is "
"non-@code{nil}, this function only examines named nodes."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:930
#, no-wrap
msgid "treesit-parent-until node predicate &optional include-node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:937
msgid ""
"This function repeatedly finds the parents of @var{node}, and returns the "
"parent that satisfies @var{predicate}.  @var{predicate} can be either a "
"function that takes a node as argument and returns @code{t} or @code{nil}, "
"or a regexp matching node type names, or other valid predicates described in "
"@code{treesit-thing-settings}.  If no parent satisfies @var{predicates}, "
"this function returns @code{nil}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:941
msgid ""
"Normally this function only looks at the parents of @var{node} but not "
"@var{node} itself.  But if @var{include-node} is non-@code{nil}, this "
"function returns @var{node} if @var{node} satisfies @var{predicate}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:943
#, no-wrap
msgid "treesit-parent-while node predicate"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:950
msgid ""
"This function goes up the tree starting from @var{node}, and keeps doing so "
"as long as the nodes satisfy @var{predicate}, a function that takes a node "
"as argument.  That is, this function returns the highest parent of "
"@var{node} that still satisfies @var{predicate}.  Note that if @var{node} "
"satisfies @var{predicate} but its immediate parent doesn't, @var{node} "
"itself is returned."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:952
#, no-wrap
msgid "treesit-node-top-level node &optional predicate include-node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:957
msgid ""
"This function returns the highest parent of @var{node} that has the same "
"type as @var{node}.  If no such parent exists, it returns @code{nil}.  "
"Therefore this function is also useful for testing whether @var{node} is "
"top-level."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:963
msgid ""
"If @var{predicate} is @code{nil}, this function uses @var{node}'s type to "
"find the parent.  If @var{predicate} is non-@code{nil}, this function "
"searches the parent that satisfies @var{predicate}.  If @var{include-node} "
"is non-@code{nil}, this function returns @var{node} if @var{node} satisfies "
"@var{predicate}."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:967
#, no-wrap
msgid "information of node, syntax trees"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:968
#, no-wrap
msgid "syntax trees, node information"
msgstr ""

#. type: heading
#: original_texis/parsing.texi:970
#, no-wrap
msgid "Basic information of Node"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:974
msgid ""
"Every node is associated with a parser, and that parser is associated with a "
"buffer.  The following functions retrieve them."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:975
#, no-wrap
msgid "treesit-node-parser node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:977
msgid "This function returns @var{node}'s associated parser."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:979
#, no-wrap
msgid "treesit-node-buffer node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:981
msgid "This function returns @var{node}'s parser's associated buffer."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:983
#, no-wrap
msgid "treesit-node-language node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:985
msgid "This function returns @var{node}'s parser's associated language."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:989
msgid ""
"Each node represents a portion of text in the buffer.  Functions below find "
"relevant information about that text."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:990
#, no-wrap
msgid "treesit-node-start node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:992
msgid "Return the start position of @var{node}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:994
#, no-wrap
msgid "treesit-node-end node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:996
msgid "Return the end position of @var{node}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:998
#, no-wrap
msgid "treesit-node-text node &optional object"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1002
msgid ""
"Return the buffer text that @var{node} represents, as a string.  (If "
"@var{node} is retrieved from parsing a string, it will be the text from that "
"string.)"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1004
#, no-wrap
msgid "predicates for syntax tree nodes"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1006
msgid "Here are some predicates on tree-sitter nodes:"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1007
#, no-wrap
msgid "treesit-node-p object"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1009
msgid "Checks if @var{object} is a tree-sitter syntax node."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1011
#, no-wrap
msgid "compare tree-sitter syntax nodes"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1012
#, no-wrap
msgid "tree-sitter nodes, comparing"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1013
#, no-wrap
msgid "treesit-node-eq node1 node2"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1018
msgid ""
"Checks if @var{node1} and @var{node2} refer to the same node in a "
"tree-sitter syntax tree.  This function uses the same equivalence metric as "
"@code{equal}.  You can also compare nodes using @code{equal} "
"(@pxref{Equality Predicates})."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:1020
#, no-wrap
msgid "Property information"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1026
msgid ""
"In general, nodes in a concrete syntax tree fall into two categories: "
"@dfn{named nodes} and @dfn{anonymous nodes}.  Whether a node is named or "
"anonymous is determined by the language grammar (@pxref{tree-sitter named "
"node, named node})."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1027
#, no-wrap
msgid "tree-sitter missing node"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1028
#, no-wrap
msgid "missing node, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1035
msgid ""
"Apart from being named or anonymous, a node can have other properties.  A "
"node can be ``missing'': such nodes are inserted by the parser in order to "
"recover from certain kinds of syntax errors, i.e., something should probably "
"be there according to the grammar, but is not there.  This can happen during "
"editing of the program source, when the source is not yet in its final form."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1036
#, no-wrap
msgid "tree-sitter extra node"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1037
#, no-wrap
msgid "extra node, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1040
msgid ""
"A node can be ``extra'': such nodes represent things like comments, which "
"can appear anywhere in the text."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1041
#, no-wrap
msgid "tree-sitter outdated node"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1042
#, no-wrap
msgid "outdated node, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1045
msgid ""
"A node can be ``outdated'', if its parser has reparsed at least once after "
"the node was created."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1046
#, no-wrap
msgid "tree-sitter node that has error"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1047
#, no-wrap
msgid "has error, tree-sitter node"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1051
msgid ""
"A node ``has error'' if the text it spans contains a syntax error.  It can "
"be that the node itself has an error, or one of its descendants has an "
"error."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1052
#, no-wrap
msgid "tree-sitter, live parsing node"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1053
#, no-wrap
msgid "live node, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1056
msgid ""
"A node is considered @dfn{live} if its parser is not deleted, and the buffer "
"to which it belongs is a live buffer (@pxref{Killing Buffers})."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1057
#, no-wrap
msgid "treesit-node-check node property"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1061
msgid ""
"This function returns non-@code{nil} if @var{node} has the specified "
"@var{property}.  @var{property} can be @code{named}, @code{missing}, "
"@code{extra}, @code{outdated}, @code{has-error}, or @code{live}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1063
#, no-wrap
msgid "treesit-node-type node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1069
msgid ""
"Named nodes have ``types'' (@pxref{tree-sitter node type, node type}).  For "
"example, a named node can be a @code{string_literal} node, where "
"@code{string_literal} is its type.  The type of an anonymous node is just "
"the text that the node represents; e.g., the type of a @samp{,} node is just "
"@samp{,}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1071
msgid "This function returns @var{node}'s type as a string."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:1073
#, no-wrap
msgid "Information as a child or parent"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1075
#, no-wrap
msgid "treesit-node-index node &optional named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1079
msgid ""
"This function returns the index of @var{node} as a child node of its "
"parent.  If @var{named} is non-@code{nil}, it only counts named nodes "
"(@pxref{tree-sitter named node, named node})."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1081
#, no-wrap
msgid "treesit-node-field-name node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1085
msgid ""
"A child of a parent node could have a field name (@pxref{tree-sitter node "
"field name, field name}).  This function returns the field name of "
"@var{node} as a child of its parent."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1087
#, no-wrap
msgid "treesit-node-field-name-for-child node n"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1091
msgid ""
"This function returns the field name of the @var{n}'th child of @var{node}.  "
"It returns @code{nil} if there is no @var{n}'th child, or the @var{n}'th "
"child doesn't have a field name."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1094
msgid ""
"Note that @var{n} counts both named and anonymous children, and @var{n} can "
"be negative, e.g., @minus{}1 represents the last child."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1096
#, no-wrap
msgid "treesit-node-child-count node &optional named"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1100
msgid ""
"This function returns the number of children of @var{node}.  If @var{named} "
"is non-@code{nil}, it only counts named children (@pxref{tree-sitter named "
"node, named node})."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:1102
#, no-wrap
msgid "Convenience functions"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1104
#, no-wrap
msgid "treesit-node-enclosed-p smaller larger &optional strict"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1108
msgid ""
"This function returns non-@code{nil} if @var{smaller} is enclosed in "
"@var{larger}.  @var{smaller} and @var{larger} can be either a cons "
"@code{(@var{beg} . @var{end})} or a node."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1111
msgid ""
"Return non-@code{nil} if @var{larger}'s start <= @var{smaller}'s start and "
"@var{larger}'s end <= @var{smaller}'s end."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1113
msgid "If @var{strict} is @code{t}, compare with < rather than <=."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1116
msgid ""
"If @var{strict} is @code{partial}, consider @var{larger} encloses "
"@var{smaller} when at least one side is strictly enclosing."
msgstr ""

#. type: section
#: original_texis/parsing.texi:1119
#, no-wrap
msgid "Pattern Matching Tree-sitter Nodes"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1120
#, no-wrap
msgid "pattern matching with tree-sitter nodes"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1122
#, no-wrap
msgid "capturing, tree-sitter node"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1128
msgid ""
"Tree-sitter lets Lisp programs match patterns using a small declarative "
"language.  This pattern matching consists of two steps: first tree-sitter "
"matches a @dfn{pattern} against nodes in the syntax tree, then it "
"@dfn{captures} specific nodes that matched the pattern and returns the "
"captured nodes."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1132
msgid ""
"We describe first how to write the most basic query pattern and how to "
"capture nodes in a pattern, then the pattern-matching function, and finally "
"the more advanced pattern syntax."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:1133
#, no-wrap
msgid "Basic query syntax"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1135
#, no-wrap
msgid "tree-sitter query pattern syntax"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1136
#, no-wrap
msgid "pattern syntax, tree-sitter query"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1137
#, no-wrap
msgid "query, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1141
msgid ""
"A @dfn{query} consists of multiple @dfn{patterns}.  Each pattern is an "
"s-expression that matches a certain node in the syntax node.  A pattern has "
"the form @w{@code{(@var{type} (@var{child}@dots{}))}}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1144
msgid ""
"For example, a pattern that matches a @code{binary_expression} node that "
"contains @code{number_literal} child nodes would look like"
msgstr ""

#. type: example
#: original_texis/parsing.texi:1147
#, no-wrap
msgid "(binary_expression (number_literal))\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1152
msgid ""
"To @dfn{capture} a node using the query pattern above, append "
"@code{@@@var{capture-name}} after the node pattern you want to capture.  For "
"example,"
msgstr ""

#. type: example
#: original_texis/parsing.texi:1155
#, no-wrap
msgid "(binary_expression (number_literal) @@number-in-exp)\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1161
msgid ""
"captures @code{number_literal} nodes that are inside a "
"@code{binary_expression} node with the capture name @code{number-in-exp}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1164
msgid ""
"We can capture the @code{binary_expression} node as well, with, for example, "
"the capture name @code{biexp}:"
msgstr ""

#. type: example
#: original_texis/parsing.texi:1168
#, no-wrap
msgid ""
"(binary_expression\n"
" (number_literal) @@number-in-exp) @@biexp\n"
msgstr ""

#. type: heading
#: original_texis/parsing.texi:1170
#, no-wrap
msgid "Query function"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1172
#, no-wrap
msgid "query functions, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1174
msgid "Now we can introduce the @dfn{query functions}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1175
#, no-wrap
msgid "treesit-query-capture node query &optional beg end node-only"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1181
msgid ""
"This function matches patterns in @var{query} within @var{node}.  The "
"argument @var{query} can be either an s-expression, a string, or a compiled "
"query object.  For now, we focus on the s-expression syntax; string syntax "
"and compiled queries are described at the end of the section."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1186
msgid ""
"The argument @var{node} can also be a parser or a language symbol.  A parser "
"means use its root node, a language symbol means find or create a parser for "
"that language in the current buffer, and use the root node."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1196
msgid ""
"The function returns all the captured nodes in an alist with elements of the "
"form @w{@code{(@var{capture_name} . @var{node})}}.  If @var{node-only} is "
"non-@code{nil}, it returns the list of @var{node}s instead.  By default the "
"entire text of @var{node} is searched, but if @var{beg} and @var{end} are "
"both non-@code{nil}, they specify the region of buffer text where this "
"function should match nodes.  Any matching node whose span overlaps with the "
"region between @var{beg} and @var{end} is captured; it doesn't have to be "
"completely contained in the region."
msgstr ""

#. type: vindex
#: original_texis/parsing.texi:1197
#, no-wrap
msgid "treesit-query-error"
msgstr ""

#. type: findex
#: original_texis/parsing.texi:1198
#, no-wrap
msgid "treesit-query-validate"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1203 original_texis/parsing.texi:1504
msgid ""
"This function raises the @code{treesit-query-error} error if @var{query} is "
"malformed.  The signal data contains a description of the specific error.  "
"You can use @code{treesit-query-validate} to validate and debug the query."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1207
msgid "For example, suppose @var{node}'s text is @code{1 + 2}, and @var{query} is"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1213
#, no-wrap
msgid ""
"(setq query\n"
"      '((binary_expression\n"
"         (number_literal) @@number-in-exp) @@biexp)\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1217
msgid "Matching that query would return"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1224
#, no-wrap
msgid ""
"(treesit-query-capture node query)\n"
"    @result{} ((biexp . @var{<node for \"1 + 2\">})\n"
"       (number-in-exp . @var{<node for \"1\">})\n"
"       (number-in-exp . @var{<node for \"2\">}))\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1229
msgid ""
"As mentioned earlier, @var{query} could contain multiple patterns.  For "
"example, it could have two top-level patterns:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1235
#, no-wrap
msgid ""
"(setq query\n"
"      '((binary_expression) @@biexp\n"
"        (number_literal) @@number @@biexp)\n"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1238
#, no-wrap
msgid "treesit-query-string string query language"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1241
msgid ""
"This function parses @var{string} as @var{language}, matches its root node "
"with @var{query}, and returns the result."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:1243
#, no-wrap
msgid "More query syntax"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1248
msgid ""
"Besides node type and capture name, tree-sitter's pattern syntax can express "
"anonymous node, field name, wildcard, quantification, grouping, alternation, "
"anchor, and predicate."
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:1249
#, no-wrap
msgid "Anonymous node"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1253
msgid ""
"An anonymous node is written verbatim, surrounded by quotes.  A pattern "
"matching (and capturing) keyword @code{return} would be"
msgstr ""

#. type: example
#: original_texis/parsing.texi:1256
#, no-wrap
msgid "\"return\" @@keyword\n"
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:1258
#, no-wrap
msgid "Wild card"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1263
msgid ""
"In a pattern, @samp{(_)} matches any named node, and @samp{_} matches any "
"named or anonymous node.  For example, to capture any named child of a "
"@code{binary_expression} node, the pattern would be"
msgstr ""

#. type: example
#: original_texis/parsing.texi:1266
#, no-wrap
msgid "(binary_expression (_) @@in-biexp)\n"
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:1268
#, no-wrap
msgid "Field name"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1273
msgid ""
"It is possible to capture child nodes that have specific field names.  In "
"the pattern below, @code{declarator} and @code{body} are field names, "
"indicated by the colon following them."
msgstr ""

#. type: group
#: original_texis/parsing.texi:1279
#, no-wrap
msgid ""
"(function_definition\n"
"  declarator: (_) @@func-declarator\n"
"  body: (_) @@func-body)\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1284
msgid ""
"It is also possible to capture a node that doesn't have a certain field, "
"say, a @code{function_definition} without a @code{body} field:"
msgstr ""

#. type: example
#: original_texis/parsing.texi:1287
#, no-wrap
msgid "(function_definition !body) @@func-no-body\n"
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:1289
#, no-wrap
msgid "Quantify node"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1291
#, no-wrap
msgid "quantify node, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1296
msgid ""
"Tree-sitter recognizes quantification operators @samp{:*}, @samp{:+}, and "
"@samp{:?}.  Their meanings are the same as in regular expressions: @samp{:*} "
"matches the preceding pattern zero or more times, @samp{:+} matches one or "
"more times, and @samp{:?} matches zero or one times."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1299
msgid ""
"For example, the following pattern matches @code{type_declaration} nodes "
"that have @emph{zero or more} @code{long} keywords."
msgstr ""

#. type: example
#: original_texis/parsing.texi:1302
#, no-wrap
msgid "(type_declaration \"long\" :*) @@long-type\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1306
msgid ""
"The following pattern matches a type declaration that may or may not have a "
"@code{long} keyword:"
msgstr ""

#. type: example
#: original_texis/parsing.texi:1309
#, no-wrap
msgid "(type_declaration \"long\" :?) @@long-type\n"
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:1311
#, no-wrap
msgid "Grouping"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1316
msgid ""
"Similar to groups in regular expressions, we can bundle patterns into groups "
"and apply quantification operators to them.  For example, to express a "
"comma-separated list of identifiers, one could write"
msgstr ""

#. type: example
#: original_texis/parsing.texi:1319
#, no-wrap
msgid "(identifier) (\",\" (identifier)) :*\n"
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:1321
#, no-wrap
msgid "Alternation"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1326
msgid ""
"Again, similar to regular expressions, we can express ``match any one of "
"these patterns'' in a pattern.  The syntax is a vector of patterns.  For "
"example, to capture some keywords in C, the pattern would be"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1335
#, no-wrap
msgid ""
"[\n"
"  \"return\"\n"
"  \"break\"\n"
"  \"if\"\n"
"  \"else\"\n"
"] @@keyword\n"
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:1338
#, no-wrap
msgid "Anchor"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1345
msgid ""
"The anchor operator @code{:anchor} can be used to enforce juxtaposition, "
"i.e., to enforce two things to be directly next to each other.  The two "
"``things'' can be two nodes, or a child and the end of its parent.  For "
"example, to capture the first child, the last child, or two adjacent "
"children:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1350
#, no-wrap
msgid ""
";; Anchor the child with the end of its parent.\n"
"(compound_expression (_) @@last-child :anchor)\n"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1355
#, no-wrap
msgid ""
";; Anchor the child with the beginning of its parent.\n"
"(compound_expression :anchor (_) @@first-child)\n"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1363
#, no-wrap
msgid ""
";; Anchor two adjacent children.\n"
"(compound_expression\n"
" (_) @@prev-child\n"
" :anchor\n"
" (_) @@next-child)\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1368
msgid "Note that the enforcement of juxtaposition ignores any anonymous nodes."
msgstr ""

#. type: subheading
#: original_texis/parsing.texi:1369
#, no-wrap
msgid "Predicate"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1373
msgid ""
"It is possible to add predicate constraints to a pattern.  For example, with "
"the following pattern:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1380
#, no-wrap
msgid ""
"(\n"
" (array :anchor (_) @@first (_) @@last :anchor)\n"
" (:equal @@first @@last)\n"
")\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1388
msgid ""
"tree-sitter only matches arrays where the first element is equal to the last "
"element.  To attach a predicate to a pattern, we need to group them "
"together.  Currently there are three predicates: @code{:equal}, "
"@code{:match}, and @code{:pred}."
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:1389
#, no-wrap
msgid "Predicate :equal arg1 arg2"
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:1393
msgid ""
"Matches if @var{arg1} is equal to @var{arg2}.  Arguments can be either "
"strings or capture names.  Capture names represent the text that the "
"captured node spans in the buffer."
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:1395
#, no-wrap
msgid "Predicate :match regexp capture-name"
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:1399
msgid ""
"Matches if the text that @var{capture-name}'s node spans in the buffer "
"matches regular expression @var{regexp}, given as a string literal.  "
"Matching is case-sensitive."
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:1401
#, no-wrap
msgid "Predicate :pred fn &rest nodes"
msgstr ""

#. type: deffn
#: original_texis/parsing.texi:1405
msgid ""
"Matches if function @var{fn} returns non-@code{nil} when passed each node in "
"@var{nodes} as arguments.  The function runs with the current buffer set to "
"the buffer of node being queried."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1410
msgid ""
"Note that a predicate can only refer to capture names that appear in the "
"same pattern.  Indeed, it makes little sense to refer to capture names in "
"other patterns."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:1411
#, no-wrap
msgid "String patterns"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1413
#, no-wrap
msgid "tree-sitter patterns as strings"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1414
#, no-wrap
msgid "patterns, tree-sitter, in string form"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1418
msgid ""
"Besides s-expressions, Emacs allows the tree-sitter's native query syntax to "
"be used by writing them as strings.  It largely resembles the s-expression "
"syntax.  For example, the following query"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1426
#, no-wrap
msgid ""
"(treesit-query-capture\n"
" node '((addition_expression\n"
"         left: (_) @@left\n"
"         \"+\" @@plus-sign\n"
"         right: (_) @@right) @@addition\n"
"\n"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1428
#, no-wrap
msgid "         [\"return\" \"break\"] @@keyword))\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1433
msgid "is equivalent to"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1441
#, no-wrap
msgid ""
"(treesit-query-capture\n"
" node \"(addition_expression\n"
"        left: (_) @@left\n"
"        \\\"+\\\" @@plus-sign\n"
"        right: (_) @@right) @@addition\n"
"\n"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1443
#, no-wrap
msgid "        [\\\"return\\\" \\\"break\\\"] @@keyword\")\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1448
msgid ""
"Most patterns can be written directly as s-expressions inside a string.  "
"Only a few of them need modification:"
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1452
msgid "Anchor @code{:anchor} is written as @samp{.}."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1454
msgid "@samp{:?} is written as @samp{?}."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1456
msgid "@samp{:*} is written as @samp{*}."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1458
msgid "@samp{:+} is written as @samp{+}."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:1462
msgid ""
"@code{:equal}, @code{:match} and @code{:pred} are written as @code{#equal}, "
"@code{#match} and @code{#pred}, respectively.  In general, predicates change "
"their @samp{:} to @samp{#}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1465
msgid "For example,"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1472
#, no-wrap
msgid ""
"'((\n"
"   (compound_expression :anchor (_) @@first (_) :* @@rest)\n"
"   (:match \"love\" @@first)\n"
"   ))\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1477
msgid "is written in string form as"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1484
#, no-wrap
msgid ""
"\"(\n"
"  (compound_expression . (_) @@first (_)* @@rest)\n"
"  (#match \\\"love\\\" @@first)\n"
"  )\"\n"
msgstr ""

#. type: heading
#: original_texis/parsing.texi:1487
#, no-wrap
msgid "Compiling queries"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1489
#, no-wrap
msgid "compiling tree-sitter queries"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1490
#, no-wrap
msgid "queries, compiling"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1495
msgid ""
"If a query is intended to be used repeatedly, especially in tight loops, it "
"is important to compile that query, because a compiled query is much faster "
"than an uncompiled one.  A compiled query can be used anywhere a query is "
"accepted."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1496
#, no-wrap
msgid "treesit-query-compile language query"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1499
msgid ""
"This function compiles @var{query} for @var{language} into a compiled query "
"object and returns it."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1506
#, no-wrap
msgid "treesit-query-language query"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1508
msgid "This function returns the language of @var{query}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1510
#, no-wrap
msgid "treesit-query-expand query"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1513
msgid "This function converts the s-expression @var{query} into the string format."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1515
#, no-wrap
msgid "treesit-pattern-expand pattern"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1518
msgid ""
"This function converts the s-expression @var{pattern} into the string "
"format."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1523
msgid ""
"For more details, read the tree-sitter project's documentation about "
"pattern-matching, which can be found at "
"@uref{https://tree-sitter.github.io/tree-sitter/using-parsers#pattern-matching-with-queries}."
msgstr ""

#. type: section
#: original_texis/parsing.texi:1525
#, no-wrap
msgid "User-defined ``Things'' and Navigation"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1526
#, no-wrap
msgid "user-defined things, with tree-sitter parsing"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1534
msgid ""
"It's often useful to be able to identify and find certain @dfn{things} in a "
"buffer, like function and class definitions, statements, code blocks, "
"strings, comments, etc.  Emacs allows users to define what kind of "
"tree-sitter node corresponds to a ``thing''.  This enables handy features "
"like jumping to the next function, marking the code block at point, or "
"transposing two function arguments."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1538
msgid ""
"The ``things'' feature in Emacs is independent of the pattern matching "
"feature of tree-sitter, and comparatively less powerful, but more suitable "
"for navigation and traversing the parse tree."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1540
msgid "You can define things with @code{treesit-thing-settings}."
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:1541
#, no-wrap
msgid "treesit-thing-settings"
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:1548
msgid ""
"This is an alist of thing definitions for each language.  The key of each "
"entry is a language symbol, and the value is a list of thing definitions of "
"the form @w{@code{(@var{thing} @var{pred})}}, where @var{thing} is a symbol "
"representing the thing, like @code{defun}, @code{sexp}, or @code{sentence}; "
"and @var{pred} specifies what kind of tree-sitter node is this @var{thing}."
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:1556
msgid ""
"@var{pred} can be a regexp string that matches the type of the node; it can "
"be a function that takes a node as the argument and returns a boolean that "
"indicates whether the node qualifies as the thing; or it can be a cons "
"@w{@code{(@var{regexp} . @var{fn})}}, which is a combination of a regular "
"expression @var{regexp} and a function @var{fn}---the node has to match both "
"the @var{regexp} and to satisfy @var{fn} to qualify as the thing."
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:1561
msgid ""
"@var{pred} can also be recursively defined.  It can be @w{@code{(or "
"@var{pred}@dots{})}}, meaning that satisfying any one of the @var{pred}s "
"qualifies the node as the thing.  It can be @w{@code{(not @var{pred})}}, "
"meaning that not satisfying @var{pred} qualifies the node."
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:1566
msgid ""
"Finally, @var{pred} can refer to other @var{thing}s defined in this list.  "
"For example, @w{@code{(or sexp sentence)}} defines something that's either a "
"@code{sexp} thing or a @code{sentence} thing, as defined by some other rule "
"in the alist."
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:1568
msgid "Here's an example @code{treesit-thing-settings} for C and C++:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1581
#, no-wrap
msgid ""
"((c\n"
"  (defun \"function_definition\")\n"
"  (sexp (not \"[](),[@{@}]\"))\n"
"  (comment \"comment\")\n"
"  (string \"raw_string_literal\")\n"
"  (text (or comment string)))\n"
" (cpp\n"
"  (defun (\"function_definition\" . cpp-ts-mode-defun-valid-p))\n"
"  (defclass \"class_specifier\")\n"
"  (comment \"comment\")))\n"
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:1587
msgid ""
"Note that this example is modified for didactic purposes, and isn't exactly "
"how C and C@t{++} modes define things."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1594
msgid ""
"The rest of this section lists a few functions that take advantage of the "
"thing definitions.  Besides the functions below, some other functions listed "
"elsewhere also utilize the thing feature, e.g., tree-traversing functions "
"like @code{treesit-search-forward}, @code{treesit-induce-sparse-tree}, etc.  "
"@xref{Retrieving Nodes}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1595
#, no-wrap
msgid "treesit-thing-prev position thing"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1601
msgid ""
"This function returns the first node before @var{position} that is the "
"specified @var{thing}.  If no such node exists, it returns @code{nil}.  It's "
"guaranteed that, if a node is returned, the node's end position is less or "
"equal to @var{position}.  In other words, this function never returns a node "
"that encloses @var{position}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1604
msgid ""
"@var{thing} can be either a thing symbol like @code{defun}, or simply a "
"thing definition like @code{\"function_definition\"}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1606
#, no-wrap
msgid "treesit-thing-next position thing"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1611
msgid ""
"This function is similar to @code{treesit-thing-prev}, only it returns the "
"first node @emph{after} @var{position} that's the @var{thing}.  It also "
"guarantees that if a node is returned, the node's start position is greater "
"or equal to @var{position}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1613
#, no-wrap
msgid "treesit-navigate-thing position arg side thing &optional tactic"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1620
msgid ""
"This function builds upon @code{treesit-thing-prev} and "
"@code{treesit-thing-next} and provides functionality that a navigation "
"command would find useful.  It returns the position after moving across "
"@var{arg} instances of @var{thing} from @var{position}.  If there aren't "
"enough things to navigate across, it returns nil.  The function doesn't move "
"point."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1625
msgid ""
"A positive @var{arg} means moving forward that many instances of "
"@var{thing}; negative @var{arg} means moving backward.  If @var{side} is "
"@code{beg}, this function stops at the beginning of @var{thing}; if "
"@code{end}, stop at the end of @var{thing}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1628
msgid ""
"Like in @code{treesit-thing-prev}, @var{thing} can be a thing symbol defined "
"in @code{treesit-thing-settings}, or a thing definition."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1639
msgid ""
"@var{tactic} determines how this function moves between things.  It can be "
"@code{nested}, @code{top-level}, @code{restricted}, or @code{nil}.  "
"@code{nested} or @code{nil} means normal nested navigation: first try to "
"move across siblings; if there aren't any siblings left in the current "
"level, move to the parent, then its siblings, and so on.  @code{top-level} "
"means only navigate across top-level things and ignore nested things.  "
"@code{restricted} means movement is restricted within the thing that "
"encloses @var{position}, if there is such a thing.  This tactic is useful "
"for commands that want to stop at the current nesting level and not move up."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1641
#, no-wrap
msgid "treesit-thing-at position thing &optional strict"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1644
msgid ""
"This function returns the smallest node that's the @var{thing} and encloses "
"@var{position}; if there's no such node, it returns @code{nil}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1648
msgid ""
"The returned node must enclose @var{position}, i.e., its start position is "
"less or equal to @var{position}, and it's end position is greater or equal "
"to @var{position}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1652
msgid ""
"If @var{strict} is non-@code{nil}, this function uses strict comparison, "
"i.e., start position must be strictly greater than @var{position}, and end "
"position must be strictly less than @var{position}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1655
msgid ""
"@var{thing} can be either a thing symbol defined in "
"@code{treesit-thing-settings}, or a thing definition."
msgstr ""

#. type: findex
#: original_texis/parsing.texi:1657
#, no-wrap
msgid "treesit-beginning-of-thing"
msgstr ""

#. type: findex
#: original_texis/parsing.texi:1658
#, no-wrap
msgid "treesit-end-of-thing"
msgstr ""

#. type: findex
#: original_texis/parsing.texi:1659
#, no-wrap
msgid "treesit-thing-at-point"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1664
msgid ""
"There are also some convenient wrapper functions.  "
"@code{treesit-beginning-of-thing} moves point to the beginning of a thing, "
"@code{treesit-end-of-thing} moves to the end of a thing, and "
"@code{treesit-thing-at-point} returns the thing at point."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1672
msgid ""
"There are also defun commands that specifically use the @code{defun} "
"definition (as a fallback of @code{treesit-defun-type-regexp}), like "
"@code{treesit-beginning-of-defun}, @code{treesit-end-of-defun}, and "
"@code{treesit-defun-at-point}.  In addition, these functions use "
"@code{treesit-defun-tactic} as the navigation tactic.  They are described in "
"more detail in other sections (@pxref{Tree-sitter Major Modes})."
msgstr ""

#. type: section
#: original_texis/parsing.texi:1674
#, no-wrap
msgid "Parsing Text in Multiple Languages"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1675
#, no-wrap
msgid "multiple languages, parsing with tree-sitter"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1676
#, no-wrap
msgid "parsing multiple languages with tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1686
msgid ""
"Sometimes, the source of a programming language could contain snippets of "
"other languages; @acronym{HTML} + @acronym{CSS} + JavaScript is one "
"example.  In that case, text segments written in different languages need to "
"be assigned different parsers.  Traditionally, this is achieved by using "
"narrowing.  While tree-sitter works with narrowing (@pxref{tree-sitter "
"narrowing, narrowing}), the recommended way is instead to specify regions of "
"buffer text (i.e., ranges) in which a parser will operate.  This section "
"describes functions for setting and getting ranges for a parser."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1687
#, no-wrap
msgid "primary parser"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1694
msgid ""
"Generally when there are multiple languages at play, there is a ``primary'', "
"or ``host'' language.  The parser for this language---the @dfn{primary "
"parser}, parses the entire buffer.  Parsers for other languages are "
"``embedded'' or ``guest'' parsers, which only work on part of the buffer.  "
"The parse tree of the primary parser is usually used to determine the ranges "
"in which the embedded parsers operate."
msgstr ""

#. type: vindex
#: original_texis/parsing.texi:1695
#, no-wrap
msgid "treesit-primary-parser"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1699
msgid ""
"Major modes should set @code{treesit-primary-parser} to the primary parser "
"before calling @code{treesit-major-mode-setup}, so that Emacs can configure "
"the primary parser correctly for font-lock and other features."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1708
msgid ""
"Lisp programs should call @code{treesit-update-ranges} to make sure the "
"ranges for each parser are correct before using parsers in a buffer, and "
"call @code{treesit-language-at} to figure out the language responsible for "
"the text at some position.  These two functions don't work by themselves; "
"they need major modes to set @code{treesit-range-settings} and "
"@code{treesit-language-at-point-function}, which do the actual work.  These "
"functions and variables are explained in more detail towards the end of the "
"section."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1713
msgid ""
"In short, multi-language major modes should set "
"@code{treesit-primary-parser}, @code{treesit-range-settings}, and "
"@code{treesit-language-at-point-function} before calling "
"@code{treesit-major-mode-setup}."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:1714
#, no-wrap
msgid "Getting and setting ranges"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1716
#, no-wrap
msgid "treesit-parser-set-included-ranges parser ranges"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1721
msgid ""
"This function sets up @var{parser} to operate on @var{ranges}.  The "
"@var{parser} will only read the text of the specified ranges.  Each range in "
"@var{ranges} is a pair of the form @w{@code{(@var{beg} . @var{end})}}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1724
msgid ""
"The ranges in @var{ranges} must come in order and must not overlap.  That "
"is, in pseudo code:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1732
#, no-wrap
msgid ""
"(cl-loop for idx from 1 to (1- (length ranges))\n"
"         for prev = (nth (1- idx) ranges)\n"
"         for next = (nth idx ranges)\n"
"         should (<= (car prev) (cdr prev)\n"
"                    (car next) (cdr next)))\n"
msgstr ""

#. type: vindex
#: original_texis/parsing.texi:1735
#, no-wrap
msgid "treesit-range-invalid"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1740
msgid ""
"If @var{ranges} violates this constraint, or something else went wrong, this "
"function signals the @code{treesit-range-invalid} error.  The signal data "
"contains a specific error message and the ranges we are trying to set."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1743
msgid ""
"This function can also be used for disabling ranges.  If @var{ranges} is "
"@code{nil}, the parser is set to parse the whole buffer."
msgstr ""

#. type: group
#: original_texis/parsing.texi:1750
#, no-wrap
msgid ""
"(treesit-parser-set-included-ranges\n"
" parser '((1 . 9) (16 . 24) (24 . 25)))\n"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1754
#, no-wrap
msgid "treesit-parser-included-ranges parser"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1760
msgid ""
"This function returns the ranges set for @var{parser}.  The return value is "
"the same as the @var{ranges} argument of "
"@code{treesit-parser-included-ranges}: a list of cons cells of the form "
"@w{@code{(@var{beg} . @var{end})}}.  If @var{parser} doesn't have any "
"ranges, the return value is @code{nil}."
msgstr ""

#. type: group
#: original_texis/parsing.texi:1765
#, no-wrap
msgid ""
"(treesit-parser-included-ranges parser)\n"
"    @result{} ((1 . 9) (16 . 24) (24 . 25))\n"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1769
#, no-wrap
msgid "treesit-query-range source query &optional beg end"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1774
msgid ""
"This function matches @var{source} with @var{query} and returns the ranges "
"of captured nodes.  The return value is a list of cons cells of the form "
"@w{@code{(@var{beg} . @var{end})}}, where @var{beg} and @var{end} specify "
"the beginning and the end of a region of text."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1780
msgid ""
"For convenience, @var{source} can be a language symbol, a parser, or a "
"node.  If it's a language symbol, this function matches in the root node of "
"the first parser using that language; if a parser, this function matches in "
"the root node of that parser; if a node, this function matches in that node."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1785
msgid ""
"The argument @var{query} is the query used to capture nodes (@pxref{Pattern "
"Matching}).  The capture names don't matter.  The arguments @var{beg} and "
"@var{end}, if both non-@code{nil}, limit the range in which this function "
"queries."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1788
msgid ""
"Like other query functions, this function raises the "
"@code{treesit-query-error} error if @var{query} is malformed."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:1790
#, no-wrap
msgid "Supporting multiple languages in Lisp programs"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1795
msgid ""
"It should suffice for general Lisp programs to call the following two "
"functions in order to support program sources that mix multiple languages."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1796
#, no-wrap
msgid "treesit-update-ranges &optional beg end"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1802
msgid ""
"This function updates ranges for parsers in the buffer.  It makes sure the "
"parsers' ranges are set correctly between @var{beg} and @var{end}, according "
"to @code{treesit-range-settings}.  If omitted, @var{beg} defaults to the "
"beginning of the buffer, and @var{end} defaults to the end of the buffer."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1805
msgid ""
"For example, fontification functions use this function before querying for "
"nodes in a region."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1807
#, no-wrap
msgid "treesit-language-at pos"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1815
msgid ""
"This function returns the language of the text at buffer position "
"@var{pos}.  Under the hood it calls "
"@code{treesit-language-at-point-function} and returns its return value.  If "
"@code{treesit-language-at-point-function} is @code{nil}, this function "
"returns the language of the first parser in the returned value of "
"@code{treesit-parser-list}.  If there is no parser in the buffer, it returns "
"@code{nil}."
msgstr ""

#. type: heading
#: original_texis/parsing.texi:1817
#, no-wrap
msgid "Supporting multiple languages in major modes"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1819
#, no-wrap
msgid "host language, tree-sitter"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1820
#, no-wrap
msgid "tree-sitter host and embedded languages"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1821
#, no-wrap
msgid "embedded language, tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1828
msgid ""
"Normally, in a set of languages that can be mixed together, there is a "
"@dfn{host language} and one or more @dfn{embedded languages}.  A Lisp "
"program usually first parses the whole document with the host language's "
"parser, retrieves some information, sets ranges for the embedded languages "
"with that information, and then parses the embedded languages."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1836
msgid ""
"Take a buffer containing @acronym{HTML}, @acronym{CSS}, and JavaScript as an "
"example.  A Lisp program will first parse the whole buffer with an "
"@acronym{HTML} parser, then query the parser for @code{style_element} and "
"@code{script_element} nodes, which correspond to @acronym{CSS} and "
"JavaScript text, respectively.  Then it sets the range of the @acronym{CSS} "
"and JavaScript parsers to the range which their corresponding nodes span."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1838
msgid "Given a simple @acronym{HTML} document:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1845
#, no-wrap
msgid ""
"<html>\n"
"  <script>1 + 2</script>\n"
"  <style>body @{ color: \"blue\"; @}</style>\n"
"</html>\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1851
msgid ""
"a Lisp program will first parse with a @acronym{HTML} parser, then set "
"ranges for @acronym{CSS} and JavaScript parsers:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1858
#, no-wrap
msgid ""
";; Create parsers.\n"
"(setq html (treesit-parser-create 'html))\n"
"(setq css (treesit-parser-create 'css))\n"
"(setq js (treesit-parser-create 'javascript))\n"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1867
#, no-wrap
msgid ""
";; Set CSS ranges.\n"
"(setq css-range\n"
"      (treesit-query-range\n"
"       'html\n"
"       '((style_element (raw_text) @@capture))))\n"
"(treesit-parser-set-included-ranges css css-range)\n"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1876
#, no-wrap
msgid ""
";; Set JavaScript ranges.\n"
"(setq js-range\n"
"      (treesit-query-range\n"
"       'html\n"
"       '((script_element (raw_text) @@capture))))\n"
"(treesit-parser-set-included-ranges js js-range)\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:1886
msgid ""
"Emacs automates this process in @code{treesit-update-ranges}.  A "
"multi-language major mode should set @code{treesit-range-settings} so that "
"@code{treesit-update-ranges} knows how to perform this process "
"automatically.  Major modes should use the helper function "
"@code{treesit-range-rules} to generate a value that can be assigned to "
"@code{treesit-range-settings}.  The settings in the following example "
"directly translate into operations shown above."
msgstr ""

#. type: group
#: original_texis/parsing.texi:1894
#, no-wrap
msgid ""
"(setq treesit-range-settings\n"
"      (treesit-range-rules\n"
"       :embed 'javascript\n"
"       :host 'html\n"
"       '((script_element (raw_text) @@capture))\n"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1899
#, no-wrap
msgid ""
"       :embed 'css\n"
"       :host 'html\n"
"       '((style_element (raw_text) @@capture))))\n"
msgstr ""

#. type: group
#: original_texis/parsing.texi:1918
#, no-wrap
msgid ""
";; Major modes with multiple languages should always set\n"
";; `treesit-language-at-point-function' (which see).\n"
"(setq treesit-language-at-point-function\n"
"      (lambda (pos)\n"
"        (let* ((node (treesit-node-at pos 'html))\n"
"               (parent (treesit-node-parent node)))\n"
"          (cond\n"
"           ((and node parent\n"
"                 (equal (treesit-node-type node) \"raw_text\")\n"
"                 (equal (treesit-node-type parent) \"script_element\"))\n"
"            'javascript)\n"
"           ((and node parent\n"
"                 (equal (treesit-node-type node) \"raw_text\")\n"
"                 (equal (treesit-node-type parent) \"style_element\"))\n"
"            'css)\n"
"           (t 'html)))))\n"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1921
#, no-wrap
msgid "treesit-range-rules &rest query-specs"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1925
msgid ""
"This function is used to set @code{treesit-range-settings}.  It takes care "
"of compiling queries and other post-processing, and outputs a value that "
"@code{treesit-range-settings} can have."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1930
msgid ""
"It takes a series of @var{query-spec}s, where each @var{query-spec} is a "
"@var{query} preceded by zero or more @var{keyword}/@var{value} pairs.  Each "
"@var{query} is a tree-sitter query in either the string, s-expression, or "
"compiled form, or a function."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1935
msgid ""
"If @var{query} is a tree-sitter query, it should be preceded by two "
"@var{keyword}/@var{value} pairs, where the @code{:embed} keyword specifies "
"the embedded language, and the @code{:host} keyword specifies the host "
"language."
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:1936
#, no-wrap
msgid "local parser"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1941
msgid ""
"If the query is given the @code{:local} keyword whose value is @code{t}, the "
"range set by this query has a dedicated local parser; otherwise the range "
"shares a parser with other ranges for the same language."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1946
msgid ""
"By default, a parser sees its ranges as a continuum, rather than treating "
"them as separate independent segments.  Therefore, if the embedded ranges "
"are semantically independent segments, they should be processed by local "
"parsers, described below."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1949
msgid ""
"Local parser set to a range can be retrieved by "
"@code{treesit-local-parsers-at} and @code{treesit-local-parsers-on}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1955
msgid ""
"@code{treesit-update-ranges} uses @var{query} to figure out how to set the "
"ranges for parsers for the embedded language.  It queries @var{query} in a "
"host language parser, computes the ranges which the captured nodes span, and "
"applies these ranges to embedded language parsers."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1962
msgid ""
"If @var{query} is a function, it doesn't need any @var{keyword} and "
"@var{value} pair.  It should be a function that takes 2 arguments, "
"@var{start} and @var{end}, and sets the ranges for parsers in the current "
"buffer in the region between @var{start} and @var{end}.  It is fine for this "
"function to set ranges in a larger region that encompasses the region "
"between @var{start} and @var{end}."
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:1964
#, no-wrap
msgid "treesit-range-settings"
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:1970
msgid ""
"This variable helps @code{treesit-update-ranges} in updating the ranges for "
"parsers in the buffer.  It is a list of @var{setting}s where the exact "
"format of a @var{setting} is considered internal.  You should use "
"@code{treesit-range-rules} to generate a value that this variable can have."
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:1978
#, no-wrap
msgid "treesit-language-at-point-function"
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:1983
msgid ""
"This variable's value should be a function that takes a single argument, "
"@var{pos}, which is a buffer position, and returns the language of the "
"buffer text at @var{pos}.  This variable is used by "
"@code{treesit-language-at}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1985
#, no-wrap
msgid "treesit-local-parsers-at &optional pos language"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1988
msgid ""
"This function returns all the local parsers at @var{pos} in the current "
"buffer.  @var{pos} defaults to point."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1993
msgid ""
"Local parsers are those which only parse a limited region marked by an "
"overlay with a non-@code{nil} @code{treesit-parser} property.  If "
"@var{language} is non-@code{nil}, only return parsers for that language."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1995
#, no-wrap
msgid "treesit-local-parsers-on &optional beg end language"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:1999
msgid ""
"This function is the same as @code{treesit-local-parsers-at}, but it returns "
"the local parsers in the range between @var{beg} and @var{end} instead of at "
"point."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:2002
msgid ""
"@var{beg} and @var{end} default to the entire accessible portion of the "
"buffer."
msgstr ""

#. type: section
#: original_texis/parsing.texi:2005
#, no-wrap
msgid "Developing major modes with tree-sitter"
msgstr ""

#. type: cindex
#: original_texis/parsing.texi:2006
#, no-wrap
msgid "major mode, developing with tree-sitter"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:2010
msgid ""
"This section covers some general guidelines on developing tree-sitter "
"integration for a major mode."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:2013
msgid ""
"A major mode supporting tree-sitter features should roughly follow this "
"pattern:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:2022
#, no-wrap
msgid ""
"(define-derived-mode woomy-mode prog-mode \"Woomy\"\n"
"  \"A mode for Woomy programming language.\"\n"
"  (when (treesit-ready-p 'woomy)\n"
"    (setq-local treesit-variables ...)\n"
"    ...\n"
"    (treesit-major-mode-setup)))\n"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:2027
msgid ""
"@code{treesit-ready-p} automatically emits a warning if conditions for "
"enabling tree-sitter aren't met."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:2031
msgid ""
"If a tree-sitter major mode shares setup with its ``native'' counterpart, "
"one can create a ``base mode'' that contains the common setup, like this:"
msgstr ""

#. type: group
#: original_texis/parsing.texi:2038
#, no-wrap
msgid ""
"(define-derived-mode woomy--base-mode prog-mode \"Woomy\"\n"
"  \"An internal mode for Woomy programming language.\"\n"
"  (common-setup)\n"
"  ...)\n"
msgstr ""

#. type: group
#: original_texis/parsing.texi:2045
#, no-wrap
msgid ""
"(define-derived-mode woomy-mode woomy--base-mode \"Woomy\"\n"
"  \"A mode for Woomy programming language.\"\n"
"  (native-setup)\n"
"  ...)\n"
msgstr ""

#. type: group
#: original_texis/parsing.texi:2054
#, no-wrap
msgid ""
"(define-derived-mode woomy-ts-mode woomy--base-mode \"Woomy\"\n"
"  \"A mode for Woomy programming language.\"\n"
"  (when (treesit-ready-p 'woomy)\n"
"    (setq-local treesit-variables ...)\n"
"    ...\n"
"    (treesit-major-mode-setup)))\n"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:2057
#, no-wrap
msgid "treesit-ready-p language &optional quiet"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:2063
msgid ""
"This function checks for conditions for activating tree-sitter.  It checks "
"whether Emacs was built with tree-sitter, whether the buffer's size is not "
"too large for tree-sitter to handle, and whether the grammar for "
"@var{language} is available on the system (@pxref{Language Grammar})."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:2067
msgid ""
"This function emits a warning if tree-sitter cannot be activated.  If "
"@var{quiet} is @code{message}, the warning is turned into a message; if "
"@var{quiet} is @code{t}, no warning or message is displayed."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:2070
msgid ""
"If all the necessary conditions are met, this function returns "
"non-@code{nil}; otherwise it returns @code{nil}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:2072
#, no-wrap
msgid "treesit-major-mode-setup"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:2074
msgid "This function activates some tree-sitter features for a major mode."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:2076
msgid "Currently, it sets up the following features:"
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:2080
msgid ""
"If @code{treesit-font-lock-settings} (@pxref{Parser-based Font Lock})  is "
"non-@code{nil}, it sets up fontification."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:2085
msgid ""
"If either @code{treesit-simple-indent-rules} or "
"@code{treesit-indent-function} (@pxref{Parser-based Indentation}) is "
"non-@code{nil}, it sets up indentation."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:2090
msgid ""
"If @code{treesit-defun-type-regexp} is non-@code{nil}, it sets up navigation "
"functions for @code{beginning-of-defun} and @code{end-of-defun}."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:2094
msgid ""
"If @code{treesit-defun-name-function} is non-@code{nil}, it sets up add-log "
"functions used by @code{add-log-current-defun}."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:2098
msgid ""
"If @code{treesit-simple-imenu-settings} (@pxref{Imenu}) is non-@code{nil}, "
"it sets up Imenu."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:2102
msgid ""
"If @code{treesit-outline-predicate} (@pxref{Outline Minor Mode}) is "
"non-@code{nil}, it sets up Outline minor mode."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:2109
msgid ""
"If @code{sexp} and/or @code{sentence} are defined in "
"@code{treesit-thing-settings} (@pxref{User-defined Things}), it enables "
"navigation commands that move, respectively, by sexps and sentences by "
"defining variables such as @code{forward-sexp-function} and "
"@code{forward-sentence-function}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:2117
msgid ""
"For more information on these built-in tree-sitter features, "
"@pxref{Parser-based Font Lock}, @pxref{Parser-based Indentation}, and "
"@pxref{List Motion}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:2120
msgid ""
"For supporting mixing of multiple languages in a major mode, @pxref{Multiple "
"Languages}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:2125
msgid ""
"Besides @code{beginning-of-defun} and @code{end-of-defun}, Emacs provides "
"some additional functions for working with defuns: "
"@code{treesit-defun-at-point} returns the defun node at point, and "
"@code{treesit-defun-name} returns the name of a defun node."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:2128
#, no-wrap
msgid "treesit-defun-at-point"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:2133
msgid ""
"This function returns the defun node at point, or @code{nil} if none is "
"found.  It respects @code{treesit-defun-tactic}: if its value is "
"@code{top-level}, this function returns the top-level defun, and if its "
"value is @code{nested}, it returns the immediate enclosing defun."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:2136
msgid ""
"This function requires @code{treesit-defun-type-regexp} to work.  If it is "
"@code{nil}, this function simply returns @code{nil}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:2138
#, no-wrap
msgid "treesit-defun-name node"
msgstr ""

#. type: defun
#: original_texis/parsing.texi:2142
msgid ""
"This function returns the defun name of @var{node}.  It returns @code{nil} "
"if there is no defun name for @var{node}, or if @var{node} is not a defun "
"node, or if @var{node} is @code{nil}."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:2145
msgid ""
"Depending on the language and major mode, the defun names are names like "
"function name, class name, struct name, etc."
msgstr ""

#. type: defun
#: original_texis/parsing.texi:2148
msgid ""
"If @code{treesit-defun-name-function} is @code{nil}, this function always "
"returns @code{nil}."
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:2150
#, no-wrap
msgid "treesit-defun-name-function"
msgstr ""

#. type: defvar
#: original_texis/parsing.texi:2157
msgid ""
"If non-@code{nil}, this variable's value should be a function that is called "
"with a node as its argument, and returns the defun name of the node.  The "
"function should have the same semantics as @code{treesit-defun-name}: if the "
"node is not a defun node, or the node is a defun node but doesn't have a "
"name, or the node is @code{nil}, it should return @code{nil}."
msgstr ""

#. type: section
#: original_texis/parsing.texi:2160
#, no-wrap
msgid "Tree-sitter C API Correspondence"
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:2164
msgid ""
"Emacs's tree-sitter integration doesn't expose every feature provided by "
"tree-sitter's C API@.  Missing features include:"
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:2168
msgid "Creating a tree cursor and navigating the syntax tree with it."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:2170
msgid "Setting timeout and cancellation flag for a parser."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:2172
msgid "Setting the logger for a parser."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:2174
msgid "Printing a @acronym{DOT} graph of the syntax tree to a file."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:2177
msgid "Copying and modifying a syntax tree.  (Emacs doesn't expose a tree object.)"
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:2179
msgid "Using (row, column) coordinates as position."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:2182
msgid ""
"Updating a node with changes.  (In Emacs, retrieve a new node instead of "
"updating the existing one.)"
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:2184
msgid "Querying statics of a language grammar."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:2188
msgid ""
"In addition, Emacs makes some changes to the C API to make the API more "
"convenient and idiomatic:"
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:2193
msgid ""
"Instead of using byte positions, the Emacs Lisp API uses character "
"positions."
msgstr ""

#. type: itemize
#: original_texis/parsing.texi:2195
msgid "Null nodes are converted to @code{nil}."
msgstr ""

#. type: Plain text
#: original_texis/parsing.texi:2201
msgid ""
"Below is the correspondence between all C API functions and their ELisp "
"counterparts.  Sometimes one ELisp function corresponds to multiple C "
"functions, and many C functions don't have an ELisp counterpart."
msgstr ""

#. type: example
#: original_texis/parsing.texi:2303
#, no-wrap
msgid ""
"ts_parser_new                           treesit-parser-create\n"
"ts_parser_delete\n"
"ts_parser_set_language\n"
"ts_parser_language                      treesit-parser-language\n"
"ts_parser_set_included_ranges           treesit-parser-set-included-ranges\n"
"ts_parser_included_ranges               treesit-parser-included-ranges\n"
"ts_parser_parse\n"
"ts_parser_parse_string                  treesit-parse-string\n"
"ts_parser_parse_string_encoding\n"
"ts_parser_reset\n"
"ts_parser_set_timeout_micros\n"
"ts_parser_timeout_micros\n"
"ts_parser_set_cancellation_flag\n"
"ts_parser_cancellation_flag\n"
"ts_parser_set_logger\n"
"ts_parser_logger\n"
"ts_parser_print_dot_graphs\n"
"ts_tree_copy\n"
"ts_tree_delete\n"
"ts_tree_root_node\n"
"ts_tree_language\n"
"ts_tree_edit\n"
"ts_tree_get_changed_ranges\n"
"ts_tree_print_dot_graph\n"
"ts_node_type                            treesit-node-type\n"
"ts_node_symbol\n"
"ts_node_start_byte                      treesit-node-start\n"
"ts_node_start_point\n"
"ts_node_end_byte                        treesit-node-end\n"
"ts_node_end_point\n"
"ts_node_string                          treesit-node-string\n"
"ts_node_is_null\n"
"ts_node_is_named                        treesit-node-check\n"
"ts_node_is_missing                      treesit-node-check\n"
"ts_node_is_extra                        treesit-node-check\n"
"ts_node_has_changes\n"
"ts_node_has_error                       treesit-node-check\n"
"ts_node_parent                          treesit-node-parent\n"
"ts_node_child                           treesit-node-child\n"
"ts_node_field_name_for_child            treesit-node-field-name-for-child\n"
"ts_node_child_count                     treesit-node-child-count\n"
"ts_node_named_child                     treesit-node-child\n"
"ts_node_named_child_count               treesit-node-child-count\n"
"ts_node_child_by_field_name             treesit-node-child-by-field-name\n"
"ts_node_child_by_field_id\n"
"ts_node_next_sibling                    treesit-node-next-sibling\n"
"ts_node_prev_sibling                    treesit-node-prev-sibling\n"
"ts_node_next_named_sibling              treesit-node-next-sibling\n"
"ts_node_prev_named_sibling              treesit-node-prev-sibling\n"
"ts_node_first_child_for_byte            treesit-node-first-child-for-pos\n"
"ts_node_first_named_child_for_byte      treesit-node-first-child-for-pos\n"
"ts_node_descendant_for_byte_range       treesit-node-descendant-for-range\n"
"ts_node_descendant_for_point_range\n"
"ts_node_named_descendant_for_byte_range treesit-node-descendant-for-range\n"
"ts_node_named_descendant_for_point_range\n"
"ts_node_edit\n"
"ts_node_eq                              treesit-node-eq\n"
"ts_tree_cursor_new\n"
"ts_tree_cursor_delete\n"
"ts_tree_cursor_reset\n"
"ts_tree_cursor_current_node\n"
"ts_tree_cursor_current_field_name\n"
"ts_tree_cursor_current_field_id\n"
"ts_tree_cursor_goto_parent\n"
"ts_tree_cursor_goto_next_sibling\n"
"ts_tree_cursor_goto_first_child\n"
"ts_tree_cursor_goto_first_child_for_byte\n"
"ts_tree_cursor_goto_first_child_for_point\n"
"ts_tree_cursor_copy\n"
"ts_query_new\n"
"ts_query_delete\n"
"ts_query_pattern_count\n"
"ts_query_capture_count\n"
"ts_query_string_count\n"
"ts_query_start_byte_for_pattern\n"
"ts_query_predicates_for_pattern\n"
"ts_query_step_is_definite\n"
"ts_query_capture_name_for_id\n"
"ts_query_string_value_for_id\n"
"ts_query_disable_capture\n"
"ts_query_disable_pattern\n"
"ts_query_cursor_new\n"
"ts_query_cursor_delete\n"
"ts_query_cursor_exec                    treesit-query-capture\n"
"ts_query_cursor_did_exceed_match_limit\n"
"ts_query_cursor_match_limit\n"
"ts_query_cursor_set_match_limit\n"
"ts_query_cursor_set_byte_range\n"
"ts_query_cursor_set_point_range\n"
"ts_query_cursor_next_match\n"
"ts_query_cursor_remove_match\n"
"ts_query_cursor_next_capture\n"
"ts_language_symbol_count\n"
"ts_language_symbol_name\n"
"ts_language_symbol_for_name\n"
"ts_language_field_count\n"
"ts_language_field_name_for_id\n"
"ts_language_field_id_for_name\n"
"ts_language_symbol_type\n"
"ts_language_version\n"
msgstr ""
