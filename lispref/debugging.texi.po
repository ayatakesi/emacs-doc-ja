# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Emacs-24.5\n"
"POT-Creation-Date: 2019-10-14 22:47+0900\n"
"PO-Revision-Date: 2019-11-02 16:07+0900\n"
"Last-Translator: Ayanokoji Takesi <ayanokoji.takesi@gmail.com>\n"
"Language-Team: \n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: node
#: original_texis/debugging.texi:6
#, no-wrap
msgid "Debugging"
msgstr "Debugging"

#. type: chapter
#: original_texis/debugging.texi:7
#, no-wrap
msgid "Debugging Lisp Programs"
msgstr "Debugging Lisp Programs"

#. type: cindex
#: original_texis/debugging.texi:8
#, no-wrap
msgid "debugging lisp programs"
msgstr "debugging lisp programs"

#. type: Plain text
#: original_texis/debugging.texi:12
msgid "There are several ways to find and investigate problems in an Emacs Lisp program."
msgstr "Emacs Lispプログラム内の問題を見つけて詳細に調べる方法がいくつかあります。"

#. type: itemize
#: original_texis/debugging.texi:18
msgid "If a problem occurs when you run the program, you can use the built-in Emacs Lisp debugger to suspend the Lisp evaluator, and examine and/or alter its internal state."
msgstr "プログラム実行中に問題が発生した場合には、Lisp評価機能をサスペンドするためにビルトインのEmacs Lispデバッガを使用して評価機能の内部状態の調査および/または変更を行なうことができる。"

#. type: itemize
#: original_texis/debugging.texi:21
msgid "You can use Edebug, a source-level debugger for Emacs Lisp."
msgstr "Emacs LispにたいするソースレベルデバッガのEdebugを使用できる。"

#. type: itemize
#: original_texis/debugging.texi:25
msgid "If a syntactic problem is preventing Lisp from even reading the program, you can locate it using Lisp editing commands."
msgstr "文法的な問題によりLispがプログラムを読むことさえできない場合には、Lisp編集コマンドを使用して該当箇所を見つけることができる。"

#. type: itemize
#: original_texis/debugging.texi:29
msgid "You can look at the error and warning messages produced by the byte compiler when it compiles the program.  @xref{Compiler Errors}."
msgstr "バイトコンパイラーがプログラムをコンパイルするとき、コンパイラーにより生成されるエラーメッセージと警告メッセージを調べることができる。@ref{Compiler Errors}を参照のこと。"

#. type: itemize
#: original_texis/debugging.texi:33
msgid "You can use the Testcover package to perform coverage testing on the program."
msgstr "Testcoverパッケージを使用してプログラムのテストカバレッジを行なうことができる。"

#. type: itemize
#: original_texis/debugging.texi:37
msgid "You can use the ERT package to write regression tests for the program.  @xref{Top,the ERT manual,, ert, ERT: Emacs Lisp Regression Testing}."
msgstr "ERTパッケージを使用してプログラムにたいするリグレッションテストを記述できる。@ref{Top,the ERT manual,, ert, ERT: Emacs Lisp Regression Testing}を参照のこと。"

#. type: itemize
#: original_texis/debugging.texi:40
msgid "You can profile the program to get hints about how to make it more efficient."
msgstr "プログラムをプロファイルしてプログラムをより効果的にするためのヒントを取得できる。"

#. type: Plain text
#: original_texis/debugging.texi:45
msgid "Other useful tools for debugging input and output problems are the dribble file (@pxref{Terminal Input}) and the @code{open-termscript} function (@pxref{Terminal Output})."
msgstr "入出力の問題をデバックする便利なその他のツールとして、ドリブルファイル(dribble file: @ref{Terminal Input}を参照)と、@code{open-termscript}関数(@ref{Terminal Output})があります。"

#. type: node
#: original_texis/debugging.texi:52 original_texis/debugging.texi:54
#, no-wrap
msgid "Debugger"
msgstr "Debugger"

#. type: menuentry
#: original_texis/debugging.texi:52
msgid "A debugger for the Emacs Lisp evaluator."
msgstr "Emacs Lisp評価機能にたいするデバッガ。"

#. type: menuentry
#: original_texis/debugging.texi:52
msgid "Edebug"
msgstr "Edebug"

#. type: menuentry
#: original_texis/debugging.texi:52
msgid "A source-level Emacs Lisp debugger."
msgstr "Emacs Lispソースレベルデバッガ。"

#. type: node
#: original_texis/debugging.texi:52 original_texis/debugging.texi:682
#, no-wrap
msgid "Syntax Errors"
msgstr "Syntax Errors"

#. type: menuentry
#: original_texis/debugging.texi:52
msgid "How to find syntax errors."
msgstr "シンタックスエラーを見つける方法。"

#. type: section
#: original_texis/debugging.texi:52 original_texis/debugging.texi:773
#: original_texis/debugging.texi:774
#, no-wrap
msgid "Test Coverage"
msgstr "Test Coverage"

#. type: menuentry
#: original_texis/debugging.texi:52
msgid "Ensuring you have tested all branches in your code."
msgstr "プログラムのすべての分岐を確実にテストする。"

#. type: section
#: original_texis/debugging.texi:52 original_texis/debugging.texi:815
#: original_texis/debugging.texi:816
#, no-wrap
msgid "Profiling"
msgstr "Profiling"

#. type: menuentry
#: original_texis/debugging.texi:52
msgid "Measuring the resources that your code uses."
msgstr "あなたのコードが使用するリソースの計測。"

#. type: section
#: original_texis/debugging.texi:55
#, no-wrap
msgid "The Lisp Debugger"
msgstr "The Lisp Debugger"

#. type: cindex
#: original_texis/debugging.texi:56
#, no-wrap
msgid "debugger for Emacs Lisp"
msgstr "debugger for Emacs Lisp"

#. type: cindex
#: original_texis/debugging.texi:57
#, no-wrap
msgid "Lisp debugger"
msgstr "Lisp debugger"

#. type: cindex
#: original_texis/debugging.texi:58
#, no-wrap
msgid "break"
msgstr "break"

#. type: Plain text
#: original_texis/debugging.texi:67
msgid "The ordinary @dfn{Lisp debugger} provides the ability to suspend evaluation of a form.  While evaluation is suspended (a state that is commonly known as a @dfn{break}), you may examine the run time stack, examine the values of local or global variables, or change those values.  Since a break is a recursive edit, all the usual editing facilities of Emacs are available; you can even run programs that will enter the debugger recursively.  @xref{Recursive Editing}."
msgstr "普通の@dfn{Lispデバッガ}は、フォーム評価のサスペンド機能を提供します。評価がサスペンド(一般的には@dfn{break}の状態として知られる)されている間、実行時スタックを調べたり、ローカル変数やグローバル変数の値を調べたり変更することができます。breakは再帰編集(recursive edit)なので、Emacsの通常の編集機能が利用可能です。デバッガにエンターするようにプログラムを実行することさえ可能です。@ref{Recursive Editing}を参照してください。"

#. type: node
#: original_texis/debugging.texi:77 original_texis/debugging.texi:79
#, no-wrap
msgid "Error Debugging"
msgstr "Error Debugging"

#. type: menuentry
#: original_texis/debugging.texi:77
msgid "Entering the debugger when an error happens."
msgstr "エラー発生時にデバッガにエンターする。"

#. type: node
#: original_texis/debugging.texi:77 original_texis/debugging.texi:186
#, no-wrap
msgid "Infinite Loops"
msgstr "Infinite Loops"

#. type: menuentry
#: original_texis/debugging.texi:77
msgid "Stopping and debugging a program that doesn't exit."
msgstr "exitしないプログラムの停止デバッグ。"

#. type: node
#: original_texis/debugging.texi:77 original_texis/debugging.texi:216
#, no-wrap
msgid "Function Debugging"
msgstr "Function Debugging"

#. type: menuentry
#: original_texis/debugging.texi:77
msgid "Entering it when a certain function is called."
msgstr "特定の関数が呼び出されたときにデバッガにエンターする。"

#. type: node
#: original_texis/debugging.texi:77 original_texis/debugging.texi:286
#, no-wrap
msgid "Explicit Debug"
msgstr "Explicit Debug"

#. type: menuentry
#: original_texis/debugging.texi:77
msgid "Entering it at a certain point in the program."
msgstr "プログラム内の特定箇所でデバッガにエンターする。"

#. type: node
#: original_texis/debugging.texi:77 original_texis/debugging.texi:309
#, no-wrap
msgid "Using Debugger"
msgstr "Using Debugger"

#. type: menuentry
#: original_texis/debugging.texi:77
msgid "What the debugger does; what you see while in it."
msgstr "デバッガが行なうこと: そこで何を目にするか。"

#. type: subsection
#: original_texis/debugging.texi:77 original_texis/debugging.texi:366
#: original_texis/debugging.texi:367
#, no-wrap
msgid "Debugger Commands"
msgstr "Debugger Commands"

#. type: menuentry
#: original_texis/debugging.texi:77
msgid "Commands used while in the debugger."
msgstr "デバッガで使用するコマンド。"

#. type: subsection
#: original_texis/debugging.texi:77 original_texis/debugging.texi:460
#: original_texis/debugging.texi:461
#, no-wrap
msgid "Invoking the Debugger"
msgstr "Invoking the Debugger"

#. type: menuentry
#: original_texis/debugging.texi:77
msgid "How to call the function @code{debug}."
msgstr "関数@code{debug}の呼び出し方。"

#. type: node
#: original_texis/debugging.texi:77 original_texis/debugging.texi:556
#, no-wrap
msgid "Internals of Debugger"
msgstr "Internals of Debugger"

#. type: menuentry
#: original_texis/debugging.texi:77
msgid "Subroutines of the debugger, and global variables."
msgstr "デバッガのサブルーチンとグローバル変数。"

#. type: subsection
#: original_texis/debugging.texi:80
#, no-wrap
msgid "Entering the Debugger on an Error"
msgstr "Entering the Debugger on an Error"

#. type: cindex
#: original_texis/debugging.texi:81
#, no-wrap
msgid "error debugging"
msgstr "error debugging"

#. type: cindex
#: original_texis/debugging.texi:82
#, no-wrap
msgid "debugging errors"
msgstr "debugging errors"

#. type: Plain text
#: original_texis/debugging.texi:87
msgid "The most important time to enter the debugger is when a Lisp error happens.  This allows you to investigate the immediate causes of the error."
msgstr "デバッガに入るタイミングとして一番重要なのは、Lispエラーが発生したときです。デバッガではエラーの直接原因を調査できます。"

#. type: Plain text
#: original_texis/debugging.texi:95
msgid "However, entry to the debugger is not a normal consequence of an error.  Many commands signal Lisp errors when invoked inappropriately, and during ordinary editing it would be very inconvenient to enter the debugger each time this happens.  So if you want errors to enter the debugger, set the variable @code{debug-on-error} to non-@code{nil}.  (The command @code{toggle-debug-on-error} provides an easy way to do this.)"
msgstr "しかしデバッガへのエンターは、エラーによる通常の結末ではありません。多くのコマンドは不適切に呼び出されたときにLispエラーをシグナルするので、通常の編集の間にこれが発生するたびデバッガにエンターするのは、とても不便でしょう。したがってエラーの際にデバッガにエンターしたいなら、変数@code{debug-on-error}に非@code{nil}をセットします(コマンド@code{toggle-debug-on-error}はこれを簡単に行う方法を提供する)。"

#. type: defopt
#: original_texis/debugging.texi:96
#, no-wrap
msgid "debug-on-error"
msgstr "debug-on-error"

#. type: defopt
#: original_texis/debugging.texi:102
msgid "This variable determines whether the debugger is called when an error is signaled and not handled.  If @code{debug-on-error} is @code{t}, all kinds of errors call the debugger, except those listed in @code{debug-ignored-errors} (see below).  If it is @code{nil}, none call the debugger."
msgstr "この変数はエラーがシグナルされて、それがハンドルされていないときにデバッガを呼び出すかどうかを決定する。@code{debug-on-error}が@code{t}なら、@code{debug-ignored-errors}(以下参照)にリストされているエラー以外の、すべての種類のエラーがデバッガを呼び出す。@code{nil}ならデバッガを呼び出さない。"

#. type: defopt
#: original_texis/debugging.texi:109
msgid "The value can also be a list of error conditions (@pxref{Signaling Errors}).  Then the debugger is called only for error conditions in this list (except those also listed in @code{debug-ignored-errors}).  For example, if you set @code{debug-on-error} to the list @code{(void-variable)}, the debugger is only called for errors about a variable that has no value."
msgstr "値にはエラー条件(@ref{Signaling Errors}を参照)のリストも指定できる。その場合はこのリスト内のエラー条件だけによってデバッガが呼び出される(@code{debug-ignored-errors}にもリストされているエラー条件は除外される)。たとえば@code{debug-on-error}をリスト@code{(void-variable)}にセットすると、値をもたない変数に関するエラーにたいしてのみデバッガが呼び出される。"

#. type: defopt
#: original_texis/debugging.texi:112
msgid "Note that @code{eval-expression-debug-on-error} overrides this variable in some cases; see below."
msgstr "@code{eval-expression-debug-on-error}がこの変数をオーバーライドするケースがいくつかあることに注意(以下参照)。"

#. type: defopt
#: original_texis/debugging.texi:116
msgid "When this variable is non-@code{nil}, Emacs does not create an error handler around process filter functions and sentinels.  Therefore, errors in these functions also invoke the debugger.  @xref{Processes}."
msgstr "この変数が非@code{nil}のとき、Emacsはプロセスフィルター関数と番兵(sentinel)の周囲にエラーハンドラーを作成しない。したがってこれらの関数内でのエラーは、デバッガを呼び出す。@ref{Processes}を参照のこと。"

#. type: defopt
#: original_texis/debugging.texi:118
#, no-wrap
msgid "debug-ignored-errors"
msgstr "debug-ignored-errors"

#. type: defopt
#: original_texis/debugging.texi:125
msgid "This variable specifies errors which should not enter the debugger, regardless of the value of @code{debug-on-error}.  Its value is a list of error condition symbols and/or regular expressions.  If the error has any of those condition symbols, or if the error message matches any of the regular expressions, then that error does not enter the debugger."
msgstr "この変数は@code{debug-on-error}の値に関わらず、デバッガにエンターすべきでないエラーを指定する。変数の値はエラー条件のシンボルおよび/または正規表現のリスト。エラーがこれら条件シンボルのいずれか、またはエラーメッセージが正規表現のいずれかにマッチすれば、そのエラーはデバッガにエンターしない。"

#. type: defopt
#: original_texis/debugging.texi:132
msgid "The normal value of this variable includes @code{user-error}, as well as several errors that happen often during editing but rarely result from bugs in Lisp programs.  However, ``rarely'' is not ``never''; if your program fails with an error that matches this list, you may try changing this list to debug the error.  The easiest way is usually to set @code{debug-ignored-errors} to @code{nil}."
msgstr "この変数の通常の値には@code{user-error}、および編集中に頻繁に発生するがLispプログラムのバグに起因することは稀であるような、いくつかのエラーが含まれる。しかし``稀である''ことは``絶対ない''ということではない。あなたのプログラムがこのリストにマッチするエラーによって機能しないなら、そのエラーをデバッグするためにこのリストの変更を試みるのもよいだろう。通常は@code{debug-ignored-errors}を@code{nil}にセットしておくのが、もっとも簡単な方法である。"

#. type: defopt
#: original_texis/debugging.texi:134
#, no-wrap
msgid "eval-expression-debug-on-error"
msgstr "eval-expression-debug-on-error"

#. type: defopt
#: original_texis/debugging.texi:139
msgid "If this variable has a non-@code{nil} value (the default), running the command @code{eval-expression} causes @code{debug-on-error} to be temporarily bound to to @code{t}.  @xref{Lisp Eval,, Evaluating Emacs-Lisp Expressions, emacs, The GNU Emacs Manual}."
msgstr "この変数が非@code{nil}値(デフォルト)なら、コマンド@code{eval-expression}の実行によって一時的に@code{debug-on-error}が@code{t}がバインドされる。@ref{Lisp Eval,, Evaluating Emacs-Lisp Expressions, emacs, The GNU Emacs Manual}を参照のこと。"

#. type: defopt
#: original_texis/debugging.texi:142
msgid "If @code{eval-expression-debug-on-error} is @code{nil}, then the value of @code{debug-on-error} is not changed during @code{eval-expression}."
msgstr "@code{eval-expression-debug-on-error}が@code{nil}なら、@code{eval-expression}の間も@code{debug-on-error}の値は変更されない。"

#. type: defopt
#: original_texis/debugging.texi:144
#, no-wrap
msgid "debug-on-signal"
msgstr "debug-on-signal"

#. type: defopt
#: original_texis/debugging.texi:148
msgid "Normally, errors caught by @code{condition-case} never invoke the debugger.  The @code{condition-case} gets a chance to handle the error before the debugger gets a chance."
msgstr "@code{condition-case}でキャッチされたエラー、は通常は決してデバッガを呼び出さない。@code{condition-case}はデバッガがそのエラーをハンドルする前にエラーをハンドルする機会を得る。"

#. type: defopt
#: original_texis/debugging.texi:154
msgid "If you change @code{debug-on-signal} to a non-@code{nil} value, the debugger gets the first chance at every error, regardless of the presence of @code{condition-case}.  (To invoke the debugger, the error must still fulfill the criteria specified by @code{debug-on-error} and @code{debug-ignored-errors}.)"
msgstr "@code{debug-on-signal}を非@code{nil}値に変更すると、@code{condition-case}の存在如何に関わらずすべてのエラーにおいてデバッガが最初に機会を得る(デバッガを呼び出すためには依然としてそのエラーが@code{debug-on-error}と@code{debug-ignored-errors}で指定された条件を満たさなければならない)。"

#. type: defopt
#: original_texis/debugging.texi:161
msgid "@strong{Warning:} Setting this variable to non-@code{nil} may have annoying effects.  Various parts of Emacs catch errors in the normal course of affairs, and you may not even realize that errors happen there.  If you need to debug code wrapped in @code{condition-case}, consider using @code{condition-case-unless-debug} (@pxref{Handling Errors})."
msgstr "@strong{警告:} この変数を非@code{nil}にセットすると、芳しくない効果があるかもしれない。Emacsのさまざまな部分で処理の通常の過程としてエラーがキャッチされており、そのエラーが発生したことに気づかないことさえあるかもしれない。@code{condition-case}でラップされたコードをデバッグする必要があるなら、@code{condition-case-unless-debug}(@pxref{Handling Errors}を参照)の使用を考慮されたい。"

#. type: defopt
#: original_texis/debugging.texi:163
#, no-wrap
msgid "debug-on-event"
msgstr "debug-on-event"

#. type: defopt
#: original_texis/debugging.texi:170
msgid "If you set @code{debug-on-event} to a special event (@pxref{Special Events}), Emacs will try to enter the debugger as soon as it receives this event, bypassing @code{special-event-map}.  At present, the only supported values correspond to the signals @code{SIGUSR1} and @code{SIGUSR2} (this is the default).  This can be helpful when @code{inhibit-quit} is set and Emacs is not otherwise responding."
msgstr "@code{debug-on-event}をスペシャルイベント(@ref{Special Events}を参照)にセットすると、Emacsは@code{special-event-map}をバイパスしてこのイベントを受け取ると即座にデバッガへのエンターを試みる。現在のところサポートされる値は、シグナル@code{SIGUSR1}と@code{SIGUSR2}に対応する値のみ(これがデフォルト)。これは@code{inhibit-quit}がセットされていて、それ以外はEmacsが応答しない場合に有用かもしれない。"

#. type: cindex
#: original_texis/debugging.texi:172
#, no-wrap
msgid "message, finding what causes a particular message"
msgstr "message, finding what causes a particular message"

#. type: defvar
#: original_texis/debugging.texi:173
#, no-wrap
msgid "debug-on-message"
msgstr "debug-on-message"

#. type: defvar
#: original_texis/debugging.texi:178
msgid "If you set @code{debug-on-message} to a regular expression, Emacs will enter the debugger if it displays a matching message in the echo area.  For example, this can be useful when trying to find the cause of a particular message."
msgstr "@code{debug-on-message}に正規表現をセットした場合は、それにマッチするメッセージがエコーエリアに表示されると、Emacsはデバッガにエンターする。たとえばこれは特定のメッセージの原因を探すのに有用かもしれない。"

#. type: Plain text
#: original_texis/debugging.texi:185
msgid "To debug an error that happens during loading of the init file, use the option @samp{--debug-init}.  This binds @code{debug-on-error} to @code{t} while loading the init file, and bypasses the @code{condition-case} which normally catches errors in the init file."
msgstr "initファイルロード中に発生したエラーをデバッグするには、オプション@samp{--debug-init}を使用する。これはinitファイルロードの間に@code{debug-on-error}を@code{t}にバインドして、通常はinitファイル内のエラーをキャッチする@code{condition-case}をバイパスする。"

#. type: subsection
#: original_texis/debugging.texi:187
#, no-wrap
msgid "Debugging Infinite Loops"
msgstr "Debugging Infinite Loops"

#. type: cindex
#: original_texis/debugging.texi:188
#, no-wrap
msgid "infinite loops"
msgstr "infinite loops"

#. type: cindex
#: original_texis/debugging.texi:189
#, no-wrap
msgid "loops, infinite"
msgstr "loops, infinite"

#. type: cindex
#: original_texis/debugging.texi:190
#, no-wrap
msgid "quitting from infinite loop"
msgstr "quitting from infinite loop"

#. type: cindex
#: original_texis/debugging.texi:191
#, no-wrap
msgid "stopping an infinite loop"
msgstr "stopping an infinite loop"

#. type: Plain text
#: original_texis/debugging.texi:196
msgid "When a program loops infinitely and fails to return, your first problem is to stop the loop.  On most operating systems, you can do this with @kbd{C-g}, which causes a @dfn{quit}.  @xref{Quitting}."
msgstr "プログラムが無限にループしてリターンできないとき、最初の問題はそのループをいかに停止するかです。ほとんどのオペレーティングシステムでは、(@dfn{quit}させる)@kbd{C-g}でこれを行うことができます。@ref{Quitting}を参照してください。"

#. type: Plain text
#: original_texis/debugging.texi:203
msgid "Ordinary quitting gives no information about why the program was looping.  To get more information, you can set the variable @code{debug-on-quit} to non-@code{nil}.  Once you have the debugger running in the middle of the infinite loop, you can proceed from the debugger using the stepping commands.  If you step through the entire loop, you may get enough information to solve the problem."
msgstr "普通のquitでは、なぜそのプログラムがループしたかについての情報は与えられません。変数@code{debug-on-quit}に非@code{nil}をセットすることにより、より多くの情報を得ることができます。無限ループの途中でデバッガを実行すれば、デバッガからステップコマンドで先へ進むことができます。ループ全体をステップで追えば、問題を解決するために十分な情報が得られるでしょう。"

#. type: Plain text
#: original_texis/debugging.texi:207
msgid "Quitting with @kbd{C-g} is not considered an error, and @code{debug-on-error} has no effect on the handling of @kbd{C-g}.  Likewise, @code{debug-on-quit} has no effect on errors."
msgstr "@kbd{C-g}によるquitはエラーとは判断されないので、@kbd{C-g}のハンドルに@code{debug-on-error}は効果がありません。同じように@code{debug-on-quit}はエラーにたいして効果がありません。"

#. type: defopt
#: original_texis/debugging.texi:208
#, no-wrap
msgid "debug-on-quit"
msgstr "debug-on-quit"

#. type: defopt
#: original_texis/debugging.texi:214
msgid "This variable determines whether the debugger is called when @code{quit} is signaled and not handled.  If @code{debug-on-quit} is non-@code{nil}, then the debugger is called whenever you quit (that is, type @kbd{C-g}).  If @code{debug-on-quit} is @code{nil} (the default), then the debugger is not called when you quit."
msgstr "この変数は@code{quit}がシグナルされて、それがハンドルされていないときにデバッガを呼び出すかどうかを決定する。@code{debug-on-quit}が非@code{nil}なら、quit(つまり@kbd{C-g}をタイプ)したときは常にデバッガが呼び出される。@code{debug-on-quit}が@code{nil}(デフォルト)なら、quitしてもデバッガは呼び出されない。"

#. type: subsection
#: original_texis/debugging.texi:217
#, no-wrap
msgid "Entering the Debugger on a Function Call"
msgstr "Entering the Debugger on a Function Call"

#. type: cindex
#: original_texis/debugging.texi:218
#, no-wrap
msgid "function call debugging"
msgstr "function call debugging"

#. type: cindex
#: original_texis/debugging.texi:219
#, no-wrap
msgid "debugging specific functions"
msgstr "debugging specific functions"

#. type: Plain text
#: original_texis/debugging.texi:227
msgid "To investigate a problem that happens in the middle of a program, one useful technique is to enter the debugger whenever a certain function is called.  You can do this to the function in which the problem occurs, and then step through the function, or you can do this to a function called shortly before the problem, step quickly over the call to that function, and then step through its caller."
msgstr "プログラムの途中で発生する問題を調べるための有用なテクニックの1つは、特定の関数が呼び出されたときデバッガにエンターする方法です。問題が発生した関数にこれを行ってその関数をステップで追ったり、問題箇所の少し手前の関数呼び出しでこれを行って、その関数をステップオーバーしてその後をステップで追うことができます。"

#. type: deffn
#: original_texis/debugging.texi:228
#, no-wrap
msgid "Command debug-on-entry function-name"
msgstr "Command debug-on-entry function-name"

#. type: deffn
#: original_texis/debugging.texi:231
msgid "This function requests @var{function-name} to invoke the debugger each time it is called."
msgstr "この関数は@var{function-name}が呼び出されるたびにデバッガの呼び出しを要求する。"

#. type: deffn
#: original_texis/debugging.texi:240
msgid "Any function or macro defined as Lisp code may be set to break on entry, regardless of whether it is interpreted code or compiled code.  If the function is a command, it will enter the debugger when called from Lisp and when called interactively (after the reading of the arguments).  You can also set debug-on-entry for primitive functions (i.e., those written in C) this way, but it only takes effect when the primitive is called from Lisp code.  Debug-on-entry is not allowed for special forms."
msgstr "Lispコードで定義された任意の関数とマクロは、インタープリターに解釈されたコードかコンパイル済みのコードかに関わらず、エントリーにbreakをセットできる。その関数がコマンドならLispから呼び出されたときと、インタラクティブに呼び出されたときにデバッガにエンターする。(たとえばCで記述された)プリミティブ関数にもこの方法で@code{debug-on-entry}をセットできるが、そのプリミティブがLispコードから呼び出されたときだけ効果がある。@code{debug-on-entry}はスペシャルフォームにはセットできない。"

#. type: deffn
#: original_texis/debugging.texi:245
msgid "When @code{debug-on-entry} is called interactively, it prompts for @var{function-name} in the minibuffer.  If the function is already set up to invoke the debugger on entry, @code{debug-on-entry} does nothing.  @code{debug-on-entry} always returns @var{function-name}."
msgstr "@code{debug-on-entry}がインタラクティブに呼び出されたときは、ミニバッファーで@var{function-name}の入力を求める。その関数がすでにエントリーでデバッガを呼び出すようにセットアップされていたら、@code{debug-on-entry}は何も行わない。@code{debug-on-entry}は常に@var{function-name}をリターンする。"

#. type: deffn
#: original_texis/debugging.texi:247
msgid "Here's an example to illustrate use of this function:"
msgstr "以下はこの関数の使い方を説明するための例である:"

#. type: group
#: original_texis/debugging.texi:254
#, no-wrap
msgid ""
"(defun fact (n)\n"
"  (if (zerop n) 1\n"
"      (* n (fact (1- n)))))\n"
"     @result{} fact\n"
msgstr ""
"(defun fact (n)\n"
"  (if (zerop n) 1\n"
"      (* n (fact (1- n)))))\n"
"     @result{} fact\n"

#. type: group
#: original_texis/debugging.texi:258
#, no-wrap
msgid ""
"(debug-on-entry 'fact)\n"
"     @result{} fact\n"
msgstr ""
"(debug-on-entry 'fact)\n"
"     @result{} fact\n"

#. type: group
#: original_texis/debugging.texi:261
#, no-wrap
msgid "(fact 3)\n"
msgstr "(fact 3)\n"

#. type: group
#: original_texis/debugging.texi:272
#, no-wrap
msgid ""
"------ Buffer: *Backtrace* ------\n"
"Debugger entered--entering a function:\n"
"* fact(3)\n"
"  eval((fact 3))\n"
"  eval-last-sexp-1(nil)\n"
"  eval-last-sexp(nil)\n"
"  call-interactively(eval-last-sexp)\n"
"------ Buffer: *Backtrace* ------\n"
msgstr ""
"------ Buffer: *Backtrace* ------\n"
"Debugger entered--entering a function:\n"
"* fact(3)\n"
"  eval((fact 3))\n"
"  eval-last-sexp-1(nil)\n"
"  eval-last-sexp(nil)\n"
"  call-interactively(eval-last-sexp)\n"
"------ Buffer: *Backtrace* ------\n"

#. type: deffn
#: original_texis/debugging.texi:277
#, no-wrap
msgid "Command cancel-debug-on-entry &optional function-name"
msgstr "Command cancel-debug-on-entry &optional function-name"

#. type: deffn
#: original_texis/debugging.texi:284
msgid "This function undoes the effect of @code{debug-on-entry} on @var{function-name}.  When called interactively, it prompts for @var{function-name} in the minibuffer.  If @var{function-name} is omitted or @code{nil}, it cancels break-on-entry for all functions.  Calling @code{cancel-debug-on-entry} does nothing to a function which is not currently set up to break on entry."
msgstr "この関数は@var{function-name}にたいする@code{debug-on-entry}の効果をアンドゥする。インタラクティブに呼び出されたときは、ミニバッファーで@var{function-name}の入力を求める。@var{function-name}が省略または@code{nil}なら、すべての関数にたいするbreak-on-entryをキャンセルする。エントリー時にbreakするようセットアップされていない関数に@code{cancel-debug-on-entry}を呼び出したときは何も行わない。"

#. type: subsection
#: original_texis/debugging.texi:287
#, no-wrap
msgid "Explicit Entry to the Debugger"
msgstr "Explicit Entry to the Debugger"

#. type: cindex
#: original_texis/debugging.texi:288
#, no-wrap
msgid "debugger, explicit entry"
msgstr "debugger, explicit entry"

#. type: cindex
#: original_texis/debugging.texi:289
#, no-wrap
msgid "force entry to debugger"
msgstr "force entry to debugger"

#. type: Plain text
#: original_texis/debugging.texi:297
msgid "You can cause the debugger to be called at a certain point in your program by writing the expression @code{(debug)} at that point.  To do this, visit the source file, insert the text @samp{(debug)} at the proper place, and type @kbd{C-M-x} (@code{eval-defun}, a Lisp mode key binding).  @strong{Warning:} if you do this for temporary debugging purposes, be sure to undo this insertion before you save the file!"
msgstr "プログラム内の特定箇所に式@code{(debug)}を記述することによって、その箇所でデバッガが呼び出されるようにできます。これを行うにはソースファイルをvisitして、適切な箇所にテキスト@samp{(debug)}を挿入し、@kbd{C-M-x}(Lispモードでの@code{eval-defun}にたいするキーバインド)をタイプします。@strong{警告:} 一時的なデバッグ目的のためにこれを行なう場合には、ファイルを保存する前に確実にアンドゥしてください!"

#. type: Plain text
#: original_texis/debugging.texi:303
msgid "The place where you insert @samp{(debug)} must be a place where an additional form can be evaluated and its value ignored.  (If the value of @code{(debug)} isn't ignored, it will alter the execution of the program!)  The most common suitable places are inside a @code{progn} or an implicit @code{progn} (@pxref{Sequencing})."
msgstr "@samp{(debug)}を挿入する箇所は追加フォームが評価されることができ、かつその値を無視することができる箇所でなければなりません(@samp{(debug)}の値を無視しないとプログラムの実行が変更されてしまうだろう!)。一般的にもっとも適した箇所は、@code{progn}または暗黙的な@code{progn}(@ref{Sequencing}を参照)の内部です。"

#. type: Plain text
#: original_texis/debugging.texi:308
msgid "If you don't know exactly where in the source code you want to put the debug statement, but you want to display a backtrace when a certain message is displayed, you can set @code{debug-on-message} to a regular expression matching the desired message."
msgstr "デバッグ命令を配置したいソースコード中の正確な箇所がわからないが、特定のメッセージが表示されたときにバックトレースを表示したい場合には、意図するメッセージにマッチする正規表現を@code{debug-on-message}にセットできます。"

#. type: subsection
#: original_texis/debugging.texi:310
#, no-wrap
msgid "Using the Debugger"
msgstr "Using the Debugger"

#. type: Plain text
#: original_texis/debugging.texi:319
msgid "When the debugger is entered, it displays the previously selected buffer in one window and a buffer named @file{*Backtrace*} in another window.  The backtrace buffer contains one line for each level of Lisp function execution currently going on.  At the beginning of this buffer is a message describing the reason that the debugger was invoked (such as the error message and associated data, if it was invoked due to an error)."
msgstr "デバッガにエンターすると、その前に選択されていたウィンドウを1つのウィンドウに表示して、他のウィンドウに@file{*Backtrace*}という名前のバッファーを表示します。backtraceバッファーには、現在実行されているLisp関数の各レベルが1行ずつ含まれます。このバッファーの先頭は、デバッガが呼び出された理由を説明するメッセージ(デバッガがエラーにより呼び出された場合はエラーメッセージや関連するデータなど)です。"

#. type: vindex
#: original_texis/debugging.texi:320
#, no-wrap
msgid "debugger-bury-or-kill"
msgstr "debugger-bury-or-kill"

#. type: Plain text
#: original_texis/debugging.texi:335
msgid "The backtrace buffer is read-only and uses a special major mode, Debugger mode, in which letters are defined as debugger commands.  The usual Emacs editing commands are available; thus, you can switch windows to examine the buffer that was being edited at the time of the error, switch buffers, visit files, or do any other sort of editing.  However, the debugger is a recursive editing level (@pxref{Recursive Editing})  and it is wise to go back to the backtrace buffer and exit the debugger (with the @kbd{q} command) when you are finished with it.  Exiting the debugger gets out of the recursive edit and buries the backtrace buffer.  (You can customize what the @kbd{q} command does with the backtrace buffer by setting the variable @code{debugger-bury-or-kill}.  For example, set it to @code{kill} if you prefer to kill the buffer rather than bury it.  Consult the variable's documentation for more possibilities.)"
msgstr "backtraceバッファーは読み取り専用で、文字キーにデバッガコマンドが定義されたDebuggerモードという特別なメジャーモードを使用します。通常のEmacs編集コマンドが利用できます。したがってエラー時に編集されていたバッファーを調べるためにウィンドウを切り替えたり、バッファーの切り替えやファイルのvisit、その他一連の編集処理を行なうことができます。しかしデバッガは再帰編集レベル(@ref{Recursive Editing}を参照)にあり、編集が終わったらそれはbacktraceバッファーに戻って、(@kbd{q}コマンドで)デバッガをexitできます。デバッガをexitすることによって再帰編集を抜け出し、backtraceバッファーはバリー(bury: 覆い隠す)されます(変数@code{debugger-bury-or-killw}をセットすることによってbacktraceバッファーで@kbd{q}コマンドが何を行うかをカスタマイズできる。たとえばバッファーをバリーせずにkillしたいなら、この変数を@code{kill}にセットする。他の値については変数のドキュメントを調べてほしい)。"

#. type: Plain text
#: original_texis/debugging.texi:345
msgid "When the debugger has been entered, the @code{debug-on-error} variable is temporarily set according to @code{eval-expression-debug-on-error}.  If the latter variable is non-@code{nil}, @code{debug-on-error} will temporarily be set to @code{t}.  This means that any further errors that occur while doing a debugging session will (by default) trigger another backtrace.  If this is not what you want, you can either set @code{eval-expression-debug-on-error} to @code{nil}, or set @code{debug-on-error} to @code{nil} in @code{debugger-mode-hook}."
msgstr "デバッガにエンターしたとき、@code{eval-expression-debug-on-error}に一致するように変数@code{debug-on-error}が一時的にセットされます。変数@code{eval-expression-debug-on-error}が非@code{nil}なら、@code{debug-on-error}は一時的に@code{t}にセットされます。これはデバッグセッション行っている間にさらにエラーが発生すると、(デフォルトでは)他のbacktraceがトリガーされることを意味します。これが望ましくなければ、@code{debugger-mode-hook}内で@code{eval-expression-debug-on-error}を@code{nil}にセットするか、@code{debug-on-error}を@code{nil}にセットすることができます。"

#. type: cindex
#: original_texis/debugging.texi:346
#, no-wrap
msgid "current stack frame"
msgstr "current stack frame"

#. type: Plain text
#: original_texis/debugging.texi:356
msgid "The backtrace buffer shows you the functions that are executing and their argument values.  It also allows you to specify a stack frame by moving point to the line describing that frame.  (A stack frame is the place where the Lisp interpreter records information about a particular invocation of a function.)  The frame whose line point is on is considered the @dfn{current frame}.  Some of the debugger commands operate on the current frame.  If a line starts with a star, that means that exiting that frame will call the debugger again.  This is useful for examining the return value of a function."
msgstr "backtraceバッファーは実行されている関数と、その関数の引数の値を示します。そのフレームを示す行にポイントを移動して、スタックフレームを指定することもできます(スタックフレームとは、Lispインタープリターがある関数への特定の呼び出しを記録する場所のこと)。行ポイントがオンのフレームが、@dfn{カレントフレーム(current frame)}となります。デバッガコマンドのいくつかは、カレントフレームを処理します。ある行がスター(star)で始まる場合は、そのフレームをexitすることによって再びデバッガが呼び出されることを意味します。これは関数のリターン値を調べるとき有用です。"

#. type: Plain text
#: original_texis/debugging.texi:360
msgid "If a function name is underlined, that means the debugger knows where its source code is located.  You can click with the mouse on that name, or move to it and type @key{RET}, to visit the source code."
msgstr "関数名にアンダーラインが引かれている場合は、デバッガがその関数のソースコードの位置を知っていることを意味します。その名前をマウスでクリックするか、そこに移動して@key{RET}をタイプすれば、ソースコードをvisitできます。"

#. type: Plain text
#: original_texis/debugging.texi:365
msgid "The debugger itself must be run byte-compiled, since it makes assumptions about how many stack frames are used for the debugger itself.  These assumptions are false if the debugger is running interpreted."
msgstr "デバッガはデバッガ自身のスタックフレーム数を想定するため、バイトコンパイルされて実行されなければなりません。デバッガがインタープリターに解釈されて実行されているときは、これらの想定は正しくなくなります。"

#. type: cindex
#: original_texis/debugging.texi:368
#, no-wrap
msgid "debugger command list"
msgstr "debugger command list"

#. type: Plain text
#: original_texis/debugging.texi:380
msgid "The debugger buffer (in Debugger mode) provides special commands in addition to the usual Emacs commands.  The most important use of debugger commands is for stepping through code, so that you can see how control flows.  The debugger can step through the control structures of an interpreted function, but cannot do so in a byte-compiled function.  If you would like to step through a byte-compiled function, replace it with an interpreted definition of the same function.  (To do this, visit the source for the function and type @kbd{C-M-x} on its definition.)  You cannot use the Lisp debugger to step through a primitive function."
msgstr "(Debuggerモードの)debuggerバッファーでは、通常のEmacsコマンドに加えて特別なコマンドが提供されます。デバッガでもっとも重要な使い方をするのは、制御フローを見ることができるコードをステップ実行するコマンドです。デバッガはインタープリターによって解釈された制御構造のステップ実行はできますが、バイトコンパイル済みの関数ではできません。バイトコンパイル済み関数をステップ実行したいなら、同じ関数の解釈された定義に置き換えてください(これを行なうにはその関数のソースをvisitして、関数の定義で@kbd{C-M-x}とタイプする)。プリミティブ関数のステップ実行にLispデバッガは使用できません。"

#. type: Plain text
#: original_texis/debugging.texi:383
msgid "Here is a list of Debugger mode commands:"
msgstr "以下はDebuggerモードのコマンドのリストです:"

#. type: item
#: original_texis/debugging.texi:385
#, no-wrap
msgid "c"
msgstr "c"

#. type: table
#: original_texis/debugging.texi:390
msgid "Exit the debugger and continue execution.  This resumes execution of the program as if the debugger had never been entered (aside from any side-effects that you caused by changing variable values or data structures while inside the debugger)."
msgstr "デバッガをexitして実行を継続する。これはあたかもデバッガにエンターしなかったかのようにプログラムの実行を再開する(デバッガ内で行った変数値やデータ構造の変更などの副作用は除外)。"

#. type: item
#: original_texis/debugging.texi:391
#, no-wrap
msgid "d"
msgstr "d"

#. type: table
#: original_texis/debugging.texi:396
msgid "Continue execution, but enter the debugger the next time any Lisp function is called.  This allows you to step through the subexpressions of an expression, seeing what values the subexpressions compute, and what else they do."
msgstr "実行を継続するが、次にLisp関数が何か呼び出されたときはデバッガにエンターする。これによりある式の下位の式をステップ実行して、下位の式が計算する値や行うことを確認できる。"

#. type: table
#: original_texis/debugging.texi:401
msgid "The stack frame made for the function call which enters the debugger in this way will be flagged automatically so that the debugger will be called again when the frame is exited.  You can use the @kbd{u} command to cancel this flag."
msgstr "デバッガにエンターした関数呼び出しにたいして、この方法で作成されたスタックフレームには自動的にフラグがつくため、そのフレームをexitすると再びデバッガが呼び出される。このフラグは@kbd{u}コマンドを使用してキャンセルできる。"

#. type: item
#: original_texis/debugging.texi:402
#, no-wrap
msgid "b"
msgstr "b"

#. type: table
#: original_texis/debugging.texi:406
msgid "Flag the current frame so that the debugger will be entered when the frame is exited.  Frames flagged in this way are marked with stars in the backtrace buffer."
msgstr "カレントフレームにフラグをつけるので、そのフレームをexitするときデバッガにエンターする。この方法でフラグがつけられたフレームは、backtraceバッファーでスターのマークがつく。"

#. type: item
#: original_texis/debugging.texi:407
#, no-wrap
msgid "u"
msgstr "u"

#. type: table
#: original_texis/debugging.texi:411
msgid "Don't enter the debugger when the current frame is exited.  This cancels a @kbd{b} command on that frame.  The visible effect is to remove the star from the line in the backtrace buffer."
msgstr "カレントフレームをexitしたときデバッガにエンターしない。これはそのフレームの@kbd{b}コマンドをキャンセルする。目に見える効果としてはbacktraceバッファーの行からスターが削除される。"

#. type: item
#: original_texis/debugging.texi:412
#, no-wrap
msgid "j"
msgstr "j"

#. type: table
#: original_texis/debugging.texi:416
msgid "Flag the current frame like @kbd{b}.  Then continue execution like @kbd{c}, but temporarily disable break-on-entry for all functions that are set up to do so by @code{debug-on-entry}."
msgstr "@kbd{b}と同じようにカレントフレームにフラグをつける。その後に@kbd{c}のように実行を継続するが、@code{debug-on-entry}によりセットアップされたすべての関数にたいするbreak-on-entryを一時的に無効にする。"

#. type: item
#: original_texis/debugging.texi:417
#, no-wrap
msgid "e"
msgstr "e"

#. type: table
#: original_texis/debugging.texi:426
msgid "Read a Lisp expression in the minibuffer, evaluate it (with the relevant lexical environment, if applicable), and print the value in the echo area.  The debugger alters certain important variables, and the current buffer, as part of its operation; @kbd{e} temporarily restores their values from outside the debugger, so you can examine and change them.  This makes the debugger more transparent.  By contrast, @kbd{M-:} does nothing special in the debugger; it shows you the variable values within the debugger."
msgstr "ミニバッファーのLisp式を読み取り、(関連するlexical環境が適切なら)それを評価してエコーエリアに値をプリントする。デバッガは特定の重要な変数とバッファーを処理の一部として変更する。@kbd{e}は一時的にデバッガの外部からそれらの値をリストアするので、それらを調べて変更できる。これによりデバッガはより透過的になる。対照的にデバッガ内で@kbd{M-:}は特別なことを行わず、デバッガ内での変数の値を表示する。"

#. type: item
#: original_texis/debugging.texi:427
#, no-wrap
msgid "R"
msgstr "R"

#. type: table
#: original_texis/debugging.texi:430
msgid "Like @kbd{e}, but also save the result of evaluation in the buffer @file{*Debugger-record*}."
msgstr "@kbd{e}と同様だがバッファー@file{*Debugger-record*}内の評価結果も保存する。"

#. type: item
#: original_texis/debugging.texi:431
#, no-wrap
msgid "q"
msgstr "q"

#. type: table
#: original_texis/debugging.texi:434
msgid "Terminate the program being debugged; return to top-level Emacs command execution."
msgstr "デバッグされているプログラムを終了して、Emacsコマンド実行のトップレベルにリターンする。"

#. type: table
#: original_texis/debugging.texi:437
msgid "If the debugger was entered due to a @kbd{C-g} but you really want to quit, and not debug, use the @kbd{q} command."
msgstr "@kbd{C-g}によりデバッガにエンターしたが、実際はデバッグではなくquitしたいときは@kbd{q}コマンドを使用する。"

#. type: item
#: original_texis/debugging.texi:438
#, no-wrap
msgid "r"
msgstr "r"

#. type: table
#: original_texis/debugging.texi:441
msgid "Return a value from the debugger.  The value is computed by reading an expression with the minibuffer and evaluating it."
msgstr "デバッガから値をリターンする。ミニバッファーで式を読み取ってそれを評価することにより値が計算される。"

#. type: table
#: original_texis/debugging.texi:448
msgid "The @kbd{r} command is useful when the debugger was invoked due to exit from a Lisp call frame (as requested with @kbd{b} or by entering the frame with @kbd{d}); then the value specified in the @kbd{r} command is used as the value of that frame.  It is also useful if you call @code{debug} and use its return value.  Otherwise, @kbd{r} has the same effect as @kbd{c}, and the specified return value does not matter."
msgstr "@kbd{d}コマンドは、(@kbd{b}によるリクエストや@kbd{d}によるそのフレームへのエンターによる)Lisp呼び出しフレームからのexitでデバッガが呼び出されたときに有用である。@kbd{r}コマンドで指定された値は、そのフレームの値として使用される。これは@code{debug}を呼び出して、そのリターン値を使用するときにも有用。それ以外は@kbd{r}は@kbd{c}と同じ効果をもち、指定されたリターン値は問題とはならない。"

#. type: table
#: original_texis/debugging.texi:450
msgid "You can't use @kbd{r} when the debugger was entered due to an error."
msgstr "エラーによりデバッガにエンターしたときは@kbd{r}コマンドは使用できない。"

#. type: item
#: original_texis/debugging.texi:451
#, no-wrap
msgid "l"
msgstr "l"

#. type: table
#: original_texis/debugging.texi:455
msgid "Display a list of functions that will invoke the debugger when called.  This is a list of functions that are set to break on entry by means of @code{debug-on-entry}."
msgstr "呼び出されたときにデバッガを呼び出す関数をリストする。これは@code{debug-on-entry}によりエントリー時にbreakするようセットされた関数のリストである。"

#. type: item
#: original_texis/debugging.texi:456
#, no-wrap
msgid "v"
msgstr "v"

#. type: table
#: original_texis/debugging.texi:458
msgid "Toggle the display of local variables of the current stack frame."
msgstr "カレントスタックフレームのローカル変数の表示を切り替える。"

#. type: cindex
#: original_texis/debugging.texi:462
#, no-wrap
msgid "invoking lisp debugger"
msgstr "invoking lisp debugger"

#. type: Plain text
#: original_texis/debugging.texi:466
msgid "Here we describe in full detail the function @code{debug} that is used to invoke the debugger."
msgstr "以下ではデバッガを呼び出すために使用される関数@code{debug}の完全な詳細を説明します。"

#. type: deffn
#: original_texis/debugging.texi:467
#, no-wrap
msgid "Command debug &rest debugger-args"
msgstr "Command debug &rest debugger-args"

#. type: deffn
#: original_texis/debugging.texi:473
msgid "This function enters the debugger.  It switches buffers to a buffer named @file{*Backtrace*} (or @file{*Backtrace*<2>} if it is the second recursive entry to the debugger, etc.), and fills it with information about the stack of Lisp function calls.  It then enters a recursive edit, showing the backtrace buffer in Debugger mode."
msgstr "この関数はデバッガにエンターする。この関数は@file{*Backtrace*}(デバッガへの2回目以降の再帰エントリーでは@file{*Backtrace*<2>、...})という名前のバッファーにバッファーを切り替えて、Lisp関数呼び出しについての情報を書き込む。それから再帰編集にエンターして、Debuggerモードでbacktraceバッファーを表示する。"

#. type: deffn
#: original_texis/debugging.texi:478
msgid "The Debugger mode @kbd{c}, @kbd{d}, @kbd{j}, and @kbd{r} commands exit the recursive edit; then @code{debug} switches back to the previous buffer and returns to whatever called @code{debug}.  This is the only way the function @code{debug} can return to its caller."
msgstr "Debuggerモードのコマンド@kbd{c}、@kbd{d}、@kbd{j}、@kbd{r}は再帰編集をexitする。その後、@code{debug}は以前のバッファーに戻って、@code{debug}を呼び出したものが何であれそこにリターンする。これは関数@code{debug}が呼び出し元にリターンできる唯一の方法である。"

#. type: deffn
#: original_texis/debugging.texi:483
msgid "The use of the @var{debugger-args} is that @code{debug} displays the rest of its arguments at the top of the @file{*Backtrace*} buffer, so that the user can see them.  Except as described below, this is the @emph{only} way these arguments are used."
msgstr "@var{debugger-args}を使用すると、@code{debug}は@file{*Backtrace*}の最上部に残りの引数を表示するしてユーザーがそれらを確認できる。以下で説明する場合を除いて、これはこれらの引数を使用する@emph{唯一}の方法である。"

#. type: deffn
#: original_texis/debugging.texi:488
msgid "However, certain values for first argument to @code{debug} have a special significance.  (Normally, these values are used only by the internals of Emacs, and not by programmers calling @code{debug}.)  Here is a table of these special values:"
msgstr "しかし@code{debug}への1つ目の引数にたいする値は、特別な意味をもつ(これらの値は通常は@code{debug}を呼び出すプログラマーではなく、Emacs内部でのみ使用される)。以下はこれら特別な値のテーブルである:"

#. type: item
#: original_texis/debugging.texi:490
#, no-wrap
msgid "lambda"
msgstr "lambda"

#. type: cindex
#: original_texis/debugging.texi:491
#, no-wrap
msgid "@code{lambda} in debug"
msgstr "@code{lambda} in debug"

#. type: table
#: original_texis/debugging.texi:497
msgid "A first argument of @code{lambda} means @code{debug} was called because of entry to a function when @code{debug-on-next-call} was non-@code{nil}.  The debugger displays @samp{Debugger entered--entering a function:} as a line of text at the top of the buffer."
msgstr "1つ目の引数が@code{lambda}のなら、それは@code{debug-on-next-call}が非@code{nil}のときに関数にエントリーしたことによって@code{debug}が呼び出されたことを意味する。デバッガはバッファーのトップのテキスト行に@samp{Debugger entered--entering a function:}と表示する。"

#. type: item
#: original_texis/debugging.texi:498
#, no-wrap
msgid "debug"
msgstr "debug"

#. type: table
#: original_texis/debugging.texi:504
msgid "@code{debug} as first argument means @code{debug} was called because of entry to a function that was set to debug on entry.  The debugger displays the string @samp{Debugger entered--entering a function:}, just as in the @code{lambda} case.  It also marks the stack frame for that function so that it will invoke the debugger when exited."
msgstr "1つ目の引数が@code{debug}なら、それはエントリー時にデバッグされるようにセットされた関数にエントリーしたことにって@code{debug}が呼び出されたことを意味する。デバッガは@code{lambda}のときと同様、@samp{Debugger entered--entering a function:}を表示する。これはその関数のスタックフレームもマークするので、exit時にデバッガが呼び出される。"

#. type: item
#: original_texis/debugging.texi:505
#, no-wrap
msgid "t"
msgstr "t"

#. type: table
#: original_texis/debugging.texi:511
msgid "When the first argument is @code{t}, this indicates a call to @code{debug} due to evaluation of a function call form when @code{debug-on-next-call} is non-@code{nil}.  The debugger displays @samp{Debugger entered--beginning evaluation of function call form:} as the top line in the buffer."
msgstr "1つ目の引数が@code{t}なら、それは@code{debug-on-next-call}が非@code{nil}のときに関数呼び出しの評価によって@code{debug}が呼び出されたことを示す。デバッガはバッファーのトップの行に@samp{Debugger entered--beginning evaluation of function call form:}と表示する。"

#. type: item
#: original_texis/debugging.texi:512
#, no-wrap
msgid "exit"
msgstr "exit"

#. type: table
#: original_texis/debugging.texi:519
msgid "When the first argument is @code{exit}, it indicates the exit of a stack frame previously marked to invoke the debugger on exit.  The second argument given to @code{debug} in this case is the value being returned from the frame.  The debugger displays @samp{Debugger entered--returning value:} in the top line of the buffer, followed by the value being returned."
msgstr "1つ目の引数が@code{exit}のときは、exit時にデバッガを呼び出すよう以前にマークされたスタックフレームをexitしたことを示す。この場合は@code{debug}に与えられた2つ目の引数がそのフレームからリターンされた値になる。デバッガはバッファーのトップの行に@samp{Debugger entered--returning value:}とリターンされた値を表示する。"

#. type: item
#: original_texis/debugging.texi:520
#, no-wrap
msgid "error"
msgstr "error"

#. type: cindex
#: original_texis/debugging.texi:521
#, no-wrap
msgid "@code{error} in debug"
msgstr "@code{error} in debug"

#. type: table
#: original_texis/debugging.texi:527
msgid "When the first argument is @code{error}, the debugger indicates that it is being entered because an error or @code{quit} was signaled and not handled, by displaying @samp{Debugger entered--Lisp error:} followed by the error signaled and any arguments to @code{signal}.  For example,"
msgstr "1つ目の引数が@code{error}のときは、ハンドルされていないエラーまたは@code{quit}がシグナルされてデバッガにエンターした場合であり、デバッガは@samp{Debugger entered--Lisp error:}とその後にシグナルされたエラーと@code{signal}への引数を表示してそれを示す。たとえば、"

#. type: group
#: original_texis/debugging.texi:532
#, no-wrap
msgid ""
"(let ((debug-on-error t))\n"
"  (/ 1 0))\n"
msgstr ""
"(let ((debug-on-error t))\n"
"  (/ 1 0))\n"

#. type: group
#: original_texis/debugging.texi:540
#, no-wrap
msgid ""
"------ Buffer: *Backtrace* ------\n"
"Debugger entered--Lisp error: (arith-error)\n"
"  /(1 0)\n"
"...\n"
"------ Buffer: *Backtrace* ------\n"
msgstr ""
"------ Buffer: *Backtrace* ------\n"
"Debugger entered--Lisp error: (arith-error)\n"
"  /(1 0)\n"
"...\n"
"------ Buffer: *Backtrace* ------\n"

#. type: table
#: original_texis/debugging.texi:546
msgid "If an error was signaled, presumably the variable @code{debug-on-error} is non-@code{nil}.  If @code{quit} was signaled, then presumably the variable @code{debug-on-quit} is non-@code{nil}."
msgstr "エラーがシグナルされた場合はおそらく変数@code{debug-on-error}は非@code{nil}で、@code{quit}がシグナルされた場合はおそらく変数@code{debug-on-quit}は非@code{nil}である。"

#. type: item
#: original_texis/debugging.texi:547
#, no-wrap
msgid "nil"
msgstr "nil"

#. type: table
#: original_texis/debugging.texi:553
msgid "Use @code{nil} as the first of the @var{debugger-args} when you want to enter the debugger explicitly.  The rest of the @var{debugger-args} are printed on the top line of the buffer.  You can use this feature to display messages---for example, to remind yourself of the conditions under which @code{debug} is called."
msgstr "明示的にデバッガにエンターしたいときは、@var{debugger-args}の1つ目の引数に@code{nil}を使用する。残りの@var{debugger-args}はバッファーのトップの行にプリントされる。メッセージ --- たとえば@code{debug}が呼び出された条件を思い出すためのリマインダーとして --- の表示にこの機能を使用できる。"

#. type: subsection
#: original_texis/debugging.texi:557
#, no-wrap
msgid "Internals of the Debugger"
msgstr "Internals of the Debugger"

#. type: Plain text
#: original_texis/debugging.texi:561
msgid "This section describes functions and variables used internally by the debugger."
msgstr "このセクションではデバッガ内部で使用される関数と変数について説明します。"

#. type: defvar
#: original_texis/debugging.texi:562
#, no-wrap
msgid "debugger"
msgstr "debugger"

#. type: defvar
#: original_texis/debugging.texi:568
msgid "The value of this variable is the function to call to invoke the debugger.  Its value must be a function of any number of arguments, or, more typically, the name of a function.  This function should invoke some kind of debugger.  The default value of the variable is @code{debug}."
msgstr "この関数の値はデバッガを呼び出す関数呼び出しである。値には任意個数の引数をとる関数、より具体的には関数の名前でなければならない。この関数は何らかのデバッガを呼び出すこと。この変数のデフォルト値は@code{debug}。"

#. type: defvar
#: original_texis/debugging.texi:572
msgid "The first argument that Lisp hands to the function indicates why it was called.  The convention for arguments is detailed in the description of @code{debug} (@pxref{Invoking the Debugger})."
msgstr "関数にたいしてLispが渡す1つ目の引数は、その関数がなぜ呼び出されたかを示す。引数の慣習については@code{debug}(@ref{Invoking the Debugger})に詳解がある。"

#. type: deffn
#: original_texis/debugging.texi:574
#, no-wrap
msgid "Command backtrace"
msgstr "Command backtrace"

#. type: cindex
#: original_texis/debugging.texi:575
#, no-wrap
msgid "run time stack"
msgstr "run time stack"

#. type: cindex
#: original_texis/debugging.texi:576
#, no-wrap
msgid "call stack"
msgstr "call stack"

#. type: deffn
#: original_texis/debugging.texi:582
msgid "This function prints a trace of Lisp function calls currently active.  This is the function used by @code{debug} to fill up the @file{*Backtrace*} buffer.  It is written in C, since it must have access to the stack to determine which function calls are active.  The return value is always @code{nil}."
msgstr "この関数は現在アクティブなLisp関数呼び出しのトレースをプリントする。この関数は@code{debug}が@file{*Backtrace*}バッファーに書き込む内容を得るために使用される。どの関数呼び出しがアクティブか判断するためにスタックにアクセスしなければならないので、この関数はCで記述されている。リターン値は常に@code{nil}。"

#. type: deffn
#: original_texis/debugging.texi:587
msgid "In the following example, a Lisp expression calls @code{backtrace} explicitly.  This prints the backtrace to the stream @code{standard-output}, which, in this case, is the buffer @samp{backtrace-output}."
msgstr "以下の例ではLisp式で明示的に@code{backtrace}を呼び出している。これはストリーム@code{standard-output}(この場合はバッファー@samp{backtrace-output})にbacktraceをプリントする。"

#. type: deffn
#: original_texis/debugging.texi:592
msgid "Each line of the backtrace represents one function call.  The line shows the values of the function's arguments if they are all known; if they are still being computed, the line says so.  The arguments of special forms are elided."
msgstr "backtraceの各行は、1つの関数呼び出しを表す。関数の引数が既知なら行に値が表示され、まだ計算中の場合は行にその旨が示される。スペシャルフォームの引数は無視される。"

#. type: group
#: original_texis/debugging.texi:601
#, no-wrap
msgid ""
"(with-output-to-temp-buffer \"backtrace-output\"\n"
"  (let ((var 1))\n"
"    (save-excursion\n"
"      (setq var (eval '(progn\n"
"                         (1+ var)\n"
"                         (list 'testing (backtrace))))))))\n"
"\n"
msgstr ""
"(with-output-to-temp-buffer \"backtrace-output\"\n"
"  (let ((var 1))\n"
"    (save-excursion\n"
"      (setq var (eval '(progn\n"
"                         (1+ var)\n"
"                         (list 'testing (backtrace))))))))\n"
"\n"

#. type: group
#: original_texis/debugging.texi:603
#, no-wrap
msgid "     @result{} (testing nil)\n"
msgstr "     @result{} (testing nil)\n"

#. type: group
#: original_texis/debugging.texi:609
#, no-wrap
msgid ""
"----------- Buffer: backtrace-output ------------\n"
"  backtrace()\n"
"  (list ...computing arguments...)\n"
msgstr ""
"----------- Buffer: backtrace-output ------------\n"
"  backtrace()\n"
"  (list ...computing arguments...)\n"

#. type: smallexample
#: original_texis/debugging.texi:618
#, no-wrap
msgid ""
"  (progn ...)\n"
"  eval((progn (1+ var) (list (quote testing) (backtrace))))\n"
"  (setq ...)\n"
"  (save-excursion ...)\n"
"  (let ...)\n"
"  (with-output-to-temp-buffer ...)\n"
"  eval((with-output-to-temp-buffer ...))\n"
"  eval-last-sexp-1(nil)\n"
msgstr ""
"  (progn ...)\n"
"  eval((progn (1+ var) (list (quote testing) (backtrace))))\n"
"  (setq ...)\n"
"  (save-excursion ...)\n"
"  (let ...)\n"
"  (with-output-to-temp-buffer ...)\n"
"  eval((with-output-to-temp-buffer ...))\n"
"  eval-last-sexp-1(nil)\n"

#. type: group
#: original_texis/debugging.texi:622
#, no-wrap
msgid ""
"  eval-last-sexp(nil)\n"
"  call-interactively(eval-last-sexp)\n"
"----------- Buffer: backtrace-output ------------\n"
msgstr ""
"  eval-last-sexp(nil)\n"
"  call-interactively(eval-last-sexp)\n"
"----------- Buffer: backtrace-output ------------\n"

#. type: defvar
#: original_texis/debugging.texi:626
#, no-wrap
msgid "debug-on-next-call"
msgstr "debug-on-next-call"

#. type: cindex
#: original_texis/debugging.texi:627
#, no-wrap
msgid "@code{eval}, and debugging"
msgstr "@code{eval}, and debugging"

#. type: cindex
#: original_texis/debugging.texi:628
#, no-wrap
msgid "@code{apply}, and debugging"
msgstr "@code{apply}, and debugging"

#. type: cindex
#: original_texis/debugging.texi:629
#, no-wrap
msgid "@code{funcall}, and debugging"
msgstr "@code{funcall}, and debugging"

#. type: defvar
#: original_texis/debugging.texi:633
msgid "If this variable is non-@code{nil}, it says to call the debugger before the next @code{eval}, @code{apply} or @code{funcall}.  Entering the debugger sets @code{debug-on-next-call} to @code{nil}."
msgstr "この変数が非@code{nil}なら、それは次の@code{eval}、@code{apply}、@code{funcall}の前にデバッガを呼び出すよう指定する。デバッガへのエンターによって@code{debug-on-next-call}は@code{nil}にセットされる。"

#. type: defvar
#: original_texis/debugging.texi:635
msgid "The @kbd{d} command in the debugger works by setting this variable."
msgstr "デバッガの@kbd{d}コマンドは、この変数をセットすることにより機能します。"

#. type: defun
#: original_texis/debugging.texi:637
#, no-wrap
msgid "backtrace-debug level flag"
msgstr "backtrace-debug level flag"

#. type: defun
#: original_texis/debugging.texi:643
msgid "This function sets the debug-on-exit flag of the stack frame @var{level} levels down the stack, giving it the value @var{flag}.  If @var{flag} is non-@code{nil}, this will cause the debugger to be entered when that frame later exits.  Even a nonlocal exit through that frame will enter the debugger."
msgstr "この関数はそのスタックフレームの@var{level}下位のスタックフレームのdebug-on-exitフラグに@var{flag}に応じた値をセットする。@var{flag}が非@code{nil}なら、後でそのフレームをexitするときデバッガにエンターする。そのフレームを通じた非ローカルexitでも、デバッガにエンターする。"

#. type: defun
#: original_texis/debugging.texi:645
msgid "This function is used only by the debugger."
msgstr "この関数はデバッガだけに使用される。"

#. type: defvar
#: original_texis/debugging.texi:647
#, no-wrap
msgid "command-debug-status"
msgstr "command-debug-status"

#. type: defvar
#: original_texis/debugging.texi:653
msgid "This variable records the debugging status of the current interactive command.  Each time a command is called interactively, this variable is bound to @code{nil}.  The debugger can set this variable to leave information for future debugger invocations during the same command invocation."
msgstr "この変数はカレントのインタラクティブコマンドのデバッグ状態を記録する。コマンドがインタラクティブに呼び出されるたびに、この変数は@code{nil}にバインドされる。デバッガは同じコマンドが呼び出されたときのデバッガ呼び出しに情報を残すために、この変数をセットできる。"

#. type: defvar
#: original_texis/debugging.texi:657
msgid "The advantage of using this variable rather than an ordinary global variable is that the data will never carry over to a subsequent command invocation."
msgstr "普通のグローバル変数ではなくこの変数を使用する利点は、そのデータが後続のコマンド呼び出しに決して引き継がれないことである。"

#. type: defun
#: original_texis/debugging.texi:659
#, no-wrap
msgid "backtrace-frame frame-number"
msgstr "backtrace-frame frame-number"

#. type: defun
#: original_texis/debugging.texi:663
msgid "The function @code{backtrace-frame} is intended for use in Lisp debuggers.  It returns information about what computation is happening in the stack frame @var{frame-number} levels down."
msgstr "関数@code{backtrace-frame}はLispデバッガ内での使用を意図している。これは@var{frame-number}レベル下位のスタックフレームで、何の評価が行われているかに関する情報をリターンする。"

#. type: defun
#: original_texis/debugging.texi:666
msgid "If that frame has not evaluated the arguments yet, or is a special form, the value is @code{(nil @var{function} @var{arg-forms}@dots{})}."
msgstr "そのフレームがまだ引数を評価していない、またはそのフレームがスペシャルフォームの場合、値は@code{(nil @var{function} @var{arg-forms}@dots{})}。"

#. type: defun
#: original_texis/debugging.texi:670
msgid "If that frame has evaluated its arguments and called its function already, the return value is @code{(t @var{function} @var{arg-values}@dots{})}."
msgstr "そのフレームが引数を評価して関数をすでに呼び出していたら、リターン値は@code{(t @var{function} @var{arg-values}@dots{})}。"

#. type: defun
#: original_texis/debugging.texi:675
msgid "In the return value, @var{function} is whatever was supplied as the @sc{car} of the evaluated list, or a @code{lambda} expression in the case of a macro call.  If the function has a @code{&rest} argument, that is represented as the tail of the list @var{arg-values}."
msgstr "リターン値の@var{function}は何であれ評価されたリストの@sc{car}として提供される。マクロ呼び出しの場合は@code{lambda}式になる。その関数に@code{&rest}引数があればリスト@var{arg-values}の末尾に示される。"

#. type: defun
#: original_texis/debugging.texi:678
msgid "If @var{frame-number} is out of range, @code{backtrace-frame} returns @code{nil}."
msgstr "@var{frame-number}が範囲外なら@code{backtrace-frame}は@code{nil}をリターンする。"

#. type: include
#: original_texis/debugging.texi:680
#, no-wrap
msgid "edebug.texi"
msgstr "edebug-ja.texi"

#. type: section
#: original_texis/debugging.texi:683
#, no-wrap
msgid "Debugging Invalid Lisp Syntax"
msgstr "Debugging Invalid Lisp Syntax"

#. type: cindex
#: original_texis/debugging.texi:684
#, no-wrap
msgid "debugging invalid Lisp syntax"
msgstr "debugging invalid Lisp syntax"

#. type: Plain text
#: original_texis/debugging.texi:694
msgid "The Lisp reader reports invalid syntax, but cannot say where the real problem is.  For example, the error @samp{End of file during parsing} in evaluating an expression indicates an excess of open parentheses (or square brackets).  The reader detects this imbalance at the end of the file, but it cannot figure out where the close parenthesis should have been.  Likewise, @samp{Invalid read syntax: \")\"} indicates an excess close parenthesis or missing open parenthesis, but does not say where the missing parenthesis belongs.  How, then, to find what to change?"
msgstr "Lispリーダーは無効な構文(invalid syntax)について報告はしますが実際の問題箇所は報告しません。たとえばある式を評価中のエラー@samp{End of file during parsing}は、開カッコまたは開角カッコ(open parenthese or open square bracket)が多いことを示しています。Lispリーダーはこの不一致をファイル終端で検出しましたが、本来閉カッコがあるべき箇所を解決することはできません。同様に@samp{Invalid read syntax: \\\")\\\"}は開カッコの欠落を示していますが、欠落しているカッコが属すべき場所は告げません。ならばどうやって変更すべき箇所を探せばよいのでしょうか?"

#. type: Plain text
#: original_texis/debugging.texi:699
msgid "If the problem is not simply an imbalance of parentheses, a useful technique is to try @kbd{C-M-e} at the beginning of each defun, and see if it goes to the place where that defun appears to end.  If it does not, there is a problem in that defun."
msgstr "問題が単なるカッコの不一致でない場合の便利なテクニックは、各defunの先頭で@kbd{C-M-e}とタイプして、そのdefunの最後と思われる箇所に移動するか確認する方法です。もし移動しなければ、問題はそのdefunの内部にあります。"

#. type: cindex
#: original_texis/debugging.texi:700
#, no-wrap
msgid "unbalanced parentheses"
msgstr "unbalanced parentheses"

#. type: cindex
#: original_texis/debugging.texi:701
#, no-wrap
msgid "parenthesis mismatch, debugging"
msgstr "parenthesis mismatch, debugging"

#. type: Plain text
#: original_texis/debugging.texi:706
msgid "However, unmatched parentheses are the most common syntax errors in Lisp, and we can give further advice for those cases.  (In addition, just moving point through the code with Show Paren mode enabled might find the mismatch.)"
msgstr "マッチしないカッコがLispにおいてもっとも一般的な構文エラーなので、これらのケースにたいしてさらにアドバイスすることができます(Show Parenモードを有効にしてコードにポイントを移動するだけでカッコの不一致を探しやすくなるだろう)。"

#. type: node
#: original_texis/debugging.texi:710 original_texis/debugging.texi:712
#, no-wrap
msgid "Excess Open"
msgstr "Excess Open"

#. type: menuentry
#: original_texis/debugging.texi:710
msgid "How to find a spurious open paren or missing close."
msgstr "誤った開カッコと閉カッコの欠落を探す方法。"

#. type: node
#: original_texis/debugging.texi:710 original_texis/debugging.texi:747
#, no-wrap
msgid "Excess Close"
msgstr "Excess Close"

#. type: menuentry
#: original_texis/debugging.texi:710
msgid "How to find a spurious close paren or missing open."
msgstr "誤った閉カッコと開カッコの欠落を探す方法。"

#. type: subsection
#: original_texis/debugging.texi:713
#, no-wrap
msgid "Excess Open Parentheses"
msgstr "Excess Open Parentheses"

#. type: cindex
#: original_texis/debugging.texi:714
#, no-wrap
msgid "excess open parentheses"
msgstr "excess open parentheses"

#. type: Plain text
#: original_texis/debugging.texi:720
msgid "The first step is to find the defun that is unbalanced.  If there is an excess open parenthesis, the way to do this is to go to the end of the file and type @kbd{C-u C-M-u}.  This will move you to the beginning of the first defun that is unbalanced."
msgstr "カッコがマッチしないdefunを探すことが最初のステップです。過剰な開カッコが存在する場合は、ファイルの終端に移動して@kbd{C-u C-M-u}とタイプします。これによってカッコがマッチしない最初のdefunの先頭に移動するでしょう。"

#. type: Plain text
#: original_texis/debugging.texi:727
msgid "The next step is to determine precisely what is wrong.  There is no way to be sure of this except by studying the program, but often the existing indentation is a clue to where the parentheses should have been.  The easiest way to use this clue is to reindent with @kbd{C-M-q} and see what moves.  @strong{But don't do this yet!} Keep reading, first."
msgstr "何が間違っているのか正確に判断するのが次のステップです。これを確実に行なうには、そのプログラムを詳しく調べる以外に方法はありませんが、カッコがあるべき箇所を探すのに既存のインデントが手掛かりになることが多々あります。@kbd{C-M-q}で再インデントして何が移動されるか確認するのが、この手掛かりを使用するもっとも簡単な方法です。@strong{しかし、行うのはちょっと待ってください!} まず続きを読んでからにしましょう。"

#. type: Plain text
#: original_texis/debugging.texi:733
msgid "Before you do this, make sure the defun has enough close parentheses.  Otherwise, @kbd{C-M-q} will get an error, or will reindent all the rest of the file until the end.  So move to the end of the defun and insert a close parenthesis there.  Don't use @kbd{C-M-e} to move there, since that too will fail to work until the defun is balanced."
msgstr "これを行なう前にdefunに十分な閉カッコがあるか確認します。十分な閉カッコがなければ@kbd{C-M-q}がエラーとなるか、そのdefunからファイル終端までの残りすべてが再インデントされます。その場合はdefunの最後に移動して、そこに閉カッコを挿入します。そのdefunのカッコの釣り合いがとれるまでは、defunの最後に移動するのに@kbd{C-M-e}は失敗するでしょうから使用できません。"

#. type: Plain text
#: original_texis/debugging.texi:741
msgid "Now you can go to the beginning of the defun and type @kbd{C-M-q}.  Usually all the lines from a certain point to the end of the function will shift to the right.  There is probably a missing close parenthesis, or a superfluous open parenthesis, near that point.  (However, don't assume this is true; study the code to make sure.)  Once you have found the discrepancy, undo the @kbd{C-M-q} with @kbd{C-_}, since the old indentation is probably appropriate to the intended parentheses."
msgstr "これでdefunの先頭に移動して@kbd{C-M-q}とタイプすることができます。通常は一定のポイントからその関数の最後までのすべての行が、右へとシフトされるでしょう。これはおそらくそのポイント付近で閉カッコが欠落しているか不要な開カッコがあります(しかしこれを真実と決め付けずコードを詳しく調べてること)。不一致箇所を見つけたら、元のインデントはおそらく意図されたカッコに適しているはずなので、@kbd{C-_}で@kbd{C-M-q}をアンドゥしてください。"

#. type: Plain text
#: original_texis/debugging.texi:746
msgid "After you think you have fixed the problem, use @kbd{C-M-q} again.  If the old indentation actually fit the intended nesting of parentheses, and you have put back those parentheses, @kbd{C-M-q} should not change anything."
msgstr "問題をfixできたと思った後に、再度@kbd{C-M-q}を使用します。実際に元のインデントが意図したカッコのネストに適合していて、足りないカッコを追加していたら、@kbd{C-M-q}は何も変更しないはずです。"

#. type: subsection
#: original_texis/debugging.texi:748
#, no-wrap
msgid "Excess Close Parentheses"
msgstr "Excess Close Parentheses"

#. type: cindex
#: original_texis/debugging.texi:749
#, no-wrap
msgid "excess close parentheses"
msgstr "excess close parentheses"

#. type: Plain text
#: original_texis/debugging.texi:754
msgid "To deal with an excess close parenthesis, first go to the beginning of the file, then type @kbd{C-u -1 C-M-u} to find the end of the first unbalanced defun."
msgstr "過剰な閉カッコへの対処は、まずファイルの先頭に移動してから、カッコのマッチしないdefunを探すために@kbd{C-u -1 C-M-u}をタイプします。"

#. type: Plain text
#: original_texis/debugging.texi:759
msgid "Then find the actual matching close parenthesis by typing @kbd{C-M-f} at the beginning of that defun.  This will leave you somewhere short of the place where the defun ought to end.  It is possible that you will find a spurious close parenthesis in that vicinity."
msgstr "それからそのdefunの先頭で@kbd{C-M-f}をタイプして、実際にマッチする閉カッコを探します。これによりそのdefunの終端より幾分手前の箇所に移動するはずです。その付近に間違った閉カッコが見つかるでしょう。"

#. type: Plain text
#: original_texis/debugging.texi:767
msgid "If you don't see a problem at that point, the next thing to do is to type @kbd{C-M-q} at the beginning of the defun.  A range of lines will probably shift left; if so, the missing open parenthesis or spurious close parenthesis is probably near the first of those lines.  (However, don't assume this is true; study the code to make sure.)  Once you have found the discrepancy, undo the @kbd{C-M-q} with @kbd{C-_}, since the old indentation is probably appropriate to the intended parentheses."
msgstr "そのポイントに問題が見つからなければ、そのdefunの先頭で@kbd{C-M-q}をタイプするのが次のステップです。ある行範囲はおそらく左へシフトするでしょう。その場合には欠落している開カッコまたは間違った閉カッコは、おそらくそれらの行の1行目付近にあるでしょう (しかしこれを真実と決め付けずコードを詳しく調べること)。不一致箇所を見つけたら、元のインデントはおそらく意図されたカッコに適しているはずなので、@kbd{C-_}で@kbd{C-M-q}をアンドゥしてください。"

#. type: Plain text
#: original_texis/debugging.texi:772
msgid "After you think you have fixed the problem, use @kbd{C-M-q} again.  If the old indentation actually fits the intended nesting of parentheses, and you have put back those parentheses, @kbd{C-M-q} should not change anything."
msgstr "問題をfixできたと思った後に再度@kbd{C-M-q}を使用します。実際に元のインデントが意図したカッコのネストに適合していて、足りないカッコを追加していたら、@kbd{C-M-q}は何も変更しないはずです。"

#. type: cindex
#: original_texis/debugging.texi:775
#, no-wrap
msgid "coverage testing"
msgstr "coverage testing"

#. type: findex
#: original_texis/debugging.texi:777
#, no-wrap
msgid "testcover-start"
msgstr "testcover-start"

#. type: findex
#: original_texis/debugging.texi:778
#, no-wrap
msgid "testcover-mark-all"
msgstr "testcover-mark-all"

#. type: findex
#: original_texis/debugging.texi:779
#, no-wrap
msgid "testcover-next-mark"
msgstr "testcover-next-mark"

#. type: Plain text
#: original_texis/debugging.texi:788
msgid "You can do coverage testing for a file of Lisp code by loading the @code{testcover} library and using the command @kbd{M-x testcover-start @key{RET} @var{file} @key{RET}} to instrument the code.  Then test your code by calling it one or more times.  Then use the command @kbd{M-x testcover-mark-all} to display colored highlights on the code to show where coverage is insufficient.  The command @kbd{M-x testcover-next-mark} will move point forward to the next highlighted spot."
msgstr "@code{testcover}ライブラリーをロードしてコマンド@kbd{M-x testcover-start @key{RET} @var{file} @key{RET}}でコードをインストルメントすることにより、Lispコードのファイルにたいしてカバレッジテストを行なうことができます。コードを1回以上呼び出すことによってテストが行なわれます。コマンド@kbd{M-x testcover-mark-all}を使用すれば、カバレッジが不十分な箇所が色付きでハイライト表示されます。コマンド@kbd{M-x testcover-next-mark}は次のハイライトされた箇所へポイントを前方に移動します。"

#. type: Plain text
#: original_texis/debugging.texi:796
msgid "Normally, a red highlight indicates the form was never completely evaluated; a brown highlight means it always evaluated to the same value (meaning there has been little testing of what is done with the result).  However, the red highlight is skipped for forms that can't possibly complete their evaluation, such as @code{error}.  The brown highlight is skipped for forms that are expected to always evaluate to the same value, such as @code{(setq x 14)}."
msgstr "赤くハイライトされた箇所は通常はそのフォームが完全に評価されたことが一度もないことを示し、茶色でハイライトされた箇所は常に同じ値に評価された(その結果にたいして少ししかテストされていない)ことを意味します。しかし@code{error}のように完全に評価するのが不可能なフォームにたいしては、赤いハイライトはスキップされます。@code{(setq x 14)}のように常に同じ値に評価されることが期待されるフォームにたいしては、茶色のハイライトはスキップされます。"

#. type: Plain text
#: original_texis/debugging.texi:799
msgid "For difficult cases, you can add do-nothing macros to your code to give advice to the test coverage tool."
msgstr "難しいケースではテストカバレッジツールにアドバイスを与えるために、コードにdo-nothingマクロを追加することができます。"

#. type: defmac
#: original_texis/debugging.texi:800
#, no-wrap
msgid "1value form"
msgstr "1value form"

#. type: defmac
#: original_texis/debugging.texi:803
msgid "Evaluate @var{form} and return its value, but inform coverage testing that @var{form}'s value should always be the same."
msgstr "@var{form}を評価してその値をリターンするが、テストカバレッジにたいして@var{form}が常に同じ値だという情報を与える。"

#. type: defmac
#: original_texis/debugging.texi:805
#, no-wrap
msgid "noreturn form"
msgstr "noreturn form"

#. type: defmac
#: original_texis/debugging.texi:808
msgid "Evaluate @var{form}, informing coverage testing that @var{form} should never return.  If it ever does return, you get a run-time error."
msgstr "@var{form}を評価して@var{form}が決してリターンしないという情報をカバレッジテストに与える。もしリターンしたらrun-timeエラーとなる。"

#. type: Plain text
#: original_texis/debugging.texi:813
msgid "Edebug also has a coverage testing feature (@pxref{Coverage Testing}).  These features partly duplicate each other, and it would be cleaner to combine them."
msgstr "Edebugにもカバレッジテスト機能があります(@ref{Coverage Testing}を参照)。これらの機能は部分的に重複しており、組み合わせることで明確になるでしょう。"

#. type: cindex
#: original_texis/debugging.texi:817
#, no-wrap
msgid "profiling"
msgstr "profiling"

#. type: cindex
#: original_texis/debugging.texi:818
#, no-wrap
msgid "profile"
msgstr "profile"

#. type: cindex
#: original_texis/debugging.texi:819
#, no-wrap
msgid "measuring resource usage"
msgstr "measuring resource usage"

#. type: cindex
#: original_texis/debugging.texi:820
#, no-wrap
msgid "memory usage"
msgstr "memory usage"

#. type: Plain text
#: original_texis/debugging.texi:827
msgid "If your program is working correctly, but you want to make it run more quickly or efficiently, the first thing to do is @dfn{profile} your code so that you know how it is using resources.  If you find that one particular function is responsible for a significant portion of the runtime, you can start looking for ways to optimize that piece."
msgstr "プログラムは正常に機能しているものの、より高速または効率的に実行させたい場合にまず行うべきは、そのプログラムがリソースをどのように使用するか知るためにコードを@dfn{プロファイル(profile)}することです。ある特定の関数の実行が、実行時間のうち無視できない割り合いを占めるようなら、その部分を最適化する方法を探すことを開始できます。"

#. type: Plain text
#: original_texis/debugging.texi:837
msgid "Emacs has built-in support for this.  To begin profiling, type @kbd{M-x profiler-start}.  You can choose to profile by processor usage, memory usage, or both.  After doing some work, type @kbd{M-x profiler-report} to display a summary buffer for each resource that you chose to profile.  The names of the report buffers include the times at which the reports were generated, so you can generate another report later on without erasing previous results.  When you have finished profiling, type @kbd{M-x profiler-stop} (there is a small overhead associated with profiling)."
msgstr "このためにEmacsにはビルトインのサポートがあります。プロファイリングを開始するには@kbd{M-x profiler-start}をタイプします。プロファイルはプロセッサー使用(processor usage)とメモリー使用(memory usage)、またはその両方を選択できます。何らかの処理を行った後に@kbd{M-x profiler-report}とタイプすると、プロファイルに選択した各リソースがsummaryバッファーに表示されます。reportバッファーの名前にはそのレポートが生成された時刻が含まれるので、前の結果を消去せずに後で他のレポートを生成できます。プロファイリングが終了したら@kbd{M-x profiler-stop}とタイプしてください(プロファイリングに関連する多少のオーバーヘッドがあるため)。"

#. type: Plain text
#: original_texis/debugging.texi:846
msgid "The profiler report buffer shows, on each line, a function that was called, followed by how much resource (processor or memory) it used in absolute and percentage times since profiling started.  If a given line has a @samp{+} symbol at the left-hand side, you can expand that line by typing @key{RET}, in order to see the function(s) called by the higher-level function.  Use a prefix argument (@key{C-u RET}) to see the whole call tree below a function.  Pressing @key{RET} again will collapse back to the original state."
msgstr "profiler reportバッファーでは各行に呼び出された関数と、その後にプロファイリングが開始されてから使用したリソース(プロセッサーまたはメモリー)の絶対時間とパーセンテージ時間が表示されます。左側にシンボル@samp{+}のある行では@key{RET}をタイプして行を展開して、高位レベルの関数に呼び出された関数を確認できます。もう一度@key{RET}をタイプすると、元の状態へと行が折り畳まれます。"

#. type: Plain text
#: original_texis/debugging.texi:851
msgid "Press @kbd{j} or @kbd{mouse-2} to jump to the definition of a function.  Press @kbd{d} to view a function's documentation.  You can save a profile to a file using @kbd{C-x C-w}.  You can compare two profiles using @kbd{=}."
msgstr "@kbd{j}か@kbd{mouse-2}を押下すると関数の定義にジャンプします。@kbd{d}を押下すると関数のドキュメントを閲覧できます。@kbd{C-x C-w}を使用してプロファイルをファイルに保存できます。@kbd{=}を使用すれば2つのプロファイルを比較することができます。"

#. type: file{#1}
#: original_texis/debugging.texi:854
#, no-wrap
msgid "elp.el"
msgstr "elp.el"

#. type: cindex
#: original_texis/debugging.texi:855
#, no-wrap
msgid "timing programs"
msgstr "timing programs"

#. type: Plain text
#: original_texis/debugging.texi:858
msgid "The @file{elp} library offers an alternative approach.  See the file @file{elp.el} for instructions."
msgstr "@file{elp}ライブラリーは別のアプローチを提案します。使い方は@file{elp.el}を参照してください。"

#. type: file{#1}
#: original_texis/debugging.texi:859
#, no-wrap
msgid "benchmark.el"
msgstr "benchmark.el"

#. type: cindex
#: original_texis/debugging.texi:860
#, no-wrap
msgid "benchmarking"
msgstr "benchmarking"

#. type: Plain text
#: original_texis/debugging.texi:864
msgid "You can check the speed of individual Emacs Lisp forms using the @file{benchmark} library.  See the functions @code{benchmark-run} and @code{benchmark-run-compiled} in @file{benchmark.el}."
msgstr "@file{benchmark}ライブラリーを使用してEmacs Lispフォームのスピードを個別にチェックできます。@file{benchmark.el}内の関数@code{benchmark-run}と@code{benchmark-run-compiled}を参照してください。"

#. type: cindex
#: original_texis/debugging.texi:867
#, no-wrap
msgid "--enable-profiling option of configure"
msgstr "--enable-profiling option of configure"

#. type: ifnottex
#: original_texis/debugging.texi:874
msgid "To profile Emacs at the level of its C code, you can build it using the @option{--enable-profiling} option of @command{configure}.  When Emacs exits, it generates a file @file{gmon.out} that you can examine using the @command{gprof} utility.  This feature is mainly useful for debugging Emacs.  It actually stops the Lisp-level @kbd{M-x profiler-@dots{}} commands described above from working."
msgstr "@command{configure}のオプションに@option{--enable-profiling}を使用してビルドすることにより、EmacsをCコードのレベルでプロファイルすることができます。こうしてビルドされたEmacsは、Emacsをexitするときに@command{gprof}ユーティリティを使用して検証できるファイル@file{gmon.out}を生成します。この機能は主にEmacsのデバッグに有用です。このEmacsは実行状態から上述の@kbd{M-x profiler-@dots{}}コマンドによりLispレベルで実際にストップします。"
