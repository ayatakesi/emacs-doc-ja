# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Emacs 26.1\n"
"POT-Creation-Date: 2024-06-30 14:10+0000\n"
"PO-Revision-Date: 2024-03-26 03:45+0900\n"
"Last-Translator: Ayanokoji Takesi <ayanokoji.takesi@gmail.com>\n"
"Language-Team: \n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: node
#: original_texis/debugging.texi:6
#, no-wrap
msgid "Debugging"
msgstr "Debugging"

#. type: chapter
#: original_texis/debugging.texi:7
#, no-wrap
msgid "Debugging Lisp Programs"
msgstr "Debugging Lisp Programs"

#. type: cindex
#: original_texis/debugging.texi:8
#, no-wrap
msgid "debugging lisp programs"
msgstr "debugging lisp programs"

#. type: Plain text
#: original_texis/debugging.texi:12
msgid "There are several ways to find and investigate problems in an Emacs Lisp program."
msgstr "Emacs Lispプログラム内の問題を見つけて詳細に調べる方法がいくつかあります。"

#. type: itemize
#: original_texis/debugging.texi:18
msgid "If a problem occurs when you run the program, you can use the built-in Emacs Lisp debugger (@pxref{Debugger}) to suspend the Lisp evaluator, and examine and/or alter its internal state."
msgstr "プログラム実行中に問題が発生した場合には、Lisp評価機能をサスペンドするためにビルトインのEmacs Lispデバッガ(@ref{Debugger}を参照)を使用して評価機能の内部状態の調査および/または変更を行なうことができる。"

#. type: itemize
#: original_texis/debugging.texi:22
msgid "You can use Edebug, a source-level debugger for Emacs Lisp.  @xref{Edebug}."
msgstr "Emacs LispにたいするソースレベルデバッガのEdebugを使用できる。@ref{Edebug}を参照のこと。"

#. type: cindex
#: original_texis/debugging.texi:24
#, no-wrap
msgid "tracing Lisp programs"
msgstr "tracing Lisp programs"

#. type: itemize
#: original_texis/debugging.texi:32
msgid "You can trace the execution of functions involved in the problem using the tracing facilities provided by the @file{trace.el} package.  This package provides the functions @code{trace-function-foreground} and @code{trace-function-background} for tracing function calls, and @code{trace-values} for adding values of select variables to the trace.  For the details, see the documentation of these facilities in @file{trace.el}."
msgstr "@file{trace.el}パッケージが提供するトレース機能を使用して問題に関する関数の実行をトレースできます。このパッケージは関数呼び出しのトレース用に@code{trace-function-foreground}と@code{trace-function-background}、値をトレースする変数の追加用に@code{trace-values}という関数を提供する。詳細は@file{trace.el}にあるこれらの機能のドキュメントを参照のと。"

#. type: itemize
#: original_texis/debugging.texi:36
msgid "If a syntactic problem is preventing Lisp from even reading the program, you can locate it using Lisp editing commands."
msgstr "文法的な問題によりLispがプログラムを読むことさえできない場合には、Lisp編集コマンドを使用して該当箇所を見つけることができる。"

#. type: itemize
#: original_texis/debugging.texi:40
msgid "You can look at the error and warning messages produced by the byte compiler when it compiles the program.  @xref{Compiler Errors}."
msgstr "バイトコンパイラーがプログラムをコンパイルするとき、コンパイラーにより生成されるエラーメッセージと警告メッセージを調べることができる。@ref{Compiler Errors}を参照のこと。"

#. type: itemize
#: original_texis/debugging.texi:44
msgid "You can use the Testcover package to perform coverage testing on the program."
msgstr "Testcoverパッケージを使用してプログラムのテストカバレッジを行なうことができる。"

#. type: itemize
#: original_texis/debugging.texi:48
msgid "You can use the ERT package to write regression tests for the program.  @xref{Top,the ERT manual,, ert, ERT: Emacs Lisp Regression Testing}."
msgstr "ERTパッケージを使用してプログラムにたいするリグレッションテストを記述できる。@ref{Top,the ERT manual,, ert, ERT: Emacs Lisp Regression Testing}を参照のこと。"

#. type: itemize
#: original_texis/debugging.texi:52
msgid "You can profile the program to get hints about how to make it more efficient.  @xref{Profiling}."
msgstr "プログラムをプロファイルしてプログラムをより効果的にするためのヒントを取得できる。@ref{Profiling}を参照のこと。"

#. type: Plain text
#: original_texis/debugging.texi:57
msgid "Other useful tools for debugging input and output problems are the dribble file (@pxref{Terminal Input}) and the @code{open-termscript} function (@pxref{Terminal Output})."
msgstr "入出力の問題をデバックする便利なその他のツールとして、ドリブルファイル(dribble file: @ref{Terminal Input}を参照)と、@code{open-termscript}関数(@ref{Terminal Output})があります。"

#. type: node
#: original_texis/debugging.texi:64 original_texis/debugging.texi:66
#, no-wrap
msgid "Debugger"
msgstr "Debugger"

#. type: menuentry
#: original_texis/debugging.texi:64
msgid "A debugger for the Emacs Lisp evaluator."
msgstr "Emacs Lisp評価機能にたいするデバッガ。"

#. type: menuentry
#: original_texis/debugging.texi:64
msgid "Edebug"
msgstr "Edebug"

#. type: menuentry
#: original_texis/debugging.texi:64
msgid "A source-level Emacs Lisp debugger."
msgstr "Emacs Lispソースレベルデバッガ。"

#. type: node
#: original_texis/debugging.texi:64 original_texis/debugging.texi:915
#, no-wrap
msgid "Syntax Errors"
msgstr "Syntax Errors"

#. type: menuentry
#: original_texis/debugging.texi:64
msgid "How to find syntax errors."
msgstr "シンタックスエラーを見つける方法。"

#. type: section
#: original_texis/debugging.texi:64 original_texis/debugging.texi:1013
#: original_texis/debugging.texi:1014
#, no-wrap
msgid "Test Coverage"
msgstr "Test Coverage"

#. type: menuentry
#: original_texis/debugging.texi:64
msgid "Ensuring you have tested all branches in your code."
msgstr "プログラムのすべての分岐を確実にテストする。"

#. type: section
#: original_texis/debugging.texi:64 original_texis/debugging.texi:1055
#: original_texis/debugging.texi:1056
#, no-wrap
msgid "Profiling"
msgstr "Profiling"

#. type: menuentry
#: original_texis/debugging.texi:64
msgid "Measuring the resources that your code uses."
msgstr "あなたのコードが使用するリソースの計測。"

#. type: section
#: original_texis/debugging.texi:67
#, no-wrap
msgid "The Lisp Debugger"
msgstr "The Lisp Debugger"

#. type: cindex
#: original_texis/debugging.texi:68
#, no-wrap
msgid "debugger for Emacs Lisp"
msgstr "debugger for Emacs Lisp"

#. type: cindex
#: original_texis/debugging.texi:69
#, no-wrap
msgid "Lisp debugger"
msgstr "Lisp debugger"

#. type: cindex
#: original_texis/debugging.texi:70
#, no-wrap
msgid "break"
msgstr "break"

#. type: Plain text
#: original_texis/debugging.texi:79
msgid "The ordinary @dfn{Lisp debugger} provides the ability to suspend evaluation of a form.  While evaluation is suspended (a state that is commonly known as a @dfn{break}), you may examine the run time stack, examine the values of local or global variables, or change those values.  Since a break is a recursive edit, all the usual editing facilities of Emacs are available; you can even run programs that will enter the debugger recursively.  @xref{Recursive Editing}."
msgstr "普通の@dfn{Lispデバッガ}は、フォーム評価のサスペンド機能を提供します。評価がサスペンド(一般的には@dfn{break}の状態として知られる)されている間、実行時スタックを調べたり、ローカル変数やグローバル変数の値を調べたり変更することができます。breakは再帰編集(recursive edit)なので、Emacsの通常の編集機能が利用可能です。デバッガにエンターするようにプログラムを実行することさえ可能です。@ref{Recursive Editing}を参照してください。"

#. type: node
#: original_texis/debugging.texi:92 original_texis/debugging.texi:94
#, no-wrap
msgid "Error Debugging"
msgstr "Error Debugging"

#. type: menuentry
#: original_texis/debugging.texi:92
msgid "Entering the debugger when an error happens."
msgstr "エラー発生時にデバッガにエンターする。"

#. type: node
#: original_texis/debugging.texi:92 original_texis/debugging.texi:223
#, no-wrap
msgid "Debugging Redisplay"
msgstr "Debugging Redisplay"

#. type: menuentry
#: original_texis/debugging.texi:92
msgid "Getting backtraces from redisplay errors."
msgstr "再表示エラーからのバックトレース取得。"

#. type: node
#: original_texis/debugging.texi:92 original_texis/debugging.texi:262
#, no-wrap
msgid "Infinite Loops"
msgstr "Infinite Loops"

#. type: menuentry
#: original_texis/debugging.texi:92
msgid "Stopping and debugging a program that doesn't exit."
msgstr "exitしないプログラムの停止デバッグ。"

#. type: node
#: original_texis/debugging.texi:92 original_texis/debugging.texi:292
#, no-wrap
msgid "Function Debugging"
msgstr "Function Debugging"

#. type: menuentry
#: original_texis/debugging.texi:92
msgid "Entering it when a certain function is called."
msgstr "特定の関数が呼び出されたときにデバッガにエンターする。"

#. type: node
#: original_texis/debugging.texi:92 original_texis/debugging.texi:362
#, no-wrap
msgid "Variable Debugging"
msgstr "Variable Debugging"

#. type: menuentry
#: original_texis/debugging.texi:92
msgid "Entering it when a variable is modified."
msgstr "変数が変更されたときにデバッガにエンターする。"

#. type: node
#: original_texis/debugging.texi:92 original_texis/debugging.texi:392
#, no-wrap
msgid "Explicit Debug"
msgstr "Explicit Debug"

#. type: menuentry
#: original_texis/debugging.texi:92
msgid "Entering it at a certain point in the program."
msgstr "プログラム内の特定箇所でデバッガにエンターする。"

#. type: node
#: original_texis/debugging.texi:92 original_texis/debugging.texi:416
#, no-wrap
msgid "Using Debugger"
msgstr "Using Debugger"

#. type: menuentry
#: original_texis/debugging.texi:92
msgid "What the debugger does."
msgstr "デバッガが行なうこと。"

#. type: subsection
#: original_texis/debugging.texi:92 original_texis/debugging.texi:455
#: original_texis/debugging.texi:456
#, no-wrap
msgid "Backtraces"
msgstr "Backtraces"

#. type: menuentry
#: original_texis/debugging.texi:92
msgid "What you see while in the debugger."
msgstr "デバッガ内で何を目にするか。"

#. type: subsection
#: original_texis/debugging.texi:92 original_texis/debugging.texi:523
#: original_texis/debugging.texi:524
#, no-wrap
msgid "Debugger Commands"
msgstr "Debugger Commands"

#. type: menuentry
#: original_texis/debugging.texi:92
msgid "Commands used while in the debugger."
msgstr "デバッガで使用するコマンド。"

#. type: subsection
#: original_texis/debugging.texi:92 original_texis/debugging.texi:626
#: original_texis/debugging.texi:627
#, no-wrap
msgid "Invoking the Debugger"
msgstr "Invoking the Debugger"

#. type: menuentry
#: original_texis/debugging.texi:92
msgid "How to call the function @code{debug}."
msgstr "関数@code{debug}の呼び出し方。"

#. type: node
#: original_texis/debugging.texi:92 original_texis/debugging.texi:736
#, no-wrap
msgid "Internals of Debugger"
msgstr "Internals of Debugger"

#. type: menuentry
#: original_texis/debugging.texi:92
msgid "Subroutines of the debugger, and global variables."
msgstr "デバッガのサブルーチンとグローバル変数。"

#. type: subsection
#: original_texis/debugging.texi:95
#, no-wrap
msgid "Entering the Debugger on an Error"
msgstr "Entering the Debugger on an Error"

#. type: cindex
#: original_texis/debugging.texi:96
#, no-wrap
msgid "error debugging"
msgstr "error debugging"

#. type: cindex
#: original_texis/debugging.texi:97
#, no-wrap
msgid "debugging errors"
msgstr "debugging errors"

#. type: Plain text
#: original_texis/debugging.texi:102
msgid "The most important time to enter the debugger is when a Lisp error happens.  This allows you to investigate the immediate causes of the error."
msgstr "デバッガに入るタイミングとして一番重要なのは、Lispエラーが発生したときです。デバッガではエラーの直接原因を調査できます。"

#. type: Plain text
#: original_texis/debugging.texi:110
msgid "However, entry to the debugger is not a normal consequence of an error.  Many commands signal Lisp errors when invoked inappropriately, and during ordinary editing it would be very inconvenient to enter the debugger each time this happens.  So if you want errors to enter the debugger, set the variable @code{debug-on-error} to non-@code{nil}.  (The command @code{toggle-debug-on-error} provides an easy way to do this.)"
msgstr "しかしデバッガへのエンターは、エラーによる通常の結末ではありません。多くのコマンドは不適切に呼び出されたときにLispエラーをシグナルするので、通常の編集の間にこれが発生するたびデバッガにエンターするのは、とても不便でしょう。したがってエラーの際にデバッガにエンターしたいなら、変数@code{debug-on-error}に非@code{nil}をセットします(コマンド@code{toggle-debug-on-error}はこれを簡単に行う方法を提供する)。"

#. type: Plain text
#: original_texis/debugging.texi:114
msgid "Note that, for technical reasons, you cannot use the facilities defined in this subsection to debug errors in Lisp that the redisplay code has invoked.  @xref{Debugging Redisplay}, for help with these."
msgstr "再表示コードによって呼び出されたLispエラーは、技術的な理由によりこのサブセクションで定義されている機能ではデバッグできないことに注意してください。これらについてのヘルプについては@ref{Debugging Redisplay}を参照してください。"

#. type: defopt
#: original_texis/debugging.texi:115
#, no-wrap
msgid "debug-on-error"
msgstr "debug-on-error"

#. type: defopt
#: original_texis/debugging.texi:121
msgid "This variable determines whether the debugger is called when an error is signaled and not handled.  If @code{debug-on-error} is @code{t}, all kinds of errors call the debugger, except those listed in @code{debug-ignored-errors} (see below).  If it is @code{nil}, none call the debugger."
msgstr "この変数はエラーがシグナルされて、それがハンドルされていないときにデバッガを呼び出すかどうかを決定する。@code{debug-on-error}が@code{t}なら、@code{debug-ignored-errors}(以下参照)にリストされているエラー以外の、すべての種類のエラーがデバッガを呼び出す。@code{nil}ならデバッガを呼び出さない。"

#. type: defopt
#: original_texis/debugging.texi:128
msgid "The value can also be a list of error conditions (@pxref{Signaling Errors}).  Then the debugger is called only for error conditions in this list (except those also listed in @code{debug-ignored-errors}).  For example, if you set @code{debug-on-error} to the list @code{(void-variable)}, the debugger is only called for errors about a variable that has no value."
msgstr "値にはエラー条件(@ref{Signaling Errors}を参照)のリストも指定できる。その場合はこのリスト内のエラー条件だけによってデバッガが呼び出される(@code{debug-ignored-errors}にもリストされているエラー条件は除外される)。たとえば@code{debug-on-error}をリスト@code{(void-variable)}にセットすると、値をもたない変数に関するエラーにたいしてのみデバッガが呼び出される。"

#. type: defopt
#: original_texis/debugging.texi:131
msgid "Note that @code{eval-expression-debug-on-error} overrides this variable in some cases; see below."
msgstr "@code{eval-expression-debug-on-error}がこの変数をオーバーライドするケースがいくつかあることに注意(以下参照)。"

#. type: defopt
#: original_texis/debugging.texi:135
msgid "When this variable is non-@code{nil}, Emacs does not create an error handler around process filter functions and sentinels.  Therefore, errors in these functions also invoke the debugger.  @xref{Processes}."
msgstr "この変数が非@code{nil}のとき、Emacsはプロセスフィルター関数と番兵(sentinel)の周囲にエラーハンドラーを作成しない。したがってこれらの関数内でのエラーは、デバッガを呼び出す。@ref{Processes}を参照のこと。"

#. type: defopt
#: original_texis/debugging.texi:137
#, no-wrap
msgid "debug-ignored-errors"
msgstr "debug-ignored-errors"

#. type: defopt
#: original_texis/debugging.texi:144
msgid "This variable specifies errors which should not enter the debugger, regardless of the value of @code{debug-on-error}.  Its value is a list of error condition symbols and/or regular expressions.  If the error has any of those condition symbols, or if the error message matches any of the regular expressions, then that error does not enter the debugger."
msgstr "この変数は@code{debug-on-error}の値に関わらず、デバッガにエンターすべきでないエラーを指定する。変数の値はエラー条件のシンボルおよび/または正規表現のリスト。エラーがこれら条件シンボルのいずれか、またはエラーメッセージが正規表現のいずれかにマッチすれば、そのエラーはデバッガにエンターしない。"

#. type: defopt
#: original_texis/debugging.texi:151
msgid "The normal value of this variable includes @code{user-error}, as well as several errors that happen often during editing but rarely result from bugs in Lisp programs.  However, ``rarely'' is not ``never''; if your program fails with an error that matches this list, you may try changing this list to debug the error.  The easiest way is usually to set @code{debug-ignored-errors} to @code{nil}."
msgstr "この変数の通常の値には@code{user-error}、および編集中に頻繁に発生するがLispプログラムのバグに起因することは稀であるような、いくつかのエラーが含まれる。しかし``稀である''ことは``絶対ない''ということではない。あなたのプログラムがこのリストにマッチするエラーによって機能しないなら、そのエラーをデバッグするためにこのリストの変更を試みるのもよいだろう。通常は@code{debug-ignored-errors}を@code{nil}にセットしておくのが、もっとも簡単な方法である。"

#. type: defopt
#: original_texis/debugging.texi:153
#, no-wrap
msgid "eval-expression-debug-on-error"
msgstr "eval-expression-debug-on-error"

#. type: defopt
#: original_texis/debugging.texi:158
msgid "If this variable has a non-@code{nil} value (the default), running the command @code{eval-expression} causes @code{debug-on-error} to be temporarily bound to @code{t}.  @xref{Lisp Eval,, Evaluating Emacs Lisp Expressions, emacs, The GNU Emacs Manual}."
msgstr "この変数が非@code{nil}値(デフォルト)なら、コマンド@code{eval-expression}の実行により一時的に@code{debug-on-error}が@code{t}がバインドされる。@ref{Lisp Eval,, Evaluating Emacs Lisp Expressions, emacs, The GNU Emacs Manual}を参照のこと。"

#. type: defopt
#: original_texis/debugging.texi:161
msgid "If @code{eval-expression-debug-on-error} is @code{nil}, then the value of @code{debug-on-error} is not changed during @code{eval-expression}."
msgstr "@code{eval-expression-debug-on-error}が@code{nil}なら、@code{eval-expression}の間も@code{debug-on-error}の値は変更されない。"

#. type: defopt
#: original_texis/debugging.texi:163
#, no-wrap
msgid "debug-on-signal"
msgstr "debug-on-signal"

#. type: defopt
#: original_texis/debugging.texi:167
msgid "Normally, errors caught by @code{condition-case} never invoke the debugger.  The @code{condition-case} gets a chance to handle the error before the debugger gets a chance."
msgstr "@code{condition-case}でキャッチされたエラー、は通常は決してデバッガを呼び出さない。@code{condition-case}はデバッガがそのエラーをハンドルする前にエラーをハンドルする機会を得る。"

#. type: defopt
#: original_texis/debugging.texi:173
msgid "If you change @code{debug-on-signal} to a non-@code{nil} value, the debugger gets the first chance at every error, regardless of the presence of @code{condition-case}.  (To invoke the debugger, the error must still fulfill the criteria specified by @code{debug-on-error} and @code{debug-ignored-errors}.)"
msgstr "@code{debug-on-signal}を非@code{nil}値に変更すると、@code{condition-case}の存在如何に関わらずすべてのエラーにおいてデバッガが最初に機会を得る(デバッガを呼び出すためには依然としてそのエラーが@code{debug-on-error}と@code{debug-ignored-errors}で指定された条件を満たさなければならない)。"

#. type: cindex
#: original_texis/debugging.texi:174
#, no-wrap
msgid "emacsclient, getting a backtrace"
msgstr "emacsclient, getting a backtrace"

#. type: cindex
#: original_texis/debugging.texi:175
#, no-wrap
msgid "backtrace from emacsclient's @option{--eval}"
msgstr "backtrace from emacsclient's @option{--eval}"

#. type: defopt
#: original_texis/debugging.texi:180
msgid "For example, setting this variable is useful to get a backtrace from code evaluated by emacsclient's @option{--eval} option.  If Lisp code evaluated by emacsclient signals an error while this variable is non-@code{nil}, the backtrace will popup in the running Emacs."
msgstr "たとえばemacsclientの@option{--eval}オプションによるコードの評価からバックトレースを取得するためにはこの変数をセットすると便利。この変数が非@code{nil}のときにemacsclientで評価されたLispコードがエラーをシグナルすると、バックトレースは実行中のEmacsにポップアップされる。"

#. type: defopt
#: original_texis/debugging.texi:187
msgid "@strong{Warning:} Setting this variable to non-@code{nil} may have annoying effects.  Various parts of Emacs catch errors in the normal course of affairs, and you may not even realize that errors happen there.  If you need to debug code wrapped in @code{condition-case}, consider using @code{condition-case-unless-debug} (@pxref{Handling Errors})."
msgstr "@strong{警告:} この変数を非@code{nil}にセットすると、芳しくない効果があるかもしれない。Emacsのさまざまな部分で処理の通常の過程としてエラーがキャッチされており、そのエラーが発生したことに気づかないことさえあるかもしれない。@code{condition-case}でラップされたコードをデバッグする必要があるなら、@code{condition-case-unless-debug}(@pxref{Handling Errors}を参照)の使用を考慮されたい。"

#. type: defopt
#: original_texis/debugging.texi:189
#, no-wrap
msgid "debug-on-event"
msgstr "debug-on-event"

#. type: defopt
#: original_texis/debugging.texi:196
msgid "If you set @code{debug-on-event} to a special event (@pxref{Special Events}), Emacs will try to enter the debugger as soon as it receives this event, bypassing @code{special-event-map}.  At present, the only supported values correspond to the signals @code{SIGUSR1} and @code{SIGUSR2} (this is the default).  This can be helpful when @code{inhibit-quit} is set and Emacs is not otherwise responding."
msgstr "@code{debug-on-event}をスペシャルイベント(@ref{Special Events}を参照)にセットすると、Emacsは@code{special-event-map}をバイパスしてこのイベントを受け取ると即座にデバッガへのエンターを試みる。現在のところサポートされる値は、シグナル@code{SIGUSR1}と@code{SIGUSR2}に対応する値のみ(これがデフォルト)。これは@code{inhibit-quit}がセットされていて、それ以外はEmacsが応答しない場合に有用かもしれない。"

#. type: cindex
#: original_texis/debugging.texi:198
#, no-wrap
msgid "message, finding what causes a particular message"
msgstr "message, finding what causes a particular message"

#. type: defvar
#: original_texis/debugging.texi:199
#, no-wrap
msgid "debug-on-message"
msgstr "debug-on-message"

#. type: defvar
#: original_texis/debugging.texi:204
msgid "If you set @code{debug-on-message} to a regular expression, Emacs will enter the debugger if it displays a matching message in the echo area.  For example, this can be useful when trying to find the cause of a particular message."
msgstr "@code{debug-on-message}に正規表現をセットした場合は、それにマッチするメッセージがエコーエリアに表示されると、Emacsはデバッガにエンターする。たとえばこれは特定のメッセージの原因を探すのに有用かもしれない。"

#. type: vindex
#: original_texis/debugging.texi:206 original_texis/debugging.texi:580
#, no-wrap
msgid "debug-allow-recursive-debug"
msgstr "debug-allow-recursive-debug"

#. type: defvar
#: original_texis/debugging.texi:215
msgid "You can evaluate forms in the current stack frame in the @samp{*Backtrace*} buffer with the @key{e} command, and while edebugging you can use the @key{e} and @key{C-x C-e} commands to do something similar.  By default, the debugger is inhibited by these commands (because (re-)entering the debugger at this point will usually take you out of the debugging context you're in).  Set @code{debug-allow-recursive-debug} to a non-@code{nil} value to allow these commands to enter the debugger recursively."
msgstr "@samp{*Backtrace*}バッファーのカレントスタックフレーム内のフォームは@key{e}コマンドで評価できる。またedebug中なら@key{e}や@key{C-x C-e}のコマンドを使用すれば、同様のことを行うことができる。デフォルトではこれらのコマンドによってデバッガは抑制される(この時点でデバッガに(再)エンターすると、デバッグ中のコンテキストから抜け出してしまうので)。しかし@code{debug-allow-recursive-debug}を非@code{nil}値にセットすると、これらのコマンドが再帰的にデバッガにエンターできるようになる。"

#. type: Plain text
#: original_texis/debugging.texi:222
msgid "To debug an error that happens during loading of the init file, use the option @samp{--debug-init}.  This binds @code{debug-on-error} to @code{t} while loading the init file, and bypasses the @code{condition-case} which normally catches errors in the init file."
msgstr "initファイルロード中に発生したエラーをデバッグするには、オプション@samp{--debug-init}を使用する。これはinitファイルロードの間に@code{debug-on-error}を@code{t}にバインドして、通常はinitファイル内のエラーをキャッチする@code{condition-case}をバイパスする。"

#. type: subsection
#: original_texis/debugging.texi:224
#, no-wrap
msgid "Debugging Redisplay Errors"
msgstr "Debugging Redisplay Errors"

#. type: cindex
#: original_texis/debugging.texi:225
#, no-wrap
msgid "redisplay errors"
msgstr "redisplay errors"

#. type: cindex
#: original_texis/debugging.texi:226
#, no-wrap
msgid "debugging redisplay errors"
msgstr "debugging redisplay errors"

#. type: Plain text
#: original_texis/debugging.texi:232
msgid "When an error occurs in Lisp code which redisplay has invoked, Emacs's usual debugging mechanisms are unusable, for technical reasons.  This subsection describes how to get a backtrace from such an error, which should be helpful in debugging it."
msgstr "再表示によって呼び出されたLispコード内でエラーが発生した際には、技術的な理由によりEmacsでの通常時のデバッグメカニズムが使えなくなります。このサブセクションではそのようなエラーからどのようにしてバックトレースを取得するかを説明します。デバッグ中に役に立つはずです。"

#. type: Plain text
#: original_texis/debugging.texi:236
msgid "These directions apply to Lisp forms used, for example, in @code{:eval} mode line constructs (@pxref{Mode Line Data}), and in all hooks invoked from redisplay, such as:"
msgstr "これらの説明はたとえばモードライン構文@code{:eval} (@ref{Mode Line Data}を参照)のように、再表示から呼び出される以下のようなすべてのフック内で使用されているLispフォームに適用されます。"

#. type: itemize
#: original_texis/debugging.texi:240
msgid "@code{fontification-functions} (@pxref{Auto Faces})."
msgstr "@code{fontification-functions} (@ref{Auto Faces}を参照)"

#. type: itemize
#: original_texis/debugging.texi:242
msgid "@code{window-scroll-functions} (@pxref{Window Hooks})."
msgstr "@code{window-scroll-functions} (@ref{Window Hooks}を参照)"

#. type: Plain text
#: original_texis/debugging.texi:248
msgid "Note that if you have had an error in a hook function called from redisplay, the error handling might have removed this function from the hook.  You will thus need to reinitialize that hook somehow, perhaps with @code{add-hook}, to be able to replay the bug."
msgstr "再表示から呼び出されたフック関数でエラーが発生すると、エラー処理によってその関数がフックから削除されているかもしれないことに注意してください。したがってそのバグを再現するためにそのフックを何らかの手段、恐らくは@code{add-hook}を使って再初期化する必要があるでしょう。"

#. type: Plain text
#: original_texis/debugging.texi:256
msgid "To generate a backtrace in these circumstances, set the variable @code{backtrace-on-redisplay-error} to non-@code{nil}.  When the error occurs, Emacs will dump the backtrace to the buffer @file{*Redisplay-trace*}, but won't automatically display it in a window.  This is to avoid needlessly corrupting the redisplay you are debugging.  You will thus need to display the buffer yourself, with a command such as @code{switch-to-buffer-other-frame} @key{C-x 5 b}."
msgstr "これらのような状況下でバックトレースを生成するには、変数@code{backtrace-on-redisplay-error}に非@code{nil}をセットします。エラーが発生するとEmacsはバッファー@file{*Redisplay-trace*}にバックトレースをダンプしますが、そのバッファーを自動的にウィンドウには表示しません。これはデバッグ中の再表示弐不必要な破壊を避けるためです。したがって@code{switch-to-buffer-other-frame} @key{C-x 5 b}のようなコマンドによって、このバッファーを自分で表示する必要があります。"

#. type: defvar
#: original_texis/debugging.texi:257
#, no-wrap
msgid "backtrace-on-redisplay-error"
msgstr "backtrace-on-redisplay-error"

#. type: defvar
#: original_texis/debugging.texi:260
msgid "Set this variable to non-@code{nil} to enable the generation of a backtrace when an error occurs in any Lisp called from redisplay."
msgstr "再表示から呼び出されたすべてのLispにたいしてエラー発生時のバックトレース生成を有効にするには、この変数に非@code{nil}をセットする。"

#. type: subsection
#: original_texis/debugging.texi:263
#, no-wrap
msgid "Debugging Infinite Loops"
msgstr "Debugging Infinite Loops"

#. type: cindex
#: original_texis/debugging.texi:264
#, no-wrap
msgid "infinite loops"
msgstr "infinite loops"

#. type: cindex
#: original_texis/debugging.texi:265
#, no-wrap
msgid "loops, infinite"
msgstr "loops, infinite"

#. type: cindex
#: original_texis/debugging.texi:266
#, no-wrap
msgid "quitting from infinite loop"
msgstr "quitting from infinite loop"

#. type: cindex
#: original_texis/debugging.texi:267
#, no-wrap
msgid "stopping an infinite loop"
msgstr "stopping an infinite loop"

#. type: Plain text
#: original_texis/debugging.texi:272
msgid "When a program loops infinitely and fails to return, your first problem is to stop the loop.  On most operating systems, you can do this with @kbd{C-g}, which causes a @dfn{quit}.  @xref{Quitting}."
msgstr "プログラムが無限にループしてリターンできないとき、最初の問題はそのループをいかに停止するかです。ほとんどのオペレーティングシステムでは、(@dfn{quit}させる)@kbd{C-g}でこれを行うことができます。@ref{Quitting}を参照してください。"

#. type: Plain text
#: original_texis/debugging.texi:279
msgid "Ordinary quitting gives no information about why the program was looping.  To get more information, you can set the variable @code{debug-on-quit} to non-@code{nil}.  Once you have the debugger running in the middle of the infinite loop, you can proceed from the debugger using the stepping commands.  If you step through the entire loop, you may get enough information to solve the problem."
msgstr "普通のquitでは、なぜそのプログラムがループしたかについての情報は与えられません。変数@code{debug-on-quit}に非@code{nil}をセットすることにより、より多くの情報を得ることができます。無限ループの途中でデバッガを実行すれば、デバッガからステップコマンドで先へ進むことができます。ループ全体をステップで追えば、問題を解決するために十分な情報が得られるでしょう。"

#. type: Plain text
#: original_texis/debugging.texi:283
msgid "Quitting with @kbd{C-g} is not considered an error, and @code{debug-on-error} has no effect on the handling of @kbd{C-g}.  Likewise, @code{debug-on-quit} has no effect on errors."
msgstr "@kbd{C-g}によるquitはエラーとは判断されないので、@kbd{C-g}のハンドルに@code{debug-on-error}は効果がありません。同じように@code{debug-on-quit}はエラーにたいして効果がありません。"

#. type: defopt
#: original_texis/debugging.texi:284
#, no-wrap
msgid "debug-on-quit"
msgstr "debug-on-quit"

#. type: defopt
#: original_texis/debugging.texi:290
msgid "This variable determines whether the debugger is called when @code{quit} is signaled and not handled.  If @code{debug-on-quit} is non-@code{nil}, then the debugger is called whenever you quit (that is, type @kbd{C-g}).  If @code{debug-on-quit} is @code{nil} (the default), then the debugger is not called when you quit."
msgstr "この変数は@code{quit}がシグナルされて、それがハンドルされていないときにデバッガを呼び出すかどうかを決定する。@code{debug-on-quit}が非@code{nil}なら、quit(つまり@kbd{C-g}をタイプ)したときは常にデバッガが呼び出される。@code{debug-on-quit}が@code{nil}(デフォルト)なら、quitしてもデバッガは呼び出されない。"

#. type: subsection
#: original_texis/debugging.texi:293
#, no-wrap
msgid "Entering the Debugger on a Function Call"
msgstr "Entering the Debugger on a Function Call"

#. type: cindex
#: original_texis/debugging.texi:294
#, no-wrap
msgid "function call debugging"
msgstr "function call debugging"

#. type: cindex
#: original_texis/debugging.texi:295
#, no-wrap
msgid "debugging specific functions"
msgstr "debugging specific functions"

#. type: Plain text
#: original_texis/debugging.texi:303
msgid "To investigate a problem that happens in the middle of a program, one useful technique is to enter the debugger whenever a certain function is called.  You can do this to the function in which the problem occurs, and then step through the function, or you can do this to a function called shortly before the problem, step quickly over the call to that function, and then step through its caller."
msgstr "プログラムの途中で発生する問題を調べるための有用なテクニックの1つは、特定の関数が呼び出されたときデバッガにエンターする方法です。問題が発生した関数にこれを行ってその関数をステップで追ったり、問題箇所の少し手前の関数呼び出しでこれを行って、その関数をステップオーバーしてその後をステップで追うことができます。"

#. type: deffn
#: original_texis/debugging.texi:304
#, no-wrap
msgid "Command debug-on-entry function-name"
msgstr "Command debug-on-entry function-name"

#. type: deffn
#: original_texis/debugging.texi:307
msgid "This function requests @var{function-name} to invoke the debugger each time it is called."
msgstr "この関数は@var{function-name}が呼び出されるたびにデバッガの呼び出しを要求する。"

#. type: deffn
#: original_texis/debugging.texi:316
msgid "Any function or macro defined as Lisp code may be set to break on entry, regardless of whether it is interpreted code or compiled code.  If the function is a command, it will enter the debugger when called from Lisp and when called interactively (after the reading of the arguments).  You can also set debug-on-entry for primitive functions (i.e., those written in C) this way, but it only takes effect when the primitive is called from Lisp code.  Debug-on-entry is not allowed for special forms."
msgstr "Lispコードで定義された任意の関数とマクロは、インタープリターに解釈されたコードかコンパイル済みのコードかに関わらず、エントリーにbreakをセットできる。その関数がコマンドならLispから呼び出されたときと、インタラクティブに呼び出されたときにデバッガにエンターする。(たとえばCで記述された)プリミティブ関数にもこの方法で@code{debug-on-entry}をセットできるが、そのプリミティブがLispコードから呼び出されたときだけ効果がある。@code{debug-on-entry}はスペシャルフォームにはセットできない。"

#. type: deffn
#: original_texis/debugging.texi:321
msgid "When @code{debug-on-entry} is called interactively, it prompts for @var{function-name} in the minibuffer.  If the function is already set up to invoke the debugger on entry, @code{debug-on-entry} does nothing.  @code{debug-on-entry} always returns @var{function-name}."
msgstr "@code{debug-on-entry}がインタラクティブに呼び出されたときは、ミニバッファーで@var{function-name}の入力を求める。その関数がすでにエントリーでデバッガを呼び出すようにセットアップされていたら、@code{debug-on-entry}は何も行わない。@code{debug-on-entry}は常に@var{function-name}をリターンする。"

#. type: deffn
#: original_texis/debugging.texi:323
msgid "Here's an example to illustrate use of this function:"
msgstr "以下はこの関数の使い方を説明するための例である:"

#. type: group
#: original_texis/debugging.texi:330
#, no-wrap
msgid ""
"(defun fact (n)\n"
"  (if (zerop n) 1\n"
"      (* n (fact (1- n)))))\n"
"     @result{} fact\n"
msgstr ""
"(defun fact (n)\n"
"  (if (zerop n) 1\n"
"      (* n (fact (1- n)))))\n"
"     @result{} fact\n"

#. type: group
#: original_texis/debugging.texi:334
#, no-wrap
msgid ""
"(debug-on-entry 'fact)\n"
"     @result{} fact\n"
msgstr ""
"(debug-on-entry 'fact)\n"
"     @result{} fact\n"

#. type: group
#: original_texis/debugging.texi:337
#, no-wrap
msgid "(fact 3)\n"
msgstr "(fact 3)\n"

#. type: group
#: original_texis/debugging.texi:348
#, no-wrap
msgid ""
"------ Buffer: *Backtrace* ------\n"
"Debugger entered--entering a function:\n"
"* fact(3)\n"
"  eval((fact 3))\n"
"  eval-last-sexp-1(nil)\n"
"  eval-last-sexp(nil)\n"
"  call-interactively(eval-last-sexp)\n"
"------ Buffer: *Backtrace* ------\n"
msgstr ""
"------ Buffer: *Backtrace* ------\n"
"Debugger entered--entering a function:\n"
"* fact(3)\n"
"  eval((fact 3))\n"
"  eval-last-sexp-1(nil)\n"
"  eval-last-sexp(nil)\n"
"  call-interactively(eval-last-sexp)\n"
"------ Buffer: *Backtrace* ------\n"

#. type: deffn
#: original_texis/debugging.texi:353
#, no-wrap
msgid "Command cancel-debug-on-entry &optional function-name"
msgstr "Command cancel-debug-on-entry &optional function-name"

#. type: deffn
#: original_texis/debugging.texi:360
msgid "This function undoes the effect of @code{debug-on-entry} on @var{function-name}.  When called interactively, it prompts for @var{function-name} in the minibuffer.  If @var{function-name} is omitted or @code{nil}, it cancels break-on-entry for all functions.  Calling @code{cancel-debug-on-entry} does nothing to a function which is not currently set up to break on entry."
msgstr "この関数は@var{function-name}にたいする@code{debug-on-entry}の効果をアンドゥする。インタラクティブに呼び出されたときは、ミニバッファーで@var{function-name}の入力を求める。@var{function-name}が省略または@code{nil}なら、すべての関数にたいするbreak-on-entryをキャンセルする。エントリー時にbreakするようセットアップされていない関数に@code{cancel-debug-on-entry}を呼び出したときは何も行わない。"

#. type: subsection
#: original_texis/debugging.texi:363
#, no-wrap
msgid "Entering the debugger when a variable is modified"
msgstr "変数の変更時にデバッガにエンターする。"

#. type: cindex
#: original_texis/debugging.texi:364
#, no-wrap
msgid "variable write debugging"
msgstr "variable write debugging"

#. type: cindex
#: original_texis/debugging.texi:365
#, no-wrap
msgid "debugging changes to variables"
msgstr "debugging changes to variables"

#. type: Plain text
#: original_texis/debugging.texi:370
msgid "Sometimes a problem with a function is due to a wrong setting of a variable.  Setting up the debugger to trigger whenever the variable is changed is a quick way to find the origin of the setting."
msgstr "不正な変数のセッティングが関数に問題をもたらすときがあります。元のセッティングを調べるためには、変数の変更時に常にデバッガがトリガーされるようにセットアップするのが手軽な方法です。"

#. type: deffn
#: original_texis/debugging.texi:371
#, no-wrap
msgid "Command debug-on-variable-change variable"
msgstr "Command debug-on-variable-change variable"

#. type: deffn
#: original_texis/debugging.texi:374
msgid "This function arranges for the debugger to be called whenever @var{variable} is modified."
msgstr "この関数は@var{variable}の変更時に常にデバッガが呼び出されるようにアレンジする。"

#. type: deffn
#: original_texis/debugging.texi:380
msgid "It is implemented using the watchpoint mechanism, so it inherits the same characteristics and limitations: all aliases of @var{variable} will be watched together, only dynamic variables can be watched, and changes to the objects referenced by variables are not detected.  For details, see @ref{Watching Variables}."
msgstr "これはwatchpointメカニズムを使用して実装されているので同じような特徴と制限を継承する。つまり@var{variable}のすべてのエイリアスは一緒にwatchされて、watch対象はダイナミック変数のみであり変数から参照されるオブジェクトの変更は検出されない。詳細は@ref{Watching Variables}を参照のこと。"

#. type: deffn
#: original_texis/debugging.texi:382
#, no-wrap
msgid "Command cancel-debug-on-variable-change &optional variable"
msgstr "Command cancel-debug-on-variable-change &optional variable"

#. type: deffn
#: original_texis/debugging.texi:389
msgid "This function undoes the effect of @code{debug-on-variable-change} on @var{variable}.  When called interactively, it prompts for @var{variable} in the minibuffer.  If @var{variable} is omitted or @code{nil}, it cancels break-on-change for all variables.  Calling @code{cancel-debug-on-variable-change} does nothing to a variable which is not currently set up to break on change."
msgstr "この関数は@var{variable}にたいする@code{debug-on-variable-change}の効果をアンドゥする。インタラクティブに呼び出されたときはミニバッファーで@var{variable}の入力をもとめる。@var{variable}が省略か@code{nil}ならすべての変数にたいする変更時のブレークを取り消す。カレントで変更時にブレークするようにセットアップされていない変数にたいして@code{cancel-debug-on-variable-change}の呼び出しは何も行わない。"

#. type: subsection
#: original_texis/debugging.texi:393
#, no-wrap
msgid "Explicit Entry to the Debugger"
msgstr "Explicit Entry to the Debugger"

#. type: cindex
#: original_texis/debugging.texi:394
#, no-wrap
msgid "debugger, explicit entry"
msgstr "debugger, explicit entry"

#. type: cindex
#: original_texis/debugging.texi:395
#, no-wrap
msgid "force entry to debugger"
msgstr "force entry to debugger"

#. type: cindex
#: original_texis/debugging.texi:397
#, no-wrap
msgid "@code{eval-defun}, and explicit entry to debugger"
msgstr "@code{eval-defun}, and explicit entry to debugger"

#. type: Plain text
#: original_texis/debugging.texi:404
msgid "You can cause the debugger to be called at a certain point in your program by writing the expression @code{(debug)} at that point.  To do this, visit the source file, insert the text @samp{(debug)} at the proper place, and type @kbd{C-M-x} (@code{eval-defun}, a Lisp mode key binding).  @strong{Warning:} if you do this for temporary debugging purposes, be sure to undo this insertion before you save the file!"
msgstr "プログラム内の特定箇所に式@code{(debug)}を記述することによって、その箇所でデバッガが呼び出されるようにできます。これを行うにはソースファイルをvisitして、適切な箇所にテキスト@samp{(debug)}を挿入し、@kbd{C-M-x}(Lispモードでの@code{eval-defun}にたいするキーバインド)をタイプします。@strong{警告:} 一時的なデバッグ目的のためにこれを行なう場合には、ファイルを保存する前に確実にアンドゥしてください!"

#. type: Plain text
#: original_texis/debugging.texi:410
msgid "The place where you insert @samp{(debug)} must be a place where an additional form can be evaluated and its value ignored.  (If the value of @code{(debug)} isn't ignored, it will alter the execution of the program!)  The most common suitable places are inside a @code{progn} or an implicit @code{progn} (@pxref{Sequencing})."
msgstr "@samp{(debug)}を挿入する箇所は追加フォームが評価されることができ、かつその値を無視することができる箇所でなければなりません(@samp{(debug)}の値を無視しないとプログラムの実行が変更されてしまうだろう!)。一般的にもっとも適した箇所は、@code{progn}または暗黙的な@code{progn}(@ref{Sequencing}を参照)の内部です。"

#. type: Plain text
#: original_texis/debugging.texi:415
msgid "If you don't know exactly where in the source code you want to put the debug statement, but you want to display a backtrace when a certain message is displayed, you can set @code{debug-on-message} to a regular expression matching the desired message."
msgstr "デバッグ命令を配置したいソースコード中の正確な箇所がわからないが、特定のメッセージが表示されたときにバックトレースを表示したい場合には、意図するメッセージにマッチする正規表現を@code{debug-on-message}にセットできます。"

#. type: subsection
#: original_texis/debugging.texi:417
#, no-wrap
msgid "Using the Debugger"
msgstr "Using the Debugger"

#. type: Plain text
#: original_texis/debugging.texi:426
msgid "When the debugger is entered, it displays the previously selected buffer in one window and a buffer named @file{*Backtrace*} in another window.  The backtrace buffer contains one line for each level of Lisp function execution currently going on.  At the beginning of this buffer is a message describing the reason that the debugger was invoked (such as the error message and associated data, if it was invoked due to an error)."
msgstr "デバッガにエンターすると、その前に選択されていたウィンドウを1つのウィンドウに表示して、他のウィンドウに@file{*Backtrace*}という名前のバッファーを表示します。backtraceバッファーには、現在実行されているLisp関数の各レベルが1行ずつ含まれます。このバッファーの先頭は、デバッガが呼び出された理由を説明するメッセージ(デバッガがエラーにより呼び出された場合はエラーメッセージや関連するデータなど)です。"

#. type: vindex
#: original_texis/debugging.texi:427
#, no-wrap
msgid "debugger-bury-or-kill"
msgstr "debugger-bury-or-kill"

#. type: Plain text
#: original_texis/debugging.texi:442
msgid "The backtrace buffer is read-only and uses a special major mode, Debugger mode, in which letters are defined as debugger commands.  The usual Emacs editing commands are available; thus, you can switch windows to examine the buffer that was being edited at the time of the error, switch buffers, visit files, or do any other sort of editing.  However, the debugger is a recursive editing level (@pxref{Recursive Editing})  and it is wise to go back to the backtrace buffer and exit the debugger (with the @kbd{q} command) when you are finished with it.  Exiting the debugger gets out of the recursive edit and buries the backtrace buffer.  (You can customize what the @kbd{q} command does with the backtrace buffer by setting the variable @code{debugger-bury-or-kill}.  For example, set it to @code{kill} if you prefer to kill the buffer rather than bury it.  Consult the variable's documentation for more possibilities.)"
msgstr "backtraceバッファーは読み取り専用で、文字キーにデバッガコマンドが定義されたDebuggerモードという特別なメジャーモードを使用します。通常のEmacs編集コマンドが利用できます。したがってエラー時に編集されていたバッファーを調べるためにウィンドウを切り替えたり、バッファーの切り替えやファイルのvisit、その他一連の編集処理を行なうことができます。しかしデバッガは再帰編集レベル(@ref{Recursive Editing}を参照)にあり、編集が終わったらそれはbacktraceバッファーに戻って、(@kbd{q}コマンドで)デバッガをexitできます。デバッガをexitすることによって再帰編集を抜け出し、backtraceバッファーはバリー(bury: 覆い隠す)されます(変数@code{debugger-bury-or-killw}をセットすることによってbacktraceバッファーで@kbd{q}コマンドが何を行うかをカスタマイズできる。たとえばバッファーをバリーせずにkillしたいなら、この変数を@code{kill}にセットする。他の値については変数のドキュメントを調べてほしい)。"

#. type: Plain text
#: original_texis/debugging.texi:450
msgid "When the debugger has been entered, the @code{debug-on-error} variable is temporarily set according to @code{eval-expression-debug-on-error}.  If the latter variable is non-@code{nil}, @code{debug-on-error} will temporarily be set to @code{t}.  However, further errors that occur while debugging won't (by default) trigger another debugger, because @code{inhibit-debugger} will also be bound to non-@code{nil}."
msgstr "デバッガにエンターしたとき、@code{eval-expression-debug-on-error}に一致するように変数@code{debug-on-error}が一時的にセットされます。変数@code{eval-expression-debug-on-error}が非@code{nil}なら、@code{debug-on-error}は一時的に@code{t}にセットされます。ただしデバッグ中に更にエラーが発生しても、(デフォルトでは)別のデバッガをトリガーすることはありません。それは@code{inhibit-debugger}も非@code{nil}にバインドされているからです。"

#. type: Plain text
#: original_texis/debugging.texi:454
msgid "The debugger itself must be run byte-compiled, since it makes assumptions about the state of the Lisp interpreter.  These assumptions are false if the debugger is running interpreted."
msgstr "デバッガはLispインタープリターの状態について想定を行うので、バイトコンパイルされて実行されなければなりません。デバッガがインタープリターに解釈されて実行されているときは、これらの想定は正しくなくなります。"

#. type: cindex
#: original_texis/debugging.texi:457
#, no-wrap
msgid "backtrace buffer"
msgstr "backtrace buffer"

#. type: Plain text
#: original_texis/debugging.texi:462
msgid "Debugger mode is derived from Backtrace mode, which is also used to show backtraces by Edebug and ERT@.  (@pxref{Edebug}, and @ref{Top,the ERT manual,, ert, ERT: Emacs Lisp Regression Testing}.)"
msgstr "DebuggerモードはEdebugとERT(@ref{Edebug}と@ref{Top,the ERT manual,, ert, ERT: Emacs Lisp Regression Testing}を参照)がbacktrace表示にも使用するBacktraceモードから派生したモードです。"

#. type: cindex
#: original_texis/debugging.texi:463
#, no-wrap
msgid "stack frame"
msgstr "stack frame"

#. type: Plain text
#: original_texis/debugging.texi:470
msgid "The backtrace buffer shows you the functions that are executing and their argument values.  When a backtrace buffer is created, it shows each stack frame on one, possibly very long, line.  (A stack frame is the place where the Lisp interpreter records information about a particular invocation of a function.)  The most recently called function will be at the top."
msgstr "backtraceバッファーは実行されている関数と、その関数の引数の値を示します。backtraceバッファー作成時には1つのスタックフレームにたいして1行(非常に長い可能性がある)を表示します(スタックフレームとはLispインタープリターが特定の関数呼び出しに関する情報を記録する場所のこと)。もっとも最近の呼び出しが最上行になります。"

#. type: cindex
#: original_texis/debugging.texi:471
#, no-wrap
msgid "current stack frame"
msgstr "current stack frame"

#. type: Plain text
#: original_texis/debugging.texi:475
msgid "In a backtrace you can specify a stack frame by moving point to a line describing that frame.  The frame whose line point is on is considered the @dfn{current frame}."
msgstr "backtraceではフレームを記述する行にポイントを移動してフタックフレームを指定できます。ポイントのある行のフレームが@dfn{カレントフレーム(current frame)}とみなされます。"

#. type: Plain text
#: original_texis/debugging.texi:484
msgid "If a function name is underlined, that means Emacs knows where its source code is located.  You can click with the mouse on that name, or move to it and type @key{RET}, to visit the source code.  You can also type @key{RET} while point is on any name of a function or variable which is not underlined, to see help information for that symbol in a help buffer, if any exists.  The @code{xref-find-definitions} command, bound to @kbd{M-.}, can also be used on any identifier in a backtrace (@pxref{Looking Up Identifiers,,,emacs, The GNU Emacs Manual})."
msgstr "関数名に下線が引かれている場合には、Emacsがソースコードの場所を知っていることを意味します。その関数名をマウスでクリックするか、そこに移動して@key{RET}をタイプすることにより、ソースコードをvisitできます。下線のない関数名や変数名にポイントがあるときに@key{RET}をタイプした場合には、もしあればそのシンボルにたいするヘルプ情報をhelpバッファーで確認することもできます。@kbd{M-.}にバインドされている@code{xref-find-definitions}コマンドはbacktrace内の任意の識別子にも使用できます(@ref{Looking Up Identifiers,,,emacs, The GNU Emacs Manual}を参照)。"

#. type: Plain text
#: original_texis/debugging.texi:491
msgid "In backtraces, the tails of long lists and the ends of long strings, vectors or structures, as well as objects which are deeply nested, will be printed as underlined ``...''.  You can click with the mouse on a ``...'', or type @key{RET} while point is on it, to show the part of the object that was hidden.  To control how much abbreviation is done, customize @code{backtrace-line-length}."
msgstr "backtraceでは長いリストの末尾およびベクターや構造、同じように深くネストされたオブジェクトの終端は下線つきの``...''でプリントされます。``...''上でマウスをクリックするか、その上にポイントがある状態で@key{RET}をタイプすることにより、オブジェクトの隠蔽されている部分を表示できます。省略を行う量の制御は@code{backtrace-line-length}をカスタマイズしてください。"

#. type: Plain text
#: original_texis/debugging.texi:493
msgid "Here is a list of commands for navigating and viewing backtraces:"
msgstr "以下はbacktraceの操作と閲覧を行うコマンドのリストです:"

#. type: item
#: original_texis/debugging.texi:495
#, no-wrap
msgid "v"
msgstr "v"

#. type: table
#: original_texis/debugging.texi:497
msgid "Toggle the display of local variables of the current stack frame."
msgstr "カレントスタックフレームのローカル変数の表示を切り替える。"

#. type: item
#: original_texis/debugging.texi:498
#, no-wrap
msgid "p"
msgstr "p"

#. type: table
#: original_texis/debugging.texi:501
msgid "Move to the beginning of the frame, or to the beginning of the previous frame."
msgstr "フレームまたは前のフレームの先頭に移動する。"

#. type: item
#: original_texis/debugging.texi:502
#, no-wrap
msgid "n"
msgstr "n"

#. type: table
#: original_texis/debugging.texi:504
msgid "Move to the beginning of the next frame."
msgstr "次のフレームの先頭に移動する。"

#. type: item
#: original_texis/debugging.texi:505
#, no-wrap
msgid "+"
msgstr "+"

#. type: table
#: original_texis/debugging.texi:508
msgid "Add line breaks and indentation to the top-level Lisp form at point to make it more readable."
msgstr "可読性向上のためにポイント位置に行ブレークを追加してトップレベルLispフォームにインデントする。"

#. type: item
#: original_texis/debugging.texi:509
#, no-wrap
msgid "-"
msgstr "-"

#. type: table
#: original_texis/debugging.texi:511
msgid "Collapse the top-level Lisp form at point back to a single line."
msgstr "ポイント位置のトップレベルLispフォームを1行に折り畳む。"

#. type: item
#: original_texis/debugging.texi:512
#, no-wrap
msgid "#"
msgstr "#"

#. type: table
#: original_texis/debugging.texi:514
msgid "Toggle @code{print-circle} for the frame at point."
msgstr "ポイント位置のフレームの@code{print-circle}を切り替える。"

#. type: item
#: original_texis/debugging.texi:515
#, no-wrap
msgid ":"
msgstr ":"

#. type: table
#: original_texis/debugging.texi:517
msgid "Toggle @code{print-gensym} for the frame at point."
msgstr "ポイント位置のフレームの@code{print-gensym}を切り替える。"

#. type: item
#: original_texis/debugging.texi:518
#, no-wrap
msgid "."
msgstr "."

#. type: table
#: original_texis/debugging.texi:520
msgid "Expand all the forms abbreviated with ``...'' in the frame at point."
msgstr "ポイント位置のフレームの``...''で省略されたすべてのフォームを展開する。"

#. type: cindex
#: original_texis/debugging.texi:525
#, no-wrap
msgid "debugger command list"
msgstr "debugger command list"

#. type: Plain text
#: original_texis/debugging.texi:538
msgid "The debugger buffer (in Debugger mode) provides special commands in addition to the usual Emacs commands and to the Backtrace mode commands described in the previous section.  The most important use of debugger commands is for stepping through code, so that you can see how control flows.  The debugger can step through the control structures of an interpreted function, but cannot do so in a byte-compiled function.  If you would like to step through a byte-compiled function, replace it with an interpreted definition of the same function.  (To do this, visit the source for the function and type @kbd{C-M-x} on its definition.)  You cannot use the Lisp debugger to step through a primitive function."
msgstr "(Debuggerモードの)debuggerバッファーでは通常のEmacsコマンドに加えて特別なコマンド、および前セクションで説明したBacktraceモードのコマンドが提供されます。デバッガでもっとも重要な使い方をするのは、制御フローを見ることができるコードをステップ実行するコマンドです。デバッガはインタープリターによって解釈された制御構造のステップ実行はできますが、バイトコンパイル済みの関数ではできません。バイトコンパイル済み関数をステップ実行したいなら、同じ関数の解釈された定義に置き換えてください(これを行なうにはその関数のソースをvisitして、関数の定義で@kbd{C-M-x}とタイプする)。プリミティブ関数のステップ実行にLispデバッガは使用できません。"

#. type: Plain text
#: original_texis/debugging.texi:543
msgid "Some of the debugger commands operate on the current frame.  If a frame starts with a star, that means that exiting that frame will call the debugger again.  This is useful for examining the return value of a function."
msgstr "デバッガのコマンドのいくつかはカレントフレームを処理します。フレームが星印で開始される場合には、そのフレームをexitすることにより再びデバッガが呼び出されることを意味します。これは関数のリターン値の検証に有用です。"

#. type: Plain text
#: original_texis/debugging.texi:546
msgid "Here is a list of Debugger mode commands:"
msgstr "以下はDebuggerモードのコマンドのリストです:"

#. type: item
#: original_texis/debugging.texi:548
#, no-wrap
msgid "c"
msgstr "c"

#. type: table
#: original_texis/debugging.texi:553
msgid "Exit the debugger and continue execution.  This resumes execution of the program as if the debugger had never been entered (aside from any side-effects that you caused by changing variable values or data structures while inside the debugger)."
msgstr "デバッガをexitして実行を継続する。これはあたかもデバッガにエンターしなかったかのようにプログラムの実行を再開する(デバッガ内で行った変数値やデータ構造の変更などの副作用は除外)。"

#. type: item
#: original_texis/debugging.texi:554
#, no-wrap
msgid "d"
msgstr "d"

#. type: table
#: original_texis/debugging.texi:559
msgid "Continue execution, but enter the debugger the next time any Lisp function is called.  This allows you to step through the subexpressions of an expression, seeing what values the subexpressions compute, and what else they do."
msgstr "実行を継続するが、次にLisp関数が何か呼び出されたときはデバッガにエンターする。これによりある式の下位の式をステップ実行して、下位の式が計算する値や行うことを確認できる。"

#. type: table
#: original_texis/debugging.texi:564
msgid "The stack frame made for the function call which enters the debugger in this way will be flagged automatically so that the debugger will be called again when the frame is exited.  You can use the @kbd{u} command to cancel this flag."
msgstr "デバッガにエンターした関数呼び出しにたいして、この方法で作成されたスタックフレームには自動的にフラグがつくため、そのフレームをexitすると再びデバッガが呼び出される。このフラグは@kbd{u}コマンドを使用してキャンセルできる。"

#. type: item
#: original_texis/debugging.texi:565
#, no-wrap
msgid "b"
msgstr "b"

#. type: table
#: original_texis/debugging.texi:569
msgid "Flag the current frame so that the debugger will be entered when the frame is exited.  Frames flagged in this way are marked with stars in the backtrace buffer."
msgstr "カレントフレームにフラグをつけるので、そのフレームをexitするときデバッガにエンターする。この方法でフラグがつけられたフレームは、backtraceバッファーでスターのマークがつく。"

#. type: item
#: original_texis/debugging.texi:570
#, no-wrap
msgid "u"
msgstr "u"

#. type: table
#: original_texis/debugging.texi:574
msgid "Don't enter the debugger when the current frame is exited.  This cancels a @kbd{b} command on that frame.  The visible effect is to remove the star from the line in the backtrace buffer."
msgstr "カレントフレームをexitしたときデバッガにエンターしない。これはそのフレームの@kbd{b}コマンドをキャンセルする。目に見える効果としてはbacktraceバッファーの行からスターが削除される。"

#. type: item
#: original_texis/debugging.texi:575
#, no-wrap
msgid "j"
msgstr "j"

#. type: table
#: original_texis/debugging.texi:579
msgid "Flag the current frame like @kbd{b}.  Then continue execution like @kbd{c}, but temporarily disable break-on-entry for all functions that are set up to do so by @code{debug-on-entry}."
msgstr "@kbd{b}と同じようにカレントフレームにフラグをつける。その後に@kbd{c}のように実行を継続するが、@code{debug-on-entry}によりセットアップされたすべての関数にたいするbreak-on-entryを一時的に無効にする。"

#. type: item
#: original_texis/debugging.texi:581
#, no-wrap
msgid "e"
msgstr "e"

#. type: table
#: original_texis/debugging.texi:594
msgid "Read a Lisp expression in the minibuffer, evaluate it (with the relevant lexical environment, if applicable), and print the value in the echo area.  The debugger alters certain important variables, and the current buffer, as part of its operation; @kbd{e} temporarily restores their values from outside the debugger, so you can examine and change them.  This makes the debugger more transparent.  By contrast, @kbd{M-:} does nothing special in the debugger; it shows you the variable values within the debugger.  By default, this command suppresses the debugger during evaluation, so that an error in the evaluated expression won't add a new error on top of the existing one.  Set the @code{debug-allow-recursive-debug} user option to a non-@code{nil} value to override this."
msgstr "ミニバッファーのLisp式を読み取り、(関連するlexical環境が適切なら)それを評価してエコーエリアに値をプリントする。デバッガは特定の重要な変数とバッファーを処理の一部として変更する。@kbd{e}は一時的にデバッガの外部からそれらの値をリストアするので、それらを調べて変更できる。これによりデバッガはより透過的になる。対照的にデバッガ内で@kbd{M-:}は特別なことを行わず、デバッガ内での変数の値を表示する。このコマンドは既存のエラーの最上位の上に新たなエラーとして式の評価によるエラーを追加しないように、デフォルトでは評価の間はデバッガを抑止する。これはユーザーオプション@code{debug-allow-recursive-debug}を非@code{nil}値にセットすることによってオーバーライドできる。"

#. type: item
#: original_texis/debugging.texi:595
#, no-wrap
msgid "R"
msgstr "R"

#. type: table
#: original_texis/debugging.texi:598
msgid "Like @kbd{e}, but also save the result of evaluation in the buffer @file{*Debugger-record*}."
msgstr "@kbd{e}と同様だがバッファー@file{*Debugger-record*}内の評価結果も保存する。"

#. type: item
#: original_texis/debugging.texi:599
#, no-wrap
msgid "q"
msgstr "q"

#. type: table
#: original_texis/debugging.texi:602
msgid "Terminate the program being debugged; return to top-level Emacs command execution."
msgstr "デバッグされているプログラムを終了して、Emacsコマンド実行のトップレベルにリターンする。"

#. type: table
#: original_texis/debugging.texi:605
msgid "If the debugger was entered due to a @kbd{C-g} but you really want to quit, and not debug, use the @kbd{q} command."
msgstr "@kbd{C-g}によりデバッガにエンターしたが、実際はデバッグではなくquitしたいときは@kbd{q}コマンドを使用する。"

#. type: item
#: original_texis/debugging.texi:606
#, no-wrap
msgid "r"
msgstr "r"

#. type: table
#: original_texis/debugging.texi:609
msgid "Return a value from the debugger.  The value is computed by reading an expression with the minibuffer and evaluating it."
msgstr "デバッガから値をリターンする。ミニバッファーで式を読み取ってそれを評価することにより値が計算される。"

#. type: table
#: original_texis/debugging.texi:616
msgid "The @kbd{r} command is useful when the debugger was invoked due to exit from a Lisp call frame (as requested with @kbd{b} or by entering the frame with @kbd{d}); then the value specified in the @kbd{r} command is used as the value of that frame.  It is also useful if you call @code{debug} and use its return value.  Otherwise, @kbd{r} has the same effect as @kbd{c}, and the specified return value does not matter."
msgstr "@kbd{d}コマンドは、(@kbd{b}によるリクエストや@kbd{d}によるそのフレームへのエンターによる)Lisp呼び出しフレームからのexitでデバッガが呼び出されたときに有用である。@kbd{r}コマンドで指定された値は、そのフレームの値として使用される。これは@code{debug}を呼び出して、そのリターン値を使用するときにも有用。それ以外は@kbd{r}は@kbd{c}と同じ効果をもち、指定されたリターン値は問題とはならない。"

#. type: table
#: original_texis/debugging.texi:618
msgid "You can't use @kbd{r} when the debugger was entered due to an error."
msgstr "エラーによりデバッガにエンターしたときは@kbd{r}コマンドは使用できない。"

#. type: item
#: original_texis/debugging.texi:619
#, no-wrap
msgid "l"
msgstr "l"

#. type: table
#: original_texis/debugging.texi:623
msgid "Display a list of functions that will invoke the debugger when called.  This is a list of functions that are set to break on entry by means of @code{debug-on-entry}."
msgstr "呼び出されたときにデバッガを呼び出す関数をリストする。これは@code{debug-on-entry}によりエントリー時にbreakするようセットされた関数のリストである。"

#. type: cindex
#: original_texis/debugging.texi:628
#, no-wrap
msgid "invoking lisp debugger"
msgstr "invoking lisp debugger"

#. type: Plain text
#: original_texis/debugging.texi:632
msgid "Here we describe in full detail the function @code{debug} that is used to invoke the debugger."
msgstr "以下ではデバッガを呼び出すために使用される関数@code{debug}の完全な詳細を説明します。"

#. type: deffn
#: original_texis/debugging.texi:633
#, no-wrap
msgid "Command debug &rest debugger-args"
msgstr "Command debug &rest debugger-args"

#. type: deffn
#: original_texis/debugging.texi:646
msgid "This function enters the debugger.  In interactive sessions, it switches to a buffer named @file{*Backtrace*} (or @file{*Backtrace*<2>} if it is the second recursive entry to the debugger, etc.), and fills it with information about the stack of Lisp function calls.  It then enters a recursive edit, showing the backtrace buffer in Debugger mode.  In batch mode (more generally, when @code{noninteractive} is non-@code{nil}, @pxref{Batch Mode}), this function shows the Lisp backtrace on the standard error stream, and then kills Emacs, causing it to exit with a non-zero exit code (@pxref{Killing Emacs}).  Binding @code{backtrace-on-error-noninteractive} to @code{nil} suppresses the backtrace in batch mode, see below."
msgstr "この関数はデバッガにエンターする。インタラクティブなセッションではこの関数は@file{*Backtrace*}(デバッガへの2回目以降の再帰エントリーでは@file{*Backtrace*<2>、...})という名前のバッファーにバッファーを切り替えて、Lisp関数呼び出しについての情報を書き込む。それから再帰編集にエンターして、Debuggerモードでbacktraceバッファーを表示する。バッチモード(より一般的には@code{noninteractive}が非@code{nil}の場合; @ref{Batch Mode}を参照)、この関数は標準エラーストリームにLispのバックトレースを表示した後に非0のexitコードでEmacsをkillする(@ref{Killing Emacs}を参照)。バッチモードでバックトレースを抑止するには@code{backtrace-on-error-noninteractive}に@code{nil}をバインドすればよい。以下を参照のこと。"

#. type: deffn
#: original_texis/debugging.texi:651
msgid "The Debugger mode @kbd{c}, @kbd{d}, @kbd{j}, and @kbd{r} commands exit the recursive edit; then @code{debug} switches back to the previous buffer and returns to whatever called @code{debug}.  This is the only way the function @code{debug} can return to its caller."
msgstr "Debuggerモードのコマンド@kbd{c}、@kbd{d}、@kbd{j}、@kbd{r}は再帰編集をexitする。その後、@code{debug}は以前のバッファーに戻って、@code{debug}を呼び出したものが何であれそこにリターンする。これは関数@code{debug}が呼び出し元にリターンできる唯一の方法である。"

#. type: deffn
#: original_texis/debugging.texi:656
msgid "The use of the @var{debugger-args} is that @code{debug} displays the rest of its arguments at the top of the @file{*Backtrace*} buffer, so that the user can see them.  Except as described below, this is the @emph{only} way these arguments are used."
msgstr "@var{debugger-args}を使用すると、@code{debug}は@file{*Backtrace*}の最上部に残りの引数を表示するしてユーザーがそれらを確認できる。以下で説明する場合を除いて、これはこれらの引数を使用する@emph{唯一}の方法である。"

#. type: deffn
#: original_texis/debugging.texi:661
msgid "However, certain values for first argument to @code{debug} have a special significance.  (Normally, these values are used only by the internals of Emacs, and not by programmers calling @code{debug}.)  Here is a table of these special values:"
msgstr "しかし@code{debug}への1つ目の引数にたいする値は、特別な意味をもつ(これらの値は通常は@code{debug}を呼び出すプログラマーではなく、Emacs内部でのみ使用される)。以下はこれら特別な値のテーブルである:"

#. type: item
#: original_texis/debugging.texi:663
#, no-wrap
msgid "lambda"
msgstr "lambda"

#. type: cindex
#: original_texis/debugging.texi:664
#, no-wrap
msgid "@code{lambda} in debug"
msgstr "@code{lambda} in debug"

#. type: table
#: original_texis/debugging.texi:670
msgid "A first argument of @code{lambda} means @code{debug} was called because of entry to a function when @code{debug-on-next-call} was non-@code{nil}.  The debugger displays @samp{Debugger entered--entering a function:} as a line of text at the top of the buffer."
msgstr "1つ目の引数が@code{lambda}のなら、それは@code{debug-on-next-call}が非@code{nil}のときに関数にエントリーしたことによって@code{debug}が呼び出されたことを意味する。デバッガはバッファーのトップのテキスト行に@samp{Debugger entered--entering a function:}と表示する。"

#. type: item
#: original_texis/debugging.texi:671
#, no-wrap
msgid "debug"
msgstr "debug"

#. type: table
#: original_texis/debugging.texi:677
msgid "@code{debug} as first argument means @code{debug} was called because of entry to a function that was set to debug on entry.  The debugger displays the string @samp{Debugger entered--entering a function:}, just as in the @code{lambda} case.  It also marks the stack frame for that function so that it will invoke the debugger when exited."
msgstr "1つ目の引数が@code{debug}なら、それはエントリー時にデバッグされるようにセットされた関数にエントリーしたことにって@code{debug}が呼び出されたことを意味する。デバッガは@code{lambda}のときと同様、@samp{Debugger entered--entering a function:}を表示する。これはその関数のスタックフレームもマークするので、exit時にデバッガが呼び出される。"

#. type: item
#: original_texis/debugging.texi:678
#, no-wrap
msgid "t"
msgstr "t"

#. type: table
#: original_texis/debugging.texi:684
msgid "When the first argument is @code{t}, this indicates a call to @code{debug} due to evaluation of a function call form when @code{debug-on-next-call} is non-@code{nil}.  The debugger displays @samp{Debugger entered--beginning evaluation of function call form:} as the top line in the buffer."
msgstr "1つ目の引数が@code{t}なら、それは@code{debug-on-next-call}が非@code{nil}のときに関数呼び出しの評価によって@code{debug}が呼び出されたことを示す。デバッガはバッファーのトップの行に@samp{Debugger entered--beginning evaluation of function call form:}と表示する。"

#. type: item
#: original_texis/debugging.texi:685
#, no-wrap
msgid "exit"
msgstr "exit"

#. type: table
#: original_texis/debugging.texi:692
msgid "When the first argument is @code{exit}, it indicates the exit of a stack frame previously marked to invoke the debugger on exit.  The second argument given to @code{debug} in this case is the value being returned from the frame.  The debugger displays @samp{Debugger entered--returning value:} in the top line of the buffer, followed by the value being returned."
msgstr "1つ目の引数が@code{exit}のときは、exit時にデバッガを呼び出すよう以前にマークされたスタックフレームをexitしたことを示す。この場合は@code{debug}に与えられた2つ目の引数がそのフレームからリターンされた値になる。デバッガはバッファーのトップの行に@samp{Debugger entered--returning value:}とリターンされた値を表示する。"

#. type: item
#: original_texis/debugging.texi:693
#, no-wrap
msgid "error"
msgstr "error"

#. type: cindex
#: original_texis/debugging.texi:694
#, no-wrap
msgid "@code{error} in debug"
msgstr "@code{error} in debug"

#. type: table
#: original_texis/debugging.texi:700
msgid "When the first argument is @code{error}, the debugger indicates that it is being entered because an error or @code{quit} was signaled and not handled, by displaying @samp{Debugger entered--Lisp error:} followed by the error signaled and any arguments to @code{signal}.  For example,"
msgstr "1つ目の引数が@code{error}のときは、ハンドルされていないエラーまたは@code{quit}がシグナルされてデバッガにエンターした場合であり、デバッガは@samp{Debugger entered--Lisp error:}とその後にシグナルされたエラーと@code{signal}への引数を表示してそれを示す。たとえば、"

#. type: group
#: original_texis/debugging.texi:705
#, no-wrap
msgid ""
"(let ((debug-on-error t))\n"
"  (/ 1 0))\n"
msgstr ""
"(let ((debug-on-error t))\n"
"  (/ 1 0))\n"

#. type: group
#: original_texis/debugging.texi:713
#, no-wrap
msgid ""
"------ Buffer: *Backtrace* ------\n"
"Debugger entered--Lisp error: (arith-error)\n"
"  /(1 0)\n"
"...\n"
"------ Buffer: *Backtrace* ------\n"
msgstr ""
"------ Buffer: *Backtrace* ------\n"
"Debugger entered--Lisp error: (arith-error)\n"
"  /(1 0)\n"
"...\n"
"------ Buffer: *Backtrace* ------\n"

#. type: table
#: original_texis/debugging.texi:719
msgid "If an error was signaled, presumably the variable @code{debug-on-error} is non-@code{nil}.  If @code{quit} was signaled, then presumably the variable @code{debug-on-quit} is non-@code{nil}."
msgstr "エラーがシグナルされた場合はおそらく変数@code{debug-on-error}は非@code{nil}で、@code{quit}がシグナルされた場合はおそらく変数@code{debug-on-quit}は非@code{nil}である。"

#. type: item
#: original_texis/debugging.texi:720
#, no-wrap
msgid "nil"
msgstr "nil"

#. type: table
#: original_texis/debugging.texi:726
msgid "Use @code{nil} as the first of the @var{debugger-args} when you want to enter the debugger explicitly.  The rest of the @var{debugger-args} are printed on the top line of the buffer.  You can use this feature to display messages---for example, to remind yourself of the conditions under which @code{debug} is called."
msgstr "明示的にデバッガにエンターしたいときは、@var{debugger-args}の1つ目の引数に@code{nil}を使用する。残りの@var{debugger-args}はバッファーのトップの行にプリントされる。メッセージ --- たとえば@code{debug}が呼び出された条件を思い出すためのリマインダーとして --- の表示にこの機能を使用できる。"

#. type: defvar
#: original_texis/debugging.texi:729
#, no-wrap
msgid "backtrace-on-error-noninteractive"
msgstr "backtrace-on-error-noninteractive"

#. type: defvar
#: original_texis/debugging.texi:734
msgid "If this variable is non-@code{nil}, the default, entering the debugger in batch mode shows the backtrace of Lisp functions calls.  Binding the variable to the @code{nil} value suppresses the backtrace and shows only the error message."
msgstr "この変数が非@code{nil} (デフォルト)の場合には、バッチモードでデバッガにエンターするとLisp関数呼び出しのバックトレースを表示する。この変数の値を@code{nil}にバインドすることによってバックトレースの表示は抑制されてエラーメッセージだけが表示されるようになる。"

#. type: subsection
#: original_texis/debugging.texi:737
#, no-wrap
msgid "Internals of the Debugger"
msgstr "Internals of the Debugger"

#. type: Plain text
#: original_texis/debugging.texi:741
msgid "This section describes functions and variables used internally by the debugger."
msgstr "このセクションではデバッガ内部で使用される関数と変数について説明します。"

#. type: defvar
#: original_texis/debugging.texi:742
#, no-wrap
msgid "debugger"
msgstr "debugger"

#. type: defvar
#: original_texis/debugging.texi:748
msgid "The value of this variable is the function to call to invoke the debugger.  Its value must be a function of any number of arguments, or, more typically, the name of a function.  This function should invoke some kind of debugger.  The default value of the variable is @code{debug}."
msgstr "この関数の値はデバッガを呼び出す関数呼び出しである。値には任意個数の引数をとる関数、より具体的には関数の名前でなければならない。この関数は何らかのデバッガを呼び出すこと。この変数のデフォルト値は@code{debug}。"

#. type: defvar
#: original_texis/debugging.texi:752
msgid "The first argument that Lisp hands to the function indicates why it was called.  The convention for arguments is detailed in the description of @code{debug} (@pxref{Invoking the Debugger})."
msgstr "関数にたいしてLispが渡す1つ目の引数は、その関数がなぜ呼び出されたかを示す。引数の慣習については@code{debug}(@ref{Invoking the Debugger})に詳解がある。"

#. type: defun
#: original_texis/debugging.texi:754
#, no-wrap
msgid "backtrace"
msgstr "backtrace"

#. type: cindex
#: original_texis/debugging.texi:755
#, no-wrap
msgid "run time stack"
msgstr "run time stack"

#. type: cindex
#: original_texis/debugging.texi:756
#, no-wrap
msgid "call stack"
msgstr "call stack"

#. type: defun
#: original_texis/debugging.texi:760
msgid "This function prints a trace of Lisp function calls currently active.  The trace is identical to the one that @code{debug} would show in the @file{*Backtrace*} buffer.  The return value is always @code{nil}."
msgstr "この関数は現在アクティブなLisp関数呼び出しのトレースをプリントする。このトレースは@code{debug}が@file{*Backtrace*}バッファーで表示するものと等しい。リターン値は常に@code{nil}。"

#. type: defun
#: original_texis/debugging.texi:765
msgid "In the following example, a Lisp expression calls @code{backtrace} explicitly.  This prints the backtrace to the stream @code{standard-output}, which, in this case, is the buffer @samp{backtrace-output}."
msgstr "以下の例ではLisp式で明示的に@code{backtrace}を呼び出している。これはストリーム@code{standard-output}(この場合はバッファー@samp{backtrace-output})にbacktraceをプリントする。"

#. type: defun
#: original_texis/debugging.texi:771
msgid "Each line of the backtrace represents one function call.  The line shows the function followed by a list of the values of the function's arguments if they are all known; if they are still being computed, the line consists of a list containing the function and its unevaluated arguments.  Long lists or deeply nested structures may be elided."
msgstr "backtraceの各行は1つの関数呼び出しを表す。関数の引数が既知なら行に関数とその後に値が表示される。まだ計算中なら関数と未評価の引数を含むリストから行が構成される。長いリストや深くネストされた構造は省略されるかもしれない。"

#. type: group
#: original_texis/debugging.texi:780
#, no-wrap
msgid ""
"(with-output-to-temp-buffer \"backtrace-output\"\n"
"  (let ((var 1))\n"
"    (save-excursion\n"
"      (setq var (eval '(progn\n"
"                         (1+ var)\n"
"                         (list 'testing (backtrace))))))))\n"
"\n"
msgstr ""
"(with-output-to-temp-buffer \"backtrace-output\"\n"
"  (let ((var 1))\n"
"    (save-excursion\n"
"      (setq var (eval '(progn\n"
"                         (1+ var)\n"
"                         (list 'testing (backtrace))))))))\n"
"\n"

#. type: group
#: original_texis/debugging.texi:782
#, no-wrap
msgid "     @result{} (testing nil)\n"
msgstr "     @result{} (testing nil)\n"

#. type: group
#: original_texis/debugging.texi:788
#, no-wrap
msgid ""
"----------- Buffer: backtrace-output ------------\n"
"  backtrace()\n"
"  (list 'testing (backtrace))\n"
msgstr ""
"----------- Buffer: backtrace-output ------------\n"
"  backtrace()\n"
"  (list 'testing (backtrace))\n"

#. type: smallexample
#: original_texis/debugging.texi:797
#, no-wrap
msgid ""
"  (progn ...)\n"
"  eval((progn (1+ var) (list 'testing (backtrace))))\n"
"  (setq ...)\n"
"  (save-excursion ...)\n"
"  (let ...)\n"
"  (with-output-to-temp-buffer ...)\n"
"  eval((with-output-to-temp-buffer ...))\n"
"  eval-last-sexp-1(nil)\n"
msgstr ""
"  (progn ...)\n"
"  eval((progn (1+ var) (list 'testing (backtrace))))\n"
"  (setq ...)\n"
"  (save-excursion ...)\n"
"  (let ...)\n"
"  (with-output-to-temp-buffer ...)\n"
"  eval((with-output-to-temp-buffer ...))\n"
"  eval-last-sexp-1(nil)\n"

#. type: group
#: original_texis/debugging.texi:801
#, no-wrap
msgid ""
"  eval-last-sexp(nil)\n"
"  call-interactively(eval-last-sexp)\n"
"----------- Buffer: backtrace-output ------------\n"
msgstr ""
"  eval-last-sexp(nil)\n"
"  call-interactively(eval-last-sexp)\n"
"----------- Buffer: backtrace-output ------------\n"

#. type: defopt
#: original_texis/debugging.texi:805
#, no-wrap
msgid "debugger-stack-frame-as-list"
msgstr "debugger-stack-frame-as-list"

#. type: defopt
#: original_texis/debugging.texi:810
msgid "If this variable is non-@code{nil}, every stack frame of the backtrace is displayed as a list.  This aims at improving the backtrace readability at the cost of special forms no longer being visually different from regular function calls."
msgstr "この変数が非@code{nil}ならバックトレースのすべてのスタックフレームはリストとして表示される。これは通常の関数呼び出しとバックトレースの特殊形式の視覚的な違いによるコストをなくして、バックトレースの可読性を向上することが目的。"

#. type: defopt
#: original_texis/debugging.texi:813
msgid "With @code{debugger-stack-frame-as-list} non-@code{nil}, the above example would look as follows:"
msgstr "@code{debugger-stack-frame-as-list}が非@code{nil}なら上記の例は以下のようになる:"

#. type: group
#: original_texis/debugging.texi:819
#, no-wrap
msgid ""
"----------- Buffer: backtrace-output ------------\n"
"  (backtrace)\n"
"  (list 'testing (backtrace))\n"
msgstr ""
"----------- Buffer: backtrace-output ------------\n"
"  (backtrace)\n"
"  (list 'testing (backtrace))\n"

#. type: smallexample
#: original_texis/debugging.texi:828
#, no-wrap
msgid ""
"  (progn ...)\n"
"  (eval (progn (1+ var) (list 'testing (backtrace))))\n"
"  (setq ...)\n"
"  (save-excursion ...)\n"
"  (let ...)\n"
"  (with-output-to-temp-buffer ...)\n"
"  (eval (with-output-to-temp-buffer ...))\n"
"  (eval-last-sexp-1 nil)\n"
msgstr ""
"  (progn ...)\n"
"  (eval (progn (1+ var) (list 'testing (backtrace))))\n"
"  (setq ...)\n"
"  (save-excursion ...)\n"
"  (let ...)\n"
"  (with-output-to-temp-buffer ...)\n"
"  (eval (with-output-to-temp-buffer ...))\n"
"  (eval-last-sexp-1 nil)\n"

#. type: group
#: original_texis/debugging.texi:832
#, no-wrap
msgid ""
"  (eval-last-sexp nil)\n"
"  (call-interactively eval-last-sexp)\n"
"----------- Buffer: backtrace-output ------------\n"
msgstr ""
"  (eval-last-sexp nil)\n"
"  (call-interactively eval-last-sexp)\n"
"----------- Buffer: backtrace-output ------------\n"

#. type: defvar
#: original_texis/debugging.texi:836
#, no-wrap
msgid "debug-on-next-call"
msgstr "debug-on-next-call"

#. type: cindex
#: original_texis/debugging.texi:837
#, no-wrap
msgid "@code{eval}, and debugging"
msgstr "@code{eval}, and debugging"

#. type: cindex
#: original_texis/debugging.texi:838
#, no-wrap
msgid "@code{apply}, and debugging"
msgstr "@code{apply}, and debugging"

#. type: cindex
#: original_texis/debugging.texi:839
#, no-wrap
msgid "@code{funcall}, and debugging"
msgstr "@code{funcall}, and debugging"

#. type: defvar
#: original_texis/debugging.texi:843
msgid "If this variable is non-@code{nil}, it says to call the debugger before the next @code{eval}, @code{apply} or @code{funcall}.  Entering the debugger sets @code{debug-on-next-call} to @code{nil}."
msgstr "この変数が非@code{nil}なら、それは次の@code{eval}、@code{apply}、@code{funcall}の前にデバッガを呼び出すよう指定する。デバッガへのエンターによって@code{debug-on-next-call}は@code{nil}にセットされる。"

#. type: defvar
#: original_texis/debugging.texi:845
msgid "The @kbd{d} command in the debugger works by setting this variable."
msgstr "デバッガの@kbd{d}コマンドは、この変数をセットすることにより機能します。"

#. type: defun
#: original_texis/debugging.texi:847
#, no-wrap
msgid "backtrace-debug level flag"
msgstr "backtrace-debug level flag"

#. type: defun
#: original_texis/debugging.texi:853
msgid "This function sets the debug-on-exit flag of the stack frame @var{level} levels down the stack, giving it the value @var{flag}.  If @var{flag} is non-@code{nil}, this will cause the debugger to be entered when that frame later exits.  Even a nonlocal exit through that frame will enter the debugger."
msgstr "この関数はそのスタックフレームの@var{level}下位のスタックフレームのdebug-on-exitフラグに@var{flag}に応じた値をセットする。@var{flag}が非@code{nil}なら、後でそのフレームをexitするときデバッガにエンターする。そのフレームを通じた非ローカルexitでも、デバッガにエンターする。"

#. type: defun
#: original_texis/debugging.texi:855
msgid "This function is used only by the debugger."
msgstr "この関数はデバッガだけに使用される。"

#. type: defvar
#: original_texis/debugging.texi:857
#, no-wrap
msgid "command-debug-status"
msgstr "command-debug-status"

#. type: defvar
#: original_texis/debugging.texi:863
msgid "This variable records the debugging status of the current interactive command.  Each time a command is called interactively, this variable is bound to @code{nil}.  The debugger can set this variable to leave information for future debugger invocations during the same command invocation."
msgstr "この変数はカレントのインタラクティブコマンドのデバッグ状態を記録する。コマンドがインタラクティブに呼び出されるたびに、この変数は@code{nil}にバインドされる。デバッガは同じコマンドが呼び出されたときのデバッガ呼び出しに情報を残すために、この変数をセットできる。"

#. type: defvar
#: original_texis/debugging.texi:867
msgid "The advantage of using this variable rather than an ordinary global variable is that the data will never carry over to a subsequent command invocation."
msgstr "普通のグローバル変数ではなくこの変数を使用する利点は、そのデータが後続のコマンド呼び出しに決して引き継がれないことである。"

#. type: defvar
#: original_texis/debugging.texi:869
msgid "This variable is obsolete and will be removed in future versions."
msgstr "この変数は時代遅れであり将来のバージョンで削除されるだろう。"

#. type: defun
#: original_texis/debugging.texi:871
#, no-wrap
msgid "backtrace-frame frame-number &optional base"
msgstr "backtrace-frame frame-number &optional base"

#. type: defun
#: original_texis/debugging.texi:875
msgid "The function @code{backtrace-frame} is intended for use in Lisp debuggers.  It returns information about what computation is happening in the stack frame @var{frame-number} levels down."
msgstr "関数@code{backtrace-frame}はLispデバッガ内での使用を意図している。これは@var{frame-number}レベル下位のスタックフレームで何の評価が行われているかに関する情報をリターンする。"

#. type: defun
#: original_texis/debugging.texi:878
msgid "If that frame has not evaluated the arguments yet, or is a special form, the value is @code{(nil @var{function} @var{arg-forms}@dots{})}."
msgstr "そのフレームがまだ引数を評価していない、またはそのフレームがスペシャルフォームなら値は@code{(nil @var{function} @var{arg-forms}@dots{})}。"

#. type: defun
#: original_texis/debugging.texi:882
msgid "If that frame has evaluated its arguments and called its function already, the return value is @code{(t @var{function} @var{arg-values}@dots{})}."
msgstr "そのフレームが引数を評価して関数をすでに呼び出していたらリターン値は@code{(t @var{function} @var{arg-values}@dots{})}。"

#. type: defun
#: original_texis/debugging.texi:887
msgid "In the return value, @var{function} is whatever was supplied as the @sc{car} of the evaluated list, or a @code{lambda} expression in the case of a macro call.  If the function has a @code{&rest} argument, that is represented as the tail of the list @var{arg-values}."
msgstr "リターン値の@var{function}は何であれ評価されたリストの@sc{car}として提供される。マクロ呼び出しなら@code{lambda}式。その関数に@code{&rest}引数があればリスト@var{arg-values}の末尾に示される。"

#. type: defun
#: original_texis/debugging.texi:890
msgid "If @var{base} is specified, @var{frame-number} counts relative to the topmost frame whose @var{function} is @var{base}."
msgstr "@var{base}を指定すると@var{frame-number}は@var{function}が@var{base}であるようなフレームの上端から相対的に数えられる。"

#. type: defun
#: original_texis/debugging.texi:893
msgid "If @var{frame-number} is out of range, @code{backtrace-frame} returns @code{nil}."
msgstr "@var{frame-number}が範囲外なら@code{backtrace-frame}は@code{nil}をリターンする。"

#. type: defun
#: original_texis/debugging.texi:895
#, no-wrap
msgid "mapbacktrace function &optional base"
msgstr "mapbacktrace function &optional base"

#. type: defun
#: original_texis/debugging.texi:899
msgid "The function @code{mapbacktrace} calls @var{function} once for each frame in the backtrace, starting at the first frame whose function is @var{base} (or from the top if @var{base} is omitted or @code{nil})."
msgstr "関数@code{mapbacktrace}はバックトレース上の関数が@var{base}であるようなフレーム(@var{base}が省略か@code{nil}なら先頭)から順に各フレームにたいして一度@var{function}を呼び出す。"

#. type: defun
#: original_texis/debugging.texi:902
msgid "@var{function} is called with four arguments: @var{evald}, @var{func}, @var{args}, and @var{flags}."
msgstr "@var{function}は@var{evald}、@var{func}、@var{args}、@var{flags}という4つの引数で呼び出される。"

#. type: defun
#: original_texis/debugging.texi:905
msgid "If a frame has not evaluated its arguments yet or is a special form, @var{evald} is @code{nil} and @var{args} is a list of forms."
msgstr "そのフレームがまだ引数を評価していない、またはそのフレームがスペシャルフォームなら@var{evald}は@code{nil}、@var{args}はフォームのリスト。"

#. type: defun
#: original_texis/debugging.texi:911
msgid "If a frame has evaluated its arguments and called its function already, @var{evald} is @code{t} and @var{args} is a list of values.  @var{flags} is a plist of properties of the current frame: currently, the only supported property is @code{:debug-on-exit}, which is @code{t} if the stack frame's @code{debug-on-exit} flag is set."
msgstr "フレームが引数を評価して関数を呼び出し済みなら@var{evald}は@code{t}、@var{args}は値リスト。@var{flags}はカレントフレームのプロパティのplist。サポートされるプロパティは現在のところ@code{:debug-on-exit}のみであり、そのスタックフレームの@code{debug-on-exit}フラグがセットされていれば@code{t}。"

#. type: include
#: original_texis/debugging.texi:913
#, no-wrap
msgid "edebug.texi"
msgstr "edebug-ja.texi"

#. type: section
#: original_texis/debugging.texi:916
#, no-wrap
msgid "Debugging Invalid Lisp Syntax"
msgstr "Debugging Invalid Lisp Syntax"

#. type: cindex
#: original_texis/debugging.texi:917
#, no-wrap
msgid "debugging invalid Lisp syntax"
msgstr "debugging invalid Lisp syntax"

#. type: Plain text
#: original_texis/debugging.texi:927
msgid "The Lisp reader reports invalid syntax, but cannot say where the real problem is.  For example, the error @samp{End of file during parsing} in evaluating an expression indicates an excess of open parentheses (or square brackets).  The reader detects this imbalance at the end of the file, but it cannot figure out where the close parenthesis should have been.  Likewise, @samp{Invalid read syntax: \")\"} indicates an excess close parenthesis or missing open parenthesis, but does not say where the missing parenthesis belongs.  How, then, to find what to change?"
msgstr "Lispリーダーは無効な構文(invalid syntax)について報告はしますが実際の問題箇所は報告しません。たとえばある式を評価中のエラー@samp{End of file during parsing}は、開カッコまたは開角カッコ(open parenthese or open square bracket)が多いことを示しています。Lispリーダーはこの不一致をファイル終端で検出しましたが、本来閉カッコがあるべき箇所を解決することはできません。同様に@samp{Invalid read syntax: \")\"}は開カッコの欠落を示していますが、欠落しているカッコが属すべき場所は告げません。ならばどうやって変更すべき箇所を探せばよいのでしょうか?"

#. type: Plain text
#: original_texis/debugging.texi:933
msgid "If the problem is not simply an imbalance of parentheses, a useful technique is to try @kbd{C-M-e} (@code{end-of-defun}, @pxref{Moving by Defuns,,,emacs, The GNU Emacs Manual}) at the beginning of each defun, and see if it goes to the place where that defun appears to end.  If it does not, there is a problem in that defun."
msgstr "問題が単なるカッコの不一致でない場合の便利なテクニックは、各defunの先頭で@kbd{C-M-e} ( @code{end-of-defun}。@ref{Moving by Defuns,,,emacs, The GNU Emacs Manual}を参照)とタイプして、そのdefunの最後と思われる箇所に移動するか確認する方法です。もし移動しなければ、問題はそのdefunの内部にあります。"

#. type: cindex
#: original_texis/debugging.texi:934
#, no-wrap
msgid "unbalanced parentheses"
msgstr "unbalanced parentheses"

#. type: cindex
#: original_texis/debugging.texi:935
#, no-wrap
msgid "parenthesis mismatch, debugging"
msgstr "parenthesis mismatch, debugging"

#. type: Plain text
#: original_texis/debugging.texi:940
msgid "However, unmatched parentheses are the most common syntax errors in Lisp, and we can give further advice for those cases.  (In addition, just moving point through the code with Show Paren mode enabled might find the mismatch.)"
msgstr "マッチしないカッコがLispにおいてもっとも一般的な構文エラーなので、これらのケースにたいしてさらにアドバイスすることができます(Show Parenモードを有効にしてコードにポイントを移動するだけでカッコの不一致を探しやすくなるだろう)。"

#. type: node
#: original_texis/debugging.texi:944 original_texis/debugging.texi:946
#, no-wrap
msgid "Excess Open"
msgstr "Excess Open"

#. type: menuentry
#: original_texis/debugging.texi:944
msgid "How to find a spurious open paren or missing close."
msgstr "誤った開カッコと閉カッコの欠落を探す方法。"

#. type: node
#: original_texis/debugging.texi:944 original_texis/debugging.texi:984
#, no-wrap
msgid "Excess Close"
msgstr "Excess Close"

#. type: menuentry
#: original_texis/debugging.texi:944
msgid "How to find a spurious close paren or missing open."
msgstr "誤った閉カッコと開カッコの欠落を探す方法。"

#. type: subsection
#: original_texis/debugging.texi:947
#, no-wrap
msgid "Excess Open Parentheses"
msgstr "Excess Open Parentheses"

#. type: cindex
#: original_texis/debugging.texi:948
#, no-wrap
msgid "excess open parentheses"
msgstr "excess open parentheses"

#. type: Plain text
#: original_texis/debugging.texi:955
msgid "The first step is to find the defun that is unbalanced.  If there is an excess open parenthesis, the way to do this is to go to the end of the file and type @kbd{C-u C-M-u} (@code{backward-up-list}, @pxref{Moving by Parens,,,emacs, The GNU Emacs Manual}).  This will move you to the beginning of the first defun that is unbalanced."
msgstr "カッコがマッチしないdefunを探すのが、最初のステップです。過剰な開カッコが存在する場合は、ファイルの終端に移動して@kbd{C-u C-M-u} ( @code{backward-up-list}。@ref{Moving by Parens,,,emacs, The GNU Emacs Manual}を参照)とタイプします。これにより、カッコがマッチしない最初のdefunの先頭に移動するでしょう。"

#. type: Plain text
#: original_texis/debugging.texi:963
msgid "The next step is to determine precisely what is wrong.  There is no way to be sure of this except by studying the program, but often the existing indentation is a clue to where the parentheses should have been.  The easiest way to use this clue is to reindent with @kbd{C-M-q} (@code{indent-pp-sexp}, @pxref{Multi-line Indent,,,emacs, The GNU Emacs Manual}) and see what moves.  @strong{But don't do this yet!} Keep reading, first."
msgstr "何が間違っているのか正確に判断するのが次のステップです。これを確実に行なうにはプログラムを詳しく調べる以外に方法はありませんが、カッコがあるべき箇所を探すのに既存のインデントが手掛かりになることが多々あります。@kbd{C-M-q} (@code{indent-pp-sexp}。@ref{Multi-line Indent,,,emacs, The GNU Emacs Manual}を参照)で再インデントして何が移動されるか確認するのが、この手掛かりを使用するもっとも簡単な方法です。@strong{しかし、行うのはちょっと待ってください!} まず続きを読んでからにしましょう。"

#. type: Plain text
#: original_texis/debugging.texi:969
msgid "Before you do this, make sure the defun has enough close parentheses.  Otherwise, @kbd{C-M-q} will get an error, or will reindent all the rest of the file until the end.  So move to the end of the defun and insert a close parenthesis there.  Don't use @kbd{C-M-e} (@code{end-of-defun}) to move there, since that too will fail to work until the defun is balanced."
msgstr "これを行なう前にdefunに十分な閉カッコがあるか確認します。十分な閉カッコがなければ @kbd{C-M-q}がエラーとなるか、そのdefunからファイル終端までの残りすべてが再インデントされます。その場合にはdefunの最後に移動して、そこに閉カッコを挿入します。そのdefunのカッコの釣り合いがとれるまでは、defunの最後に移動するのに@kbd{C-M-e} (@code{end-of-defun})は使用できません(失敗する)。"

#. type: Plain text
#: original_texis/debugging.texi:978
msgid "Now you can go to the beginning of the defun and type @kbd{C-M-q}.  Usually all the lines from a certain point to the end of the function will shift to the right.  There is probably a missing close parenthesis, or a superfluous open parenthesis, near that point.  (However, don't assume this is true; study the code to make sure.)  Once you have found the discrepancy, undo the @kbd{C-M-q} with @kbd{C-_} (@code{undo}), since the old indentation is probably appropriate to the intended parentheses."
msgstr "これでdefunの先頭に移動して@kbd{C-M-q}とタイプすることができます。通常は一定のポイントからその関数の最後までのすべての行が、右へとシフトされるでしょう。これはおそらくそのポイント付近で閉カッコが欠落していたり不要な開カッコがあります(しかしこれを真実と仮定せずコードを詳しく調べること)。不一致箇所を見つけたら、元のインデントはおそらく意図されたカッコに適しているはずなので、@kbd{C-_} (@code{undo})で@kbd{C-M-q}をアンドゥしてください。"

#. type: Plain text
#: original_texis/debugging.texi:983
msgid "After you think you have fixed the problem, use @kbd{C-M-q} again.  If the old indentation actually fit the intended nesting of parentheses, and you have put back those parentheses, @kbd{C-M-q} should not change anything."
msgstr "問題をfixできたと思った後に、再度@kbd{C-M-q}を使用します。実際に元のインデントが意図したカッコのネストに適合していて、足りないカッコを追加していたら、@kbd{C-M-q}は何も変更しないはずです。"

#. type: subsection
#: original_texis/debugging.texi:985
#, no-wrap
msgid "Excess Close Parentheses"
msgstr "Excess Close Parentheses"

#. type: cindex
#: original_texis/debugging.texi:986
#, no-wrap
msgid "excess close parentheses"
msgstr "excess close parentheses"

#. type: Plain text
#: original_texis/debugging.texi:992
msgid "To deal with an excess close parenthesis, first go to the beginning of the file, then type @kbd{C-u -1 C-M-u} (@code{backward-up-list} with an argument of @minus{}1) to find the end of the first unbalanced defun."
msgstr "過剰な閉カッコへの対処は、まずファイルの先頭に移動してからカッコのマッチしないdefunを探すために@kbd{C-u -1 C-M-u} (引数@minus{}1で@code{backward-up-list})をタイプします。"

#. type: Plain text
#: original_texis/debugging.texi:998
msgid "Then find the actual matching close parenthesis by typing @kbd{C-M-f} (@code{forward-sexp}, @pxref{Expressions,,,emacs, The GNU Emacs Manual})  at the beginning of that defun.  This will leave you somewhere short of the place where the defun ought to end.  It is possible that you will find a spurious close parenthesis in that vicinity."
msgstr "それからdefunの先頭で@kbd{C-M-f} (@code{forward-sexp}。@ref{Expressions,,,emacs, The GNU Emacs Manual}を参照)をタイプして、実際にマッチする閉カッコを探します。これによりdefunの終端より幾分手前の箇所に移動するでしょう。その付近に間違った閉カッコが見つかるはずです。"

#. type: Plain text
#: original_texis/debugging.texi:1007
msgid "If you don't see a problem at that point, the next thing to do is to type @kbd{C-M-q} (@code{indent-pp-sexp}) at the beginning of the defun.  A range of lines will probably shift left; if so, the missing open parenthesis or spurious close parenthesis is probably near the first of those lines.  (However, don't assume this is true; study the code to make sure.)  Once you have found the discrepancy, undo the @kbd{C-M-q} with @kbd{C-_} (@code{undo}), since the old indentation is probably appropriate to the intended parentheses."
msgstr "そのポイントに問題が見つからない場合には、そのdefunの先頭で@kbd{C-M-q} (@code{indent-pp-sexp})をタイプするのが次のステップです。ある行範囲はおそらく左へシフトするでしょう。その場合には欠落している開カッコや間違った閉カッコは、おそらくそれらの行の1行目の近くにあるでしょう(しかしこれを真実と仮定せずコードを詳しく調べること)。不一致箇所が見つけたら、元のインデントはおそらく意図されたカッコに適しているはずなので@kbd{C-_} (@code{undo})で@kbd{C-M-q}をアンドゥしてください。"

#. type: Plain text
#: original_texis/debugging.texi:1012
msgid "After you think you have fixed the problem, use @kbd{C-M-q} again.  If the old indentation actually fits the intended nesting of parentheses, and you have put back those parentheses, @kbd{C-M-q} should not change anything."
msgstr "問題をfixできたと思った後に再度@kbd{C-M-q}を使用します。実際に元のインデントが意図したカッコのネストに適合していて、足りないカッコを追加していたら、@kbd{C-M-q}は何も変更しないはずです。"

#. type: cindex
#: original_texis/debugging.texi:1015
#, no-wrap
msgid "coverage testing"
msgstr "coverage testing"

#. type: findex
#: original_texis/debugging.texi:1017
#, no-wrap
msgid "testcover-start"
msgstr "testcover-start"

#. type: findex
#: original_texis/debugging.texi:1018
#, no-wrap
msgid "testcover-mark-all"
msgstr "testcover-mark-all"

#. type: findex
#: original_texis/debugging.texi:1019
#, no-wrap
msgid "testcover-next-mark"
msgstr "testcover-next-mark"

#. type: Plain text
#: original_texis/debugging.texi:1028
msgid "You can do coverage testing for a file of Lisp code by loading the @code{testcover} library and using the command @kbd{M-x testcover-start @key{RET} @var{file} @key{RET}} to instrument the code.  Then test your code by calling it one or more times.  Then use the command @kbd{M-x testcover-mark-all} to display colored highlights on the code to show where coverage is insufficient.  The command @kbd{M-x testcover-next-mark} will move point forward to the next highlighted spot."
msgstr "@code{testcover}ライブラリーをロードしてコマンド@kbd{M-x testcover-start @key{RET} @var{file} @key{RET}}でコードをインストルメントすることにより、Lispコードのファイルにたいしてカバレッジテストを行なうことができます。コードを1回以上呼び出すことによってテストが行なわれます。コマンド@kbd{M-x testcover-mark-all}を使用すれば、カバレッジが不十分な箇所が色付きでハイライト表示されます。コマンド@kbd{M-x testcover-next-mark}は次のハイライトされた箇所へポイントを前方に移動します。"

#. type: Plain text
#: original_texis/debugging.texi:1036
msgid "Normally, a red highlight indicates the form was never completely evaluated; a brown highlight means it always evaluated to the same value (meaning there has been little testing of what is done with the result).  However, the red highlight is skipped for forms that can't possibly complete their evaluation, such as @code{error}.  The brown highlight is skipped for forms that are expected to always evaluate to the same value, such as @code{(setq x 14)}."
msgstr "赤くハイライトされた箇所は通常はそのフォームが完全に評価されたことが一度もないことを示し、茶色でハイライトされた箇所は常に同じ値に評価された(その結果にたいして少ししかテストされていない)ことを意味します。しかし@code{error}のように完全に評価するのが不可能なフォームにたいしては、赤いハイライトはスキップされます。@code{(setq x 14)}のように常に同じ値に評価されることが期待されるフォームにたいしては、茶色のハイライトはスキップされます。"

#. type: Plain text
#: original_texis/debugging.texi:1039
msgid "For difficult cases, you can add do-nothing macros to your code to give advice to the test coverage tool."
msgstr "難しいケースではテストカバレッジツールにアドバイスを与えるために、コードにdo-nothingマクロを追加することができます。"

#. type: defmac
#: original_texis/debugging.texi:1040
#, no-wrap
msgid "1value form"
msgstr "1value form"

#. type: defmac
#: original_texis/debugging.texi:1043
msgid "Evaluate @var{form} and return its value, but inform coverage testing that @var{form}'s value should always be the same."
msgstr "@var{form}を評価してその値をリターンするが、テストカバレッジにたいして@var{form}が常に同じ値だという情報を与える。"

#. type: defmac
#: original_texis/debugging.texi:1045
#, no-wrap
msgid "noreturn form"
msgstr "noreturn form"

#. type: defmac
#: original_texis/debugging.texi:1048
msgid "Evaluate @var{form}, informing coverage testing that @var{form} should never return.  If it ever does return, you get a run-time error."
msgstr "@var{form}を評価して@var{form}が決してリターンしないという情報をカバレッジテストに与える。もしリターンしたらrun-timeエラーとなる。"

#. type: Plain text
#: original_texis/debugging.texi:1053
msgid "Edebug also has a coverage testing feature (@pxref{Coverage Testing}).  These features partly duplicate each other, and it would be cleaner to combine them."
msgstr "Edebugにもカバレッジテスト機能があります(@ref{Coverage Testing}を参照)。これらの機能は部分的に重複しており、組み合わせることで明確になるでしょう。"

#. type: cindex
#: original_texis/debugging.texi:1057
#, no-wrap
msgid "profiling"
msgstr "profiling"

#. type: cindex
#: original_texis/debugging.texi:1058
#, no-wrap
msgid "profile"
msgstr "profile"

#. type: cindex
#: original_texis/debugging.texi:1059
#, no-wrap
msgid "performance analysis"
msgstr "performance analysis"

#. type: cindex
#: original_texis/debugging.texi:1060
#, no-wrap
msgid "measuring resource usage"
msgstr "measuring resource usage"

#. type: cindex
#: original_texis/debugging.texi:1061
#, no-wrap
msgid "memory usage"
msgstr "memory usage"

#. type: Plain text
#: original_texis/debugging.texi:1069
msgid "If your program is working correctly, but not fast enough, and you want to make it run more quickly or efficiently, the first thing to do is @dfn{profile} your code so that you know where it spends most of the execution time.  If you find that one particular function is responsible for a significant portion of the execution time, you can start looking for ways to optimize that piece."
msgstr "プログラムは正常に機能しているものの、十分に高速ではないのでより高速かつ効率的に実行させたい場合には、そのプログラムが実行時間の大半をどこで消費しているか知るために、コードを@dfn{プロファイル(profile)}することが最初に行うべきことです。ある特定の関数の実行が実行時間のうちの無視できない割り合いを占めるようなら、その部分を最適化する方法を探すことを開始できます。"

#. type: findex
#: original_texis/debugging.texi:1070
#, no-wrap
msgid "profiler-start"
msgstr "profiler-start"

#. type: findex
#: original_texis/debugging.texi:1071
#, no-wrap
msgid "profiler-report"
msgstr "profiler-report"

#. type: findex
#: original_texis/debugging.texi:1072
#, no-wrap
msgid "profiler-stop"
msgstr "profiler-stop"

#. type: Plain text
#: original_texis/debugging.texi:1085
msgid "Emacs has built-in support for this.  To begin profiling, type @w{@kbd{M-x profiler-start}}.  You can choose to sample CPU usage periodically (@code{cpu}), when memory is allocated (@code{memory}), or both.  Then run the code you'd like to speed up.  After that, type @kbd{M-x profiler-report} to display a summary buffer for CPU usage sampled by each type (cpu and memory) that you chose to profile.  The names of the report buffers include the times at which the reports were generated, so you can generate another report later on without erasing previous results.  When you have finished profiling, type @kbd{M-x profiler-stop} (there is a small overhead associated with profiling, so we don't recommend leaving it active except when you are actually running the code you want to examine)."
msgstr "Emacsにはこのためのビルトインサポートがあります。プロファイリングを開始するには@w{@kbd{M-x profiler-start}}をタイプします。CPU使用率の定期的なサンプリング(@code{cpu}、かメモリー割り当て時(@code{memory})、またはその両方を選択できます。それから高速化したいコードを実行します。その後に@kbd{M-x profiler-report}とタイプすると、プロファイルに選択した各タイプ(cpuとmemory)によりサンプリングされたCPU使用率がsummaryバッファーに表示されます。reportバッファーの名前にはレポートが生成された時刻が含まれるので、前の結果を消去せずに後で他のレポートを生成できます。プロファイリングが終了したら@kbd{M-x profiler-stop}とタイプしてください(プロファイリングに関連したオーバーヘッドが若干あるので実際に調査したいコードの実行中以外にアクティブのままに放置することは推奨しない)。"

#. type: Plain text
#: original_texis/debugging.texi:1095
msgid "The profiler report buffer shows, on each line, a function that was called, preceded by how much CPU resources it used in absolute and percentage terms since profiling started.  If a given line has a @samp{+} symbol to the left of the function name, you can expand that line by typing @kbd{@key{RET}}, in order to see the function(s) called by the higher-level function.  Use a prefix argument (@kbd{C-u @key{RET}}) to see the whole call tree below a function.  Pressing @kbd{@key{RET}} again will collapse back to the original state."
msgstr "profiler reportバッファーでは、各行に呼び出された関数、その前にプロファイリングが開始されてから使用したCPUリソースの絶対時間とパーセンテージが表示されます。関数名の左にシンボル@samp{+}のある行では@kbd{@key{RET}}をタイプして行を展開して高位レベルの関数に呼び出された関数を確認できます。関数ツリー配下全体の呼び出しを確認するにはプレフィクス引数を使用します(@kbd{C-u @key{RET}})。もう一度@kbd{@key{RET}}をタイプすれば元の状態へと行が折り畳まれます。"

#. type: findex
#: original_texis/debugging.texi:1096
#, no-wrap
msgid "profiler-report-find-entry"
msgstr "profiler-report-find-entry"

#. type: findex
#: original_texis/debugging.texi:1097
#, no-wrap
msgid "profiler-report-describe-entry"
msgstr "profiler-report-describe-entry"

#. type: findex
#: original_texis/debugging.texi:1098
#, no-wrap
msgid "profiler-find-profile"
msgstr "profiler-find-profile"

#. type: findex
#: original_texis/debugging.texi:1099
#, no-wrap
msgid "profiler-find-profile-other-window"
msgstr "profiler-find-profile-other-window"

#. type: findex
#: original_texis/debugging.texi:1100
#, no-wrap
msgid "profiler-report-compare-profile"
msgstr "profiler-report-compare-profile"

#. type: Plain text
#: original_texis/debugging.texi:1109
msgid "Press @kbd{j} (@code{profiler-report-find-entry}) or @kbd{mouse-2} to jump to the definition of a function at point.  Press @kbd{d} (@code{profiler-report-describe-entry}) to view a function's documentation.  You can save a profile to a file using @kbd{C-x C-w} (@code{profiler-report-write-profile}) and read a saved profile with @w{@kbd{M-x profiler-find-profile}} or @w{@kbd{M-x profiler-find-profile-other-window}}.  You can compare two profiles using @kbd{=} (@code{profiler-report-compare-profile})."
msgstr "@kbd{j} (@code{profiler-report-find-entry})か@kbd{mouse-2}を押下するとポイント位置の関数の定義にジャンプします。@kbd{d} (@code{profiler-report-describe-entry})を押下すると関数のドキュメントを閲覧できます。@kbd{C-x C-w} (@code{profiler-report-write-profile})でプロファイルをファイルに保存、@w{@kbd{M-x profiler-find-profile}}や@w{@kbd{M-x profiler-find-profile-other-window}}で保存したプロファイルを読むことができます。@kbd{=} (@code{profiler-report-compare-profile})を使用すれば2つのプロファイルを比較することができます。"

#. type: file{#1}
#: original_texis/debugging.texi:1112
#, no-wrap
msgid "elp.el"
msgstr "elp.el"

#. type: cindex
#: original_texis/debugging.texi:1113
#, no-wrap
msgid "timing programs"
msgstr "timing programs"

#. type: Plain text
#: original_texis/debugging.texi:1124
msgid "The @file{elp} library offers an alternative approach, which is useful when you know in advance which Lisp function(s) you want to profile.  Using that library, you begin by setting @code{elp-function-list} to the list of function symbols---those are the functions you want to profile.  Then type @w{@kbd{M-x elp-instrument-list @key{RET} nil @key{RET}}} to arrange for profiling those functions.  After running the code you want to profile, invoke @w{@kbd{M-x elp-results}} to display the current results.  See the file @file{elp.el} for more detailed instructions.  This approach is limited to profiling functions written in Lisp, it cannot profile Emacs primitives."
msgstr "@file{elp}ライブラリーはプロファイルしたいLisp関数が事前に解っているときに有用な別のアプローチを選択肢として提供します。このライブラリーの使用するには、まず@code{elp-function-list}に関数シンボルのリスト(プロファイルしたい関数)をセットします。それから関数をプロファイル用にアレンジするために@w{@kbd{M-x elp-instrument-list @key{RET} nil @key{RET}}}とタイプします。プロファイルしたいコードの実行後に@w{@kbd{M-x elp-results}}を呼び出してカレント結果を表示します。処理手順の詳細については@file{elp.el}ファイルを参照してください。このアプローチはLispで記述された関数のプロファイリングに限定されており、Emacsプリミティブのプロファイルはできません。 "

#. type: file{#1}
#: original_texis/debugging.texi:1125
#, no-wrap
msgid "benchmark.el"
msgstr "benchmark.el"

#. type: cindex
#: original_texis/debugging.texi:1126
#, no-wrap
msgid "benchmarking"
msgstr "benchmarking"

#. type: Plain text
#: original_texis/debugging.texi:1133
msgid "You can measure the time it takes to evaluate individual Emacs Lisp forms using the @file{benchmark} library.  See the function @code{benchmark-call} as well as the macros @code{benchmark-run}, @code{benchmark-run-compiled}, and @code{benchmark-progn} in @file{benchmark.el}.  You can also use the @code{benchmark} command for timing forms interactively."
msgstr "@file{benchmark}ライブラリーを使用して個々のEmacs Lispフォームの評価に消費される時間を計測できます。@file{benchmark.el}内の関数@code{benchmark-call}、同様にマクロ@code{benchmark-run}と@code{benchmark-run-compiled}、@code{benchmark-progn}を参照してください。フォームをインタラクティブに時間計測するために@code{benchmark}コマンドも使用できます。"

#. type: cindex
#: original_texis/debugging.texi:1136
#, no-wrap
msgid "--enable-profiling option of configure"
msgstr "--enable-profiling option of configure"

#. type: ifnottex
#: original_texis/debugging.texi:1143
msgid "To profile Emacs at the level of its C code, you can build it using the @option{--enable-profiling} option of @command{configure}.  When Emacs exits, it generates a file @file{gmon.out} that you can examine using the @command{gprof} utility.  This feature is mainly useful for debugging Emacs.  It actually stops the Lisp-level @kbd{M-x profiler-@dots{}} commands described above from working."
msgstr "@command{configure}のオプションに@option{--enable-profiling}を使用してビルドすることにより、EmacsをCコードのレベルでプロファイルすることができます。こうしてビルドされたEmacsは、Emacsをexitするときに@command{gprof}ユーティリティを使用して検証できるファイル@file{gmon.out}を生成します。この機能は主にEmacsのデバッグに有用です。このEmacsは実行状態から上述の@kbd{M-x profiler-@dots{}}コマンドによりLispレベルで実際にストップします。"
