From fb72912a0392fa1f31b02bce0b4549be9cc5ee00 Mon Sep 17 00:00:00 2001
From: m-kirihara <sfaddmki-git@yahoo.co.jp>
Date: Thu, 10 Aug 2023 18:24:18 +0900
Subject: [PATCH 01/14] =?UTF-8?q?typo:=20@code{\"SS\"}=E3=80=82=E2=86=92@c?=
 =?UTF-8?q?ode{\"i\\u0307\"}=20(=E2=80=A6)=E3=80=82=EF=BC=8C(@code{\\\"i\\?=
 =?UTF-8?q?\\u0307\\\"}=E2=86=92@code{\"i\\u0307\"})?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

emacs-28ブランチ，emacs-29ブランチへの修正はバックスラッシュが多いと思います．
---
 lispref/nonascii.texi.po | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lispref/nonascii.texi.po b/lispref/nonascii.texi.po
index 61a3dfee..a7faace6 100644
--- a/lispref/nonascii.texi.po
+++ b/lispref/nonascii.texi.po
@@ -1030,7 +1030,7 @@ msgstr "special-lowercase"
 #. type: table
 #: original_texis/nonascii.texi:642
 msgid "Corresponds to Unicode language- and context-independent special lower-casing rules.  The value of this property is a string (which may be empty).  For example mapping for U+0130 @sc{latin capital letter i with dot above} the value is @code{\"i\\u0307\"} (i.e. 2-character string consisting of @sc{latin small letter i} followed by U+0307 @sc{combining dot above}).  For characters with no special mapping, the value is @code{nil} which means @code{lowercase} property needs to be consulted instead."
-msgstr "Unicodeの言語やコンテキストに依存しない特別な小文字caseルールに対応する。このプロパティの値は文字列(空も可)。たとえばU+0130 @sc{latin capital letter i with dot above}にたいするマッピングは@code{\"SS\"}。特別なマッピングのない文字にたいする値は@code{nil} (かわりに@code{lowercase}プロパティの照会が必要なことを意味する)。"
+msgstr "Unicodeの言語やコンテキストに依存しない特別な小文字caseルールに対応する。このプロパティの値は文字列(空も可)。たとえばU+0130 @sc{latin capital letter i with dot above}にたいするマッピングは@code{\"i\\u0307\"} (すなわち@sc{latin small letter i}の後にU+0307 @sc{combining dot above}が続くことによって構成される2文字の文字列)。特別なマッピングのない文字にたいする値は@code{nil} (かわりに@code{lowercase}プロパティの照会が必要なことを意味する)。"
 
 #. type: item
 #: original_texis/nonascii.texi:643

From 2e3ce8f32bbac4bd33ca4b305282bb1472e2e940 Mon Sep 17 00:00:00 2001
From: m-kirihara <sfaddmki-git@yahoo.co.jp>
Date: Thu, 10 Aug 2023 18:28:19 +0900
Subject: [PATCH 02/14] =?UTF-8?q?typo:=20=E3=83=8F=E2=86=92=E3=81=AF?=
 =?UTF-8?q?=EF=BC=8C=E3=83=8B=E2=86=92=E3=81=AB?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

「は」の置換はemacs-28ブランチ，emacs-29ブランチでも忘れています．
---
 lispref/objects.texi.po | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lispref/objects.texi.po b/lispref/objects.texi.po
index b59973ad..d89107a8 100644
--- a/lispref/objects.texi.po
+++ b/lispref/objects.texi.po
@@ -2420,7 +2420,7 @@ msgstr "primitive function"
 #. type: Plain text
 #: original_texis/objects.texi:1413
 msgid "A @dfn{primitive function} is a function callable from Lisp but written in the C programming language.  Primitive functions are also called @dfn{subrs} or @dfn{built-in functions}.  (The word ``subr'' is derived from ``subroutine''.)  Most primitive functions evaluate all their arguments when they are called.  A primitive function that does not evaluate all its arguments is called a @dfn{special form} (@pxref{Special Forms})."
-msgstr "@dfn{プリミティブ関数(primitive function)}とは、Cプログラミング言語で記述されたLispから呼び出せる関数です。プリミティブ関数は@dfn{subrs}や@dfn{ビルトイン関数(built-in functions)}とも呼ばれます(単語``subr''は``サブルーチン(subroutine)''が由来)。ほとんどのプリミティブ関数ハ、呼び出されたときニすべての引数を評価します。すべての引数を評価しないプリミティブ関数は@dfn{スペシャルフォーム(special form)}と呼ばれます(@ref{Special Forms}を参照)。"
+msgstr "@dfn{プリミティブ関数(primitive function)}とは、Cプログラミング言語で記述されたLispから呼び出せる関数です。プリミティブ関数は@dfn{subrs}や@dfn{ビルトイン関数(built-in functions)}とも呼ばれます(単語``subr''は``サブルーチン(subroutine)''が由来)。ほとんどのプリミティブ関数は、呼び出されたときにすべての引数を評価します。すべての引数を評価しないプリミティブ関数は@dfn{スペシャルフォーム(special form)}と呼ばれます(@ref{Special Forms}を参照)。"
 
 #. type: Plain text
 #: original_texis/objects.texi:1421

From eed14dc97f8ae7118e3529d975017f29745b21d7 Mon Sep 17 00:00:00 2001
From: m-kirihara <sfaddmki-git@yahoo.co.jp>
Date: Thu, 10 Aug 2023 18:31:31 +0900
Subject: [PATCH 03/14] =?UTF-8?q?typo:=20=E3=80=8C=E3=81=9F=E3=81=A8?=
 =?UTF-8?q?=E3=81=88=E3=81=B0=E3=80=8D=E6=8C=BF=E5=85=A5=EF=BC=8C=E3=81=A7?=
 =?UTF-8?q?=E2=86=92=E3=81=A7=E3=81=82=E3=82=8A=EF=BC=8C(=E3=81=9F?=
 =?UTF-8?q?=E3=81=84=E3=81=97=E3=81=A6=E3=80=82=E2=86=92=E3=81=9F=E3=81=84?=
 =?UTF-8?q?=E3=81=97=E3=81=A6=E3=80=81)?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

emacs-28ブランチ，emacs-29ブランチへの変更と同じですが，それらのブランチでは「たいして。」のように句点への誤変換があります．
---
 lispref/objects.texi.po | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lispref/objects.texi.po b/lispref/objects.texi.po
index d89107a8..b4b77fa3 100644
--- a/lispref/objects.texi.po
+++ b/lispref/objects.texi.po
@@ -2737,7 +2737,7 @@ msgstr "@dfn{バッファー(buffer)}とは、編集されるテキストを保
 #. type: Plain text
 #: original_texis/objects.texi:1567
 msgid "The contents of a buffer are much like a string, but buffers are not used like strings in Emacs Lisp, and the available operations are different.  For example, you can insert text efficiently into an existing buffer, altering the buffer's contents, whereas inserting text into a string requires concatenating substrings, and the result is an entirely new string object."
-msgstr "バッファーの内容は文字列によく似ていますが、バッファーはEmacs Lispの文字列と同じようには使用されず、利用可能な操作は異なります。文字列にテキストを挿入するためには部分文字列の結合が必要で、結果は完全に新しい文字列オブジェクトなのるのにたいして、バッファーでは既存のバッファーに効率的にテキストを挿入してバッファーの内容を変更できます。"
+msgstr "バッファーの内容は文字列によく似ていますが、バッファーはEmacs Lispの文字列と同じようには使用されず、利用可能な操作は異なります。たとえば文字列にテキストを挿入するためには部分文字列の結合が必要であり、結果は完全に新しい文字列オブジェクトなのるのにたいして、バッファーでは既存のバッファーに効率的にテキストを挿入してバッファーの内容を変更できます。"
 
 #. type: Plain text
 #: original_texis/objects.texi:1571

From 1be7a431499ccc394dfea1f4f033602ec168c26f Mon Sep 17 00:00:00 2001
From: m-kirihara <sfaddmki-git@yahoo.co.jp>
Date: Thu, 10 Aug 2023 18:35:04 +0900
Subject: [PATCH 04/14] =?UTF-8?q?typo:=20=E5=85=88=E9=A0=AD=E2=86=92?=
 =?UTF-8?q?=E7=B5=82=E7=AB=AF=EF=BC=8C@samp{\\(}=E2=86=92@samp{\\)}?=
 =?UTF-8?q?=EF=BC=8C@samp{\\(=3F:}=E5=89=8A=E9=99=A4?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

二つの@samp{…}の修正はemacs-28ブランチにもemacs-29ブランチにもありません．
---
 lispref/searching.texi.po | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lispref/searching.texi.po b/lispref/searching.texi.po
index f3f04d0f..c7e486fa 100644
--- a/lispref/searching.texi.po
+++ b/lispref/searching.texi.po
@@ -885,7 +885,7 @@ msgstr "バッファーではなく文字列とマッチする際には、@samp{
 #. type: table
 #: original_texis/searching.texi:524
 msgid "For historical compatibility reasons, @samp{$} can be used only at the end of the regular expression, or before @samp{\\)} or @samp{\\|}."
-msgstr "歴史的な互換性という理由により@samp{$}は正規表現の先頭、または@samp{\\(}、@samp{\\(?:}、@samp{\\|}の前でのみ使用できる。"
+msgstr "歴史的な互換性という理由により@samp{$}は正規表現の終端、または@samp{\\)}、@samp{\\|}の前でのみ使用できる。"
 
 #. type: samp{#1}
 #: original_texis/searching.texi:525

From b3057c081502a92f1e5c47995fbcc3421b7ea39a Mon Sep 17 00:00:00 2001
From: m-kirihara <sfaddmki-git@yahoo.co.jp>
Date: Thu, 10 Aug 2023 18:40:15 +0900
Subject: [PATCH 05/14] =?UTF-8?q?=E3=80=8C{\\=3D`}=E3=81=AF@samp{`}?=
 =?UTF-8?q?=E3=80=81=E3=80=8D=E3=81=AE=E8=BF=BD=E5=8A=A0?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

「@samp{\\=`}」への余分なバックスラッシュの削除と「@samp{`}、@samp{\\=\\[}」にある読点の追加がemacs-28ブランチには必要です．(つまり正しくは，emacs-29ブランチの記述と同じになります．)
---
 lispref/help.texi.po | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lispref/help.texi.po b/lispref/help.texi.po
index 2911388c..9a0bd2fa 100644
--- a/lispref/help.texi.po
+++ b/lispref/help.texi.po
@@ -732,7 +732,7 @@ msgstr "\\="
 #. type: table
 #: original_texis/help.texi:368
 msgid "quotes the following character and is discarded; thus, @samp{\\=`} puts @samp{`} into the output, @samp{\\=\\[} puts @samp{\\[} into the output, and @samp{\\=\\=} puts @samp{\\=} into the output."
-msgstr "これは後続の文字をクォートして無効にする。したがって@samp{\\=\\[}は@samp{\\[}、@samp{\\=\\=}は@samp{\\=}を出力する。"
+msgstr "これは後続の文字をクォートして無効にする。したがって@samp{\\=`}は@samp{`}、@samp{\\=\\[}は@samp{\\[}、@samp{\\=\\=}は@samp{\\=}を出力する。"
 
 #. type: item
 #: original_texis/help.texi:369

From da3f1f27c22e2f56d05163cd03ac41f13744c803 Mon Sep 17 00:00:00 2001
From: m-kirihara <sfaddmki-git@yahoo.co.jp>
Date: Thu, 10 Aug 2023 18:43:35 +0900
Subject: [PATCH 06/14] =?UTF-8?q?@samp{\\\\}=E2=86=92@samp{\\}=EF=BC=8C@sa?=
 =?UTF-8?q?mp{=3F\\\\(}=E2=86=92@samp{=3F\\(}?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

emacs-28ブランチ，emacs-29ブランチへの変更と同じです．
---
 lispref/objects.texi.po | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lispref/objects.texi.po b/lispref/objects.texi.po
index b4b77fa3..7eece7c6 100644
--- a/lispref/objects.texi.po
+++ b/lispref/objects.texi.po
@@ -960,7 +960,7 @@ msgstr "?Q @result{} 81     ?q @result{} 113\n"
 #. type: Plain text
 #: original_texis/objects.texi:377
 msgid "You can use the same syntax for punctuation characters.  However, if the punctuation character has a special syntactic meaning in Lisp, you must quote it with a @samp{\\}.  For example, @samp{?\\(} is the way to write the open-paren character.  Likewise, if the character is @samp{\\}, you must use a second @samp{\\} to quote it: @samp{?\\\\}."
-msgstr "区切り文字(punctuation characters)にも同じ構文を使用できますが、区切り文字がLispで特別な意味をもつ場合には@samp{\\\\}でクォートしなければなりません。たとえば@samp{?\\\\(}が開カッコを記述する方法であり、同様に文字が@samp{\\}なら、@samp{?\\\\}のようにクォートするために2つ目の@samp{\\}を使用しなければなりません。"
+msgstr "区切り文字(punctuation characters)にも同じ構文を使用できますが、区切り文字がLispで特別な意味をもつ場合には@samp{\\}でクォートしなければなりません。たとえば@samp{?\\(}が開カッコを記述する方法であり、同様に文字が@samp{\\}なら、@samp{?\\\\}のようにクォートするために2つ目の@samp{\\}を使用しなければなりません。"
 
 #. type: cindex
 #: original_texis/objects.texi:378

From 9f38a472272c9dd13d1e8fbe97c8aa568fad837e Mon Sep 17 00:00:00 2001
From: m-kirihara <sfaddmki-git@yahoo.co.jp>
Date: Thu, 10 Aug 2023 18:49:07 +0900
Subject: [PATCH 07/14] =?UTF-8?q?=E3=80=8C=E3=81=A9=E3=81=A1=E3=82=89?=
 =?UTF-8?q?=E3=82=82=E6=95=B4=E6=95=B0=E3=81=A7=E3=81=82=E3=82=8B=E3=81=8B?=
 =?UTF-8?q?=E3=81=A9=E3=81=A1=E3=82=89=E3=82=82=E6=B5=AE=E5=8B=95=E5=B0=8F?=
 =?UTF-8?q?=E6=95=B0=E3=81=A7=E3=81=82=E3=82=8B=E3=81=8B=E3=80=8D=E3=81=B8?=
 =?UTF-8?q?=E3=81=AE=E4=BF=AE=E6=AD=A3=EF=BC=8C=E3=80=8C=E3=81=AF=E3=80=81?=
 =?UTF-8?q?=E3=80=8D=E5=89=8A=E9=99=A4=EF=BC=8C=E3=80=8C(=E8=A8=B3?=
 =?UTF-8?q?=E6=B3=A8:=E5=90=8C=E3=81=98=E5=80=A4=E3=81=AE=E5=A0=B4?=
 =?UTF-8?q?=E5=90=88=E3=81=AB=E3=81=AF)=E3=80=8D=E3=81=AE=E8=BF=BD?=
 =?UTF-8?q?=E8=A8=98?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

emacs-28ブランチ，emacs-29ブランチへの変更と同じです．
---
 lispref/numbers.texi.po | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lispref/numbers.texi.po b/lispref/numbers.texi.po
index 3b6dac61..d531d028 100644
--- a/lispref/numbers.texi.po
+++ b/lispref/numbers.texi.po
@@ -810,7 +810,7 @@ msgstr "Emacs Lispでは2つのfixnumが数値的に等しければ同一のLisp
 #. type: Plain text
 #: original_texis/numbers.texi:428
 msgid "Sometimes it is useful to compare numbers with @code{eql} or @code{equal}, which treat two numbers as equal if they have the same data type (both integers, or both floating point) and the same value.  By contrast, @code{=} can treat an integer and a floating-point number as equal.  @xref{Equality Predicates}."
-msgstr "数の比較において、2つの数が同じデータ型(どちらも整数か浮動小数)では、同じ値の場合は等しい数として扱う@code{eql}や@code{equal}のほうが便利なときもあります。対照的に@code{=}は整数と浮動小数点数を等しい数と扱うことができます。@ref{Equality Predicates}を参照してください。"
+msgstr "数の比較において、2つの数が同じデータ型(どちらも整数であるかどちらも浮動小数であるか)で同じ値の場合は等しい数として扱う@code{eql}や@code{equal}のほうが便利なときもあります。対照的に@code{=}は整数と浮動小数点数を(訳注:同じ値の場合には)等しい数と扱うことができます。@ref{Equality Predicates}を参照してください。"
 
 #. type: Plain text
 #: original_texis/numbers.texi:433

From ec6e7428548e9c46949ef34bd97e15d6f3200f14 Mon Sep 17 00:00:00 2001
From: m-kirihara <sfaddmki-git@yahoo.co.jp>
Date: Thu, 10 Aug 2023 18:53:11 +0900
Subject: [PATCH 08/14] =?UTF-8?q?=E3=81=88=E3=81=8A=E2=86=92=E3=81=AE?=
 =?UTF-8?q?=EF=BC=8Ccomma=E5=89=8A=E9=99=A4=EF=BC=8C=E3=81=8C=E5=B0=8F?=
 =?UTF-8?q?=E3=81=95=E3=81=84=E6=95=B4=E6=95=B0=E3=81=AF=E2=86=92=E3=82=88?=
 =?UTF-8?q?=E3=82=8A=E5=B0=8F=E3=81=95=E3=81=84=E6=95=B4=E6=95=B0=E3=81=AE?=
 =?UTF-8?q?=E6=99=82=E3=81=AF?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

emacs-28ブランチ，emacs-29ブランチへの変更と同じです．
---
 lispref/numbers.texi.po | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/lispref/numbers.texi.po b/lispref/numbers.texi.po
index d531d028..e6d4f096 100644
--- a/lispref/numbers.texi.po
+++ b/lispref/numbers.texi.po
@@ -459,23 +459,23 @@ msgstr "integer-width"
 #. type: defvar
 #: original_texis/numbers.texi:204
 msgid "The value of this variable is a nonnegative integer that controls whether Emacs signals a range error when a large integer would be calculated.  Integers with absolute values less than"
-msgstr "この変数の値は大きな整数えお計算時にEmacsが範囲エラー(range error)をシグナルするかどうかを制御する負ではない整数。絶対値が"
+msgstr "この変数の値は大きな整数の計算時にEmacsが範囲エラー(range error)をシグナルするかどうかを制御する負ではない整数。絶対値が"
 
 #. type: ifnottex
 #: original_texis/numbers.texi:206
 msgid "2**@var{n},"
-msgstr "2**@var{n},"
+msgstr "2**@var{n}"
 
 #. type: tex
 #: original_texis/numbers.texi:209
 #, no-wrap
 msgid "@math{2^{n}},\n"
-msgstr "@math{2^{n}},\n"
+msgstr "@math{2^{n}}\n"
 
 #. type: defvar
 #: original_texis/numbers.texi:215
 msgid "where @var{n} is this variable's value, do not signal a range error.  Attempts to create larger integers typically signal a range error, although there might be no signal if a larger integer can be created cheaply.  Setting this variable to a large number can be costly if a computation creates huge integers."
-msgstr "(@var{n}はこの変数の値)が小さい整数は範囲エラーをシグナルしない。大きい整数を簡単に作成できればエラーがシグナルされない場合もあるが、通常は大きな整数の作成を試みると範囲エラーをシグナルする。この変数に大きな数値を設定すると、巨大な整数の計算にコストを要する可能性がある。"
+msgstr "(@var{n}はこの変数の値)より小さい整数の時は範囲エラーをシグナルしない。大きい整数を簡単に作成できればエラーがシグナルされない場合もあるが、通常は大きな整数の作成を試みると範囲エラーをシグナルする。この変数に大きな数値を設定すると、巨大な整数の計算にコストを要する可能性がある。"
 
 #. type: section
 #: original_texis/numbers.texi:218

From 2e0d76c968a171fe38b6614766f4f70e02f227bb Mon Sep 17 00:00:00 2001
From: m-kirihara <sfaddmki-git@yahoo.co.jp>
Date: Thu, 10 Aug 2023 18:59:39 +0900
Subject: [PATCH 09/14] =?UTF-8?q?numberl=E2=86=92number=EF=BC=8C=E6=95=B4?=
 =?UTF-8?q?=E6=95=B0=E2=86=92=E8=B2=A0=E3=81=A7=E3=81=AA=E3=81=84?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

emacs-28ブランチ，emacs-29ブランチへの変更と同じです．
---
 lispref/numbers.texi.po | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lispref/numbers.texi.po b/lispref/numbers.texi.po
index e6d4f096..54beee24 100644
--- a/lispref/numbers.texi.po
+++ b/lispref/numbers.texi.po
@@ -756,7 +756,7 @@ msgstr "natural numbers"
 #. type: defun
 #: original_texis/numbers.texi:386
 msgid "This predicate (whose name comes from the phrase ``natural number'')  tests to see whether its argument is a nonnegative integer, and returns @code{t} if so, @code{nil} otherwise.  0 is considered non-negative."
-msgstr "この述語は引数が正の整数かどうかをテストしてもしそうなら@code{t}、それ以外は@code{nil}をリターンする(名前は``natural numberl: 自然数''が由来)。0は整数と判断される。"
+msgstr "この述語は引数が正の整数かどうかをテストしてもしそうなら@code{t}、それ以外は@code{nil}をリターンする(名前は``natural number: 自然数''が由来)。0は負でないと判断される。"
 
 #. type: findex
 #: original_texis/numbers.texi:387

From a9a1bf17f7d6c0347a7efb810bf2c5d7fc1325d5 Mon Sep 17 00:00:00 2001
From: m-kirihara <sfaddmki-git@yahoo.co.jp>
Date: Thu, 10 Aug 2023 19:03:01 +0900
Subject: [PATCH 10/14] =?UTF-8?q?=E3=80=8C=E3=82=92=E3=80=8D=E8=BF=BD?=
 =?UTF-8?q?=E8=A8=98=E3=80=8C=E4=B8=8B=E6=96=B9=E3=80=8D=E5=89=8A=E9=99=A4?=
 =?UTF-8?q?=E3=80=8C=E3=81=9D=E3=81=AE=E3=80=8D=E8=BF=BD=E8=A8=98=EF=BC=8C?=
 =?UTF-8?q?=E3=80=8C=E5=85=88=E8=A1=8C=E3=83=93=E3=83=83=E3=83=88=E3=81=AF?=
 =?UTF-8?q?=E2=80=A6=E4=B8=B8=E3=82=81=E3=82=89=E3=82=8C=E3=82=8B=E3=80=82?=
 =?UTF-8?q?=E3=80=8D=E2=86=92=E3=80=8C=E5=85=88=E9=A0=AD=E3=83=93=E3=83=83?=
 =?UTF-8?q?=E3=83=88=E3=81=AF=E2=80=A6=E7=AD=89=E4=BE=A1=E3=81=A7=E3=81=82?=
 =?UTF-8?q?=E3=82=8B=E3=80=82=E3=80=8D?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

emacs-28ブランチ，emacs-29ブランチへの変更と同じです．
---
 lispref/numbers.texi.po | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/lispref/numbers.texi.po b/lispref/numbers.texi.po
index 54beee24..04978339 100644
--- a/lispref/numbers.texi.po
+++ b/lispref/numbers.texi.po
@@ -1704,12 +1704,12 @@ msgstr "@math{2^{count}}\n"
 #. type: defun
 #: original_texis/numbers.texi:894
 msgid "and then converts the result to an integer by rounding downward, toward minus infinity."
-msgstr "乗じてから下方、負の無限大に向かって丸めることにより結果を変換する。"
+msgstr "を乗じてから、負の無限大に向かって丸めることによりその結果を変換する。"
 
 #. type: defun
 #: original_texis/numbers.texi:901
 msgid "Here are examples of @code{ash}, shifting a pattern of bits one place to the left and to the right.  These examples show only the low-order bits of the binary pattern; leading bits all agree with the highest-order bit shown.  As you can see, shifting left by one is equivalent to multiplying by two, whereas shifting right by one is equivalent to dividing by two and then rounding toward minus infinity."
-msgstr "以下はビットパターンを1ビット左にシフトしてから右にシフトする例。この例で2進数パターンの下位ビットだけを示している。先行ビットは表示されている上位ビットにすべて一致する。確認できるように1ビットの左シフトは2を乗じて、右シフトは2で除してから負の無限大方向に丸められる。"
+msgstr "以下はビットパターンを1ビット左にシフトしてから右にシフトする例。この例で2進数パターンの下位ビットだけを示している。先頭ビットはすべて表示されている最上位ビットと一致する。ご覧のとおり1ビットの左シフトは2を乗ずること、1ビットの右シフトは2で除してから負の無限大方向に丸められることと等価である。"
 
 #. type: group
 #: original_texis/numbers.texi:909

From 0ff7b03d1e87206f2180d511f657c527dfc465b2 Mon Sep 17 00:00:00 2001
From: m-kirihara <sfaddmki-git@yahoo.co.jp>
Date: Thu, 10 Aug 2023 20:51:11 +0900
Subject: [PATCH 11/14] =?UTF-8?q?=E3=80=8C=E5=B7=A6=E3=81=AB@var{count}?=
 =?UTF-8?q?=E3=82=B7=E3=83=95=E3=83=88=E3=81=99=E3=82=8B=E3=80=8D=E2=86=92?=
 =?UTF-8?q?=E3=80=8C=E5=B7=A6=E3=81=AB=E3=82=B7=E3=83=95=E3=83=88=E3=80=81?=
 =?UTF-8?q?@var{count}=E3=81=8C=E8=B2=A0=E3=81=AA=E3=82=89=E2=80=A60?=
 =?UTF-8?q?=E3=81=8C=E5=89=B2=E3=82=8A=E5=BD=93=E3=81=A6=E3=82=89=E3=82=8C?=
 =?UTF-8?q?=E3=82=8B=E3=80=8D=E5=A4=89=E6=9B=B4=EF=BC=8C=E3=80=8C@code{log?=
 =?UTF-8?q?and}=E3=81=AB=E2=80=A6=E3=81=95=E3=82=8C=E3=82=8B=E3=80=82?=
 =?UTF-8?q?=E3=80=8D=E8=BF=BD=E8=A8=98?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

emacs-28ブランチ，emacs-29ブランチへの変更と同じです．
---
 lispref/numbers.texi.po | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/lispref/numbers.texi.po b/lispref/numbers.texi.po
index 04978339..b80d3f9f 100644
--- a/lispref/numbers.texi.po
+++ b/lispref/numbers.texi.po
@@ -1825,7 +1825,7 @@ msgstr "logical shift"
 #. type: defun
 #: original_texis/numbers.texi:965
 msgid "@code{lsh}, which is an abbreviation for @dfn{logical shift}, shifts the bits in @var{integer1} to the left @var{count} places, or to the right if @var{count} is negative, bringing zeros into the vacated bits.  If @var{count} is negative, then @var{integer1} must be either a fixnum or a positive bignum, and @code{lsh} treats a negative fixnum as if it were unsigned by subtracting twice @code{most-negative-fixnum} before shifting, producing a nonnegative result.  This quirky behavior dates back to when Emacs supported only fixnums; nowadays @code{ash} is a better choice."
-msgstr "@code{lsh}は@dfn{logical shift}の略で、@var{integer1}のビットを左に@var{count}シフトする。@var{count}が負なら@var{integer1}はfixnumか正のbignumのいずれかでなければならず、@code{lsh}はシフト前に負のfixnumを@code{most-negative-fixnum}で2回減算してあたかも符号なしであるかのように非負の結果を生成する。この奇妙な振る舞いはEmacsがfixnumsだけをサポートしていた頃の振る舞いであり、現在では@code{ash}がより良い選択である。"
+msgstr "@code{lsh}は@dfn{logical shift}の略で、@var{integer1}のビットを左にシフト、@var{count}が負なら右にシフトする。シフトの際に空きとなったビットには0が割り当てられる。@var{count}が負なら@var{integer1}はfixnumか正のbignumのいずれかでなければならず、@code{lsh}はシフト前に負のfixnumを@code{most-negative-fixnum}で2回減算してあたかも符号なしであるかのように非負の結果を生成する。この奇妙な振る舞いはEmacsがfixnumsだけをサポートしていた頃の振る舞いであり、現在では@code{ash}がより良い選択である。"
 
 #. type: defun
 #: original_texis/numbers.texi:969
@@ -1896,7 +1896,7 @@ msgstr ""
 #. type: defun
 #: original_texis/numbers.texi:1013
 msgid "If @code{logand} is not passed any argument, it returns a value of @minus{}1.  This number is an identity element for @code{logand} because its binary representation consists entirely of ones.  If @code{logand} is passed just one argument, it returns that argument."
-msgstr "@code{logand}に何も引数も渡さなければ、値@minus{}1がリターンされる。@minus{}1を2進数で表すとすべてのビットが1なので、@minus{}1は@code{logand}にたいする単位元(identity element)である。"
+msgstr "@code{logand}に何も引数も渡さなければ、値@minus{}1がリターンされる。@minus{}1を2進数で表すとすべてのビットが1なので、@minus{}1は@code{logand}にたいする単位元(identity element)である。@code{logand}に渡す引数が1つだけならその引数がリターンされる。"
 
 #. type: group
 #: original_texis/numbers.texi:1017 original_texis/numbers.texi:1047

From a3507ee0894205d2ab2f304ecaa219a14e10730f Mon Sep 17 00:00:00 2001
From: m-kirihara <sfaddmki-git@yahoo.co.jp>
Date: Thu, 10 Aug 2023 22:03:13 +0900
Subject: [PATCH 12/14] =?UTF-8?q?@var{x}=E3=81=AB@var{y}=E3=82=92=E4=B9=97?=
 =?UTF-8?q?=E3=81=98=E3=81=A6=E2=86=92@var{x}=E3=81=AE@var{y}=E4=B9=97?=
 =?UTF-8?q?=E3=82=92?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

emacs-28ブランチ，emacs-29ブランチへの変更と同じです．
---
 lispref/numbers.texi.po | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lispref/numbers.texi.po b/lispref/numbers.texi.po
index b80d3f9f..97c25b0a 100644
--- a/lispref/numbers.texi.po
+++ b/lispref/numbers.texi.po
@@ -2258,7 +2258,7 @@ msgstr "expt x y"
 #. type: defun
 #: original_texis/numbers.texi:1206
 msgid "This function returns @var{x} raised to power @var{y}.  If both arguments are integers and @var{y} is nonnegative, the result is an integer; in this case, overflow signals an error, so watch out.  If @var{x} is a finite negative number and @var{y} is a finite non-integer, @code{expt} returns a NaN."
-msgstr "この関数は@var{x}に@var{y}を乗じてリターンする。引数が両方とも整数で@var{y}が非負なら結果は整数になる。この場合オーバーフローはエラーをシグナルするので注意。@var{x}が有限の負数で@var{y}が有限の非整数なら、@code{expt}はNaNをリターンする。"
+msgstr "この関数は@var{x}の@var{y}乗をリターンする。引数が両方とも整数で@var{y}が非負なら結果は整数になる。この場合オーバーフローはエラーをシグナルするので注意。@var{x}が有限の負数で@var{y}が有限の非整数なら、@code{expt}はNaNをリターンする。"
 
 #. type: defun
 #: original_texis/numbers.texi:1208

From a22ad0cf147a78b7d80589c6dfc35c8a166e4d76 Mon Sep 17 00:00:00 2001
From: m-kirihara <sfaddmki-git@yahoo.co.jp>
Date: Thu, 10 Aug 2023 22:06:15 +0900
Subject: [PATCH 13/14] =?UTF-8?q?=E3=81=AE=E3=82=AA=E3=82=A2=E3=82=B9?=
 =?UTF-8?q?=E5=BE=8C=E3=81=AB=E2=86=92=E3=82=92=E3=83=91=E3=82=B9(?=
 =?UTF-8?q?=E9=80=9A=E9=81=8E)=E3=81=97=E3=81=9F=E5=BE=8C=E3=81=AB?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

emacs-28ブランチ，emacs-29ブランチへの変更と同じです．
---
 lispref/objects.texi.po | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lispref/objects.texi.po b/lispref/objects.texi.po
index 7eece7c6..5f70931d 100644
--- a/lispref/objects.texi.po
+++ b/lispref/objects.texi.po
@@ -2507,7 +2507,7 @@ msgstr "autoloadオブジェクトは通常、シンボルの関数セルにオ
 #. type: Plain text
 #: original_texis/objects.texi:1505
 msgid "A @dfn{finalizer object} helps Lisp code clean up after objects that are no longer needed.  A finalizer holds a Lisp function object.  When a finalizer object becomes unreachable after a garbage collection pass, Emacs calls the finalizer's associated function object.  When deciding whether a finalizer is reachable, Emacs does not count references from finalizer objects themselves, allowing you to use finalizers without having to worry about accidentally capturing references to finalized objects themselves."
-msgstr "@dfn{ファイナライザーオブジェクト(finalizer object)}は、オブジェクトがもはや必要なくなった後のLispコードのクリーンアップを助けます。ファイナライザーは、Lisp関数オブジェクトを保持します。ガーベージコレクションのオアス後にファイナライザーオブジェクトが到達不能になったとき、Emacsはそのファイナライザーに関連付けられた関数オブジェクトを呼び出します。ファイナライザーの到達可否の判定時、もしかしてファイナライザーオブジェクト自身が参照を離さないのではないかと心配することなくファイナライザーを使用できるように、Emacsはファイナラーオブジェト自身からの参照は勘定しません。"
+msgstr "@dfn{ファイナライザーオブジェクト(finalizer object)}は、オブジェクトがもはや必要なくなった後のLispコードのクリーンアップを助けます。ファイナライザーは、Lisp関数オブジェクトを保持します。ガーベージコレクションをパス(通過)した後にファイナライザーオブジェクトが到達不能になったとき、Emacsはそのファイナライザーに関連付けられた関数オブジェクトを呼び出します。ファイナライザーの到達可否の判定時、もしかしてファイナライザーオブジェクト自身が参照を離さないのではないかと心配することなくファイナライザーを使用できるように、Emacsはファイナラーオブジェト自身からの参照は勘定しません。"
 
 #. type: Plain text
 #: original_texis/objects.texi:1509

From dc2fe483aee2f3525c011d006968d8fce72568b8 Mon Sep 17 00:00:00 2001
From: m-kirihara <sfaddmki-git@yahoo.co.jp>
Date: Thu, 10 Aug 2023 22:29:38 +0900
Subject: [PATCH 14/14] typo
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

emacs-28ブランチ，emacs-29ブランチへの変更と同じです．
---
 lispref/commands.texi.po  | 2 +-
 lispref/debugging.texi.po | 2 +-
 lispref/minibuf.texi.po   | 2 +-
 lispref/numbers.texi.po   | 4 ++--
 lispref/objects.texi.po   | 8 ++++----
 lispref/os.texi.po        | 2 +-
 lispref/processes.texi.po | 6 +++---
 lispref/searching.texi.po | 8 ++++----
 8 files changed, 17 insertions(+), 17 deletions(-)

diff --git a/lispref/commands.texi.po b/lispref/commands.texi.po
index d7044524..a47a8dcf 100644
--- a/lispref/commands.texi.po
+++ b/lispref/commands.texi.po
@@ -348,7 +348,7 @@ msgstr "@code{interactive-only} property"
 #. type: Plain text
 #: original_texis/commands.texi:138
 msgid "Sometimes, a function is only intended to be called interactively, never directly from Lisp.  In that case, give the function a non-@code{nil} @code{interactive-only} property, either directly or via @code{declare} (@pxref{Declare Form}).  This causes the byte compiler to warn if the command is called from Lisp.  The output of @code{describe-function} will include similar information.  The value of the property can be: a string, which the byte-compiler will use directly in its warning (it should end with a period, and not start with a capital, e.g., @code{\"use (system-name) instead.\"}); @code{t}; any other symbol, which should be an alternative function to use in Lisp code."
-msgstr "インタラクティブに呼び出されることだけを意図していて、決してLispから直接呼び出されない関数が時折あります。この場合には、直接あるいは@code{declare} (@ref{Declare Form}を参照)を通じて、その関数の@code{interactive-only}プロパティに非@code{nil}を与えます。これにより、そのコマンドがLispから呼び出されるとバイトコンパイラーが警告を発します。@code{describe-function}の出力にはこれに類似する情報が含まれます。このプロパティの値には文字列、@code{t}、または任意のシンボルを指定できます。文字列なら、それはバイトコンパイラーによる警告内で直接使用されます(最初は大文字でなくピリオドで終端される文字列であること。たとえば@code{\\\"use (system-name) instead.\\\"})。シンボルなら、それはLispコード内で使用されるかわりの関数です。"
+msgstr "インタラクティブに呼び出されることだけを意図していて、決してLispから直接呼び出されない関数が時折あります。この場合には、直接あるいは@code{declare} (@ref{Declare Form}を参照)を通じて、その関数の@code{interactive-only}プロパティに非@code{nil}を与えます。これにより、そのコマンドがLispから呼び出されるとバイトコンパイラーが警告を発します。@code{describe-function}の出力にはこれに類似する情報が含まれます。このプロパティの値には文字列、@code{t}、または任意のシンボルを指定できます。文字列なら、それはバイトコンパイラーによる警告内で直接使用されます(最初は大文字でなくピリオドで終端される文字列であること。たとえば@code{\"use (system-name) instead.\"})。シンボルなら、それはLispコード内で使用されるかわりの関数です。"
 
 #. type: Plain text
 #: original_texis/commands.texi:141
diff --git a/lispref/debugging.texi.po b/lispref/debugging.texi.po
index 7c091b11..2249ca05 100644
--- a/lispref/debugging.texi.po
+++ b/lispref/debugging.texi.po
@@ -1607,7 +1607,7 @@ msgstr "debugging invalid Lisp syntax"
 #. type: Plain text
 #: original_texis/debugging.texi:911
 msgid "The Lisp reader reports invalid syntax, but cannot say where the real problem is.  For example, the error @samp{End of file during parsing} in evaluating an expression indicates an excess of open parentheses (or square brackets).  The reader detects this imbalance at the end of the file, but it cannot figure out where the close parenthesis should have been.  Likewise, @samp{Invalid read syntax: \")\"} indicates an excess close parenthesis or missing open parenthesis, but does not say where the missing parenthesis belongs.  How, then, to find what to change?"
-msgstr "Lispリーダーは無効な構文(invalid syntax)について報告はしますが実際の問題箇所は報告しません。たとえばある式を評価中のエラー@samp{End of file during parsing}は、開カッコまたは開角カッコ(open parenthese or open square bracket)が多いことを示しています。Lispリーダーはこの不一致をファイル終端で検出しましたが、本来閉カッコがあるべき箇所を解決することはできません。同様に@samp{Invalid read syntax: \\\")\\\"}は開カッコの欠落を示していますが、欠落しているカッコが属すべき場所は告げません。ならばどうやって変更すべき箇所を探せばよいのでしょうか?"
+msgstr "Lispリーダーは無効な構文(invalid syntax)について報告はしますが実際の問題箇所は報告しません。たとえばある式を評価中のエラー@samp{End of file during parsing}は、開カッコまたは開角カッコ(open parenthese or open square bracket)が多いことを示しています。Lispリーダーはこの不一致をファイル終端で検出しましたが、本来閉カッコがあるべき箇所を解決することはできません。同様に@samp{Invalid read syntax: \")\"}は開カッコの欠落を示していますが、欠落しているカッコが属すべき場所は告げません。ならばどうやって変更すべき箇所を探せばよいのでしょうか?"
 
 #. type: Plain text
 #: original_texis/debugging.texi:917
diff --git a/lispref/minibuf.texi.po b/lispref/minibuf.texi.po
index 3951c575..632e26ef 100644
--- a/lispref/minibuf.texi.po
+++ b/lispref/minibuf.texi.po
@@ -1694,7 +1694,7 @@ msgstr "この関数はポイントの前のテキストが@var{string}、ポイ
 #. type: defun
 #: original_texis/minibuf.texi:1034
 msgid "Normally completion operates on the whole string, so for all normal collections, this will always return @code{(0 . (length @var{suffix}))}.  But more complex completion, such as completion on files, is done one field at a time.  For example, completion of @code{\"/usr/sh\"} will include @code{\"/usr/share/\"} but not @code{\"/usr/share/doc\"} even if @code{\"/usr/share/doc\"} exists.  Also @code{all-completions} on @code{\"/usr/sh\"} will not include @code{\"/usr/share/\"} but only @code{\"share/\"}.  So if @var{string} is @code{\"/usr/sh\"} and @var{suffix} is @code{\"e/doc\"}, @code{completion-boundaries} will return @w{@code{(5 . 1)}} which tells us that the @var{collection} will only return completion information that pertains to the area after @code{\"/usr/\"} and before @code{\"/doc\"}.  @code{try-completion} is not affected by nontrivial boundaries; e.g., @code{try-completion} on @code{\"/usr/sh\"} might still return @code{\"/usr/share/\"}, not @code{\"share/\"}."
-msgstr "補完は通常は文字列(string)全体に作用するので、すべての普通のコレクション(collection)にたいして、この関数は常に@code{(0 . (length @var{suffix}))}をリターンするだろう。しかしファイルにたいする補完などの、より複雑な補完は1回に1フィールド行われる。たとえばたとえ@code{\"/usr/share/doc\"}が存在しても、@code{\"/usr/sh\"}の補完に@code{\"/usr/share/\"}は含まれるが、@code{\"/usr/share/doc\"}は含まれないだろう。また@code{\"/usr/sh\"}にたいする@code{all-completions}に@code{\"/usr/share/\"}は含まれず、@code{\"share/\"}だけが含まれるだろう。@var{string}が@code{\"/usr/sh\"}、@var{suffix}が@code{\"e/doc\"}なら、@code{completion-boundaries}は@w{@code{(5 . 1)}}をリターンするだろう。これは@var{collection}が@code{\"/usr/\"}の後ろにあり@code{\"/doc\"}の前にある領域に関する補完情報だけをリターンするであろうことを告げている。@code{try-completion}は意味のある境界に影響されない。すなわち@code{\\\"/usr/sh\\\"}にたいして@code{try-completion}は@code{\\\"share/\\\"}ではなく、依然として@code{\\\"/usr/share/\\\"}をリターンする。"
+msgstr "補完は通常は文字列(string)全体に作用するので、すべての普通のコレクション(collection)にたいして、この関数は常に@code{(0 . (length @var{suffix}))}をリターンするだろう。しかしファイルにたいする補完などの、より複雑な補完は1回に1フィールド行われる。たとえばたとえ@code{\"/usr/share/doc\"}が存在しても、@code{\"/usr/sh\"}の補完に@code{\"/usr/share/\"}は含まれるが、@code{\"/usr/share/doc\"}は含まれないだろう。また@code{\"/usr/sh\"}にたいする@code{all-completions}に@code{\"/usr/share/\"}は含まれず、@code{\"share/\"}だけが含まれるだろう。@var{string}が@code{\"/usr/sh\"}、@var{suffix}が@code{\"e/doc\"}なら、@code{completion-boundaries}は@w{@code{(5 . 1)}}をリターンするだろう。これは@var{collection}が@code{\"/usr/\"}の後ろにあり@code{\"/doc\"}の前にある領域に関する補完情報だけをリターンするであろうことを告げている。@code{try-completion}は意味のある境界に影響されない。すなわち@code{\"/usr/sh\"}にたいして@code{try-completion}は@code{\"share/\"}ではなく、依然として@code{\"/usr/share/\"}をリターンする。"
 
 #. type: Plain text
 #: original_texis/minibuf.texi:1039
diff --git a/lispref/numbers.texi.po b/lispref/numbers.texi.po
index 97c25b0a..b03b9d71 100644
--- a/lispref/numbers.texi.po
+++ b/lispref/numbers.texi.po
@@ -649,7 +649,7 @@ msgstr "logb x"
 #. type: defun
 #: original_texis/numbers.texi:331
 msgid "This function returns the binary exponent of @var{x}.  More precisely, if @var{x} is finite and nonzero, the value is the logarithm base 2 of @math{|x|}, rounded down to an integer.  If @var{x} is zero or infinite, the value is infinity; if @var{x} is a NaN, the value is a NaN."
-msgstr "この関数は@var{x}の2進指数をリターンする。より正確には@var{x}が有限かつ非0なら@math{|x|}の2を底とする対数を整数に切り下げた値。@var{x}が0または無限なら値は無限大。@var{x}がNaなら値はNaN。"
+msgstr "この関数は@var{x}の2進指数をリターンする。より正確には@var{x}が有限かつ非0なら@math{|x|}の2を底とする対数を整数に切り下げた値。@var{x}が0または無限なら値は無限大。@var{x}がNaNなら値はNaN。"
 
 #. type: example
 #: original_texis/numbers.texi:339
@@ -1666,7 +1666,7 @@ msgstr "logical arithmetic"
 #. type: Plain text
 #: original_texis/numbers.texi:876
 msgid "In a computer, an integer is represented as a binary number, a sequence of @dfn{bits} (digits which are either zero or one).  Conceptually the bit sequence is infinite on the left, with the most-significant bits being all zeros or all ones.  A bitwise operation acts on the individual bits of such a sequence.  For example, @dfn{shifting} moves the whole sequence left or right one or more places, reproducing the same pattern moved over."
-msgstr "コンピューターの中では、整数は@dfn{ビット(bit: 0か1の数字)}のシーケンスである2進数で表されます。ビットシーケンスは概念的には最上位ビットがすべて0か1であるような左側に無限なシ0ケンスです。ビット演算はそのようなシーケンスの中の個々のビットに作用します。たとえば@dfn{シフト(shifting)}はシーケンス全体を1つ以上左または右に移動して、移動されたのと同じパターンを再現します。"
+msgstr "コンピューターの中では、整数は@dfn{ビット(bit: 0か1の数字)}のシーケンスである2進数で表されます。ビットシーケンスは概念的には最上位ビットがすべて0か1であるような左側に無限なシーケンスです。ビット演算はそのようなシーケンスの中の個々のビットに作用します。たとえば@dfn{シフト(shifting)}はシーケンス全体を1つ以上左または右に移動して、移動されたのと同じパターンを再現します。"
 
 #. type: Plain text
 #: original_texis/numbers.texi:878
diff --git a/lispref/objects.texi.po b/lispref/objects.texi.po
index 5f70931d..f2044143 100644
--- a/lispref/objects.texi.po
+++ b/lispref/objects.texi.po
@@ -1301,7 +1301,7 @@ msgstr "2**7"
 #. type: Plain text
 #: original_texis/objects.texi:575
 msgid "bit attached to an @acronym{ASCII} character indicates a meta character; thus, the meta characters that can fit in a string have codes in the range from 128 to 255, and are the meta versions of the ordinary @acronym{ASCII} characters.  @xref{Strings of Events}, for details about @key{META}-handling in strings."
-msgstr "ビットが付加されます。したがって文字列に含めることができるメタ文字のコードは1から255の範囲となり、メタ文字は通常の@acronym{ASCII}文字のメタ修飾されたバージョンとなります。文字列内での@key{META}処理の詳細については、@ref{Strings of Events}を参照してください。"
+msgstr "ビットが付加されます。したがって文字列に含めることができるメタ文字のコードは128から255の範囲となり、メタ文字は通常の@acronym{ASCII}文字のメタ修飾されたバージョンとなります。文字列内での@key{META}処理の詳細については、@ref{Strings of Events}を参照してください。"
 
 #. type: Plain text
 #: original_texis/objects.texi:582
@@ -2135,7 +2135,7 @@ msgstr "Non-@acronym{ASCII} Characters in Strings"
 #. type: Plain text
 #: original_texis/objects.texi:1142
 msgid "There are two text representations for non-@acronym{ASCII} characters in Emacs strings: multibyte and unibyte (@pxref{Text Representations}).  Roughly speaking, unibyte strings store raw bytes, while multibyte strings store human-readable text.  Each character in a unibyte string is a byte, i.e., its value is between 0 and 255.  By contrast, each character in a multibyte string may have a value between 0 to 4194303 (@pxref{Character Type}).  In both cases, characters above 127 are non-@acronym{ASCII}."
-msgstr "Emacdの文字列内の非@acronym{ASCII}文字にたいしては2つのテキスト表現 --- マルチバイト(multibyte)とユニバイト(unibyte)があります(@ref{Text Representations}を参照)。大まかに言うとユニバイト文字列にはraw(生)バイトが保存され、マルチバイト文字列には人間が読めるテキストが保存されます。ユニバイト文字列内の各文字はバイトであり、値は0から255となります。対照的にマルチバイト文字列内の各文字は、0から4194303の値をもつかもしれません(@ref{Character Type}を参照)。いずれも127より上の文字は非@acronym{ASCII}です。"
+msgstr "Emacsの文字列内の非@acronym{ASCII}文字にたいしては2つのテキスト表現 --- マルチバイト(multibyte)とユニバイト(unibyte)があります(@ref{Text Representations}を参照)。大まかに言うとユニバイト文字列にはraw(生)バイトが保存され、マルチバイト文字列には人間が読めるテキストが保存されます。ユニバイト文字列内の各文字はバイトであり、値は0から255となります。対照的にマルチバイト文字列内の各文字は、0から4194303の値をもつかもしれません(@ref{Character Type}を参照)。いずれも127より上の文字は非@acronym{ASCII}です。"
 
 #. type: Plain text
 #: original_texis/objects.texi:1152
@@ -2323,7 +2323,7 @@ msgstr "@dfn{ブールベクター(bool-vector)}は、要素が@code{t}か@code{
 #. type: Plain text
 #: original_texis/objects.texi:1323
 msgid "The printed representation of a bool-vector is like a string, except that it begins with @samp{#&} followed by the length.  The string constant that follows actually specifies the contents of the bool-vector as a bitmap---each character in the string contains 8 bits, which specify the next 8 elements of the bool-vector (1 stands for @code{t}, and 0 for @code{nil}).  The least significant bits of the character correspond to the lowest indices in the bool-vector."
-msgstr "ブールベクターのプリント表現は文字列と似ていますが、後に長さを記述した@samp{#&}で始まります。これに続く文字列定数は、ビットマップとして実際に内容を指定するブールベクターです --- 文字列定数内のそれぞれの``文字''は8ビットを含み、これはブールベクターの次の8要素を指定します(1は@code{t}、0は@code{nil}です)。文字の最下位ビットブールベクターの最下位のインデックスに対応します。"
+msgstr "ブールベクターのプリント表現は文字列と似ていますが、後に長さを記述した@samp{#&}で始まります。これに続く文字列定数は、ビットマップとして実際に内容を指定するブールベクターです --- 文字列定数内のそれぞれの``文字''は8ビットを含み、これはブールベクターの次の8要素を指定します(1は@code{t}、0は@code{nil}です)。文字の最下位ビットが、ブールベクターの最下位のインデックスに対応しています。"
 
 #. type: example
 #: original_texis/objects.texi:1329
@@ -3897,7 +3897,7 @@ msgstr "@var{object1}と@var{object2}が同じ名前をもつシンボルなら
 #. type: defun
 #: original_texis/objects.texi:2214
 msgid "If @var{object1} and @var{object2} are numbers with differing types or values, then they cannot be the same object and @code{eq} returns @code{nil}.  If they are fixnums with the same value, then they are the same object and @code{eq} returns @code{t}.  If they were computed separately but happen to have the same value and the same non-fixnum numeric type, then they might or might not be the same object, and @code{eq} returns @code{t} or @code{nil} depending on whether the Lisp interpreter created one object or two."
-msgstr "@var{object1}と@var{object2}異なるタイプや値をもつ数値なら同じオブジェクトではなく、@code{eq}は@code{nil}をリターンする。同じ値をもつfixnumなら同じオブジェクトであり、@code{eq}は@code{t}をリターンする。別個に計算されてたまたま同じ値をもち、かつ非fixnumタイプの同じ数値型なら、それらは同じかもしれないし違うかもしれず、Lispインタープリターが作成したオブジェクトが1つか2つかに依存して@code{eq}は@code{t}か@code{nil}をリターンする。"
+msgstr "@var{object1}と@var{object2}が異なるタイプや値をもつ数値なら同じオブジェクトではなく、@code{eq}は@code{nil}をリターンする。同じ値をもつfixnumなら同じオブジェクトであり、@code{eq}は@code{t}をリターンする。別個に計算されてたまたま同じ値をもち、かつ非fixnumタイプの同じ数値型なら、それらは同じかもしれないし違うかもしれず、Lispインタープリターが作成したオブジェクトが1つか2つかに依存して@code{eq}は@code{t}か@code{nil}をリターンする。"
 
 #. type: group
 #: original_texis/objects.texi:2219
diff --git a/lispref/os.texi.po b/lispref/os.texi.po
index e499959b..93742a2b 100644
--- a/lispref/os.texi.po
+++ b/lispref/os.texi.po
@@ -2547,7 +2547,7 @@ msgstr "TZ@r{, environment variable}"
 #. type: Plain text
 #: original_texis/os.texi:1471
 msgid "The default time zone is determined by the @env{TZ} environment variable.  @xref{System Environment}.  For example, you can tell Emacs to default to Universal Time with @code{(setenv \"TZ\" \"UTC0\")}.  If @env{TZ} is not in the environment, Emacs uses system wall clock time, which is a platform-dependent default time zone."
-msgstr "デフォルトのタイムゾーンは環境変数@env{TZ}により判断されます。@ref{System Environment}を参照してください。たとえば@code{(setenv \\\"TZ\\\" \\\"UTC0\\\")}とすれば万国標準時の使用をEmacsに指示できます。その環境に@env{TZ}がなければ、Emacsはプラットフォーム依存のデフォルト時刻であるシステムの実時間(system wall clock time)を使用します。"
+msgstr "デフォルトのタイムゾーンは環境変数@env{TZ}により判断されます。@ref{System Environment}を参照してください。たとえば@code{(setenv \"TZ\" \"UTC0\")}とすれば万国標準時の使用をEmacsに指示できます。その環境に@env{TZ}がなければ、Emacsはプラットフォーム依存のデフォルト時刻であるシステムの実時間(system wall clock time)を使用します。"
 
 #. type: Plain text
 #: original_texis/os.texi:1480
diff --git a/lispref/processes.texi.po b/lispref/processes.texi.po
index dc902f75..efb8d845 100644
--- a/lispref/processes.texi.po
+++ b/lispref/processes.texi.po
@@ -4062,7 +4062,7 @@ msgstr "@var{buffer}引数はその接続に関連付けるバッファー。そ
 #. type: defun
 #: original_texis/processes.texi:2579
 msgid "The arguments @var{host} and @var{service} specify where to connect to; @var{host} is the host name (a string), and @var{service} is the name of a defined network service (a string) or a port number (an integer like @code{80} or an integer string like @code{\"80\"})."
-msgstr "引数@var{host}と@var{service}は接続先を指定する。@var{host}はホスト名(文字列)、@var{service}は定義済みのネットワークサービス名(文字列)、またはポート番号(@code{80}のような整数か@code{\\\"80\\\"}のような整数文字列)。"
+msgstr "引数@var{host}と@var{service}は接続先を指定する。@var{host}はホスト名(文字列)、@var{service}は定義済みのネットワークサービス名(文字列)、またはポート番号(@code{80}のような整数か@code{\"80\"}のような整数文字列)。"
 
 #. type: defun
 #: original_texis/processes.texi:2582
@@ -4506,7 +4506,7 @@ msgstr ":service @var{service}"
 #. type: table
 #: original_texis/processes.texi:2838
 msgid "@var{service} specifies a port number to connect to; or, for a server, the port number to listen on.  It should be a service name like @samp{\"https\"} that translates to a port number, or an integer like @samp{443} or an integer string like @samp{\"443\"} that specifies the port number directly.  For a server, it can also be @code{t}, which means to let the system select an unused port number."
-msgstr "@var{service}は接続先のポート番号、またはサーバーにたいしてはlistenするポート番号である。これは@samp{\"https\"}のようにポート番号に変換されるようなサービス名、または直接ポート番号を指定する@samp{4430}のような整数か@samp{\\\"443\\\"}のような整数文字列であること。サーバーにたいしては@code{t}も指定でき、これは未使用のポート番号をシステムに選択させることを意味する。"
+msgstr "@var{service}は接続先のポート番号、またはサーバーにたいしてはlistenするポート番号である。これは@samp{\"https\"}のようにポート番号に変換されるようなサービス名、または直接ポート番号を指定する@samp{443}のような整数か@samp{\"443\"}のような整数文字列であること。サーバーにたいしては@code{t}も指定でき、これは未使用のポート番号をシステムに選択させることを意味する。"
 
 #. type: item
 #: original_texis/processes.texi:2839
@@ -5099,7 +5099,7 @@ msgstr "この関数はネットワークアドレスのLisp表現を文字列
 #. type: defun
 #: original_texis/processes.texi:3199
 msgid "A five-element vector @code{[@var{a} @var{b} @var{c} @var{d} @var{p}]} represents an IPv4 address @var{a}.@var{b}.@var{c}.@var{d} and port number @var{p}.  @code{format-network-address} converts that to the string @code{\"@var{a}.@var{b}.@var{c}.@var{d}:@var{p}\"}."
-msgstr "5要素のベクター@code{[@var{a} @var{b} @var{c} @var{d} @var{p}]}はIPv4アドレス@var{a}.@var{b}.@var{c}.@var{d}、およびポート番号@var{p}を表す。@code{format-network-address}はこれを文字列@code{\\\"@var{a}.@var{b}.@var{c}.@var{d}:@var{p}\\\"}に変換する。"
+msgstr "5要素のベクター@code{[@var{a} @var{b} @var{c} @var{d} @var{p}]}はIPv4アドレス@var{a}.@var{b}.@var{c}.@var{d}、およびポート番号@var{p}を表す。@code{format-network-address}はこれを文字列@code{\"@var{a}.@var{b}.@var{c}.@var{d}:@var{p}\"}に変換する。"
 
 #. type: defun
 #: original_texis/processes.texi:3205
diff --git a/lispref/searching.texi.po b/lispref/searching.texi.po
index c7e486fa..10a39f12 100644
--- a/lispref/searching.texi.po
+++ b/lispref/searching.texi.po
@@ -778,7 +778,7 @@ msgstr "ある種の文字候補は、たとえそれらがEmacs内において
 #. type: enumerate
 #: original_texis/searching.texi:458
 msgid "Although a range's bound can be almost any character, it is better style to stay within natural sequences of ASCII letters and digits because most people have not memorized character code tables.  For example, @samp{[.-9]} is less clear than @samp{[./0-9]}, and @samp{[`-~]} is less clear than @samp{[`a-z@{|@}~]}.  Unicode character escapes can help here; for example, for most programmers @samp{[ก-ฺ฿-๛]} is less clear than @samp{[\\u0E01-\\u0E3A\\u0E3F-\\u0E5B]}."
-msgstr "ほとんどすべての文字を範囲の境界にできるとはいえ、文字コードテーブルを記憶している人はほとんどいないので、ASCII文字や数字の自然な順序を守るほうがよいスタイルである。たとえば@samp{[.-9]}は@samp{[./0-9]}、@samp{[`-~]}は@samp{[`a-z@{|@}~]}より明確さに劣る。ここではUnicodeの文字エスケープが助けとなる。たとえばほとんどのプログラマーにとっては@samp{[ก-ฺ฿-๛]}より@samp{[\\\\u0E01-\\\\u0E3A\\\\u0E3F-\\\\u0E5B]}のほうが明確だろう。"
+msgstr "ほとんどすべての文字を範囲の境界にできるとはいえ、文字コードテーブルを記憶している人はほとんどいないので、ASCII文字や数字の自然な順序を守るほうがよいスタイルである。たとえば@samp{[.-9]}は@samp{[./0-9]}、@samp{[`-~]}は@samp{[`a-z@{|@}~]}より明確さに劣る。ここではUnicodeの文字エスケープが助けとなる。たとえばほとんどのプログラマーにとっては@samp{[ก-ฺ฿-๛]}より@samp{[\\u0E01-\\u0E3A\\u0E3F-\\u0E5B]}のほうが明確だろう。"
 
 #. type: enumerate
 #: original_texis/searching.texi:463
@@ -912,7 +912,7 @@ msgstr "@samp{\\}はスペシャル文字をクォートするので@samp{\\$}
 #. type: table
 #: original_texis/searching.texi:541
 msgid "Note that @samp{\\} also has special meaning in the read syntax of Lisp strings (@pxref{String Type}), and must be quoted with @samp{\\}.  For example, the regular expression that matches the @samp{\\} character is @samp{\\\\}.  To write a Lisp string that contains the characters @samp{\\\\}, Lisp syntax requires you to quote each @samp{\\} with another @samp{\\}.  Therefore, the read syntax for a regular expression matching @samp{\\} is @code{\"\\\\\\\\\"}."
-msgstr "@samp{\\}はLisp文字列(@ref{String Type}を参照)の入力構文(read syntax)内でも特別な意味をもち、@samp{\\}でクォートしなければならないことに注意。たとえば文字@samp{\\}にマッチする正規表現は@samp{\\\\}。文字@samp{\\\\}を含むLisp文字列を記述するには、別の@samp{\\\\}で@samp{\\\\}をクォートすることをLisp構文は要求する。したがって@samp{\\}にマッチする正規表現にたいする入力構文は@code{\"\\\\\\\\\"}となる。"
+msgstr "@samp{\\}はLisp文字列(@ref{String Type}を参照)の入力構文(read syntax)内でも特別な意味をもち、@samp{\\}でクォートしなければならないことに注意。たとえば文字@samp{\\}にマッチする正規表現は@samp{\\\\}。文字@samp{\\\\}を含むLisp文字列を記述するには、別の@samp{\\}で@samp{\\}をクォートすることをLisp構文は要求する。したがって@samp{\\}にマッチする正規表現にたいする入力構文は@code{\"\\\\\\\\\"}となる。"
 
 #. type: Plain text
 #: original_texis/searching.texi:549
@@ -3564,7 +3564,7 @@ msgstr "rx-to-string rx-expr &optional no-group"
 #. type: defun
 #: original_texis/searching.texi:1575
 msgid "Translate @var{rx-expr} to a string regexp which is returned.  If @var{no-group} is absent or nil, bracket the result in a non-capturing group, @samp{\\(?:@dots{}\\)}, if necessary to ensure that a postfix operator appended to it will apply to the whole expression.  Example:"
-msgstr "@var{rx-expr}をリターンされる文字列regexpに変換する。@var{no-group}が省略またはnilの場合には、後に付加する後置演算子が式全体に適用されるために、必要なら結果を非キャプチャリンググループ@samp{\\\\(?:@dots{}\\\\)}としてカッコで括る。たとえば:"
+msgstr "@var{rx-expr}をリターンされる文字列regexpに変換する。@var{no-group}が省略またはnilの場合には、後に付加する後置演算子が式全体に適用されるために、必要なら結果を非キャプチャリンググループ@samp{\\(?:@dots{}\\)}としてカッコで括る。たとえば:"
 
 #. type: group
 #: original_texis/searching.texi:1580
@@ -3946,7 +3946,7 @@ msgstr "非@code{nil}"
 #. type: table
 #: original_texis/searching.texi:1837
 msgid "The resulting regexp is surrounded by @samp{\\(} and @samp{\\)}."
-msgstr "結果となるregexpは@samp{\\\\(}と@samp{\\\\)}で括られる。"
+msgstr "結果となるregexpは@samp{\\(}と@samp{\\)}で括られる。"
 
 #. type: code{#1}
 #: original_texis/searching.texi:1838 original_texis/searching.texi:1994
